pCur -> pPtr = 0 ; <NEW_LINE>
CHAR_LEN_TABLE ( ISO2022JPCharLenTable ) , <NEW_LINE>
return ( SkipDXTMipmaps ( image , dds_info , 8 , exception ) ) ; <NEW_LINE>
<NEW_LINE>
<NEW_LINE>For image rotations , the optimized versions have a lazy antialiasing for <NEW_LINE>
ClearTextRun ( nsnull ) ; <NEW_LINE>
ippSetString ( job -> attrs , & attr , 0 , con -> username ) ; <NEW_LINE>
AutoPushJSContext cx ( scriptContext -> GetNativeContext ( ) ) ; <NEW_LINE>
nsCOMPtr < nsIDOMWindow > window = do_QueryInterface ( GetScopeObject ( ) ) ; <NEW_LINE>nsCOMPtr < nsPIDOMWindow > pwin = do_QueryInterface ( window ) ; <NEW_LINE>NS_ENSURE_TRUE ( pwin , NS_OK ) ; <NEW_LINE>NS_ASSERTION ( pwin -> IsInnerWindow ( ) , "Should have inner window here ! " ) ; <NEW_LINE>NS_ENSURE_TRUE ( pwin -> GetOuterWindow ( ) && <NEW_LINE>pwin -> GetOuterWindow ( ) -> GetCurrentInnerWindow ( ) == pwin , <NEW_LINE>NS_OK ) ; <NEW_LINE>
CWD_API realpath_cache_bucket * realpath_cache_lookup ( const char * path , size_t path_len , time_t t ) <NEW_LINE>
MOZ_ASSERT ( cx == nsContentUtils::GetCurrentJSContext ( ) ) ; <NEW_LINE>
<NEW_LINE>
return mutt_bcache_del ( bcache , cache_id ( id ) ) ; <NEW_LINE>
vp9_coeff_probs_model * const probs = cm -> fc -> coef_probs [ tx_size ] ; <NEW_LINE>
return MakeUsing ( sk_calloc_canfail , info , rowBytes ) ; <NEW_LINE>
if ( ! InstCast ( aNPP ) -> CallPStreamNotifyConstructor ( <NEW_LINE>sn , url , NullableString ( aTarget ) , false , nsCString ( ) , false , & err ) ) { <NEW_LINE>NS_RUNTIMEABORT ( "StreamNotify constructor failed" ) ; <NEW_LINE> } <NEW_LINE>
if ( dstOffset > SIZE_MAX - 4 || <NEW_LINE>dstOffset + 4 > SIZE_MAX - nalLength || <NEW_LINE>dstOffset + 4 + nalLength > ( * buffer ) -> size ( ) ) { <NEW_LINE> ( * buffer ) -> release ( ) ; <NEW_LINE> ( * buffer ) = NULL ; <NEW_LINE>if ( decryptedDrmBuffer . data ) { <NEW_LINE>delete [ ] decryptedDrmBuffer . data ; <NEW_LINE>decryptedDrmBuffer . data = NULL ; <NEW_LINE> } <NEW_LINE>return ERROR_MALFORMED ; <NEW_LINE> } <NEW_LINE>
return ERROR_INV_SLICE_HDR_T ; <NEW_LINE>
in [ 0 ] = _mm_loadu_si128 ( ( const __m128i * ) ( input ) ) ; <NEW_LINE>in [ 1 ] = _mm_loadu_si128 ( ( const __m128i * ) ( input + 8 ) ) ; <NEW_LINE>
if ( len < 0 || len > MAX_RDS_PS_NAME ) { <NEW_LINE>
GenerateGetTypedArrayElement ( cx , masm , attacher , tarr , idval , object ( ) , index ( ) , output ( ) , <NEW_LINE>allowDoubleResult ( ) ) ; <NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_GRAY_TO_RGB ) != 0 ) <NEW_LINE>
key = ssplit ( term , " = " , & value ) ; <NEW_LINE>
set_and_cost_bmi_mvs ( cpi , x , xd , i , this_mode , mode_mv [ this_mode ] , <NEW_LINE>frame_mv , seg_mvs [ i ] , bsi -> ref_mv , <NEW_LINE>x -> nmvjointcost , x -> mvcost ) ; <NEW_LINE>
static int <NEW_LINE>
CanvasUtils::DoDrawImageSecurityCheck ( HTMLCanvasElement ( ) , principal , forceWriteOnly ) ; <NEW_LINE>
<NEW_LINE>if ( ! inDocument ( ) && ! isInShadowTree ( ) && ! node . isContainerNode ( ) ) <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>
#define ROUND_POWER_OF_TWO ( value , n ) \ <NEW_LINE> ( ( ( value ) + ( 1 << ( ( n ) - 1 ) ) ) >> ( n ) ) <NEW_LINE><NEW_LINE>#define ALIGN_POWER_OF_TWO ( value , n ) \ <NEW_LINE> ( ( ( value ) + ( ( 1 << ( n ) ) - 1 ) ) & ~ ( ( 1 << ( n ) ) - 1 ) ) <NEW_LINE><NEW_LINE>#if CONFIG_VP9_HIGHBITDEPTH <NEW_LINE>#define CONVERT_TO_SHORTPTR ( x ) ( ( uint16_t * ) ( ( ( uintptr_t ) x ) << 1 ) ) <NEW_LINE>#define CONVERT_TO_BYTEPTR ( x ) ( ( uint8_t * ) ( ( ( uintptr_t ) x ) >> 1 ) ) <NEW_LINE>#endif <NEW_LINE><NEW_LINE>
ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <NEW_LINE> & ps_codec -> s_parse . s_bitstrm , <NEW_LINE>slice_qp , <NEW_LINE>cabac_init_idc , <NEW_LINE> & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; <NEW_LINE>if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) <NEW_LINE> { <NEW_LINE>ps_codec -> i4_slice_error = 1 ; <NEW_LINE>end_of_slice_flag = 1 ; <NEW_LINE>ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; <NEW_LINE> } <NEW_LINE>
CallbackWrapper * callbacks ) <NEW_LINE>
const IPCThreadState * ipc = IPCThreadState::self ( ) ; <NEW_LINE>const pid_t pid = ipc -> getCallingPid ( ) ; <NEW_LINE>const uid_t uid = ipc -> getCallingUid ( ) ; <NEW_LINE>if ( ( uid != AID_SHELL ) <NEW_LINE> && ! PermissionCache::checkPermission ( String16 ( <NEW_LINE>"android . permission . DUMP" ) , pid , uid ) ) { <NEW_LINE>result . appendFormat ( "Permission Denial: can't dump BufferQueueConsumer " <NEW_LINE>"from pid = % d , uid = % d\n" , pid , uid ) ; <NEW_LINE> } else { <NEW_LINE>mCore -> dump ( result , prefix ) ; <NEW_LINE> } <NEW_LINE>
if ( ( id == 0x0F43B675 ) || ( id == 0x0C53BB6B ) ) { <NEW_LINE>
while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) && <NEW_LINE> ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) <NEW_LINE>
int test_main ( int argc , char * argv [ ] ) ;
memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ; <NEW_LINE>
PopulateWithStartingAfter ( mElements [ count - 1 ] , nsnull , elementsToAppend ) ; <NEW_LINE>
Parser parser ( cx , principals , originPrincipals , callerFrame ) ; <NEW_LINE>
#endif <NEW_LINE>
onReset ( ) ; <NEW_LINE>
} else { <NEW_LINE>for ( i = 0 ; i < r / 2 ; i ++ ) { <NEW_LINE>sc_path_t tmppath ; <NEW_LINE><NEW_LINE>memset ( & tmppath , 0 , sizeof ( tmppath ) ) ; <NEW_LINE>memcpy ( & tmppath , & path , sizeof ( path ) ) ; <NEW_LINE>memcpy ( tmppath . value + tmppath . len , files + 2 * i , 2 ) ; <NEW_LINE>tmppath . len += 2 ; <NEW_LINE>enum_dir ( tmppath , depth + 1 ) ; <NEW_LINE> } <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>void InitContentSecurityPolicy ( <NEW_LINE>ContentSecurityPolicy * = nullptr , <NEW_LINE>const ContentSecurityPolicy * policy_to_inherit = nullptr ) ; <NEW_LINE>
SearchProvider ( AutocompleteProviderListener * listener , Profile * profile ) ; <NEW_LINE>
prevType ( ) == JitFrame_Unwound_BaselineStub || <NEW_LINE>prevType ( ) == JitFrame_Entry ) ; <NEW_LINE>
<NEW_LINE>
const struct nfsd4_layout_ops * ops ; <NEW_LINE>
if ( png_rtran_ok ( png_ptr , 0 ) == 0 ) <NEW_LINE>
already_AddRefed < nsISVGPoint > GetItem ( uint32_t index , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE>already_AddRefed < nsISVGPoint > IndexedGetter ( uint32_t index , bool & found , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE>
RenderInline * isolatedInline = toRenderInline ( highestContainingIsolateWithinRoot ( startObj , currentRoot ) ) ; <NEW_LINE>ASSERT ( isolatedInline ) ; <NEW_LINE>
return InternalLoad ( errorPageURI , nullptr , nullptr , mozilla::net::RP_Default , <NEW_LINE>
void SkipAtRule ( ) ; <NEW_LINE>
if ( aNeedsCxPush && ! pusher . Push ( cx ) ) { <NEW_LINE>
#line 6162 "dcraw / dcraw . c" <NEW_LINE>
{ <NEW_LINE>nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>mFrameConstructor -> ProcessPendingRestyles ( ) ; <NEW_LINE> } <NEW_LINE>
InitialShapeEntry::getLookup ( ) const <NEW_LINE>
int i_index = ( i * 2 * tk -> i_frame_size / tk -> i_coded_frame_size ) + y ; <NEW_LINE>if ( i_index >= tk -> i_subpackets ) <NEW_LINE>return ; <NEW_LINE><NEW_LINE>
good = ~ 0U ; <NEW_LINE>
<NEW_LINE>if ( ! ( js_CodeSpec [ pn -> pn_op ] . format & JOF_SET ) ) <NEW_LINE>pn -> pn_op = JSOP_SETNAME ; <NEW_LINE>
1 , regs , regs -> cp0_badvaddr ) ;
if ( ! ValidateValue ( m_anSofHorzSampFact_Hi [ nCompIdent ] , 1 , 4 , _T ( "Horizontal Sampling Factor < Hi > " ) , true , 1 ) ) return DECMARK_ERR ; if ( ! ValidateValue ( m_anSofVertSampFact_Vi [ nCompIdent ] , 1 , 4 , _T ( "Vertical Sampling Factor < Vi > " ) , true , 1 ) ) return DECMARK_ERR ;
cx = JSContextForPluginInstance ( reinterpret_cast < nsIPluginInstance * > ( mJavaClient ) ) ; <NEW_LINE>if ( ! cx ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>AutoPushJSContext autopush ( securitySupports , cx ) ; <NEW_LINE>if ( NS_FAILED ( autopush . ResultOfPush ( ) ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>
TEMP_FAILURE_RETRY ( recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ) ; <NEW_LINE>
return ret_value ; <NEW_LINE>
FlushPendingReflows ( ) ; <NEW_LINE>if ( ! mStyleContextHolder ) { <NEW_LINE>return NS_ERROR_NOT_AVAILABLE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>const nsStyleDisplay * display = GetStyleDisplay ( ) ; <NEW_LINE>
static void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <NEW_LINE>
RPCAP_MSG_FINDALLIF_REPLY , nif , replylen ) ; <NEW_LINE>
static void copyMultiCh8 ( short * dst , const int * src [ FLACParser::kMaxChannels ] , unsigned nSamples , unsigned nChannels ) <NEW_LINE>
NS_SUCCEEDED ( URIInheritsSecurityContext ( aURI , & inherits ) ) && <NEW_LINE>inherits ) { <NEW_LINE>
memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <NEW_LINE>
<NEW_LINE>
fp -> thisp = ( JSObject * ) state . nativeVp [ 1 ] ; <NEW_LINE>fp -> argc = state . nativeVpLen - 2 ; <NEW_LINE>fp -> argv = state . nativeVp + 2 ; <NEW_LINE>
if ( content -> Tag ( ) == nsGkAtoms::object && <NEW_LINE> ! content -> HasAttr ( kNameSpaceID_None , nsGkAtoms::src ) && <NEW_LINE>content -> GetAttr ( kNameSpaceID_None , nsGkAtoms::data , data ) && <NEW_LINE>
delete [ ] frames_ ; <NEW_LINE>
while ( first && first -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
PHP_FUNCTION ( locale_get_display_script ) <NEW_LINE>
for_each_leaf_cfs_rq ( rq , cfs_rq ) { <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , sfar ) ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
JSObject * NewOutObject ( JSContext * cx , JSObject * scope ) ; <NEW_LINE>
script_resource -> CalculateAccessControlStatus ( <NEW_LINE>fetcher_ -> Context ( ) . GetSecurityOrigin ( ) ) ) ; <NEW_LINE>
IDBObjectStore::ClearCloneReadInfo ( mCloneReadInfo ) ; <NEW_LINE>
#line 819 "ext / standard / var_unserializer . c" <NEW_LINE>
<NEW_LINE>
fp = iter . interpFrame ( ) ; <NEW_LINE>
AutoPushJSContext cx ( ctxNew -> GetNativeContext ( ) ) ; <NEW_LINE>
if ( safe_mount ( console -> name , lxcpath , "none" , MS_BIND , 0 , rootfs -> mount ) ) { <NEW_LINE>
if ( isspace ( ( unsigned char ) * s ) ) <NEW_LINE>
if ( alternative -> m_minimumSize > priorAlternative -> m_minimumSize ) { <NEW_LINE>add32 ( Imm32 ( alternative -> m_minimumSize - priorAlternative -> m_minimumSize ) , index ) ; <NEW_LINE>op . m_jumps . append ( jumpIfNoAvailableInput ( ) ) ; <NEW_LINE> } else if ( priorAlternative -> m_minimumSize > alternative -> m_minimumSize ) <NEW_LINE>sub32 ( Imm32 ( priorAlternative -> m_minimumSize - alternative -> m_minimumSize ) , index ) ; <NEW_LINE>
JS::MutableHandle < JSObject * > aObject , <NEW_LINE>JS::MutableHandle < JSScript * > aTableScript , <NEW_LINE>
virtual void TabDetachedAt ( content::WebContents * contents , <NEW_LINE>int index ) OVERRIDE ; <NEW_LINE>
int sse_diff = 0 ; <NEW_LINE><NEW_LINE>const int zero_bias = denoiser -> denoise_pars . denoise_mv_bias ; <NEW_LINE>zero_mv_sse = ( unsigned int ) ( ( int64_t ) zero_mv_sse * zero_bias / 100 ) ; <NEW_LINE>sse_diff = zero_mv_sse - best_sse ; <NEW_LINE>
void ScrollTo ( const gfx::Vector2d & new_value ) ; <NEW_LINE>
return ! capable_wrt_inode_uidgid ( inode , CAP_FOWNER ) ; <NEW_LINE>
if ( curr -> renderer ( ) -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
const vpx_prob vp9_kf_y_mode_prob [ INTRA_MODES ] [ INTRA_MODES ] [ INTRA_MODES - 1 ] = { <NEW_LINE>
PHPAPI void php_clear_stat_cache ( zend_bool clear_realpath_cache , const char * filename , size_t filename_len ) <NEW_LINE>
* q ++ = ' ' ; <NEW_LINE>
if ( ! e ) { <NEW_LINE>strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; <NEW_LINE>the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>if ( cm -> last_frame_seg_map && ! cm -> frame_parallel_decode ) <NEW_LINE>memset ( cm -> last_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; <NEW_LINE><NEW_LINE>if ( cm -> current_frame_seg_map ) <NEW_LINE>memset ( cm -> current_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; <NEW_LINE>
if ( isOutOfFlowPositioned ( ) ) <NEW_LINE>
img = ctx -> iface -> dec . get_frame ( get_alg_priv ( ctx ) , iter ) ; <NEW_LINE>
d . lengthAndFlags = buildLengthAndFlags ( length ( ) , NON_STATIC_ATOM_FLAGS ) ; <NEW_LINE>
PassRefPtr < DocumentFragment > createFragmentForInnerOuterHTML ( const String & , Element * , ExceptionCode & ) ; <NEW_LINE>PassRefPtr < DocumentFragment > createFragmentForTransformToFragment ( const String & , const String & sourceMIMEType , Document * outputDoc ) ; <NEW_LINE>PassRefPtr < DocumentFragment > createContextualFragment ( const String & , Element * , FragmentScriptingPermission ) ; <NEW_LINE>
@stability Evolving <NEW_LINE>
<NEW_LINE>unsigned width = static_cast < unsigned > ( input -> width ( ) ) ; <NEW_LINE>
do_init_search , cost_list , vfp , use_mvcost , <NEW_LINE>
setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , MUS_SZ , 0 ) ; <NEW_LINE>
" [ - P pkcs11_whitelist ] [ - t life ] [ command [ arg . . . ] ] \n" <NEW_LINE>
isoclns_print ( ndo , p , length ) ; <NEW_LINE>
void ResizeTransparencyBitmap ( ) ; <NEW_LINE>
ND_TCHECK ( bp [ 0 ] ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
if ( ( png_ptr -> color_type & PNG_COLOR_MASK_COLOR ) == 0 ) <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
<NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
size += <NEW_LINE>EbmlMasterElementSize ( kMkvContentEncodings , content_encodings_size ) + <NEW_LINE>content_encodings_size ; <NEW_LINE>
#line 205 "re_grammar . c" <NEW_LINE>
if ( ! runWithNextObject -> m_object -> isOutOfFlowPositioned ( ) && ! runWithNextObject -> m_box -> isLineBreak ( ) ) { <NEW_LINE>
nsCOMPtr < nsIContent > content = do_QueryReferent ( mContent ) ; <NEW_LINE>uint32_t cattrs = content -> GetAttrCount ( ) ; <NEW_LINE>
if ( ! jas_safe_size_mul3 ( cmpt -> width_ , cmpt -> height_ , cmpt -> cps_ , & size ) ) { <NEW_LINE>
CheckLoadURIWithPrincipal ( mNullPrincipal , attrURI , flags ) ; <NEW_LINE>
JSContext * cx = scriptContext -> GetNativeContext ( ) ; <NEW_LINE>
ND_TCHECK_24BITS ( p + 2 ) ; <NEW_LINE>
if ( ! ext_dp -> icmp_length && <NEW_LINE>ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { <NEW_LINE>
impl -> set ( key , value ) ; <NEW_LINE>
ArrayBufferView & view = aData . Value ( ) . GetAsArrayBufferView ( ) ; <NEW_LINE>view . ComputeLengthAndData ( ) ; <NEW_LINE>rv = strStream -> SetData ( reinterpret_cast < char * > ( view . Data ( ) ) , <NEW_LINE>view . Length ( ) ) ; <NEW_LINE>
bool ExitScript ( JSContext * , JSScript * , JSFunction * , bool popSPSFrame ) ; <NEW_LINE>
if ( ! js_SafeCallFunctionValue ( cx , JSVAL_TO_OBJECT ( v ) , scopeFun , <NEW_LINE>OBJECT_TO_JSVAL ( unsafeObj ) , argc , argv , <NEW_LINE>rval ) ) { <NEW_LINE>
SourceDataCache::AutoHoldEntry holder ; <NEW_LINE>const jschar * chars = lazy -> source ( ) -> chars ( cx , holder ) ; <NEW_LINE>
<NEW_LINE>if ( ec_GFp_pt_is_inf_jac ( px , py , pz ) == MP_YES || mp_cmp_z ( py ) == 0 ) { <NEW_LINE>
Directionality oldDir = eDir_NotSet ; <NEW_LINE>bool dirAffectsAncestor = ( NodeType ( ) == nsIDOMNode::TEXT_NODE && <NEW_LINE>TextNodeWillChangeDirection ( this , & oldDir , aOffset ) ) ; <NEW_LINE>
bool pending_vrdisplay_raf_ = false ; <NEW_LINE>
if ( warn != 0 ) <NEW_LINE>
GetNextToken ( q , & q , MagickPathExtent , keyword ) ; <NEW_LINE>
std::unique_ptr < TransformPaintPropertyNode > Clone ( ) const { <NEW_LINE>return base::WrapUnique ( <NEW_LINE>
if ( ( width == 0 ) || ( height == 0 ) ) <NEW_LINE>
return_ACPI_STATUS ( ReturnStatus ) ; <NEW_LINE>
PRBool isChromeDoc = IsChromeURI ( mDocumentURI ) ; <NEW_LINE><NEW_LINE>if ( isChromeDoc && aScriptProto -> mScriptObject . mObject ) { <NEW_LINE>
ushort huff [ 1024 ] , vpred [ 2 ] [ 2 ] , hpred [ 2 ] ; <NEW_LINE>
nsCString prefix ( "XUL" ) ; <NEW_LINE>
if ( webgl_version_ > kWebGL1 ) { <NEW_LINE>
<NEW_LINE>nsCSSKeyframesRule * KeyframesRuleForName ( nsPresContext * aPresContext , <NEW_LINE>const nsString & aName ) ; <NEW_LINE>
<NEW_LINE>cmd -> releaseRef ( ) ; <NEW_LINE>
<NEW_LINE>
if ( ! curr -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
if ( curr -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
nsresult WriteToDecoder ( const char * aBuffer , uint32_t aCount , DecodeStrategy aStrategy ) ; <NEW_LINE>nsresult DecodeSomeData ( uint32_t aMaxBytes , DecodeStrategy aStrategy ) ; <NEW_LINE>
count += 2 ; <NEW_LINE>bufLen - = 2 ; <NEW_LINE>
#endif <NEW_LINE>#endif <NEW_LINE>
if ( setDecodeArgs ( & s_dec_ip , & s_dec_op , inHeader , outHeader , timeStampIx ) ) { <NEW_LINE>ivdec_api_function ( mCodecCtx , ( void * ) & s_dec_ip , ( void * ) & s_dec_op ) ; <NEW_LINE> } <NEW_LINE>
OMX_BUFFERHEADERTYPE * OMXNodeInstance::findBufferHeader ( <NEW_LINE>OMX::buffer_id buffer , OMX_U32 portIndex ) { <NEW_LINE>
perform_formatting_test ( png_store * ps ) <NEW_LINE>
#include "compiler / compilerdebug . h" <NEW_LINE>
xmlGenericError , xmlGenericError , NULL ) ; <NEW_LINE>
# endif <NEW_LINE>
if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , xmi_size , 0 ) ) == 0 ) { <NEW_LINE>
RenderObject * containingBlock = isOutOfFlowPositioned ( ) ? container ( ) : this -> containingBlock ( ) ; <NEW_LINE>
nsRefPtr < BufferMediaResource > resource = <NEW_LINE>
<NEW_LINE>
PRBool didInitialReflow = PR_FALSE ; <NEW_LINE>shell -> GetDidInitialReflow ( & didInitialReflow ) ; <NEW_LINE>if ( didInitialReflow ) { <NEW_LINE><NEW_LINE><NEW_LINE>continue ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
else if ( relaxed != 0 ) <NEW_LINE>
if ( so == & slirp -> udb || so -> so_lport != uh -> uh_sport || <NEW_LINE>
nsJSUtils::ReportPendingException ( cx ) ; <NEW_LINE>
inline PRBool EnsureStringLength ( nsAString & aStr , PRUint32 aLen ) <NEW_LINE> { <NEW_LINE>aStr . SetLength ( aLen ) ; <NEW_LINE>return ( aStr . Length ( ) == aLen ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>inline PRBool EnsureStringLength ( nsACString & aStr , PRUint32 aLen ) <NEW_LINE> { <NEW_LINE>aStr . SetLength ( aLen ) ; <NEW_LINE>return ( aStr . Length ( ) == aLen ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE><NEW_LINE>
if ( ! ( obj = xpc_NewIDObject ( cx , JS_GetGlobalForScopeChain ( cx ) , * iid2 ) ) ) <NEW_LINE>
bool gestureDidScroll ( const WebCore::IntSize & ) ; <NEW_LINE>
if ( png_rtran_ok ( png_ptr , 0 ) == 0 ) <NEW_LINE>
std::lock_guard < std::recursive_mutex > lock ( local_socket_list_lock ) ; <NEW_LINE>
<NEW_LINE>if ( attr_set_level == 10 ) <NEW_LINE>ND_PRINT ( ( ndo , " ( too many nested levels , not recursing ) " ) ) ; <NEW_LINE>else if ( ! bgp_attr_print ( ndo , atype , tptr , alen , attr_set_level + 1 ) ) <NEW_LINE>
OBJ_TO_INNER_OBJECT ( cx , obj ) ; <NEW_LINE>if ( ! obj ) { <NEW_LINE>return JS_FALSE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
Context ( ) . DispatchWillSendRequest ( <NEW_LINE>identifier , resource_request , ResourceResponse ( ) , <NEW_LINE>resource -> GetType ( ) , resource -> Options ( ) . initiator_info ) ; <NEW_LINE>
if ( it . m_obj -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
serv = svc_create_pooled ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ; <NEW_LINE>
AutoPushJSContext cx ( GetJSContext ( ) ) ; <NEW_LINE>
virtual nsresult InstallMember ( JSContext * aCx , <NEW_LINE>JSObject * aTargetClassObject ) ; <NEW_LINE>
for ( k = 0 ; offset < len ; j ++ ) <NEW_LINE>
if ( ! WriteEbmlElement ( writer , kMkvSeekID , <NEW_LINE>
SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
iadst16_dspr2 ( temp_in , temp_out ) ; <NEW_LINE>
as_vmov ( VFPRegister ( dest ) . singleOverlay ( ) , VFPRegister ( src ) . singleOverlay ( ) ) ; <NEW_LINE>
5000 ) != 0 ) <NEW_LINE>
<NEW_LINE>
AutoPushJSContext cx ( GetJSContextFromNPP ( npp ) ) ; <NEW_LINE>
void FixGrayBits ( bool aForceGC ) ; <NEW_LINE>
if ( c == EOF ) <NEW_LINE>
if ( mOffsetTableLength > 0 && options && options -> getSeekTo ( & seekTimeUs , & mode ) ) { <NEW_LINE>
ALOGE ( "Too small output buffer for reference frame: % lu bytes" , <NEW_LINE> ( unsigned long ) outHeader -> nAllocLen ) ; <NEW_LINE>
const int * src [ FLACParser::kMaxChannels ] , <NEW_LINE>
SITE_IDENTITY_STATUS_MALWARE , <NEW_LINE>SITE_IDENTITY_STATUS_SOCIAL_ENGINEERING , <NEW_LINE>SITE_IDENTITY_STATUS_UNWANTED_SOFTWARE , <NEW_LINE>SITE_IDENTITY_STATUS_SIGN_IN_PASSWORD_REUSE , <NEW_LINE>SITE_IDENTITY_STATUS_ENTERPRISE_PASSWORD_REUSE , <NEW_LINE>SITE_IDENTITY_STATUS_BILLING , <NEW_LINE>
v = file_strncmp ( m -> value . s , ms -> search . s + idx , slen , <NEW_LINE>m -> str_flags ) ; <NEW_LINE>
VideoColorSpace * color_space ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>
int sent = TEMP_FAILURE_RETRY ( send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ) ; <NEW_LINE>
status = sBtInterface -> enable ( false ) ; <NEW_LINE>
memcpy ( udp , up , 4 ) ; <NEW_LINE>memcpy ( vdp , vp , 4 ) ; <NEW_LINE>
uint64 frame_timestamp_ns , bool is_key ) { <NEW_LINE>
strncpy ( rblkcipher . type , "blkcipher" , sizeof ( rblkcipher . type ) ) ; <NEW_LINE>strncpy ( rblkcipher . geniv , alg -> cra_blkcipher . geniv ? : " < default > " , <NEW_LINE>sizeof ( rblkcipher . geniv ) ) ; <NEW_LINE>
if ( containsFloats ( ) && ! isFloating ( ) && ! isOutOfFlowPositioned ( ) && ( newStyle -> position ( ) == AbsolutePosition || newStyle -> position ( ) == FixedPosition ) ) <NEW_LINE>
*
if ( curr -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
socklen_t optlen = sizeof ( optval ) ; <NEW_LINE>
vpx_decrypt_cb decrypt_cb ; <NEW_LINE>
return OffTheBooks::calloc_ ( items * size ) ; <NEW_LINE>
msg -> msg_namelen = sizeof ( * sax ) ; <NEW_LINE>
gfxFloat kernelX = aInstance -> GetPrimitiveNumber ( nsSVGUtils::X , <NEW_LINE>aKernelUnitLength , <NEW_LINE>nsSVGNumberPair::eFirst ) ; <NEW_LINE>gfxFloat kernelY = aInstance -> GetPrimitiveNumber ( nsSVGUtils::Y , <NEW_LINE>aKernelUnitLength , <NEW_LINE>nsSVGNumberPair::eSecond ) ; <NEW_LINE>
#ifndef BASE_ALLOCATOR_ALLOCATOR_EXTENSION_THUNKS_H_ <NEW_LINE>#define BASE_ALLOCATOR_ALLOCATOR_EXTENSION_THUNKS_H_ <NEW_LINE>
rv = zsocket_connect ( * sock , " % s" , info -> description ) ; <NEW_LINE>
vpx_decrypt_cb decrypt_cb ; <NEW_LINE>
status = MagickFalse ; <NEW_LINE>break ; <NEW_LINE>
aRv = manager -> GetUserMediaDevices ( mWindow , aConstraints , onsuccess , onerror , <NEW_LINE>aInnerWindowID ) ; <NEW_LINE>
FREERDP_LOCAL BOOL nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , <NEW_LINE>
nsresult nsDocShellBackwardsEnumerator::BuildArrayRecursive ( nsIDocShellTreeItem * inItem , nsTArray < nsWeakPtr > & inItemArray ) <NEW_LINE>
long num = oggpack_read ( opb , _ilog ( s -> entries - i ) ) ; <NEW_LINE>if ( num < 0 ) goto _eofout ; <NEW_LINE>for ( j = 0 ; j < num && i < s -> entries ; j ++ , i ++ ) <NEW_LINE>lengthlist [ i ] = ( char ) length ; <NEW_LINE>s -> dec_maxlength = length ; <NEW_LINE>length ++ ; <NEW_LINE>
add_proto_failed: <NEW_LINE>unregister_pernet_device ( & ipgre_net_ops ) ; <NEW_LINE>
m_proxy -> postBeginFrameAndCommitOnCCThread ( ) ; <NEW_LINE>
<NEW_LINE>
if ( map && nmap ) <NEW_LINE>cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ; <NEW_LINE>else <NEW_LINE>cp = ikev1_attr_print ( ndo , cp , ep2 ) ; <NEW_LINE>if ( cp == NULL ) <NEW_LINE>goto trunc ; <NEW_LINE>
nsHTMLParanoidFragmentSink::nsHTMLParanoidFragmentSink ( PRBool aAllContent ) : <NEW_LINE>nsHTMLFragmentContentSink ( aAllContent ) , mSkip ( PR_FALSE ) <NEW_LINE>
#include "compiler / compilerdebug . h" <NEW_LINE>
img -> stride [ VPX_PLANE_Y ] = img -> stride [ VPX_PLANE_ALPHA ] = stride_in_bytes ; <NEW_LINE>img -> stride [ VPX_PLANE_U ] = img -> stride [ VPX_PLANE_V ] = stride_in_bytes >> xcs ; <NEW_LINE>
if ( grub_errno ) { <NEW_LINE>free ( filename ) ; <NEW_LINE>
DownloadManager::shared ( ) . startDownload ( m_policyDownloadID , page ( ) , request ) ; <NEW_LINE>
rv = nsContentUtils::ASCIIToLower ( aName , lower ) ; <NEW_LINE>if ( NS_SUCCEEDED ( rv ) ) { <NEW_LINE>nameAtom = do_GetAtom ( lower ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
bool growPendingArray ( JSContext * cx ) ; <NEW_LINE>
<NEW_LINE>
<NEW_LINE>uint32_t framerate = mFramerate ? : ( 30 << 16 ) ; <NEW_LINE>frameDuration = ( uint32_t ) ( ( ( uint64_t ) 1000000 << 16 ) / framerate ) ; <NEW_LINE>
#endif <NEW_LINE>
<NEW_LINE>
ENGINE_SET_INVALID_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <NEW_LINE>
PNG_UNUSED ( png_ptr ) <NEW_LINE>return 0L ; <NEW_LINE>
static const float tonemasks [ P_BANDS ] [ 6 ] [ EHMER_MAX ] = { <NEW_LINE>
goto loser ; <NEW_LINE>
{ <NEW_LINE>pcx_colormap = ( unsigned char * ) RelinquishMagickMemory ( pcx_colormap ) ; <NEW_LINE>ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> } <NEW_LINE>
#ifdef PNG_READ_TRANSFORMS_SUPPORTED
if ( TEMP_FAILURE_RETRY ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) ) < 0 ) <NEW_LINE>
xmlBufResetInput ( input -> buf -> buffer , input ) ; <NEW_LINE>
else if ( currChild -> isFloatingOrOutOfFlowPositioned ( ) ) { <NEW_LINE>
Selection ( ) . SetSelection ( <NEW_LINE>SelectionInDOMTree::Builder ( ) . Collapse ( end_of_text ) . Build ( ) , <NEW_LINE>SetSelectionData::Builder ( ) <NEW_LINE> . SetShouldCloseTyping ( true ) <NEW_LINE> . SetShouldClearTypingStyle ( true ) <NEW_LINE> . SetShouldShowHandle ( true ) <NEW_LINE> . Build ( ) ) ; <NEW_LINE>
if ( mFrame . IsAlive ( ) && <NEW_LINE>
__android_log_print ( ANDROID_LOG_INFO , "Gecko" , " % s" , buffer . ptr ( ) ) ; <NEW_LINE>
out [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ; <NEW_LINE>
uint32 encodeable , sameOriginPrincipals ; <NEW_LINE>
mDecodingMonitor . AssertCurrentThreadIn ( ) ; <NEW_LINE>
int32 inOOMReport ; <NEW_LINE>
vpx_decrypt_cb decrypt_cb , <NEW_LINE>
if ( ! ( * pvalue ) -> mightBeType ( propertyType ) ) { <NEW_LINE><NEW_LINE><NEW_LINE>JS_ASSERT_IF ( ( * pvalue ) -> type ( ) != MIRType_Value , ( * pvalue ) -> type ( ) != propertyType ) ; <NEW_LINE>
nsresult InstallImplementation ( nsXBLPrototypeBinding * aPrototypeBinding , nsXBLBinding * aBinding ) ; <NEW_LINE>
memcpy ( dst , src , src_ybc -> uv_width ) ; <NEW_LINE>
strncpy ( rcipher . type , "cipher" , sizeof ( rcipher . type ) ) ; <NEW_LINE>
qnargv [ 0 ] = OBJECT_TO_JSVAL ( ns ) ; <NEW_LINE>
<NEW_LINE>static char * pkcs11_whitelist ; <NEW_LINE><NEW_LINE>
#define BT_SHB_INSANE_MAX 1024 * 1024 * 1 <NEW_LINE>
CHECK_PRINCIPAL_AND_DATA ( ShouldProcess ) ; <NEW_LINE>
count_segs_sb ( cm , xd , tile , & mi [ mi_dr * mis + mi_dc ] , <NEW_LINE>
RefPtr < DocumentFragment > fragment = createContextualFragment ( markup , toHTMLElement ( parent ) , AllowScriptingContent ) ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
XPC_XOW_WrapObject ( JSContext * cx , JSObject * parent , jsval * vp , <NEW_LINE>XPCWrappedNative * wn = nsnull ) ; <NEW_LINE>
major = stoi ( ssplit ( sclone ( version ) , " . " , & tok ) ) ; <NEW_LINE>minor = stoi ( ssplit ( tok , " . " , & tok ) ) ; <NEW_LINE>patch = stoi ( ssplit ( tok , " . " , & tok ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>
( char * ) in -> proc_buf_in + in_buf . frameCount * src_frame_size , <NEW_LINE>in -> proc_buf_frames * src_frame_size ) ; <NEW_LINE>
appendPsqlMetaConnect ( buf , dbname ) ; <NEW_LINE>
#define LIBXSLT_DEFAULT_PLUGINS_PATH ( ) "NULL" <NEW_LINE>
nsIContent * nonNative = content -> FindFirstNonChromeOnlyAccessContent ( ) ; <NEW_LINE>
if ( q < p || q > e ) { <NEW_LINE>
if ( XrayUtils::IsTransparent ( cx , wrapper , id ) ) { <NEW_LINE>
static nsComboboxControlFrame * sFocused ; <NEW_LINE>
FILE_RCSID ( "@ ( # ) $ File: readelf . c , v 1 . 103 2014 / 05 / 02 02:25:10 christos Exp $ " ) <NEW_LINE>
( void ) CloneString ( & draw_info -> geometry , geometry ) ; <NEW_LINE>
<NEW_LINE>
ADVANCE_BLOCK ( ) ; <NEW_LINE>
class DEVICE_BLUETOOTH_EXPORT Observer { <NEW_LINE>
StartSampling ( GetRefreshDriver ( ) ) ; <NEW_LINE>
ctx -> last_untrusted = sk_X509_num ( ctx -> chain ) ; <NEW_LINE>
static_cast < unsigned > ( input -> width ( ) ) * info . bytesPerPixel ( ) ) ; <NEW_LINE>
if ( ! doapr_outch ( sbuffer , buffer , & currlen , maxlen , ch ) ) <NEW_LINE>return 0 ; <NEW_LINE>
for ( i = 0 ; i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <NEW_LINE>
if ( diffs != 0 ) <NEW_LINE>
CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ; <NEW_LINE>
virtual void OnChannelConnected ( int32 peer_pid ) OVERRIDE ; <NEW_LINE>
FilterSetter < Policy > ( cx , wrapper , id , desc ) ; <NEW_LINE>return true ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>JPEGImageDecoder * decoder = m_decoder ; <NEW_LINE>if ( ! decoder -> outputScanlines ( ) ) { <NEW_LINE>if ( decoder -> failed ( ) ) <NEW_LINE>return false ; <NEW_LINE>
sb -> s_readonly_remount = 1 ; <NEW_LINE>smp_wmb ( ) ; <NEW_LINE>
size_t str_len = 0 ; <NEW_LINE>
if ( safe_mount ( "none" , path , "tmpfs" , 0 , "size = 100000 , mode = 755" , <NEW_LINE>rootfs -> path ? rootfs -> mount : NULL ) ) { <NEW_LINE>
int i = 0 ; <NEW_LINE>cl_int status = CL_SUCCESS ; <NEW_LINE>cl_uint numDevices = 0 ; <NEW_LINE>size_t * binarySizes = NULL ; <NEW_LINE>cl_device_id * devices = NULL ; <NEW_LINE>char ** binaries = NULL ; <NEW_LINE>char * str = NULL ; <NEW_LINE>int ret_value = 1 ; <NEW_LINE>
if ( shift != 0 ) <NEW_LINE>
memcpy ( cp , qp -> d_memory , original_length ) ; <NEW_LINE>
for ( i = 0 ; i < TTABLE_SIZE ; ++ i ) if ( transform_info [ i ] . name != NULL ) <NEW_LINE>
void * H264SwDecMalloc ( u32 size , u32 num ) ; <NEW_LINE>
info , inliningDepth_ + 1 , loopDepth_ ) ; <NEW_LINE>
SSL_SET_OPTIONS ( & mysql_connection ) ; <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>void ForgetWindow ( aura::Window * window , <NEW_LINE>bool destroyed , <NEW_LINE>bool was_in_overview = false ) ; <NEW_LINE>
<NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
<NEW_LINE>
memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <NEW_LINE>
size_t actualSize = region -> readFromMemory ( regionData , size ) ; <NEW_LINE><NEW_LINE>if ( size != actualSize ) { <NEW_LINE>delete region ; <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
memcpy ( pc -> fc . coef_probs , default_coef_probs , sizeof ( default_coef_probs ) ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
if ( start_time_ == value ) <NEW_LINE>
if ( mTree ) <NEW_LINE>mFirstRange -> Invalidate ( mTree ) ; <NEW_LINE>
void TouchEventHandler::handleTouchPoint ( const Platform::TouchPoint & point , unsigned modifiers ) <NEW_LINE>
nsCOMPtr < nsIDOMElement > elem = do_QueryReferent ( mContent ) ; <NEW_LINE>
jas_uchar * data ; <NEW_LINE>
XPCAutoRequest ar ( cx ) ; <NEW_LINE>
&& ! mTimeToSample . empty ( ) ; <NEW_LINE>
#elif defined ( __GNUC__ ) || defined ( __clang__ ) <NEW_LINE>
: PerformanceResourceTiming ( <NEW_LINE>info ? info -> FinalResponse ( ) . Url ( ) . GetString ( ) : "" , <NEW_LINE>"navigation" , <NEW_LINE>time_origin , <NEW_LINE>server_timing ) , <NEW_LINE>
#elif defined ( JAS_HAVE_GETRUSAGE ) <NEW_LINE>
<NEW_LINE>
std::unique_ptr < PropertyTreeState > local_border_box_properties ; <NEW_LINE>
nsRefPtr < HTMLMediaElement > mMediaElement ; <NEW_LINE>
<NEW_LINE>already_AddRefed < dom::SVGTransform > GetItemAt ( uint32_t aIndex ) ; <NEW_LINE>
thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride ) ; <NEW_LINE>
id = __ipv6_select_ident ( net , & addrs [ 1 ] , & addrs [ 0 ] ) ; <NEW_LINE>
for ( a = ROUNDDOWN ( uaddr , addr_incr ) ; a < end_addr ; a += addr_incr ) { <NEW_LINE>
NS_ASSERTION ( aListID == kColGroupList , "unexpected child list" ) ; <NEW_LINE>
! validated_urls_ . Contains ( request . GetResourceRequest ( ) . Url ( ) ) ) { <NEW_LINE>
if ( metadata -> data_count > metadata -> data_capacity ) { <NEW_LINE>ALOGE ( " % s: Data count ( % " PRIu32 " ) should be <= data capacity " <NEW_LINE>" ( % " PRIu32 " ) " , <NEW_LINE>__FUNCTION__ , metadata -> data_count , metadata -> data_capacity ) ; <NEW_LINE>android_errorWriteLog ( SN_EVENT_LOG_ID , "30591838" ) ; <NEW_LINE>return ERROR ; <NEW_LINE> } <NEW_LINE><NEW_LINE>const metadata_uptrdiff_t entries_end = metadata -> entries_start + metadata -> entry_capacity ; <NEW_LINE>
virtual void TabDetachedAt ( content::WebContents * contents , <NEW_LINE>int index ) OVERRIDE ; <NEW_LINE>
void SetTimeSourceForTesting ( scoped_ptr < base::TickClock > time_source ) ;
memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ; <NEW_LINE>
quantum_info = AcquireQuantumInfo ( image_info , next_image ) ; <NEW_LINE>
ENGINE_SET_INVALID_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <NEW_LINE>
png_destroy_write_struct ( & png_ptr , & info_ptr ) ; <NEW_LINE>free ( png_pixels ) ; <NEW_LINE>png_pixels = NULL ; <NEW_LINE>
daddy = safe_calloc ( sizeof ( creator_template ) ) ; <NEW_LINE>
if ( file_printf ( ms , " , too many % s ( % u ) " , name , num <NEW_LINE>
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) ) { <NEW_LINE>
vmcs_write16 ( HOST_FS_SELECTOR , 0 ) ; <NEW_LINE>vmcs_write16 ( HOST_GS_SELECTOR , 0 ) ; <NEW_LINE>
chase = t [ chase * 2 + ( ( lok >> i ) & 1 ) ] ; <NEW_LINE>if ( chase & 0x80UL ) break ; <NEW_LINE>
std::unique_ptr < TransformPaintPropertyNode > old_paint_offset_translation_ ; <NEW_LINE>
cx -> compartment -> wrap ( cx , props ) ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
QQuickWebViewPrivate::onComponentComplete ( ) ; <NEW_LINE>
@stability Stable <NEW_LINE>
AssertFlushedPendingReflows ( ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>nsresult Redirect ( nsIChannel * newChannel , PRUint32 redirectFlags , <NEW_LINE>PRBool openNewChannel ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( a > 1 . ) <NEW_LINE>return 1 . ; <NEW_LINE>else if ( a >= 0 ) <NEW_LINE>return a ; <NEW_LINE>else <NEW_LINE>return 0 ; <NEW_LINE>
NS_IF_RELEASE ( sContent ) ; <NEW_LINE>
const ScrollPaintPropertyNode * scroll = nullptr ; <NEW_LINE>
class PLATFORM_EXPORT MediaStreamSource : public RefCounted < MediaStreamSource > { <NEW_LINE>
<NEW_LINE>prev_slice_err = 2 ; <NEW_LINE>num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs <NEW_LINE> - ps_dec -> u2_total_mbs_coded ; <NEW_LINE>
b * data . blue_coefficient - 2 . / 32768 - out_qe ; <NEW_LINE>
if ( fchmod ( fileno ( fp ) , 0666 & ~ curumsk ) < 0 ) { <NEW_LINE>
* ( -- dp ) = hi_filler ; <NEW_LINE>
void reset ( C p = C ( ) ) { <NEW_LINE>
<NEW_LINE>if ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <NEW_LINE> { <NEW_LINE>FLUSH_BITS ( ps_stream -> u4_offset , ps_stream -> u4_buf , ps_stream -> u4_buf_nxt , u4_no_of_bits , ps_stream -> pu4_buf_aligned ) <NEW_LINE> } <NEW_LINE>
if ( ( existing = mprReadJsonObj ( obj , name ) ) != 0 ) { <NEW_LINE>
PRBool returnString , jsval * rval ) <NEW_LINE>
if ( ! ( com -> data = JAS_CAST ( jas_uchar * , jas_strdup ( buf ) ) ) ) { <NEW_LINE>
#endif <NEW_LINE>
} <NEW_LINE><NEW_LINE>
fMemArray = sk_malloc_throw ( fAllocCount , sizeof ( T ) ) ; <NEW_LINE>
void DrawingBufferClientRestorePixelPackParameters ( ) override { <NEW_LINE><NEW_LINE>
fi -> spoffset = - fp -> script -> nfixed ; <NEW_LINE>
#endif <NEW_LINE>#endif <NEW_LINE>#endif
if ( ! bgp_attr_print ( ndo , atype , p , alen , 0 ) ) <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
uint64 encryption_size = <NEW_LINE>EbmlElementSize ( kMkvContentEncKeyID , enc_key_id_ , enc_key_id_length_ ) ; <NEW_LINE>
# if PNG_LIBPNG_VER < 10700 <NEW_LINE>data . red_coefficient = 6968 / 32768 . ; <NEW_LINE>data . green_coefficient = 23434 / 32768 . ; <NEW_LINE>data . blue_coefficient = 2366 / 32768 . ; <NEW_LINE># else <NEW_LINE>data . red_coefficient = . 2126 ; <NEW_LINE>data . green_coefficient = . 7152 ; <NEW_LINE>data . blue_coefficient = . 0722 ; <NEW_LINE># endif <NEW_LINE>
<NEW_LINE>
last mod: $ Id $ <NEW_LINE>
nsCOMPtr < nsIDOMElement > element ; <NEW_LINE>nsCOMPtr < nsIDOMText > textNode = do_QueryInterface ( curNode ) ; <NEW_LINE>if ( textNode ) { <NEW_LINE><NEW_LINE>nsCOMPtr < nsIDOMNode > parent ; <NEW_LINE>textNode -> GetParentNode ( getter_AddRefs ( parent ) ) ; <NEW_LINE>element = do_QueryInterface ( parent ) ; <NEW_LINE> } else { <NEW_LINE>element = do_QueryInterface ( curNode ) ; <NEW_LINE> } <NEW_LINE>if ( element ) { <NEW_LINE>RelativeChangeIndentationOfElementNode ( element , - 1 ) ; <NEW_LINE> } <NEW_LINE>
void DetachTab ( content::WebContents * tab ) ; <NEW_LINE>
ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) <NEW_LINE>"Unexpected body state ( % i ) " , ( int ) ctx -> state ) ; <NEW_LINE>return APR_EGENERAL ; <NEW_LINE>
p = GetVirtualPixels ( image , 0 , y , image -> columns , 1 , & image -> exception ) ; <NEW_LINE>
if ( isa && udptlportno > 0 ) { <NEW_LINE>
inline AutoCompartment ( ExclusiveContext * cx , JSCompartment * target ) ; <NEW_LINE>
<NEW_LINE>
va_list args ) { <NEW_LINE>
void <NEW_LINE>nsSMILAnimationController::Disconnect ( ) <NEW_LINE> { <NEW_LINE>NS_ABORT_IF_FALSE ( mDocument , "disconnecting when we weren't connected . . . ? " ) ; <NEW_LINE>NS_ABORT_IF_FALSE ( mRefCnt . get ( ) == 1 , <NEW_LINE>"Expecting to disconnect when doc is sole remaining owner" ) ; <NEW_LINE><NEW_LINE>StopSampling ( GetRefreshDriverForDoc ( mDocument ) ) ; <NEW_LINE><NEW_LINE>mDocument = nsnull ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
Copyright ( c ) 2010 - 2016 , The Linux Foundation . All rights reserved . <NEW_LINE>
state -> object_nl = fstrndup ( RSTRING_PTR ( object_nl ) , len ) ; <NEW_LINE>
nsRefPtr < nsPrefetchNode > node = mCurrentNode ; <NEW_LINE>rv = node -> OpenChannel ( ) ; <NEW_LINE>
void neuter ( void * newData ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
if ( shouldBeDirty && ! alreadyDirty && markParents == MarkContainingBlockChain && ( isText ( ) || ! style ( ) -> isOutOfFlowPositioned ( ) ) ) <NEW_LINE>
rv = ProcessPseudoRowGroupFrame ( aPresContext , aPseudoFrames . mRowGroup , aHighestFrame ) ; <NEW_LINE>
goto done ; <NEW_LINE>
CreateFileHelper::CreateFileResult * result ( CreateFileHelper::CreateFileResult::create ( ) ) ; <NEW_LINE>
#include "core / html / forms / KeyboardClickableInputTypeView . h" <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
} <NEW_LINE>
rv = NS_CheckContentLoadPolicy ( nsIContentPolicy::TYPE_XSLT , <NEW_LINE>
textToDraw . Length ( ) , <NEW_LINE>isRTL ? NSBIDI_RTL : NSBIDI_LTR , <NEW_LINE>presShell -> GetPresContext ( ) , <NEW_LINE>processor , <NEW_LINE>nsBidiPresUtils::MODE_MEASURE , <NEW_LINE>nsnull , <NEW_LINE>0 , <NEW_LINE> & totalWidthCoord , <NEW_LINE> & bidiEngine ) ; <NEW_LINE>
s_canPropagateFloatIntoSibling = oldStyle ? ! isFloatingOrOutOfFlowPositioned ( ) && ! avoidsFloats ( ) : false ; <NEW_LINE>
# define UNP_RECIPROCAL ( alpha ) ( ( ( ( 0xffff * 0xff ) << 7 ) + ( alpha >> 1 ) ) / alpha ) <NEW_LINE>
txVariableItem * var = <NEW_LINE>static_cast < txVariableItem * > ( aState . popPtr ( aState . eVariableItem ) ) ; <NEW_LINE>
<NEW_LINE>
size_t cwd_skip = 0 ; <NEW_LINE>
MonitorAutoLock mon ( mMonitor ) ; <NEW_LINE>return mAudioClock . GetPositionUnlocked ( ) ; <NEW_LINE>
nsIScriptContext * scriptContext = GetContext ( ) ; <NEW_LINE>NS_ENSURE_STATE ( scriptContext ) ; <NEW_LINE><NEW_LINE>nsRefPtr < nsDOMOfflineResourceList > applicationCache = <NEW_LINE>new nsDOMOfflineResourceList ( manifestURI , uri , this , scriptContext ) ; <NEW_LINE>NS_ENSURE_TRUE ( applicationCache , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE><NEW_LINE>applicationCache -> Init ( ) ; <NEW_LINE>
virtual nsresult InstallMember ( JSContext * aCx , <NEW_LINE>JSObject * aTargetClassObject ) ; <NEW_LINE>
json_tokener_error_parse_comment , <NEW_LINE>json_tokener_error_size <NEW_LINE>
nsCOMPtr < nsIDOMElement > elem = do_QueryReferent ( mContent ) ; <NEW_LINE>
opt_use_ssl = TRUE ; <NEW_LINE>
unsigned int maxval ; <NEW_LINE>
the_url [ sizeof ( the_url ) - 1 ] = 0 ; <NEW_LINE>
while ( c != '\n' && ScanAsSpace ( c ) ) <NEW_LINE>
if ( err != 0 ) <NEW_LINE>
__u8		remote_tx_win ; <NEW_LINE>__u8		remote_max_tx ; <NEW_LINE>__u16		retrans_timeout ; <NEW_LINE>__u16		monitor_timeout ; <NEW_LINE>__u16		max_pdu_size ; <NEW_LINE><NEW_LINE>
return false ; <NEW_LINE>
static base::WeakPtr < PepperMediaDeviceManager > GetForRenderFrame ( <NEW_LINE>RenderFrame * render_frame ) ; <NEW_LINE>
return GetWebMediaPlayer ( ) ? GetWebMediaPlayer ( ) -> HasSingleSecurityOrigin ( ) <NEW_LINE>: true ; <NEW_LINE>
if ( TEMP_FAILURE_RETRY ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) ) == - 1 ) <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
nsresult rv = ScrollHorzInternal ( parts , aNewIndex ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE>
vpx_free ( img -> img_data ) ; <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
NS_IF_RELEASE ( sContent ) ; <NEW_LINE>
vpx_roi_map_t roi ; <NEW_LINE>memset ( & roi , 0 , sizeof ( roi ) ) ; <NEW_LINE>
uint32_t flags ; <NEW_LINE>
ast_variables_destroy ( headers ) ; <NEW_LINE>
if ( looks_like_pbl ( filename ) ) { <NEW_LINE>
CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ; <NEW_LINE>
#ifndef BASE_NUMERICS_SAFE_CONVERSIONS_H_ <NEW_LINE>#define BASE_NUMERICS_SAFE_CONVERSIONS_H_ <NEW_LINE>
if ( ! mProcessStyle || name != nsGkAtoms::style ) { <NEW_LINE>return NS_OK ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE> } while ( bufferSize < neededSize && bufferSize > 0 ) ; <NEW_LINE><NEW_LINE><NEW_LINE>if ( bufferSize <= 0 ) { <NEW_LINE>errorCode = XML_ERROR_NO_MEMORY ; <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
#include " . / vpx_scale_rtcd . h" <NEW_LINE>
bool WouldTaintOrigin ( ) const override { return false ; } <NEW_LINE>
uint8_t build_id_data [ 160 ] ; <NEW_LINE>if ( nhdr . n_descsz > sizeof ( build_id_data ) ) { <NEW_LINE>ALOGE ( "Possible corrupted note , desc size value is too large: % u" , <NEW_LINE>nhdr . n_descsz ) ; <NEW_LINE>
uint8 * tmp ; <NEW_LINE>
dom::Uint8ClampedArray * aArray , <NEW_LINE>
if ( end_time_ == value ) <NEW_LINE>
JS_FRIEND_API ( JSBool ) <NEW_LINE>js::DefaultValue ( JSContext * cx , HandleObject obj , JSType hint , MutableHandleValue vp ) <NEW_LINE>
nanojit::LIns * args [ ] , bool rooted ) ; <NEW_LINE>
switch ( getFileTypeNoFollowSymlinks ( path ) ) { <NEW_LINE>
rootFrame = FrameManager ( ) -> GetRootFrame ( ) ; <NEW_LINE>if ( aHeight == NS_UNCONSTRAINEDSIZE && rootFrame ) { <NEW_LINE>
msg -> fp = mutt_bcache_get ( pop_data -> bcache , cache_id ( h -> data ) ) ; <NEW_LINE>
static void calc_segtree_probs ( int * segcounts , vpx_prob * segment_tree_probs ) { <NEW_LINE>
BOOL ( * decode ) ( NSC_CONTEXT * context ) ; <NEW_LINE>BOOL ( * encode ) ( NSC_CONTEXT * context , const BYTE * BitmapData , <NEW_LINE>
<NEW_LINE>
pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , <NEW_LINE>max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ; <NEW_LINE>
else if ( png_get_PLTE ( png_ptr , info_ptr , & palette , & num_palette ) != 0 ) <NEW_LINE>
params , portIndex , false , false , NULL ) ; <NEW_LINE>
TypedObject & obj = v . toObject ( ) . as < TypedObject > ( ) ; <NEW_LINE>MOZ_ASSERT ( ! obj . owner ( ) . isNeutered ( ) ) ; <NEW_LINE>return reinterpret_cast < Elem > ( obj . typedMem ( ) ) ; <NEW_LINE>
if ( ! box -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
NS_IMPL_ISUPPORTS2 ( CSSParserImpl , nsICSSParser , nsICSSParser_1_9_2 ) <NEW_LINE>
modifier += rounding ; <NEW_LINE>
AddPendingRecompile ( cx , script_ ) ; <NEW_LINE>
if ( ! pReader ) <NEW_LINE>return E_FILE_FORMAT_INVALID ; <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
PUBLIC ssize slen ( cchar * s ) <NEW_LINE>
if ( m_isExternalScript ) { <NEW_LINE>ScriptResource * resource = m_resource ? m_resource . get ( ) : sourceCode . resource ( ) ; <NEW_LINE>if ( resource && ! resource -> mimeTypeAllowedByNosniff ( ) ) { <NEW_LINE>contextDocument -> addConsoleMessage ( SecurityMessageSource , ErrorMessageLevel , "Refused to execute script from '" + resource -> url ( ) . elidedString ( ) + "' because its MIME type ( '" + resource -> mimeType ( ) + "' ) is not executable , and strict MIME type checking is enabled . " ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
AutoPushJSContext cx ( scriptContext -> GetNativeContext ( ) ) ; <NEW_LINE>
if ( ! next -> isRenderBlock ( ) || next -> isFloatingOrOutOfFlowPositioned ( ) || toRenderBlock ( next ) -> avoidsFloats ( ) ) <NEW_LINE>
if ( ( count < 0 ) || ( p > ( datum + length - count ) ) || <NEW_LINE> ( count > ( ssize_t ) length ) ) <NEW_LINE>
const int * src [ FLACParser::kMaxChannels ] , <NEW_LINE>
<NEW_LINE>
<NEW_LINE><NEW_LINE>void ForceUpdateBackup ( ) ; <NEW_LINE>
{ Z_PACKET_STAT , 		"stat" } , <NEW_LINE> { 0 , 			NULL } <NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_STRIP_ALPHA ) != 0 ) <NEW_LINE>
if ( snprintf ( pattern , 499 , " . / test / relaxng / % s_ ? . xml" , prefix ) >= 499 ) <NEW_LINE>pattern [ 499 ] = 0 ; <NEW_LINE>
#include "third_party / blink / public / web / window_features . mojom . h" <NEW_LINE>
f . regs . setToEndOfScript ( ) ; <NEW_LINE>
JS_ReportError ( aCx , "Failed to load script ( nsresult = 0x % x ) " , aLoadResult ) ; <NEW_LINE>
static int fmtstr ( char ** , char ** , size_t * , size_t * , <NEW_LINE>const char * , int , int , int ) ; <NEW_LINE>static int fmtint ( char ** , char ** , size_t * , size_t * , <NEW_LINE>LLONG , int , int , int , int ) ; <NEW_LINE>static int fmtfp ( char ** , char ** , size_t * , size_t * , <NEW_LINE>LDOUBLE , int , int , int ) ; <NEW_LINE>static int doapr_outch ( char ** , char ** , size_t * , size_t * , int ) ; <NEW_LINE>static int _dopr ( char ** sbuffer , char ** buffer , <NEW_LINE>size_t * maxlen , size_t * retlen , int * truncated , <NEW_LINE>const char * format , va_list args ) ; <NEW_LINE>
<NEW_LINE>AutoFillCCInfoBarDelegate * cc_infobar_ ; <NEW_LINE>
<NEW_LINE>atoms = script -> atomMap . vector ; <NEW_LINE><NEW_LINE>
if ( ots::Process ( & output , aData , aLength , <NEW_LINE>gfxPlatform::GetPlatform ( ) -> PreserveOTLTablesWhenSanitizing ( ) ) ) { <NEW_LINE>
typedef js::HashMap < JSScript * , <NEW_LINE>JS::Heap < JSObject * > , <NEW_LINE>js::PointerHasher < JSScript * , 3 > , <NEW_LINE>js::SystemAllocPolicy > ThisObjectsMap ; <NEW_LINE>ThisObjectsMap mThisObjects ; <NEW_LINE>
#define ASM_REGISTER_STATE_CHECK ( statement ) do { \ <NEW_LINE>libvpx_test::RegisterStateCheck reg_check ; \ <NEW_LINE>statement ; \ <NEW_LINE>
if ( verbose != 0 ) <NEW_LINE>
void FireOnInput ( PRBool aTrusted ) ; <NEW_LINE>
for ( p = s1 ; ( p = strchr ( p , * s2 ) ) != NULL ; p ++ ) { <NEW_LINE>
void checkHeader ( ) const ; <NEW_LINE>
<NEW_LINE>if ( ( ctxt -> value -> user == NULL ) || <NEW_LINE> ( ( ( xmlLocationSetPtr ) ctxt -> value -> user ) -> locNr == 0 ) ) <NEW_LINE>return ( total ) ; <NEW_LINE><NEW_LINE>
kzalloc ( 2 * ( length + 1 ) , GFP_KERNEL ) ; <NEW_LINE>
js_InflateString ( JSContext * cx , const char * bytes , size_t * lengthp ) <NEW_LINE>
ND_TCHECK_16BITS ( p + 2 ) ; <NEW_LINE>
HP_COLOR_COLOR , <NEW_LINE>HP_COLOR_BLACK , <NEW_LINE>
<NEW_LINE>
if ( focusedContent -> ChromeOnlyAccess ( ) ) { <NEW_LINE>focusedContent = focusedContent -> FindFirstNonChromeOnlyAccessContent ( ) ; <NEW_LINE>
m . command = CMD_NONE ; <NEW_LINE>
if ( cur -> type == XML_ATTRIBUTE_NODE ) { <NEW_LINE>cur = cur -> parent ; <NEW_LINE> } else if ( cur -> type == XML_NAMESPACE_DECL ) { <NEW_LINE>xmlNsPtr ns = ( xmlNsPtr ) cur ; <NEW_LINE><NEW_LINE>if ( ( ns -> next == NULL ) || <NEW_LINE> ( ns -> next -> type == XML_NAMESPACE_DECL ) ) <NEW_LINE>return ( NULL ) ; <NEW_LINE>cur = ( xmlNodePtr ) ns -> next ; <NEW_LINE> } <NEW_LINE>
unsigned int offset = sizeof ( struct ipv6hdr ) ; <NEW_LINE>
XPCAutoRequest ar ( mContext ) ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
<NEW_LINE>
<NEW_LINE>
<NEW_LINE><NEW_LINE>void AddBrowserAction ( Extension * extension ) ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>void RemoveBrowserAction ( Extension * extension ) ;
if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) <NEW_LINE>crypt_info = NULL ; <NEW_LINE>
#endif <NEW_LINE>
guint i = 1 ; <NEW_LINE>
uint16_t numChannels = 0 , chansSpecified , chanMask = 0 ; <NEW_LINE>
SynthesizeSlowNativeFrame ( state , cx , innermost ) ; <NEW_LINE>
vpx_img_alloc ( & raw , input . fmt , input . width , input . height , 32 ) ; <NEW_LINE>
delete [ ] chunking_base_name_ ; <NEW_LINE>
if ( p_sys -> i_buffer < tk -> i_frame_size <NEW_LINE> || tk -> i_sipr_subpacket_count >= tk -> i_subpacket_h ) <NEW_LINE>
scale = adjust_scale ( scale ) ; <NEW_LINE>
DeleteImgFrame ( aFrameNum ) ; <NEW_LINE>
State state ( this ) ; <NEW_LINE>return shared . symbols . lookup ( & state , str , strlen ( str ) ) ; <NEW_LINE>
for ( j = 0 ; j < cfg -> searches_per_step ; j ++ ) { <NEW_LINE>
#endif <NEW_LINE>
-> PostTask ( <NEW_LINE>BLINK_FROM_HERE , <NEW_LINE>CrossThreadBind ( & ScriptProcessorHandler:: <NEW_LINE>FireProcessEventForOfflineAudioContext , <NEW_LINE>WrapRefPtr ( this ) , double_buffer_index_ , <NEW_LINE>CrossThreadUnretained ( waitable_event . get ( ) ) ) ) ;
if ( ! ValidateModuleName ( sModule , sRetMsg ) ) { <NEW_LINE>return nullptr ; <NEW_LINE>
if ( multiple != 0 ) <NEW_LINE>
<NEW_LINE>
ND_PRINT ( ( ndo , " % 04x: % 04x " , panid , EXTRACT_LE_16BITS ( p ) ) ) ; <NEW_LINE>
virtual status_t dump ( int fd , const Vector < String16 > & args ) ; <NEW_LINE><NEW_LINE>virtual status_t dumpClient ( int fd , const Vector < String16 > & args ) ; <NEW_LINE>
NS_HOLD_JS_OBJECTS ( this , nsDOMFileReader ) ; <NEW_LINE>
static int fit_line ( lsfit_acc * a , int fits , int * y0 , int * y1 ) { <NEW_LINE>
ND_PRINT ( ( ndo , " % s" , mldv2_tstr ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>
while ( ( ( depth >= 0 ) && ( RAW != 0 ) ) && <NEW_LINE> ( ctxt -> instate != XML_PARSER_EOF ) ) { <NEW_LINE>
if ( ret != 0 ) <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
ND_PRINT ( ( ndo , " % s" , rpl_tstr ) ) ; <NEW_LINE>
JSContext * cx = nsContentUtils::GetCurrentJSContext ( ) ;
NGBlockNode ng_input_node ; <NEW_LINE>
int get_vpx_encoder_count ( void ) { <NEW_LINE>
#ifndef BASE_TEST_TEST_REG_UTIL_WIN_H_ <NEW_LINE>#define BASE_TEST_TEST_REG_UTIL_WIN_H_
public gfx::GLSurface { <NEW_LINE>
} else if ( AccessCheck::subsumes ( target , origin ) ) {
NS_IMPL_CYCLE_COLLECTION_CLASS ( HTMLTemplateElement ) <NEW_LINE><NEW_LINE>NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED ( HTMLTemplateElement , <NEW_LINE>nsGenericHTMLElement ) <NEW_LINE>if ( tmp -> mContent ) { <NEW_LINE>tmp -> mContent -> SetHost ( nullptr ) ; <NEW_LINE>tmp -> mContent = nullptr ; <NEW_LINE> } <NEW_LINE>NS_IMPL_CYCLE_COLLECTION_UNLINK_END <NEW_LINE><NEW_LINE>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED ( HTMLTemplateElement , <NEW_LINE>nsGenericHTMLElement ) <NEW_LINE>NS_IMPL_CYCLE_COLLECTION_TRAVERSE ( mContent ) <NEW_LINE>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END <NEW_LINE>
memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; <NEW_LINE>memset ( & best_mode . mbmode , 0 , sizeof ( best_mode . mbmode ) ) ; <NEW_LINE>memset ( & best_mode . bmodes , 0 , sizeof ( best_mode . bmodes ) ) ; <NEW_LINE>
static_cast < unsigned > ( input -> width ( ) ) * info . bytesPerPixel ( ) ) ; <NEW_LINE>
if ( preserveChunk ) <NEW_LINE>preserveNextChunk = true ; <NEW_LINE>else <NEW_LINE>finishChunk = true ; <NEW_LINE>
successors_ = js_pod_calloc < uint32_t > ( numSuccessors ) ; <NEW_LINE>
for ( WillBeHeapVector < RefPtrWillBeMember < SVGSVGElement > > ::iterator itr = timeContainers . begin ( ) ; itr != end ; ++ itr ) { <NEW_LINE>SMILTimeContainer * timeContainer = ( * itr ) -> timeContainer ( ) ; <NEW_LINE>if ( ! timeContainer -> isStarted ( ) ) <NEW_LINE>timeContainer -> begin ( ) ; <NEW_LINE> } <NEW_LINE>
if ( ( length > 0 ) || <NEW_LINE> ( png_ptr -> mode & PNG_HAVE_CHUNK_AFTER_IDAT ) != 0 ) <NEW_LINE>
NS_ASSERTION ( ! mInstance || ! aInstance , "mInstance should only be set or unset ! " ) ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( mInstance && ! aInstance ) <NEW_LINE>mInstance -> InvalidateOwner ( ) ; <NEW_LINE>
if ( png_ptr != NULL && info_ptr != NULL && <NEW_LINE> ( info_ptr -> valid & PNG_INFO_bKGD ) != 0 && <NEW_LINE>background != NULL ) <NEW_LINE>
findBufferHeader ( msg . u . buffer_data . buffer , kPortIndexInput ) ; <NEW_LINE>if ( buffer == NULL ) { <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE>
@stability Stable <NEW_LINE>
void putPrivmsg ( const QString & target , const QString & message , std::function < QByteArray ( const QString & , const QString & ) > encodeFunc , Cipher * cipher = 0 ) ; <NEW_LINE>
#define USB_API_MAX 4 <NEW_LINE><NEW_LINE>
ND_TCHECK_16BITS ( p + 2 ) ; <NEW_LINE>
UINT32 extra = 0 ; <NEW_LINE>
} else <NEW_LINE>free ( flagsp ) ; <NEW_LINE>
( ec_enabled ? VPX_CODEC_USE_ERROR_CONCEALMENT : 0 ) | <NEW_LINE> ( frame_parallel ? VPX_CODEC_USE_FRAME_THREADING : 0 ) ; <NEW_LINE>if ( vpx_codec_dec_init ( & decoder , interface -> codec_interface ( ) , <NEW_LINE> & cfg , dec_flags ) ) { <NEW_LINE>
void dwc3_gadget_del_and_unmap_request ( struct dwc3_ep * dep , <NEW_LINE>struct dwc3_request * req , int status ) <NEW_LINE>
str -> d . lengthAndFlags = buildLengthAndFlags ( pos - str -> d . u1 . chars , DEPENDENT_FLAGS ) ; <NEW_LINE>
jas_matind_t i ; <NEW_LINE>jas_matind_t j ; <NEW_LINE>
MInstruction * callee ; <NEW_LINE>if ( inliningDepth_ == 0 ) <NEW_LINE>callee = MCallee::New ( ) ; <NEW_LINE>else <NEW_LINE>callee = MConstant::New ( ObjectValue ( * info ( ) . fun ( ) ) ) ; <NEW_LINE>
if ( length ) { <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>
if ( pos -> prev ) { <NEW_LINE>pos -> prev -> next = edge ; <NEW_LINE>edge -> prev = pos -> prev ; <NEW_LINE>edge -> next = pos ; <NEW_LINE>pos -> prev = edge ; <NEW_LINE> } else { <NEW_LINE><NEW_LINE>pos -> next -> prev = edge ; <NEW_LINE>edge -> next = pos -> next ; <NEW_LINE>edge -> prev = pos ; <NEW_LINE>pos -> next = edge ; <NEW_LINE> } <NEW_LINE>
IDBObjectStore::ClearCloneWriteInfo ( mCloneWriteInfo ) ; <NEW_LINE>
static void fdct4_sse2 ( __m128i * in ) { <NEW_LINE>const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) cospi_16_64 ) ; <NEW_LINE>
if ( diff . needsFullLayout ( ) || diff . needsSimplifiedLayout ( ) ) { <NEW_LINE>
nsPartChannel::nsPartChannel ( nsIChannel * aMultipartChannel , PRUint32 aPartID , <NEW_LINE>nsIStreamListener * aListener ) : <NEW_LINE>mMultipartChannel ( aMultipartChannel ) , <NEW_LINE>mListener ( aListener ) , <NEW_LINE>
bool popScope = ( inLetHead || ( let && ( cg -> flags & TCF_IN_FOR_INIT ) ) ) ; <NEW_LINE>JS_ASSERT_IF ( popScope , let ) ; <NEW_LINE>
memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <NEW_LINE>
if ( num_in == 0 ) <NEW_LINE>
RETURN_EMPTY_STRING ( ) ; <NEW_LINE>
if ( png_ptr != NULL && info_ptr != NULL && <NEW_LINE> ( info_ptr -> valid & PNG_INFO_pCAL ) != 0 && <NEW_LINE>purpose != NULL && X0 != NULL && X1 != NULL && type != NULL && <NEW_LINE>
if ( ! ownerDoc || ! ( sgo = ownerDoc -> GetScopeObject ( ) ) ) { <NEW_LINE>
static unsigned char pass_salt [ 16 ] ; <NEW_LINE>
const std::string & mailbox_name ) = 0 ;
nsresult rv = nsContentUtils::ASCIIToLower ( aMimeType , type ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) { <NEW_LINE>return rv ; <NEW_LINE> } <NEW_LINE>
if ( equalIgnoringASCIICase ( pressedAttr , "mixed" ) ) <NEW_LINE>
TRACK_RUN_IN_THIS_SCOPED_REGION ( member_func ) ; \ <NEW_LINE>
MOZ_ASSERT ( mClassObject ) ; <NEW_LINE>
nsSize GetWidthHeightForImage ( nsRefPtr < imgRequestProxy > & aImageRequest ) ; <NEW_LINE>
size_t size = bytes + CHK_OVERHEAD_SIZE ; <NEW_LINE>if ( size < bytes ) { <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE>uint8_t * buffer = ( uint8_t * ) dlmalloc ( size ) ; <NEW_LINE>
|| ( nparams > 0 && params == NULL ) ) <NEW_LINE>
if ( ! doapr_outch ( sbuffer , buffer , & currlen , maxlen , ch ) ) <NEW_LINE>return 0 ; <NEW_LINE>
unregister_pernet_device ( & ipgre_net_ops ) ; <NEW_LINE>
virtual already_AddRefed < MediaResource > CloneData ( MediaDecoder * aDecoder ) ; <NEW_LINE>
if ( png_ptr -> interlaced != 0 ) <NEW_LINE>
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE><NEW_LINE>rv = location -> SetHref ( nsDependentJSString ( val ) ) ; <NEW_LINE><NEW_LINE>
last mod: $ Id: backends . h 16552 2009 - 09 - 12 02:09:04Z xiphmont $ <NEW_LINE>
bool shouldRequestSpellCheckingOptionsForPoint ( const Platform::IntPoint & documentContentPosition , const WebCore::Element * , imf_sp_text_t & ) ; <NEW_LINE>
ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <NEW_LINE>
AutoPushJSContext jscontext ( aContext -> GetNativeContext ( ) ) ; <NEW_LINE>
delete [ ] encryption -> signature ; <NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' && <NEW_LINE>strcmp ( conn_opt -> keyword , "dbname" ) != 0 ) <NEW_LINE>
iterobj -> setPrivate ( const_cast < Shape * > ( shape -> previous ( ) . get ( ) ) ) ; <NEW_LINE>
hs = ci -> halfrate_flag ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
recon_yoffset , recon_uvoffset , <NEW_LINE> & cpi -> common . lf_info , mb_row , mb_col , <NEW_LINE>block_index ) ; <NEW_LINE>
#define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 90 ) <NEW_LINE>
<NEW_LINE><NEW_LINE>virtual void NavigateBackForwardSoon ( int offset , bool has_user_gesture ) { }
#if ( defined PNG_READ_RGB_TO_GRAY_SUPPORTED ) || \ <NEW_LINE> ( defined PNG_READ_FILLER_SUPPORTED ) <NEW_LINE>
free ( tk -> p_subpackets ) ; <NEW_LINE>free ( tk -> p_subpackets_timecode ) ; <NEW_LINE>
<NEW_LINE>
zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
if ( looks_like_pbl ( filename ) ) { <NEW_LINE>
if ( mFD ) { <NEW_LINE>ConnectToProxy ( mFD ) ; <NEW_LINE>ForgetFD ( ) ; <NEW_LINE> } <NEW_LINE>
cpuData = sk_malloc_throw ( sizeInBytes ) ; <NEW_LINE>
static const l_int32 L_BUFSIZE = 256 ; <NEW_LINE>
const sp < IMediaPlayerService > <NEW_LINE>
num_chunks = ( unsigned int ) ( sizeof chunks_to_ignore ) / 5U ; <NEW_LINE>
case 3:	 * op ++ |= ( v ) ; op_offset ++ ; break ; 	\ <NEW_LINE>
static void phar_file_stat ( const char * filename , size_t filename_length , int type , void ( * orig_stat_func ) ( INTERNAL_FUNCTION_PARAMETERS ) , INTERNAL_FUNCTION_PARAMETERS ) <NEW_LINE>
goto err ; <NEW_LINE>
type == EventTypeNames::mouseout || <NEW_LINE>type == EventTypeNames::mousemove || <NEW_LINE>type == EventTypeNames::pointerover || <NEW_LINE>type == EventTypeNames::pointerout || <NEW_LINE>type == EventTypeNames::pointermove ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>void ClearUnloadState ( TabContents * tab , bool process_now ) ;
if ( oldStyle && m_scrollbar && m_part != NoPart && ( diff . needsRepaint ( ) || diff . needsLayout ( ) ) ) <NEW_LINE>
ResetDirectionSetByTextNode ( this , aNullParent ) ; <NEW_LINE>
OMX_BUFFERHEADERTYPE * header = findBufferHeader ( buffer , portIndex ) ; <NEW_LINE>
: lastBinding ( NULL ) , nargs ( 0 ) , nvars ( 0 ) , nupvars ( 0 ) , hasDup_ ( false ) <NEW_LINE>
bool setDecodeArgs ( <NEW_LINE>
uint64 surface_id , <NEW_LINE>const std::string & mailbox_name ) { } <NEW_LINE>virtual void AcceleratedSurfaceRelease ( ) { } <NEW_LINE>
entry -> seekable_stream = MagickTrue ; <NEW_LINE>
DECLARE_ALIGNED ( 16 , unsigned char , best_predictor [ 16 * 4 ] ) ; <NEW_LINE>DECLARE_ALIGNED ( 16 , short , best_dqcoeff [ 16 ] ) ; <NEW_LINE>
if ( count > PR_UINT32_MAX - self -> mLength ) { <NEW_LINE>return NS_ERROR_ILLEGAL_VALUE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( self -> mLength + count > self -> mAllocated ) { <NEW_LINE>self -> mData = static_cast < PRUint8 * > ( NS_Realloc ( self -> mData , <NEW_LINE>self -> mLength + count ) ) ; <NEW_LINE>if ( ! self -> mData ) { <NEW_LINE>self -> mLength = 0 ; <NEW_LINE>self -> mAllocated = 0 ; <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE>self -> mAllocated = self -> mLength + count ; <NEW_LINE> } <NEW_LINE><NEW_LINE>::memcpy ( self -> mData + self -> mLength , fromSegment , count ) ; <NEW_LINE>self -> mLength += count ; <NEW_LINE><NEW_LINE>
DECLARE_ALIGNED ( 4 , short , FData [ 12 * 4 ] ) ; <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
AutoPushJSContext cx ( context -> GetNativeContext ( ) ) ; <NEW_LINE>
pr_emerg ( "mm % px mmap % px seqnum % llu task_size % lu\n" <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** stream , <NEW_LINE>nsIChannel ** channel ) = 0 ;
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>JSCompartment * target = js::GetContextCompartment ( cx ) ; <NEW_LINE>JSCompartment * origin = js::GetObjectCompartment ( obj ) ; <NEW_LINE>obj = AccessCheck::subsumes ( target , origin ) ? WaiveXray ( cx , obj ) : obj ; <NEW_LINE>
if ( getter . jitInfo ( ) && getter . jitInfo ( ) -> isDOMJitInfo ( ) ) <NEW_LINE>
if ( ( ( ebcdicHandler == NULL ) && <NEW_LINE> ( strstr ( globbuf . gl_pathv [ i ] , "ebcdic" ) != NULL ) ) || <NEW_LINE> ( ( eucJpHandler == NULL ) && <NEW_LINE> ( strstr ( globbuf . gl_pathv [ i ] , "icu_parse_test" ) != NULL ) ) ) <NEW_LINE>
memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ; <NEW_LINE>
static void pack_mb_row_tokens ( VP8_COMP * cpi , vp8_writer * w ) <NEW_LINE>
nsCOMPtr < nsIDOMHTMLCanvasElement > mCanvasElement ; <NEW_LINE>nsHTMLCanvasElement * HTMLCanvasElement ( ) { <NEW_LINE>return static_cast < nsHTMLCanvasElement * > ( mCanvasElement . get ( ) ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>NS_ADDREF_THIS ( ) ; <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
if ( STATE_FIRST_CALL == mState && * aSrcLength < 2 ) <NEW_LINE> { <NEW_LINE>nsresult res = ( * aSrcLength == 0 ) ? NS_OK : NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> * aSrcLength = 0 ; <NEW_LINE> * aDestLength = 0 ; <NEW_LINE>return res ; <NEW_LINE> } <NEW_LINE>
extern void image_transform_default_ini ( const image_transform * this , <NEW_LINE>transform_display * that ) ; <NEW_LINE><NEW_LINE>void <NEW_LINE>image_transform_default_ini ( const image_transform * this , <NEW_LINE>
<NEW_LINE>
MarkLineDirty ( prevSibLine , lineList ) ; <NEW_LINE>
@stability Evolving <NEW_LINE>
va_list args ) <NEW_LINE>
memcpy ( sortlist , cpi -> mb_activity_map , <NEW_LINE>sizeof ( unsigned int ) * cpi -> common . MBs ) ;
if ( isOutOfFlowPositioned ( ) ) { <NEW_LINE>
static const char * const cfg = " -- target = mips32 - linux - gcc -- disable - dspr2 -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect -- disable - install - docs -- size - limit = 4096x3072" ; <NEW_LINE>
ERREXIT ( cinfo , JERR_PPM_OUTOFRANGE ) ; <NEW_LINE>
scale = adjust_scale ( scale ) ; <NEW_LINE>
static int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) { <NEW_LINE>
* rowp ++ = suffix [ code ] & mColorMask ; <NEW_LINE>
const png_uint_32 id = FILEID ( colour_type , bit_depth , 0 , <NEW_LINE>
JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS ( JSSCRIPT_RESERVED_SLOTS ) | <NEW_LINE>
return equalIgnoringASCIICase ( grabbed , "true" ) || <NEW_LINE>equalIgnoringASCIICase ( grabbed , "false" ) ; <NEW_LINE>
strncpy ( NamedColorList -> List [ NamedColorList -> nColors ] . Name , Name , cmsMAX_PATH - 1 ) ; <NEW_LINE>
nsCOMPtr < nsITreeBoxObject > mTree ; <NEW_LINE>
while ( * s && ( * s != '\"' ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) ) <NEW_LINE>
void DidFocus ( WebLocalFrame * ) override { did_focus_called_ = true ; } <NEW_LINE>
PlatformMouseEvent mouseEvent ( point . documentViewportPosition ( ) , m_lastScreenPoint , PlatformEvent::MouseMoved , 1 , LeftButton , shiftActive , ctrlActive , altActive , TouchScreen ) ; <NEW_LINE>m_lastScreenPoint = point . screenPosition ( ) ; <NEW_LINE>
uschar * hn ; <NEW_LINE><NEW_LINE>if ( received_protocol ) <NEW_LINE> { <NEW_LINE>fprintf ( stderr , "received_protocol is set already\n" ) ; <NEW_LINE>exit ( EXIT_FAILURE ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>hn = Ustrchr ( argrest , ':' ) ; <NEW_LINE>
if ( do_background != 0 && i < num_trans && trans [ i ] < 255 ) <NEW_LINE>
if ( req -> buf != NULL ) <NEW_LINE>free_ep_req ( midi -> out_ep , req ) ; <NEW_LINE>
Cluster * const old_cluster = cluster_list_ [ cluster_list_size_ - 1 ] ; <NEW_LINE>
OMX_U32 frameSize ; <NEW_LINE>OMX_U64 yFrameSize = ( OMX_U64 ) mWidth * ( OMX_U64 ) mHeight ; <NEW_LINE>if ( yFrameSize > ( ( OMX_U64 ) UINT32_MAX / 3 ) * 2 ) { <NEW_LINE>ALOGE ( "Frame size too large" ) ; <NEW_LINE>notify ( OMX_EventError , OMX_ErrorUndefined , 0 , NULL ) ; <NEW_LINE>mSignalledError = true ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>frameSize = ( OMX_U32 ) ( yFrameSize + ( yFrameSize / 2 ) ) ; <NEW_LINE><NEW_LINE>
if ( ( ret = init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , <NEW_LINE>s -> bits [ i ] , 4 , 4 , 0 ) ) < 0 ) <NEW_LINE>return ret ; <NEW_LINE>
if ( ( y == 0 ) || ( last_row [ x + bit ] != one_row [ x + bit ] ) ) <NEW_LINE>
HTMLCanvasElement ( ) -> InvalidateFrame ( & r ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
<NEW_LINE>record_size += 1 ; <NEW_LINE><NEW_LINE>
r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL ) ; <NEW_LINE>
memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ; <NEW_LINE>
<NEW_LINE>#include "vpx_dsp / prob . h" <NEW_LINE><NEW_LINE>#include "vp9 / common / vp9_mv . h" <NEW_LINE>
#endif <NEW_LINE>
struct inode * __isofs_iget ( struct super_block * sb , <NEW_LINE>unsigned long block , <NEW_LINE>unsigned long offset , <NEW_LINE>int relocated ) <NEW_LINE>
if ( dest != src && src != NULL ) { <NEW_LINE>
if ( ctxt -> instate == XML_PARSER_EOF ) { <NEW_LINE><NEW_LINE> } else if ( ctxt -> nameNr == 0 ) { <NEW_LINE>
RootJSResultObjects ( ) ; <NEW_LINE>
memcpy ( upred_ptr , uabove_row , 8 ) ; <NEW_LINE>memcpy ( vpred_ptr , vabove_row , 8 ) ; <NEW_LINE>
static inline zend_ulong realpath_cache_key ( const char * path , size_t path_len ) <NEW_LINE>
if ( win -> IsInnerWindow ( ) || win -> IsFrozen ( ) ) { <NEW_LINE><NEW_LINE><NEW_LINE>
void markRoots ( JSTracer * trc ) ; <NEW_LINE>
if ( mTree ) <NEW_LINE>mFirstRange -> Invalidate ( mTree ) ; <NEW_LINE>
<NEW_LINE>if ( buffer_caret + pixel_block_size > rle_size ) { <NEW_LINE>gdFree ( decompression_buffer ) ; <NEW_LINE>gdFree ( conversion_buffer ) ; <NEW_LINE>return - 1 ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
if ( m_pInfo == NULL || m_pTracks == NULL ) <NEW_LINE>return E_FILE_FORMAT_INVALID ; <NEW_LINE>
res = ctx -> iface -> enc . encode ( get_alg_priv ( ctx ) , img , pts , <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
NULL , NULL , <NEW_LINE>JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT ) ) { <NEW_LINE>
static const char CVS_ID [ ] = "@ ( # ) $ RCSfile: certdata . c , v $ $ Revision: 1 . 67 . 2 . 1 $ $ Date: 2010 / 08 / 27 15:46:44 $ "" ; @ ( # ) $ RCSfile: certdata . c , v $ $ Revision: 1 . 67 . 2 . 1 $ $ Date: 2010 / 08 / 27 15:46:44 $ " ; <NEW_LINE>
js_GetDeflatedUTF8StringLength ( JSContext * cx , const jschar * chars , size_t nchars ) <NEW_LINE>
<NEW_LINE>
if ( isOutOfFlowPositioned ( ) ) <NEW_LINE>
if ( NS_URIIsLocalFile ( mCodebase ) ) { <NEW_LINE>
if ( Z_TYPE_PP ( item ) != IS_LONG ) { <NEW_LINE>zval lval ; <NEW_LINE>lval = ** item ; <NEW_LINE>zval_copy_ctor ( & lval ) ; <NEW_LINE>convert_to_long ( & lval ) ; <NEW_LINE>stylearr [ index ++ ] = Z_LVAL ( lval ) ; <NEW_LINE> } else { <NEW_LINE>stylearr [ index ++ ] = Z_LVAL_PP ( item ) ; <NEW_LINE> } <NEW_LINE>
if ( JAS_CAST ( jas_uint , jas_stream_read ( in , ppm -> data , ppm -> len ) ) != ppm -> len ) { <NEW_LINE>
#include "components / dom_distiller / content / browser / distiller_ui_handle . h" <NEW_LINE>
sock -> _wreq . alloced_ptr = sock -> _wreq . bufs ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
. llseek = ftrace_filter_lseek , <NEW_LINE>
#include "chrome / browser / autocomplete / autocomplete_provider . h" <NEW_LINE><NEW_LINE>class AutocompleteInput ; <NEW_LINE>struct AutocompleteMatch ;
: _glyph_loader ( new Loader ( face ) ) , <NEW_LINE>
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] = { L'\0' } ; <NEW_LINE>wcsncpy ( updateStatusFilePath , updateDirPath , MAX_PATH ) ; <NEW_LINE>
perf_swevent_event ( event , nr , data , regs ) ; <NEW_LINE>
if ( ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) || <NEW_LINE> ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) ) { <NEW_LINE>
media::VideoColorSpace color_space ; <NEW_LINE>
if ( child -> isBlockFlow ( ) && ! child -> isFloatingOrOutOfFlowPositioned ( ) ) { <NEW_LINE>
if ( ( wp -> path = websValidateUriPath ( path ) ) == 0 ) { <NEW_LINE>
if ( ! m_sources . count ( AutoplaySource::Method ) || <NEW_LINE> ! m_element -> isHTMLVideoElement ( ) || ! m_element -> muted ( ) ) <NEW_LINE>
if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || <NEW_LINE>pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
uint64 EbmlElementSize ( uint64 type , float ) { <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
#define GR2_VERSION_BUGFIX 3 <NEW_LINE>
jas_stream_flushbuf ( ( stream ) , ( jas_uchar ) ( c ) ) : \ <NEW_LINE>
JSAutoTempValueRooter tvr ( cx , JS_ARRAY_LENGTH ( tmp ) , tmp ) ; <NEW_LINE>
packet_size = ( size_t ) ( image -> depth > 8 ? 2 : 1 ) ; <NEW_LINE>
row_bytes = 4 * image -> columns ; <NEW_LINE>
static const vpx_prob default_partition_probs [ PARTITION_CONTEXTS ] <NEW_LINE>
{ <NEW_LINE>quantum_info = DestroyQuantumInfo ( quantum_info ) ; <NEW_LINE>ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
<NEW_LINE><NEW_LINE>realGuessMax = PR_MIN ( 500 , realGuessMax ) ; <NEW_LINE>
JSBool <NEW_LINE>
if ( object -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
isoclns_print ( ndo , p , l2info . length ) ; <NEW_LINE>
#include "base / callback_old . h" <NEW_LINE>
option = ssplit ( option , " = \t , " , & ovalue ) ; <NEW_LINE>
<NEW_LINE>
r = vt_verify_kbmode ( fd ) ; <NEW_LINE>if ( r == - EBUSY ) { <NEW_LINE>log_warning_errno ( r , "Virtual console % s is not in K_XLATE or K_UNICODE: % m" , name ) ; <NEW_LINE>return 0 ; <NEW_LINE> } else if ( r < 0 ) <NEW_LINE>return log_warning_errno ( r , "Failed to verify kbdmode on % s: % m" , name ) ; <NEW_LINE><NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
return layer -> isRootLayer ( ) || layerRenderer -> isOutOfFlowPositioned ( ) || layerRenderer -> isRelPositioned ( ) || layer -> hasTransform ( ) ; <NEW_LINE>
pusher . Push ( cx ) ; <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
fname_len = strlen ( fname ) ; <NEW_LINE>
if ( ! pusher . Push ( mContext ) ) <NEW_LINE>
<NEW_LINE>
nsCOMPtr < nsIAtom > attrLocal = attrName -> LocalName ( ) ; <NEW_LINE>
if ( ! child -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ; <NEW_LINE>l_row -- ; l_column -- ; <NEW_LINE>
static inline int _setEdgePixel ( const gdImagePtr src , unsigned int x , unsigned int y , gdFixed coverage , const int bgColor ) <NEW_LINE>
chase = ( ( ogg_uint32_t * ) ( book -> dec_table ) ) [ chase * 2 + ( ( lok >> i ) & 1 ) ] ; <NEW_LINE>if ( chase & 0x80000000UL ) break ; <NEW_LINE>
#endif <NEW_LINE>
if ( ! offset || ! ht ) { <NEW_LINE>
<NEW_LINE>if ( ! mDepthAttachment . IsNull ( ) && ! mDepthAttachment . HasSameDimensionsAs ( mColorAttachment ) ) <NEW_LINE>return PR_TRUE ; <NEW_LINE>if ( ! mStencilAttachment . IsNull ( ) && ! mStencilAttachment . HasSameDimensionsAs ( mColorAttachment ) ) <NEW_LINE>return PR_TRUE ; <NEW_LINE>if ( ! mDepthStencilAttachment . IsNull ( ) && ! mDepthStencilAttachment . HasSameDimensionsAs ( mColorAttachment ) ) <NEW_LINE>return PR_TRUE ; <NEW_LINE><NEW_LINE>
<NEW_LINE>
VpxInputContext * vpx_ctx_ ; <NEW_LINE>WebmInputContext * webm_ctx_ ; <NEW_LINE>
<NEW_LINE>
if ( size > cdigits ) <NEW_LINE>
@stability Stable <NEW_LINE>
efree ( buf ) ; <NEW_LINE>efree ( buf2 ) ; <NEW_LINE>
ReentrantMonitorAutoEnter lock ( mDecodingMonitor ) ; <NEW_LINE>
if ( block -> isLoopHeader ( ) ) { <NEW_LINE>if ( ! analyzeLoop ( block ) ) <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE>
else return apr_psprintf ( cmd -> pool , "ModSecurity: Invalid value for SexHashEngine: % s" , p1 ) ; <NEW_LINE>
<NEW_LINE>#define MAX_VP9_HEADER_SIZE 80 <NEW_LINE>
while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && <NEW_LINE>ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <NEW_LINE>
bool & isvalid , CryptoKey & session_key , <NEW_LINE>std::unique_ptr < AuthAuthorizerChallenge > * challenge ) override ; <NEW_LINE>
if ( ( png_ptr -> colorspace . flags & PNG_COLORSPACE_INVALID ) != 0 ) <NEW_LINE>
#line 4041 "dcraw / dcraw . c" <NEW_LINE>
if ( snprintf ( pattern , 499 , " . / test / relaxng / % s_ ? . xml" , prefix ) >= 499 ) <NEW_LINE>pattern [ 499 ] = 0 ; <NEW_LINE>
if ( code == gcode && wordlist [ key ] . index >= 0 ) <NEW_LINE>
HashSet < String > validated_urls_ ; <NEW_LINE>
virtual void WriteInternal ( const char * aBuffer , uint32_t aCount , DecodeStrategy aStrategy ) ; <NEW_LINE>
thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride ) ; <NEW_LINE>
res = HSM_COM_PATH_ERR ; goto cleanup ;
if ( ! legend -> isFloatingOrOutOfFlowPositioned ( ) && legend -> node ( ) && ( legend -> node ( ) -> hasTagName ( legendTag ) ) ) <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>JSObject * wrapped = wrappedObject ( wrapper ) ; <NEW_LINE>JSPrincipals * wrapperPrincipals = wrapper -> compartment ( ) -> principals ; <NEW_LINE>JSPrincipals * wrappedPrincipals = wrapped -> compartment ( ) -> principals ; <NEW_LINE>if ( ! wrapperPrincipals || ! wrappedPrincipals || <NEW_LINE> ! wrapperPrincipals -> subsume ( wrapperPrincipals , wrappedPrincipals ) ) <NEW_LINE> { <NEW_LINE>return DefaultValue ( cx , wrapper , hint , vp ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>AutoCompartment call ( cx , wrapped ) ; <NEW_LINE>if ( ! call . enter ( ) ) <NEW_LINE>return false ; <NEW_LINE><NEW_LINE> * vp = ObjectValue ( * wrapped ) ; <NEW_LINE>
bool & isvalid , CryptoKey & session_key , <NEW_LINE>std::unique_ptr < AuthAuthorizerChallenge > * challenge ) override ; <NEW_LINE>
validated_urls_ . Contains ( existing_resource -> Url ( ) ) ) <NEW_LINE>
return 1 ; <NEW_LINE>
<NEW_LINE>
ERROR ( "read_id_table: failed to read id table block" <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
bufsize = MIN ( file -> size , sizeof buf ) ; <NEW_LINE>
const PRErrorCode originalError = PR_GetError ( ) ; <NEW_LINE>PRErrorCode err = originalError ;
<NEW_LINE>char * c_ptr = ( char * ) malloc ( xsum ( xsum ( extra_zeroes , c_len ) , 1 ) ) ; <NEW_LINE>
Chapter * Segment::AddChapter ( ) { return chapters_ . AddChapter ( & seed_ ) ; } <NEW_LINE><NEW_LINE>Tag * Segment::AddTag ( ) { return tags_ . AddTag ( ) ; } <NEW_LINE>
unsigned int <NEW_LINE>
vpx_decrypt_cb decrypt_cb ; <NEW_LINE>
NS_IF_RELEASE ( sContent ) ; <NEW_LINE>
const HeapPtrShape & previous ( ) const { <NEW_LINE>
<NEW_LINE>nsINode * element = dataset -> GetElement ( ) ; <NEW_LINE>return WrapNativeParent ( cx , globalObj , element , element , parentObj ) ; <NEW_LINE>
LongSeek ( mp4 , qtsize - 8 ) ; <NEW_LINE>
conn -> username = ssplit ( sclone ( username ) , ":" , & ptok ) ; <NEW_LINE>
if ( ! obj -> isFloatingOrOutOfFlowPositioned ( ) ) { <NEW_LINE>
isoclns_print ( ndo , bp , len ) ; <NEW_LINE>
typedef png_structp version_1_2_54 ; <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
#line 1282 "ext / standard / var_unserializer . c" <NEW_LINE>
m . command = CMD_NONE ; <NEW_LINE>
mImageRequest -> CancelAndForgetObserver ( NS_ERROR_FAILURE ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
* table_start = fragment_table_index [ 0 ] ; <NEW_LINE>
if ( curr -> isAnonymous ( ) || curr -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
#ifdef IS_X8664 <NEW_LINE>
static void pack_tokens_into_partitions ( VP8_COMP * cpi , unsigned char * cx_data , <NEW_LINE>
if ( save != 0 ) <NEW_LINE>
virtual void ClearInstance ( ) OVERRIDE ; <NEW_LINE>
nsRefPtr < nsIWebGLUniformLocation > loc = prog -> GetUniformLocationObject ( prog , intlocation ) ; <NEW_LINE>
<NEW_LINE>
printf ( "gamma % f: maximum 16 - bit error % f\n" , g , maxerr ) ; <NEW_LINE>
WORD64 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ; <NEW_LINE>WORD64 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ; <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( mIsDocumentObserver ) { <NEW_LINE>if ( aType >= Flush_ContentAndNotify ) { <NEW_LINE>FlushTags ( ) ; <NEW_LINE> } <NEW_LINE>else if ( mCurrentContext ) { <NEW_LINE>mCurrentContext -> FlushText ( ) ; <NEW_LINE> } <NEW_LINE>
nsCOMPtr < nsPIDOMWindow > window = mDocument -> GetWindow ( ) ; <NEW_LINE>
JSAutoByteString params ; <NEW_LINE>
#include < sslopt - case . h > <NEW_LINE>
return parent ? parent -> FindFirstNonChromeOnlyAccessContent ( ) : nullptr ; <NEW_LINE>
<NEW_LINE>case AST_OPTION_TONE_VERIFY: <NEW_LINE>case AST_OPTION_TDD: <NEW_LINE>case AST_OPTION_RELAXDTMF: <NEW_LINE>case AST_OPTION_AUDIO_MODE: <NEW_LINE>case AST_OPTION_DIGIT_DETECT: <NEW_LINE>case AST_OPTION_FAX_DETECT: <NEW_LINE>
last mod: $ Id: codebook . c 16597 2009 - 10 - 01 02:54:22Z tterribe $ <NEW_LINE>
for ( unsigned int i = 0 ; i < m_PictureParameters . ItemCount ( ) ; i ++ ) { <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
if ( curr -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
for ( jsuint i = start ; i != end ; i += step ) { <NEW_LINE>
defenses = mprReadJson ( child , "defenses" ) ; <NEW_LINE>expression = mprReadJson ( child , "expression" ) ; <NEW_LINE>period = httpGetTicks ( mprReadJson ( child , "period" ) ) ; <NEW_LINE>
bool BASE_API PreReadImage ( const wchar_t * file_path , size_t size_to_read , <NEW_LINE>size_t step_size ) ; <NEW_LINE>
item -> PostHandleEvent ( aVisitor , aPusher ) ; <NEW_LINE>
if ( ( off >= offset ) && ( off + sizeof ( flat_binder_object ) <= offset + len ) ) { <NEW_LINE>
#endif <NEW_LINE>
credits = be32_to_cpup ( rdma_resp + 2 ) ; <NEW_LINE>
if ( ! mAudioCaptured && aCaptured && ! mStopAudioThread ) { <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>ScheduleStateMachine ( ) ; <NEW_LINE>
struct mlx5_ib_create_qp_resp resp = { } ; <NEW_LINE>
OMX_BUFFERHEADERTYPE * findBufferHeader ( OMX::buffer_id buffer , OMX_U32 portIndex ) ; <NEW_LINE>
done = qrio_get_gpio ( QRIO_GPIO_A , FPGA_DONE ) ; <NEW_LINE>
if ( ! EnsureStringLength ( charXferString , charLength ) ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE><NEW_LINE>
bestmv -> as_mv . row *= 8 ; <NEW_LINE>bestmv -> as_mv . col *= 8 ; <NEW_LINE>
#line 1215 "ext / standard / var_unserializer . c" <NEW_LINE>
char * hash = strchr ( buffer , '#' ) ; <NEW_LINE>if ( ! comma || ( hash && hash < comma ) ) <NEW_LINE>
#define YYLEX_PARAM context -> lexer ( ) <NEW_LINE>
png_ptr -> pixel_depth = ( png_byte ) ( png_ptr -> bit_depth * png_ptr -> channels ) ; <NEW_LINE>
nsresult rv = NS_CreateJSTimeoutHandler ( this , <NEW_LINE>
if ( chnMem . autoVolSlide && m . volcmd == VOLCMD_NONE ) <NEW_LINE>
__ptrace_link ( child , new_parent , current_cred ( ) ) ; <NEW_LINE>
<NEW_LINE>
if ( ( png_ptr -> mng_features_permitted & PNG_FLAG_MNG_FILTER_64 ) != 0 && <NEW_LINE>
memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE>
size_t bytes = size + alignment + 3 * sizeof ( size_t ) ; <NEW_LINE><NEW_LINE>if ( bytes < size ) <NEW_LINE>return 0 ; <NEW_LINE>size = bytes ; <NEW_LINE>
#define VPX_CODEC_ABI_VERSION ( 3 + VPX_IMAGE_ABI_VERSION ) <NEW_LINE>
unsigned int czero , clead , cdigits ; <NEW_LINE>
class SocketStreamDispatcherHost <NEW_LINE>: public content::BrowserMessageFilter , <NEW_LINE>public net::SocketStream::Delegate , <NEW_LINE>public SSLErrorHandler::Delegate , <NEW_LINE>public base::SupportsWeakPtr < SocketStreamDispatcherHost > { <NEW_LINE>
- 3 , - 4 , - 7 , 4 , 3 , 0 , - 1 , - 2 , - 5 , <NEW_LINE>
white_point ( const color_encoding * encoding ) <NEW_LINE>
memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <NEW_LINE>
nsContentUtils::AddScriptRunner ( new nsPLDOMEvent ( mContent , <NEW_LINE>NS_LITERAL_STRING ( "ValueChange" ) , PR_TRUE ) ) ; <NEW_LINE>
if ( ! cx ) <NEW_LINE>return false ; <NEW_LINE><NEW_LINE>if ( xpc::IsXBLScope ( js::GetContextCompartment ( cx ) ) ) <NEW_LINE>return true ; <NEW_LINE><NEW_LINE>if ( ! JS_DescribeScriptedCaller ( cx , & script , nullptr ) || ! script ) <NEW_LINE>
base::WeakPtr < Delegate > delegate_ ; <NEW_LINE>
<NEW_LINE>
for ( a = pool -> current ; nb > a -> limit || a -> avail > a -> limit - nb ; <NEW_LINE>pool -> current = a ) { <NEW_LINE>
status_t Camera2ClientBase < TClientBase > ::dumpClient ( int fd , <NEW_LINE>
PasswordGenerationController * controller_ ; <NEW_LINE>
if ( outputBufferSafe ( outHeader ) ) { <NEW_LINE>
do { <NEW_LINE>ReResolveStyleContext ( aPresContext , outOfFlowFrame , <NEW_LINE>content , aChangeList , <NEW_LINE>NS_SubtractHint ( aMinChange , <NEW_LINE>nsChangeHint_ReflowFrame ) , <NEW_LINE>childRestyleHint , <NEW_LINE>fireAccessibilityEvents , <NEW_LINE>aRestyleTracker ) ; <NEW_LINE> } while ( outOfFlowFrame = outOfFlowFrame -> GetNextContinuation ( ) ) ; <NEW_LINE>
wp -> socket_mode = 0660 ; <NEW_LINE>
LongSeek ( mp4 , qtsize - 8 ) ; <NEW_LINE>
portDefn -> nSize = sizeof ( OMX_PARAM_PORTDEFINITIONTYPE ) ; <NEW_LINE>
if ( ! _gdImageWBMPCtx ( im , fg , out ) ) { <NEW_LINE>rv = gdDPExtractData ( out , size ) ; <NEW_LINE> } else { <NEW_LINE>rv = NULL ; <NEW_LINE> } <NEW_LINE>
mapping ] ) ) ; <NEW_LINE>
if ( ! enterCompiler . init ( script , false , 0 ) ) <NEW_LINE>return false ; <NEW_LINE>
<NEW_LINE>
pusher . Push ( cx ) ; <NEW_LINE>
pusher . Push ( cx , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ; <NEW_LINE>
#line 648 "ext / standard / var_unserializer . re" <NEW_LINE>
memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , <NEW_LINE>sizeof ( MB_MODE_INFO ) ) ; <NEW_LINE>
if ( XrayUtils::NeedsWaive ( cx , wrapper , id ) ) { <NEW_LINE>RootedObject waived ( cx , WrapperFactory::WaiveXray ( cx , wrapper ) ) ; <NEW_LINE>if ( ! waived || ! JS_WrapObject ( cx , waived . address ( ) ) ) <NEW_LINE>return false ; <NEW_LINE>if ( ! JS_GetPropertyDescriptorById ( cx , waived , id , flags , desc ) ) <NEW_LINE>return false ; <NEW_LINE>if ( desc -> obj != waived ) <NEW_LINE>desc -> obj = nullptr ; <NEW_LINE>return true ; <NEW_LINE>
{ <NEW_LINE> ( void ) RelinquishUniqueFileResource ( memory_info -> filename ) ; <NEW_LINE>RelinquishMagickResource ( DiskResource , memory_info -> length ) ; <NEW_LINE> } <NEW_LINE>
#define LIBRAW_PATCH_VERSION 4 <NEW_LINE>
modifier_current_encoding ( const png_modifier * pm , color_encoding * ce ) <NEW_LINE>
if ( curr -> renderer ( ) -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
delete [ ] track_entries_ ; <NEW_LINE>
g [ j ] += g [ j ] ; <NEW_LINE>
const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( ( int16_t ) - cospi_16_64 ) ; <NEW_LINE>const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) cospi_16_64 ) ; <NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_EXPAND ) != 0 ) <NEW_LINE>
if ( params ) { <NEW_LINE>munmap ( params , allocSize ) ; <NEW_LINE> } <NEW_LINE>
ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ; <NEW_LINE>if ( ret == - 1 ) <NEW_LINE>goto trunc ; <NEW_LINE>if ( ret == TRUE ) <NEW_LINE>
* ( -- dp ) = hi_filler ; <NEW_LINE>
if ( len > 0 ) <NEW_LINE>properties [ len - 1 ] = AboveForm ; <NEW_LINE>
png_malloc_warn ( png_ptr , ( sizeof * control ) ) ) ; <NEW_LINE>
* q ++ = ' ' ; <NEW_LINE>
<NEW_LINE>
virtual bool GetURLAndTitle ( OSExchangeData::FilenameToURLPolicy policy , <NEW_LINE>GURL * url , <NEW_LINE>base::string16 * title ) const ; <NEW_LINE>
UnmarkGrayTracer trc ; <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ; <NEW_LINE>
GtkWidget * widget = GetMozContainerWidget ( ) ; <NEW_LINE>
c -> markRoots ( trc ) ;
class BASE_EXPORT ScopedZxHandle <NEW_LINE>
void vp9_cost_tokens ( int * costs , const vpx_prob * probs , vpx_tree tree ) ; <NEW_LINE>void vp9_cost_tokens_skip ( int * costs , const vpx_prob * probs , vpx_tree tree ) ; <NEW_LINE>
if ( grandParent && grandParent -> IsXUL ( ) ) { <NEW_LINE>
png_uint_16 i = ( ( png_uint_16 ) ( ( * ( buf ) ) & 0xff ) << 8 ) + <NEW_LINE> ( ( png_uint_16 ) ( ( * ( buf + 1 ) ) & 0xff ) ) ; <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
if ( ! ipc . opt ) { <NEW_LINE>struct ip_options_rcu * inet_opt ; <NEW_LINE><NEW_LINE>rcu_read_lock ( ) ; <NEW_LINE>inet_opt = rcu_dereference ( inet -> inet_opt ) ; <NEW_LINE>if ( inet_opt ) { <NEW_LINE>memcpy ( & opt_copy , inet_opt , <NEW_LINE>sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; <NEW_LINE>ipc . opt = & opt_copy . opt ; <NEW_LINE> } <NEW_LINE>rcu_read_unlock ( ) ; <NEW_LINE> } <NEW_LINE>
if ( BITMASK_PRESENT ( & m_out_bm_count , i ) ) { <NEW_LINE>BITMASK_CLEAR ( & m_out_bm_count , i ) ; <NEW_LINE>free_output_buffer ( & m_out_mem_ptr [ i ] ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( release_output_done ( ) ) { <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>
#line 1229 "ext / standard / var_unserializer . c" <NEW_LINE>
result = TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ; <NEW_LINE>
static inline __u64 dccp_v6_init_sequence ( struct sk_buff * skb ) <NEW_LINE>
<NEW_LINE>
return throwError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
cached_resource <NEW_LINE> ? InspectorPageAgent::ToResourceType ( cached_resource -> GetType ( ) ) <NEW_LINE>: InspectorPageAgent::kOtherResource ; <NEW_LINE>
#endif <NEW_LINE>
<NEW_LINE><NEW_LINE>
<NEW_LINE>#define VPX_MAX_LAYERS 12 <NEW_LINE><NEW_LINE><NEW_LINE>#define MAX_LAYERS VPX_MAX_LAYERS <NEW_LINE>
if ( tsa && tportno > 0 ) { <NEW_LINE>
ENGINE_SET_INVALID_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <NEW_LINE>
ZEND_ARG_INFO ( 0 , flags ) <NEW_LINE>
<NEW_LINE><NEW_LINE>vp [ 2 + -- argc ] = JSVAL_VOID ; <NEW_LINE>
"mcrypt" , <NEW_LINE>
uint64 size = <NEW_LINE>EbmlElementSize ( kMkvSamplingFrequency , static_cast < float > ( sample_rate_ ) ) ; <NEW_LINE>
bool DummyFramebufferOperation ( const char * info ) ; <NEW_LINE>
nsCOMPtr < nsIObjectLoadingContent > content = do_QueryReferent ( mContent ) ; <NEW_LINE>
if ( sid -> cached == never_cached ) { <NEW_LINE> ( * ss -> sec . cache ) ( sid ) ; <NEW_LINE> } <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
if ( total >= 0 && avail > total ) <NEW_LINE>return E_FILE_FORMAT_INVALID ; <NEW_LINE>
} else if ( size != 0 ) { <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>virtual bool WouldTaintOrigin ( ) const = 0 ; <NEW_LINE>
char ** lines = NULL ; <NEW_LINE>
return ( SkipRGBMipmaps ( image , dds_info , 3 , exception ) ) ; <NEW_LINE>
col_sum [ c ] += adjustment ; <NEW_LINE>
if ( check_anon ( kdc_active_realm , client . princ , request -> server ) != 0 ) { <NEW_LINE>
return obj && subsumes ( js::GetObjectCompartment ( wrapper ) , <NEW_LINE>js::GetObjectCompartment ( obj ) ) ; <NEW_LINE>
return gridAreaBreadthForChild - ( child . needsLayout ( ) ? computeMarginLogicalHeightForChild ( child ) : marginLogicalHeightForChild ( child ) ) ; <NEW_LINE>
ND_TCHECK2 ( * ext , sizeof ( a ) ) ; <NEW_LINE>
"Unknown Transfer - Encoding: % s ; " <NEW_LINE>"using read - until - close" , tenc ) ; <NEW_LINE>
void WebGLRenderingContextBase:: <NEW_LINE>DrawingBufferClientRestorePixelPackParameters ( ) { <NEW_LINE>
static PassRefPtr < RTCSessionDescriptionRequestImpl > create ( ScriptExecutionContext * , PassRefPtr < RTCSessionDescriptionCallback > , PassRefPtr < RTCErrorCallback > , PassRefPtr < RTCPeerConnection > ) ; <NEW_LINE>
#include "vpx_ports / msvc . h" <NEW_LINE>
memset ( ypred_ptr , yleft_col [ r ] , 16 ) ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
StackFrame * fp = NULL ; <NEW_LINE>if ( iter . isScript ( ) && ! iter . isIon ( ) ) <NEW_LINE>fp = iter . interpFrame ( ) ; <NEW_LINE>
<NEW_LINE>int coeff_prob_appx_step ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>MOTION_THRESHOLD lf_motion_threshold ;
void vp9_filter_block_plane_ss00 ( struct VP9Common * const cm , <NEW_LINE>struct macroblockd_plane * const plane , <NEW_LINE>int mi_row , <NEW_LINE>LOOP_FILTER_MASK * lfm ) ; <NEW_LINE><NEW_LINE>void vp9_filter_block_plane_ss11 ( struct VP9Common * const cm , <NEW_LINE>struct macroblockd_plane * const plane , <NEW_LINE>int mi_row , <NEW_LINE>LOOP_FILTER_MASK * lfm ) ; <NEW_LINE><NEW_LINE>void vp9_filter_block_plane_non420 ( struct VP9Common * cm , <NEW_LINE>struct macroblockd_plane * plane , <NEW_LINE>MODE_INFO ** mi_8x8 , <NEW_LINE>int mi_row , int mi_col ) ; <NEW_LINE>
sclone scmp scopy sfmt sfmtv slen slower smatch sstarts sncaselesscmp sncmp sncopy stok strim supper <NEW_LINE>
delete [ ] encryption -> key_id ; <NEW_LINE>
JSAutoByteString params ; <NEW_LINE>
#include "imgRequestProxy . h" <NEW_LINE>
if ( curr -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <NEW_LINE>
@stability Evolving <NEW_LINE>
( row_info -> color_type & PNG_COLOR_MASK_COLOR ) != 0 ) <NEW_LINE>
if ( mIsSecure && ! audio && mVideoTrack . mSource != NULL ) { <NEW_LINE>
if ( descendantsHaveSameLineHeightAndBaseline ( ) && ! child -> renderer ( ) -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
#include "compiler / compilerdebug . h" <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
nsCxPusher pusher ; <NEW_LINE>JSContext * cx = mContext ? mContext -> GetNativeContext ( ) <NEW_LINE>: nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE>pusher . Push ( cx , nsCxPusher::ALWAYS_PUSH ) ; <NEW_LINE>
} <NEW_LINE>
vpx_codec_dec_init ( & stream -> decoder , decoder -> codec_interface ( ) , NULL , 0 ) ; <NEW_LINE>
u8 * oid = fs -> cache . array [ x ] . objectId . id ; <NEW_LINE>if ( bufLen < 2 ) <NEW_LINE>break ; <NEW_LINE>
do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , & data , regs ) ; <NEW_LINE>
if ( ! CallPPluginStreamConstructor ( ps , nsDependentCString ( aMIMEType ) , <NEW_LINE>NullableString ( aWindow ) , & result ) ) { <NEW_LINE>NS_RUNTIMEABORT ( "PluginStream constructor failed" ) ; <NEW_LINE> } <NEW_LINE>
if ( installed ) { <NEW_LINE>js::Rooted < JS::Value > v ( cx , <NEW_LINE>args . length ( ) > 0 ? args [ 0 ] : JS::UndefinedValue ( ) ) ; <NEW_LINE>if ( ! ::JS_SetPropertyById ( cx , thisObj , id , v . address ( ) ) ) { <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>args . rval ( ) . setUndefined ( ) ; <NEW_LINE>return true ; <NEW_LINE>
uint16 bitspersample , samplesperpixel = 1 ; <NEW_LINE>uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ; <NEW_LINE>
if ( HTMLCanvasElement ( ) -> IsWriteOnly ( ) && ! nsContentUtils::IsCallerTrustedForRead ( ) ) { <NEW_LINE>
fprintf ( stderr , <NEW_LINE>" - a [ lpha ] < file > . pgm read PNG alpha channel as pgm - file\n" ) ; <NEW_LINE>
<NEW_LINE>if ( ( ! ( frameReflowStatus & NS_INLINE_BREAK_FIRST_LETTER_COMPLETE ) && <NEW_LINE>nsGkAtoms::placeholderFrame != frameType ) || <NEW_LINE> * aLineReflowStatus == LINE_REFLOW_STOP ) { <NEW_LINE>
file -> namelen = MIN ( sizeof file -> name , len ) ; <NEW_LINE>memcpy ( file -> name , d , file -> namelen ) ; <NEW_LINE>
<NEW_LINE>cond_resched ( ) ; <NEW_LINE>
modifier += rounding ; <NEW_LINE>
nsresult rv = UpdateDB ( ) ; <NEW_LINE>
ignore = fscanf ( fp , "Commandfile name: % 511s\n" , buf ) ; <NEW_LINE>
ReentrantMonitorAutoEnter lock ( mDecodingMonitor ) ; <NEW_LINE>
EXPECT_ANY_THROW ( read_ . read ( queue_ ) ) ; <NEW_LINE>
ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; <NEW_LINE>ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; <NEW_LINE>return e_error ; <NEW_LINE>
if ( ( data_length % entry_size ) != 0 ) <NEW_LINE>
* rowp ++ = * -- stackp & mColorMask ; <NEW_LINE>
for ( i = 0 ; i < arr_size ; i ++ ) { <NEW_LINE>
rv = FindInsertionPoint ( & temp , aItem -> GetStartParent ( ) , <NEW_LINE>aItem -> StartOffset ( ) , CompareToRangeStart , <NEW_LINE> & insertionPoint ) ; <NEW_LINE>
ReentrantMonitorAutoEnter lock ( mDecodingMonitor ) ; <NEW_LINE>
const float ** * curves , <NEW_LINE>const float * f , <NEW_LINE>const float * flr , <NEW_LINE>float * seed , <NEW_LINE>float specmax ) { <NEW_LINE>
static v8::Handle < v8::Value > throwNotEnoughArgumentsError ( v8::Isolate * ) ; <NEW_LINE>
png_debug1 ( 1 , "in % lx storage function" , png_ptr == NULL ? 0xabadca11U : <NEW_LINE>
char group [ LONG_STRING ] = "" ; <NEW_LINE>
CallbackWrapper * wrapper = new CallbackWrapper ( callbacks ) ; <NEW_LINE>
int passkey , <NEW_LINE>int entered ) ;
pthread_mutex_destroy ( & bio -> bio_mutex ) ; <NEW_LINE>
const String & descriptorsUUID ) { <NEW_LINE>
nsCopySupport::FireClipboardEvent ( NS_COPY , nsIClipboard::kGlobalClipboard , mPresShell , nullptr ) ; <NEW_LINE>
store_image_row ( const png_store * ps , png_const_structp pp , int nImage , <NEW_LINE>
|| pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
class CONTENT_EXPORT BrowserCompositorMac : public DelegatedFrameHostClient { <NEW_LINE>
JSOp op2 = js_GetOpcode ( cx , script , ++ regs . pc ) ; <NEW_LINE>
const image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE>
return o -> isRenderView ( ) || o -> isOutOfFlowPositioned ( ) || o -> isRelPositioned ( ) || layer -> hasTransform ( ) ; <NEW_LINE>
if ( HTMLCanvasElement ( ) -> IsWriteOnly ( ) && ! IsCallerTrustedForRead ( ) ) { <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>if ( lhs -> lower_infinite_ && rhs -> lower_infinite_ ) <NEW_LINE>r -> makeLowerInfinite ( ) ; <NEW_LINE>if ( lhs -> upper_infinite_ && rhs -> upper_infinite_ ) <NEW_LINE>r -> makeUpperInfinite ( ) ; <NEW_LINE>
if ( row_info -> color_type > 3 ) <NEW_LINE>color_channels -- ; <NEW_LINE>
jas_ulong tmp ; <NEW_LINE>
#ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED <NEW_LINE>
( void ) size ; <NEW_LINE> ( void ) source ; <NEW_LINE>
WebGLVersion webgl_version , <NEW_LINE>
sads [ j ] += mvsad_err_cost ( x , & mv , & fcenter_mv , error_per_bit ) ; <NEW_LINE>
memset ( mv_ref_ct , 0 , sizeof ( mv_ref_ct ) ) ; <NEW_LINE>memset ( mv_mode_cts , 0 , sizeof ( mv_mode_cts ) ) ; <NEW_LINE>
RefPtr < DocumentFragment > fragment = createContextualFragment ( markup , toHTMLElement ( m_element ) , AllowScriptingContent ) ; <NEW_LINE>
memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE>
else if ( ( png_ptr -> mode & PNG_IS_READ_STRUCT ) == 0 ) <NEW_LINE>
if ( ! renderLayer -> renderer ( ) -> isOutOfFlowPositioned ( ) || renderLayer -> renderer ( ) -> style ( ) -> position ( ) != FixedPosition ) <NEW_LINE>
buffer . link ( outOfBounds , slowPathStart ) ; <NEW_LINE>buffer . link ( done , fastPathRejoin ) ; <NEW_LINE>
@stability Evolving <NEW_LINE>
timr -> it_overrun += hrtimer_forward ( timer , timer -> base -> get_time ( ) , <NEW_LINE>timr -> it_interval ) ; <NEW_LINE>
nsIHTMLDocument * doc = static_cast < nsIHTMLDocument * > ( JS_GetPrivate ( obj ) ) ; <NEW_LINE>if ( doc ) { <NEW_LINE>xpc::DeferredRelease ( doc ) ; <NEW_LINE> } <NEW_LINE>
if ( p -> proto == IPPROTO_TCP && pflow -> protoctx != NULL && <NEW_LINE> ( p -> flags & PKT_STREAM_EST ) ) <NEW_LINE> { <NEW_LINE>
m_glContext = glXCreateNewContext ( m_display , m_fbConfigs [ 0 ] , GLX_RGBA_TYPE , shareContextObject , true ) ; <NEW_LINE>
const int qslen = blen - qs ; <NEW_LINE>memmove ( s + j , s + qs , ( size_t ) qslen ) ; <NEW_LINE>qs = j ; <NEW_LINE>j += qslen ; <NEW_LINE>
nsCOMPtr < nsIPresShell > presShell = GetPresShellForContent ( aElement ) ; <NEW_LINE>
m . command = CMD_NONE ; <NEW_LINE>
state -> space_before = fstrndup ( RSTRING_PTR ( space_before ) , len ) ; <NEW_LINE>
while ( ( i < ( int ) header_buf_used ) && ( header_buf [ i ] == '\r' || header_buf [ i ] == '\n' ) ) <NEW_LINE>
std::make_unique < CanonicalCookie > ( <NEW_LINE>
if ( ! current . m_obj -> isFloatingOrOutOfFlowPositioned ( ) ) { <NEW_LINE>
ShortcutsProvider ( AutocompleteProviderListener * listener , Profile * profile ) ;
#if ENABLE_BGP_VNC_ATTR <NEW_LINE>
if ( mMaxTextLength != PR_UINT32_MAX ) { <NEW_LINE>NS_ASSERTION ( mMaxTextLength < PR_UINT32_MAX - aFrame -> GetContentLength ( ) , "integer overflow" ) ; <NEW_LINE>if ( mMaxTextLength >= PR_UINT32_MAX - aFrame -> GetContentLength ( ) ) { <NEW_LINE>mMaxTextLength = PR_UINT32_MAX ; <NEW_LINE> } else { <NEW_LINE>mMaxTextLength += aFrame -> GetContentLength ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
ptr_hbe_txposer -> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <NEW_LINE>ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <NEW_LINE>
tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <NEW_LINE>if ( ! tmp2 ) <NEW_LINE>free ( tmp ) ; <NEW_LINE>tmp = tmp2 ; <NEW_LINE>
strncpy ( rl . type , "larval" , sizeof ( rl . type ) ) ; <NEW_LINE>
store_output ( & out01 , ( output + 0 * 8 ) ) ; <NEW_LINE>store_output ( & out23 , ( output + 1 * 8 ) ) ; <NEW_LINE>
gboolean enableSpellChecking ; <NEW_LINE>g_object_get ( G_OBJECT ( webSettings ) , "enable - spell - checking" , & enableSpellChecking , NULL ) ; <NEW_LINE>if ( enableSpellChecking ) { <NEW_LINE>WebKit::EditorClient * client = static_cast < WebKit::EditorClient * > ( core ( webView ) -> editorClient ( ) ) ; <NEW_LINE>static_cast < WebKit::TextCheckerClientEnchant * > ( client -> textChecker ( ) ) -> updateSpellCheckingLanguage ( g_value_get_string ( & value ) ) ; <NEW_LINE> } <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
explicit ShellContentUtilityClient ( bool is_browsertest = false ) ; <NEW_LINE>
if ( sessionClosing_ != ClosingState::CLOSED && streamId > lastStreamID_ ) { <NEW_LINE>
return mStorage -> CanAccess ( aPrincipal ) ; <NEW_LINE>
class BASE_API FileVersionInfo { <NEW_LINE>
strncpy ( racomp . type , "acomp" , sizeof ( racomp . type ) ) ; <NEW_LINE>
#include "platform / mediastream / MediaStreamSource . h" <NEW_LINE>
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) ) <NEW_LINE>
#include "sfntly / port / type . h" <NEW_LINE>
for ( cp = stok ( query , " " , & tok ) ; cp != NULL && argp != NULL ; ) { <NEW_LINE>
if ( getChannels ( ) == 0 || getChannels ( ) > kMaxChannels ) { <NEW_LINE>
void Focus ( LocalFrame * ) override { } <NEW_LINE>
handle -> event -> pending_wakeup = 1 ; <NEW_LINE>irq_work_queue ( & handle -> event -> pending ) ; <NEW_LINE>
new WebAudioDecodeJob ( contentType , this ) ; <NEW_LINE>
PREDICTION_MODE mode ; <NEW_LINE>
<NEW_LINE>
this , change_unpack_params ) ; <NEW_LINE>
BufferMeta * buffer_meta = new BufferMeta ( params , portIndex , true ) ; <NEW_LINE>
if ( GetNativeGlobal ( ) ) { <NEW_LINE>JSAutoCompartment ac ( mContext , GetNativeGlobal ( ) ) ; <NEW_LINE>JS_MaybeGC ( mContext ) ; <NEW_LINE> } <NEW_LINE>
len = file && file -> size > 0 ? file -> size : 4096 ; <NEW_LINE>
return lookup ( str , length , state -> hash_seed ( ) ) ; <NEW_LINE>
<NEW_LINE> ( * psig ) = s + padlen + 3 ; <NEW_LINE><NEW_LINE><NEW_LINE> { <NEW_LINE>const u_char * p ; <NEW_LINE>size_t cnt_ffs = 0 ; <NEW_LINE><NEW_LINE>for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) <NEW_LINE>if ( * p == 0xFF ) <NEW_LINE>cnt_ffs ++ ; <NEW_LINE><NEW_LINE>if ( cnt_ffs != padlen ) <NEW_LINE>return "4" "invalid Padding String" ; <NEW_LINE> } <NEW_LINE>
# error "libpng requires an unsigned 16 - bit type" <NEW_LINE>
virtual ~ MockConnectionVisitor ( ) ; <NEW_LINE>
if ( ctxt -> input -> cur - ctxt -> input -> base < len ) { <NEW_LINE><NEW_LINE>htmlParseErr ( ctxt , XML_ERR_INTERNAL_ERROR , <NEW_LINE>"unexpected change of input buffer" , NULL , NULL ) ; <NEW_LINE>return ( NULL ) ; <NEW_LINE> } <NEW_LINE>
if ( ! childFrame || childFrame -> GetContent ( ) != aChild ) { <NEW_LINE><NEW_LINE><NEW_LINE>
memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <NEW_LINE>
if ( inchar != c ) <NEW_LINE>
size = ( ssize ) httpGetNumber ( mprReadJson ( prop , "size" ) ) ; <NEW_LINE>format = mprReadJson ( prop , "format" ) ; <NEW_LINE>formatter = mprReadJson ( prop , "formatter" ) ; <NEW_LINE>location = mprReadJson ( prop , "location" ) ; <NEW_LINE>level = ( char ) stoi ( mprReadJson ( prop , "level" ) ) ; <NEW_LINE>backup = ( int ) stoi ( mprReadJson ( prop , "backup" ) ) ; <NEW_LINE>anew = smatch ( mprReadJson ( prop , "anew" ) , "true" ) ; <NEW_LINE>maxContent = ( ssize ) httpGetNumber ( mprReadJson ( prop , "content" ) ) ; <NEW_LINE>
mWebGLError = LOCAL_GL_NO_ERROR ; <NEW_LINE>
if ( ( 1 != ps_dec_state -> u2_decode_header ) && <NEW_LINE> ( ( ( bytes_remaining > 0 ) && ( 1 == ps_dec_state -> u2_header_done ) ) || ps_dec_state -> u1_flushfrm ) ) <NEW_LINE>
JSObject ** aClassObject , bool * aNew ) <NEW_LINE>
: capacity ( capacity ) , initializedLength ( 0 ) , length ( length ) , flags ( 0 ) <NEW_LINE>
nsSize reflowSize ( size . width , NS_UNCONSTRAINEDSIZE ) ; <NEW_LINE>
TransformChange transformChange = calculateLocalTransform ( ) ; <NEW_LINE>m_didScreenScaleFactorChange = <NEW_LINE>transformChange == TransformChange::Full || SVGLayoutSupport::screenScaleFactorChanged ( parent ( ) ) ; <NEW_LINE>
const char * base_path = NULL ; <NEW_LINE>
if ( ! ( child -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) ) { <NEW_LINE>
if ( num_head < LONG_MAX / ( long ) sizeof ( u_header_T * ) ) <NEW_LINE>uhp_table = ( u_header_T ** ) U_ALLOC_LINE ( <NEW_LINE>
byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) , strmLen ) ; <NEW_LINE>
FilterSetter < Policy > ( cx , wrapper , id , desc ) ; <NEW_LINE>return true ; <NEW_LINE>
cx -> compartment -> wrap ( cx , vp ) ) ; <NEW_LINE>
int32_t sessionId __unused , <NEW_LINE>int32_t ioId __unused , <NEW_LINE>
if ( prev && prev -> isBlockFlow ( ) && ! prev -> isFloatingOrOutOfFlowPositioned ( ) ) { <NEW_LINE>
size_t inliningDepth_ ; <NEW_LINE>
PHP_FUNCTION ( locale_get_display_name ) <NEW_LINE>
ret = snprintf ( dest , len , " % s / lxc / lock / % s" , rundir , p ) ; <NEW_LINE>
nsCOMPtr < nsPIDOMWindow > innerWindow = static_cast < nsPIDOMWindow * > <NEW_LINE> ( nsGlobalWindow::GetInnerWindowWithId ( req -> InnerWindowID ( ) ) ) ; <NEW_LINE>
static nsresult getXSLTId ( const txXPathNode & aNode , <NEW_LINE>const txXPathNode & aBase , nsAString & aResult ) ; <NEW_LINE>
RefPtr < SharedBuffer > data = readFile ( layoutTestResourcesDir , "animated - gif - with - offsets . gif" ) ; <NEW_LINE>
if ( ! WriteToContainedDecoder ( aBuffer , toFeed , aStrategy ) ) { <NEW_LINE>
#line 1286 "ext / standard / var_unserializer . c" <NEW_LINE>
xmlSchemaSetParserErrors ( ctxt , testErrorHandler , testErrorHandler , <NEW_LINE>ctxt ) ; <NEW_LINE>
if ( ! setDecodeArgs ( & s_dec_ip , & s_dec_op , inHeader , outHeader , timeStampIx ) ) { <NEW_LINE>ALOGE ( "Decoder arg setup failed" ) ; <NEW_LINE>notify ( OMX_EventError , OMX_ErrorUndefined , 0 , NULL ) ; <NEW_LINE>mSignalledError = true ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
return box -> height ( ) && box -> style ( ) -> visibility ( ) == VISIBLE && ! box -> isFloatingOrOutOfFlowPositioned ( ) ; <NEW_LINE>
class ExtensionInfoBar : public InfoBarView , <NEW_LINE>
if ( detect_transition_to_still ( cpi , i , cpi -> oxcf . key_freq - i , <NEW_LINE>
#include "core / rendering / style / StyleDifference . h" <NEW_LINE>
for ( i = LAST_FRAME ; i < MAX_REF_FRAMES ; ++ i ) <NEW_LINE>vp8_yv12_copy_frame ( cpi -> Source , <NEW_LINE> & cpi -> denoiser . yv12_running_avg [ i ] ) ; <NEW_LINE>
rv = zsocket_bind ( * sock , " % s" , info -> description ) ; <NEW_LINE>
nsPIDOMWindow * pwin = mDocument -> GetInnerWindow ( ) ; <NEW_LINE>if ( ! pwin || ! pwin -> IsInnerWindow ( ) ) { <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE>nsCOMPtr < nsIScriptGlobalObject > globalObject = do_QueryInterface ( pwin ) ; <NEW_LINE>NS_ASSERTION ( globalObject , "windows must be global objects" ) ; <NEW_LINE>
static already_AddRefed < MediaResource > Create ( MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <NEW_LINE>
virtual void WriteInternal ( const char * aBuffer , uint32_t aCount , DecodeStrategy aStrategy ) ; <NEW_LINE>
int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <NEW_LINE>
if ( png_crc_finish ( png_ptr , 0 ) != 0 ) <NEW_LINE>
RootedObject obj ( cx , GetProxyTargetObject ( proxy ) ) ; <NEW_LINE>return CheckDefineProperty ( cx , obj , RootedId ( cx , id ) , RootedValue ( cx , desc -> value ) , <NEW_LINE>desc -> getter , desc -> setter , desc -> attrs ) && <NEW_LINE>JS_DefinePropertyById ( cx , obj , id , desc -> value , desc -> getter , desc -> setter , <NEW_LINE>
do ret = TEMP_FAILURE_RETRY ( send ( sock_fd , buf , s , 0 ) ) ; <NEW_LINE>
if ( cluster_stop >= 0 && pos > cluster_stop ) <NEW_LINE>return E_FILE_FORMAT_INVALID ; <NEW_LINE>
if ( ( png_ptr -> mode & PNG_HAVE_IHDR ) != 0 ) <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
if ( ! inItemArray . AppendElement ( do_GetWeakReference ( inItem ) ) ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE>
<NEW_LINE>virtual DWORD GetProcessId ( ) const = 0 ; <NEW_LINE><NEW_LINE><NEW_LINE>virtual bool IsPermanentError ( int failure_count ) const = 0 ;
#ifndef BASE_TEST_SEQUENCED_WORKER_POOL_OWNER_H_ <NEW_LINE>#define BASE_TEST_SEQUENCED_WORKER_POOL_OWNER_H_ <NEW_LINE>
if ( param2 < 0 || param2 >= NUM_EQ_BANDS ) { <NEW_LINE>p -> status = - EINVAL ; <NEW_LINE>if ( param2 < 0 ) { <NEW_LINE>android_errorWriteLog ( 0x534e4554 , "32436341" ) ; <NEW_LINE>ALOGW ( "\tERROR EQ_PARAM_CENTER_FREQ band % d" , param2 ) ; <NEW_LINE> } <NEW_LINE>
clip_mask -> background_color . alpha = ( MagickRealType ) TransparentAlpha ; <NEW_LINE>
if ( ( status = lstat ( filename , filestats ) ) != 0 ) <NEW_LINE>
result = newTexture -> GetSurfaceLevel ( levelToFetch , & newSurface ) ; <NEW_LINE><NEW_LINE>if ( FAILED ( result ) ) <NEW_LINE> { <NEW_LINE>return error ( GL_OUT_OF_MEMORY ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
static int CVE_2011_1833_ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options , <NEW_LINE>uid_t * check_ruid ) <NEW_LINE>
* replySize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + sizeof ( uint16_t ) ) || <NEW_LINE><NEW_LINE> ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t ) ) { <NEW_LINE>
rc -> optimal_buffer_level / 100 ) ; <NEW_LINE>
class PasswordGenerationController ; <NEW_LINE>
result = js_regexec ( re -> prog , text , & m , opts ) ; <NEW_LINE>if ( result < 0 ) <NEW_LINE>js_error ( J , "regexec failed" ) ; <NEW_LINE>if ( result == 0 ) { <NEW_LINE>
ZEND_BEGIN_ARG_INFO_EX ( arginfo_r_dir___construct , 0 , 0 , 1 ) <NEW_LINE>
Chapters::Chapters ( ) : chapters_size_ ( 0 ) , chapters_count_ ( 0 ) , chapters_ ( NULL ) { } <NEW_LINE>
if ( ( png_ptr -> flags & PNG_FLAG_ROW_INIT ) == 0 ) <NEW_LINE>
BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; <NEW_LINE>
#endif <NEW_LINE>
<NEW_LINE>
<NEW_LINE>inline bool SafeAddInt32 ( int32 a , int32 b , int32 * dst ) { <NEW_LINE>int64 sum64 = static_cast < int64 > ( a ) + b ; <NEW_LINE>int32 sum32 = static_cast < int32 > ( sum64 ) ; <NEW_LINE>bool safe = sum64 == static_cast < int64 > ( sum32 ) ; <NEW_LINE> * dst = safe ? sum32 : 0 ; <NEW_LINE>return safe ; <NEW_LINE>
if ( safe_mount ( "cgroup" , cgpath , "tmpfs" , 0 , "size = 10000 , mode = 755" , root ) ) { <NEW_LINE>
<NEW_LINE> { <NEW_LINE>int * sortpointer [ VIF_POSIT + 2 ] ; <NEW_LINE>for ( j = 0 ; j < count + 2 ; j ++ ) sortpointer [ j ] = info -> postlist + j ; <NEW_LINE>qsort ( sortpointer , count + 2 , sizeof ( * sortpointer ) , icomp ) ; <NEW_LINE><NEW_LINE>for ( j = 1 ; j < count + 2 ; j ++ ) <NEW_LINE>if ( * sortpointer [ j - 1 ] == * sortpointer [ j ] ) goto err_out ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
IsTransparent ( JSContext * cx , JSObject * wrapper , jsid id ) ; <NEW_LINE>
bool <NEW_LINE>JSObject::reportReadOnly ( JSContext * cx , jsid id , unsigned report ) <NEW_LINE>
c_prev = prev -> yChan ; <NEW_LINE>if ( ! c_prev ) { <NEW_LINE>ALOGE ( "b / 35269635" ) ; <NEW_LINE>android_errorWriteLog ( 0x534e4554 , "35269635" ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>c_prev += offset ; <NEW_LINE><NEW_LINE>
<NEW_LINE>
<NEW_LINE>
if ( mAppliedVBs [ i ] . serial != attributes [ i ] . serial || <NEW_LINE>mAppliedVBs [ i ] . stride != attributes [ i ] . stride || <NEW_LINE>mAppliedVBs [ i ] . offset != attributes [ i ] . offset ) <NEW_LINE> { <NEW_LINE>device -> SetStreamSource ( i , attributes [ i ] . vertexBuffer , attributes [ i ] . offset , attributes [ i ] . stride ) ; <NEW_LINE>mAppliedVBs [ i ] . serial = attributes [ i ] . serial ; <NEW_LINE>mAppliedVBs [ i ] . stride = attributes [ i ] . stride ; <NEW_LINE>mAppliedVBs [ i ] . offset = attributes [ i ] . offset ; <NEW_LINE> } <NEW_LINE>
if ( c . for_write != 0 ) <NEW_LINE>
982 , 986 , 987 , 991 , 992 , 996 , 1021 , 1026 , 1034 , 1035 , <NEW_LINE>1039 , 1040 , 1041 , 1042 , 1046 , 1047 , 1048 , 1058 , 1059 , 1063 , <NEW_LINE>1065 , 1070 , 1072 , 1076 , 1081 , 1082 , 1086 , 1087 , 1091 , 1100 , <NEW_LINE>1101 , 1105 , 1106 , 1115 , 1130 , 1134 , 1135 , 1139 , 1140 , 1144 , <NEW_LINE>1145 , 1149 , 1154 , 1158 , 1162 , 1163 , 1167 , 1172 , 1173 , 1177 , <NEW_LINE>1179 , 1181 , 1183 , 1185 <NEW_LINE>
* best_mv = tmp_mv ; <NEW_LINE>
String ret ( <NEW_LINE>safe_address ( <NEW_LINE>chunks + 1 , <NEW_LINE>endlen , <NEW_LINE>srclen <NEW_LINE> ) , <NEW_LINE>ReserveString <NEW_LINE> ) ; <NEW_LINE>
AutoPushJSContext cx ( sc -> GetNativeContext ( ) ) ; <NEW_LINE>
const int bgr = ( image -> format & PNG_FORMAT_FLAG_BGR ) != 0 ? 2 : 0 ; <NEW_LINE>
if ( pCP == NULL ) <NEW_LINE>return false ; <NEW_LINE>
<NEW_LINE>atoms = script -> atomMap . vector ; <NEW_LINE><NEW_LINE>
<NEW_LINE>if ( cpkt . length != 16 ) { <NEW_LINE>fprintf ( stderr , _ ( "Invalid salt length: % d ( instead of 16 ) received from server % s\n" ) , cpkt . length , ether_ntoa ( ( struct ether_addr * ) dstmac ) ) ; <NEW_LINE> } <NEW_LINE>memcpy ( pass_salt , cpkt . data , 16 ) ; <NEW_LINE>
<NEW_LINE>if ( aNamespaceID == kNameSpaceID_XMLEvents && <NEW_LINE>aName == nsGkAtoms::event && mNodeInfo -> GetDocument ( ) ) { <NEW_LINE>mNodeInfo -> GetDocument ( ) -> AddXMLEventsContent ( this ) ; <NEW_LINE> } <NEW_LINE>if ( aValueForAfterSetAttr ) { <NEW_LINE>rv = AfterSetAttr ( aNamespaceID , aName , aValueForAfterSetAttr , aNotify ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result , <NEW_LINE>nsIChannel ** channel ) ; <NEW_LINE>
if ( boundFunction -> IsUndefined ( ) && functionScopes ( context , function ) . ToLocal ( & scopes ) ) { <NEW_LINE>
nsresult rv = proxyEnv . getOrSetFakeOrigin ( ( nsCSecurityContext * ) securityContext ) ; <NEW_LINE>if ( NS_SUCCEEDED ( rv ) ) <NEW_LINE>secureEnv -> SetField ( field -> mFieldType , obj , field -> mFieldID , value , securityContext ) ; <NEW_LINE>
CryptoKey & session_key , <NEW_LINE>std::unique_ptr < AuthAuthorizerChallenge > * challenge ) { <NEW_LINE>return false ; <NEW_LINE> }
if ( ( memory_info -> blob == NULL ) && <NEW_LINE> ( AcquireMagickResource ( DiskResource , length ) != MagickFalse ) ) <NEW_LINE>
if ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft != NULL ) <NEW_LINE> ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) ( u_in , u_out , <NEW_LINE>anal_size * 2 ) ; <NEW_LINE>
source = ssplit ( sclone ( item -> value ) , ":" , & kind ) ; <NEW_LINE>if ( * kind == '\0' ) { <NEW_LINE>kind = "controller" ; <NEW_LINE> } <NEW_LINE>
#line 500 "ext / standard / var_unserializer . re" <NEW_LINE>
m_blobDataHandles . set ( file -> uuid ( ) , file -> blobDataHandle ( ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>nsCOMPtr < nsIPrincipal > ownerPrincipal ; <NEW_LINE>uint32_t sandboxFlags = doc -> GetSandboxFlags ( ) ; <NEW_LINE>if ( sandboxFlags & SANDBOXED_ORIGIN ) { <NEW_LINE>ownerPrincipal = do_CreateInstance ( "@mozilla . org / nullprincipal ; 1" ) ; <NEW_LINE> } else { <NEW_LINE><NEW_LINE>ownerPrincipal = thisContent -> NodePrincipal ( ) ; <NEW_LINE> } <NEW_LINE>nsContentUtils::SetUpChannelOwner ( ownerPrincipal , chan , mURI , true , <NEW_LINE>sandboxFlags & SANDBOXED_ORIGIN ) ; <NEW_LINE>
SSL_TRC ( 3 , ( " % d: SSL3 [ % d ] : handle session_ticket handshake during % s handshake" , <NEW_LINE>SSL_GETPID ( ) , ss -> fd , <NEW_LINE>ss -> ssl3 . hs . isResuming ? "resumption" : "full" ) ) ; <NEW_LINE>
int64 iskew = ( int64 ) imagew - ( int64 ) tilew ; <NEW_LINE>
if ( gl -> WorkAroundDriverBugs ( ) && <NEW_LINE>program -> UpperBoundNumSamplerUniforms ( ) > 16 ) <NEW_LINE> { <NEW_LINE>
if ( best_mode_index >= 0 && <NEW_LINE>best_mbmode . ref_frame [ 0 ] > INTRA_FRAME ) <NEW_LINE>
}
decoder -> name , vpx_codec_iface_name ( decoder -> codec_interface ( ) ) ) ; <NEW_LINE>
bool isOutOfFlowPositionedWithSpecifiedHeight = cb -> isOutOfFlowPositioned ( ) && ( ! cbstyle -> logicalHeight ( ) . isAuto ( ) || ( ! cbstyle -> top ( ) . isAuto ( ) && ! cbstyle -> bottom ( ) . isAuto ( ) ) ) ; <NEW_LINE>
* p_tx0 = ( OPJ_INT32 ) opj_uint_max ( p_cp -> tx0 + p * p_cp -> tdx , p_image -> x0 ) ; <NEW_LINE> * p_tx1 = ( OPJ_INT32 ) opj_uint_min ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx , p_image -> x1 ) ; <NEW_LINE> * p_ty0 = ( OPJ_INT32 ) opj_uint_max ( p_cp -> ty0 + q * p_cp -> tdy , p_image -> y0 ) ; <NEW_LINE> * p_ty1 = ( OPJ_INT32 ) opj_uint_min ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy , p_image -> y1 ) ; <NEW_LINE>
NeedsWaive ( JSContext * cx , JSObject * wrapper , jsid id ) <NEW_LINE>
<NEW_LINE><NEW_LINE>
memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ; <NEW_LINE>
if ( sc_select_file ( card , & prkey_info . path , & f ) != SC_SUCCESS <NEW_LINE> || ! f -> prop_attr || f -> prop_attr_len < 2 ) { <NEW_LINE>
<NEW_LINE>while ( * end_ptr != '\"' && * end_ptr && ++ len ) <NEW_LINE> { <NEW_LINE>if ( * end_ptr ++ == '\\' ) <NEW_LINE> { <NEW_LINE>if ( * end_ptr == '\0' ) <NEW_LINE> { <NEW_LINE><NEW_LINE>return 0 ; <NEW_LINE> } <NEW_LINE>end_ptr ++ ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE><NEW_LINE>
vpx_clear_system_state ( ) ; <NEW_LINE>
xmlRelaxNGSetParserErrors ( pctxt , testErrorHandler , testErrorHandler , <NEW_LINE>pctxt ) ; <NEW_LINE>
goto err ; <NEW_LINE>
if ( IS_ENABLED ( CONFIG_SPL_GZIP ) ) { <NEW_LINE>fit_image_get_comp ( fit , node , & image_comp ) ; <NEW_LINE>debug ( " % s " , genimg_get_comp_name ( image_comp ) ) ; <NEW_LINE>
<NEW_LINE>void DoError ( ) ; <NEW_LINE><NEW_LINE>class HandleErrorWorker : public nsRunnable <NEW_LINE> { <NEW_LINE>public: <NEW_LINE><NEW_LINE>static void DispatchIfNeeded ( RasterImage * aImage ) ; <NEW_LINE><NEW_LINE>NS_IMETHOD Run ( ) ; <NEW_LINE><NEW_LINE>private: <NEW_LINE>HandleErrorWorker ( RasterImage * aImage ) ; <NEW_LINE><NEW_LINE>nsRefPtr < RasterImage > mImage ; <NEW_LINE> } ; <NEW_LINE><NEW_LINE>
<NEW_LINE>
return vp9_is_valid_scale ( sf ) && <NEW_LINE> ( sf -> x_scale_fp != REF_NO_SCALE || sf -> y_scale_fp != REF_NO_SCALE ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>static INLINE int valid_ref_frame_size ( int ref_width , int ref_height , <NEW_LINE>int this_width , int this_height ) { <NEW_LINE>return 2 * this_width >= ref_width && <NEW_LINE>2 * this_height >= ref_height && <NEW_LINE>this_width <= 16 * ref_width && <NEW_LINE>this_height <= 16 * ref_height ; <NEW_LINE>
auto const port_str = folly::to < std::string > ( port ) ; <NEW_LINE>auto const key_len = strlen ( hostname ) + 1 + port_str . length ( ) ; <NEW_LINE>auto key = String ( key_len , ReserveString ) ; <NEW_LINE>key += hostname ; <NEW_LINE>key += ":" ; <NEW_LINE>key += port_str ; <NEW_LINE>return_val . set ( key , server_stats ) ; <NEW_LINE>
if ( ( png_ptr -> row_number & 1 ) == 0 ) <NEW_LINE>
<NEW_LINE>scoped_ptr < SyncSessionJob > pending_nudge_ ; <NEW_LINE>
cx -> rsasiglen = sig -> len ; <NEW_LINE>if ( cx -> rsasiglen > sizeof ( cx -> u . rsasig ) ) { <NEW_LINE>PORT_SetError ( SEC_ERROR_INPUT_LEN ) ; <NEW_LINE>rv = SECFailure ; <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>if ( cx -> hashAlg == SEC_OID_UNKNOWN ) { <NEW_LINE>rv = GetAlgorithmForUnknownDigestInfo ( cx -> key , sig , <NEW_LINE> & cx -> hashAlg , wincx ) ; <NEW_LINE> } <NEW_LINE>
const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) cospi_16_64 ) ; <NEW_LINE>
( ptr ) = H264SwDecMalloc ( sizeof ( type ) , ( count ) ) ; \ <NEW_LINE>
<NEW_LINE><NEW_LINE>
bool CopyMetafileDataToReadOnlySharedMem ( <NEW_LINE>const PdfMetafileSkia & metafile , <NEW_LINE>base::SharedMemoryHandle * read_only_shared_mem_handle ) ; <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
{ <NEW_LINE>if ( color_image != ( Image * ) NULL ) <NEW_LINE>color_image = DestroyImage ( color_image ) ; <NEW_LINE>if ( color_image_info != ( Image * ) NULL ) <NEW_LINE>color_image_info = DestroyImageInfo ( color_image_info ) ; <NEW_LINE>ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; <NEW_LINE> } <NEW_LINE>
#line 118 "hex_grammar . c" <NEW_LINE>
AutoPushJSContext cx ( GetJSContextFromNPP ( npp ) ) ; <NEW_LINE>
mPort ( 0 ) , <NEW_LINE>mIsCertIssuerBlacklisted ( PR_FALSE ) <NEW_LINE>
if ( snprintf ( result , 499 , "result / pattern / % s" , baseFilename ( xml ) ) >= 499 ) <NEW_LINE>result [ 499 ] = 0 ; <NEW_LINE>
case 4: <NEW_LINE>
memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ; <NEW_LINE>
mime = ssplit ( sclone ( mime ) , " ; " , 0 ) ; <NEW_LINE>
if ( ! err ) { <NEW_LINE>bh = head ; <NEW_LINE>do { <NEW_LINE>if ( buffer_new ( bh ) ) <NEW_LINE>clear_buffer_new ( bh ) ; <NEW_LINE> } while ( ( bh = bh -> b_this_page ) != head ) ; <NEW_LINE>return 0 ; <NEW_LINE> } <NEW_LINE>
nsresult InitBasic ( ) ; <NEW_LINE>
break ; <NEW_LINE>
if ( IsValidColormapIndex ( image , ( ssize_t ) ( * p & mask ) , & index , exception ) == <NEW_LINE>
nsRefPtrHashtable < nsVoidPtrHashKey , nsDOMWorkerPool > mPools ; <NEW_LINE>
if ( lose ) <NEW_LINE>goto trunc ; <NEW_LINE>
char * err_msg ; <NEW_LINE>
RefPtr < TestNode > imp = WTF::getPtr ( proxyImp -> location ( ) ) ; <NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
AutoCompartment ac ( cx , cx -> runtime ( ) -> atomsCompartment ) ; <NEW_LINE>
CHAR_LEN_TABLE ( SJISCharLenTable ) , <NEW_LINE>
if ( syscall_nr < 0 || syscall_nr >= NR_syscalls ) <NEW_LINE>
sprintf ( c_path , " % s % s % d_C_XXXXXX" , HSM_FM_SCK_PREFIX , mgr_prefix , hdl -> instance ) ;
return 1 ; <NEW_LINE>
if ( flags & CMS_DEBUG_DECRYPT ) <NEW_LINE>cms -> d . envelopedData -> encryptedContentInfo -> debug = 1 ; <NEW_LINE>else <NEW_LINE>cms -> d . envelopedData -> encryptedContentInfo -> debug = 0 ; <NEW_LINE>if ( ! pk && ! cert && ! dcont && ! out ) <NEW_LINE>return 1 ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
GenerateGetTypedArrayElement ( cx , masm , attacher , tarr , idval , object ( ) , index ( ) , output ( ) , <NEW_LINE>allowDoubleResult ( ) ) ; <NEW_LINE>
if ( have_alpha != 0 ) <NEW_LINE>
Total += vpx_mse16x16 ( src + j , source -> y_stride , <NEW_LINE>
<NEW_LINE>
inline Lookup getLookup ( ) const ; <NEW_LINE>
return mprReadJson ( obj , key ) ; <NEW_LINE>
int flag , <NEW_LINE>int uvfilter ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>error = gl -> GetAndClearError ( ) ; <NEW_LINE>
nsIScriptGlobalObject * global = document -> GetScopeObject ( ) ; <NEW_LINE>
memcpy ( dest , source , dest_width ) ; <NEW_LINE>
<NEW_LINE>
return mount_entry_on_generic ( mntent , mntent -> mnt_dir , NULL ) ; <NEW_LINE>
efree ( ent1 ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
DISALLOW_IMPLICIT_CONSTRUCTORS ( AutoLock ) ; <NEW_LINE>
const YV12_BUFFER_CONFIG * const frame = pbi -> common . frame_to_show ; <NEW_LINE>if ( frame == NULL ) return VPX_CODEC_ERROR ; <NEW_LINE> * corrupted = frame -> corrupted ; <NEW_LINE>
nsCOMPtr < nsIURI > baseURI = GetBaseURI ( ) ; <NEW_LINE>
nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE>
( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_GAMMA ) != 0 && <NEW_LINE>
switch ( addr_len ) { <NEW_LINE>
SSL_TRC ( 3 , ( " % d: SSL3 [ % d ] : send session_ticket handshake during % s handshake" , <NEW_LINE>SSL_GETPID ( ) , ss -> fd , <NEW_LINE>ss -> ssl3 . hs . isResuming ? "resumption" : "full" ) ) ; <NEW_LINE>
if ( ! jas_safe_size_mul3 ( info -> width , info -> height , info -> numplanes , <NEW_LINE> & num_samples ) ) { <NEW_LINE>jas_eprintf ( "image size too large\n" ) ; <NEW_LINE>goto error ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( opts . max_samples > 0 && num_samples > opts . max_samples ) { <NEW_LINE>jas_eprintf ( "maximum number of pixels exceeded ( % zu ) \n" , <NEW_LINE>opts . max_samples ) ; <NEW_LINE>goto error ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
<NEW_LINE>
void Focus ( LocalFrame * ) override ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
<NEW_LINE>if ( mListenerManager ) { <NEW_LINE>mListenerManager -> Disconnect ( ) ; <NEW_LINE>mListenerManager = nsnull ; <NEW_LINE> } <NEW_LINE>
sWebSocketAdmissions -> SessionCount ( ) < kLingeringCloseThreshold ) {
<NEW_LINE>OfflineCacheUpdateChild::Send__delete__ ( this ) ; <NEW_LINE>
if ( mHasTimeToSample || data_size < 8 ) { <NEW_LINE>
if ( safe_mount ( "proc" , path , "proc" , 0 , NULL , rootfs ) < 0 ) <NEW_LINE>
<NEW_LINE>int64 GetModificationTime ( ) const ;
if ( it -> state ( ) != BlackBerry::Platform::TouchPoint::TouchReleased ) { <NEW_LINE>it -> updateState ( BlackBerry::Platform::TouchPoint::TouchStationary ) ; <NEW_LINE>
comm_event -> event_id . header . size , 0 ) ; <NEW_LINE>
} else if ( ( child = mprReadJsonObj ( obj , property ) ) == 0 ) { <NEW_LINE>
extern int parse_rock_ridge_inode ( struct iso_directory_record * , struct inode * , int relocated ) ; <NEW_LINE>
option = ssplit ( option , " = \t , " , & ovalue ) ; <NEW_LINE>
if ( aFontData ) { <NEW_LINE>NS_Free ( ( void * ) aFontData ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
m_data -> context -> DrawEllipticArc ( rect . x ( ) , rect . y ( ) , rect . width ( ) , rect . height ( ) , startAngle , startAngle + angleSpan ) ; <NEW_LINE>
} <NEW_LINE>
else_len = compile_length_tree ( Else , reg ) ; <NEW_LINE>if ( else_len < 0 ) return else_len ; <NEW_LINE> } <NEW_LINE>else <NEW_LINE>else_len = 0 ; <NEW_LINE>r = add_op ( reg , OP_JUMP ) ; <NEW_LINE>if ( r != 0 ) return r ; <NEW_LINE>COP ( reg ) -> jump . addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP ; <NEW_LINE><NEW_LINE>r = add_op ( reg , OP_ATOMIC_END ) ; <NEW_LINE>if ( r != 0 ) return r ; <NEW_LINE><NEW_LINE>if ( IS_NOT_NULL ( Else ) ) { <NEW_LINE>
<NEW_LINE><NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
const sp < IMediaPlayerService > service ( getMediaPlayerService ( ) ) ; <NEW_LINE>
CheckedInt32 requiredBytes = CheckedInt32 ( aWidth ) * CheckedInt32 ( aHeight ) * 4 ; <NEW_LINE>if ( MOZ_UNLIKELY ( ! requiredBytes . isValid ( ) ) ) { <NEW_LINE>
if ( GetStyleSheet ( ) ) { <NEW_LINE>nsCOMPtr < nsIDOMStyleSheet > ss ( do_QueryInterface ( GetStyleSheet ( ) ) ) ; <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
if ( diff . hasNoChange ( ) || ! oldStyle ) <NEW_LINE>
IDBObjectStore::ClearCloneReadInfo ( mCloneReadInfo ) ; <NEW_LINE>
nsCOMPtr < nsIContent > content = do_QueryReferent ( mContent ) ; <NEW_LINE>nsIPresShell * presShell = nsContentUtils::FindPresShellForDocument ( content -> OwnerDoc ( ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>mElements . RemoveObject ( aContent ) ; <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
float amp , float ampoffset ) { <NEW_LINE>
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE>
p_oggpacket -> packet , p_oggpacket -> bytes ) ; <NEW_LINE>
if ( ! PPEEK_IS ( ' ) ' ) ) { <NEW_LINE>r = ONIGERR_INVALID_GROUP_NAME ; <NEW_LINE>onig_scan_env_set_error_string ( env , r , p - 1 , p + 1 ) ; <NEW_LINE>return r ; <NEW_LINE> } <NEW_LINE>
nsresult Init ( nsGlobalWindow * aWindow , PRBool * aIsInterval , <NEW_LINE>
if ( png_ptr -> transformations != 0 ) <NEW_LINE>
std::vector < uint8 > scanline_ ; <NEW_LINE>
store_image_check ( const png_store * ps , png_const_structp pp , int iImage ) <NEW_LINE>
void AddSharedWorker ( const GURL & worker , <NEW_LINE>const std::string & name , <NEW_LINE>const url::Origin & constructor_origin ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( ! SetupCairoFont ( aContext ) ) { <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE>
p_chk -> strf . vids . p_bih = malloc ( __MAX ( p_chk -> common . i_chunk_size , <NEW_LINE>sizeof ( * p_chk -> strf . vids . p_bih ) ) ) ; <NEW_LINE>
<NEW_LINE>if ( targetContent ) { <NEW_LINE>nsIAtom * tag = targetContent -> Tag ( ) ; <NEW_LINE>if ( tag == nsXULAtoms::menu || tag == nsXULAtoms::menuitem ) <NEW_LINE>return NS_OK ; <NEW_LINE> } <NEW_LINE>
while ( curr && ! ( curr -> isInline ( ) || curr -> isFloatingOrOutOfFlowPositioned ( ) ) ) <NEW_LINE>
if ( ppc ) { <NEW_LINE>if ( fp -> hasImacropc ( ) ) <NEW_LINE> * ppc = fp -> imacropc ( ) ; <NEW_LINE>else <NEW_LINE> * ppc = fp -> pcQuadratic ( * this ) ; <NEW_LINE> } <NEW_LINE>
bool AttachSession ( DevToolsSession * session ) override ; <NEW_LINE>
}
void GetSettingsWithUI ( gfx::NativeView parent_view , <NEW_LINE>
static int <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>bool CanCaptureVisiblePage ( const GURL & document_url , <NEW_LINE>const Extension * extension , <NEW_LINE>int tab_id , <NEW_LINE>std::string * error ) const ; <NEW_LINE>
if ( ptr_hbe_txposer -> k_start < 0 ) { <NEW_LINE>return - 1 ; <NEW_LINE> } <NEW_LINE>
if ( sc_select_file ( card , & pin_info . path , & f ) != SC_SUCCESS <NEW_LINE> || ! f -> prop_attr || f -> prop_attr_len < 4 ) { <NEW_LINE>
JSObject * GetJSObject ( ) ; <NEW_LINE>JSObject * GetJSObjectPreserveColor ( ) const ; <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
vp9_ppflags_t flags ; <NEW_LINE>vp9_zero ( flags ) ; <NEW_LINE>
<NEW_LINE>
#define BUILD_REVISION 778 <NEW_LINE>
JS::AutoEnterFrameCompartment ac ; <NEW_LINE>if ( ac . enter ( cx , fp ) ) <NEW_LINE>
const bool is_incognito_ ; <NEW_LINE>const bool is_valid_ssl_ ; <NEW_LINE>const bool is_browser_window_active_ ; <NEW_LINE>
typedef Member < ResultType > StorageType ; <NEW_LINE>
CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ; <NEW_LINE>
if ( m_scrollableArea && m_scrollableArea -> scroll ( pressedPartScrollDirection ( ) , pressedPartScrollGranularity ( ) ) ) <NEW_LINE>
nsHTMLParanoidFragmentSink ( PRBool aAllContent = PR_FALSE ) ; <NEW_LINE>
size_t arg_length , args_length , old_args_length ; <NEW_LINE>
bss -> ssid_len = min_t ( int , 32 , elem -> len ) ; <NEW_LINE>memcpy ( bss -> ssid , elem -> data , bss -> ssid_len ) ; <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ;
jas_uchar buf [ MIF_MAGICLEN ] ; <NEW_LINE>
OMX_BUFFERHEADERTYPE * header = findBufferHeader ( buffer , kPortIndexOutput ) ; <NEW_LINE>if ( header == NULL ) { <NEW_LINE>return BAD_VALUE ; <NEW_LINE> } <NEW_LINE>
for ( i = 0 ; i < TTABLE_SIZE ; ++ i ) if ( transform_info [ i ] . name != NULL ) <NEW_LINE>
#ifdef SQLITE_TEST <NEW_LINE>if ( rc == SQLITE_OK ) { <NEW_LINE>rc = sqlite3_create_function ( db , "inttoptr" , 1 , SQLITE_UTF8 , 0 , <NEW_LINE>inttoptrFunc , 0 , 0 ) ; <NEW_LINE> } <NEW_LINE>#endif <NEW_LINE>#endif <NEW_LINE>
ND_TCHECK ( * tptr ) ; <NEW_LINE>
inline std::unique_ptr < ClipPaintPropertyNode > CreateClipPathClip ( <NEW_LINE>const ClipPaintPropertyNode & parent , <NEW_LINE>const TransformPaintPropertyNode * local_transform_space , <NEW_LINE>
const int64_t currpos = ftello ( stream -> file ) ; <NEW_LINE>
<NEW_LINE>nsRefPtr < gfxImageSurface > imageSurf = new gfxImageSurface ( gfxIntSize ( size . width , size . height ) , format , false ) ; <NEW_LINE><NEW_LINE>bool resultOfCopy = imageSurf -> CopyFrom ( source ) ; <NEW_LINE>NS_ASSERTION ( resultOfCopy , "Failed to copy surface . " ) ; <NEW_LINE>surf = imageSurf ; <NEW_LINE>
{ <NEW_LINE> ( void ) ThrowMagickException ( _exception , GetMagickModule ( ) , <NEW_LINE>OptionError , "ImageSequenceRequired" , "` % s'" , option ) ; <NEW_LINE>new_images = DestroyImage ( new_images ) ; <NEW_LINE>status = MagickFalse ; <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>
keys_ . push_back ( std::make_unique < PrivateKey > ( ) ) ; <NEW_LINE>
if ( code == max_code ) <NEW_LINE>
php_pcre_match_impl ( pce , subject , subject_len , return_value , subpats , <NEW_LINE>
for ( nsCOMPtr < nsIContent > child = aNode -> GetLastChild ( ) ; <NEW_LINE>
if ( int_fb ) <NEW_LINE>int_fb -> in_use = 0 ; <NEW_LINE>
base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <NEW_LINE>size = offsetof ( POLYGON , p [ 0 ] ) + base_size ; <NEW_LINE><NEW_LINE><NEW_LINE>if ( base_size / npts != sizeof ( poly -> p [ 0 ] ) || size <= base_size ) <NEW_LINE>ereport ( ERROR , <NEW_LINE> ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , <NEW_LINE>errmsg ( "too many points requested" ) ) ) ; <NEW_LINE><NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
class CORE_EXPORT CSSCustomIdentValue : public CSSValue { <NEW_LINE>
nsCOMPtr < nsIWebNavigation > webNav = <NEW_LINE>do_GetInterface ( ( nsIScriptGlobalObject * ) this ) ; <NEW_LINE>
if ( keyPairInfo -> ecPopPubKey && keyPairInfo -> ecPopPubKey -> keyType == ecKey ) <NEW_LINE>
pusher . PushNull ( ) ; <NEW_LINE>DoTick ( ) ; <NEW_LINE>pusher . Pop ( ) ; <NEW_LINE>
DECLARE_ALIGNED ( 256 , static const InterpKernel , <NEW_LINE>sub_pel_filters_8 [ SUBPEL_SHIFTS ] ) = { <NEW_LINE>
vpx_clear_system_state ( ) ; <NEW_LINE>
if ( ! mProcessStyle || name != nsGkAtoms::style ) { <NEW_LINE>return NS_OK ; <NEW_LINE> } <NEW_LINE>
if ( js::GetObjectJSClass ( aThisObject ) == & kFakeBackstagePassJSClass ) { <NEW_LINE>mThisObjects . Put ( aScript , aThisObject ) ; <NEW_LINE> } <NEW_LINE>
AutoCompartment ac ( cx , cx -> runtime ( ) -> atomsCompartment ) ; <NEW_LINE>
return TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ; <NEW_LINE>
if ( png_rtran_ok ( png_ptr , 0 ) == 0 ) <NEW_LINE>
#define MODULE_MAGIC_NUMBER_MINOR 3 <NEW_LINE>
unsigned int reserved ) ;
#endif <NEW_LINE>#if HAVE_NEON || HAVE_NEON_ASM <NEW_LINE>
if ( error || colspan < 0 || colspan > MAX_COLSPAN ) <NEW_LINE>
<NEW_LINE>
CLIENT_MULTI_STATEMENTS | <NEW_LINE>CLIENT_REMEMBER_OPTIONS ; <NEW_LINE>
nsStyleLinkElement::SetStyleSheet ( nsnull ) ; <NEW_LINE>
if ( ! ::JS_DefineUCProperty ( cx , obj , ::JS_GetStringChars ( str ) , <NEW_LINE>::JS_GetStringLength ( str ) , val , nsnull , nsnull , <NEW_LINE>JSPROP_ENUMERATE ) ) { <NEW_LINE>
nsCOMPtr < nsIChannel > chan ; <NEW_LINE>nsresult rv = OpenContentStream ( PR_FALSE , result , getter_AddRefs ( chan ) ) ; <NEW_LINE>NS_ASSERTION ( ! chan || ! * result , "Got both a channel and a stream ? " ) ; <NEW_LINE>if ( NS_SUCCEEDED ( rv ) && chan ) { <NEW_LINE>rv = Redirect ( chan , nsIChannelEventSink::REDIRECT_INTERNAL , PR_FALSE ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) <NEW_LINE>return rv ; <NEW_LINE>rv = chan -> Open ( result ) ; <NEW_LINE> } else if ( rv == NS_ERROR_NOT_IMPLEMENTED ) <NEW_LINE>
bool is_contextual_cards_bar_integration_enabled_cached_ ; <NEW_LINE>bool is_contextual_cards_bar_integration_enabled_ ; <NEW_LINE>
m_pOutput_pmem [ i ] . buffer = NULL ; <NEW_LINE>
if ( ext && strlen ( ext ) > 1 && strlen ( ext ) <= sizeof ( szExt ) ) { <NEW_LINE>
this -> ~ nsView ( ) ; <NEW_LINE><NEW_LINE>const uintptr_t POISON = nsPresArena::GetPoisonValue ( ) ; <NEW_LINE>char * p = reinterpret_cast < char * > ( this ) ; <NEW_LINE>char * limit = p + sizeof ( * this ) ; <NEW_LINE>for ( ; p < limit ; p += sizeof ( uintptr_t ) ) { <NEW_LINE> * reinterpret_cast < uintptr_t * > ( p ) = POISON ; <NEW_LINE> } <NEW_LINE><NEW_LINE>nsView::operator delete ( this ) ; <NEW_LINE>
<NEW_LINE>
_y4m -> bps = 32 ; <NEW_LINE>
if ( inliningDepth_ > 0 ) <NEW_LINE>
if ( DIFF ( l1_new , l2_new ) < DIFF ( l1 , l2 ) && w > text_info -> glyphs ) { <NEW_LINE>if ( w -> linebreak ) <NEW_LINE>text_info -> n_lines -- ; <NEW_LINE>
int row , col , i , v , kernel ; <NEW_LINE>
JSAutoTempValueRooter tvr ( cx , 1 , & reviver ) ; <NEW_LINE>
static const <NEW_LINE>
if ( num_unknowns != 0 ) <NEW_LINE>
#include "core / html / forms / KeyboardClickableInputTypeView . h" <NEW_LINE>
if ( OffsetVal > UINT32_MAX - ByteCount || OffsetVal + ByteCount > ExifLength ) { <NEW_LINE>
#line 1069 "ext / standard / var_unserializer . c" <NEW_LINE>
nsCOMPtr < nsIContent > parentContent ; <NEW_LINE><NEW_LINE>if ( mTopLeftHandle ) { <NEW_LINE>res = mTopLeftHandle -> GetParentNode ( getter_AddRefs ( parentNode ) ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( res , res ) ; <NEW_LINE>parentContent = do_QueryInterface ( parentNode ) ; <NEW_LINE> } <NEW_LINE>
snprintf ( grump , sizeof ( grump ) , <NEW_LINE>"start % ld end % ld" , ( long ) sub . rm_so , <NEW_LINE>
<NEW_LINE>
if ( ! mCanvasElement && ! mDocShell ) { <NEW_LINE>NS_ERROR ( "No canvas element and no docshell in GetImageData ! ! ! " ) ; <NEW_LINE>return NS_ERROR_DOM_SECURITY_ERR ; <NEW_LINE> } <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( mCanvasElement && <NEW_LINE>HTMLCanvasElement ( ) -> IsWriteOnly ( ) && <NEW_LINE> ! nsContentUtils::IsCallerTrustedForRead ( ) ) <NEW_LINE> { <NEW_LINE>
class WebsiteSettingsPopupView : public content::WebContentsObserver , <NEW_LINE>public PermissionSelectorViewObserver , <NEW_LINE>public views::BubbleDelegateView , <NEW_LINE>public views::ButtonListener , <NEW_LINE>public views::LinkListener , <NEW_LINE>public views::TabbedPaneListener , <NEW_LINE>public WebsiteSettingsUI { <NEW_LINE>
<NEW_LINE>
return equalIgnoringASCIICase ( toElement ( node ) -> getAttribute ( aria_hiddenAttr ) , <NEW_LINE>"false" ) ; <NEW_LINE>
player -> setStartTime ( monotonicAnimationStartTime - player -> timeline ( ) . zeroTime ( ) , false ) ; <NEW_LINE>
NS_ASSERTION ( size >= 0 && size <= PR_INT32_MAX , "Size out of range . " ) ; <NEW_LINE>nsresult rv = gMediaCache -> ReadCacheFile ( offset , aBuffer + count , PRInt32 ( size ) , & bytes ) ; <NEW_LINE>
if ( ! inItemArray . AppendElement ( do_GetWeakReference ( inItem ) ) ) <NEW_LINE>
if ( ( png_ptr -> flags & PNG_FLAG_APP_ERRORS_WARN ) != 0 ) <NEW_LINE>
void SetRenderer ( int process_host_id , <NEW_LINE>
static void get_icu_value_src_php ( char * tag_name , INTERNAL_FUNCTION_PARAMETERS ) <NEW_LINE>
TEMP_FAILURE_RETRY ( write ( pipefd [ 1 ] , large_data , strlen ( large_data ) ) ) ; <NEW_LINE>
StreamingVertexBuffer * mCurrentValueBuffer [ MAX_VERTEX_ATTRIBS ] ; <NEW_LINE>UINT mCurrentValueOffsets [ MAX_VERTEX_ATTRIBS ] ; <NEW_LINE>
mPusher . Push ( mCx ) ; <NEW_LINE>
SynthesizeSlowNativeFrame ( InterpState & state , JSContext * cx , VMSideExit * exit ) <NEW_LINE>
<NEW_LINE>already_AddRefed < nsIURI > GetBaseURI ( ) const ; <NEW_LINE><NEW_LINE>
void <NEW_LINE>nsTableFrame::DoRemoveFrame ( ChildListID aListID , <NEW_LINE>nsIFrame * aOldFrame ) <NEW_LINE> { <NEW_LINE>
for ( j = 0 ; j < book -> dim && i < offset + n ; j ++ ) { <NEW_LINE>a [ chptr ++ ] [ i ] += v [ j ] ; <NEW_LINE>if ( chptr == ch ) { <NEW_LINE>chptr = 0 ; <NEW_LINE>i ++ ; <NEW_LINE> } <NEW_LINE>
const sp < IMediaPlayerService > MediaMetadataRetriever::getService ( ) <NEW_LINE>
store_pool_error ( png_store * ps , png_const_structp pp , const char * msg ) <NEW_LINE>
virtual void onComponentComplete ( ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>int AddToBuffer ( Endpoint * endp , int target_len , const u_char ** data , int * len ) ; <NEW_LINE><NEW_LINE>
if ( ! js_doregexec ( J , re -> prog , text , & m , 0 ) ) <NEW_LINE>
const int target = rc -> avg_frame_bandwidth * kf_ratio ; <NEW_LINE>
mpz_powm_sec ( r , key -> g , k , key -> p ) ; <NEW_LINE>
AutoPushJSContext cx ( aBoundContext -> GetNativeContext ( ) ) ; <NEW_LINE>
<NEW_LINE>bytecnt_max = nbytes - offset ; <NEW_LINE>bytecnt_max = bytecnt_max > ( 1 << 14 ) ? ( 1 << 14 ) : bytecnt_max ; <NEW_LINE>bytecnt_max = bytecnt > nbytes ? nbytes : bytecnt_max ; <NEW_LINE>if ( bytecnt == 0 || bytecnt > bytecnt_max ) <NEW_LINE>bytecnt = bytecnt_max ; <NEW_LINE>
& arr , false , 0 , 0 , 0 , 0 ) ; <NEW_LINE>
static const REF_DEFINITION vp9_ref_order [ MAX_REFS ] = { <NEW_LINE>
char bogus_public [ 41 ] ; <NEW_LINE>char bogus_secret [ 41 ] ; <NEW_LINE>
last mod: $ Id: registry . h 15531 2008 - 11 - 24 23:50:06Z xiphmont $ <NEW_LINE>
nsCOMPtr < nsIAtom > typeAtom = aListenerStruct -> mTypeAtom ; <NEW_LINE>nsIAtom * attrName = typeAtom ; <NEW_LINE>
<NEW_LINE>already_AddRefed < nsISVGPoint > GetItemAt ( uint32_t aIndex ) ; <NEW_LINE>
static INLINE int64_t <NEW_LINE>
return ERROR_INV_SLICE_HDR_T ; <NEW_LINE>
void ConfigureStreams ( ) ; <NEW_LINE>
SkAutoFree dirEntryBuffer ( sk_malloc_canfail ( sizeof ( Entry ) * numImages ) ) ; <NEW_LINE>
if ( ss -> ssl3 . hs . ws != wait_cert_request ) { <NEW_LINE>desc = unexpected_message ; <NEW_LINE>errCode = SSL_ERROR_RX_UNEXPECTED_CERT_REQUEST ; <NEW_LINE>goto alert_loser ; <NEW_LINE>
if ( XrayUtils::NeedsWaive ( cx , wrapper , id ) ) { <NEW_LINE>JSObject * waived = WrapperFactory::WaiveXray ( cx , wrapper ) ; <NEW_LINE>if ( ! waived || ! JS_WrapObject ( cx , & waived ) ) <NEW_LINE>return false ; <NEW_LINE>return JS_GetPropertyDescriptorById ( cx , waived , id , flags , desc ) ; <NEW_LINE>
SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
AutoPushJSContext cx ( sc -> GetNativeContext ( ) ) ; <NEW_LINE>
delete [ ] content_encoding_entries ; <NEW_LINE>
nsContentUtils::AddScriptRunner ( <NEW_LINE>new FocusBlurEvent ( aTarget , aType , aPresShell -> GetPresContext ( ) ) ) ; <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
static const char * const cfg = " -- target = generic - gnu -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect -- disable - install - docs -- size - limit = 4096x3072" ; <NEW_LINE>
pCur -> pPtr = sqlite3_value_pointer ( argv [ 0 ] ) ; <NEW_LINE>pCur -> iCnt = pCur -> pPtr ? sqlite3_value_int64 ( argv [ 1 ] ) : 0 ; <NEW_LINE>
NS_ENSURE_NATIVE_COLUMN ( aCol ) ; <NEW_LINE>
if ( image -> ping == MagickFalse ) <NEW_LINE>
<NEW_LINE>
uint32 strip , nstrips = TIFFNumberOfStrips ( in ) ; <NEW_LINE>
if ( image -> channel_map [ image -> channel_map [ channel ] . offset ] . traits == UndefinedPixelTrait ) <NEW_LINE>
ThrowPDFException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE>
class CallbackWrapper FINAL : public GarbageCollectedFinalized < CallbackWrapper > { <NEW_LINE>
if ( mInDtor || mOnDestroyCalled || mWindowType == eWindowType_invisible ) { <NEW_LINE>
if ( m_pattern . m_body -> m_hasFixedSize <NEW_LINE> && ( alternative -> m_minimumSize > beginOp -> m_alternative -> m_minimumSize ) <NEW_LINE> && ( alternative -> m_minimumSize - beginOp -> m_alternative -> m_minimumSize == 1 ) ) <NEW_LINE>
BLOCK_SIZE bsize , <NEW_LINE>int64_t rate , <NEW_LINE>int64_t dist , <NEW_LINE>int skip ) { <NEW_LINE>
if ( ! ::JS_DefineProperty ( cx , helper , "all" , JSVAL_VOID , nsnull , nsnull , <NEW_LINE>JSPROP_ENUMERATE ) ) { <NEW_LINE>return JS_FALSE ; <NEW_LINE> } <NEW_LINE>
PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , <NEW_LINE>const MODE_INFO * left_mi , int b ) { <NEW_LINE>
result = mUndoStack . Pop ( getter_AddRefs ( tx ) ) ; <NEW_LINE>
thissad += mvsad_err_cost ( x , & this_mv , & fcenter_mv , sad_per_bit ) ; \ <NEW_LINE>
if ( mcopy ( ms , p , m -> type , 0 , s , offset , nbytes , m ) == - 1 ) <NEW_LINE>
if ( fscanf ( fp , " Number of pts = % d ; format = % 127s\n" , & n , typestr ) != 2 ) <NEW_LINE>
localname = NULL ; <NEW_LINE>goto done ; <NEW_LINE>
ts -> tm_mon + 1 , ts -> tm_mday , ts -> tm_hour , ts -> tm_min , ts -> tm_sec ) ; <NEW_LINE>
guint		tpiLen ; <NEW_LINE>
error = curl_multi_fdset ( mh -> multi , & readfds , & writefds , & exceptfds , & maxfd ) ; <NEW_LINE>SAVE_CURLM_ERROR ( mh , error ) ; <NEW_LINE><NEW_LINE>
<NEW_LINE>
#line 563 "ext / standard / var_unserializer . re" <NEW_LINE>
void UpdateAppState ( content::WebContents * contents , AppState app_state ) ; <NEW_LINE>
( ctxt -> value -> nodesetval -> nodeNr > 1 ) ) <NEW_LINE>xmlXPathNodeSetKeepLast ( ctxt -> value -> nodesetval ) ; <NEW_LINE>
NS_ABORT_IF_FALSE ( size >= 0 && size <= PR_INT32_MAX , "Size out of range . " ) ; <NEW_LINE>nsresult rv = gMediaCache -> ReadCacheFile ( offset , aBuffer + count , PRInt32 ( size ) , & bytes ) ; <NEW_LINE>
nsContentUtils::AddScriptRunner ( new nsPLDOMEvent ( mContent , <NEW_LINE>NS_LITERAL_STRING ( "ValueChange" ) , PR_FALSE ) ) ; <NEW_LINE>
( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error && <NEW_LINE> ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) <NEW_LINE>
if ( png_ptr -> save_buffer_size != 0 ) <NEW_LINE>
vector < nsRefPtr < XPCWrappedNative > > * set = <NEW_LINE>static_cast < vector < nsRefPtr < XPCWrappedNative > > * > ( arg ) ; <NEW_LINE><NEW_LINE>set -> push_back ( static_cast < Native2WrappedNativeMap::Entry * > ( hdr ) -> value ) ; <NEW_LINE>
if ( perf_output_begin ( & handle , event , header . size , 1 ) ) <NEW_LINE>
if ( OBJ_IS_NATIVE ( obj2 ) ) <NEW_LINE>JS_LOCK_OBJ ( cx , obj2 ) ; <NEW_LINE>
for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( depth ) ; i ++ ) <NEW_LINE>
return retval ; <NEW_LINE>
key = ssplit ( sclone ( pair ) , " = " , & value ) ; <NEW_LINE>
<NEW_LINE>if ( portIndex != kPortIndexInput ) { <NEW_LINE>android_errorWriteLog ( 0x534e4554 , "29422020" ) ; <NEW_LINE>return BAD_VALUE ; <NEW_LINE> } else if ( mNumPortBuffers [ portIndex ] > 0 ) { <NEW_LINE>android_errorWriteLog ( 0x534e4554 , "29422020" ) ; <NEW_LINE>return INVALID_OPERATION ; <NEW_LINE> } <NEW_LINE><NEW_LINE>const sp < GraphicBufferSource > surfaceCheck = getGraphicBufferSource ( ) ; <NEW_LINE>
ret_value = 0 ; <NEW_LINE>goto to_exit ; <NEW_LINE>
? XPCWrapper::Unwrap ( cx , cur , false ) <NEW_LINE>: js::UnwrapObject ( cur , false ) ; <NEW_LINE>
rv = aState . pushPtr ( condGoto , aState . eConditionalGoto ) ; <NEW_LINE>
fp = fopen_safe ( file_name , "a" ) ; <NEW_LINE>
#ifndef BASE_DEBUG_PROFILER_H_ <NEW_LINE>#define BASE_DEBUG_PROFILER_H_ <NEW_LINE>
scoped_ptr < DistillerUIHandle > ui_handle ) ; <NEW_LINE>
snprintf ( buf , sizeof ( buf ) , " % s . conf" , set ) ; <NEW_LINE>
const image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE>
mContent = do_GetWeakReference ( aContent ) ; <NEW_LINE>
- 3 , - 1 , - 3 , 4 , - 1 , - 3 , - 1 , - 1 , - 3 , <NEW_LINE>
script = frontend::CompileScript ( cx , obj , NULL , principals , NULL , tcflags , <NEW_LINE>buf , len , filename , 1 , cx -> findVersion ( ) ) ; <NEW_LINE>
RootedShape newShape ( cx , EmptyShape::getInitialShape ( cx , res -> getClass ( ) , <NEW_LINE>res -> getTaggedProto ( ) , <NEW_LINE>res -> getMetadata ( ) , <NEW_LINE>res -> getParent ( ) , <NEW_LINE>res -> numFixedSlots ( ) , <NEW_LINE>shape -> getObjectFlags ( ) ) ) ; <NEW_LINE>
if ( m_needsBoundariesUpdate || transformChange != TransformChange::None ) { <NEW_LINE>
BufferMeta * buffer_meta = new BufferMeta ( params , portIndex ) ; <NEW_LINE>
const long long id = ReadID ( pReader , pos , len ) ; <NEW_LINE>if ( id < 0 || ( pos + len ) > stop ) <NEW_LINE>return E_FILE_FORMAT_INVALID ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>bool HasAccessToFunction ( const std::string & function_name , <NEW_LINE>bool allow_implicit ) const ; <NEW_LINE>
virtual void TabDetachedAt ( content::WebContents * contents , <NEW_LINE>
<NEW_LINE><NEW_LINE>deflateInit ( & mUpstreamZlib , Z_NO_COMPRESSION ) ; <NEW_LINE>
void * newMemArray = sk_malloc_throw ( fAllocCount , sizeof ( T ) ) ; <NEW_LINE>
nsObjectLoadingContent::UpdateObjectParameters ( bool aJavaURI ) <NEW_LINE>
while ( ( c = GetChar ( ts ) ) != '\n' && ScanAsSpace ( c ) ) <NEW_LINE>
data . ComputeLengthAndData ( ) ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>
if ( len < 10 ) <NEW_LINE>
parameters . cp_comment = ( char * ) property ; <NEW_LINE>
vpx_push_neon ( post_store ) ; <NEW_LINE>
umaHelper ( ) . onAutoplayInitiated ( AutoplaySource::Method ) ; <NEW_LINE>
static const char * const cfg = " -- target = armv7 - linux - gcc -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect -- disable - install - docs -- size - limit = 4096x3072" ; <NEW_LINE>
nsAutoCString host ( PublicKeyPinningService::CanonicalizeHostname ( aHost ) ) ; <NEW_LINE>
BufferMeta * buffer_meta = new BufferMeta ( size , portIndex ) ; <NEW_LINE>
if ( entry . filename_len > endbuffer - buffer - 20 ) { <NEW_LINE>
<NEW_LINE>
return VPX_CODEC_UNSUP_BITSTREAM ; <NEW_LINE>
NS_ENSURE_STATE ( pusher . Push ( cx ) ) ; <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
NS_ENSURE_TRUE ( offset < aBufLength , NS_ERROR_GFX_CMAP_MALFORMED ) ; <NEW_LINE>
#endif
goto err ; <NEW_LINE>
if ( length > ( unsigned int ) png_ptr -> num_palette || <NEW_LINE>length > ( unsigned int ) PNG_MAX_PALETTE_LENGTH || <NEW_LINE>
if ( tpgt >= TL_TPGS_PER_HBA ) { <NEW_LINE>
&& ! newChild -> isFloatingOrOutOfFlowPositioned ( ) && ! newChild -> isInline ( ) && ! isAnonymousColumnSpanBlock ( ) ) { <NEW_LINE>
virtual void WriteInternal ( const char * aBuffer , uint32_t aCount , DecodeStrategy aStrategy ) ; <NEW_LINE>
nscoord float_min = floats [ i ] . Width ( ) ; <NEW_LINE>
#if defined PNG_READ_SUPPORTED || defined PNG_WRITE_tRNS_SUPPORTED <NEW_LINE>
pp = pp * rooti + p ; <NEW_LINE>p = p * rooti + a [ k ] ; <NEW_LINE>
<NEW_LINE>void Reset ( ) ; <NEW_LINE>
MaybeRemoveMutationObserver ( mFocusedInputNode ) ; <NEW_LINE>
nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE>
key = ssplit ( key , ":\r\n\t " , NULL ) ; <NEW_LINE>
Value v = getSlot ( FUNCTION_NS ) ; <NEW_LINE>
xdr -> atoms = NULL ; <NEW_LINE>xdr -> atomsMap = NULL ; <NEW_LINE>
str [ 0 ] = 0 ; <NEW_LINE>
cache_info -> mapped = MagickFalse ; <NEW_LINE>cache_info -> pixels = ( PixelPacket * ) MagickAssumeAligned ( <NEW_LINE>AcquireAlignedMemory ( 1 , ( size_t ) cache_info -> length ) ) ; <NEW_LINE>
xpc::WrapperFactory::RewrapForSameCompartment , <NEW_LINE>
snprintf ( grump , sizeof ( grump ) , <NEW_LINE>"start % ld end % ld , past end of string" , <NEW_LINE>
aImg -> mDecodingMonitor . AssertCurrentThreadIn ( ) ; <NEW_LINE>
THIS_FUNCTION_IS_DEPRECATED ( extern const void * lh_table_lookup ( struct lh_table * t , const void * k ) ) ;
const NativeProperties * properties , <NEW_LINE>const NativeProperties * chromeOnlyProperties , <NEW_LINE>
return NS_OK ; <NEW_LINE>
DECLARE_ALIGNED ( 256 , static const InterpKernel , <NEW_LINE>sub_pel_filters_8s [ SUBPEL_SHIFTS ] ) = { <NEW_LINE>
nsWeakFrame weakFrame ( this ) ; <NEW_LINE>bool change = <NEW_LINE>HandleListSelection ( aMouseEvent , selectedIndex ) ; <NEW_LINE>if ( ! weakFrame . IsAlive ( ) ) { <NEW_LINE>return NS_OK ; <NEW_LINE> } <NEW_LINE>mChangesSinceDragStart = change ; <NEW_LINE>
if ( ( parent == NULL ) || ( node -> doc == NULL ) || isRVT || <NEW_LINE> ( comp -> novar == 0 ) ) <NEW_LINE>
if ( l > ( unsigned ) ( buf + n - p ) ) { <NEW_LINE>
rv = aState . pushPtr ( var , aState . eVariableItem ) ; <NEW_LINE>
static const sp < IMediaPlayerService > getMediaPlayerService ( ) ; <NEW_LINE>
if ( ! m_element -> isHTMLVideoElement ( ) || ! m_element -> muted ( ) || <NEW_LINE> ! m_sources . count ( AutoplaySource::Method ) ) <NEW_LINE>
void __perf_sw_event ( u32 event_id , u64 nr , struct pt_regs * regs , u64 addr ) <NEW_LINE>
m . command = CMD_NONE ; <NEW_LINE>
#ifndef CHROME_BROWSER_CHROMEOS_KIOSK_NEXT_HOME_APP_CONTROLLER_SERVICE_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_KIOSK_NEXT_HOME_APP_CONTROLLER_SERVICE_H_ <NEW_LINE>
<NEW_LINE>
buffer = zend_string_safe_alloc ( 1 , len , 0 , 0 ) ; <NEW_LINE>
vorbis_info_psy_global * g , <NEW_LINE>vorbis_look_psy * p , <NEW_LINE>vorbis_info_mapping0 * vi , <NEW_LINE>float ** mdct ) { <NEW_LINE>
cpi -> common . Width * cpi -> common . Height ; <NEW_LINE>
explicit DOMHandler ( bool allow_file_access ) ; <NEW_LINE>
file_fmttime ( p -> l + m -> num_mask , FILE_T_LOCAL , tbuf ) ) == - 1 ) <NEW_LINE>
aNotify , nsnull ) ; <NEW_LINE>
nsresult MarkLineDirty ( line_iterator aLine , <NEW_LINE>const nsLineList * aLineList = nsnull ) ; <NEW_LINE>
for ( i = 0 ; i < SERDES_MAX ; i ++ ) { <NEW_LINE>
if ( 2 == cipher_len || * out_len < cipher_len - 2 ) <NEW_LINE>
<NEW_LINE>
#include "ppapi / c / pp_completion_callback . h" <NEW_LINE>
if ( ! pusher . Push ( mContext , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ) <NEW_LINE>
res = utee_param_to_param ( utc , param , callee_params ) ; <NEW_LINE>if ( res != TEE_SUCCESS ) <NEW_LINE>return res ; <NEW_LINE>
return SetUTCTime ( cx , obj , TIMECLIP ( result ) , vp ) ; <NEW_LINE>
isoclns_print ( ndo , p , length ) ; <NEW_LINE>
void UpdateCredentials ( <NEW_LINE>const std::string & account_id , <NEW_LINE>const std::string & refresh_token , <NEW_LINE>signin_metrics::SourceForRefreshTokenOperation source = <NEW_LINE>signin_metrics::SourceForRefreshTokenOperation::kUnknown ) ; <NEW_LINE><NEW_LINE>void RevokeCredentials ( <NEW_LINE>const std::string & account_id , <NEW_LINE>signin_metrics::SourceForRefreshTokenOperation source = <NEW_LINE>signin_metrics::SourceForRefreshTokenOperation::kUnknown ) ; <NEW_LINE><NEW_LINE><NEW_LINE>void RevokeAllCredentials ( <NEW_LINE>signin_metrics::SourceForRefreshTokenOperation source = <NEW_LINE>signin_metrics::SourceForRefreshTokenOperation::kUnknown ) ;
if ( png_get_gAMA ( read_ptr , read_info_ptr , & gamma ) != 0 ) <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
PutModule ( "ClientEncoding = " + pUser -> GetClientEncoding ( ) ) ; <NEW_LINE>
DECLARE_ALIGNED ( 256 , static const InterpKernel , <NEW_LINE>sub_pel_filters_8lp [ SUBPEL_SHIFTS ] ) = { <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>virtual bool CanCloseContents ( std::vector < int > * indices ) = 0 ;
* replySize < ( int ) sizeof ( effect_param_t ) || <NEW_LINE><NEW_LINE> ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t ) ) { <NEW_LINE>
for ( s = 0 ; s < ns && row < imagelength ; s ++ ) { <NEW_LINE>
static const float vwin1024 [ 512 ] = { <NEW_LINE>
if ( png_ptr -> rgb_to_gray_coefficients_set == 0 && <NEW_LINE>
jas_uchar * data ; <NEW_LINE>
mStopOnClose = reason ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
if ( stop >= 0 && pos > stop ) <NEW_LINE>
<NEW_LINE>
TEST ( TArray , Assign ) <NEW_LINE>
static VPX_INLINE void mem_put_le24 ( void * vmem , MEM_VALUE_T val ) { <NEW_LINE>
if ( ! result -> IsFunction ( ) ) <NEW_LINE>return ; <NEW_LINE>
return KRB5_PLUGIN_NO_HANDLE ; <NEW_LINE>
<NEW_LINE>
if ( isOutOfFlowPositioned ( ) ) <NEW_LINE>
nsIIOService * serv , nsIPrincipal * principal , <NEW_LINE>JSObject ** scriptObjp ) <NEW_LINE>
NewSessionTicket * session_ticket ) ; <NEW_LINE>
if ( ( ( mask & PNG_FREE_PLTE ) & info_ptr -> free_me ) != 0 ) <NEW_LINE>
cleanup:
#include "base / compiler_specific . h" <NEW_LINE>
void updateCoefficientsIfNecessary ( ) ; <NEW_LINE><NEW_LINE>void updateCoefficients ( double frequency , double Q , double gain , double detune ) ; <NEW_LINE><NEW_LINE>private: <NEW_LINE><NEW_LINE>mutable Mutex m_processLock ; <NEW_LINE>
static void ShowInfoBar ( <NEW_LINE>content::WebContents * web_contents , <NEW_LINE>std::unique_ptr < SendTabToSelfInfoBarDelegate > delegate ) ; <NEW_LINE>
if ( newMap -> Find ( wrapper -> GetIdentityObject ( ) ) ) <NEW_LINE>MOZ_CRASH ( ) ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
#include "platform / mediastream / MediaStreamSource . h" <NEW_LINE>
if ( IsValidColormapIndex ( image , ( ssize_t ) ( x * map_length + <NEW_LINE>
mJSAttributes | JSPROP_PERMANENT | JSPROP_READONLY ) ) <NEW_LINE>
JMESSAGE ( JERR_PPM_OUTOFRANGE , "Numeric value out of range in PPM file" ) <NEW_LINE>
NS_CreateJSTimeoutHandler ( nsGlobalWindow * aWindow , <NEW_LINE>
* ( rp ) = ( png_byte ) ( * rp - * ( rp + 1 ) ) ; <NEW_LINE> * ( rp + 2 ) = ( png_byte ) ( * ( rp + 2 ) - * ( rp + 1 ) ) ; <NEW_LINE>
{ "yes" , 			COMP_DELAYED } , <NEW_LINE>
QueueCheckPluginStopEvent ( ) ; <NEW_LINE>
if ( length > 1 ) <NEW_LINE>print_unknown_data ( ndo , p , "\n\t" , length ) ; <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
fArray = ( T * ) sk_malloc_throw ( count , sizeof ( T ) ) ; <NEW_LINE>
if ( x & ( 1U << ( unsigned int ) i ) ) return i ; <NEW_LINE>
ssize_t ret = TEMP_FAILURE_RETRY ( write ( uart_fd , data + transmitted_length , length ) ) ; <NEW_LINE>
if ( ! WriteEbmlElement ( writer , kMkvDuration , <NEW_LINE>
@stability Stable <NEW_LINE>
Address addressForInlineReturn ( ) ; <NEW_LINE>
l_tx0 = p_cp -> tx0 + p * <NEW_LINE>p_cp -> tdx ; <NEW_LINE> * p_tx0 = ( OPJ_INT32 ) opj_uint_max ( l_tx0 , p_image -> x0 ) ; <NEW_LINE> * p_tx1 = ( OPJ_INT32 ) opj_uint_min ( opj_uint_adds ( l_tx0 , p_cp -> tdx ) , p_image -> x1 ) ; <NEW_LINE>l_ty0 = p_cp -> ty0 + q * <NEW_LINE>p_cp -> tdy ; <NEW_LINE> * p_ty0 = ( OPJ_INT32 ) opj_uint_max ( l_ty0 , p_image -> y0 ) ; <NEW_LINE> * p_ty1 = ( OPJ_INT32 ) opj_uint_min ( opj_uint_adds ( l_ty0 , p_cp -> tdy ) , p_image -> y1 ) ; <NEW_LINE>
static bool neuterViews ( JSContext * cx , Handle < ArrayBufferObject * > buffer , void * newData ) ; <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
if ( out + 2 > outend ) { <NEW_LINE><NEW_LINE><NEW_LINE>mState = 0xFF ; <NEW_LINE> ++ in ; <NEW_LINE>res = NS_OK_UDEC_MOREOUTPUT ; <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>out = EmitSurrogatePair ( mUcs4 , out ) ; <NEW_LINE>
XPCNativeWrapperCtor , 0 , nsnull , nsnull , <NEW_LINE>
static const char * const cfg = " -- target = mips64 - linux - gcc -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect -- disable - install - docs -- size - limit = 4096x3072" ; <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
for ( ObjectValueMap::Range r = table -> map . all ( ) ; ! r . empty ( ) ; r . popFront ( ) ) { <NEW_LINE>
if ( fifo -> skbuff -> len > 3 && <NEW_LINE> ! fifo -> skbuff -> data [ fifo -> skbuff -> len - 1 ] ) { <NEW_LINE>
JSContext * cx = xpc_UnmarkGrayContext ( ccx . GetJSContext ( ) ) ; <NEW_LINE>
<NEW_LINE>
m . command = CMD_NONE ; <NEW_LINE>
if ( STATE_FIRST_CALL == mState && * aSrcLength < 2 ) <NEW_LINE> { <NEW_LINE> * aSrcLength = 0 ; <NEW_LINE> * aDestLength = 0 ; <NEW_LINE>return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> } <NEW_LINE>
RefPtr < DocumentFragment > fragment = createContextualFragment ( markup , toHTMLElement ( m_element ) , AllowScriptingContent ) ; <NEW_LINE>
DataReductionRequestType data_reduction_type , <NEW_LINE>
fp -> thisp = ( JSObject * ) state . nativeVp [ 1 ] ; <NEW_LINE>fp -> argc = state . nativeVpLen - 2 ; <NEW_LINE>fp -> argv = state . nativeVp + 2 ; <NEW_LINE>
<NEW_LINE>bool InitPrintSettings ( WebKit::WebFrame * frame ) ; <NEW_LINE><NEW_LINE>
scoped_ptr < BluetoothAdapterChromeOS::PairingContext > pairing_context_ ;
#define VERSION "2 . 04 of 15 June 2014" <NEW_LINE>
static_cast < unsigned > ( parsedOptions . cropRect . height ( ) ) * <NEW_LINE>
memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <NEW_LINE>memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <NEW_LINE>memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <NEW_LINE>
size_t pos = 0 ; <NEW_LINE>
<NEW_LINE>
class BASE_API NonThreadSafe : public NonThreadSafeImpl { <NEW_LINE>
SOW_FLAG = PARTIALLY_TRANSPARENT << 1 , <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>SHADOWING_FORBIDDEN = SOW_FLAG << 1 } ; <NEW_LINE>
} else if ( ( number > INT_MIN ) && ( number < INT_MAX ) && <NEW_LINE> ( number == ( int ) number ) ) { <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
char * certUsage , PRBool checkSig , PRBool logit , <NEW_LINE>PRBool ascii , secuPWData * pwdata ) <NEW_LINE>
if ( sub_rect . IsValid ( ) && sub_rect == SentinelEmptyRect ( ) ) { <NEW_LINE>
m_hasPendingErrorEvent = true ; <NEW_LINE>errorEventSender ( ) . dispatchEventSoon ( this ) ; <NEW_LINE>
log_op = fopen_safe ( log_name , "a" ) ; <NEW_LINE>
( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) != 0 ) <NEW_LINE>
if ( ent -> data == NULL ) { <NEW_LINE>retval = FAILURE ; <NEW_LINE> } else { <NEW_LINE> * return_value = * ( ent -> data ) ; <NEW_LINE>zval_copy_ctor ( return_value ) ; <NEW_LINE>retval = SUCCESS ; <NEW_LINE> } <NEW_LINE>
return OFPERR_OFPGMFC_BAD_COMMAND ; <NEW_LINE>
b43err ( dev -> wl , " % s" , errmsg ) ; <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
ObjectValueMap::Ptr ptr = weakmap -> map . lookup ( key ) ; <NEW_LINE>
#define VPX_MAXIMUM_WORK_BUFFERS 8
JSObject * glob = JS_GetScopeChain ( cx ) ; <NEW_LINE>if ( ! glob ) <NEW_LINE>return JS_FALSE ; <NEW_LINE>glob = GetGlobalObject ( cx , glob ) ; <NEW_LINE>
static int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <NEW_LINE>
for ( i = 0 ; i < cur_arr_len ; i ++ ) { <NEW_LINE>if ( cur_arr [ i * 2 ] != NULL && strlen ( cur_arr [ i * 2 ] ) == saved_pos && strncmp ( cur_loc_range , cur_arr [ i * 2 ] , saved_pos ) == 0 ) { <NEW_LINE>
iakerb_ctx_id_t iakerb_ctx = ( iakerb_ctx_id_t ) * context_handle ; <NEW_LINE>
nsTArray < nsRefPtr < WebGLShader > > mAttachedShaders ; <NEW_LINE>
int i , hasAdditionalBlocks , <NEW_LINE>
const image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE>
while ( next_format ( & colour_type , & bit_depth , & npalette , <NEW_LINE>pm -> test_lbg_gamma_sbit , pm -> test_tRNS ) ) <NEW_LINE>
vp8_pack_tokens ( & cpi -> bc [ 1 ] , cpi -> tok , cpi -> tok_count ) ; <NEW_LINE>
if ( finished == 0 ) <NEW_LINE>
sharedTimer = g_idle_add ( timeout_cb , NULL ) ; <NEW_LINE>
#include "vpx / vpx_codec . h" <NEW_LINE>static const char * const cfg = " -- force - target = mips32 - android - gcc -- disable - runtime - cpu - detect -- sdk - path = / usr / local / google / home / vigneshv / Downloads / android - ndk - r10 -- enable - dspr2 -- disable - examples -- disable - docs -- enable - realtime - only -- disable - webm - io" ; <NEW_LINE>
LANG_ID_MICROSOFT_EN_US = 0x0409 , <NEW_LINE><NEW_LINE>CMAP_MAX_CODEPOINT = 0x10ffff <NEW_LINE><NEW_LINE>
size_t bytes = no * size ; <NEW_LINE><NEW_LINE>if ( size && no != bytes / size ) <NEW_LINE>return 0 ; <NEW_LINE>unsigned flags = NEDMALLOC_FORCERESERVE ( p , 0 , bytes ) ; <NEW_LINE>return nedpmalloc2 ( p , bytes , 0 , M2_ZERO_MEMORY | flags ) ; <NEW_LINE>
if ( pledge ( "stdio rpath cpath unix id proc exec" , NULL ) == - 1 ) <NEW_LINE>
if ( ! WriteToContainedDecoder ( mBIHraw , sizeof ( mBIHraw ) , aStrategy ) ) { <NEW_LINE>
if ( mInDtor || mOnDestroyCalled || mWindowType == eWindowType_invisible ) { <NEW_LINE>
file_fmttime ( p -> q + m -> num_mask , 0 , tbuf ) ) == - 1 ) <NEW_LINE>
class BASE_API LogMessageVoidify { <NEW_LINE>
OMX_BUFFERHEADERTYPE * header = findBufferHeader ( buffer , portIndex ) ; <NEW_LINE>if ( header == NULL ) { <NEW_LINE>return BAD_VALUE ; <NEW_LINE> } <NEW_LINE>
for ( uint32_t c = mGIFStruct . width ; c > 0 ; c -- ) { <NEW_LINE> * -- to = cmap [ * -- from ] ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
document = content -> GetOwnerDoc ( ) ; <NEW_LINE>
* _retval = xpc_UnmarkGrayContext ( cx ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>
__be32 * pdata ; <NEW_LINE>if ( datalen != 4 ) <NEW_LINE>return - EINVAL ; <NEW_LINE>pdata = ( __be32 * ) data ; <NEW_LINE>
WCHAR installDirUpdater [ MAX_PATH + 1 ] = { L'\0' } ; <NEW_LINE>
if ( ! ( buf = g_try_malloc0 ( size ) ) ) { <NEW_LINE>
while ( ( current_element != NULL ) && ( current_element -> string != NULL ) && ( strcmp ( name , current_element -> string ) != 0 ) ) <NEW_LINE>
probes::ExitScript ( cx , script , script -> function ( ) , <NEW_LINE>iter . baselineFrame ( ) -> hasPushedSPSFrame ( ) ) ; <NEW_LINE>
const base::WeakPtr < SSLErrorHandler::Delegate > & delegate , <NEW_LINE>
DisableDeviceMotionUpdates ( ) ; <NEW_LINE>mHasDeviceMotion = PR_FALSE ; <NEW_LINE><NEW_LINE>
q = QueueAuthenticPixels ( image , 0 , y , image -> columns , ( size_t ) level , exception ) ; <NEW_LINE>
size_t bytes = size + alignment + 3 * sizeof ( size_t ) ; if ( bytes < size ) return 0 ; size = bytes ;
if ( border < 0 || color < 0 ) { <NEW_LINE>
vpx_prob ref_single_p1 = vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ; <NEW_LINE>vpx_prob ref_single_p2 = vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ; <NEW_LINE>
if ( linear != 0 ) <NEW_LINE>
void Write ( const char * aBuffer , uint32_t aCount , DecodeStrategy aStrategy ) ; <NEW_LINE>
if ( pread ( fd , xsh_addr , xsh_sizeof , off + size * strtab ) < ( ssize_t ) xsh_sizeof ) { <NEW_LINE>
Push ( cx ) ; <NEW_LINE>return true ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>nsresult SetHeader ( nsHttpAtom header , const nsACString & value , <NEW_LINE>PRBool merge = PR_FALSE , <NEW_LINE>PRBool replace = PR_TRUE ) ; <NEW_LINE><NEW_LINE>
gfxCtx -> Polygon ( p , MOZ_ARRAY_LENGTH ( p ) ) ; <NEW_LINE>
ND_PRINT ( ( ndo , " % s" , rpl_tstr ) ) ; <NEW_LINE>
return - 1 ;
{ <NEW_LINE> } <NEW_LINE>
#endif <NEW_LINE>#endif <NEW_LINE>
nsCOMPtr < nsIDOMElement > mFrameElement ; <NEW_LINE>
" 0x02: At least one chunk had a CRC error . " , <NEW_LINE>
offset , <NEW_LINE>
const int64_t instance_id_ ; <NEW_LINE>
nhdr = * h ; <NEW_LINE>nhdr . caplen = caplen ; <NEW_LINE>nhdr . len = length ; <NEW_LINE>hdrlen += printer ( ndo , & nhdr , p ) ; <NEW_LINE>
<NEW_LINE>
return interpFrame ( ) -> calleev ( ) ; <NEW_LINE>
if ( ! r -> m_box || r -> m_object -> isOutOfFlowPositioned ( ) || r -> m_box -> isLineBreak ( ) ) <NEW_LINE>
vp8_pack_tokens ( w , p , tokens ) ; <NEW_LINE>
compact_pixels = AcquireCompactPixels ( next_image ) ; <NEW_LINE>
if ( v >= 0x10000 ) { <NEW_LINE>
<NEW_LINE>
if ( inHeader -> nFilledLen < frameSize ) { <NEW_LINE>ALOGE ( "b / 27662364: expected % zu bytes vs % u" , frameSize , inHeader -> nFilledLen ) ; <NEW_LINE>notify ( OMX_EventError , OMX_ErrorStreamCorrupt , 0 , NULL ) ; <NEW_LINE>mSignalledError = true ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
@stability Stable <NEW_LINE>
{ <NEW_LINE>i_temp = ih264d_read_mmco_commands ( ps_dec ) ; <NEW_LINE>if ( i_temp < 0 ) <NEW_LINE> { <NEW_LINE>return ERROR_DBP_MANAGER_T ; <NEW_LINE> } <NEW_LINE>ps_dec -> u4_bitoffset = i_temp ; <NEW_LINE> } <NEW_LINE>
UpdateWebGLErrorAndClearGLError ( ) ; <NEW_LINE> * _retval = mWebGLError ; <NEW_LINE>mWebGLError = LOCAL_GL_NO_ERROR ; <NEW_LINE>
if ( ( ( error_code >> 16 ) != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) <NEW_LINE>
SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( ! mPrevContinuation || <NEW_LINE>mPrevContinuation -> GetStyleContext ( ) != GetStyleContext ( ) ) { <NEW_LINE>ClearTextRun ( ) ; <NEW_LINE> } <NEW_LINE>nsSplittableFrame::RemoveFromFlow ( this ) ; <NEW_LINE>
& red_y , & green_x , & green_y , & blue_x , & blue_y ) != 0 ) <NEW_LINE>
unsigned char * buf = SafeArrayAlloc < unsigned char > ( 1 , buflen ) ; <NEW_LINE>
while ( SetCookieInternal ( aHostURI , aChannel , cookieHeader , serverTime , aFromHttp ) ) { <NEW_LINE><NEW_LINE>if ( ! aFromHttp ) <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>
cxPusher . Push ( cx ) ; <NEW_LINE>
<NEW_LINE>
if ( renderer ( ) -> isOutOfFlowPositioned ( ) || renderer ( ) -> isRelPositioned ( ) ) <NEW_LINE>
PRPackedBool mInDtor ; <NEW_LINE>
if ( small ) <NEW_LINE> { <NEW_LINE>if ( pixel_depth <= 8 ) <NEW_LINE>return 1 << pixel_depth ; <NEW_LINE><NEW_LINE>else <NEW_LINE>return 256 ; <NEW_LINE> } <NEW_LINE><NEW_LINE>else if ( pixel_depth < 8 ) <NEW_LINE>
CanReify ( vp ) ? Reify ( cx , cx -> compartment , vp ) : cx -> compartment -> wrap ( cx , vp ) ) ; <NEW_LINE>
static const char * const cfg = " -- target = x86 - linux - gcc -- disable - sse4_1 -- disable - avx -- disable - avx2 -- as = yasm -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect -- disable - install - docs -- size - limit = 4096x3072" ; <NEW_LINE>
snprintf ( & str [ i_level * 5 ] , sizeof ( str ) - 5 * i_level , <NEW_LINE>
<NEW_LINE>
SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <NEW_LINE>
return vpx_reader_has_error ( & r ) ; <NEW_LINE>
#include "mozilla / Mutex . h" <NEW_LINE>#include "mozilla / ReentrantMonitor . h" <NEW_LINE>
static INLINE void <NEW_LINE>
q = QueueAuthenticPixels ( image , x , y , MagickMin ( 4 , dds_info -> width - x ) , <NEW_LINE>MagickMin ( 4 , dds_info -> height - y ) , exception ) ; <NEW_LINE>
const WebGLVersion webgl_version_ ; <NEW_LINE>
if ( equalIgnoringASCIICase ( getAttribute ( aria_requiredAttr ) , "true" ) ) <NEW_LINE>
switch ( speedFrac & 3 ) <NEW_LINE>
if ( ! vct_iscrlf ( p ) ) { <NEW_LINE>for ( ; ! vct_iscrlf ( p ) ; p ++ ) <NEW_LINE>
if ( ( ( mask & PNG_FREE_ICCP ) & info_ptr -> free_me ) != 0 ) <NEW_LINE>
<NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>REPORT_UNEXPECTED_TOKEN ( PEUnknownAtRule ) ; <NEW_LINE>OUTPUT_ERROR ( ) ; <NEW_LINE>SkipAtRule ( ) ; <NEW_LINE>return PR_TRUE ; <NEW_LINE>
nsresult NS_CreateJSTimeoutHandler ( nsGlobalWindow * aWindow , <NEW_LINE>
AutoPushJSContext cx ( aContext -> GetNativeContext ( ) ) ; <NEW_LINE>
if ( JSContext * cx = nsContentUtils::GetCurrentJSContext ( ) ) { <NEW_LINE>return SetHrefWithContext ( cx , aUrl , true ) ; <NEW_LINE>
if ( err == OK && sidebandHandle ) { <NEW_LINE>
#ifndef CONTENT_RENDERER_DEVTOOLS_AGENT_H_ <NEW_LINE>#define CONTENT_RENDERER_DEVTOOLS_AGENT_H_ <NEW_LINE>
if ( ! tokenStream . seek ( position , parser -> tokenStream ) ) <NEW_LINE>return false ; <NEW_LINE>
#define LINESIZE 65536 <NEW_LINE>
MOZ_ASSERT ( mDropdownFrame , "mDroppedDown without frame" ) ; <NEW_LINE>nsIView * view = mDropdownFrame -> GetView ( ) ; <NEW_LINE>MOZ_ASSERT ( view ) ; <NEW_LINE>nsIWidget * widget = view -> GetWidget ( ) ; <NEW_LINE>if ( widget ) { <NEW_LINE>widget -> CaptureRollupEvents ( this , false , true ) ; <NEW_LINE>
best_filter = mbmi -> interp_filter ; <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( ! FireClipboardEvent ( NS_PASTE , - 1 ) ) <NEW_LINE>
<NEW_LINE>edt -> tvb = tvb_new_real_data ( pd , fd -> cap_len , <NEW_LINE>fd -> pkt_len > G_MAXINT ? G_MAXINT : fd -> pkt_len ) ; <NEW_LINE>
. gro_receive	 = ipip_gro_receive , <NEW_LINE>
field = ssplit ( sclone ( fields [ i ] ) , ":" , & typeString ) ; <NEW_LINE>
<NEW_LINE>
rate2 += vp9_get_switchable_rate ( cpi , xd ) ; <NEW_LINE>
nsBaseChannel::Redirect ( nsIChannel * newChannel , PRUint32 redirectFlags , <NEW_LINE>PRBool openNewChannel ) <NEW_LINE>
#define GET_INDEXBASE ( pc ) ( JS_ASSERT ( * ( pc ) == JSOP_INDEXBASE \ <NEW_LINE> || * ( pc ) == JSOP_TRAP ) , \ <NEW_LINE>
STIN void mdct_bitreverse ( mdct_lookup * init , <NEW_LINE>
<NEW_LINE>#define EXTRACT_8BITS ( p ) ( * ( p ) ) <NEW_LINE>#define EXTRACT_LE_8BITS ( p ) ( * ( p ) ) <NEW_LINE><NEW_LINE>
cx = JSContextForPluginInstance ( reinterpret_cast < nsIPluginInstance * > ( mJavaClient ) ) ; <NEW_LINE>if ( ! cx ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>AutoPushJSContext autopush ( securitySupports , cx ) ; <NEW_LINE>if ( NS_FAILED ( autopush . ResultOfPush ( ) ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>mElements . RemoveObject ( aContent ) ; <NEW_LINE>
nsresult rv = it -> Init ( ) ; <NEW_LINE>rv |= CopyInnerTo ( it ) ; <NEW_LINE>
uint32 length = cg -> lexdeps . count ; <NEW_LINE>if ( ! vector || cg -> upvarMap . length != length ) { <NEW_LINE>vector = ( UpvarCookie * ) js_realloc ( vector , length * sizeof * vector ) ; <NEW_LINE>
item -> PostHandleEvent ( aVisitor , aPusher ) ; <NEW_LINE>
#line 10181 "dcraw / dcraw . c" <NEW_LINE>
if ( TEMP_FAILURE_RETRY ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) ) == sizeof ( cmd ) ) <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
inline std::unique_ptr < TransformPaintPropertyNode > CreateTransform ( <NEW_LINE>const TransformPaintPropertyNode & parent , <NEW_LINE>
nsresult rv = proxyEnv . getOrSetFakeOrigin ( ( nsCSecurityContext * ) securityContext ) ; <NEW_LINE>if ( NS_SUCCEEDED ( rv ) ) <NEW_LINE>rv = secureEnv -> CallNonvirtualMethod ( method -> mReturnType , obj , clazz , method -> mMethodID , args , & outValue , securityContext ) ; <NEW_LINE>
size_t len = strlen ( reflection_what ) ; <NEW_LINE>
initiator_info , resource_type ) ; <NEW_LINE>
( png_ptr -> mode & PNG_WROTE_tIME ) != 0 ) <NEW_LINE>
if ( do_local_compose == 0 && do_local_background != 2 ) <NEW_LINE>
return count_mounts ( m -> mnt_ns , child ) ; <NEW_LINE>
delete [ ] encryption -> sig_key_id ; <NEW_LINE>
void appendAttribute ( StringBuilder & , Element * , const Attribute & , Namespaces * ) ; <NEW_LINE>
if ( newChild -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
if ( png_ptr -> interlaced != 0 ) <NEW_LINE>
SetUTCTime ( cx , obj , UTC ( local ) ) ; <NEW_LINE>
#ifndef BASE_MEMORY_MEMORY_PRESSURE_LISTENER_H_ <NEW_LINE>#define BASE_MEMORY_MEMORY_PRESSURE_LISTENER_H_ <NEW_LINE>
bool fill ( const SourceCoords & other ) ; <NEW_LINE>
uint64 surface_id , <NEW_LINE>const std::string & mailbox_name ) OVERRIDE ; <NEW_LINE>
3 , 3 , 3 , 0 , 0 , 11 , 0 , 9 , 3 , 2 , <NEW_LINE>0 , 4 , 0 , 4 , 3 , 3 , 3 , 3 , 3 , 3 , <NEW_LINE>1 , 3 , 3 , 1 , 5 , 1 , 3 , 0 , 4 , 1 , <NEW_LINE>1 , 3 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , <NEW_LINE>4 , 1 , 1 , 1 , 1 , 4 , 1 , 4 , 1 , 1 , <NEW_LINE>2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 2 , <NEW_LINE>3 , 3 , 1 <NEW_LINE>
extern int perf_event_overflow ( struct perf_event * event , <NEW_LINE>
<NEW_LINE>
#endif <NEW_LINE>
{ } <NEW_LINE>
if ( ( index == ( OMX_INDEXTYPE ) OMX_IndexParamConsumerUsageBits && size < 4 ) || <NEW_LINE> ( code != SET_INTERNAL_OPTION && size < 8 ) ) { <NEW_LINE>
js_InitRandom ( JSContext * cx ) ; <NEW_LINE>
if ( png_ptr != NULL && info_ptr != NULL && <NEW_LINE> ( info_ptr -> valid & PNG_INFO_iCCP ) != 0 && <NEW_LINE>name != NULL && compression_type != NULL && profile != NULL && <NEW_LINE>proflen != NULL ) <NEW_LINE>
PRBool merge , PRBool replace ) <NEW_LINE>
scale = adjust_scale ( scale ) ; <NEW_LINE>
SetUTCTime ( cx , obj , UTC ( local ) ) ; <NEW_LINE>
<NEW_LINE>
<NEW_LINE>
delete [ ] frame_ ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
if ( IsTextureSizeSafeToPassToDriver ( target , width , height ) ) { <NEW_LINE>mSymbols . fCopyTexImage2D ( target , level , internalformat , <NEW_LINE>x , FixYValue ( y , height ) , <NEW_LINE>width , height , border ) ; <NEW_LINE><NEW_LINE> } else { <NEW_LINE><NEW_LINE><NEW_LINE>mSymbols . fCopyTexImage2D ( target , - 1 , internalformat , <NEW_LINE>x , FixYValue ( y , height ) , <NEW_LINE> - 1 , - 1 , - 1 ) ; <NEW_LINE><NEW_LINE> } <NEW_LINE>
aImg -> mDecodingMonitor . AssertCurrentThreadIn ( ) ; <NEW_LINE>
if ( isRoot ( ) || isBody ( ) || ( isOutOfFlowPositioned ( ) && style ( ) -> position ( ) == FixedPosition ) ) <NEW_LINE>
if ( ! to -> GetJSObjectPreserveColor ( ) ) { <NEW_LINE>
DECLARE_ALIGNED ( 16 , unsigned char , FData2 [ 4 * 9 ] ) ; <NEW_LINE>
( mutt_bcache_exists ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) ) == 0 ) ; <NEW_LINE>
if ( ! memsetSafe ( outHeader , 0 , mConfig -> outputFrameSize * sizeof ( int16_t ) ) ) { <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE>
jas_uchar buf [ 2 ] ; <NEW_LINE>
<NEW_LINE>
nsCOMPtr < nsIDocument > oldDocument = adoptedNode -> OwnerDoc ( ) ; <NEW_LINE>
& arr , true , <NEW_LINE>
ret = perf_output_begin ( & handle , event , read_event . header . size , 0 ) ; <NEW_LINE>
g_free ( compr ) ; <NEW_LINE>
int64 modification_time ) ; <NEW_LINE>
if ( ss -> ssl3 . hs . kea_def -> ephemeral ) { <NEW_LINE>ss -> ssl3 . hs . ws = wait_server_key ; <NEW_LINE> } else { <NEW_LINE>ss -> ssl3 . hs . ws = wait_cert_request ; <NEW_LINE> } <NEW_LINE>
AccessCheck::deny ( cx , id ) ; <NEW_LINE>return false ; <NEW_LINE>
#include "components / dom_distiller / content / browser / distiller_ui_handle . h" <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
StoragePartition * storage_partition_ ; <NEW_LINE>
memcpy ( & best_mode -> mbmode , & x -> e_mbd . mode_info_context -> mbmi , sizeof ( MB_MODE_INFO ) ) ; <NEW_LINE>memcpy ( & best_mode -> partition , x -> partition_info , sizeof ( PARTITION_INFO ) ) ; <NEW_LINE>
len = get_line_size ( * b + len , * avail - len , nl ) ; <NEW_LINE>
option = ssplit ( option , " = \t , " , & ovalue ) ; <NEW_LINE>
if ( image == ( Image * ) NULL ) <NEW_LINE>image = screen ; <NEW_LINE>else <NEW_LINE>AppendImageToList ( & image , screen ) ; <NEW_LINE>
dst_name = safe_calloc ( strlen ( name ) * 2 + 16 ) ; <NEW_LINE>
if ( png_ptr -> transformations != 0 ) <NEW_LINE>
me -> active_tracks = 0 ; <NEW_LINE>
while ( ( ch = getopt ( ac , av , "cDdksE:a:P:t:" ) ) != - 1 ) { <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( pStorage -> activeSps -> picWidthInMbs == 0 ) <NEW_LINE> { <NEW_LINE>pStorage -> picSizeInMbs = 0 ; <NEW_LINE> } <NEW_LINE>else if ( pStorage -> activeSps -> picHeightInMbs > <NEW_LINE>UINT32_MAX / pStorage -> activeSps -> picWidthInMbs ) <NEW_LINE> { <NEW_LINE>return ( MEMORY_ALLOCATION_ERROR ) ; <NEW_LINE> } <NEW_LINE>else <NEW_LINE> { <NEW_LINE>pStorage -> picSizeInMbs = <NEW_LINE>pStorage -> activeSps -> picWidthInMbs * <NEW_LINE>pStorage -> activeSps -> picHeightInMbs ; <NEW_LINE> } <NEW_LINE>
mpz_powm_sec ( b , b , key -> e , key -> n ) ; <NEW_LINE>
if ( ! ie1 || ! ie2 ) <NEW_LINE>
static VPX_INLINE signed MEM_VALUE_T \ <NEW_LINE>mem_get_s##end##sz##_aligned ( const void * vmem ) { \ <NEW_LINE>
static void copyMultiCh16 ( short * dst , const int * src [ FLACParser::kMaxChannels ] , unsigned nSamples , unsigned nChannels ) <NEW_LINE>
int sample ) ; <NEW_LINE>
virtual void SetRenderer ( int process_host_id , <NEW_LINE>
obj -> moveDenseArrayElementsUnbarriered ( 0 , 1 , initlen ) ; <NEW_LINE>
Cluster ** const qq = new ( std::nothrow ) Cluster * [ n ] ; <NEW_LINE>if ( qq == NULL ) <NEW_LINE>return false ; <NEW_LINE>
GtkWidget * widget = GetMozContainerWidget ( ) ; <NEW_LINE>
const unsigned char * , uint32_t , size_t , struct magic * ) ; <NEW_LINE>
memcpy ( dst , src , 8 ) ; <NEW_LINE><NEW_LINE>
{ <NEW_LINE>xref = ( MagickOffsetType * ) RelinquishMagickMemory ( xref ) ; <NEW_LINE>ThrowWriterException ( ResourceLimitError , <NEW_LINE>"MemoryAllocationFailed" ) ; <NEW_LINE> } <NEW_LINE>
if ( ( r = sshbuf_put_stringb ( m , state -> input ) ) != 0 || <NEW_LINE>
stream << "array [ " << getArraySize ( ) << " ] of " ; <NEW_LINE>
if ( x == 0 ) { <NEW_LINE><NEW_LINE>ha -> netmask . s_addr = 0 ; <NEW_LINE> } else { <NEW_LINE>ha -> netmask . s_addr = htonl ( 0xFFFFFFFF << ( 32 - x ) ) ; <NEW_LINE> } <NEW_LINE>
return ret ; <NEW_LINE>beach: <NEW_LINE>free ( ptr ) ; <NEW_LINE>
virtual bool requiresLayer ( ) const { return isRoot ( ) || isOutOfFlowPositioned ( ) || isRelPositioned ( ) || isTransparent ( ) || hasTransform ( ) || hasHiddenBackface ( ) || hasMask ( ) || hasReflection ( ) || hasFilter ( ) || style ( ) -> specifiesColumns ( ) ; } <NEW_LINE>
static const PRUint8 * <NEW_LINE>
extern void ssl3_SetSIDSessionTicket ( sslSessionID * sid , <NEW_LINE>NewSessionTicket * session_ticket , <NEW_LINE>PRBool isResumptionUpdate ) ; <NEW_LINE>
va_list args ) <NEW_LINE>
static INLINE unsigned int <NEW_LINE>
RefPtr < TestNode > imp = WTF::getPtr ( proxyImp -> locationWithCallWith ( ) ) ; <NEW_LINE>
if ( aNeedsCxPush && ! pusher . Push ( cx , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ) { <NEW_LINE>
bool seek ( const Position & pos , const TokenStream & other ) ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
left = gdo_len - ( p - gdo ) ; <NEW_LINE>
for ( i = 0 ; ( i + 3 ) < sec -> size ; i += 4 ) { <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
PHP_FUNCTION ( locale_get_display_variant ) <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( mMetadataType [ kPortIndexInput ] == kMetadataBufferTypeGrallocSource ) { <NEW_LINE>header -> nFilledLen = rangeLength ? sizeof ( VideoGrallocMetadata ) : 0 ; <NEW_LINE>
URL_EXPORT std::ostream & operator << ( std::ostream & out , const Origin & origin ) ; <NEW_LINE><NEW_LINE>URL_EXPORT bool IsSameOriginWith ( const GURL & a , const GURL & b ) ; <NEW_LINE>
oggpack_buffer * opb , int maptype ) { <NEW_LINE>
<NEW_LINE>if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && <NEW_LINE> ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && <NEW_LINE>key -> type -> destroy ) <NEW_LINE>
while ( 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) ) <NEW_LINE>
if ( ! ps_dec -> u1_first_slice_in_stream && ps_dec -> u4_first_slice_in_pic ) <NEW_LINE>
CHAR_LEN_TABLE ( ISO2022CNCharLenTable ) , <NEW_LINE>
RefPtr < DocumentFragment > fragment = createFragmentForInnerOuterHTML ( html , parent . get ( ) , ec ) ; <NEW_LINE>
<NEW_LINE>info_ptr -> text [ i ] . compression = PNG_TEXT_COMPRESSION_NONE_WR ; <NEW_LINE>
if ( ! drainOneOutputBuffer ( mFirstPictureId , mFirstPicture ) ) { <NEW_LINE>ALOGE ( "Drain failed" ) ; <NEW_LINE>notify ( OMX_EventError , OMX_ErrorUndefined , 0 , NULL ) ; <NEW_LINE>mSignalledError = true ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>if ( BITMASK_PRESENT ( & m_inp_bm_count , i ) ) { <NEW_LINE>BITMASK_CLEAR ( & m_inp_bm_count , i ) ; <NEW_LINE>if ( m_inp_mem_ptr ) <NEW_LINE>free_input_buffer ( i , & m_inp_mem_ptr [ i ] ) ; <NEW_LINE>else <NEW_LINE>free_input_buffer ( i , NULL ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( release_input_done ( ) ) { <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
PREDICTION_MODE vp9_above_block_mode ( const MODE_INFO * cur_mi , <NEW_LINE>const MODE_INFO * above_mi , int b ) { <NEW_LINE>
if ( ! V8ScriptRunner::callInternalFunction ( v8::Local < v8::Function > ::Cast ( method ) , holder , argc , argv , scriptState -> isolate ( ) ) . ToLocal ( & result ) ) { <NEW_LINE>
#ifndef CHROME_BROWSER_CHROMEOS_UI_SETTING_LEVEL_BUBBLE_VIEW_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_UI_SETTING_LEVEL_BUBBLE_VIEW_H_ <NEW_LINE>
virtual void OnChannelConnected ( int32 peer_pid ) = 0 ; <NEW_LINE>
field_type = get_exif_ui16 ( e , tag_pos + 2 ) ; <NEW_LINE>value_count = get_exif_ui32 ( e , tag_pos + 4 ) ; <NEW_LINE>
pusher . Push ( cx ) ; <NEW_LINE>
while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && <NEW_LINE>ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <NEW_LINE>
result = strToMatch ( lang_tag , cur_arr [ i * 2 ] ) ; <NEW_LINE>
#error "gperf generated tables don't work with this execution character set . Please report a bug to < bug - gnu - gperf@gnu . org > . " <NEW_LINE>
memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <NEW_LINE>memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; <NEW_LINE>
#include "chrome / browser / ui / views / infobars / infobar_view . h" <NEW_LINE>
int64 GetCachedHostUsage ( const std::string & host ) const ; <NEW_LINE>
Copyright ( c ) 2000 , 2016 , Oracle and / or its affiliates . All rights reserved . <NEW_LINE>
unsigned char * ek = NULL , * tkey = NULL ; <NEW_LINE>int eklen , tkeylen ; <NEW_LINE>
class NavigationManagerImpl ; <NEW_LINE>
navigationManager: <NEW_LINE> ( web::NavigationManagerImpl * ) navigationManager <NEW_LINE>
* message = estrndup ( stats_header -> message , stats_header -> message_len ) ; <NEW_LINE>
if ( oldChild -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
if ( ! htmlDocument -> hasNamedItem ( key ) && ! htmlDocument -> hasExtraNamedItem ( key ) ) <NEW_LINE>
nsCOMPtr < nsIScriptContext > m_cx ; <NEW_LINE>
#endif <NEW_LINE>
case CARRAY_COLUMN_POINTER: return SQLITE_OK ; <NEW_LINE>
if ( ret == - EEXIST || ret == - EOVERFLOW ) <NEW_LINE>
bool WouldTaintOrigin ( ) const override ; <NEW_LINE>
sProperties , sFunctions , NULL , NULL ) ; <NEW_LINE>if ( ! proto ) { <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE><NEW_LINE>JSObject * ctor = JS_GetConstructor ( aCx , proto ) ; <NEW_LINE>if ( ! ctor ) { <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( ! dom::DefineConstants ( aCx , ctor , sStaticConstants ) || <NEW_LINE> ! dom::DefineConstants ( aCx , proto , sStaticConstants ) ) { <NEW_LINE>
extern bool cephx_verify_authorizer ( <NEW_LINE>CephContext * cct , KeyStore * keys , <NEW_LINE>bufferlist::iterator & indata , <NEW_LINE>CephXServiceTicketInfo & ticket_info , <NEW_LINE>std::unique_ptr < AuthAuthorizerChallenge > * challenge , <NEW_LINE>bufferlist & reply_bl ) ;
double GetGPMFSampleRate ( size_t handle , uint32_t fourcc , uint32_t flags , double * firstsampletime , double * lastsampletime ) <NEW_LINE>
CHAR_LEN_TABLE ( ISO2022KRCharLenTable ) , <NEW_LINE>
if ( mMaxTextLength != PR_UINT32_MAX ) { <NEW_LINE>NS_ASSERTION ( mMaxTextLength < PR_UINT32_MAX - aFrame -> GetContentLength ( ) , "integer overflow" ) ; <NEW_LINE>if ( mMaxTextLength >= PR_UINT32_MAX - aFrame -> GetContentLength ( ) ) { <NEW_LINE>mMaxTextLength = PR_UINT32_MAX ; <NEW_LINE> } else { <NEW_LINE>mMaxTextLength += aFrame -> GetContentLength ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
if ( ( png_ptr -> mode & PNG_HAVE_IDAT ) == 0 ) <NEW_LINE>
using namespace mozilla::layers ; <NEW_LINE>
#endif <NEW_LINE>#endif
PRInt32 index = 0 ; <NEW_LINE>GetIndexInSubtree ( aContainer , aChild , & index ) ; <NEW_LINE>PRInt32 count = InsertRow ( parentIndex , index , aChild ) ; <NEW_LINE>
random_init_single ( r -> rng_state ( ) , 5489UL ) ; <NEW_LINE>
if ( JSObject * jso = to -> GetJSObjectPreserveColor ( ) ) { <NEW_LINE>JS_SetPrivate ( cx , jso , nsnull ) ; <NEW_LINE>
nsRefPtr < nsStyleContext > styleContext ; <NEW_LINE>GetRuleNodeForContent ( content , getter_AddRefs ( styleContext ) , & ruleNode ) ; <NEW_LINE>
<NEW_LINE>
key = ssplit ( sclone ( argv [ i ] ) , " = " , ( char ** ) & value ) ; <NEW_LINE>
#ifndef BASE_ALLOCATOR_ALLOCATOR_EXTENSION_H_ <NEW_LINE>#define BASE_ALLOCATOR_ALLOCATOR_EXTENSION_H_ <NEW_LINE>
if ( ( base_format & PNG_FORMAT_FLAG_LINEAR ) != 0 && <NEW_LINE> ( image -> flags & PNG_IMAGE_FLAG_16BIT_sRGB ) == 0 ) <NEW_LINE>
typedef struct _php_mcrypt { <NEW_LINE>
#endif
if ( ! image || image -> image ( ) == Image::nullImage ( ) ) <NEW_LINE>
if ( kern_msg -> msg_name ) <NEW_LINE>kern_msg -> msg_name = kern_address ; <NEW_LINE>
@stability Stable <NEW_LINE>
if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy ) ) == NULL ) { <NEW_LINE>
goto trunc ; <NEW_LINE>
m_pInput_pmem [ i ] . buffer = NULL ; <NEW_LINE>
void DidInstallNewDocument ( Document * , InstallNewDocumentReason ) ; <NEW_LINE>
TEMP_FAILURE_RETRY ( usleep ( 200000 ) ) ; <NEW_LINE>
if ( ! sub_rect . IsValid ( ) || sub_rect . X ( ) < 0 || sub_rect . Y ( ) < 0 || <NEW_LINE>sub_rect . MaxX ( ) > image_width || sub_rect . MaxY ( ) > image_height || <NEW_LINE>sub_rect . Width ( ) < 0 || sub_rect . Height ( ) < 0 ) { <NEW_LINE>
if ( SeekBlob ( image , offset , SEEK_CUR ) < 0 ) <NEW_LINE>break ; <NEW_LINE>
#endif <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
png_ptr = png_create_write_struct ( png_get_libpng_ver ( NULL ) , mainprog_ptr , <NEW_LINE>
if ( cv . frame != CrossScriptSSA::OUTER_FRAME || ! analysis -> integerOperation ( cx , pc ) ) <NEW_LINE>
# if DIGITIZE <NEW_LINE>1 . 3 <NEW_LINE># else <NEW_LINE>1 . 0 <NEW_LINE># endif <NEW_LINE> / 255 , data . gamma ) ; <NEW_LINE>
if ( ( cc0 % rowsize ) != 0 ) <NEW_LINE> { <NEW_LINE>TIFFErrorExt ( tif -> tif_clientdata , "PredictorEncodeTile" , <NEW_LINE>" % s" , " ( cc0 % rowsize ) != 0" ) ; <NEW_LINE>return 0 ; <NEW_LINE> } <NEW_LINE>
"The OpenID Connect callback URL received an invalid request" ) , <NEW_LINE>HTTP_INTERNAL_SERVER_ERROR ) ; <NEW_LINE>
<NEW_LINE>
return ret ; <NEW_LINE>
<NEW_LINE><NEW_LINE>static bool ReadLength ( TlsParser * parser , uint16_t version , uint32_t * length ) ; <NEW_LINE><NEW_LINE>
return ContentScriptHasUniversalXPConnect ( ) ; <NEW_LINE>
TEMP_FAILURE_RETRY ( ioctl ( uinput_fd , UI_DEV_DESTROY ) ) ; <NEW_LINE>
#endif <NEW_LINE>
if ( isOutOfFlowPositioned ( ) ) <NEW_LINE>
static void timer_config_save_cb ( void * data ) ; <NEW_LINE>static void btif_config_write ( void ) ; <NEW_LINE>static void btif_config_devcache_cleanup ( void ) ;
DEBUG_PRINT_LOW ( "Value of m_out_mem_ptr % p" , m_out_mem_ptr ) ; <NEW_LINE>
xmlXPtrFreeLocationSet ( newlocset ) ; <NEW_LINE>goto rangeto_error ; <NEW_LINE>
nsIFrame * parent = frame ; <NEW_LINE>nsIFrame * nextParent = next ; <NEW_LINE>while ( parent && nextParent ) { <NEW_LINE>if ( parent == nextParent || <NEW_LINE>nextParent != parent -> GetNextInFlow ( ) || <NEW_LINE> ! parent -> IsFrameOfType ( nsIFrame::eLineParticipant ) || <NEW_LINE> ! nextParent -> IsFrameOfType ( nsIFrame::eLineParticipant ) ) { <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>parent -> SetNextContinuation ( nextParent ) ; <NEW_LINE>nextParent -> SetPrevContinuation ( parent ) ; <NEW_LINE><NEW_LINE>parent = parent -> GetParent ( ) ; <NEW_LINE>nextParent = nextParent -> GetParent ( ) ; <NEW_LINE> } <NEW_LINE>
if ( ! pkthdr -> len || pkthdr -> len < pkthdr -> caplen ) { <NEW_LINE>fprintf ( stderr , "safe_pcap_next ERROR: Invalid packet length in % s: % s ( ) line % d: packet length = % u capture length = % u\n" , <NEW_LINE>
if ( js_doregexec ( J , re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <NEW_LINE>
if ( fileBytes . size ( ) >= 4 && * ( U32 * ) fileBytes . data ( ) == 0x6d736100 ) <NEW_LINE>
if ( Destroyed ( ) ) <NEW_LINE>return ; <NEW_LINE>
#if defined ( JAS_HAVE_GETTIMEOFDAY ) <NEW_LINE>
setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , track_size [ i ] , running_event [ i ] ) ; <NEW_LINE>
|| pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
if ( png_sRGB_checks [ i ] . have_md5 != 0 ) <NEW_LINE>
for ( xval = rval ; * xval != ' [ ' && * xval != ' { ' && * xval ; xval ++ ) <NEW_LINE>
yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <NEW_LINE>
if ( equalIgnoringASCIICase ( siblingAriaRole , role ) ) <NEW_LINE>
<NEW_LINE>
AudioOutputAuthorizationHandler ( media::AudioSystem * audio_system , <NEW_LINE>
int flags = TEMP_FAILURE_RETRY ( fcntl ( fd , F_GETFL , 0 ) ) ; <NEW_LINE>TEMP_FAILURE_RETRY ( fcntl ( fd , F_SETFL , flags | O_NONBLOCK ) ) ; <NEW_LINE>
#ifndef CHROME_BROWSER_CHROMEOS_UI_SETTING_LEVEL_BUBBLE_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_UI_SETTING_LEVEL_BUBBLE_H_ <NEW_LINE>
RefPtr < TestNode > imp = WTF::getPtr ( proxyImp -> locationWithPerWorldBindings ( ) ) ; <NEW_LINE>
other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx , <NEW_LINE>false ) ; <NEW_LINE>
<NEW_LINE>
#ifndef BASE_PROCESS_INTERNAL_LINUX_H_ <NEW_LINE>#define BASE_PROCESS_INTERNAL_LINUX_H_ <NEW_LINE>
if ( 0xD800 <= c && c <= 0xDFFF ) { <NEW_LINE>
- ( void ) dismissModals ; <NEW_LINE>
return close_connection ( conn ) ; <NEW_LINE>
unsigned long resource_id , const GURL & url , int notify_id ) ; <NEW_LINE>virtual webkit_glue::WebPluginResourceClient * CreateSeekableResourceClient ( <NEW_LINE>unsigned long resource_id , int range_request_id ) ; <NEW_LINE>
va_list args ) <NEW_LINE>
AutoPushJSContext cx ( context -> GetNativeContext ( ) ) ; <NEW_LINE>
browserInfo . lParam = nsnull ; <NEW_LINE>
explicit DXVAVideoDecodeAccelerator ( <NEW_LINE>media::VideoDecodeAccelerator::Client * client ) ; <NEW_LINE>
if ( quantum_info != ( QuantumInfo * ) NULL ) <NEW_LINE>quantum_info = DestroyQuantumInfo ( quantum_info ) ; <NEW_LINE>
if ( ( res = ctx -> iface -> enc . encode ( get_alg_priv ( ctx ) , img , pts , <NEW_LINE>
#line 558 "ext / standard / var_unserializer . re" <NEW_LINE>
#define LIBXML_MODULE_EXTENSION " . dll" <NEW_LINE>
FinalizeCallback ( JSFreeOp * fop , JSFinalizeStatus status , JSBool isCompartmentGC ) <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
if ( mCallback && weakFrame . IsAlive ( ) ) <NEW_LINE>
CallbackWrapper * wrapper = new CallbackWrapper ( callbacks ) ; <NEW_LINE>
#ifndef BASE_TEST_SIMPLE_TEST_TICK_CLOCK_H_ <NEW_LINE>#define BASE_TEST_SIMPLE_TEST_TICK_CLOCK_H_ <NEW_LINE>
friend class CCScopedMainThreadProxy ; <NEW_LINE><NEW_LINE><NEW_LINE>static void postTask ( PassOwnPtr < Task > ) ; <NEW_LINE><NEW_LINE>
fPtr = sk_malloc_throw ( size ) ; <NEW_LINE>
AutoPushJSContext cx ( context -> GetNativeContext ( ) ) ; <NEW_LINE>
prefs -> AddObserver ( "gfx . downloadable_fonts . " , fontPrefObserver , PR_FALSE ) ; <NEW_LINE>
s -> peer -> peer = nullptr ; <NEW_LINE>s -> peer -> close ( s -> peer ) ; <NEW_LINE>s -> peer = nullptr ; <NEW_LINE>
<NEW_LINE>
PRUint32 numElementsToUpload = NS_MIN ( location_object -> mArrayLength , JS_GetTypedArrayLength ( wa ) / ( dim * dim ) ) ; \ <NEW_LINE>gl -> f##name ( location , numElementsToUpload , transpose , ( ptrType * ) JS_GetTypedArrayData ( wa ) ) ; \ <NEW_LINE>
else <NEW_LINE> { <NEW_LINE>png_memcpy ( png_ptr -> save_buffer , old_buffer , png_ptr -> save_buffer_size ) ; <NEW_LINE>png_free ( png_ptr , old_buffer ) ; <NEW_LINE>png_ptr -> save_buffer_max = new_max ; <NEW_LINE> } <NEW_LINE>
#if INSIDE_BLINK <NEW_LINE>BLINK_PLATFORM_EXPORT WebMediaConstraint ( const WebCore::MediaConstraint & ) ; <NEW_LINE>
ERR ( "Ipv6 socket open failed" ) ; <NEW_LINE>
<NEW_LINE>
if ( ! PS ( use_only_cookies ) && ! PS ( id ) && <NEW_LINE>
rv = ProcessPseudoRowGroupFrame ( aPresContext , aPseudoFrames . mRowGroup , aHighestFrame ) ; <NEW_LINE>
if ( pos > stop ) <NEW_LINE>return E_FILE_FORMAT_INVALID ; <NEW_LINE>
img = ctx -> iface -> enc . get_preview ( get_alg_priv ( ctx ) ) ; <NEW_LINE>
void ( * mCopy ) ( short * dst , const int * src [ kMaxChannels ] , unsigned nSamples , unsigned nChannels ) ; <NEW_LINE>
m . command = CMD_NONE ; <NEW_LINE>
last mod: $ Id: res0 . c 16552 2009 - 09 - 12 02:09:04Z xiphmont $
#endif <NEW_LINE>
bool preserveChunk = preserveNextChunk ; <NEW_LINE>preserveNextChunk = false ; <NEW_LINE>
NP_RemoveProperty , <NEW_LINE>
FILE_RCSID ( "@ ( # ) $ File: apprentice . c , v 1 . 210 2014 / 05 / 14 23:15:42 christos Exp $ " ) <NEW_LINE>
PRBool returnStringOnly , jsval * rval ) <NEW_LINE>
std::vector < TBuiltInFunction > mFunctions ; <NEW_LINE>
if ( sFocused == this ) { <NEW_LINE>
bool verify_authorizer ( Connection * con , int peer_type , int protocol , bufferlist & auth , <NEW_LINE>bufferlist & auth_reply , <NEW_LINE>bool & isvalid , CryptoKey & session_key , <NEW_LINE>std::unique_ptr < AuthAuthorizerChallenge > * challenge ) ;
jschar * dst , size_t * dstlenp ) <NEW_LINE>
if ( slot >= fp -> argc ) <NEW_LINE>RETURN_STOP_A ( "can't trace out - of - range arguments" ) ; <NEW_LINE>stack ( 0 , get ( & cx -> fp -> argv [ slot ] ) ) ; <NEW_LINE>
const uint64 track_pos_size = <NEW_LINE>EbmlMasterElementSize ( kMkvCueTrackPositions , size ) + size ; <NEW_LINE>const uint64 payload_size = <NEW_LINE>EbmlElementSize ( kMkvCueTime , time_ ) + track_pos_size ; <NEW_LINE>
static void open_input_file ( struct VpxInputContext * input ) { <NEW_LINE>
std::unique_ptr < ScrollPaintPropertyNode > Clone ( ) const { <NEW_LINE>return base::WrapUnique ( <NEW_LINE>new ScrollPaintPropertyNode ( Parent ( ) , State ( state_ ) ) ) ; <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , addr ) ; <NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
delete [ ] language_ ; <NEW_LINE>
let maintSvcDir = getMaintSvcDir ( ) ; <NEW_LINE>
void OnCheckForCancel ( int32 preview_ui_id , <NEW_LINE>
#endif <NEW_LINE>
BufferMeta * bufferMeta = new BufferMeta ( graphicBuffer , portIndex ) ; <NEW_LINE>
if ( ! send && ! SSL_READ_ETM ( ssl ) && <NEW_LINE>
unsigned int svcrdma_max_req_size = RPCRDMA_DEF_INLINE_THRESH ; <NEW_LINE>static unsigned int min_max_inline = RPCRDMA_DEF_INLINE_THRESH ; <NEW_LINE>static unsigned int max_max_inline = RPCRDMA_MAX_INLINE_THRESH ; <NEW_LINE>
inliningDepth_ ( inliningDepth ) , <NEW_LINE>
ret = ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ; <NEW_LINE>if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) <NEW_LINE> { <NEW_LINE>return ret ; <NEW_LINE> } <NEW_LINE>
static void generate_filename ( const char * pattern , char * out , size_t q_len , <NEW_LINE>unsigned int d_w , unsigned int d_h , <NEW_LINE>unsigned int frame_in ) { <NEW_LINE>
static const uint8_t bifilter4_coeff [ 8 ] [ 2 ] = { <NEW_LINE>
if ( peer -> code ( ) && IsFragmentGraphWithUnreachableGCThing ( cx , peer ) ) <NEW_LINE>
<NEW_LINE>
const FetchInitiatorInfo & , <NEW_LINE>Resource::Type ) { <NEW_LINE>
vp8_pack_tokens ( w , p , tokens ) ; <NEW_LINE>
uint16_t type , phnum , shnum , notecount ; <NEW_LINE>
vpx_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ; <NEW_LINE>
if ( mprWriteJsonObj ( app -> config , key , credentials ) < 0 ) { <NEW_LINE>
segment -> AppendSlice ( * aInputTrack -> GetSegment ( ) , <NEW_LINE>
public:
uint32_t bufLength = arrayBuffer . byteLength ( ) ; <NEW_LINE>if ( begin > bufLength || end > bufLength || begin > end ) { <NEW_LINE>JS_ReportErrorNumber ( cx , js_GetErrorMessage , NULL , JSMSG_TYPE_ERR_BAD_ARGS ) ; <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
if ( retval ) <NEW_LINE>return retval ; <NEW_LINE><NEW_LINE>args -> flags &= ~ ATTR_REPLACE ; <NEW_LINE>
s [ 1 ] = '\0' ; <NEW_LINE>
#include "cc / CCScopedMainThreadProxy . h" <NEW_LINE>
return mPartChannel -> SendOnDataAvailable ( mContext , inStream , offset , aLen ) ; <NEW_LINE>
! js_data . isObject ( ) ) <NEW_LINE>
{ <NEW_LINE>tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <NEW_LINE>if ( ! tmp2 ) <NEW_LINE>free ( tmp ) ; <NEW_LINE>tmp = tmp2 ; <NEW_LINE> } <NEW_LINE>
nsCOMPtr < nsIContent > content = do_QueryReferent ( mContent ) ; <NEW_LINE>nsCOMPtr < nsIRunnable > event = new AsyncPaintWaitEvent ( content , false ) ; <NEW_LINE>
if ( at_start != 0 ) <NEW_LINE>
#endif
<NEW_LINE>if ( hdr -> name [ 99 ] ) { <NEW_LINE>strncat ( name , hdr -> name , 100 ) ; <NEW_LINE> } else { <NEW_LINE>strcat ( name , hdr -> name ) ; <NEW_LINE> } <NEW_LINE>
if ( pCmdData == NULL || <NEW_LINE>cmdSize < ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || <NEW_LINE>pReplyData == NULL || replySize == NULL || <NEW_LINE> * replySize != sizeof ( int32_t ) ) { <NEW_LINE>
XPCJSRuntime::FinalizeCallback ( JSFreeOp * fop , JSFinalizeStatus status , JSBool isCompartmentGC ) <NEW_LINE>
extern uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint32_t siz , uint8_t running_event ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
<NEW_LINE>
void * syscall_page = ( void * ) get_zeroed_page ( GFP_ATOMIC ) ; <NEW_LINE>syscall_pages [ 0 ] = virt_to_page ( syscall_page ) ; <NEW_LINE>
int port_length = 0 ; <NEW_LINE>if ( mPort != - 1 ) { <NEW_LINE>nsAutoCString buf ; <NEW_LINE>buf . Assign ( ':' ) ; <NEW_LINE>buf . AppendInt ( mPort ) ; <NEW_LINE>port_length = buf . Length ( ) ; <NEW_LINE> } <NEW_LINE>mHost . mPos = mAuthority . mPos + mAuthority . mLen - port_length ; <NEW_LINE>
struct perf_sample_data * data , <NEW_LINE>
long WebPImage::getHeaderOffset ( byte * data , long data_size , byte * header , long header_size ) <NEW_LINE> { <NEW_LINE>if ( data_size < header_size ) { return - 1 ; } <NEW_LINE>
else { <NEW_LINE>jsExceptionHere ( JSET_ERROR , "vertical_byte only works for 1bpp ArrayBuffers\n" ) ; <NEW_LINE>return 0 ; <NEW_LINE> } <NEW_LINE>if ( gfx . data . height & 7 ) { <NEW_LINE>jsExceptionHere ( JSET_ERROR , "height must be a multiple of 8 when using vertical_byte\n" ) ; <NEW_LINE>return 0 ; <NEW_LINE> } <NEW_LINE>
const ComputedStyle * RootElementStyle ( ) const { <NEW_LINE>return root_element_style_ . get ( ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>if ( qcms_supports_iccv4 && <NEW_LINE> ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && <NEW_LINE> ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) ) <NEW_LINE> {
fPtr = ( T * ) sk_malloc_throw ( count , sizeof ( T ) ) ; <NEW_LINE>
if ( newChild -> isFloatingOrOutOfFlowPositioned ( ) ) { <NEW_LINE>
{ 0xd5b1e3c5 , 0x85dc , 0x403e , \ <NEW_LINE> { 0xbb , 0x4a , 0x54 , 0x66 , 0xdc , 0xbe , 0x15 , 0x69 } } <NEW_LINE>
return 0 ; <NEW_LINE>
<NEW_LINE>if ( newPtr != nullptr && newPtr == oldPtr ) { <NEW_LINE>NS_RUNTIMEABORT ( "Logic flaw in the caller" ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
<NEW_LINE>
xmlGenericError , xmlGenericError , NULL ) ; <NEW_LINE>
#endif
#if ENABLE_BGP_VNC_ATTR <NEW_LINE>
if ( ( m -> type != FILE_REGEX || ( m -> str_flags & REGEX_LINE_COUNT ) == 0 ) && <NEW_LINE> ( m -> type != FILE_PSTRING && ( m -> str_flags & PSTRING_LEN ) != 0 ) ) { <NEW_LINE>
if ( document -> hasNamedItem ( name ) || document -> hasExtraNamedItem ( name ) ) <NEW_LINE>
if ( need_expand != 0 ) <NEW_LINE>
LIBRAW_WARN_FALLBACK_TO_AHD = 1 << 15 , <NEW_LINE>LIBRAW_WARN_PARSEFUJI_PROCESSED = 1 << 16 <NEW_LINE>
aReflowState -> SetComputedHeightWithoutResettingResizeFlags ( <NEW_LINE>aReflowState -> ComputedHeight ( ) - scrollbars . TopBottom ( ) ) ; <NEW_LINE>
<NEW_LINE>
rv = verifyPKCS1DigestInfo ( cx , digest ) ; <NEW_LINE>
const PixelStoreParams & unpack_params , <NEW_LINE>
#include "chrome / browser / chromeos / audio / audio_mixer . h" <NEW_LINE>
mElements . AppendObject ( aContent ) ; <NEW_LINE>
bool hasVarTag ) ; <NEW_LINE>
depth , ( i . isIon ( ) ? 0 : i . interpFrame ( ) ) , <NEW_LINE>filename , line , <NEW_LINE>
if ( ! mTimeToSample . empty ( ) || data_size < 8 ) { <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
if ( ( info_ptr -> valid & PNG_INFO_sPLT ) != 0 ) <NEW_LINE>
<NEW_LINE>
if ( XrayUtils::IsTransparent ( cx , wrapper , JSID_VOID ) ) { <NEW_LINE>
if ( channel ) { <NEW_LINE>rv = NS_DispatchToCurrentThread ( new RedirectRunnable ( this , channel ) ) ; <NEW_LINE>if ( NS_SUCCEEDED ( rv ) ) <NEW_LINE>mWaitingOnAsyncRedirect = PR_TRUE ; <NEW_LINE>return rv ; <NEW_LINE> } <NEW_LINE>
ignore = fscanf ( fp , "Output file name: % 511s\n" , buf ) ; <NEW_LINE>
v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p24_p08 ) ; <NEW_LINE>v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p24_p08 ) ; <NEW_LINE>v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_m24 ) ; <NEW_LINE>v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_m24 ) ; <NEW_LINE>
return obj -> isFloating ( ) || ( obj -> isOutOfFlowPositioned ( ) && ! obj -> style ( ) -> isOriginalDisplayInlineType ( ) && ! obj -> container ( ) -> isRenderInline ( ) ) ; <NEW_LINE>
DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown ; <NEW_LINE>
return std::make_unique < T > ( std::forward < Args > ( args ) . . . ) ; <NEW_LINE>
ENGINE_SET_INVALID_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <NEW_LINE>
{ <NEW_LINE>annotate_info = DestroyDrawInfo ( annotate_info ) ; <NEW_LINE>annotate = DestroyDrawInfo ( annotate ) ; <NEW_LINE>return ( MagickFalse ) ; <NEW_LINE> } <NEW_LINE>
memcpy ( mbd -> dequant_y1_dc , xd -> dequant_y1_dc , sizeof ( xd -> dequant_y1_dc ) ) ; <NEW_LINE>memcpy ( mbd -> dequant_y1 , xd -> dequant_y1 , sizeof ( xd -> dequant_y1 ) ) ; <NEW_LINE>memcpy ( mbd -> dequant_y2 , xd -> dequant_y2 , sizeof ( xd -> dequant_y2 ) ) ; <NEW_LINE>memcpy ( mbd -> dequant_uv , xd -> dequant_uv , sizeof ( xd -> dequant_uv ) ) ; <NEW_LINE>
static PassOwnPtr < SuccessCallbackImpl > create ( HelperType * helper ) <NEW_LINE>
if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , <NEW_LINE>rootfs -> path ? rootfs -> mount : NULL ) != 0 ) { <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
ND_PRINT ( ( ndo , " % s at " , <NEW_LINE>linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; <NEW_LINE>tpaddr_print_ip ( ndo , ap , pro ) ; <NEW_LINE>
ret = TEMP_FAILURE_RETRY ( poll ( & pfd , 1 , 1 ) ) ; <NEW_LINE>
#ifndef BASE_ANDROID_TRACE_EVENT_BINDING_H_ <NEW_LINE>#define BASE_ANDROID_TRACE_EVENT_BINDING_H_ <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( reinterpret_cast < RefBase::weakref_type * > ( <NEW_LINE>tr . target . ptr ) -> attemptIncStrong ( this ) ) { <NEW_LINE>error = reinterpret_cast < BBinder * > ( tr . cookie ) -> transact ( tr . code , buffer , <NEW_LINE> & reply , tr . flags ) ; <NEW_LINE>reinterpret_cast < BBinder * > ( tr . cookie ) -> decStrong ( this ) ; <NEW_LINE> } else { <NEW_LINE>error = UNKNOWN_TRANSACTION ; <NEW_LINE> } <NEW_LINE>
touches [ index ] . updateState ( BlackBerry::Platform::TouchPoint::TouchReleased ) ; <NEW_LINE>
<NEW_LINE>
frame . thisp = OBJ_THIS_OBJECT ( cx , frame . thisp ) ; <NEW_LINE>
AutoPushJSContext cx ( boundContext -> GetNativeContext ( ) ) ; <NEW_LINE>
__android_log_print ( ANDROID_LOG_INFO , "Gecko" , " % s" , msg . get ( ) ) ; <NEW_LINE>
JSString * str = Int32ToString ( cx , JSID_TO_INT ( id ) ) ; <NEW_LINE>
txCopy * copy = static_cast < txCopy * > ( aState . popPtr ( aState . eCopy ) ) ; <NEW_LINE>
<NEW_LINE>
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) ) <NEW_LINE>
m_canCollapseWithChildren = ! block -> isRenderView ( ) && ! block -> isRoot ( ) && ! block -> isOutOfFlowPositioned ( ) <NEW_LINE>
if ( ( uval & 0x80000000 ) == 0 ) <NEW_LINE>return - ( png_int_32 ) uval ; <NEW_LINE><NEW_LINE>return 0 ; <NEW_LINE>
<NEW_LINE>return js::Handle < js::GlobalObject * > ::fromMarkedLocation ( compartment -> global_ . unsafeGet ( ) ) ; <NEW_LINE>
<NEW_LINE>
if ( ( png_ptr -> flags & <NEW_LINE> ( PNG_FLAG_STRIP_ERROR_NUMBERS | PNG_FLAG_STRIP_ERROR_TEXT ) ) != 0 ) <NEW_LINE>
if ( sc_asn1_read_tag ( & body , rbuflen , & cla_out , & tag_out , & bodylen ) != SC_SUCCESS <NEW_LINE>
if ( default_duration_ ) <NEW_LINE>size += EbmlElementSize ( kMkvDefaultDuration , default_duration_ ) ; <NEW_LINE>
if ( cgroup ) { <NEW_LINE>if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) <NEW_LINE>return - ENOENT ; <NEW_LINE>if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) <NEW_LINE>return - EACCES ; <NEW_LINE>
<NEW_LINE>
if ( segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) { <NEW_LINE>const int data = get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ; <NEW_LINE>
<NEW_LINE>
printf ( "unsquashfs version 4 . 3 - git ( 2019 / 07 / 15 ) \n" ) ; \ <NEW_LINE>
#endif
<NEW_LINE><NEW_LINE>if ( cm -> filter_level > 0 && update_any_ref_buffers ) <NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
if ( ( api_id < USB_API_WINUSBX ) || ( api_id >= USB_API_MAX ) ) { <NEW_LINE>
class BASE_API Pickle { <NEW_LINE>
get_key_type ( keyType , valstr , sizeof valstr ) ; <NEW_LINE>
if ( location == 0 && ( png_ptr -> mode & PNG_IS_READ_STRUCT ) == 0 ) <NEW_LINE>
if ( ( read = TEMP_FAILURE_RETRY ( recv ( fd , p , len , MSG_NOSIGNAL ) ) ) == - 1 ) <NEW_LINE>
<NEW_LINE>
mozilla::Mutex mThreadPoolMutex ; <NEW_LINE>nsCOMPtr < nsIThreadPool > mThreadPool ; <NEW_LINE>
uint32_t l_w = img1 -> d_w ; <NEW_LINE>uint32_t c_w = <NEW_LINE>
if ( ! peer && sip_cfg . alwaysauthreject && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_REGISTERTRYING ) ) { <NEW_LINE>
nsresult rv = proxyEnv . getOrSetFakeOrigin ( ( nsCSecurityContext * ) securityContext ) ; <NEW_LINE>if ( NS_SUCCEEDED ( rv ) ) <NEW_LINE>secureEnv -> NewObject ( clazz , method -> mMethodID , args , & outObject , securityContext ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>nsRefPtr < DOMSVGLengthList > animVal = mAList -> mAnimVal ; <NEW_LINE>
nsCOMPtr < nsIDocument > doc = <NEW_LINE>nsContentUtils::GetDocumentFromScriptContext ( mScriptContext ) ; <NEW_LINE>
finishedNunboxSlots_ . append ( candidate -> lastInterval ( ) ) ; <NEW_LINE>
ND_PRINT ( ( ndo , " % 04x: % s " , panid , le64addr_string ( ndo , p ) ) ) ; <NEW_LINE>
void LearnOrigins ( <NEW_LINE>const std::string & host , <NEW_LINE>const GURL & main_frame_origin , <NEW_LINE>const std::map < url::Origin , OriginRequestSummary > & summaries ) ; <NEW_LINE>
fPtr = ( T * ) sk_malloc_throw ( count , sizeof ( T ) ) ; <NEW_LINE>
#include "base / callback_old . h" <NEW_LINE>
if ( m_loadEventProgress != LoadEventInProgress && pageDismissalEventBeingDispatched ( ) == NoDismissal ) <NEW_LINE>
pusher . Push ( ctx ) ; <NEW_LINE>
static INLINE void add_token ( TOKENEXTRA ** t , const vpx_prob * context_tree , <NEW_LINE>int32_t extra , uint8_t token , <NEW_LINE>
<NEW_LINE>if ( i . isIon ( ) ) <NEW_LINE>continue ; <NEW_LINE>if ( dbg -> observesFrame ( i . interpFrame ( ) ) ) <NEW_LINE>return dbg -> getScriptFrame ( cx , i . interpFrame ( ) , vp ) ; <NEW_LINE>
! method . LowerCaseEqualsLiteral ( "get" ) && <NEW_LINE> ! method . LowerCaseEqualsLiteral ( "head" ) ) { <NEW_LINE>
bool initialized ( ) const { return ! elems_ . empty ( ) ; } <NEW_LINE>void initElems ( FuncPtrVector && elems ) { elems_ = Move ( elems ) ; JS_ASSERT ( initialized ( ) ) ; } <NEW_LINE>unsigned numElems ( ) const { JS_ASSERT ( initialized ( ) ) ; return elems_ . length ( ) ; } <NEW_LINE>
return mDocShell -> InternalLoad ( mURI , mOriginalURI , <NEW_LINE>mReferrer , <NEW_LINE>
nsStyleLinkElement::SetStyleSheet ( nsnull ) ; <NEW_LINE>
snprintf ( buf , L_BUFSIZE , " % f % f\n" , valx , valy ) ; <NEW_LINE>
return hdrlen + 2 + addr_len ; <NEW_LINE>
unsigned long timeleft , request_size , copy_size ; <NEW_LINE>
m_hasBorderOrPaddingLogicalWidthChanged = oldStyle && diff . needsFullLayout ( ) && needsLayout ( ) && borderOrPaddingLogicalWidthChanged ( oldStyle , newStyle ) ;
WORD32 i , j ; <NEW_LINE>
if ( num != ( unsigned int ) png_ptr -> num_palette || <NEW_LINE>num > ( unsigned int ) PNG_MAX_PALETTE_LENGTH ) <NEW_LINE>
802 , 806 , 833 , 871 , 917 , 939 , 948 , 957 , 972 , 984 , <NEW_LINE>998 , 1011 , 1022 , 1033 , 1063 , 1032 , 1177 , 1176 , 1255 , 1261 , <NEW_LINE>1268 , 1267 , 1330 , 1329 , 1390 , 1399 , 1408 , 1417 , 1426 , 1435 , <NEW_LINE>1444 , 1448 , 1456 , 1457 , 1462 , 1484 , 1496 , 1512 , 1511 , 1517 , <NEW_LINE>1528 , 1529 , 1534 , 1541 , 1552 , 1553 , 1557 , 1565 , 1569 , 1579 , <NEW_LINE>1593 , 1609 , 1619 , 1628 , 1653 , 1665 , 1677 , 1693 , 1705 , 1721 , <NEW_LINE>1766 , 1785 , 1803 , 1821 , 1839 , 1865 , 1883 , 1893 , 1903 , 1913 , <NEW_LINE>1923 , 1933 , 1943 <NEW_LINE>
<NEW_LINE>if ( lhs -> isFinite ( ) || rhs -> isFinite ( ) ) <NEW_LINE> * nullRange = true ; <NEW_LINE>
<NEW_LINE><NEW_LINE>base::ProcessHandle parentHandle = 0 ; <NEW_LINE>if ( XRE_GetProcessType ( ) != GeckoProcessType_GMPlugin ) { <NEW_LINE>mozilla::DebugOnly < bool > ok = base::OpenProcessHandle ( parentPID , & parentHandle ) ; <NEW_LINE>NS_ABORT_IF_FALSE ( ok , "can't open handle to parent" ) ; <NEW_LINE> } <NEW_LINE>
nsCOMPtr < nsIContent > parent = child -> GetParent ( ) ; <NEW_LINE>
namespace media { <NEW_LINE>class AudioSystem ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_SCALE_16 ) != 0 ) <NEW_LINE><NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , <NEW_LINE>
DecodePool::Singleton ( ) -> DecodeSomeOfImage ( mImage , DECODE_ASYNC , type , mRequest -> mBytesToDecode ) ; <NEW_LINE>
strncpy ( rcomp . type , "compression" , sizeof ( rcomp . type ) ) ; <NEW_LINE>
extern const char kEnableContextualSearchContextualCardsBarIntegration [ ] ; <NEW_LINE>
int max_file_size = 0 , skip_upload = 0 , anonindex = 0 ; <NEW_LINE>
bits [ 0 ] = cpu_to_be64 ( sctx -> count [ 1 ] << 3 | sctx -> count [ 0 ] >> 61 ) ;
{ <NEW_LINE>MATLAB_KO: <NEW_LINE>clone_info = DestroyImageInfo ( clone_info ) ; <NEW_LINE>ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( mInstanceOwner ) <NEW_LINE>QueueCheckPluginStopEvent ( ) ; <NEW_LINE>
int range_request_id ) ; <NEW_LINE>
const long long seekIdId = ReadID ( pReader , pos , len ) ; <NEW_LINE>if ( seekIdId < 0 ) <NEW_LINE>return false ; <NEW_LINE>
windowInfo . windowSize = mainFrame -> view ( ) -> visibleContentRect ( includeScrollbars ) . size ( ) ; <NEW_LINE>if ( ! m_document -> settings ( ) -> applyPageScaleFactorInCompositor ( ) ) <NEW_LINE>windowInfo . windowSize . scale ( 1 / m_document -> page ( ) -> deviceScaleFactor ( ) ) ; <NEW_LINE>
char t = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ; <NEW_LINE><NEW_LINE> * d ++ = ( char ) ( ( isprint ( t ) ) ? t : ' ' ) ; <NEW_LINE>
dwc3_gadget_del_and_unmap_request ( dep , req , ret ) ; <NEW_LINE>
u64 vmacache_seqnum ; <NEW_LINE>
<NEW_LINE>if ( png_ptr -> interlaced != 0 && <NEW_LINE> ( png_ptr -> transformations & PNG_INTERLACE ) != 0 ) <NEW_LINE>
uint64_t slotMask = 0 ; <NEW_LINE>
envelope_lookup * ve ; <NEW_LINE>
else if ( ( png_ptr -> color_type & PNG_COLOR_MASK_COLOR ) != 0 ) <NEW_LINE>
return 0 ; <NEW_LINE>
if ( intlocation >= 0 ) { <NEW_LINE>WebGLUniformInfo info = prog -> GetUniformInfoForMappedIdentifier ( mappedName ) ; <NEW_LINE>loc = new WebGLUniformLocation ( this , <NEW_LINE>prog , <NEW_LINE>intlocation , <NEW_LINE>info ) ; <NEW_LINE>NS_ADDREF ( loc ) ; <NEW_LINE> } <NEW_LINE>
bool IsSandboxed ( SandboxFlags mask ) const { <NEW_LINE>return IsSandboxed ( mask , sandbox_flags_ ) ; <NEW_LINE> } <NEW_LINE>static bool IsSandboxed ( SandboxFlags mask , SandboxFlags sandbox_flags ) { <NEW_LINE>return sandbox_flags & mask ; <NEW_LINE> } <NEW_LINE>
SetQuotes ( PR_TRUE ) ; <NEW_LINE>
int best_filt_val ; <NEW_LINE>
nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>
char * ext , szName [ 1024 ] , szExt [ 20 ] ; <NEW_LINE>
<NEW_LINE><NEW_LINE>nsresult rv = DecodeSomeOfImage ( aImg , DECODE_ASYNC , DECODE_TYPE_UNTIL_SIZE ) ; <NEW_LINE>
<NEW_LINE>jsuint oldsize = ARRAY_DENSE_LENGTH ( obj ) ; <NEW_LINE>if ( oldsize >= newlen && ! ResizeSlots ( cx , obj , oldsize , newlen ) ) <NEW_LINE>
int count = snprintf ( dest , destlen , " % s . hcache" , path ) ; <NEW_LINE><NEW_LINE><NEW_LINE>char * first = strchr ( dest , ' / ' ) ; <NEW_LINE>char * last = strrchr ( dest , ' / ' ) ; <NEW_LINE>if ( first && last && ( last > first ) ) <NEW_LINE> { <NEW_LINE>memmove ( first , last , strlen ( last ) + 1 ) ; <NEW_LINE>count - = ( last - first ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>return count ; <NEW_LINE>
if ( o -> isReplaced ( ) || o -> isFloating ( ) || o -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
length = BOTAN_CHECKED_ADD ( length , item_size ) ; <NEW_LINE>length = BOTAN_CHECKED_ADD ( length , tag_size ) ; <NEW_LINE>length = BOTAN_CHECKED_ADD ( length , length_size ) ; <NEW_LINE>
! defined ( CONFIG_ARCH_K3 ) && ! defined ( CONFIG_ARCH_BCM68360 ) && \ <NEW_LINE> ! defined ( CONFIG_ARCH_BCM6858 ) && ! defined ( CONFIG_ARCH_BCM63158 ) && \ <NEW_LINE> ! defined ( CONFIG_ARCH_ROCKCHIP ) && ! defined ( CONFIG_ARCH_LX2160A ) && \ <NEW_LINE> ! defined ( CONFIG_ARCH_LS1028A ) && ! defined ( CONFIG_ARCH_LS2080A ) && \ <NEW_LINE> ! defined ( CONFIG_ARCH_LS1088A ) && ! defined ( CONFIG_ARCH_ASPEED ) && \ <NEW_LINE> ! defined ( CONFIG_ARCH_U8500 ) <NEW_LINE>
if ( ( png_ptr -> mode & PNG_IS_READ_STRUCT ) != 0 ) <NEW_LINE>
aImg -> mDecodingMonitor . AssertCurrentThreadIn ( ) ; <NEW_LINE>
if ( Cr_image -> matte != MagickFalse ) <NEW_LINE>
uint64 cue_size = 0 ; <NEW_LINE>for ( int32 i = 0 ; i < cues_ . cue_entries_size ( ) ; ++ i ) <NEW_LINE>cue_size += cues_ . GetCueByIndex ( i ) -> Size ( ) ; <NEW_LINE>for ( int32 i = 0 ; i < cues_ . cue_entries_size ( ) ; ++ i ) <NEW_LINE>
* addr_len = sizeof ( * sin6 ) ; <NEW_LINE>
PNG_FP_1 ) != 0 && png_gamma_significant ( gtest ) == 0 ) <NEW_LINE>
if ( vsa && vportno > 0 ) { <NEW_LINE>
if ( mMimeTypes ) { <NEW_LINE>mMimeTypes -> Invalidate ( ) ; <NEW_LINE>mMimeTypes = nsnull ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( mPlugins ) { <NEW_LINE>mPlugins -> Invalidate ( ) ; <NEW_LINE>mPlugins = nsnull ; <NEW_LINE> } <NEW_LINE>
class BASE_EXPORT ComponentContext { <NEW_LINE>
imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx , imsy ) ; <NEW_LINE>
<NEW_LINE>
NS_FAILED ( * aErrorCode ) && <NEW_LINE>mUnicharData -> GetBufferSize ( ) > mUnicharDataLength ) ; <NEW_LINE>
virtual bool ShouldSwapProcessesForNavigation ( <NEW_LINE>content::SiteInstance * site_instance , <NEW_LINE>const GURL & current_url , <NEW_LINE>const GURL & new_url ) OVERRIDE ; <NEW_LINE>
typedef js::HashMap < JSObject * , Value , DefaultHasher < JSObject * > , RuntimeAllocPolicy > <NEW_LINE>ObjectValueMap ; <NEW_LINE>
strncpy ( rhash . type , "ahash" , sizeof ( rhash . type ) ) ; <NEW_LINE>
if ( buf_size < 26 ) { <NEW_LINE>
png_uint_32 x , unsigned int sample_index , int swap16 , int littleendian ) <NEW_LINE>
bool has_background_page ( ) const { <NEW_LINE>return background_url_ . is_valid ( ) || ! background_scripts_ . empty ( ) ; <NEW_LINE> } <NEW_LINE>const std::vector < std::string > & background_scripts ( ) const { <NEW_LINE>return background_scripts_ ; <NEW_LINE> } <NEW_LINE>
row_info . pixel_depth != png_ptr -> transformed_pixel_depth ) <NEW_LINE>
" $ 3 status: For 'ERR' the accumulated status code from 'EXIT CODES' above . " , <NEW_LINE>
return false ; <NEW_LINE>
const unsigned int blockSize = cipher_def -> block_size ; <NEW_LINE>
if ( ( png_ptr -> transformations & PNG_INTERLACE ) != 0 ) <NEW_LINE>
pngtest_check_text_support ( png_structp png_ptr , png_textp text_ptr , <NEW_LINE>
mClipboardType , mItems , mDragImage , mDragImageX , mDragImageY ) ; <NEW_LINE>
nsresult BuildURIfromBase ( const char * aURL , nsIURI ** aBuiltURI , <NEW_LINE>JSContext ** aCXused ) ; <NEW_LINE>
bool NS_FASTCALL SetLength ( size_type newLength ) ; <NEW_LINE>
clipboardData = new nsDOMDataTransfer ( aType , aType == NS_PASTE , aClipboardType ) ; <NEW_LINE>
BASE_API bool BaseInitLoggingImpl ( const PathChar * log_file , <NEW_LINE>LoggingDestination logging_dest , <NEW_LINE>LogLockingState lock_log , <NEW_LINE>OldFileDeletionState delete_old , <NEW_LINE>DcheckState dcheck_state ) ;
<NEW_LINE>nsRefPtr < nsPresContext > presContext = GetPresContext ( ) ; <NEW_LINE>if ( presContext -> Document ( ) != aParentNode -> OwnerDoc ( ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>
nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>
smart_str_free ( & out_buf ) ; <NEW_LINE>
CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ; <NEW_LINE>
#line 10270 "dcraw / dcraw . c" <NEW_LINE>
MPrepareCall * getPrepareCall ( ) { <NEW_LINE>return getOperand ( PrepareCallOperandIndex ) -> toPrepareCall ( ) ; <NEW_LINE> } <NEW_LINE>
BlobRegistry::registerBlobURL ( m_internalURL , blobData ) ; <NEW_LINE>
bool LoadedNonEmptyDocument ( ) const { return did_load_non_empty_document_ ; } <NEW_LINE>void DidLoadNonEmptyDocument ( ) { did_load_non_empty_document_ = true ; } <NEW_LINE>
verbose ( env , "\nfrom % d to % d % s:" , <NEW_LINE>env -> prev_insn_idx , env -> insn_idx , <NEW_LINE>env -> cur_state -> speculative ? <NEW_LINE>" ( speculative execution ) " : "" ) ; <NEW_LINE>
char * buff ; <NEW_LINE><NEW_LINE>if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { <NEW_LINE>error_line ( " % s is not a valid . DFF file ! " , infilename ) ; <NEW_LINE>return WAVPACK_SOFT_ERROR ; <NEW_LINE> } <NEW_LINE><NEW_LINE>buff = malloc ( bytes_to_copy ) ; <NEW_LINE>
#ifndef CHROME_BROWSER_CHROMEOS_AUDIO_AUDIO_HANDLER_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_AUDIO_AUDIO_HANDLER_H_ <NEW_LINE>
last mod: $ Id: bitrate . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE>
& profile , & proflen ) != 0 ) <NEW_LINE>
result = mRedoStack -> Pop ( getter_AddRefs ( item ) ) ; <NEW_LINE>
<NEW_LINE>
face = gr_make_face_with_ops ( & dummyFace , & face_handle::ops , 0 ) ; <NEW_LINE>testAssert ( "fail gracefully on bad table" , ! face ) ; <NEW_LINE>
std::map < std::string , std::string > & varyingLongNameMap ) <NEW_LINE>
<NEW_LINE>std::set < AutoplaySource > m_sources ; <NEW_LINE><NEW_LINE>
fMemArray = sk_malloc_throw ( fAllocCount , sizeof ( T ) ) ; <NEW_LINE>
( * resp ) -> resp = calloc ( 1024 , 1 ) ; <NEW_LINE>
if ( tm -> outOfMemory ( ) || <NEW_LINE>OverfullJITCache ( tm ) || <NEW_LINE> ! tm -> tracedScripts . put ( cx -> fp ( ) -> script ( ) ) ) { <NEW_LINE>if ( ! OverfullJITCache ( tm ) ) <NEW_LINE>js_ReportOutOfMemory ( cx ) ; <NEW_LINE>
<NEW_LINE>buffer . assign ( buf_size , 1 , 1 , 1 , 0 ) ; <NEW_LINE>
printf ( " % s % d % d % d % d % ld\n" , fmtname , numcmpts , width , height , depth , <NEW_LINE>JAS_CAST ( long , jas_image_rawsize ( image ) ) ) ; <NEW_LINE>
png_ptr -> options = ( png_byte ) ( ( ( current & ~ mask ) | setting ) & 0xff ) ; <NEW_LINE>
class CSSParserImpl : public nsICSSParser_1_9_2 { <NEW_LINE>
PRUint32 textLength = mText . GetLength ( ) ; <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
<NEW_LINE>StartupCache * cache = ( principal == mSystemPrincipal ) <NEW_LINE> ? StartupCache::GetSingleton ( ) <NEW_LINE>: nsnull ; <NEW_LINE>
return 1 ; <NEW_LINE>
result = parse_rock_ridge_inode_internal ( de , inode , <NEW_LINE>flags | RR_REGARD_XA ) ; <NEW_LINE>
if ( is_screen != 0 ) <NEW_LINE>
class MEDIA_GPU_EXPORT H264Picture <NEW_LINE>: public base::RefCountedThreadSafe < H264Picture > { <NEW_LINE>
option = ssplit ( option , " = , " , & ovalue ) ; <NEW_LINE>
<NEW_LINE>
#ifndef BlobRegistry_h <NEW_LINE>#define BlobRegistry_h <NEW_LINE>
if ( status == APR_ECONNRESET ) { <NEW_LINE>ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , status , session -> c , <NEW_LINE>"h2 - stream ( % ld - % d ) : on_header , reset stream" , <NEW_LINE>session -> id , stream -> id ) ; <NEW_LINE>nghttp2_submit_rst_stream ( ngh2 , NGHTTP2_FLAG_NONE , stream -> id , <NEW_LINE>NGHTTP2_INTERNAL_ERROR ) ; <NEW_LINE> } <NEW_LINE>else if ( status != APR_SUCCESS && ! h2_stream_is_ready ( stream ) ) { <NEW_LINE>
TEMP_FAILURE_RETRY ( write ( sockfd [ 1 ] , & byte , 1 ) ) ; <NEW_LINE>
<NEW_LINE>bool is_cors_cross_origin_ = false ;
if ( ! EnsureStringLength ( output , resultLen ) ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE>
AutoPushJSContext cx ( scriptContext -> GetNativeContext ( ) ) ; <NEW_LINE>
v8CallBoolean ( instance -> CreateDataProperty ( info . GetIsolate ( ) -> GetCurrentContext ( ) , property , value ) ) ; <NEW_LINE>
nsWindow * GetContainerWindow ( ) ; <NEW_LINE>
mDecodingMonitor . AssertCurrentThreadIn ( ) ; <NEW_LINE>
return String::hash_str ( state , ( unsigned char * ) a -> dp , a -> used * sizeof ( mp_digit ) ) ; <NEW_LINE>
NS_IF_ADDREF ( * aTransaction = mTransaction ) ; <NEW_LINE>
return equalIgnoringASCIICase ( getAttribute ( aria_multilineAttr ) , "true" ) ; <NEW_LINE>
snprintf ( & str [ i_level * 5 ] , sizeof ( str ) - 5 * i_level , <NEW_LINE>
if ( ! EnsureStringLength ( aDest , aSource . Length ( ) ) ) <NEW_LINE>return ; <NEW_LINE>
<NEW_LINE><NEW_LINE>
if ( ! mThisObjects . put ( aScript , aThisObject ) ) { <NEW_LINE>MOZ_CRASH ( ) ; <NEW_LINE> } <NEW_LINE>
__android_log_print ( ANDROID_LOG_INFO , "Gecko" , " % s" , NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) ) ; <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
PRPackedBool mIsPending ; <NEW_LINE>PRPackedBool mIsUnsafe ; <NEW_LINE>
nsContentUtils::AddScriptRunner ( <NEW_LINE>NS_NewRunnableMethod ( this , & nsXULTemplateBuilder::RunnableLoadAndRebuild ) ) ; <NEW_LINE>
if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) ) { <NEW_LINE>struct stat dsb ; <NEW_LINE><NEW_LINE>if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { <NEW_LINE>uid_t fuid ; <NEW_LINE><NEW_LINE>if ( sb . st_uid == 0 || <NEW_LINE> ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && <NEW_LINE>sb . st_uid == fuid ) ) { <NEW_LINE>sb = dsb ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
nsCOMPtr < nsIDOMXULElement > xulElement ( do_QueryInterface ( child ) ) ; <NEW_LINE>xulElement -> GetResource ( getter_AddRefs ( resource ) ) ; <NEW_LINE>
if ( num_unknowns != 0 ) <NEW_LINE>
memcpy ( & cm -> lfc , & cm -> fc , sizeof ( cm -> fc ) ) ; <NEW_LINE>
JS_CHECK_RECURSION ( cx , return Jaeger_ThrowBeforeEnter ) ; <NEW_LINE>
new_fname = safe_calloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <NEW_LINE>
static int <NEW_LINE>
uint32_t qttag , qtsize32 ; <NEW_LINE>size_t len ; <NEW_LINE>
* buff = __archive_read_ahead ( a , minimum , & bytes_avail ) ; <NEW_LINE>
<NEW_LINE>nsCOMPtr < nsICanvasElement > mCanvasElement ; <NEW_LINE>
<NEW_LINE>
} <NEW_LINE>
PNG_DFN " ; Version 1 . 6 . 20" <NEW_LINE>
<NEW_LINE>mParentPtrBits = aNullParent ? 0 : mParentPtrBits & ~ PARENT_BIT_INDOCUMENT ; <NEW_LINE><NEW_LINE>
if ( ! typeName ) abort ( ) ; <NEW_LINE>
nsCOMPtr < nsIContent > element = ungenerated [ last ] ; <NEW_LINE>
ASSERT ( ! oldStyle || diff . needsRepaint ( ) || diff . needsLayout ( ) ) ; <NEW_LINE>
error = prctl_update_vma_anon_name ( vma , & prev , start , tmp , <NEW_LINE>
if ( lineBox == firstRootBox ( ) && totalLogicalHeight < pageLogicalHeightAtNewOffset && ! isOutOfFlowPositioned ( ) && ! isTableCell ( ) ) <NEW_LINE>
version = ssplit ( sclone ( version ) , " - " , & preVersion ) ; <NEW_LINE>base = ssplit ( sclone ( expr ) , " - " , & pre ) ; <NEW_LINE>
PRUint32 approxLen = 3 ; <NEW_LINE>
name = mprReadJson ( prop , "operation" ) ; <NEW_LINE>args = mprReadJson ( prop , "args" ) ; <NEW_LINE>
NS_ENSURE_TRUE_VOID ( pusher . Push ( cx , nsCxPusher::ALWAYS_PUSH ) ) ; <NEW_LINE>
static inline zend_ulong realpath_cache_key ( const char * path , size_t path_len ) <NEW_LINE>
virtual void appendText ( StringBuilder & out , Text * ) ; <NEW_LINE>virtual void appendElement ( StringBuilder & out , Element * , Namespaces * ) ; <NEW_LINE>virtual void appendCustomAttributes ( StringBuilder & out , Element * , Namespaces * ) ; <NEW_LINE>virtual void appendEndTag ( Node * ) ; <NEW_LINE>private: <NEW_LINE>
memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>
TEMP_FAILURE_RETRY ( send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ; <NEW_LINE>
pusher . PushNull ( ) ; <NEW_LINE>
<NEW_LINE>
if ( STATE_FIRST_CALL == mState && * aSrcLength < 2 ) <NEW_LINE> { <NEW_LINE> * aSrcLength = 0 ; <NEW_LINE> * aDestLength = 0 ; <NEW_LINE>return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> } <NEW_LINE>
singletonPos = getSingletonPos ( loc_name ) ; <NEW_LINE>
ALOGE ( "memset buffer too small: got % lu , expected % zu" , ( unsigned long ) outHeader -> nAllocLen , len ) ; <NEW_LINE>
NS_ASSERTION ( NS_FRAME_IS_FULLY_COMPLETE ( aStatus ) || <NEW_LINE>
jas_uchar jas_iccprofdata_srgb [ ] = <NEW_LINE>
PL_ArenaFinish ( ) ; <NEW_LINE>
#include " . / vpx_dsp_rtcd . h" <NEW_LINE>#include "vp8 / encoder / quantize . h" <NEW_LINE>
#define LIBRAW_PATCH_VERSION 1 <NEW_LINE>
@stability Evolving <NEW_LINE>
cx = JSContextForPluginInstance ( reinterpret_cast < nsIPluginInstance * > ( mJavaClient ) ) ; <NEW_LINE>if ( ! cx ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>AutoPushJSContext autopush ( nsnull , cx ) ; <NEW_LINE>if ( NS_FAILED ( autopush . ResultOfPush ( ) ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>
return std::make_unique < T > ( std::forward < Args > ( args ) . . . ) ; <NEW_LINE>
<NEW_LINE>
memset ( dest_ptr1 , src_ptr1 [ 0 ] , el ) ; <NEW_LINE>memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; <NEW_LINE>memset ( dest_ptr2 , src_ptr2 [ 0 ] , er ) ; <NEW_LINE>
comment = GetImageProperty ( image , "comment" ) ; <NEW_LINE>if ( comment != ( const char * ) NULL ) <NEW_LINE>tga_info . id_length = ( unsigned char ) MagickMin ( strlen ( comment ) , 255 ) ; <NEW_LINE>
uint32 )
#include "platform / win / HWndDC . h" <NEW_LINE>
struct dbus_info * info = handler ? handler -> opaque : NULL ; <NEW_LINE>
<NEW_LINE>
return equalIgnoringASCIICase ( liveRegion , "polite" ) || <NEW_LINE>equalIgnoringASCIICase ( liveRegion , "assertive" ) ; <NEW_LINE>
int iSC ; <NEW_LINE>if ( len < 1 + iACLen ) <NEW_LINE>break ; <NEW_LINE>iSC = buf [ iOffset + iACLen ] ; <NEW_LINE>
if ( png_crc_finish ( png_ptr , 0 ) != 0 ) <NEW_LINE>
php_array_replace_recursive ( seen , couldRecur ( v , subarr1 . get ( ) ) , <NEW_LINE>
if ( cdigits + czero + 1 < precision + clead ) <NEW_LINE>
if ( o -> style ( ) -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
ND_PRINT ( ( ndo , " % s" , tstr ) ) ; <NEW_LINE>
#line 785 "ext / standard / var_unserializer . c" <NEW_LINE>
<NEW_LINE>
nsCOMPtr < nsIDOMNode > node = do_QueryInterface ( mContent ) ; <NEW_LINE>nsContentUtils::AddScriptRunner ( new nsPLDOMEvent ( node , <NEW_LINE>NS_LITERAL_STRING ( "ValueChange" ) ) ) ; <NEW_LINE>
extern const char kInvalidWebviewPartition [ ] ; <NEW_LINE>extern const char kInvalidWebviewPartitionName [ ] ; <NEW_LINE>extern const char kInvalidWebviewPartitionsList [ ] ; <NEW_LINE>
bool SoftAVC::setDecodeArgs ( <NEW_LINE>
<NEW_LINE><NEW_LINE>nsSize availSize ( aReflowState . ComputedWidth ( ) , NS_UNCONSTRAINEDSIZE ) ; <NEW_LINE>
if ( aNeedsCxPush ) { <NEW_LINE>pusher . Push ( cx ) ; <NEW_LINE>
ATOM_DTD_FORMAT aModeTimings [ MAX_SUPPORTED_TV_TIMING_V1_2 ] ; <NEW_LINE>
Copyright ( c ) 1997 - 2008 University of Cambridge <NEW_LINE>
if ( shift == 0 ) <NEW_LINE>
f_rng_blind , <NEW_LINE>p_rng_blind , <NEW_LINE>ECDSA_RS_ECP ) ) ; <NEW_LINE>
strncpy ( szFileName , pszFileName , sizeof ( szFileName ) - 5 ) ; <NEW_LINE>
nsHttpResponseHead ( ) : mVersion ( NS_HTTP_VERSION_1_1 ) <NEW_LINE>
if ( ( output_format & PNG_FORMAT_FLAG_ALPHA ) != 0 ) <NEW_LINE>
data = ssplit ( command , " | " , & command ) ; <NEW_LINE>
( void ) FormatLocaleString ( key , MagickPathExtent , " % s - geometry" , <NEW_LINE>name ) ; <NEW_LINE>
<NEW_LINE>
if ( isOutOfFlowPositioned ( ) ) { <NEW_LINE>
static bool <NEW_LINE>HasUnreachableGCThingsImpl ( JSContext * cx , TreeFragment * f ) <NEW_LINE> { <NEW_LINE>if ( f -> visiting ) <NEW_LINE>return false ; <NEW_LINE>f -> visiting = true ; <NEW_LINE><NEW_LINE>if ( ! f -> code ( ) ) <NEW_LINE>return false ; <NEW_LINE><NEW_LINE>
. mmap = ecryptfs_mmap , <NEW_LINE>
if ( dstOffset > SIZE_MAX - 4 || <NEW_LINE>dstOffset + 4 > SIZE_MAX - nalLength || <NEW_LINE>dstOffset + 4 + nalLength > mBuffer -> size ( ) ) { <NEW_LINE>ALOGE ( "b / 26365349 : % zu % zu" , dstOffset , mBuffer -> size ( ) ) ; <NEW_LINE>android_errorWriteLog ( 0x534e4554 , "26365349" ) ; <NEW_LINE>mBuffer -> release ( ) ; <NEW_LINE>mBuffer = NULL ; <NEW_LINE>return ERROR_MALFORMED ; <NEW_LINE> } <NEW_LINE>
if ( png_rtran_ok ( png_ptr , 0 ) == 0 ) <NEW_LINE>
explicit SendTabToSelfInfoBarDelegate ( content::WebContents * web_contents , <NEW_LINE>const SendTabToSelfEntry * entry ) ; <NEW_LINE><NEW_LINE>content::WebContents * web_contents_ = nullptr ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
#if defined ( WINCE ) || ( MOZ_WINSDK_TARGETVER == MOZ_NTDDI_WS03 ) <NEW_LINE>
provider = ssplit ( sclone ( spec ) , ": <NEW_LINE>if ( * provider == '\0' || * path == '\0' ) { <NEW_LINE>
virtual void cryptographicallyRandomValues ( unsigned char * buffer , size_t length ) <NEW_LINE> { <NEW_LINE>RELEASE_ASSERT_NOT_REACHED ( ) ; <NEW_LINE> } <NEW_LINE>
nsresult rv = nsContentUtils::ASCIIToLower ( aNode . GetKeyAt ( i ) , key ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) { <NEW_LINE>return rv ; <NEW_LINE> } <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
LongSeek ( mp4 , qtsize - 8 ) ; <NEW_LINE>
#ifndef BASE_ANDROID_LIBRARY_LOADER_LIBRARY_LOAD_FROM_APK_STATUS_CODES_H_ <NEW_LINE>#define BASE_ANDROID_LIBRARY_LOADER_LIBRARY_LOAD_FROM_APK_STATUS_CODES_H_ <NEW_LINE>
if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) <NEW_LINE>
for ( unsigned j = 0 ; j < srcEndCopyPosition - srcStartCopyPosition ; <NEW_LINE>
while ( * tail ) tail = & ( * tail ) -> next ; <NEW_LINE>
: mLock ( "transaction lock" ) <NEW_LINE>
<NEW_LINE>
conn -> sasl_username = g_strdup ( ircnet -> sasl_username ) ; <NEW_LINE>conn -> sasl_password = g_strdup ( ircnet -> sasl_password ) ; <NEW_LINE>
return mount_entry_on_generic ( mntent , path , rootfs ) ; <NEW_LINE>
draw_info -> undercolor . alpha = ( MagickRealType ) TransparentAlpha ; <NEW_LINE>
switch ( target ) { <NEW_LINE>case GL_PIXEL_UNPACK_BUFFER: <NEW_LINE>state_ . pixel_unpack_buffer_binding = buffer ; <NEW_LINE>break ; <NEW_LINE>case GL_PIXEL_PACK_BUFFER: <NEW_LINE>state_ . pixel_pack_buffer_binding = buffer ; <NEW_LINE>break ; <NEW_LINE>default: <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>
dst = SafeArrayAlloc < char > ( 1 , len + 1 ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>WORD16 ai2_level_arr [ 19 ] ; <NEW_LINE>WORD16 * i2_level_arr = & ai2_level_arr [ 3 ] ; <NEW_LINE>
RootedObject na ( cx , a ) , aProto ( cx , a -> getProto ( ) ) , nb ( cx , b ) , bProto ( cx , b -> getProto ( ) ) ; <NEW_LINE><NEW_LINE><NEW_LINE>return SetProto ( cx , na , bProto , true ) && SetProto ( cx , nb , aProto , true ) ; <NEW_LINE>
<NEW_LINE>
if ( cb_ret < 0 ) <NEW_LINE>
<NEW_LINE>if ( parentIndex >= 0 ) { <NEW_LINE>PRInt32 index = 0 ; <NEW_LINE>GetIndexInSubtree ( aContainer , aChild , & index ) ; <NEW_LINE>PRInt32 count = InsertRow ( parentIndex , index , aChild ) ; <NEW_LINE>if ( mBoxObject ) <NEW_LINE>mBoxObject -> RowCountChanged ( parentIndex + index + 1 , count ) ; <NEW_LINE> } <NEW_LINE>
# if PNG_RELEASE_BUILD <NEW_LINE>
name = ssplit ( sclone ( name ) , "#" , ( char ** ) & version ) ; <NEW_LINE>if ( * version == '\0' ) { <NEW_LINE>
buf2 = estrndup ( value , value_len ) ; <NEW_LINE>
route -> mode = mprReadJson ( route -> config , "app . mode" ) ; <NEW_LINE>
if ( new_str ) { <NEW_LINE>Z_STRVAL_P ( ent1 -> data ) = new_str ; <NEW_LINE>Z_STRLEN_P ( ent1 -> data ) = new_len ; <NEW_LINE> } else { <NEW_LINE>ZVAL_EMPTY_STRING ( ent1 -> data ) ; <NEW_LINE> } <NEW_LINE>
enum StyleDifferenceLegacy { <NEW_LINE>
if ( ( tcptls_session -> f = fdopen ( tcptls_session -> fd , "w + " ) ) ) { <NEW_LINE>if ( setvbuf ( tcptls_session -> f , NULL , _IONBF , 0 ) ) { <NEW_LINE>fclose ( tcptls_session -> f ) ; <NEW_LINE>tcptls_session -> f = NULL ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
int i , j , nbNs , attval ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>struct XPCWrappedNativeJSClass <NEW_LINE>
TEMP_FAILURE_RETRY ( usleep ( us_delay ) ) ; <NEW_LINE>
ps_dec -> u2_total_mbs_coded += u1_num_mbs ; <NEW_LINE>
txXPathNodeUtils::getXSLTId ( nodes -> get ( 0 ) , es -> getSourceDocument ( ) , <NEW_LINE>strRes -> mValue ) ; <NEW_LINE>
OwnPtr < InspectorResourceAgent > resourceAgentPtr ( InspectorResourceAgent::create ( m_instrumentingAgents . get ( ) , pageAgent , inspectorClient , m_state . get ( ) ) ) ; <NEW_LINE>
if ( shouldReleaseXPC && mXPC ) <NEW_LINE>NS_RELEASE ( mXPC ) ; <NEW_LINE>
if ( ! merge && entry && replace ) <NEW_LINE>
<NEW_LINE>bool argPacked = ! argTypes -> hasObjectFlags ( cx , types::OBJECT_FLAG_NON_PACKED ) ; <NEW_LINE>bool thisPacked = ! thisTypes -> hasObjectFlags ( cx , types::OBJECT_FLAG_NON_PACKED ) ; <NEW_LINE>if ( ! ( thisPacked && ! argPacked ) ) <NEW_LINE>return compileArrayConcat ( thisTypes , argTypes , thisValue , arg ) ; <NEW_LINE>
if ( full_quantize != 0 ) <NEW_LINE>
if ( current . m_obj -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
if ( ! drainOneOutputBuffer ( picId , data ) ) { <NEW_LINE>ALOGE ( "Drain failed" ) ; <NEW_LINE>notify ( OMX_EventError , OMX_ErrorUndefined , 0 , NULL ) ; <NEW_LINE>mSignalledError = true ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
void SetRenderer ( int process_host_id , <NEW_LINE>
if ( sa && portno > 0 ) { <NEW_LINE>
if ( uep -> ue_size < LONG_MAX / ( int ) sizeof ( char_u * ) ) <NEW_LINE>array = ( char_u ** ) U_ALLOC_LINE ( sizeof ( char_u * ) * uep -> ue_size ) ; <NEW_LINE>
if ( png_muldiv ( & res , 100000 , 100000 , a ) != 0 ) <NEW_LINE>
@stability Evolving <NEW_LINE>
pa , temp * scanline ) == ( tmsize_t ) ( - 1 ) <NEW_LINE>
if ( ( state & PNG_FP_SAW_ANY ) != 0 ) <NEW_LINE>
* _retval = xpc_UnmarkGrayContext ( data -> GetJSContextStack ( ) -> Peek ( ) ) ; <NEW_LINE>
size_t pos , const char * msg ) <NEW_LINE>
rv = nsContentUtils::GetSecurityManager ( ) -> <NEW_LINE>GetChannelPrincipal ( channel , getter_AddRefs ( aRequest -> mOriginPrincipal ) ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE><NEW_LINE>
#line 496 "ext / standard / var_unserializer . c" <NEW_LINE>
nsIFrame * parent = aFrame -> GetParent ( ) ; <NEW_LINE>nsBlockFrame * parentBlock = nsLayoutUtils::GetAsBlock ( parent ) ; <NEW_LINE>if ( ! parentBlock ) { <NEW_LINE>aFrame -> ClearTextRuns ( ) ; <NEW_LINE>if ( aFrame != lastRemoved ) { <NEW_LINE>static_cast < nsTextFrame * > ( lastRemoved ) -> ClearTextRuns ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
for ( x = 0 ; x < ( ssize_t ) Cr_image -> columns ; x ++ ) <NEW_LINE>
xmlGenericError ( xmlGenericErrorContext , <NEW_LINE>"xmlXPathCompareNodeSetValue: Can't compare node set " <NEW_LINE>"and object of type % d\n" , <NEW_LINE>val -> type ) ; <NEW_LINE>xmlXPathReleaseObject ( ctxt -> context , arg ) ; <NEW_LINE>xmlXPathReleaseObject ( ctxt -> context , val ) ; <NEW_LINE>XP_ERROR0 ( XPATH_INVALID_TYPE ) ; <NEW_LINE>
v = ObjectValue ( * obj ) ; <NEW_LINE>setSlot ( FUNCTION_NS , v ) ; <NEW_LINE>
void SetRenderer ( int render_process_id , <NEW_LINE>
xmlSchemaSetValidErrors ( ctxt , testErrorHandler , testErrorHandler , ctxt ) ; <NEW_LINE>
if ( ! setDecodeArgs ( & s_dec_ip , & s_dec_op , inHeader , outHeader , timeStampIx ) ) { <NEW_LINE>ALOGE ( "Decoder arg setup failed" ) ; <NEW_LINE>notify ( OMX_EventError , OMX_ErrorUndefined , 0 , NULL ) ; <NEW_LINE>mSignalledError = true ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
if ( h -> data [ i ] < 0 ) { <NEW_LINE>for ( int j = 0 ; j < i ; j ++ ) { <NEW_LINE>close ( h -> data [ j ] ) ; <NEW_LINE> } <NEW_LINE>native_handle_delete ( h ) ; <NEW_LINE>return 0 ; <NEW_LINE> } <NEW_LINE>
if ( ( png_ptr -> flags & PNG_FLAG_CRC_CRITICAL_IGNORE ) != 0 ) <NEW_LINE>
strncpy ( uaddr -> sa_data , dev -> name , 14 ) ; <NEW_LINE>
if ( png_crc_finish ( png_ptr , skip ) != 0 ) <NEW_LINE>
explicit ShellMainDelegate ( bool is_browsertest = false ) ; <NEW_LINE>
strncpy ( rcomp . type , "compression" , sizeof ( rcomp . type ) ) ; <NEW_LINE>
in_what -> stride ) ; <NEW_LINE>
NS_ASSERTION ( aForFrame || ( aForFrameLine && aLineContainer ) , <NEW_LINE>"One of aForFrame or aForFrameLine + aLineContainer must be set ! " ) ; <NEW_LINE><NEW_LINE>if ( ! aLineContainer || ! aForFrameLine ) { <NEW_LINE>
char buf [ L_BUFSIZE ] ; <NEW_LINE>
if ( ! setDecodeArgs ( & s_dec_ip , & s_dec_op , inHeader , outHeader , timeStampIx ) ) { <NEW_LINE>ALOGE ( "Decoder arg setup failed" ) ; <NEW_LINE>notify ( OMX_EventError , OMX_ErrorUndefined , 0 , NULL ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
elementStyle = nsComputedDOMStyle::GetStyleContextForElementNoFlush ( content -> AsElement ( ) , <NEW_LINE>nullptr , <NEW_LINE>ps ) ; <NEW_LINE>
if ( full_quantize == 0 ) <NEW_LINE>
PRBool aNotify , <NEW_LINE>const nsAString * aValueForAfterSetAttr ) ; <NEW_LINE>
FireChromeDOMEvent ( mPresContext , domEventToFire ) ; <NEW_LINE>
RefPtr < DocumentFragment > fragment = createContextualFragment ( markup , toHTMLElement ( m_element ) , AllowScriptingContent ) ; <NEW_LINE>
AutoReset < bool > in_stop_all_loaders ( & in_stop_all_loaders_ , true ) ; <NEW_LINE>
initialDataTransfer = new nsDOMDataTransfer ( aDragEvent -> message , true , - 1 ) ; <NEW_LINE>
#endif
m_inactivityInSeconds = 0 ; <NEW_LINE>
#endif <NEW_LINE>
ENGINE_SET_INVALID_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <NEW_LINE>
prev_slice_incomplete_flag = 1 ; <NEW_LINE>
char buf [ L_BUFSIZE ] ; <NEW_LINE>
status = AcquireImageColormap ( image , 2 ) ; <NEW_LINE>
else if ( mono_class_is_subclass_of ( dest_class , src_class , FALSE ) ) { <NEW_LINE><NEW_LINE>return FALSE ; <NEW_LINE><NEW_LINE> } else <NEW_LINE>
& cfg_ , flags_ ) ; <NEW_LINE>
static_cast < unsigned > ( resizeWidth ) * resizedInfo . bytesPerPixel ( ) ) ; <NEW_LINE>
op = JSOP_NOP ; <NEW_LINE>
doRemoveChild ( aNotify ) ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
<NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <NEW_LINE>if ( ! tmp2 ) <NEW_LINE>free ( tmp ) ; <NEW_LINE>tmp = tmp2 ; <NEW_LINE>
NS_DECL_CYCLE_COLLECTING_ISUPPORTS <NEW_LINE><NEW_LINE>NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS ( WebGLContext , nsICanvasRenderingContextWebGL ) <NEW_LINE><NEW_LINE>
if ( ( levels = mprReadJsonObj ( prop , "levels" ) ) != 0 ) { <NEW_LINE>
if ( ( output_format & PNG_FORMAT_FLAG_COLOR ) != 0 ) <NEW_LINE>
#include "platform / win / SystemInfo . h" <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
void neuter ( void * newData ) ; <NEW_LINE>
} while ( ScanAsSpace ( c ) ) ; <NEW_LINE>
js_Atomize ( JSContext * cx , const char * bytes , size_t length , uintN flags ) <NEW_LINE>
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; <NEW_LINE>size_t bufferLeft = MAXPATHLEN * 2 ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>
NS_ConvertUTF16toUTF8 ( source ) . get ( ) , 1 , <NEW_LINE>returnStringOnly , rval ) ; <NEW_LINE>
nsWeakPtr mContent ; <NEW_LINE>
Clear ( ) ; <NEW_LINE>
result . translate3d ( blendDoubles ( fromX , toX , progress ) , <NEW_LINE>blendDoubles ( fromY , toY , progress ) , <NEW_LINE>blendDoubles ( fromZ , toZ , progress ) ) ; <NEW_LINE>
if ( ! config -> num_channels || ! config -> sample_rate ) { <NEW_LINE>
if ( js_doregexec ( J , re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <NEW_LINE>
if ( offsetParent -> isBox ( ) && offsetParent -> isBody ( ) && ! offsetParent -> isRelPositioned ( ) && ! offsetParent -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
struct VP8_COMP ; <NEW_LINE><NEW_LINE>void vp8_init_mode_costs ( struct VP8_COMP * x ) ; <NEW_LINE>
if ( ! targetElement || ! isSVGAnimateElement ( * resultElement ) ) <NEW_LINE>
if ( TEMP_FAILURE_RETRY ( poll ( & pfd , 1 , 0 ) ) == 0 ) <NEW_LINE>
AutoPushJSContext cx ( aScx -> GetNativeContext ( ) ) ; <NEW_LINE>JS::CompileOptions options ( cx ) ; <NEW_LINE>
quantum = MagickMin ( quantum / number_coordinates , BezierQuantum ) ; <NEW_LINE>
<NEW_LINE>
void * pixels = sk_malloc_canfail ( size ) ; <NEW_LINE>
RootedObject scope ( cx , JS_GetGlobalForScopeChain ( cx ) ) ; <NEW_LINE>
struct CONTENT_EXPORT Options ; <NEW_LINE>
if ( ! vct_iscrlf ( r ) ) { <NEW_LINE>
png_size_t copy = output_size - count ; <NEW_LINE>if ( ( png_size_t ) avail < copy ) copy = ( png_size_t ) avail ; <NEW_LINE>
if ( ( len + * stringlen ) >= * stralloc ) { <NEW_LINE>
if ( png_set_text_2 ( png_ptr , info_ptr , & text , 1 ) != 0 ) <NEW_LINE>
nsLayoutUtils::IGNORE_PAINT_SUPPRESSION | nsLayoutUtils::IGNORE_CROSS_DOC | <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
vpx_write ( w , hp , <NEW_LINE>
mpz_powm_sec ( z , a , m , n ) ; <NEW_LINE>
#include "core / html / forms / KeyboardClickableInputTypeView . h" <NEW_LINE>
if ( sc_select_file ( card , & prkey_info . path , NULL ) != SC_SUCCESS || ! f -> prop_attr ) { <NEW_LINE>
if ( png_muldiv ( & xy -> whitex , whiteX , PNG_FP_1 , dwhite ) == 0 ) <NEW_LINE>return 1 ; <NEW_LINE>if ( png_muldiv ( & xy -> whitey , whiteY , PNG_FP_1 , dwhite ) == 0 ) <NEW_LINE>return 1 ; <NEW_LINE>
if ( 3 == sscanf ( l_line , " % u % u % u" , o_row_count , o_column_count , o_element_count ) && <NEW_LINE>0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <NEW_LINE> { <NEW_LINE>
const InputMethodDescriptor * GetInputMethodDescriptorFromId ( <NEW_LINE>
image_transform_set_end ( const image_transform * this , <NEW_LINE>
void doFatFingers ( const Platform::TouchPoint & ) ; <NEW_LINE>void handleTouchPoint ( const Platform::TouchPoint & , unsigned modifiers ) ; <NEW_LINE>
. SetShouldShowHandle ( true ) <NEW_LINE>
const MB_MODE_INFO * const above_mbmi = xd -> above_mbmi ; <NEW_LINE>const MB_MODE_INFO * const left_mbmi = xd -> left_mbmi ; <NEW_LINE>const int has_above = xd -> up_available ; <NEW_LINE>const int has_left = xd -> left_available ;
<NEW_LINE>
for ( k = passIC + 2 ; <NEW_LINE> ( ( k < passIC + 2 + passInstructions [ passIC + 1 ] ) && ( kk < input -> length ) ) ; <NEW_LINE>k ++ ) <NEW_LINE>
sourceMap ( ) , listenerTSData ( ) , tokenbuf ( cx ) , <NEW_LINE>
<NEW_LINE>create_struct . jmp_buf_ptr = NULL ; <NEW_LINE>create_struct . jmp_buf_size = 0 ; <NEW_LINE>create_struct . longjmp_fn = 0 ; <NEW_LINE>
vpx_active_map_t map = { 0 , 0 , 0 } ; <NEW_LINE>
: mCGContext ( NULL ) , mSize ( size ) , mForPrinting ( aForPrinting ) <NEW_LINE>
ValidateLoopIndexExpr validate ( mLoopStack ) ; <NEW_LINE>node -> getRight ( ) -> traverse ( & validate ) ; <NEW_LINE>
if ( newPtr != nullptr && newPtr == oldPtr ) { <NEW_LINE>NS_RUNTIMEABORT ( "Logic flaw in the caller" ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
#include < media / stagefright / foundation / ADebug . h > <NEW_LINE>
const vpx_codec_dec_cfg_t * cfg , <NEW_LINE>
option = ssplit ( option , " = \t , " , & ovalue ) ; <NEW_LINE>
} else if ( totalSize > sharedBuffer -> size ( ) ) { <NEW_LINE>result = - EINVAL ; <NEW_LINE> } else if ( ( size_t ) offset > sharedBuffer -> size ( ) - totalSize ) { <NEW_LINE>
if ( ( png_ptr -> mode & PNG_IS_READ_STRUCT ) != 0 ) <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( obj -> type ( ) == MIRType_Object && ! invalidatedIdempotentCache ( ) && <NEW_LINE>info ( ) . executionMode ( ) != ParallelExecution ) <NEW_LINE> { <NEW_LINE>
memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <NEW_LINE>
<NEW_LINE>
if ( ! EnsureStringLength ( aResult , aTextLength ) ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE><NEW_LINE>
if ( curr -> renderer ( ) -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
#define PNG_LIBPNG_VER 10254 <NEW_LINE>
switch ( point . state ( ) ) { <NEW_LINE>
lir -> insStorei ( vp_ins , lirbuf -> state , offsetof ( InterpState , nativeVp ) ) ; <NEW_LINE>lir -> insStorei ( INS_CONST ( 1 ) , lirbuf -> state , offsetof ( InterpState , nativeVpLen ) ) ; <NEW_LINE>
PRPackedBool mInDtor ; <NEW_LINE>
#define vp8_sixtap_predict4x4 vp8_sixtap_predict4x4_armv6 <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
if ( syscall_nr < 0 || syscall_nr >= NR_syscalls ) <NEW_LINE>
print_unknown_data ( ndo , p , "\n\t" , length ) ; <NEW_LINE>
parse_rock_ridge_inode ( de , inode , relocated ) ; <NEW_LINE>
& scal_height ) != 0 ) <NEW_LINE>
obj = NULL ; <NEW_LINE>
delete [ ] codec_private_ ; <NEW_LINE>
const static PRUint32 kMaxStrLen = 1 << 6 ; <NEW_LINE>
XPCAutoRequest ar ( cx ) ; <NEW_LINE>
ChildIterator iter , last ; <NEW_LINE>for ( ChildIterator::Init ( mContent , & iter , & last ) ; <NEW_LINE>iter != last ; <NEW_LINE> ++ iter ) { <NEW_LINE>nsIContent * child = ( * iter ) ; <NEW_LINE>
rv = xpc_EvalInSandbox ( cx , sandbox , source , filename . get ( ) , lineNo , <NEW_LINE>PR_FALSE , rval ) ; <NEW_LINE>
return cp == ( char * ) vec -> iov_base + vec -> iov_len ; <NEW_LINE>
if ( ! RemapAllWrappersForObject ( cx , origobj , newIdentity ) ) <NEW_LINE>
<NEW_LINE>
WebGLenum mWebGLError ; <NEW_LINE>
static input_method::InputMethodDescriptors * CreateInputMethodDescriptors ( ) ; <NEW_LINE>
const int * [ FLACParser::kMaxChannels ] , <NEW_LINE>
Selection ( ) . SetSelection ( <NEW_LINE>SelectionInDOMTree::Builder ( ) . Collapse ( end_of_text ) . Build ( ) , <NEW_LINE>SetSelectionData::Builder ( ) <NEW_LINE> . SetShouldCloseTyping ( true ) <NEW_LINE> . SetShouldClearTypingStyle ( true ) <NEW_LINE> . SetShouldShowHandle ( true ) <NEW_LINE> . Build ( ) ) ; <NEW_LINE>
while ( curr && ( curr -> isInline ( ) || curr -> isFloatingOrOutOfFlowPositioned ( ) ) && ( curr != boundary ) ) { <NEW_LINE>
nsIPrincipal * docPrincipal = document -> NodePrincipal ( ) ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( inheritedFromCurrent && <NEW_LINE>mItemType == typeContent && <NEW_LINE>nsContentUtils::IsSystemPrincipal ( docPrincipal ) ) { <NEW_LINE>return nsnull ; <NEW_LINE> } <NEW_LINE><NEW_LINE>return docPrincipal ; <NEW_LINE>
thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ; <NEW_LINE>
#endif <NEW_LINE>
nsOverflowContinuationTracker::AutoFinish fini ( aState . mOverflowTracker , frame ) ; <NEW_LINE>
if ( task_stack_end_corrupted ( prev ) ) <NEW_LINE>panic ( "corrupted stack end detected inside scheduler\n" ) ; <NEW_LINE>
FileSystemSyncCallbackHelper * helper = FileSystemSyncCallbackHelper::create ( ) ; <NEW_LINE>
if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) <NEW_LINE>
<NEW_LINE>
XPCWrappedNativeScope * xpcscope = GetObjectScope ( JS_GetGlobalForScopeChain ( cx ) ) ; <NEW_LINE>
if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , & next ) ) { <NEW_LINE>if ( ! fpath || strcmp ( next , fpath ) == 0 ) <NEW_LINE>ret = - EBUSY ; <NEW_LINE>else <NEW_LINE>ret = - ENOENT ; <NEW_LINE>goto out ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
if ( HeapOverflowSanityCheck ( count , quantum ) != MagickFalse ) <NEW_LINE>
return cx -> compartment -> wrap ( cx , rval ) ; <NEW_LINE>
alarm_set ( alarm_timer , CONFIG_SETTLE_PERIOD_MS , timer_config_save_cb , NULL ) ; <NEW_LINE>
new DestroyWidgetRunnable ( widget ) ; <NEW_LINE><NEW_LINE>view -> DestroyWidget ( ) ; <NEW_LINE>
if ( ! WriteEbmlElement ( writer , kMkvDocTypeVersion , doc_type_version ) ) <NEW_LINE>
printf ( " Value: % i\n" , * ( ( int * ) mapidata -> data ) ) ; <NEW_LINE>
CERTCertList * certList = nsnull ; <NEW_LINE>if ( rv == SECSuccess ) { <NEW_LINE>certList = CERT_GetCertChainFromCert ( serverCert , PR_Now ( ) , certUsageSSLCA ) ; <NEW_LINE>if ( ! certList ) { <NEW_LINE>rv = SECFailure ; <NEW_LINE> } else { <NEW_LINE>PRErrorCode blacklistErrorCode = PSM_SSL_BlacklistDigiNotar ( serverCert , <NEW_LINE>certList ) ; <NEW_LINE>if ( blacklistErrorCode != 0 ) { <NEW_LINE>infoObject -> SetCertIssuerBlacklisted ( ) ; <NEW_LINE>PORT_SetError ( blacklistErrorCode ) ; <NEW_LINE>rv = SECFailure ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE><NEW_LINE>
#ifndef CONTENT_RENDERER_DEVTOOLS_CLIENT_H_ <NEW_LINE>#define CONTENT_RENDERER_DEVTOOLS_CLIENT_H_ <NEW_LINE>
ret = PNG_INFLATE ( png_ptr , Z_SYNC_FLUSH ) ; <NEW_LINE>
static const float vwin8192 [ 4096 ] = { <NEW_LINE>
memset ( input , 0 , 32 ) ; <NEW_LINE>
void cryptographicallyRandomValues ( unsigned char * buffer , size_t length ) override <NEW_LINE> { <NEW_LINE>RELEASE_ASSERT_NOT_REACHED ( ) ; <NEW_LINE> } <NEW_LINE>
if ( curr -> renderer ( ) -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
if ( ! cxPusher . Push ( cx , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ) { <NEW_LINE>
int bit = ( lok >> i ) & 1 ; <NEW_LINE>int next = t [ chase + bit ] ; <NEW_LINE>if ( next & 0x80 ) { <NEW_LINE>chase = ( next << 8 ) | t [ chase + bit + 1 + ( ! bit || t [ chase ] & 0x80 ) ] ; <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>chase = next ; <NEW_LINE>
xmlGenericError , xmlGenericError , NULL ) ; <NEW_LINE>
typedef struct { <NEW_LINE>lua_authz_provider_spec * spec ; <NEW_LINE>apr_array_header_t * args ; <NEW_LINE> } lua_authz_provider_func ; <NEW_LINE><NEW_LINE>
SafeAutoJSContext cx ; <NEW_LINE>
virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result , <NEW_LINE>nsIChannel ** channel ) ; <NEW_LINE>
JS_SetWrapObjectCallbacks ( JS_GetRuntime ( cx ) , Wrap , SameCompartmentWrap , PreWrap ) ; <NEW_LINE>
sp < MemorySource > source = new ( std::nothrow ) MemorySource ( data , size ) ; <NEW_LINE><NEW_LINE>if ( source == NULL ) <NEW_LINE>return ; <NEW_LINE>
WEBKIT_EXPORT bool blend ( const WebTransformationMatrix & from , double progress ) ; <NEW_LINE>
static inline void realpath_cache_add ( const char * path , int path_len , const char * realpath , size_t realpath_len , int is_dir , time_t t ) <NEW_LINE>
jitter = j_jitter -> valuedouble ; <NEW_LINE>
RenderSVGRoot * renderer = toRenderSVGRoot ( rootElement -> renderer ( ) ) ; <NEW_LINE>if ( ! renderer ) <NEW_LINE>return ; <NEW_LINE>
if ( ! equalIgnoringASCIICase ( type , "color" ) ) <NEW_LINE>
error = curl_multi_add_handle ( mh -> multi , ch -> cp ) ; <NEW_LINE>SAVE_CURLM_ERROR ( mh , error ) ; <NEW_LINE><NEW_LINE>RETURN_LONG ( ( zend_long ) error ) ; <NEW_LINE>
class BASE_API FileEnumerator { <NEW_LINE>
<NEW_LINE>
AutoPushJSContext cx ( scx ? scx -> GetNativeContext ( ) : nullptr ) ; <NEW_LINE>
maxlen = 128 ; <NEW_LINE>
if ( pos != end ) <NEW_LINE>return E_FILE_FORMAT_INVALID ; <NEW_LINE><NEW_LINE>
m_entries = new ( std::nothrow ) BlockEntry * [ m_entries_size ] ; <NEW_LINE>if ( m_entries == NULL ) <NEW_LINE>return - 1 ; <NEW_LINE>
<NEW_LINE>bool mDroppedDown ; <NEW_LINE><NEW_LINE>bool mInRedisplayText ; <NEW_LINE><NEW_LINE>bool mDelayedShowDropDown ; <NEW_LINE><NEW_LINE>
temp = ( png_uint_32 ) ( * ( profile + 8 ) ) ; <NEW_LINE>if ( temp > 3 && ( profile_len & 0x03 ) ) <NEW_LINE>
break ; <NEW_LINE>
display -> local_row ) ) ; <NEW_LINE>
<NEW_LINE>
void oidc_scrub_headers ( request_rec * r ) { <NEW_LINE>
#endif
ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) calloc ( min_size , sizeof ( uint8_t ) ) ; <NEW_LINE>
ND_TCHECK_16BITS ( p + 2 ) ; <NEW_LINE>
nsWindow * window = GetContainerWindow ( ) ; <NEW_LINE>if ( ! window ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>
if ( ! IsHTML ( ) || mDisableDocWrite ) { <NEW_LINE>
char tmp_directory [ ] = LARGE_DATA_TMP_DIR" / abrt - tmp - debuginfo . XXXXXX" ; <NEW_LINE>if ( mkdtemp ( tmp_directory ) == NULL ) <NEW_LINE>perror_msg_and_die ( "Failed to create working directory" ) ; <NEW_LINE><NEW_LINE>log_info ( "Created working directory: % s" , tmp_directory ) ; <NEW_LINE><NEW_LINE><NEW_LINE>const char * args [ 13 ] ; <NEW_LINE>
<NEW_LINE>
<NEW_LINE>w = d_w ; <NEW_LINE>h = d_h ; <NEW_LINE>
image_transform_png_set_strip_alpha_set ( const image_transform * this , <NEW_LINE>
uint64_t allocSize = mNumSyncSamples * ( uint64_t ) sizeof ( uint32_t ) ; <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
ptime -> day % 32 , short_months [ ( ptime -> month - 1U ) % 12 ] , <NEW_LINE>
skb -> mac . raw = skb -> nh . raw = skb -> data ; <NEW_LINE><NEW_LINE><NEW_LINE>skb -> nh . iph -> protocol = IPPROTO_ICMP ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
static const vpx_prob default_inter_mode_probs [ INTER_MODE_CONTEXTS ] <NEW_LINE>
ps_dec -> u2_total_mbs_coded += u1_num_mbs ; <NEW_LINE>
data = realloc ( newItems , newItems -> size ) ; <NEW_LINE>if ( ! data ) <NEW_LINE>free ( dst -> data ) ; <NEW_LINE>dst -> data = data ; <NEW_LINE>
Alloc::SizeTooBig ( ) ; <NEW_LINE>
extern void ssl3_SetSIDSessionTicket ( sslSessionID * sid , <NEW_LINE>NewSessionTicket * session_ticket , <NEW_LINE>PRBool isTicketRenewal ) ; <NEW_LINE>
PluginDelegate::OutOfProcessProxy * out_of_process_proxy , <NEW_LINE>
if ( png_get_hIST ( read_ptr , read_info_ptr , & hist ) != 0 ) <NEW_LINE>
const image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE>
len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; <NEW_LINE><NEW_LINE>
bool WebGLImageConversion::ExtractTextureData ( <NEW_LINE>unsigned width , <NEW_LINE>unsigned height , <NEW_LINE>GLenum format , <NEW_LINE>GLenum type , <NEW_LINE>const PixelStoreParams & unpack_params , <NEW_LINE>bool flip_y , <NEW_LINE>bool premultiply_alpha , <NEW_LINE>const void * pixels , <NEW_LINE>Vector < uint8_t > & data ) { <NEW_LINE>
<NEW_LINE>
<NEW_LINE>
if ( ! nsHttp::IsValidToken ( flatMethod ) ) <NEW_LINE>
if ( type == FILE_BEQUAD ) <NEW_LINE>cvt_64 ( p , m ) ; <NEW_LINE>
#define _GENERATED_STDINT_H "fontconfig 2 . 12 . 6" <NEW_LINE><NEW_LINE>
AddPendingRecompile ( cx , script_ ) ; <NEW_LINE>
if ( aWatchId < 0 || count == 0 || PRUint32 ( aWatchId ) >= count ) <NEW_LINE>
<NEW_LINE>
if ( relative ) { <NEW_LINE>res = xmlBuildRelativeURI ( ( xmlChar * ) str , ( xmlChar * ) base ) ; <NEW_LINE> } else { <NEW_LINE>res = xmlBuildURI ( ( xmlChar * ) str , ( xmlChar * ) base ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
float * logmdct , <NEW_LINE>
virtual void DidFocus ( WebLocalFrame * calling_frame ) { }
virtual void OnChannelConnected ( int32 peer_pid ) OVERRIDE ; <NEW_LINE>
public AnimationDelegate { <NEW_LINE>
JS_ASSERT ( ! fp -> runningInIon ( ) ) ; <NEW_LINE>
owner = ssplit ( auth , ":" , & tok ) ; <NEW_LINE>
if ( ctxt -> instate != XML_PARSER_EOF ) <NEW_LINE>ctxt -> instate = state ; <NEW_LINE>
nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>
unsigned contentlen = 0 ; <NEW_LINE>
static char buf [ 1024 + 1 ] ; <NEW_LINE>char * bufp = buf ; <NEW_LINE>size_t space_left = sizeof ( buf ) , string_size ; <NEW_LINE>
void ResetDirectionSetByTextNode ( nsTextNode * aTextNode , bool aNullParent ) ; <NEW_LINE>
bool usable = ! HasDecoderError ( ) ; <NEW_LINE>
( * JSFinalizeCallback ) ( JSFreeOp * fop , JSFinalizeStatus status , JSBool isCompartment ) ; <NEW_LINE>
png_crc_finish ( png_ptr , ( int ) length - num * 3 ) ; <NEW_LINE>
if ( ! FireClipboardEvent ( NS_PASTE , aSelectionType ) ) <NEW_LINE>
aValue -> mMethods . IsEmpty ( ) ) { <NEW_LINE>
void vp9_choose_segmap_coding_method ( VP9_COMMON * cm , MACROBLOCKD * xd ) ; <NEW_LINE>
nsCSSKeyframesRule * KeyframesRuleForName ( nsPresContext * aPresContext , <NEW_LINE>const nsString & aName ) ; <NEW_LINE>
output_block_number_ ( true ) { } <NEW_LINE>
( void ) WriteBlob ( image , tga_info . id_length , ( unsigned char * ) comment ) ; <NEW_LINE>
#define NSS_BUILTINS_LIBRARY_VERSION_MINOR 80 <NEW_LINE>#define NSS_BUILTINS_LIBRARY_VERSION "1 . 80" <NEW_LINE>
void vp9_tree_probs_from_distribution ( vpx_tree tree , <NEW_LINE>
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] = { L'\0' } ; <NEW_LINE>wcsncpy ( updateStatusFilePath , updateDirPath , MAX_PATH ) ; <NEW_LINE>
image_transform_png_set_background_set ( const image_transform * this , <NEW_LINE>
png_ptr = png_create_read_struct ( png_get_libpng_ver ( NULL ) , mainprog_ptr , <NEW_LINE>
#endif <NEW_LINE>
#include "core / html / forms / KeyboardClickableInputTypeView . h" <NEW_LINE>
#define VERSION "2 . 12 . 6"
if ( optimize == 0 ) <NEW_LINE>w = gamma_16_from_1 [ ( ( w & 0xff ) >> gamma_shift ) ] [ w >> <NEW_LINE>
if ( ! mCxPusher . Push ( cx , nsCxPusher::ALWAYS_PUSH ) ) { <NEW_LINE>
if ( SIZE_MAX - chunk_size <= size ) { <NEW_LINE>return ERROR_MALFORMED ; <NEW_LINE> } <NEW_LINE><NEW_LINE>uint8_t * buffer = new uint8_t [ size + chunk_size ] ; <NEW_LINE>
memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ; <NEW_LINE>
MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS , <NEW_LINE>MYSQL_OPT_SSL_ENFORCE <NEW_LINE>
bool isOutOfFlowPositioned ( ) const { return position ( ) == AbsolutePosition || position ( ) == FixedPosition ; } <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
delete [ ] displays_ ; <NEW_LINE>
<NEW_LINE>void Release ( ) { <NEW_LINE>if ( mRefCnt == PR_UINT32_MAX ) { <NEW_LINE>NS_WARNING ( "refcount overflow , leaking nsCSSValue::Image" ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>if ( -- mRefCnt == 0 ) <NEW_LINE>delete this ; <NEW_LINE> } <NEW_LINE>
void fileSystemNotAvailable ( PassRefPtrWillBeRawPtr < ExecutionContext > , CallbackWrapper * ) ; <NEW_LINE>void fileSystemNotAllowedInternal ( PassRefPtrWillBeRawPtr < ExecutionContext > , CallbackWrapper * ) ; <NEW_LINE>void fileSystemAllowedInternal ( PassRefPtrWillBeRawPtr < ExecutionContext > , FileSystemType , CallbackWrapper * ) ; <NEW_LINE>void resolveURLInternal ( PassRefPtrWillBeRawPtr < ExecutionContext > , const KURL & , CallbackWrapper * ) ; <NEW_LINE>void deleteFileSystemInternal ( PassRefPtrWillBeRawPtr < ExecutionContext > , FileSystemType , CallbackWrapper * ) ; <NEW_LINE>
( ( image -> ping == MagickFalse ) && ( jp2_image -> comps [ i ] . data == NULL ) ) ) <NEW_LINE>
USB_DT_OTG , ( void ** ) & desc , sizeof ( * desc ) ) ; <NEW_LINE>
reader -> state = XML_TEXTREADER_BACKTRACK ; <NEW_LINE><NEW_LINE>xmlTextReaderRead ( reader ) ; <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
"andw $ 62463 , % % dx\n\t" <NEW_LINE>
error = curl_multi_remove_handle ( mh -> multi , ch -> cp ) ; <NEW_LINE>SAVE_CURLM_ERROR ( mh , error ) ; <NEW_LINE><NEW_LINE>RETVAL_LONG ( ( zend_long ) error ) ; <NEW_LINE>
if ( callee -> opaque ( ) ) { <NEW_LINE>
last mod: $ Id $
#include "third_party / blink / public / web / devtools_frontend . mojom - blink . h" <NEW_LINE>
<NEW_LINE>buflen = MIN ( buflen , buf_size - 8 ) ; <NEW_LINE>
void DeleteSharedWorker ( const GURL & worker , <NEW_LINE>const std::string & name , <NEW_LINE>const url::Origin & constructor_origin ) override ; <NEW_LINE>
if ( mJSGetterObject || mJSSetterObject ) { <NEW_LINE>
regs . setToEndOfScript ( ) ; <NEW_LINE>
if ( childFrame -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) { <NEW_LINE>NS_ASSERTION ( childListName == nsGkAtoms::overflowContainersList || <NEW_LINE>childListName == nsGkAtoms::excessOverflowContainersList , <NEW_LINE>"out - of - flow on wrong child list" ) ; <NEW_LINE>continue ; <NEW_LINE> } <NEW_LINE>
NS_ABORT_IF_FALSE ( size >= 0 && size <= PR_INT32_MAX , "Size out of range . " ) ; <NEW_LINE>
IDBObjectStore::ClearCloneReadInfo ( mCloneReadInfo ) ; <NEW_LINE>
thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride ) ; <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
{ <NEW_LINE>JSAutoCompartment ac ( aContext , js::GetDefaultGlobalForContext ( aContext ) ) ; <NEW_LINE>JS_ReportPendingException ( aContext ) ; <NEW_LINE> } <NEW_LINE>
nsDependentString sourceBuffer ( str ) ; <NEW_LINE>rv = nsContentUtils::ParseDocumentHTML ( sourceBuffer , document , false ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE><NEW_LINE>
#line 81 "re_grammar . y" <NEW_LINE>
0 , 112 , 112 , 121 , 125 , 136 , 200 , 204 , 219 , 223 , <NEW_LINE>232 , 246 , 245 , 258 , 281 , 313 , 335 , 355 , 359 , 374 , <NEW_LINE>382 <NEW_LINE>
static unsigned int <NEW_LINE>
v8::Handle < v8::String > keyString = key -> ToString ( ) ; <NEW_LINE>if ( type == v8::ACCESS_GET <NEW_LINE> && childFrame <NEW_LINE> && ! host -> HasRealNamedProperty ( keyString ) <NEW_LINE> && ! window -> HasRealNamedProperty ( keyString ) <NEW_LINE> && name != nameOfProtoProperty ) <NEW_LINE>
tran_low_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; <NEW_LINE>tran_low_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <NEW_LINE>tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <NEW_LINE>
bool canTrimTrailingWhitespace = ! textStyle -> WhiteSpaceIsSignificant ( ) || <NEW_LINE> ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) ; <NEW_LINE>
int argc ; <NEW_LINE>char * argv [ RUNCMD_ARGS_MAX + 1 ] ; <NEW_LINE>int r ; <NEW_LINE><NEW_LINE>
<NEW_LINE>
if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' && <NEW_LINE>strcmp ( conn_opt -> keyword , "dbname" ) != 0 ) <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
#line 699 "ext / standard / var_unserializer . re" <NEW_LINE>
if ( ! diff . needsFullLayout ( ) ) <NEW_LINE>
nsCOMPtr < nsIContent > parent = aTargetNode -> GetParent ( ) ; <NEW_LINE>rv = RemoveElement ( parent , aTargetNode ) ; <NEW_LINE>
UploadRequired * upload_required , <NEW_LINE>std::string * experiment_id ) ; <NEW_LINE>
<NEW_LINE>char buf [ 50 ] , * e ; <NEW_LINE>
const char * name , int rep_quick , my_bool no_copy_stat ) <NEW_LINE>
memcpy ( result , ptr , len ) ; <NEW_LINE>
ret = isofs_read_inode ( inode , relocated ) ; <NEW_LINE>
MOZ_CRASH ( ) ; <NEW_LINE>
if ( oldStyle && oldStyle -> alignItems ( ) == ItemPositionStretch && diff . needsFullLayout ( ) ) { <NEW_LINE>
if ( strncmp ( name , mixer_vols [ i ] . name , 32 ) == 0 ) { <NEW_LINE>
replylen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <NEW_LINE>
equalIgnoringASCIICase ( contentEditableValue , "true" ) ; <NEW_LINE>
else if ( mWritePosition + requiredSpace > mBufferSize || <NEW_LINE>mWritePosition + requiredSpace < mWritePosition ) <NEW_LINE>
nsCOMPtr < nsIContent > oldFocusedContent = mFocusedContent . forget ( ) ; <NEW_LINE>
gint bits_to_handle = remaining_bits_len + ( bit_offset % 8 ) ; <NEW_LINE>
OMX_U32 yFrameSize = sizeof ( uint8 ) * mHandle -> size ; <NEW_LINE>if ( ( outHeader -> nAllocLen < yFrameSize ) || <NEW_LINE> ( outHeader -> nAllocLen - yFrameSize < yFrameSize / 2 ) ) { <NEW_LINE>ALOGE ( "Too small output buffer for reference frame: % zu bytes" , <NEW_LINE>outHeader -> nAllocLen ) ; <NEW_LINE>android_errorWriteLog ( 0x534e4554 , "30033990" ) ; <NEW_LINE>notify ( OMX_EventError , OMX_ErrorUndefined , 0 , NULL ) ; <NEW_LINE>mSignalledError = true ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
nsJSObjWrapper * o = static_cast < nsJSObjWrapper * > ( npobj ) ; <NEW_LINE>return o -> mNpp ; <NEW_LINE>
log_file = fopen_safe ( file_name , "a" ) ; <NEW_LINE>
if ( type == FILE_LELONG ) <NEW_LINE>cvt_32 ( p , m ) ; <NEW_LINE>
# if defined ( __clang__ ) && defined ( __has_attribute ) <NEW_LINE>
<NEW_LINE>
if ( ! cpi -> rc . is_src_frame_alt_ref ) <NEW_LINE>vp9_update_rd_thresh_fact ( tile_data -> thresh_freq_fact , <NEW_LINE>sf -> adaptive_rd_thresh , bsize , best_mode_index ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
nsCSSKeyframesRule * rule = <NEW_LINE>mPresContext -> StyleSet ( ) -> KeyframesRuleForName ( mPresContext , aDest . mName ) ; <NEW_LINE>
NS_ENSURE_NATIVE_COLUMN ( aCol ) ; <NEW_LINE>
<NEW_LINE>int svc_rdma_handle_bc_reply ( struct rpc_xprt * xprt , __be32 * rdma_resp , <NEW_LINE>
nsLayoutUtils::IGNORE_PAINT_SUPPRESSION | nsLayoutUtils::IGNORE_CROSS_DOC ) ; <NEW_LINE>
#line 526 "ext / standard / var_unserializer . re" <NEW_LINE>
FILE_RCSID ( "@ ( # ) $ File: softmagic . c , v 1 . 189 2014 / 05 / 30 16:47:44 christos Exp $ " ) <NEW_LINE>
<NEW_LINE>JSStackFrame * caller = Jsvalify ( iter . interpFrame ( ) ) ; <NEW_LINE>
return symbols_ . lookup ( & shared_ , sym ) ; <NEW_LINE>
cookieStatus , cookieHeader , serverTime , aFromHttp ) ) { <NEW_LINE><NEW_LINE>if ( ! aFromHttp ) <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>
AddPendingRecompile ( cx , script_ ) ; <NEW_LINE>
blocks_ = js_pod_calloc < IonBlockCounts > ( numBlocks ) ; <NEW_LINE>
size_t bytes = no * size ; if ( size && no != bytes / size ) return 0 ; unsigned flags = NEDMALLOC_FORCERESERVE ( p , 0 , bytes ) ; return nedpmalloc2 ( p , bytes , 0 , M2_ZERO_MEMORY | flags ) ;
BlobRegistry::registerBlobURL ( m_internalURL , blobData . release ( ) ) ; <NEW_LINE>
, public nsIDocShell_ESR38_2 <NEW_LINE>
im -> alphaBlendingFlag = alphablending_bak ; <NEW_LINE>
delete [ ] chapters_ ; <NEW_LINE>
int * returndistortion , int * returnintra , <NEW_LINE>int mb_row , int mb_col ) <NEW_LINE>
row_bytes = image -> columns ; <NEW_LINE>
if ( tmp -> mbmi . mode == ZEROMV && <NEW_LINE>tmp -> mbmi . ref_frame == LAST_FRAME ) <NEW_LINE>
<NEW_LINE>
nsCopySupport::FireClipboardEvent ( NS_COPY , nsIClipboard::kGlobalClipboard , presShell , nullptr ) ; <NEW_LINE>
if ( pv -> parser == NULL || pv -> parser -> parser == NULL || <NEW_LINE>
state -> space = fstrndup ( RSTRING_PTR ( space ) , len ) ; <NEW_LINE>
png_warning ( png_ptr , "sPLT chunk too long" ) ; <NEW_LINE>return ; <NEW_LINE>
if ( PR_UINT32_MAX - sz < sizeof * a + pool -> mask ) { <NEW_LINE>a = NULL ; <NEW_LINE> } else { <NEW_LINE>sz += sizeof * a + pool -> mask ; <NEW_LINE>a = ( PLArena * ) PR_MALLOC ( sz ) ; <NEW_LINE> } <NEW_LINE>
ReentrantMonitorAutoEnter lock ( mDecodingMonitor ) ; <NEW_LINE>
RefPtr < SharedBuffer > data = readFile ( webTestsDataDir , "broken . gif" ) ; <NEW_LINE>
int count = snprintf ( dest , destlen , " % s . hcache" , path ) ; <NEW_LINE><NEW_LINE>char * first = strchr ( dest , ' / ' ) ; <NEW_LINE>char * last = strrchr ( dest , ' / ' ) ; <NEW_LINE>if ( first && last && ( last > first ) ) <NEW_LINE> { <NEW_LINE>memmove ( first , last , strlen ( last ) + 1 ) ; <NEW_LINE>count - = ( last - first ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>return count ; <NEW_LINE>
#include "core / html / forms / KeyboardClickableInputTypeView . h" <NEW_LINE>
#define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 88 )
int hstartrow ; <NEW_LINE>
const net::IPEndPoint & remote_address , <NEW_LINE>
memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>
const BigInt u1 = m_group . multiply_mod_order ( m_group . mod_order ( e ) , w ) ; <NEW_LINE>
#endif
SSL_SET_OPTIONS ( mysql ) ; <NEW_LINE>
WEBRUNNER_EXPORT extern const char kIncognitoSwitch [ ] ;
perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , xcp , 0 ) ; <NEW_LINE>
if ( nPortIndex < drv_ctx . ip_buf . actualcount && <NEW_LINE>BITMASK_PRESENT ( & m_inp_bm_count , nPortIndex ) ) { <NEW_LINE>
file_fmttime ( p -> q + m -> num_mask , FILE_T_WINDOWS , tbuf ) ) == - 1 ) <NEW_LINE>
<NEW_LINE>if ( ! EnsureStringLength ( aDest , aSource . Length ( ) ) ) { <NEW_LINE>aDest . Truncate ( ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
#line 882 "ext / standard / var_unserializer . c" <NEW_LINE>
<NEW_LINE>
m_derefElementTimer ( TaskRunnerHelper::get ( TaskType::Networking , <NEW_LINE>element -> document ( ) . frame ( ) ) , <NEW_LINE>this , <NEW_LINE> & ImageLoader::timerFired ) , <NEW_LINE>
static_cast < txConditionalGoto * > ( aState . popPtr ( aState . eConditionalGoto ) ) ; <NEW_LINE>
if ( ( state & PNG_FP_SAW_DOT ) != 0 ) <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
for ( i = 0 ; i < iface -> enc . cfg_map_count ; ++ i ) { <NEW_LINE>map = iface -> enc . cfg_maps + i ; <NEW_LINE>
for ( i = 1 ; i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <NEW_LINE>
USB_DT_SECURITY , ( void ** ) & secd , sizeof ( * secd ) ) ; <NEW_LINE>
memset ( & ah , 0 , sizeof ( ah ) ) ; <NEW_LINE>
desc . fun = i . maybeCallee ( ) ; <NEW_LINE>
if ( BITMASK_PRESENT ( & m_out_bm_count , i ) ) { <NEW_LINE>BITMASK_CLEAR ( & m_out_bm_count , i ) ; <NEW_LINE>client_buffers . free_output_buffer ( & m_out_mem_ptr [ i ] ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( release_output_done ( ) ) { <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>
if ( streamDestroyed ) { <NEW_LINE><NEW_LINE><NEW_LINE> * result = NPERR_GENERIC_ERROR ; <NEW_LINE> } <NEW_LINE>else { <NEW_LINE>
JSAutoCompartment ac ( cx , selfHostingGlobal_ ) ; <NEW_LINE>
virtual already_AddRefed < MediaResource > CloneData ( MediaDecoder * aDecoder ) ; <NEW_LINE>
return child -> isOutOfFlowPositioned ( ) || child -> style ( ) -> visibility ( ) == COLLAPSE ; <NEW_LINE>
while ( ( ctxt -> instate != XML_PARSER_EOF ) && <NEW_LINE> ( ( ( RAW == ' < ' ) && ( NXT ( 1 ) == ' ? ' ) ) || <NEW_LINE> ( CMP4 ( CUR_PTR , ' < ' , ' ! ' , ' - ' , ' - ' ) ) || <NEW_LINE>IS_BLANK_CH ( CUR ) ) ) { <NEW_LINE>
unsigned long resource_id , const GURL & url , int notify_id ) ; <NEW_LINE>virtual webkit_glue::WebPluginResourceClient * CreateSeekableResourceClient ( <NEW_LINE>unsigned long resource_id , int range_request_id ) ; <NEW_LINE>
if ( ( length > 0 ) || ( png_ptr -> mode & PNG_HAVE_CHUNK_AFTER_IDAT ) != 0 ) <NEW_LINE>
#define VERSION "2 . 02 of 15 June 2014" <NEW_LINE>
( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) != 0 ) <NEW_LINE>
if ( pageIsProcessSuppressible ( webPage ) ) <NEW_LINE>
memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ; <NEW_LINE>
unsigned int pixel_limit ; <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
interlace_type , 0 , 0 , 0 ) , do_read_interlace , pm -> use_update_info ) ; <NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_PACKSWAP ) != 0 ) <NEW_LINE>
if ( ! BN_rand ( priv_key , l , 0 , 0 ) ) goto err ; <NEW_LINE>if ( ! ENGINE_get_DH ( dh -> engine ) -> bn_mod_exp ( dh , pub_key , dh -> g , <NEW_LINE>priv_key , dh -> p , ctx , mont ) ) goto err ; <NEW_LINE>
static inline realpath_cache_bucket * realpath_cache_find ( const char * path , size_t path_len , time_t t ) <NEW_LINE>
if ( mAttachedShaders [ i ] && mAttachedShaders [ i ] -> ShaderType ( ) == shaderType ) { <NEW_LINE>
( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_GAMMA ) != 0 && <NEW_LINE>
unsigned bytesPerPixel = static_cast < unsigned > ( info . bytesPerPixel ( ) ) ; <NEW_LINE>unsigned srcPixelBytesPerRow = bytesPerPixel * data -> size ( ) . width ( ) ; <NEW_LINE>unsigned dstPixelBytesPerRow = <NEW_LINE>bytesPerPixel * parsedOptions . cropRect . width ( ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>
} JSVAL_ALIGNMENT jsval_layout ; <NEW_LINE>
if ( cur -> psvi == XSLT_RVT_LOCAL ) { <NEW_LINE>xsltReleaseRVT ( elem -> context , cur ) ; <NEW_LINE> } else if ( cur -> psvi == XSLT_RVT_FUNC_RESULT ) { <NEW_LINE>xsltRegisterLocalRVT ( elem -> context , cur ) ; <NEW_LINE>cur -> psvi = XSLT_RVT_FUNC_RESULT ; <NEW_LINE> } else { <NEW_LINE>
mWebGLError = LOCAL_GL_NO_ERROR ; <NEW_LINE>
va_list args ) <NEW_LINE>
XPCAutoRequest ar ( mContext ) ; <NEW_LINE>
} else if ( <NEW_LINE>terminatorType_ != TerminatorType::NEWLINE && b == '\r' && <NEW_LINE> ! c . isAtEnd ( ) && * c . peekBytes ( ) . data ( ) == '\n' ) { <NEW_LINE>
is_directional_ == other . is_directional_ ; <NEW_LINE>
int MAX_DIAL_ADDRESS = 128 ; <NEW_LINE>
if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ( ICANON | EXTPROC ) ) { <NEW_LINE>
JS_ASSERT ( maybecx_ -> regs ( ) . spForStackDepth ( 0 ) == interpFrame ( ) -> base ( ) ) ; <NEW_LINE>return maybecx_ -> regs ( ) . sp - interpFrame ( ) -> base ( ) ; <NEW_LINE>
if ( pCmdData == NULL || cmdSize != 2 * sizeof ( uint32_t ) || pReplyData == NULL || <NEW_LINE>replySize == NULL || * replySize < 2 * sizeof ( int32_t ) ) { <NEW_LINE>
#define ar_sha ( ap ) ( ( ( const u_char * ) ( ( ap ) + 1 ) ) + 0 ) <NEW_LINE>
<NEW_LINE>
sixel_pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , image -> rows ) ; <NEW_LINE>
if ( ! style ( ) -> isOutOfFlowPositioned ( ) && o -> hasColumns ( ) ) { <NEW_LINE>
if ( HAVE_IP ( 6 , 0 ) ) { <NEW_LINE>
return emitNativeCall ( & generatedSpecializedNative , argc , args , true ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>
} else if ( AccessCheck::needsSystemOnlyWrapper ( obj ) && ! canAccessNAC ) { <NEW_LINE>
scoped_ptr < base::TickClock > time_source_ ; <NEW_LINE>
if ( cluster_off < 0 ) { <NEW_LINE><NEW_LINE>return E_FILE_FORMAT_INVALID ; <NEW_LINE> } <NEW_LINE>
in_what -> stride ) ; <NEW_LINE>
nsRefPtr < ContextHolder > sandcx = new ContextHolder ( cx , sandbox , prin ) ; <NEW_LINE>
fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; <NEW_LINE>if ( fd >= 0 && ( fstat ( fd , & st ) == 0 ) && S_ISREG ( st . st_mode ) ) { <NEW_LINE>file = fdopen ( fd , "a" ) ; <NEW_LINE>if ( file != NULL ) { <NEW_LINE>cfg -> debug_file = file ; <NEW_LINE>cfg -> is_custom_debug_file = 1 ; <NEW_LINE>file = NULL ; <NEW_LINE>fd = - 1 ; <NEW_LINE>
case BODY_CHUNK_LF: <NEW_LINE>case BODY_CHUNK_END: <NEW_LINE>case BODY_CHUNK_END_LF: { <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ; <NEW_LINE>
js_DestroyScriptFromGC ( cx , script , NULL ) ; <NEW_LINE>
#if ENABLE_BGP_VNC_ATTR <NEW_LINE>
DecodedStreamData * aStream , <NEW_LINE>AudioSegment * aOutput ) <NEW_LINE>
ret_value = 0 ; <NEW_LINE>goto to_exit ; <NEW_LINE>
return 1 ; <NEW_LINE>
uint8_t clear_buffer [ 10 ] ; <NEW_LINE>
explicit ScopedGenericObj ( C p = C ( ) ) : obj_ ( p ) { } <NEW_LINE>
sf -> use_rd_breakout && <NEW_LINE>
NULL , <NEW_LINE>NULL , <NEW_LINE>false , <NEW_LINE>proxy_WeakmapKeyDelegate <NEW_LINE>
isoclns_print ( ndo , p - 1 , length + 1 ) ; <NEW_LINE>
static const interp_kernel filteredinterp_filters625 [ ( 1 << SUBPEL_BITS ) ] = { <NEW_LINE>
Copyright ( c ) 1998 - 2015 Greg Roelofs . All rights reserved . <NEW_LINE>
virtual bool IsPluginAvailable ( <NEW_LINE>
absl::optional < uint64_t > byteSize ( ) const override ; <NEW_LINE>uint64_t refreshByteSize ( ) override ; <NEW_LINE>uint64_t byteSizeInternal ( ) const override ; <NEW_LINE>
balloon_stats . max_retry_count = 4 ; <NEW_LINE>
sqlite3_int64 nNew = sbuf . st_size * 2 ; <NEW_LINE>
WORD32 impeg2d_dec_p_mb_params ( dec_state_t * ps_dec ) <NEW_LINE>
nsCOMPtr < nsIContent > content = do_QueryReferent ( mContent ) ; <NEW_LINE>if ( content ) { <NEW_LINE><NEW_LINE><NEW_LINE>nsCOMPtr < nsIRunnable > event = new AsyncPaintWaitEvent ( content , true ) ; <NEW_LINE>NS_DispatchToMainThread ( event ) ; <NEW_LINE> } <NEW_LINE>
base::ProcessId peer_pid ( ) { return channel_ -> peer_pid ( ) ; } <NEW_LINE>
while ( next_format ( & colour_type , & bit_depth , & palette_number , <NEW_LINE>pm -> test_lbg_gamma_composition , pm -> test_tRNS ) ) <NEW_LINE>if ( ( colour_type & PNG_COLOR_MASK_ALPHA ) != 0 <NEW_LINE>#if 0 <NEW_LINE><NEW_LINE> || colour_type == 3 <NEW_LINE>#endif <NEW_LINE> || ( colour_type != 3 && palette_number != 0 ) ) <NEW_LINE>
TEMP_FAILURE_RETRY ( write ( logfile_fd , data , length ) ) ; <NEW_LINE>
scoped_ptr < base::DictionaryValue > data ) ; <NEW_LINE>
AutoPushJSContext cx ( context -> GetNativeContext ( ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>void RemoveEntryAtIndex ( int index ) ;
( ! current -> isFloating ( ) && ! current -> isReplaced ( ) && ! current -> isOutOfFlowPositioned ( ) ) ) ) <NEW_LINE>
PUBLIC MprJson * mprReadJsonObj ( MprJson * obj , cchar * name ) <NEW_LINE>
virtual bool multiple ( ) const ; <NEW_LINE>
for ( j = last ; j < this ; j ++ ) { <NEW_LINE>oggpack_write ( opb , i - count , _ilog ( c -> entries - count ) ) ; <NEW_LINE>count = i ; <NEW_LINE> } <NEW_LINE>
* selection . start ( ) . document ( ) , text , selection . asSelection ( ) , <NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
( mHTMLEditor -> mRangeUpdater ) . DropRangeItem ( mRangeItem ) ; <NEW_LINE>
nsresult rv = proxyEnv . getOrSetFakeOrigin ( ( nsCSecurityContext * ) securityContext ) ; <NEW_LINE>if ( NS_SUCCEEDED ( rv ) ) <NEW_LINE>secureEnv -> CallMethod ( jvoid_type , obj , method -> mMethodID , args , & unusedValue , securityContext ) ; <NEW_LINE>
nsAutoCString host ( PublicKeyPinningService::CanonicalizeHostname ( aHost ) ) ; <NEW_LINE>return SetHPKPState ( host . get ( ) , dynamicEntry , 0 ) ; <NEW_LINE>
#include "vpx_dsp / vpx_convolve . h" <NEW_LINE>
#ifndef CONTENT_SHELL_RENDERER_LAYOUT_TEST_BLINK_TEST_HELPERS_H_ <NEW_LINE>#define CONTENT_SHELL_RENDERER_LAYOUT_TEST_BLINK_TEST_HELPERS_H_ <NEW_LINE>
if ( ! mActionNesting ) <NEW_LINE> { <NEW_LINE><NEW_LINE>mTheAction = action ; <NEW_LINE> } <NEW_LINE>mActionNesting ++ ; <NEW_LINE>
@stability Evolving <NEW_LINE>
if ( isDH ) { <NEW_LINE>master_params . pVersion = NULL ; <NEW_LINE> } else { <NEW_LINE>master_params . pVersion = & pms_version ; <NEW_LINE> } <NEW_LINE>
OMX_BUFFERHEADERTYPE * header = mBufferIDToBufferHeader . valueAt ( index ) ; <NEW_LINE>BufferMeta * buffer_meta = <NEW_LINE>static_cast < BufferMeta * > ( header -> pAppPrivate ) ; <NEW_LINE>if ( buffer_meta -> getPortIndex ( ) != portIndex ) { <NEW_LINE>CLOGW ( "findBufferHeader: buffer % u found but with incorrect port index . " , buffer ) ; <NEW_LINE>android_errorWriteLog ( 0x534e4554 , "28816827" ) ; <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE>return header ; <NEW_LINE>
} <NEW_LINE>
if ( ! ac . enter ( ccx , existingJSObject ) ) { <NEW_LINE>wrapper -> mIdentity = nsnull ; <NEW_LINE>NS_RELEASE ( wrapper ) ; <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( ! wrapper -> Init ( ccx , existingJSObject ) ) { <NEW_LINE>
if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , <NEW_LINE>sizeof ( jpc_fix_t ) ) ) ) { <NEW_LINE>
if ( subl == 0 ) <NEW_LINE>break ; <NEW_LINE>
res = vpx_codec_enc_config_default ( global -> codec -> codec_interface ( ) , <NEW_LINE>
else if ( fun -> isInterpretedLazy ( ) && ! fun -> isSelfHostedBuiltin ( ) ) <NEW_LINE>
public nsStubMutationObserver , <NEW_LINE>public nsIDocument_MOZILLA_1_9_2_BRANCH <NEW_LINE>
0 , 112 , 112 , 117 , 121 , 125 , 137 , 156 , 160 , 173 , <NEW_LINE>187 , 203 , 217 , 233 , 256 , 280 , 302 , 325 , 329 , 335 , <NEW_LINE>341 , 347 , 356 , 362 , 368 , 376 , 382 , 388 , 394 , 400 , <NEW_LINE>406 , 412 <NEW_LINE>
#endif <NEW_LINE>
nsIDOMGetUserMediaErrorCallback * aOnError , <NEW_LINE>uint64_t aInnerWindowID ) <NEW_LINE>
Layer * layer = compositable -> GetLayer ( ) ; <NEW_LINE>if ( ! layer || layer -> GetType ( ) != Layer::TYPE_THEBES ) { <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE>ThebesLayerComposite * thebes = static_cast < ThebesLayerComposite * > ( layer ) ; <NEW_LINE>
NS_ENSURE_NATIVE_COLUMN ( aCol ) ; <NEW_LINE>
if ( name != NULL ) <NEW_LINE>while ( iin < ( PNG_MAX_ERROR_TEXT - 1 ) && name [ iin ] != 0 ) <NEW_LINE> { <NEW_LINE>msg [ fixed_message_ln + iin ] = name [ iin ] ; <NEW_LINE> ++ iin ; <NEW_LINE> } <NEW_LINE>
static uint64_t appendToHeader ( HeaderString & header , absl::string_view data ) ; <NEW_LINE>
if ( ! item -> AllocateBuffers ( ) ) { <NEW_LINE>delete item ; <NEW_LINE>return nsnull ; <NEW_LINE> } <NEW_LINE>
nsresult GetInterfaceGlobal ( const nsIID & aIID , void ** result ) ; <NEW_LINE><NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
audio_buffer_t * outBuffer __unused ) <NEW_LINE>
char * fpath = NULL , * path1 , * cgdir = NULL , * controller , * next = NULL ; <NEW_LINE>
#define LIBRAW_PATCH_VERSION 8 <NEW_LINE>
auto key = it . first ( ) ; <NEW_LINE>auto const & value = it . secondRef ( ) ; <NEW_LINE>recursiveAddVarImpl ( key . toString ( ) , value , isObject , seen ) ; <NEW_LINE>
protected: <NEW_LINE>friend class AudioClock ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>int64_t GetPositionInFramesUnlocked ( ) ; <NEW_LINE><NEW_LINE>
XPCWrappedNativeJSClass mJSClass ; <NEW_LINE>
SynthesizeSlowNativeFrame ( InterpState & state , JSContext * cx , VMSideExit * exit ) <NEW_LINE>
jas_uchar * data ; <NEW_LINE>
nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>
struct ip_options_data replyopts ; <NEW_LINE>
mTimeToSample ( ) , <NEW_LINE>
ScrollPaintPropertyNode ( const ScrollPaintPropertyNode * parent , State && state ) <NEW_LINE>: PaintPropertyNode ( parent ) , state_ ( std::move ( state ) ) { <NEW_LINE>
chase = ( ( ogg_uint16_t * ) ( book -> dec_table ) ) [ chase * 2 + ( ( lok >> i ) & 1 ) ] ; <NEW_LINE>if ( chase & 0x8000UL ) break ; <NEW_LINE>
equalIgnoringASCIICase ( value , "true" ) ) ; <NEW_LINE>
strncpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <NEW_LINE>strncpy ( ualg -> cru_driver_name , alg -> cra_driver_name , <NEW_LINE>sizeof ( ualg -> cru_driver_name ) ) ; <NEW_LINE>strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , <NEW_LINE>sizeof ( ualg -> cru_module_name ) ) ; <NEW_LINE>ualg -> cru_type = 0 ; <NEW_LINE>ualg -> cru_mask = 0 ; <NEW_LINE>
xmlRelaxNGSetParserErrors ( ctxt , testErrorHandler , testErrorHandler , ctxt ) ; <NEW_LINE>
IDBObjectStore::ClearCloneReadInfo ( mCloneReadInfo ) ; <NEW_LINE>
static inline long decode_twos_comp ( jas_ulong c , int prec ) <NEW_LINE>
if ( TEMP_FAILURE_RETRY ( ioctl ( socket -> fd , FIONREAD , & size ) ) == - 1 ) <NEW_LINE>
return throwError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( effect_config_t ) ) { <NEW_LINE>
if ( png_get_pHYs ( read_ptr , read_info_ptr , & res_x , & res_y , <NEW_LINE> & unit_type ) != 0 ) <NEW_LINE>
nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>
cm -> interp_filter : best_filter ; <NEW_LINE>rs = cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( cpi , xd ) : 0 ; <NEW_LINE>
<NEW_LINE>next = voidcast ( IDAT_list * , malloc ( IDAT_list_size ( NULL , length ) ) ) ; <NEW_LINE>
if ( ! WriteEbmlElement ( writer , kMkvSamplingFrequency , <NEW_LINE>
DECLARE_ALIGNED ( 16 , unsigned short , FData2 [ 16 * 16 ] ) ; <NEW_LINE>
return CallQueryReferent ( mContent . get ( ) , result ) ; <NEW_LINE>
} \ <NEW_LINE>JS_FRIEND_API ( JSObject * ) js::Unwrap ## Name ## Array ( JSObject * obj ) \ <NEW_LINE> { \ <NEW_LINE>obj = CheckedUnwrap ( obj ) ; \ <NEW_LINE>if ( ! obj ) \ <NEW_LINE>return nullptr ; \ <NEW_LINE>const Class * clasp = obj -> getClass ( ) ; \ <NEW_LINE>if ( clasp == & TypedArrayObject::classes [ TypedArrayObjectTemplate < NativeType > ::ArrayTypeID ( ) ] ) \ <NEW_LINE>return obj ; \ <NEW_LINE>return nullptr ; \ <NEW_LINE> } \ <NEW_LINE>JS_FRIEND_DATA ( const js::Class * const ) js::detail::Name ## ArrayClassPtr = \ <NEW_LINE> & js::TypedArrayObject::classes [ TypedArrayObjectTemplate < NativeType > ::ArrayTypeID ( ) ] ; <NEW_LINE>
#ifndef BASE_BUILD_TIME_H_ <NEW_LINE>#define BASE_BUILD_TIME_H_ <NEW_LINE>
<NEW_LINE>if ( ( jsuint ) idx >= tarray -> length ) <NEW_LINE>RETURN_STOP_A ( "out - of - range index on typed array" ) ;
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
bool OutputSlowerPlayback ( uint8 * dest , int input_step , int output_step ) ; <NEW_LINE>
lir -> insStorei ( INS_NULL ( ) , lirbuf -> state , offsetof ( InterpState , nativeVp ) ) ; <NEW_LINE>
<NEW_LINE>#define EFX_TSO_MAX_SEGS	100 <NEW_LINE><NEW_LINE><NEW_LINE>#define EFX_RXQ_MIN_ENT		128U <NEW_LINE>#define EFX_TXQ_MIN_ENT ( efx ) ( 2 * efx_tx_max_skb_descs ( efx ) ) <NEW_LINE>
<NEW_LINE>
family = ssplit ( sclone ( arch ) , ":" , & cpu ) ; <NEW_LINE>if ( * cpu == '\0' ) { <NEW_LINE>
jas_uchar * data ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
{ <NEW_LINE>DestroyJNG ( NULL , & color_image , & color_image_info , <NEW_LINE> & alpha_image , & alpha_image_info ) ; <NEW_LINE>ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> } <NEW_LINE>
Type GetType ( ) const override ;
const standard_display * dp = voidcast ( standard_display * , <NEW_LINE>
long points ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
PROXY_CLASS_EXT , <NEW_LINE>
CallbackWrapper * callbacks ) <NEW_LINE>
weight = ( ssize_t ) StringToUnsignedLong ( token ) ; <NEW_LINE>
if ( JAS_CAST ( jas_uint , jas_stream_write ( out , ( char * ) ppm -> data , ppm -> len ) ) != ppm -> len ) { <NEW_LINE>
char buf [ L_BUFSIZE ] ; <NEW_LINE>
if ( ctxt -> instate != XML_PARSER_EOF ) <NEW_LINE>ctxt -> instate = state ; <NEW_LINE>
if ( s && s >= filename ) { <NEW_LINE>
class BASE_API LogMessage { <NEW_LINE>
if ( ! IsHTML ( ) || mDisableDocWrite ) { <NEW_LINE>
nsAutoTArray < TemplateRule , 10 > mTemplateRules ; <NEW_LINE>
#include < android / log . h > <NEW_LINE>
void OnDecode ( base::SharedMemoryHandle handle , int32 id , uint32 size ) ; <NEW_LINE>
if ( getaddrs . addr_num <= 0 || <NEW_LINE>getaddrs . addr_num >= ( INT_MAX / sizeof ( union sctp_addr ) ) ) <NEW_LINE>return - EINVAL ; <NEW_LINE>
last = RCAST ( const char * , s ) + bytecnt ; <NEW_LINE>
int bit = ( lok >> i ) & 1 ; <NEW_LINE>int next = t [ chase + bit ] ; <NEW_LINE>if ( next & 0x8000 ) { <NEW_LINE>chase = ( next << 16 ) | t [ chase + bit + 1 + ( ! bit || t [ chase ] & 0x8000 ) ] ; <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>chase = next ; <NEW_LINE>
static const interp_kernel filteredinterp_filters875 [ ( 1 << SUBPEL_BITS ) ] = { <NEW_LINE>
bool FireClipboardEvent ( int32_t aType , int32_t aSelectionType ) ; <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
void doRemoveChild ( bool aNotify ) ; <NEW_LINE>
ND_TCHECK_32BITS ( p + 2 ) ; <NEW_LINE>
if ( threadParams [ i ] . okay == 0 ) { <NEW_LINE>printf ( "Thread % d handling % s failed\n" , i , <NEW_LINE>threadParams [ i ] . filename ) ; <NEW_LINE>
fPtr = count ? ( T * ) sk_malloc_throw ( count , sizeof ( T ) ) : nullptr ; <NEW_LINE>
if ( mIsWidevine && ! audio && mVideoTrack . mSource != NULL ) { <NEW_LINE>
WORD32 i , j ; <NEW_LINE>
CKM_INVALID_MECHANISM , UNSUPPORTED_CERT_EXTENSION ) , <NEW_LINE>
<NEW_LINE><NEW_LINE>int leading_inset_ ; <NEW_LINE><NEW_LINE>
nsWindow * window = GetContainerWindow ( ) ; <NEW_LINE>if ( ! window ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>
nsresult PostHandleEvent ( nsEventChainPostVisitor & aVisitor , <NEW_LINE>nsCxPusher * aPusher ) ; <NEW_LINE>
public rdfIDataSource , <NEW_LINE>public nsIInterfaceRequestor , <NEW_LINE>public nsIChannelEventSink <NEW_LINE>
if ( diff . needsFullLayout ( ) ) <NEW_LINE>
goto err_add_port ; <NEW_LINE>
IDBObjectStore::ClearCloneReadInfo ( mCloneReadInfo ) ; <NEW_LINE>
if ( ! silf ) <NEW_LINE>
#include "platform / mediastream / MediaStreamSource . h" <NEW_LINE>
if ( ! WriteEbmlElement ( writer , kMkvContentEncKeyID , enc_key_id_ , <NEW_LINE>
@stability Stable <NEW_LINE>
} <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
rec -> sasl_username = g_strdup ( src -> sasl_username ) ; <NEW_LINE>rec -> sasl_password = g_strdup ( src -> sasl_password ) ; <NEW_LINE>
process . start ( QString ( " % 1 - s % 2 - c - q - C - L / var / log / partclone . log" ) . arg ( getPartcloneExecuter ( DDevicePartInfo ( partDevice ) ) ) . arg ( partDevice ) ) ; <NEW_LINE>
delete [ ] header ; <NEW_LINE>
#ifndef BASE_DEBUG_DEBUGGER_H_ <NEW_LINE>#define BASE_DEBUG_DEBUGGER_H_ <NEW_LINE>
FreeLineBox ( lineBox ) ; <NEW_LINE>
AutoPushJSContext cx ( sc -> GetNativeContext ( ) ) ; <NEW_LINE>
if ( ( flags & PNG_FLAG_FILLER_AFTER ) != 0 ) <NEW_LINE>
<NEW_LINE>
bool SafeToDisplayAsUnicode ( base::StringPiece16 label , <NEW_LINE>base::StringPiece top_level_domain ) ;
virtual nsresult InstallMember ( JSContext * aCx , <NEW_LINE>JSObject * aTargetClassObject ) { <NEW_LINE>
if ( dstOffset > SIZE_MAX - 4 || <NEW_LINE>dstOffset + 4 > SIZE_MAX - nalLength || <NEW_LINE>dstOffset + 4 + nalLength > mBuffer -> size ( ) ) { <NEW_LINE>ALOGE ( "b / 27208621 : % zu % zu" , dstOffset , mBuffer -> size ( ) ) ; <NEW_LINE>android_errorWriteLog ( 0x534e4554 , "27208621" ) ; <NEW_LINE>mBuffer -> release ( ) ; <NEW_LINE>mBuffer = NULL ; <NEW_LINE>return ERROR_MALFORMED ; <NEW_LINE> } <NEW_LINE>
tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <NEW_LINE>
if ( ! parser -> tokenStream . seek ( position , tokenStream ) ) <NEW_LINE>return false ; <NEW_LINE>
while ( ( RAW != ' ) ' ) && ( ctxt -> instate != XML_PARSER_EOF ) ) {
pathlen = get_node_path_locked ( node -> parent , buf , bufsize - namelen - 1 ) ; <NEW_LINE>
extern void __perf_sw_event ( u32 , u64 , struct pt_regs * , u64 ) ; <NEW_LINE>
SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
<NEW_LINE>
@stability Evolving <NEW_LINE>
if ( PNG_OUT_OF_RANGE ( xy1 -> whitex , xy2 -> whitex , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> whitey , xy2 -> whitey , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> redx , xy2 -> redx , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> redy , xy2 -> redy , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> greenx , xy2 -> greenx , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> greeny , xy2 -> greeny , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> bluex , xy2 -> bluex , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> bluey , xy2 -> bluey , delta ) ) <NEW_LINE>return 0 ; <NEW_LINE>return 1 ; <NEW_LINE>
res = ctx -> iface -> init ( ctx , NULL ) ; <NEW_LINE>if ( res ) { <NEW_LINE>ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; <NEW_LINE>vpx_codec_destroy ( ctx ) ; <NEW_LINE>
param . iter . type = siBuffer ; <NEW_LINE>
samples_per_pixel , 0 , 0 ) ; <NEW_LINE>
if ( vt_verify_kbmode ( fd_d ) < 0 ) <NEW_LINE>
if ( js::GetObjectJSClass ( obj ) == & kFakeBackstagePassJSClass ) { <NEW_LINE>MOZ_ASSERT ( mReuseLoaderGlobal ) ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>mThisObjects . Put ( tableScript , obj ) ; <NEW_LINE> } <NEW_LINE>
static already_AddRefed < MediaResource > Create ( MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <NEW_LINE>
<NEW_LINE>
#define for_each_leaf_cfs_rq ( rq , cfs_rq ) 	\ <NEW_LINE>for ( cfs_rq = & rq -> cfs ; cfs_rq ; cfs_rq = NULL ) <NEW_LINE>
ND_TCHECK_16BITS ( p + 2 ) ; <NEW_LINE>
if ( TEMP_FAILURE_RETRY ( fcntl ( semaphore -> fd , F_SETFL , flags ) ) == - 1 ) <NEW_LINE>
<NEW_LINE><NEW_LINE>DidBuildModelImpl ( aTerminated || IsBroken ( ) ) ; <NEW_LINE>
if ( ctxt -> input -> cur - ctxt -> input -> base < len ) { <NEW_LINE><NEW_LINE>xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , <NEW_LINE>"unexpected change of input buffer" ) ; <NEW_LINE>return ( NULL ) ; <NEW_LINE> } <NEW_LINE>
if ( png_ptr -> idat_size != 0 && png_ptr -> save_buffer_size != 0 ) <NEW_LINE>
#include "platform / win / HWndDC . h" <NEW_LINE>
va_list args ) <NEW_LINE>
while ( ( len > 0 ) && ( buf [ len - 1 ] == 0x20 ) ) len -- ; <NEW_LINE>
if ( ! WriteToContainedDecoder ( ( const char * ) bfhBuffer , sizeof ( bfhBuffer ) , aStrategy ) ) { <NEW_LINE>
SH_DEPENDENCY_GRAPH = 0x0400 , <NEW_LINE><NEW_LINE><NEW_LINE>SH_ENFORCE_PACKING_RESTRICTIONS = 0x0800 , <NEW_LINE>
<NEW_LINE>
| beginSl <NEW_LINE> | beginW <NEW_LINE>
goto skip_children ; <NEW_LINE>
CHAR_LEN_TABLE ( EUCJPCharLenTable ) , <NEW_LINE>
CALL_AND_WAIT ( error = bt_interface -> enable ( false ) , adapter_state_changed ) ; <NEW_LINE>
struct desc_struct desc ; <NEW_LINE>
if ( unlikely ( len + ring -> frameoffset > ring -> rx_buffersize ) ) {
HistoryContentsProvider ( AutocompleteProviderListener * listener , <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
<NEW_LINE>
int64_t Amount ( ) MOZ_OVERRIDE { return HunspellAllocator::MemoryAllocated ( ) ; } <NEW_LINE>
memcpy ( data , src , img . elemSize1 ( ) * m_width ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>
if ( innerTextRenderer && diff . needsFullLayout ( ) ) <NEW_LINE>
ogg_int32_t ** in , int * nonzero , int ch ) { <NEW_LINE>
<NEW_LINE><NEW_LINE>
if ( focusedContent -> ChromeOnlyAccess ( ) ) { <NEW_LINE>
lineHeight = <NEW_LINE>nsHTMLReflowState::CalcLineHeight ( GetStyleContext ( ) , NS_AUTOHEIGHT ) ; <NEW_LINE>
if ( ( png_ptr -> flags & PNG_FLAG_ZSTREAM_ENDED ) == 0 ) <NEW_LINE>
ALOGE ( "memset buffer too small: got % u , expected % zu" , outHeader -> nAllocLen , len ) ; <NEW_LINE>
float value = m_value ; <NEW_LINE>
xmlXPathObjectPtr res ; <NEW_LINE>
SetHeader ( atom , nsDependentCString ( p , p2 - p ) , PR_TRUE , PR_FALSE ) ; <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>
<NEW_LINE><NEW_LINE>base::WeakPtr < IndexedDBConnection > connection_ ; <NEW_LINE>
mntflags , mntdata , optional , rootfs ) ; <NEW_LINE>
NS_ENSURE_NATIVE_COLUMN ( aCol ) ; <NEW_LINE>
mDocument ( aDocument ) , mScrollPositionChangedTicks ( 0 ) , mIsLoaded ( PR_FALSE ) <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
if ( eindex < 0 || eindex >= MAX_EVENTS ) { <NEW_LINE>
nsAutoPtr < UniscribeItem > item ( us . GetItem ( i , this ) ) ; <NEW_LINE>if ( ! item ) { <NEW_LINE><NEW_LINE>break ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
fname_len = Z_STRLEN_P ( value ) ; <NEW_LINE>
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_4 ( nsWindowRoot , <NEW_LINE>mWindow , <NEW_LINE>
<NEW_LINE>virtual ProxyBypassRules::ParseFormat GetBypassListFormat ( ) = 0 ; <NEW_LINE>
virtual void OnBufferPresented ( uint64 surface_handle , <NEW_LINE>
GenerateGetTypedArrayElement ( cx , masm , attacher , tarr , idval , object ( ) , index ( ) , output ( ) , <NEW_LINE>allowDoubleResult ( ) ) ; <NEW_LINE>
#include "core / fileapi / BlobRegistry . h" <NEW_LINE>
if ( isOutOfFlowPositioned ( ) ) <NEW_LINE>
{ "enableNative" , " ( Z ) Z" , ( void * ) enableNative } , <NEW_LINE>
RELEASE_ASSERT ( ! m_beginTime ) ; <NEW_LINE>
JSContext * cx = ( JSContext * ) m_args -> m_cx -> GetNativeContext ( ) ; <NEW_LINE>
if ( png_ptr -> save_buffer_size != 0 ) <NEW_LINE>
int bps ; <NEW_LINE>unsigned int bit_depth ; <NEW_LINE>
if ( ps_dec -> u4_first_slice_in_pic == 0 ) <NEW_LINE>
GLint pack_alignment_ = 4 ; <NEW_LINE>GLint unpack_alignment_ = 4 ; <NEW_LINE>bool unpack_flip_y_ = false ; <NEW_LINE>bool unpack_premultiply_alpha_ = false ; <NEW_LINE>GLenum unpack_colorspace_conversion_ = GC3D_BROWSER_DEFAULT_WEBGL ; <NEW_LINE><NEW_LINE>GLint unpack_skip_pixels_ = 0 ; <NEW_LINE>GLint unpack_skip_rows_ = 0 ; <NEW_LINE>GLint unpack_row_length_ = 0 ; <NEW_LINE>
nsresult rv = aState . pushPtr ( copy , aState . eCopy ) ; <NEW_LINE>
size_t lines , linecnt , bytecnt , bytecnt_max ; <NEW_LINE>
mInDtor = PR_FALSE ; <NEW_LINE>
void LeaveTabletMode ( wm::WindowState * window_state , bool was_in_overview ) ; <NEW_LINE>
<NEW_LINE>
zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) <NEW_LINE>
int r = ( int ) TEMP_FAILURE_RETRY ( recv ( p_scb -> socket_id [ 1 ] , p_dcb -> p_tx_pkt , <NEW_LINE>p_dcb -> mtu , MSG_DONTWAIT ) ) ; <NEW_LINE>
if ( unlikely ( get_dumpable ( current -> mm ) != SUID_DUMP_USER ) ) { 	\ <NEW_LINE>
b1 = ssplit ( base1 , " - " , & p1 ) ; <NEW_LINE>b2 = ssplit ( base2 , " - " , & p2 ) ; <NEW_LINE>
mOwner = aOwner -> asWeakPtr ( ) ; <NEW_LINE>
if ( entry ) { <NEW_LINE>binding = mBindery . CreateBinding ( entry , & record ) ; <NEW_LINE>if ( ! binding ) { <NEW_LINE>delete entry ; <NEW_LINE>entry = nsnull ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( ! entry ) { <NEW_LINE> ( void ) mCacheMap . DeleteStorage ( & record ) ; <NEW_LINE> ( void ) mCacheMap . DeleteRecord ( & record ) ; <NEW_LINE>
int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <NEW_LINE>
res = ctx -> iface -> enc . cfg_set ( get_alg_priv ( ctx ) , cfg ) ; <NEW_LINE>
sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( pixels_length + image -> rows , <NEW_LINE>
static const double stereo_threshholds [ ] = { 0 . 0 , . 5 , 1 . 0 , 1 . 5 , 2 . 5 , 4 . 5 , 8 . 5 , 16 . 5 , 9e10 } ; <NEW_LINE>static const double stereo_threshholds_limited [ ] = { 0 . 0 , . 5 , 1 . 0 , 1 . 5 , 2 . 0 , 2 . 5 , 4 . 5 , 8 . 5 , 9e10 } ; <NEW_LINE>
InspectorPageAgent::ResourceType InspectorPageAgent::ToResourceType ( <NEW_LINE>const Resource::Type resource_type ) { <NEW_LINE>switch ( resource_type ) { <NEW_LINE>
{ <NEW_LINE><NEW_LINE>size_t new_ssize = len / ( size_t ) 2 * ( size_t ) 3 + ( size_t ) 1 ; <NEW_LINE>if ( new_ssize < len || new_ssize > LONG_MAX / sizeof ( sop ) ) { <NEW_LINE>free ( ( char * ) g ) ; <NEW_LINE>return REG_INVARG ; <NEW_LINE> } <NEW_LINE>p -> ssize = new_ssize ; <NEW_LINE> } <NEW_LINE>
loadsegment ( fs , fs_selector ) ; <NEW_LINE>#ifdef CONFIG_X86_64 <NEW_LINE>load_gs_index ( gs_selector ) ; <NEW_LINE>wrmsrl ( MSR_KERNEL_GS_BASE , current -> thread . gs ) ; <NEW_LINE>#else <NEW_LINE>loadsegment ( gs , gs_selector ) ; <NEW_LINE>#endif <NEW_LINE>kvm_load_ldt ( ldt_selector ) ; <NEW_LINE>
if ( o -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
<NEW_LINE>
smb_ofile_flush ( sr , sr -> fid_ofile ) ;
value = ( unsigned short ) buffer [ 0 ] << 8 ; <NEW_LINE>value |= ( unsigned short ) buffer [ 1 ] ; <NEW_LINE>quantum . unsigned_value = value & 0xffff ; <NEW_LINE>
if ( ss -> ssl3 . hs . ws != wait_server_key ) { <NEW_LINE>errCode = SSL_ERROR_RX_UNEXPECTED_SERVER_KEY_EXCH ; <NEW_LINE>desc = unexpected_message ; <NEW_LINE>goto alert_loser ; <NEW_LINE>
<NEW_LINE>i1_is_end_of_poc = 1 ; <NEW_LINE>ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; <NEW_LINE><NEW_LINE>if ( ps_dec -> u4_first_slice_in_pic != 2 ) <NEW_LINE>
size_t blocks ; <NEW_LINE>
<NEW_LINE>rc -> source_alt_ref_pending = 0 ; <NEW_LINE>
StyleDifferenceLegacy SVGRenderStyle::diff ( const SVGRenderStyle * other ) const <NEW_LINE>
NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * kdelegate , void * val ) <NEW_LINE>
#line 717 "ext / standard / var_unserializer . re" <NEW_LINE>
return 0 ; <NEW_LINE>
zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
<NEW_LINE>
PlatformSensorAccelerometerMac ( SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
#endif <NEW_LINE>
nsCOMPtr < nsIContent > content = do_QueryReferent ( mContent ) ; <NEW_LINE>nsCOMPtr < nsIRunnable > event = new AsyncPaintWaitEvent ( content , false ) ; <NEW_LINE>
uni_to_string ( get_finfo_value_string ( PTREE_FINFO ( tree_pointer ) ) , MIN ( get_finfo_length ( PTREE_FINFO ( tree_pointer ) ) , buffer_size ) , buffer ) ; <NEW_LINE>
clipboardData = new nsDOMDataTransfer ( NS_COPY , false , - 1 ) ; <NEW_LINE>
if ( ! CanEffectlesslyCallLookupGenericOnObject ( cx , curObj , id ) ) <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>void StartNewContentRenderingTimeout ( uint32_t next_source_id ) ;
void DeleteSharedWorker ( const GURL & worker , <NEW_LINE>const std::string & name , <NEW_LINE>const url::Origin & constructor_origin ) override ; <NEW_LINE>
nsCOMPtr < nsIChannel > mChannel ; <NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
XML_PARSE_BIG_LINES = 1 << 22 <NEW_LINE>
ClearTextRun ( nsnull ) ; <NEW_LINE>
<NEW_LINE>
int notify_id ) = 0 ; <NEW_LINE>
if ( omx -> output_use_buffer && ! omx -> m_use_output_pmem && ! omx -> is_secure_session ( ) ) { <NEW_LINE>
aConstraints , onSuccess . forget ( ) , onError . forget ( ) , <NEW_LINE> ( aInnerWindowID ? aInnerWindowID : aWindow -> WindowID ( ) ) , <NEW_LINE>loopbackAudioDevice , loopbackVideoDevice ) ; <NEW_LINE>
SetHeader ( atom , nsDependentCString ( p , p2 - p ) , PR_TRUE , PR_FALSE ) ; <NEW_LINE>
ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg6 ) ) ; <NEW_LINE>
if ( png_ptr != 0 && png_ptr -> interlaced != 0 ) <NEW_LINE>
mOffscreenStencilRB ( 0 ) , <NEW_LINE>mMaxTextureSize ( 0 ) , <NEW_LINE>mMaxCubeMapTextureSize ( 0 ) , <NEW_LINE>mMaxTextureImageSize ( 0 ) , <NEW_LINE>mMaxRenderbufferSize ( 0 ) <NEW_LINE>
snprintf ( bname , sizeof ( bname ) , " % s % s" , <NEW_LINE>
nsCOMPtr < nsIPresShell > presShell = GetPresShell ( ) ; <NEW_LINE>
memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <NEW_LINE>
if ( p -> flags & PKT_NOPACKET_INSPECTION ) {
d0u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 0 ] ) ; <NEW_LINE>d1u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 1 ] ) ; <NEW_LINE>
CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ; <NEW_LINE>
if ( ! js_doregexec ( J , re -> prog , source , & m , REG_NOTBOL ) ) <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( is_url ( source ) ) <NEW_LINE> { <NEW_LINE>pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , "Source string refers to a remote device" ) ; <NEW_LINE>goto error ; <NEW_LINE> }
if ( isRenderBlock ( ) && isOutOfFlowPositioned ( ) && style ( ) -> height ( ) . isAuto ( ) && ! ( style ( ) -> top ( ) . isAuto ( ) || style ( ) -> bottom ( ) . isAuto ( ) ) ) { <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ;
<NEW_LINE><NEW_LINE><NEW_LINE>
if ( ( png_ptr -> mode & PNG_HAVE_IDAT ) == 0 ) <NEW_LINE>
else if ( el . tagName ( ) == QLatin1String ( "forwarded" ) <NEW_LINE> && el . attribute ( QLatin1String ( "xmlns" ) ) == QLatin1String ( "urn:xmpp:forward:0" ) ) { <NEW_LINE>
if ( gData -> stateStackTop ) <NEW_LINE> -- gData -> stateStackTop ; <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , <NEW_LINE>
<NEW_LINE>virtual void AddDefaultProxyBypassRules ( ) ;
kernel = 4 ; <NEW_LINE>v = p_src [ col ] ; <NEW_LINE>
NS_ENSURE_TRUE_VOID ( pusher . Push ( cx ) ) ; <NEW_LINE>
if ( net != c_net ) <NEW_LINE>
WebGLsizei maxTextureSizeForThisLevel = maxTextureSize >> level ; <NEW_LINE><NEW_LINE>if ( width > maxTextureSizeForThisLevel || height > maxTextureSizeForThisLevel ) <NEW_LINE>return ErrorInvalidValue ( "texImage2D: width or height exceeds maximum texture size for this level" ) ; <NEW_LINE>
if ( ( png_ptr -> flags & PNG_FLAG_APP_WARNINGS_WARN ) != 0 ) <NEW_LINE>
dname = safe_calloc ( strlen ( name ) + 16 ) ; <NEW_LINE>
va_list args ) { <NEW_LINE>
#ifndef BASE_TEST_SEQUENCED_TASK_RUNNER_TEST_TEMPLATE_H_ <NEW_LINE>#define BASE_TEST_SEQUENCED_TASK_RUNNER_TEST_TEMPLATE_H_ <NEW_LINE>
} else if ( pobj -> map -> ops -> thisObject ) { <NEW_LINE>pobj = pobj -> map -> ops -> thisObject ( cx , pobj ) ; <NEW_LINE>if ( ! pobj ) <NEW_LINE>return JS_FALSE ; <NEW_LINE> * vp = OBJECT_TO_JSVAL ( pobj ) ; <NEW_LINE>
bool InternalCloseTabs ( const std::vector < int > & in_indices , <NEW_LINE>uint32 close_types ) ;
<NEW_LINE><NEW_LINE><NEW_LINE>return mExecutor -> MarkAsBroken ( NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE>
<NEW_LINE>
class BASE_API FilePath { <NEW_LINE>
if ( ! send && ! SSL_READ_ETM ( ssl ) && <NEW_LINE>
nsCOMPtr < nsIPresShell > shell = presContext -> PresShell ( ) ; <NEW_LINE>nsresult rv = shell -> RenderDocument ( r , renderDocFlags , bgColor , mThebes ) ; <NEW_LINE>
OMX_BUFFERHEADERTYPE * header = findBufferHeader ( buffer , kPortIndexInput ) ; <NEW_LINE>if ( header == NULL ) { <NEW_LINE>return BAD_VALUE ; <NEW_LINE> } <NEW_LINE>
memmove ( dp , cpi -> partition_d [ i + 1 ] , cpi -> partition_sz [ i + 1 ] ) ; <NEW_LINE>
if ( r && ! file_out ) <NEW_LINE>
referrerPolicy = document -> getReferrerPolicy ( ) ; <NEW_LINE>
struct minidump_directory entry ; <NEW_LINE>
#if defined ( __LP64__ ) && ! defined ( __OpenBSD__ ) && ! defined ( __APPLE__ ) <NEW_LINE>typedef unsigned long uint64 ; <NEW_LINE>typedef long int64 ; <NEW_LINE>
std::cout << " GenerateWord32 and Crop\n" ;
void * H264SwDecMalloc ( u32 size , u32 num ) { <NEW_LINE>if ( size > UINT32_MAX / num ) { <NEW_LINE>ALOGE ( "can't allocate % u * % u bytes" , size , num ) ; <NEW_LINE>android_errorWriteLog ( 0x534e4554 , "27855419" ) ; <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE>return malloc ( size * num ) ; <NEW_LINE>
std::map < std::string , std::string > varyingLongNameMap ; <NEW_LINE>
if ( len < 5 || p [ 0 ] != 0x80 || p [ 1 ] != 0x01 ) { <NEW_LINE>
& nparams , & units , & params ) != 0 ) <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
double correction_factor , vpx_bit_depth_t bit_depth ) ; <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
<NEW_LINE>
kiocb_batch_free ( ctx , & batch ) ; <NEW_LINE>
wcsncpy ( destinationBuffer , siblingFilePath , MAX_PATH ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
void vp9_init_intra_predictors ( void ) ; <NEW_LINE><NEW_LINE>void vp9_predict_intra_block ( const MACROBLOCKD * xd , int bwl_in , <NEW_LINE>TX_SIZE tx_size , PREDICTION_MODE mode , <NEW_LINE>
mThisObjects . clear ( ) ; <NEW_LINE>
nsTArray < nsCOMPtr < nsIDOMNode > > textNodes ; <NEW_LINE>
state -> indent = fstrndup ( RSTRING_PTR ( indent ) , len ) ; <NEW_LINE>
CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ; <NEW_LINE>
class LockImpl { <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , addr ) ; <NEW_LINE>
im -> alphaBlendingFlag = alphablending_bak ; <NEW_LINE>
if ( image -> mDecoder && image -> IsDecodeFinished ( ) ) { <NEW_LINE>
class WebPluginResourceClient ; <NEW_LINE>
<NEW_LINE>utf8 . resize ( utf8Length + 1 ) ; <NEW_LINE>utf16_to_utf8 ( utf16 . data ( ) , utf16 . length ( ) , & * utf8 . begin ( ) , utf8Length + 1 ) ; <NEW_LINE>
if ( ( png_ptr -> flags & PNG_FLAG_ZSTREAM_INITIALIZED ) != 0 ) <NEW_LINE>
if ( equalIgnoringASCIICase ( child -> getAttribute ( aria_hiddenAttr ) , "true" ) ) <NEW_LINE>
if ( ! iph || iph -> ihl < 5 ) <NEW_LINE>
<NEW_LINE>
TRACK_RUN_IN_THIS_SCOPED_REGION ( member_func ) ; \ <NEW_LINE>
if ( snprintf ( pattern , 499 , " . / test / schemas / % s_ ? . xml" , prefix ) >= 499 ) <NEW_LINE>pattern [ 499 ] = 0 ; <NEW_LINE>
<NEW_LINE>
#ifndef BASE_MAC_COCOA_PROTOCOLS_H_ <NEW_LINE>#define BASE_MAC_COCOA_PROTOCOLS_H_ <NEW_LINE>
bool & isvalid , CryptoKey & session_key , <NEW_LINE>std::unique_ptr < AuthAuthorizerChallenge > * challenge ) override { <NEW_LINE>
const PropertyTreeState & new_chunk_state , <NEW_LINE>
static void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <NEW_LINE>
mpz_powm_sec ( v , v , key -> d , key -> n ) ; <NEW_LINE>
if ( pTrack -> GetType ( ) == 2 ) {
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED ( DOMCursor , <NEW_LINE>DOMRequest ) <NEW_LINE>
void ( * mCopy ) ( short * dst , const int * src [ kMaxChannels ] , unsigned nSamples , unsigned nChannels ) ; <NEW_LINE>
if ( ( fd = _open_as_other ( path_name , req ) ) == - 1 ) { <NEW_LINE>error ( "Unable to open % s: Permission denied" , path_name ) ; <NEW_LINE>
void CVE_2015_4001_oz_hcd_get_desc_cnf ( void * hport , u8 req_id , u8 status , const u8 * desc , <NEW_LINE>u8 length , u16 offset , u16 total_size ) <NEW_LINE>
int hexdump , ret ; <NEW_LINE>
size_t ini_entries_len = 0 ; <NEW_LINE>
if ( memcmp ( chunk_name , p , 4 ) == 0 ) <NEW_LINE>
xmlGenericError , xmlGenericError , NULL ) ; <NEW_LINE>
#line 600 "ext / standard / var_unserializer . re" <NEW_LINE>
#endif <NEW_LINE>
int number_of_frames ; <NEW_LINE>
bool WriteEbmlElement ( IMkvWriter * writer , uint64 type , const uint8 * value , <NEW_LINE>
unsigned int mbs_zero_last_dot_suppress ; <NEW_LINE>int zero_last_dot_suppress ; <NEW_LINE>
n = TEMP_FAILURE_RETRY ( recv ( fd , p_buf + n_read , len - n_read , 0 ) ) ;
, m_originalSlimmingPaintSubsequenceCachingEnabled ( RuntimeEnabledFeatures::slimmingPaintSubsequenceCachingEnabled ( ) ) <NEW_LINE> , m_originalSlimmingPaintV2Enabled ( RuntimeEnabledFeatures::slimmingPaintV2Enabled ( ) ) { } <NEW_LINE>
jas_uchar buf [ JPG_MAGICLEN ] ; <NEW_LINE>
static LPCWSTR delayDLLs [ ] = { L"wsock32 . dll" , L"crypt32 . dll" , <NEW_LINE>L"cryptsp . dll" , L"cryptbase . dll" , <NEW_LINE>L"msasn1 . dll" , L"userenv . dll" , <NEW_LINE>L"secur32 . dll" } ; <NEW_LINE><NEW_LINE>
while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) <NEW_LINE> && ! EXCEED_OFFSET ( ps_bitstrm ) ) <NEW_LINE>
if ( compressed == 0 ) <NEW_LINE>
<NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
tmp = parse_code & 0x03 ; <NEW_LINE>if ( tmp > 2 ) { <NEW_LINE>av_log ( avctx , AV_LOG_ERROR , "num_refs of 3\n" ) ; <NEW_LINE>return - 1 ; <NEW_LINE> } <NEW_LINE>s -> num_refs = tmp ; <NEW_LINE>
pp::TokenVector * out = context -> output ( ) ; <NEW_LINE>
#include "platform / mediastream / MediaStreamSource . h" <NEW_LINE>
xmlFreeDocElementContent ( ctxt -> myDoc , ret ) ; <NEW_LINE>
keep = png_chunk_unknown_handling ( png_ptr , png_ptr -> chunk_name ) ; <NEW_LINE>
mod_loc_name = estrdup ( loc_name ) ; <NEW_LINE>
if ( avctx -> codec && avctx -> codec -> close && <NEW_LINE>
<NEW_LINE>
dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ; <NEW_LINE>
void AddHealthz ( const std::string & pattern ) ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>void AddLog ( const std::string & pattern ) ;
if ( ( int ) g -> sect <= 0 || <NEW_LINE> ( int ) g -> head <= 0 || <NEW_LINE><NEW_LINE> ( int ) ( g -> sect * g -> head ) <= 0 || <NEW_LINE>
mprWriteJson ( route -> config , sfmt ( "dependencies . % s" , name ) , version ) ; <NEW_LINE>
nsCOMPtr < nsPIDOMWindow > mWindow ; <NEW_LINE>
void NavigateBackForwardSoon ( int offset , bool has_user_gesture ) override ; <NEW_LINE>
std::string name_ ; <NEW_LINE>
return ( tp -> bs_name ) ; <NEW_LINE>
if ( ( PRUint64 ) capacity * elemSize > size_type ( - 1 ) / 2 ) { <NEW_LINE>
if ( ! int_port || ! rem_port || ! protocol ) <NEW_LINE>
option = ssplit ( option , " = \t , " , & ovalue ) ; <NEW_LINE>
nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE>
if ( m_frame -> loader ( ) -> stateMachine ( ) -> isDisplayingInitialEmptyDocument ( ) ) <NEW_LINE>m_frame -> loader ( ) -> didAccessInitialDocument ( ) ; <NEW_LINE><NEW_LINE>v8::Context::Scope scope ( v8Context ) ; <NEW_LINE>
isoclns_print ( ndo , p , length ) ; <NEW_LINE>
if ( TEMP_FAILURE_RETRY ( poll ( & ufd , 1 , 0 ) ) <= 0 || IS_EXCEPTION ( ufd . revents ) ) <NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_INVERT_MONO ) != 0 ) <NEW_LINE>
#ifndef BASE_SEQUENCED_TASK_RUNNER_H_ <NEW_LINE>#define BASE_SEQUENCED_TASK_RUNNER_H_ <NEW_LINE>
if ( currChild -> isFloating ( ) || currChild -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
file_fmttime ( p -> q + m -> num_mask , FILE_T_LOCAL , tbuf ) ) == - 1 ) <NEW_LINE>
#define VTP_VLAN_INFO_FIXED_PART_LEN	12	 <NEW_LINE>
"zlib@openssh . com , none" : "none , zlib@openssh . com" ; <NEW_LINE>
class OffscreenCanvasSurfaceImpl : public blink::mojom::OffscreenCanvasSurface { <NEW_LINE>
994 , 1007 , 1018 , 1024 , 1054 , 1023 , 1168 , 1167 , 1246 , 1252 , <NEW_LINE>1259 , 1258 , 1321 , 1320 , 1381 , 1390 , 1399 , 1408 , 1417 , 1426 , <NEW_LINE>1435 , 1439 , 1447 , 1448 , 1453 , 1475 , 1487 , 1503 , 1502 , 1508 , <NEW_LINE>1519 , 1520 , 1525 , 1532 , 1543 , 1544 , 1548 , 1556 , 1560 , 1570 , <NEW_LINE>1584 , 1600 , 1610 , 1619 , 1644 , 1656 , 1668 , 1684 , 1696 , 1712 , <NEW_LINE>1757 , 1776 , 1794 , 1812 , 1830 , 1856 , 1874 , 1884 , 1894 , 1904 , <NEW_LINE>1914 , 1924 , 1934 <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
ND_TCHECK ( * dp ) ; <NEW_LINE>
cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ; <NEW_LINE>if ( cp == NULL ) { <NEW_LINE>ND_PRINT ( ( ndo , " ) " ) ) ; <NEW_LINE>goto trunc ; <NEW_LINE> } <NEW_LINE>
unsigned imageRowBytes ) { <NEW_LINE>
int open_debug_log ( void ) <NEW_LINE> { <NEW_LINE>int fh ; <NEW_LINE>struct stat st ; <NEW_LINE>
virtual status_t dumpClient ( int fd , const Vector < String16 > & args ) ;
TPM_RC tpm_kdfa ( TPMI_ALG_HASH hashAlg , <NEW_LINE>
probes::ExitScript ( cx , script , script -> function ( ) , hasPushedSPSFrame ( ) ) ; <NEW_LINE>
if ( diff . needsRepaint ( ) ) { <NEW_LINE>
strncpy ( rpcomp . type , "pcomp" , sizeof ( rpcomp . type ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>static LPCWSTR delayDLLs [ ] = { L"profapi . dll" , L"wsock32 . dll" , <NEW_LINE>L"crypt32 . dll" , L"cryptsp . dll" , <NEW_LINE>L"cryptbase . dll" , L"msasn1 . dll" , <NEW_LINE>L"userenv . dll" , L"secur32 . dll" , <NEW_LINE>L"ws2_32 . dll" , L"ws2help . dll" , <NEW_LINE>L"apphelp . dll" , L"bcryptprimitives . dll" } ; <NEW_LINE>
base_path = " / tmp" ; <NEW_LINE>
page -> GetChromeClient ( ) . Focus ( nullptr ) ; <NEW_LINE>
<NEW_LINE>if ( ! ::JS_DefineProperty ( cx , class_obj , "prototype" , v , nsnull , nsnull , <NEW_LINE>JSPROP_PERMANENT | JSPROP_READONLY ) ) { <NEW_LINE>
uint32 nstrips ; <NEW_LINE>
static int XBMInteger ( Image * image , short int * hex_digits ) <NEW_LINE>
verbose ( env , "\nfrom % d to % d % s: safe\n" , <NEW_LINE>env -> prev_insn_idx , env -> insn_idx , <NEW_LINE>env -> cur_state -> speculative ? <NEW_LINE>" ( speculative execution ) " : "" ) ; <NEW_LINE>
#define MODULE_MAGIC_NUMBER_MINOR 3
if ( png_ptr != NULL && info_ptr != NULL && <NEW_LINE> ( info_ptr -> valid & PNG_INFO_pHYs ) != 0 ) <NEW_LINE>
if ( ! curr -> isFloatingOrOutOfFlowPositioned ( ) ) { <NEW_LINE>
output [ subpatternId << 1 ] = input . getPos ( ) + term . inputPosition ; <NEW_LINE>
float * qA , float * qB ) { <NEW_LINE>
( webgl_version_ > kWebGL1 || <NEW_LINE>
( void ) SetImageType ( image , BilevelType ) ; <NEW_LINE>
v8::Local < v8::Value > location = generatorObjectLocation ( context , v8::Local < v8::Object > ::Cast ( value ) ) ; <NEW_LINE>
if ( CanDiscard ( ) && ! mDecoder && ! mAnim ) { <NEW_LINE>
bool setDecodeArgs ( ivd_video_decode_ip_t * ps_dec_ip , <NEW_LINE>
if ( ( stok ( value , " } " , & cp ) ) == 0 ) { <NEW_LINE>continue ; <NEW_LINE> } <NEW_LINE>
bool <NEW_LINE>
<NEW_LINE>if ( ! lhs -> canBeNaN ( ) || ! rhs -> canBeNaN ( ) ) <NEW_LINE> * emptyRange = true ; <NEW_LINE>
if ( ! nsHttp::IsValidToken ( flatHeader ) ) <NEW_LINE>
class VP8Picture : public base::RefCountedThreadSafe < VP8Picture > { <NEW_LINE>
<NEW_LINE>if ( ! mProcessStyle || keyAtom != nsGkAtoms::style ) { <NEW_LINE>continue ; <NEW_LINE> } <NEW_LINE>
mDecodingMonitor . AssertCurrentThreadIn ( ) ; <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
#endif
if ( ( location & PNG_HAVE_IDAT ) != 0 ) <NEW_LINE>
return ntohl ( daddr -> a4 + saddr -> a4 ) ; <NEW_LINE>
ret = TEMP_FAILURE_RETRY ( poll ( pfds , 1 , 50 ) ) ; <NEW_LINE>
ObjectValueMap::Ptr ptr = weakmap -> map . lookup ( key ) ; <NEW_LINE>
smart_str_appendl ( & out_buf , pos , 1 ) ; <NEW_LINE>
( png_ptr -> flags & PNG_FLAG_ZSTREAM_ENDED ) == 0 ) <NEW_LINE>
if ( png_crc_finish ( png_ptr , 0 ) != 0 ) <NEW_LINE>
if ( png_sRGB_checks [ i ] . is_broken != 0 ) <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
NS_IF_RELEASE ( sContent ) ; <NEW_LINE>
if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) <NEW_LINE>
bool & isvalid , CryptoKey & session_key , <NEW_LINE>std::unique_ptr < AuthAuthorizerChallenge > * challenge ) override ; <NEW_LINE>
if ( STATE_FIRST_CALL == mState && * aSrcLength < 2 ) <NEW_LINE> { <NEW_LINE>nsresult res = ( * aSrcLength == 0 ) ? NS_OK : NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> * aSrcLength = 0 ; <NEW_LINE> * aDestLength = 0 ; <NEW_LINE>return res ; <NEW_LINE> } <NEW_LINE>
gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; <NEW_LINE>gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ; <NEW_LINE>
<NEW_LINE>SINGLE_AND_MULTI_THREAD_TEST_F ( CCLayerTreeHostTestShortlived3 ) <NEW_LINE>
AutoPushJSContext cx ( sc -> GetNativeContext ( ) ) ; <NEW_LINE>
png_ptr = png_create_read_struct ( png_get_libpng_ver ( NULL ) , <NEW_LINE>
JSObject * out_obj = NewOutObject ( cx , obj ) ; <NEW_LINE>
AutoPushJSContext cx ( mScriptContext -> GetNativeContext ( ) ) ; <NEW_LINE>
# endif <NEW_LINE>
row_copy ( png_bytep toBuffer , png_const_bytep fromBuffer , unsigned int bitWidth , <NEW_LINE>int littleendian ) <NEW_LINE>
info , inliningDepth_ + 1 , loopDepth_ ) ; <NEW_LINE>
nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE>
memset ( ( & oci -> post_proc_buffer_int ) -> buffer_alloc , 128 , ( & oci -> post_proc_buffer ) -> frame_size ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>ASH_EXPORT constexpr int kShelfTranslucentMaximizedWindow = 254 ;
const char * dbname ; <NEW_LINE>
v_fn_ptr . vf = vpx_mse16x16 ; <NEW_LINE>
TEMP_FAILURE_RETRY ( usleep ( 10000 ) ) ; <NEW_LINE>
buffer = zend_string_safe_alloc ( 1 , len , 0 , 0 ) ; <NEW_LINE>
for ( i = 0 ; i < ( ssize_t ) number_channels ; i ++ ) <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
vpx_decrypt_cb decrypt_cb , <NEW_LINE>
RD_BOOL ber_parse_header ( STREAM s , int tagval , uint32 * length ) ; <NEW_LINE>
uint64 payload_size = EbmlElementSize ( kMkvChapterStringUID , id_ ) + <NEW_LINE>EbmlElementSize ( kMkvChapterUID , uid_ ) + <NEW_LINE>EbmlElementSize ( kMkvChapterTimeStart , start_timecode_ ) + <NEW_LINE>EbmlElementSize ( kMkvChapterTimeEnd , end_timecode_ ) ; <NEW_LINE>
Microtask::performCheckpoint ( V8PerIsolateData::mainThreadIsolate ( ) ) ; <NEW_LINE>
static BOOL nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <NEW_LINE>
IDBObjectStore::ClearCloneWriteInfo ( mCloneWriteInfo ) ; <NEW_LINE>
if ( equalIgnoringASCIICase ( ariaSelected , "true" ) ) <NEW_LINE>
int notify_id ) ; <NEW_LINE>
if ( ( b -> opts & ACCUMULATE ) == 0 ) <NEW_LINE>
nsStyleLinkElement::SetStyleSheet ( nsnull ) ; <NEW_LINE>
. SetShouldShowHandle ( IsHandleVisible ( ) ) <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>auto resolver_cb = WTF::Bind ( <NEW_LINE> & ImageCapture::ResolveWithMediaTrackConstraints , WrapPersistent ( this ) , <NEW_LINE>ScriptValue::From ( resolver -> GetScriptState ( ) , resolver_constraints ) ) ; <NEW_LINE>
if ( length < 2U || entry_start > buffer + ( length - 2U ) ) <NEW_LINE>
m . command = CMD_NONE ; <NEW_LINE>
<NEW_LINE><NEW_LINE>rd_variance_adjustment ( cpi , x , bsize , & this_rd , <NEW_LINE>ref_frame , x -> source_variance ) ; <NEW_LINE><NEW_LINE>
JS_ASSERT_IF ( is_short , isFixed ( ) ) ; <NEW_LINE>
{ 0x0000a7b4 , FC_CASE_FOLD_EVEN_ODD , 0x0003 , 1 } , <NEW_LINE>
if ( ( state & PNG_FP_SAW_ANY ) != 0 ) <NEW_LINE>
mountflags | MS_REMOUNT , data ) < 0 ) { <NEW_LINE>
bufp += stripsize ; <NEW_LINE>
cJSON_AddNumberToObject ( j_stream , "id" , sp -> id ) ; <NEW_LINE>cJSON_AddNumberToObject ( j_stream , "bytes" , bytes_transferred ) ; <NEW_LINE>cJSON_AddNumberToObject ( j_stream , "retransmits" , retransmits ) ; <NEW_LINE>cJSON_AddNumberToObject ( j_stream , "jitter" , sp -> jitter ) ; <NEW_LINE>cJSON_AddNumberToObject ( j_stream , "errors" , sp -> cnt_error ) ; <NEW_LINE>cJSON_AddNumberToObject ( j_stream , "packets" , sp -> packet_count ) ; <NEW_LINE>
} else if ( tga -> bits == TGA_BPP_32 && tga -> alphabits ) { <NEW_LINE>
vpx_prob ref_comp_p = vp9_get_pred_prob_comp_ref_p ( cm , xd ) ; <NEW_LINE>
AutoCompartment ac ( cx , cx -> asJSContext ( ) -> runtime ( ) -> atomsCompartment ) ; <NEW_LINE>
static int fsmVerify ( const char * path , rpmfi fi , const struct stat * fsb ) <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( 1 + 2 + 16 > s -> s3 -> rrec . length ) <NEW_LINE>return 0 ; <NEW_LINE>hbtype = * p ++ ; <NEW_LINE>n2s ( p , payload ) ; <NEW_LINE>if ( 1 + 2 + payload + 16 > s -> s3 -> rrec . length ) <NEW_LINE>return 0 ; <NEW_LINE>pl = p ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
RawString str = buf . finishString ( ) ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
result = append_key_value ( loc_name , hash_arr , LOC_GRANDFATHERED_LANG_TAG ) ; <NEW_LINE>
entry_seen = 1 ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( entry_seen ) <NEW_LINE>return ( ARCHIVE_OK ) ; <NEW_LINE>else { <NEW_LINE>archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , <NEW_LINE>"Tried to parse Rockridge extensions , but none found" ) ; <NEW_LINE>return ( ARCHIVE_WARN ) ; <NEW_LINE>
conn -> m -> local_tx_end ( conn , this_func , result == NULL ? FAIL:PASS TSRMLS_CC ) ; <NEW_LINE>
MakeContinuationsNonFluidUpParentChain ( lastFrame , lastFrame -> GetNextInFlow ( ) ) ; <NEW_LINE>
static void _perf_event_enable ( struct perf_event * event ) <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( effect_config_t ) ) { <NEW_LINE>
if ( ! mIsSystemXHR && <NEW_LINE>
"An argument must be provided , which must be a " <NEW_LINE>
StackTypeSet * calleeTypes = poppedTypes ( pc , argCount + 1 ) ; <NEW_LINE><NEW_LINE><NEW_LINE>SSAValue calleeValue = poppedValue ( pc , argCount + 1 ) ; <NEW_LINE>if ( * pc != JSOP_NEW && <NEW_LINE> ( calleeValue . kind ( ) != SSAValue::PUSHED || <NEW_LINE>script -> code [ calleeValue . pushedOffset ( ) ] != JSOP_CALLPROP ) ) <NEW_LINE> { <NEW_LINE>HandleScript script_ = script ; <NEW_LINE>calleeTypes -> add ( cx , cx -> analysisLifoAlloc ( ) . new_ < TypeConstraintPropagateThis > <NEW_LINE> ( script_ , pc , Type::UndefinedType ( ) , callsite -> thisTypes ) ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>calleeTypes -> addCall ( cx , callsite ) ; <NEW_LINE>
<NEW_LINE>#define MAXDATELEN		128 <NEW_LINE><NEW_LINE>#define MAXDATEFIELDS	25 <NEW_LINE><NEW_LINE>#define TOKMAXLEN		10 <NEW_LINE>
mSelfURI , <NEW_LINE>
return toGlobalRef ( coreFrame -> script ( ) -> globalObject ( mainThreadNormalWorld ( ) ) -> globalExec ( ) ) ; <NEW_LINE>
PNG_UNUSED ( text ) <NEW_LINE>
#define HSM_FM_SCK_PREFIX	" / opt / opafm / "
if ( ! V8ScriptRunner::callInternalFunction ( v8::Local < v8::Function > ::Cast ( getter ) , holder , 0 , 0 , isolate ) . ToLocal ( & result ) ) { <NEW_LINE>
return ERROR_INV_SLICE_HDR_T ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>trust_data . dwUIChoice = WTD_UI_NONE ; <NEW_LINE>
void LayoutSVGTransformableContainer::setNeedsTransformUpdate ( ) <NEW_LINE> { <NEW_LINE>setMayNeedPaintInvalidationSubtree ( ) ; <NEW_LINE>m_needsTransformUpdate = true ; <NEW_LINE> } <NEW_LINE><NEW_LINE>static std::pair < double , double > scaleReference ( const AffineTransform & transform ) <NEW_LINE> { <NEW_LINE>return std::make_pair ( transform . xScaleSquared ( ) , transform . yScaleSquared ( ) ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>LayoutSVGContainer::TransformChange LayoutSVGTransformableContainer::calculateLocalTransform ( ) <NEW_LINE>
const CSSPropertyID propertyID = hashTableEntry ? static_cast < CSSPropertyID > ( hashTableEntry -> id ) : CSSPropertyInvalid ; <NEW_LINE><NEW_LINE><NEW_LINE>static const int CSSPropertyHistogramSize = 600 ; <NEW_LINE>COMPILE_ASSERT ( CSSPropertyHistogramSize > numCSSProperties , number_of_css_properties_exceed_CSSPropertyHistogramSize ) ; <NEW_LINE><NEW_LINE>if ( hasPrefix ( buffer , length , " - webkit - " ) && propertyID != CSSPropertyInvalid ) <NEW_LINE>HistogramSupport::histogramEnumeration ( "CSS . PrefixUsage" , max ( 1 , propertyID - firstCSSProperty ) , CSSPropertyHistogramSize ) ; <NEW_LINE><NEW_LINE>return propertyID ; <NEW_LINE>
MakeContextCurrent ( ) ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>bool sizeChanges = width != mBoundRenderbuffer -> width ( ) || <NEW_LINE>height != mBoundRenderbuffer -> height ( ) || <NEW_LINE>internalformat != mBoundRenderbuffer -> InternalFormat ( ) ; <NEW_LINE>if ( sizeChanges ) { <NEW_LINE>UpdateWebGLErrorAndClearGLError ( ) ; <NEW_LINE>gl -> fRenderbufferStorage ( target , internalformatForGL , width , height ) ; <NEW_LINE>GLenum error = LOCAL_GL_NO_ERROR ; <NEW_LINE>UpdateWebGLErrorAndClearGLError ( & error ) ; <NEW_LINE>if ( error ) { <NEW_LINE>LogMessageIfVerbose ( "bufferData generated error % s" , ErrorName ( error ) ) ; <NEW_LINE>return NS_OK ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE>gl -> fRenderbufferStorage ( target , internalformatForGL , width , height ) ; <NEW_LINE> } <NEW_LINE>
dom::Uint8ClampedArray * aArray , <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
if ( principal == systemPrincipal ) { <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>return PR_FALSE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
#line 5642 "dcraw / dcraw . c" <NEW_LINE>
sp < Sample > sample ( findSample_l ( sampleID ) ) ; <NEW_LINE>
SSLErrorHandler ( const base::WeakPtr < Delegate > & delegate , <NEW_LINE>
( void ) WriteBlobByte ( image , ( unsigned char ) ( ( 31 * transpix . red ) / <NEW_LINE>QuantumRange ) ) ; <NEW_LINE> ( void ) WriteBlobByte ( image , ( unsigned char ) ( ( 63 * transpix . green ) / <NEW_LINE>QuantumRange ) ) ; <NEW_LINE> ( void ) WriteBlobByte ( image , ( unsigned char ) ( ( 31 * transpix . blue ) / <NEW_LINE>QuantumRange ) ) ; <NEW_LINE>
if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' && <NEW_LINE>strcmp ( conn_opt -> keyword , "dbname" ) != 0 ) <NEW_LINE>
if ( png_get_gAMA_fixed ( read_ptr , read_info_ptr , & gamma ) != 0 ) <NEW_LINE>
RefPtr < { { attribute . idl_type } } > imp = WTF::getPtr ( proxyImp -> { { attribute . name } } ( ) ) ; <NEW_LINE>
const vpx_prob * context_tree , <NEW_LINE>
const char * passname [ ] = { "HCD" , "HUB" , "GEN" , "DEV" , "EXT" } ; <NEW_LINE>usbi_dbg ( "\n#### PROCESSING % ss % s" , passname [ ( pass <= DEV_PASS ) ? pass:DEV_PASS + 1 ] , <NEW_LINE>
nsIContent * content = mElements [ i ] ; <NEW_LINE>
const char * path , const char * rootfs ) <NEW_LINE>
perf_swevent_event ( event , count , & data , regs ) ; <NEW_LINE>
<NEW_LINE>FireDOMEvent ( NS_LITERAL_STRING ( "DOMMenuItemActive" ) , mPresContext , mContent ) ; <NEW_LINE>
for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) <NEW_LINE>
} else if ( strcmp ( tokens [ 1 ] . value , "mode" ) == 0 && ntokens >= 4 && <NEW_LINE>
if ( vorbis_synthesis_init ( & fsv -> vd , & fsv -> vi ) != 0 ) <NEW_LINE>return - 1 ; <NEW_LINE><NEW_LINE>if ( vorbis_block_init ( & fsv -> vd , & fsv -> vb ) != 0 ) <NEW_LINE>return - 1 ; <NEW_LINE>
_wfopen_s ( & fp , path , L"rb" ) ; <NEW_LINE>
switch ( point . state ( ) ) { <NEW_LINE>
if ( aSampleRate < WebAudioUtils::MinSampleRate || <NEW_LINE>aSampleRate > WebAudioUtils::MaxSampleRate || <NEW_LINE> ! aLength || ! aNumberOfChannels ) { <NEW_LINE>
int hs = ci -> halfrate_flag ; <NEW_LINE><NEW_LINE>
<NEW_LINE>
rt -> gcFinalizeCallback ( & fop , JSFINALIZE_END , ! isFull ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
cluster = new ( std::nothrow ) Cluster ( cluster_timecode , <NEW_LINE>offset , segment_info_ . timecode_scale ( ) ) ; <NEW_LINE>
#include "vpx_dsp / variance . h" <NEW_LINE>
mColormapSize = sizeof ( PRUint32 ) << depth ; <NEW_LINE>
if ( use_accept4 ) { <NEW_LINE>s = accept4 ( lc -> fd , ( struct sockaddr * ) sa , & socklen , <NEW_LINE>SOCK_NONBLOCK ) ; <NEW_LINE> } else { <NEW_LINE>s = accept ( lc -> fd , ( struct sockaddr * ) sa , & socklen ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>
DECLARE_ALIGNED ( 16 , unsigned short , FData2 [ 24 * 24 ] ) ; <NEW_LINE>
phar_file_stat ( filename , filename_len , funcnum , PHAR_G ( orig ) , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; \ <NEW_LINE>
snprintf ( str , sizeof ( str ) , " { v % i . . v % i } , [ % 04x ] " , vC , vC + vA - 1 , vB ) ; <NEW_LINE>
mTabWidths = new TabWidthStore ( mFrame -> GetContentOffset ( ) ) ; <NEW_LINE>
else if ( png_sRGB_checks [ i ] . have_md5 == 0 ) <NEW_LINE>
if ( ptr_hbe_txposer -> ixheaacd_real_synth_fft != NULL ) <NEW_LINE> ( * ( ptr_hbe_txposer -> ixheaacd_real_synth_fft ) ) ( synth_buf_r , synth_out , <NEW_LINE>synth_size * 2 ) ; <NEW_LINE>
if ( isOutOfFlowPositioned ( ) ) <NEW_LINE>
if ( ! tps . repushBlock ( cx , cg ) ) <NEW_LINE>return JS_FALSE ; <NEW_LINE><NEW_LINE><NEW_LINE>stmtInfo -> update = top = CG_OFFSET ( cg ) ; <NEW_LINE>
jas_uchar buf [ 2 ] ; <NEW_LINE>
<NEW_LINE>setup_new_exec ( bprm ) ; <NEW_LINE>
<NEW_LINE>if ( len + 15 > dev -> mtu ) { <NEW_LINE>mutex_unlock ( & econet_mutex ) ; <NEW_LINE>return - EMSGSIZE ; <NEW_LINE> } <NEW_LINE>
if ( ps_dec -> u4_first_slice_in_pic ) <NEW_LINE>
memcpy ( dst , src , src_ybc -> uv_width ) ; <NEW_LINE>
ret = TEMP_FAILURE_RETRY ( read ( p_dev -> fd , & ev , sizeof ( ev ) ) ) ; <NEW_LINE>
if ( ! ( renderer -> isOutOfFlowPositioned ( ) && renderer -> style ( ) -> position ( ) == FixedPosition && layer -> isStackingContext ( ) ) ) <NEW_LINE>
XPCVariant ( XPCCallContext & ccx , jsval aJSVal ) ; <NEW_LINE>var div = $ ( 'content' ) ; <NEW_LINE>var obj = { } ; <NEW_LINE>div . setUserData ( "foopy" , obj , function ( ) { } ) ; <NEW_LINE>ok ( div . getUserData ( "foopy" ) == = obj , "getUserData works with regular objects" ) ; <NEW_LINE>div . setUserData ( "foopy1" , sidebar , function ( ) { } ) ; <NEW_LINE>ok ( div . getUserData ( "foopy1" ) == = sidebar , "getUserData works with bizarre objects" ) ; <NEW_LINE><NEW_LINE> < / script > <NEW_LINE> < / pre > <NEW_LINE> < / body > <NEW_LINE> < / html >
if ( NS_FAILED ( rv ) || ! canExecute ) { <NEW_LINE>return PR_FALSE ; <NEW_LINE> } <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>PRBool haveCert ; <NEW_LINE>doc -> NodePrincipal ( ) -> GetHasCertificate ( & haveCert ) ; <NEW_LINE>if ( ! haveCert ) { <NEW_LINE>return PR_TRUE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>PRBool subsumes ; <NEW_LINE>rv = ourDocument -> NodePrincipal ( ) -> Subsumes ( doc -> NodePrincipal ( ) , & subsumes ) ; <NEW_LINE>return NS_SUCCEEDED ( rv ) && subsumes ; <NEW_LINE>
if ( ! fmtint ( sbuffer , buffer , & currlen , maxlen , value , 10 , min , <NEW_LINE>max , flags ) ) <NEW_LINE>return 0 ; <NEW_LINE>
NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS ( nsCanvasRenderingContext2D , nsIDOMCanvasRenderingContext2D ) <NEW_LINE>NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS ( nsCanvasRenderingContext2D , nsIDOMCanvasRenderingContext2D ) <NEW_LINE><NEW_LINE>NS_IMPL_CYCLE_COLLECTION_CLASS ( nsCanvasRenderingContext2D ) <NEW_LINE>NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN ( nsCanvasRenderingContext2D ) <NEW_LINE>NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR ( mCanvasElement ) <NEW_LINE>NS_IMPL_CYCLE_COLLECTION_UNLINK_END <NEW_LINE>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN ( nsCanvasRenderingContext2D ) <NEW_LINE>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR ( mCanvasElement ) <NEW_LINE>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END <NEW_LINE><NEW_LINE>NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION ( nsCanvasRenderingContext2D ) <NEW_LINE>
if ( ( zone -> allocator . arenas . arenaListsAreEmpty ( ) && ! zone -> hasMarkedCompartments ( ) ) || <NEW_LINE>lastGC ) <NEW_LINE> { <NEW_LINE>
if ( pixel_pack_parameters_dirty_ ) <NEW_LINE>client -> DrawingBufferClientRestorePixelPackParameters ( ) ; <NEW_LINE>
fprintf ( fp , " % s % s\n" , certificate_data -> hostname , certificate_data -> fingerprint ) ; <NEW_LINE>
virtual bool GetURLAndTitle ( OSExchangeData::FilenameToURLPolicy policy , <NEW_LINE>GURL * url , <NEW_LINE>base::string16 * title ) const OVERRIDE ; <NEW_LINE>
NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * kdelegate , void * val ) { } <NEW_LINE>
__android_log_print ( ANDROID_LOG_INFO , "Gecko" , " % s" , NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) ) ; <NEW_LINE>
rv = pushPtr ( const_cast < txElementHandler * > ( handler ) , eElementHandler ) ; <NEW_LINE>
newinet -> inet_opt = NULL ; <NEW_LINE>
else if ( ( ( void ( * ) ( void ) ) channel == ( void ( * ) ( void ) ) fprintf ) || <NEW_LINE>
return object -> isText ( ) || object -> isFloating ( ) || object -> isOutOfFlowPositioned ( ) || object -> isReplaced ( ) ; <NEW_LINE>
const ScrollPaintPropertyNode * ScrollNode ( ) const { return state_ . scroll ; }
unsigned int tmp = * sp & ( 0x0f0f >> ( 4 - shift ) ) ; <NEW_LINE>
void start ( WebPage * initiatingWebPage ) ; <NEW_LINE>
ND_PRINT ( ( ndo , " % s" , rpl_tstr ) ) ; <NEW_LINE>
aPrincipal , uriSpec . get ( ) , <NEW_LINE>
PHPAPI ulong <NEW_LINE>
php_array_replace_recursive ( seen , couldRecur ( v , subarr1 ) , <NEW_LINE>subarr1 , arr_value ) ; <NEW_LINE>
strncpy ( tmpf , argv [ c ] , sizeof ( tmpf ) - 1 ) ; <NEW_LINE>
<NEW_LINE>
xmlBufResetInput ( ctxt -> input -> buf -> buffer , ctxt -> input ) ; <NEW_LINE>
clone_info -> stroke . alpha = ( MagickRealType ) TransparentAlpha ; <NEW_LINE>
nsCOMPtr < nsIEditor_MOZILLA_2_0_BRANCH > editor20 = do_QueryInterface ( editor ) ; <NEW_LINE>NS_ASSERTION ( editor20 , "Something is very wrong ! " ) ; <NEW_LINE>PRBool trusted = PR_FALSE ; <NEW_LINE>editor20 -> GetLastKeypressEventTrusted ( & trusted ) ; <NEW_LINE>mFrame -> FireOnInput ( trusted ) ; <NEW_LINE>
#endif <NEW_LINE>
if ( toHTMLElement ( this ) -> highestAncestor ( ) == formRoot ) <NEW_LINE>return ; <NEW_LINE>RefPtr < HTMLElement > protector ( toHTMLElement ( this ) ) ; <NEW_LINE>setForm ( 0 ) ; <NEW_LINE>
memcpy ( & pi , nbuf + doff , MIN ( descsz , sizeof ( pi ) ) ) ; <NEW_LINE>
MOZ_ASSERT ( js::IsObjectInContextCompartment ( scope , ctx ) ) ; <NEW_LINE>
ret = safe_mount ( path , destpath , "none" , MS_BIND , NULL , conf -> rootfs . mount ) ; <NEW_LINE>
if ( newContent -> GetParentNode ( ) ) { <NEW_LINE>
jas_uchar * buf_ ; <NEW_LINE>
const lua_authz_provider_func * prov_func = parsed_require_line ; <NEW_LINE>const lua_authz_provider_spec * prov_spec = prov_func -> spec ; <NEW_LINE>
if ( ! ac . enter ( ccx , existingJSObject ) ) { <NEW_LINE>wrapper -> mIdentity = nsnull ; <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE>if ( ! wrapper -> Init ( ccx , existingJSObject ) ) <NEW_LINE>
if ( oldTextNode && rootNode -> HasDirAuto ( ) ) { <NEW_LINE>
ippSetString ( job -> attrs , & attr , 0 , printer -> job_sheets [ 0 ] ) ; <NEW_LINE>ippSetString ( job -> attrs , & attr , 1 , printer -> job_sheets [ 1 ] ) ; <NEW_LINE>
} while ( MaxDataSize >= ReadSize ) ; <NEW_LINE>
already_AddRefed < nsTimerImpl > ForgetTimer ( ) <NEW_LINE> { <NEW_LINE>return mTimer . forget ( ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>void SetTimer ( already_AddRefed < nsTimerImpl > aTimer ) <NEW_LINE> { <NEW_LINE>mTimer = aTimer ; <NEW_LINE>mGeneration = mTimer -> GetGeneration ( ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
for ( q = p ; isspace ( ( unsigned char ) * q ) && * q != '\n' ; q ++ ) <NEW_LINE>
CHAR_LEN_TABLE ( UTF8CharLenTable ) , <NEW_LINE>
XPCWrappedNativeJSClass XPC_WN_NoHelper_JSClass = { <NEW_LINE> { <NEW_LINE>
#endif <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
struct BASE_API PlatformFileInfo { <NEW_LINE>
image -> page . x = ( ssize_t ) ReadBlobLSBShort ( image ) ; <NEW_LINE>image -> page . y = ( ssize_t ) ReadBlobLSBShort ( image ) ; <NEW_LINE>
true ) ; <NEW_LINE>
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] = { L'\0' } ; <NEW_LINE>wcsncpy ( updateStatusFilePath , updateDirPath , MAX_PATH ) ; <NEW_LINE>
if ( ( width == 0 ) || ( height == 0 ) ) <NEW_LINE>
int sample ) <NEW_LINE>
if ( IsTextureSizeSafeToPassToDriver ( target , width , height ) ) { <NEW_LINE>mSymbols . fTexImage2D ( target , level , internalformat , width , height , border , format , type , pixels ) ; <NEW_LINE> } else { <NEW_LINE><NEW_LINE><NEW_LINE>mSymbols . fTexImage2D ( target , - 1 , internalformat , - 1 , - 1 , - 1 , format , type , nsnull ) ; <NEW_LINE> } <NEW_LINE>
while ( next_format ( & colour_type , & bit_depth , & palette_number , pm -> test_lbg , <NEW_LINE>pm -> test_tRNS ) ) <NEW_LINE>
print_unknown_data ( ndo , p , "\n\t" , length ) ; <NEW_LINE>
{ <NEW_LINE>nsAutoScriptBlocker scriptBlocker ; <NEW_LINE><NEW_LINE>for ( ImageObserver * observer = & mObserverList , * next ; observer ; <NEW_LINE>observer = next ) { <NEW_LINE>next = observer -> mNext ; <NEW_LINE>if ( observer -> mObserver ) { <NEW_LINE>observer -> mObserver -> Notify ( aRequest , aType , aData ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
if ( ! isFloatingOrOutOfFlowPositioned ( ) && height ( ) == 0 ) {
p -- ; <NEW_LINE>if ( p < 0 ) p += VE_AMP ; <NEW_LINE>premax = max ( premax , filters [ j ] . ampbuf [ p ] ) ; <NEW_LINE>premin = min ( premin , filters [ j ] . ampbuf [ p ] ) ; <NEW_LINE>
jas_matind_t i ; <NEW_LINE>jas_matind_t j ; <NEW_LINE>
ND_TCHECK ( p [ 2 ] ) ; <NEW_LINE>
namespace base { <NEW_LINE>class TickClock ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
retval = bprm_change_interp ( interp , bprm ) ; <NEW_LINE>if ( retval < 0 ) <NEW_LINE>return retval ; <NEW_LINE>
goto bail ; <NEW_LINE>
? get_uv_tx_size ( & mi [ 0 ] . mbmi , plane ) <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
mozilla::Maybe < AutoJSContextDestroyer > mCxDestroyer ; <NEW_LINE><NEW_LINE>JSAutoRequest mAr ; <NEW_LINE>
ret = TEMP_FAILURE_RETRY ( epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ) ; <NEW_LINE>
virtual void DidOverscroll ( const gfx::Vector2dF & accumulated_overscroll , <NEW_LINE>const gfx::Vector2dF & latest_overscroll_delta , <NEW_LINE>const gfx::Vector2dF & current_fling_velocity ) = 0 ; <NEW_LINE>
const uint8_t * bufs [ ARRAY_LEN ( s -> f ) - 1 ] ; <NEW_LINE>int lengths [ ARRAY_LEN ( s -> f ) - 1 ] ; <NEW_LINE>
if ( 0x80 & * src ) { <NEW_LINE>if ( mErrBehavior == kOnError_Signal ) <NEW_LINE>goto error3 ; <NEW_LINE> * dest ++ = UNICODE_REPLACEMENT_CHARACTER ; <NEW_LINE> } else { <NEW_LINE> * dest ++ = ( PRUnichar ) * src ; <NEW_LINE> } <NEW_LINE>
TypedArrayObjectStorage ( JSObject * obj ) : mObj ( obj ) <NEW_LINE>
intra_pred_var = vpx_get_mb_ss ( x -> src_diff ) ; <NEW_LINE>
return cx -> compartment -> wrap ( cx , vp ) ; <NEW_LINE>
#include "platform / mediastream / MediaStreamSource . h" <NEW_LINE>
<NEW_LINE>
if ( ( p == q ) || ( size < 16 ) || ( size > 256 ) ) <NEW_LINE>return ( ( Image * ) NULL ) ; <NEW_LINE>
JSCLASS_HAS_RESERVED_SLOTS ( sSJOWSlots ) , <NEW_LINE>
ENGINE_SET_INVALID_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <NEW_LINE>
bool CopyTexSubImage2D_base ( WebGLenum target , <NEW_LINE>
NS_T ( " % s / updating / % d . patch" ) , gDestinationPath , mPatchIndex ) ; <NEW_LINE>
if ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) { <NEW_LINE>
if ( ( r = ssh_packet_set_postauth ( ssh ) ) != 0 ) <NEW_LINE>
int received = TEMP_FAILURE_RETRY ( recv ( slot -> fd , buf , size , 0 ) ) ; <NEW_LINE>
#if HAVE_LZMA_H && HAVE_LIBLZMA <NEW_LINE>
if ( ! table -> map . put ( key , value ) ) <NEW_LINE>goto out_of_memory ; <NEW_LINE>return true ; <NEW_LINE>
uint8_t * buffer = ( uint8_t * ) malloc ( buffer_size ) ; <NEW_LINE>if ( ! buffer ) { <NEW_LINE>RLOGE ( "sendResponse: OOM" ) ; <NEW_LINE>pthread_mutex_unlock ( & write_lock ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
if ( ! curr -> isRenderBlock ( ) || curr -> isFloatingOrOutOfFlowPositioned ( ) || curr -> isTableCell ( ) || curr -> isRoot ( ) || curr -> isRenderView ( ) || curr -> hasOverflowClip ( ) <NEW_LINE>
if ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <NEW_LINE> { <NEW_LINE>u4_temp = * ( ps_stream -> pu4_buf_aligned ) ++ ; <NEW_LINE>CONV_LE_TO_BE ( ps_stream -> u4_buf_nxt , u4_temp ) <NEW_LINE> } <NEW_LINE>
IDBObjectStore::ClearCloneReadInfo ( mCloneReadInfos [ index ] ) ; <NEW_LINE>
#line 937 "ext / standard / var_unserializer . c" <NEW_LINE>
@stability Stable <NEW_LINE>
#include "platform / mediastream / MediaStreamSource . h" <NEW_LINE>
bool SoftMPEG2::setDecodeArgs ( <NEW_LINE>
nsRefPtr < nsTreeSelection > self = static_cast < nsTreeSelection * > ( aClosure ) ; <NEW_LINE>
uint8_t state:4 ; <NEW_LINE>uint8_t pstate:4 ; <NEW_LINE>
memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>
err = TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ) ; <NEW_LINE>
RELEASE_ASSERT ( m_textCharacters + m_textLength <= text . characters ( ) + static_cast < int > ( text . length ( ) ) ) ; <NEW_LINE>
@stability Stable <NEW_LINE>
if ( multiuser_get_app_id ( uid ) >= AID_APP ) { <NEW_LINE>
static int check_fragments_for_errors ( VP8D_COMP * pbi ) <NEW_LINE>
{ <NEW_LINE>image = DestroyImage ( image ) ; <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>
#include "compiler / compilerdebug . h" <NEW_LINE>
{ <NEW_LINE>if ( scanline != ( unsigned char * ) NULL ) <NEW_LINE>scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <NEW_LINE>if ( packed_scanline != ( unsigned char * ) NULL ) <NEW_LINE>packed_scanline = ( unsigned char * ) RelinquishMagickMemory ( <NEW_LINE>packed_scanline ) ; <NEW_LINE>if ( buffer != ( unsigned char * ) NULL ) <NEW_LINE>buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <NEW_LINE>ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
#define MAX_NUM_INPUT_OUTPUT_BUFFERS 64 <NEW_LINE>
if ( obj == cur -> GetGlobalJSObjectPreserveColor ( ) ) { <NEW_LINE>
while ( impeg2d_bit_stream_nxt ( ps_stream , MB_ESCAPE_CODE_LEN ) == MB_ESCAPE_CODE && <NEW_LINE>ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <NEW_LINE>
palette [ i ] . red = ( png_byte ) ( v & 0xff ) ; <NEW_LINE>palette [ i ] . green = ( png_byte ) ( v & 0xff ) ; <NEW_LINE>palette [ i ] . blue = ( png_byte ) ( v & 0xff ) ; <NEW_LINE>
return PerformSelection ( aClickedIndex , isShift , isControl ) ; <NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_EXPAND_16 ) != 0 ) <NEW_LINE>
PR_SetError ( err , 0 ) ; <NEW_LINE>
safe_print ( value , valsz , " \\\"' $ ` < > " ) ; <NEW_LINE>
const uint64_t alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? <NEW_LINE> ( uint64_t ) h * s * bps / 8 : ( uint64_t ) h * s ; <NEW_LINE><NEW_LINE>if ( alloc_size != ( size_t ) alloc_size ) <NEW_LINE>goto fail ; <NEW_LINE><NEW_LINE>img -> img_data = ( uint8_t * ) vpx_memalign ( buf_align , ( size_t ) alloc_size ) ; <NEW_LINE>
js::ReadBarriered < js::types::TypeObject > emptyTypeObject ; <NEW_LINE>
bool AttachSession ( DevToolsSession * session ) override ; <NEW_LINE>
} , <NEW_LINE>0 <NEW_LINE>
if ( ( isServer && ss -> ssl3 . hs . ws != wait_client_cert ) || <NEW_LINE> ( ! isServer && ss -> ssl3 . hs . ws != wait_server_cert ) ) { <NEW_LINE>desc = unexpected_message ; <NEW_LINE>errCode = SSL_ERROR_RX_UNEXPECTED_CERTIFICATE ; <NEW_LINE>goto alert_loser ; <NEW_LINE>
if ( ctx -> seq == NULL ) { <NEW_LINE><NEW_LINE> * minor_status = 0 ; <NEW_LINE>return GSS_S_DEFECTIVE_TOKEN ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( header -> buffer . length < token_wrapper_len + 22 ) { <NEW_LINE>
if ( j < outLen ) { out [ j ++ ] = ( accum >> 16 ) ; } <NEW_LINE>
nsTArray < nsRefPtr < nsRangeStore > > mArray ; <NEW_LINE>
if ( argc < 1 ) { <NEW_LINE>js_ReportMissingArg ( cx , vp , 0 ) ; <NEW_LINE>return JS_FALSE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
PRINTING_EXPORT extern const char kPreviewUIID [ ] ; <NEW_LINE>
<NEW_LINE>int32 ebml_size = GetUIntSize ( type ) ; <NEW_LINE><NEW_LINE><NEW_LINE>ebml_size += GetIntSize ( value ) ; <NEW_LINE><NEW_LINE><NEW_LINE>ebml_size ++ ; <NEW_LINE><NEW_LINE>return ebml_size ; <NEW_LINE>
void SetRenderer ( int process_host_id , <NEW_LINE>
NS_ENSURE_NATIVE_COLUMN ( aCol ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>
if ( ( jpeg_info . output_components == 1 ) && ( jpeg_info . quantize_colors == 0 ) ) <NEW_LINE>
Microtask::performCheckpoint ( V8PerIsolateData::mainThreadIsolate ( ) ) ; <NEW_LINE>
fd = cups_open ( filename , O_WRONLY | O_LARGEFILE | O_BINARY ) ; <NEW_LINE>if ( fd < 0 && errno == ENOENT ) <NEW_LINE> { <NEW_LINE>fd = cups_open ( filename , <NEW_LINE>O_WRONLY | O_CREAT | O_EXCL | O_LARGEFILE | O_BINARY ) ; <NEW_LINE>if ( fd < 0 && errno == EEXIST ) <NEW_LINE>fd = cups_open ( filename , O_WRONLY | O_LARGEFILE | O_BINARY ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( fd >= 0 ) <NEW_LINE>ftruncate ( fd , 0 ) ; <NEW_LINE>
LINKADDR_ATM , <NEW_LINE>LINKADDR_OTHER <NEW_LINE>
<NEW_LINE>
CanvasUtils::DoDrawImageSecurityCheck ( HTMLCanvasElement ( ) , res . mPrincipal , res . mIsWriteOnly ) ; <NEW_LINE>
for ( ; ; ) <NEW_LINE>
EbmlMasterElementSize ( kMkvChapterDisplay , payload_size ) + payload_size ; <NEW_LINE>
std::unique_ptr < HashSet < String >> preloaded_urls_for_test_ ; <NEW_LINE>
static void filter_selectively_vert_row2 ( int subsampling_factor , <NEW_LINE>
static void _php_mb_regex_globals_dtor ( zend_mb_regex_globals * pglobals TSRMLS_DC ) <NEW_LINE>
virtual void TabDetachedAt ( content::WebContents * contents , <NEW_LINE>int index ) OVERRIDE ; <NEW_LINE>
<NEW_LINE>
nsCOMPtr < nsIDOMElement > elem = do_QueryReferent ( mContent ) ; <NEW_LINE>
PRUint32 * aLineno , JSPrincipals * aPrincipals ) ; <NEW_LINE>
uint8_t * viewDataPointer = view -> dataPointer ( ) ; <NEW_LINE>
<NEW_LINE>
if ( count > 4 ) { <NEW_LINE>
} else if ( strcmp ( tokens [ 1 ] . value , "temp_ttl" ) == 0 && ntokens >= 4 && <NEW_LINE>
bool ShouldSkipFrame ( const gfx::Size & size ) ; <NEW_LINE>
<NEW_LINE>already_AddRefed < nsIDOMSVGNumber > GetItemAt ( uint32_t aIndex ) ; <NEW_LINE>
if ( mPreviousViewer ) { <NEW_LINE>nsCOMPtr < nsIContentViewer > previousViewer = mPreviousViewer ; <NEW_LINE>previousViewer -> SetBounds ( aBounds ) ; <NEW_LINE> } <NEW_LINE>
NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * kdelegate , void * val ) { } <NEW_LINE>
JSObject ** aClassObject , bool * aNew ) ; <NEW_LINE>
if ( ! ( si -> h && si -> w ) ) <NEW_LINE>res = VPX_CODEC_CORRUPT_FRAME ; <NEW_LINE>
ps_dec -> u4_first_slice_in_pic = 1 ; <NEW_LINE>
TypedArrayObjectStorage ( JSObject * obj ) : mObj ( obj ) <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
if ( diff . needsFullLayout ( ) ) { <NEW_LINE>
<NEW_LINE>
if ( allowed != 0 ) <NEW_LINE>
std::make_unique < CanonicalCookie > ( <NEW_LINE>
<NEW_LINE>trunc: <NEW_LINE>ND_PRINT ( ( ndo , " [ | pim ] " ) ) ; <NEW_LINE>return ; <NEW_LINE>
<NEW_LINE>
EffectPaintPropertyNode ( const EffectPaintPropertyNode * parent , State && state ) <NEW_LINE>: PaintPropertyNode ( parent ) , state_ ( std::move ( state ) ) { } <NEW_LINE>
memset ( str , 0 , MAX_APN_LENGTH + 1 ) ; <NEW_LINE>
l_tile -> x0 = ( OPJ_INT32 ) opj_uint_max ( l_cp -> tx0 + p * l_cp -> tdx , l_image -> x0 ) ; <NEW_LINE>l_tile -> y0 = ( OPJ_INT32 ) opj_uint_max ( l_cp -> ty0 + q * l_cp -> tdy , l_image -> y0 ) ; <NEW_LINE>l_tile -> x1 = ( OPJ_INT32 ) opj_uint_min ( l_cp -> tx0 + ( p + 1 ) * l_cp -> tdx , l_image -> x1 ) ; <NEW_LINE>l_tile -> y1 = ( OPJ_INT32 ) opj_uint_min ( l_cp -> ty0 + ( q + 1 ) * l_cp -> tdy , l_image -> y1 ) ; <NEW_LINE><NEW_LINE>
res = ctx -> iface -> dec . set_fb_fn ( get_alg_priv ( ctx ) , cb_get , cb_release , <NEW_LINE>
( target -> doc -> dict == ctxt -> dict ) && <NEW_LINE>xmlDictOwns ( ctxt -> dict , value ) ) { <NEW_LINE>
nsresult rv = NS_OK ; <NEW_LINE>
virtual bool multiple ( ) const <NEW_LINE>
#line 931 "ext / standard / var_unserializer . c" <NEW_LINE>
const vpx_tree_index vp9_intra_mode_tree [ TREE_SIZE ( INTRA_MODES ) ] = { <NEW_LINE>
<NEW_LINE>
const vpx_tree_index vp9_segment_tree [ TREE_SIZE ( MAX_SEGMENTS ) ] = { <NEW_LINE>
<NEW_LINE>
return static_cast < unsigned > ( lround ( to > from ? static_cast < double > ( from ) + static_cast < double > ( to - from ) * progress : static_cast < double > ( from ) - static_cast < double > ( from - to ) * progress ) ) ; <NEW_LINE>
class FindTabHelper ; <NEW_LINE>
if ( ( output_format & PNG_FORMAT_FLAG_ALPHA ) != 0 ) <NEW_LINE>
if ( ( flags & 2 ) && ( dataSize >= 2 ) ) {
png_const_bytep const pRow = store_image_row ( ps , pp , 0 , y ) ; <NEW_LINE>
{ <NEW_LINE>
bool Clear ( std::unique_ptr < PaintPropertyNode > & field ) { <NEW_LINE>
ReportBadReturn ( context , tc , pn , JSREPORT_ERROR , <NEW_LINE>
#endif <NEW_LINE>
{ <NEW_LINE>
ClipPaintPropertyNode ( const ClipPaintPropertyNode * parent , State && state ) <NEW_LINE>: PaintPropertyNode ( parent ) , state_ ( std::move ( state ) ) { } <NEW_LINE>
if ( ! EnsureStringLength ( output , inputLen ) ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE>
uint32_t nestsize = ( uint32_t ) ms -> nest_size [ ms -> nest_level ] ; <NEW_LINE>
<NEW_LINE><NEW_LINE>nsRefPtr < DOMSVGPathSegList > animVal = <NEW_LINE>
nsFtpChannel::OpenContentStream ( PRBool async , nsIInputStream ** result , <NEW_LINE>nsIChannel ** channel ) <NEW_LINE>
SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
CanvasUtils::DoDrawImageSecurityCheck ( HTMLCanvasElement ( ) , <NEW_LINE>
URLRequestContext * context_ ; <NEW_LINE>
<NEW_LINE>
RefPtr < SharedBuffer > fullData = readFile ( webTestsDataDir , "radient . gif" ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>while ( encode_frame ( & codec , NULL , - 1 , writer ) ) { } <NEW_LINE><NEW_LINE>
#line 114 "re_grammar . c" <NEW_LINE>
unsigned int channels ; <NEW_LINE>
memcpy ( tim . bitmap , p + offset , tim . length - 3 ) ; <NEW_LINE>
if ( ss -> xtnData . sentSessionTicketInClientHello ) <NEW_LINE>
if ( keep != 0 ) <NEW_LINE>
0 , 65 , 65 , 67 , 71 , 77 , 81 , 82 , 86 , 87 , <NEW_LINE>90 , 93 , 96 , 99 , 102 , 105 , 107 , 109 , 112 , 113 , <NEW_LINE>114 , 115 , 116 , 120 , 121 , 125 , 129 , 136 , 138 , 140 , <NEW_LINE>144 , 145 , 149 , 156 , 160 , 167 , 170 , 173 , 176 , 179 , <NEW_LINE>185 , 186 , 187 , 188 , 189 , 190 , 191 , 192 , 193 , 194 , <NEW_LINE>195 , 196 , 197 , 198 , 199 , 200 , 201 , 202 , 203 , 204 , <NEW_LINE>205 , 206 , 207 , 208 <NEW_LINE>
#if __LINE__ != 221446 <NEW_LINE>
if ( ! memsetSafe ( outHeader , 0 , outHeader -> nFilledLen ) ) { <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
nsresult FormatInputStream ( nsIRequest * aRequest , nsISupports * aContext , const nsAString & aBuffer ) ; <NEW_LINE><NEW_LINE>nsresult DoOnStartRequest ( nsIRequest * request , nsISupports * aContext , <NEW_LINE>nsString & aBuffer ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>
frame_all = vpx_calc_ssimg ( cpi -> Source , cm -> frame_to_show , <NEW_LINE>
return xpc_UnmarkGrayObject ( mJSObject ) ; <NEW_LINE>
* last_row , <NEW_LINE>
CHAR_LEN_TABLE ( EUCKRCharLenTable ) , <NEW_LINE>
CWD_API void realpath_cache_del ( const char * path , size_t path_len ) ; <NEW_LINE>CWD_API realpath_cache_bucket * realpath_cache_lookup ( const char * path , size_t path_len , time_t t ) ; <NEW_LINE>
if ( ( oxcf -> rc_mode == VPX_CQ ) && <NEW_LINE> ( active_best_quality < cq_level ) ) { <NEW_LINE>active_best_quality = cq_level ; <NEW_LINE>
# define SK_CRASH ( ) do { SkNO_RETURN_HINT ( ) ; abort ( ) ; } while ( false ) <NEW_LINE>
if ( isOutOfFlowPositioned ( ) ) <NEW_LINE>
<NEW_LINE>
! m_sources . empty ( ) && <NEW_LINE>
* ascii ++ = 45 , num = - fp ; <NEW_LINE>
AutoPushJSContext cx ( aContext -> GetNativeContext ( ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>TrackID mInputTrackID ; <NEW_LINE>TrackID mOutputTrackID ; <NEW_LINE>
{ <NEW_LINE>zval dval ; <NEW_LINE>dval = ** tmp ; <NEW_LINE>zval_copy_ctor ( & dval ) ; <NEW_LINE>convert_to_double ( & dval ) ; <NEW_LINE>m1 [ i ] = Z_DVAL ( dval ) ; <NEW_LINE> } <NEW_LINE>
scoped_ptr < base::TickClock > time_source_ ; <NEW_LINE>
PORT_FreeArena ( poolp , PR_TRUE ) ; <NEW_LINE>return NULL ; <NEW_LINE>
return true ; <NEW_LINE>
DecodePool::Singleton ( ) -> DecodeABitOf ( this , DECODE_SYNC ) ; <NEW_LINE>
if ( NS_SUCCEEDED ( res ) ) { <NEW_LINE>mSelState = new nsSelectionState ( ) ; <NEW_LINE>if ( mSelState ) { <NEW_LINE>mSelState -> SaveSelection ( selection ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
selection . SetSelection ( <NEW_LINE>SelectionInDOMTree::Builder ( ) <NEW_LINE> . SetBaseAndExtent ( range ) <NEW_LINE> . SetAffinity ( VP_DEFAULT_AFFINITY ) <NEW_LINE> . SetIsDirectional ( false ) <NEW_LINE> . Build ( ) , <NEW_LINE>SetSelectionData::Builder ( ) . SetShouldShowHandle ( show_handles ) . Build ( ) ) ; <NEW_LINE>
if ( ( info_ptr -> valid & PNG_INFO_PLTE ) != 0 ) <NEW_LINE>
if ( ( image -> columns != 0 ) && ( quantum != ( extent / image -> columns ) ) ) <NEW_LINE>
if ( do_local_background != 0 ) <NEW_LINE>
uint8_t * src = aArray -> Data ( ) ; <NEW_LINE>
sProperties , sFunctions , NULL , NULL ) ; <NEW_LINE>if ( ! proto ) { <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE><NEW_LINE>JSObject * ctor = JS_GetConstructor ( aCx , proto ) ; <NEW_LINE>if ( ! ctor ) { <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( ! dom::DefineConstants ( aCx , ctor , sStaticConstants ) || <NEW_LINE> ! dom::DefineConstants ( aCx , proto , sStaticConstants ) ) { <NEW_LINE>
<NEW_LINE>
if ( XrayUtils::IsTransparent ( cx , wrapper , id ) ) { <NEW_LINE>
pusher . Push ( mContext ) ; <NEW_LINE>
char * buff ; <NEW_LINE><NEW_LINE>if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { <NEW_LINE>error_line ( " % s is not a valid . WAV file ! " , infilename ) ; <NEW_LINE>return WAVPACK_SOFT_ERROR ; <NEW_LINE> } <NEW_LINE><NEW_LINE>buff = malloc ( bytes_to_copy ) ; <NEW_LINE>
if ( gs_sig != 0 ) <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
if ( ( png_ptr -> transformations & PNG_INTERLACE ) != 0 ) <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>txdb . EraseTxIndex ( * this ) ; <NEW_LINE>
Transpose ( frame ) ; <NEW_LINE>
DECLARE_ALIGNED ( 4 , short , FData [ 16 * 8 ] ) ; <NEW_LINE>
make_transform_images ( & pm ) ; <NEW_LINE>
p -> vi -> noiseoff [ j ] [ inthalfoc ] * ( 1 . - del ) + <NEW_LINE>p -> vi -> noiseoff [ j ] [ inthalfoc + 1 ] * del ; <NEW_LINE>
if ( malloc_called != 1 || free_called != 1 ) <NEW_LINE>
if ( bitmapH == NULL ) <NEW_LINE>
nsINode * p = mParent ; <NEW_LINE>mParent = nullptr ; <NEW_LINE>NS_RELEASE ( p ) ; <NEW_LINE>
<NEW_LINE>#define SSL_OP_EPHEMERAL_RSA				0x0 <NEW_LINE>
mMinLineHeight = aReflowState . CalcLineHeight ( ) ; <NEW_LINE>
* rowp ++ = suffix [ code ] & mColorMask ; <NEW_LINE>
if ( bit == 2 ) { <NEW_LINE>const __m128i const_rounding = _mm_set1_epi16 ( 1 ) ; <NEW_LINE>res [ 0 ] = _mm_add_epi16 ( res [ 0 ] , const_rounding ) ; <NEW_LINE>res [ 1 ] = _mm_add_epi16 ( res [ 1 ] , const_rounding ) ; <NEW_LINE>res [ 2 ] = _mm_add_epi16 ( res [ 2 ] , const_rounding ) ; <NEW_LINE>res [ 3 ] = _mm_add_epi16 ( res [ 3 ] , const_rounding ) ; <NEW_LINE>res [ 4 ] = _mm_add_epi16 ( res [ 4 ] , const_rounding ) ; <NEW_LINE>res [ 5 ] = _mm_add_epi16 ( res [ 5 ] , const_rounding ) ; <NEW_LINE>res [ 6 ] = _mm_add_epi16 ( res [ 6 ] , const_rounding ) ; <NEW_LINE>res [ 7 ] = _mm_add_epi16 ( res [ 7 ] , const_rounding ) ; <NEW_LINE>
case 16: <NEW_LINE>for ( b = ( bpp >> 4 ) ; b > 0 ; -- b ) <NEW_LINE>
if ( ( offsets [ 1 ] - offsets [ 0 ] < 0 ) || pcre_get_substring_list ( subject , offsets , count , & stringlist ) < 0 ) { <NEW_LINE>
memset ( input , 0 , 32 ) ; <NEW_LINE>
unsigned int actual_size = rtype == 2 ? n * 2 : n ; <NEW_LINE>unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; <NEW_LINE>unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ; <NEW_LINE>int n_read = limit_r_end - limit_r_begin ; <NEW_LINE>
nsRefPtr < nsRangeStore > mRangeItem ; <NEW_LINE>
bool setDecodeArgs ( <NEW_LINE>
xmlSchemaSetParserErrors ( ctxt , testErrorHandler , testErrorHandler , ctxt ) ; <NEW_LINE>
const InterpKernel * kernel = vp9_filter_kernels [ mi -> mbmi . interp_filter ] ; <NEW_LINE>
guint b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8 , b9 , b10 ; <NEW_LINE>
static void FinalizeCallback ( JSFreeOp * fop , JSFinalizeStatus status , JSBool isCompartmentGC ) ; <NEW_LINE>
nsresult rv = GetIndicesForInterval ( aItem -> GetStartParent ( ) , <NEW_LINE>aItem -> StartOffset ( ) , <NEW_LINE>aItem -> GetEndParent ( ) , <NEW_LINE>aItem -> EndOffset ( ) , false , <NEW_LINE> & startIndex , & endIndex ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE>
void UpdateUIFromInputMethod ( <NEW_LINE>const input_method::InputMethodDescriptor & input_method , <NEW_LINE>size_t num_active_input_methods ) ;
size_t needed = w * bytespp ; <NEW_LINE>
if ( table && oldStyle && diff . needsFullLayout ( ) && needsLayout ( ) && table -> collapseBorders ( ) && borderWidthChanged ( oldStyle , style ( ) ) ) {
TestInterfaceNode * impl = V8TestInterfaceNode::toImpl ( holder ) ; <NEW_LINE>
PageSerializer serializer ( & m_resources ) ; <NEW_LINE>
static const sp < IMediaPlayerService > getService ( ) ; <NEW_LINE>
#ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED <NEW_LINE>
ssplit ( sclone ( app -> controller ) , " - " , & plural ) ; <NEW_LINE>
let file = getMaintSvcDir ( ) ; <NEW_LINE>
if ( init_file ) { <NEW_LINE>phpdbg_init ( init_file , init_file_len , init_file_default ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
et_save , et_lastsubtype } ; <NEW_LINE>
size_type aNewLength ) ; <NEW_LINE>
if ( * cp == '\0' || strchr ( cp , ' / ' ) != NULL || <NEW_LINE>strcmp ( cp , " . " ) == 0 || strcmp ( cp , " . . " ) == 0 ) { <NEW_LINE>
if ( frame_size > LONG_MAX || frame_size <= 0 ) <NEW_LINE>
int opt_yv12 = 0 ; <NEW_LINE>int opt_i420 = 0 ; <NEW_LINE>vpx_codec_dec_cfg_t cfg = { 0 , 0 , 0 } ; <NEW_LINE>#if CONFIG_VP9_HIGHBITDEPTH <NEW_LINE>int output_bit_depth = 0 ; <NEW_LINE>#endif <NEW_LINE>
if ( number && num & ( 1 << ( number - 1 ) ) ) <NEW_LINE>
while ( ! kthread_freezable_should_stop ( NULL ) ) { <NEW_LINE><NEW_LINE>if ( signal_pending ( current ) ) <NEW_LINE>flush_signals ( current ) ;
if ( ! surface || cairo_surface_status ( surface ) ) <NEW_LINE>
const int16_t * filter = vp9_down2_symeven_half_filter ; <NEW_LINE>
<NEW_LINE>
base::WeakPtr < Delegate > delegate , <NEW_LINE>
#include "imgRequestProxy . h" <NEW_LINE>
EbmlMasterElementSize ( kMkvChapterAtom , payload_size ) + payload_size ; <NEW_LINE>
mm , mm -> mmap , ( long long ) mm -> vmacache_seqnum , mm -> task_size , <NEW_LINE>
if ( ! EnsureStringLength ( aDest , oldLength + Distance ( aSrcStart , aSrcEnd ) ) ) <NEW_LINE>return ; <NEW_LINE>
if ( code != SET_INTERNAL_OPTION && <NEW_LINE>index != ( OMX_INDEXTYPE ) OMX_IndexParamConsumerUsageBits && <NEW_LINE>declaredSize > size ) { <NEW_LINE>
return NS_OK ; <NEW_LINE>
last mod: $ Id: window . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE>
size_t data_size ; <NEW_LINE>if ( validate_and_calculate_camera_metadata_entry_data_size ( & data_size , entry . type , <NEW_LINE>entry . count ) != OK ) { <NEW_LINE>ALOGE ( " % s: Entry data size is invalid . type: % u count: % u" , __FUNCTION__ , entry . type , <NEW_LINE>entry . count ) ; <NEW_LINE>return ERROR ; <NEW_LINE> } <NEW_LINE>
guint32 len ; <NEW_LINE>
static void <NEW_LINE>
while ( ( RAW != ' > ' ) && ( ctxt -> instate != XML_PARSER_EOF ) ) { <NEW_LINE>
if ( ! fp ) { <NEW_LINE>#ifdef JS_METHODJIT <NEW_LINE>js::mjit::ExpandInlineFrames ( cx -> compartment ) ; <NEW_LINE>#endif <NEW_LINE>fp = cx -> maybefp ( ) ; <NEW_LINE> } else { <NEW_LINE>fp = fp -> prev ( ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>while ( fp && fp -> runningInIon ( ) ) <NEW_LINE>fp = fp -> prev ( ) ; <NEW_LINE><NEW_LINE> * iteratorp = Jsvalify ( fp ) ; <NEW_LINE>
TEMP_FAILURE_RETRY ( usleep ( 50 * 1000 ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>
memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <NEW_LINE>memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <NEW_LINE>
CallbackWrapper * wrapper = new CallbackWrapper ( callbacks ) ; <NEW_LINE>
newinet -> inet_opt	 = ireq -> opt ; <NEW_LINE>
{ 0xe2985850 , 0x81ca , 0x4b5d , \ <NEW_LINE> { 0xb0 , 0xf3 , 0xe3 , 0x95 , 0xd5 , 0x0d , 0x85 , 0x64 } } <NEW_LINE>
TEMP_FAILURE_RETRY ( usleep ( 100000 ) ) ; <NEW_LINE>
if ( msg -> msg_name ) { <NEW_LINE>struct sockaddr_rose * srose ; <NEW_LINE><NEW_LINE>memset ( msg -> msg_name , 0 , sizeof ( struct full_sockaddr_rose ) ) ; <NEW_LINE>srose = msg -> msg_name ; <NEW_LINE>
#line 1027 "ntp_parser . y" <NEW_LINE>
int slot = - 1 ; <NEW_LINE>
player -> setStartTime ( currentTime ( ) , false ) ; <NEW_LINE>
<NEW_LINE>atomic_dec ( & chip -> active ) ; <NEW_LINE>
if ( ( png_ptr -> transformations & PNG_INTERLACE ) == 0 ) <NEW_LINE>
zone -> maybeAlive = false ; <NEW_LINE>
BrowserContext * browser_context_ ; <NEW_LINE>StoragePartition * storage_partition_ ; <NEW_LINE>
IntPoint ( ) , selHeight , sPos , ePos ) ) ; <NEW_LINE><NEW_LINE>int logicalWidth = r . width ( ) ; <NEW_LINE>if ( r . x ( ) > m_logicalWidth ) <NEW_LINE>logicalWidth = 0 ; <NEW_LINE>else if ( r . right ( ) > m_logicalWidth ) <NEW_LINE>logicalWidth = m_logicalWidth - r . x ( ) ; <NEW_LINE><NEW_LINE>IntPoint topPoint = m_isVertical ? IntPoint ( tx + selTop , ty + m_y + r . x ( ) ) : IntPoint ( tx + m_x + r . x ( ) , ty + selTop ) ; <NEW_LINE>int width = m_isVertical ? selHeight : logicalWidth ; <NEW_LINE>int height = m_isVertical ? logicalWidth : selHeight ; <NEW_LINE><NEW_LINE>return IntRect ( topPoint , IntSize ( width , height ) ) ; <NEW_LINE>
if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( jas_uint , <NEW_LINE>
nsIFrame * frame = property -> GetReferencedFrame ( nsGkAtoms::svgPathGeometryFrame , nullptr ) ; <NEW_LINE>return frame && frame -> GetContent ( ) -> Tag ( ) == nsGkAtoms::path ? frame : nullptr ; <NEW_LINE>
ssize_t ret = TEMP_FAILURE_RETRY ( write ( fd , ev , sizeof ( * ev ) ) ) ; <NEW_LINE>
aContentType == nsIContentPolicy::TYPE_SCRIPT || <NEW_LINE>aContentType == nsIContentPolicy::TYPE_XSLT ) { <NEW_LINE>
static VPX_INLINE signed MEM_VALUE_T mem_get_s##end##sz ( const void * vmem ) { \ <NEW_LINE>
if ( curCapacity > 0 ) { <NEW_LINE><NEW_LINE>size_type temp = curCapacity ; <NEW_LINE>while ( temp < capacity ) <NEW_LINE>temp <<= 1 ; <NEW_LINE>NS_ASSERTION ( NS_MIN ( temp , kMaxCapacity ) >= capacity , <NEW_LINE>"should have hit the early return at the top" ) ; <NEW_LINE>capacity = NS_MIN ( temp , kMaxCapacity ) ; <NEW_LINE> } <NEW_LINE>
g_assert ( box_width > 0 ) ; <NEW_LINE><NEW_LINE>
detachDocumentLoader ( m_provisionalDocumentLoader ) ;
#line 1083 "ext / standard / var_unserializer . c" <NEW_LINE>
nsresult res = GetIndicesForInterval ( aBeginNode , aBeginOffset , <NEW_LINE>aEndNode , aEndOffset , aAllowAdjacent , <NEW_LINE> & startIndex , & endIndex ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( res , res ) ; <NEW_LINE><NEW_LINE>
js_InflateStringToBuffer ( cx , bytes , nbytes , chars , & nchars ) ; <NEW_LINE>
GetOuterWindow ( ) , <NEW_LINE>
#endif
JSObject ** result NS_OUTPARAM ) <NEW_LINE>
return AlignBytes ( localSlotCount_ , StackAlignment / STACK_SLOT_SIZE ) ; <NEW_LINE>
void <NEW_LINE>
return ERROR_INV_SLICE_HDR_T ; <NEW_LINE>
nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE>
xmlSchemaSetValidErrors ( ctxt , testErrorHandler , testErrorHandler , ctxt ) ; <NEW_LINE>
} else { <NEW_LINE>for ( i = 0 ; i < bundle -> n_slaves ; i ++ ) { <NEW_LINE>ofp_port_t ofp_port <NEW_LINE> = u16_to_ofp ( ntohs ( ( ( ovs_be16 * ) ( nab + 1 ) ) [ i ] ) ) ; <NEW_LINE>ofpbuf_put ( ofpacts , & ofp_port , sizeof ofp_port ) ; <NEW_LINE>bundle = ofpacts -> header ; <NEW_LINE> } <NEW_LINE>
default:	 <NEW_LINE>if ( parent_priv -> apib -> id == USB_API_COMPOSITE ) { <NEW_LINE>
TypedOrValueRegister output , bool monitoredResult , <NEW_LINE>bool allowDoubleResult ) ; <NEW_LINE>
#ifndef BASE_ANDROID_IMPORTANT_FILE_WRITER_ANDROID_H_ <NEW_LINE>#define BASE_ANDROID_IMPORTANT_FILE_WRITER_ANDROID_H_ <NEW_LINE>
#include "base / memory / ref_counted . h" <NEW_LINE>
_gdImageWebpCtx ( im , out , - 1 ) ; <NEW_LINE>
delete [ ] muxing_app_ ; <NEW_LINE>
memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mbmode , <NEW_LINE>sizeof ( MB_MODE_INFO ) ) ; <NEW_LINE>
return ( status ) ; <NEW_LINE>
{ <NEW_LINE>i_temp = ih264d_read_mmco_commands ( ps_dec ) ; <NEW_LINE>if ( i_temp < 0 ) <NEW_LINE> { <NEW_LINE>return ERROR_DBP_MANAGER_T ; <NEW_LINE> } <NEW_LINE>ps_dec -> u4_bitoffset = i_temp ; <NEW_LINE> } <NEW_LINE>
int fd = TEMP_FAILURE_RETRY ( accept ( s , ( struct sockaddr * ) & client_address , & clen ) ) ; <NEW_LINE>
m . command = CMD_NONE ; <NEW_LINE>
( void ) oxcf ; <NEW_LINE>
" timerID = setInterval ( 'checkSession ( ) ' , % d ) ; \n" <NEW_LINE>
bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) <NEW_LINE>
if ( len < 32 ) <NEW_LINE>ND_PRINT ( ( ndo , " len = % d [ bad: < 32 ] " , len ) ) ; <NEW_LINE>
std::cout << " GenerateWord32 and Crop\n" ; <NEW_LINE>
encoding_size += <NEW_LINE>EbmlMasterElementSize ( kMkvContentEncryption , encryption_size ) + <NEW_LINE>encryption_size ; <NEW_LINE>
+ cnt * sizeof ( struct posix_user_ace_state ) ; <NEW_LINE>
template < > mozilla::Atomic < size_t > mozilla::CountingAllocatorBase < HunspellAllocator > ::sAmount ( 0 ) ; <NEW_LINE>
nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE>
toTransfer = DOMArrayBuffer::create ( arrayBuffers [ i ] -> buffer ( ) -> data ( ) , arrayBuffers [ i ] -> buffer ( ) -> byteLength ( ) ) ; <NEW_LINE>
delete [ ] cue_entries_ ; <NEW_LINE>
count [ i ] += counts -> switchable_interp [ j ] [ i ] ; <NEW_LINE>
vpx_reader * r ) { <NEW_LINE>
if ( len < 1 || len > 8 ) <NEW_LINE>return E_FILE_FORMAT_INVALID ; <NEW_LINE>
return true ; <NEW_LINE>
return mExecutor -> MarkAsBroken ( NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE>
<NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
( appended . signature ( ) != "f3590c183018757da798613a23505ab9600b35935988eee12f096cb6219f2bc3" ) && <NEW_LINE>
if ( dls . pDLS ) { <NEW_LINE>Convert_art ( & dls , & defaultArt , 0 ) ; <NEW_LINE>dls . artCount = 1 ; <NEW_LINE> } <NEW_LINE>
nsresult rv = aprin -> Subsumes ( bprin , & subsumes ) ; <NEW_LINE>
RemoveInFlows ( nsTextFrame * aFrame , nsTextFrame * aFirstToNotRemove ) <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>void ResetDevicePolicy ( ) ; <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
ReentrantMonitorAutoEnter lock ( mImage -> mDecodingMonitor ) ; <NEW_LINE>
scale = adjust_scale ( scale ) ; <NEW_LINE>
ReferrerPolicy metaReferrerPolicy = ReferrerPolicyDefault ; <NEW_LINE>if ( ! attributeValue . isEmpty ( ) && ! attributeValue . isNull ( ) && SecurityPolicy::referrerPolicyFromString ( attributeValue , & metaReferrerPolicy ) ) { <NEW_LINE>documentParameters -> referrerPolicy = metaReferrerPolicy ; <NEW_LINE>
yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <NEW_LINE>
__android_log_print ( ANDROID_LOG_INFO , "Gecko" , " % s" , bytes . ptr ( ) ) ; <NEW_LINE>
const ArrayBufferView & pixbuf = pixels . Value ( ) ; <NEW_LINE>int dataType = JS_GetArrayBufferViewType ( pixbuf . Obj ( ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>if ( JustStartedNetworkLoad ( ) && ( aLoadType & LOAD_CMD_NORMAL ) ) { <NEW_LINE>mLoadType = LOAD_NORMAL_REPLACE ; <NEW_LINE> } <NEW_LINE>else { <NEW_LINE>mLoadType = aLoadType ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
png_error ( pp , "size row size incorrect" ) ; <NEW_LINE>
va_list args ) <NEW_LINE>
<NEW_LINE>int inter_mode_mask [ BLOCK_SIZES ] ;
return wpmap -> watch ( cx , obj , propid , handler , closure ) ; <NEW_LINE>
class PasswordGenerationController ; <NEW_LINE>
new_addr = realloc ( addr , size + align + ADDRESS_STORAGE_SIZE ) ; <NEW_LINE>
this -> AsyncReportViolation ( selfISupports , nullptr , violatedDirective , p , \ <NEW_LINE>
if ( ! newScope && cx ) { <NEW_LINE>jsval v ; <NEW_LINE>nsresult rv = WrapNative ( cx , global , aNewDocument , aNewDocument , & v ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE><NEW_LINE>newScope = JSVAL_TO_OBJECT ( v ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
StyleDifferenceLegacy diff ( const SVGRenderStyle * ) const ; <NEW_LINE>
delete [ ] codec_id_ ; <NEW_LINE>
if ( ! linkAndAttachStub ( cx , masm , attacher , ion , "parallel reading" ) ) <NEW_LINE>
return mprReadJsonObj ( obj , key ) ; <NEW_LINE>
if ( r -> m_object -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
nsBMPDecoder::WriteInternal ( const char * aBuffer , uint32_t aCount , DecodeStrategy ) <NEW_LINE>
uint32_t chan_chunk = 0 , desc_chunk = 0 , channel_layout = 0 , bcount ; <NEW_LINE>
bool canPropagateFloatIntoSibling = ! isFloatingOrOutOfFlowPositioned ( ) && ! avoidsFloats ( ) ; <NEW_LINE>
if ( equalIgnoringASCIICase ( <NEW_LINE>
if ( ec -> key ) <NEW_LINE> { <NEW_LINE>OPENSSL_cleanse ( ec -> key , ec -> keylen ) ; <NEW_LINE>OPENSSL_free ( ec -> key ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>ec -> key = ek ; <NEW_LINE>ec -> keylen = eklen ; <NEW_LINE>
uint64_t tableTotal = 0 ; <NEW_LINE>
CHECK_PRINCIPAL_AND_DATA ( ShouldLoad ) ; <NEW_LINE>
#endif
memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ; <NEW_LINE>
explicit UserState ( const mojom::LoginUserInfoPtr & user_info ) ; <NEW_LINE>
if ( argc < 1 ) { <NEW_LINE>js_ReportMissingArg ( cx , vp , 0 ) ; <NEW_LINE>return JS_FALSE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) , 1 ) ; <NEW_LINE>
virtual void WriteInternal ( const char * aBuffer , uint32_t aCount , DecodeStrategy aStrategy ) ; <NEW_LINE>
#include "platform / win / HWndDC . h" <NEW_LINE>
int is_rf64 = ! strncmp ( fourcc , "RF64" , 4 ) , got_ds64 = 0 , format_chunk = 0 ; <NEW_LINE>
ReentrantMonitorAutoEnter lock ( mDecodingMonitor ) ; <NEW_LINE>
NS_RUNTIMEABORT ( "Unexpected shutdown reason for toplevel actor . " ) ; <NEW_LINE>
} <NEW_LINE>
static const l_int32 L_BUFSIZE = 512 ; <NEW_LINE>
if ( fread ( image_data , 1L , rowbytes * height , saved_infile ) < <NEW_LINE>rowbytes * height ) { <NEW_LINE>free ( image_data ) ; <NEW_LINE>image_data = NULL ; <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>if ( info_ptr -> text [ i ] . compression == PNG_TEXT_COMPRESSION_NONE ) <NEW_LINE>info_ptr -> text [ i ] . compression = PNG_TEXT_COMPRESSION_NONE_WR ; <NEW_LINE>else <NEW_LINE>info_ptr -> text [ i ] . compression = PNG_TEXT_COMPRESSION_zTXt_WR ; <NEW_LINE>
else if ( ( png_ptr -> flags & PNG_FLAG_CRC_ANCILLARY_NOWARN ) == 0 ) <NEW_LINE>
memset ( ybf , 0 , sizeof ( YV12_BUFFER_CONFIG ) ) ; <NEW_LINE>
<NEW_LINE>
if ( ! do_interlace && <NEW_LINE>npasses != set_write_interlace_handling ( pp , interlace_type ) ) <NEW_LINE>
const sp < IMediaPlayerService > service ( getMediaPlayerService ( ) ) ; <NEW_LINE>
mutex_unlock ( & dev -> lock ) ; <NEW_LINE>
if ( container ) { <NEW_LINE>nsSubDocumentFrame * subDocFrame = do_QueryFrame ( container -> GetPrimaryFrame ( ) ) ; <NEW_LINE>rootViewParent = subDocFrame ? subDocFrame -> EnsureInnerView ( ) : nsnull ; <NEW_LINE> } <NEW_LINE>if ( sibling && <NEW_LINE>sibling -> GetShell ( ) && <NEW_LINE>sibling -> GetShell ( ) -> GetViewManager ( ) ) { <NEW_LINE>rootViewSibling = sibling -> GetShell ( ) -> GetViewManager ( ) -> GetRootView ( ) ; <NEW_LINE> } else { <NEW_LINE>rootViewSibling = nsnull ; <NEW_LINE> } <NEW_LINE>if ( rootViewParent && newRootView && newRootView -> GetParent ( ) != rootViewParent ) { <NEW_LINE>nsIViewManager * parentVM = rootViewParent -> GetViewManager ( ) ; <NEW_LINE>if ( parentVM ) { <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ; <NEW_LINE>
cx = JSContextForPluginInstance ( reinterpret_cast < nsIPluginInstance * > ( mJavaClient ) ) ; <NEW_LINE>if ( ! cx ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>AutoPushJSContext autopush ( securitySupports , cx ) ; <NEW_LINE>if ( NS_FAILED ( autopush . ResultOfPush ( ) ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>
value = mprReadJson ( httpGetParams ( conn ) , var ) ; <NEW_LINE>
# define SSL_READ_ETM ( s ) ( s -> s3 -> flags & TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ) <NEW_LINE># define SSL_WRITE_ETM ( s ) ( s -> s3 -> flags & TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ) <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <NEW_LINE>
if ( ! EnsureLegalActivity ( cx , obj ) ) { <NEW_LINE>return JS_FALSE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
typedef base::Callback < void ( DecoderStatus , <NEW_LINE>const scoped_refptr < VideoFrame > & ) > ReadCB ; <NEW_LINE>
image_transform_png_set_palette_to_rgb_set ( const image_transform * this , <NEW_LINE>
mCxPusher . Push ( cx ) ; <NEW_LINE>
if ( ( png_ptr -> transformations & PNG_USER_TRANSFORM ) != 0 ) <NEW_LINE>
ReentrantMonitorAutoEnter lock ( mDecodingMonitor ) ; <NEW_LINE>
#define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 86 )
req::free ( tmpstr ) ; <NEW_LINE>
if ( mprReadJson ( route -> config , sfmt ( "app . http . content . minify [ @ = ' % s' ] " , child -> value ) ) ) { <NEW_LINE>
bool b = dropdownSize . height <= below || dropdownSize . height > above ; <NEW_LINE>
ReentrantMonitorAutoEnter lock ( mDecodingMonitor ) ; <NEW_LINE>
jas_uchar buf [ 2 ] ; <NEW_LINE>
<NEW_LINE>already_AddRefed < DOMSVGPathSeg > GetItemAt ( uint32_t aIndex ) ; <NEW_LINE>
delete [ ] name_ ; <NEW_LINE>
virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result , <NEW_LINE>nsIChannel ** channel ) ; <NEW_LINE>
<NEW_LINE>void ClearTextRun ( nsTextFrame * aStartContinuation ) ; <NEW_LINE>
nsINode * startRoot = count == 0 ? mRootNode : mElements [ count - 1 ] ; <NEW_LINE>
<NEW_LINE>VERIFY ( ::SetParent ( mWnd , nsnull ) ) ; <NEW_LINE>
NS_ENSURE_NATIVE_COLUMN ( aCol ) ; <NEW_LINE>
if ( dib_info . size != 40 ) <NEW_LINE>
m . command = CMD_NONE ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
int fd = TEMP_FAILURE_RETRY ( accept ( socket -> fd , NULL , NULL ) ) ; <NEW_LINE>
*
<NEW_LINE><NEW_LINE>if ( ! mChannel || aOldChannel != mChannel ) { <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
mArray [ i ] -> GetRange ( address_of ( myRange ) ) ; <NEW_LINE>aSelState -> mArray [ i ] -> GetRange ( address_of ( itsRange ) ) ; <NEW_LINE>
nsTArray < nsCOMPtr < nsIContent > > mOwnedElements ; <NEW_LINE>
@stability Stable <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
TEMP_FAILURE_RETRY ( sem_wait ( semaphore ) ) ; \ <NEW_LINE>
AutoCompartment ac ( cx , cx -> runtime ( ) -> atomsCompartment ) ; <NEW_LINE>
TEMP_FAILURE_RETRY ( usleep ( 1 ) ) ; <NEW_LINE>
nsWindow * ownerWindow = GetContainerWindow ( ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>JSFunction * fun = JS_NewFunction ( cx , XPC_NW_toString , 0 , 0 , nsnull , <NEW_LINE>"toString" ) ; <NEW_LINE>if ( ! fun ) { <NEW_LINE>return JS_FALSE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>JSObject * funobj = JS_GetFunctionObject ( fun ) ; <NEW_LINE>STOBJ_SET_PARENT ( funobj , obj ) ; <NEW_LINE><NEW_LINE>return JS_DefineProperty ( cx , obj , "toString" , OBJECT_TO_JSVAL ( funobj ) , <NEW_LINE>nsnull , nsnull , 0 ) ; <NEW_LINE>
if ( ! V8ScriptRunner::callInternalFunction ( v8::Local < v8::Function > ::Cast ( setter ) , holder , WTF_ARRAY_LENGTH ( argv ) , argv , isolate ) . ToLocal ( & result ) ) { <NEW_LINE>
nsTArray < nsCOMPtr < nsINode > > skipList ; <NEW_LINE>
EXPECT_TRUE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE>EXPECT_TRUE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE>
ret = iwl_sta_ucode_activate ( priv , sta_id ) ; <NEW_LINE>
class MODULES_EXPORT BodyStreamBuffer final : public UnderlyingSourceBase , public WebDataConsumerHandle::Client { <NEW_LINE>
attrValue , modification , hasListeners , aNotify , nsnull ) ; <NEW_LINE>
unsigned image_size_in_bytes , skip_size_in_bytes ; <NEW_LINE>ComputeImageSizeInBytes ( format , type , width , height , 1 , unpack_params , <NEW_LINE> & image_size_in_bytes , nullptr , & skip_size_in_bytes ) ; <NEW_LINE>const uint8_t * src_data = static_cast < const uint8_t * > ( pixels ) ; <NEW_LINE>if ( skip_size_in_bytes ) { <NEW_LINE>src_data += skip_size_in_bytes ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( ! PackPixels ( src_data , source_data_format , <NEW_LINE>unpack_params . row_length ? unpack_params . row_length : width , <NEW_LINE>height , IntRect ( 0 , 0 , width , height ) , 1 , <NEW_LINE>unpack_params . alignment , 0 , format , type , <NEW_LINE>
if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && s -> framep [ VP56_FRAME_GOLDEN ] != p && <NEW_LINE>
return isInlineBlockOrInlineTable ( ) || isFloatingOrOutOfFlowPositioned ( ) || hasOverflowClip ( ) || ( parent ( ) && parent ( ) -> isDeprecatedFlexibleBox ( ) ) <NEW_LINE>
( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent - 1 ) ;
nsresult rv = handler -> Init ( aWindow , aIsInterval , aInterval ) ; <NEW_LINE>
ASSERT ( child -> isOutOfFlowPositioned ( ) ) ; <NEW_LINE>
<NEW_LINE>
void OnGetWindowScriptNPObject ( int route_id , bool * success ) ; <NEW_LINE>void OnGetPluginElement ( int route_id , bool * success ) ; <NEW_LINE>
<NEW_LINE>StyleDifferenceLegacy visualInvalidationDiffLegacy ( const RenderStyle & , unsigned & changedContextSensitiveProperties ) const ; <NEW_LINE>StyleDifferenceLegacy repaintOnlyDiff ( const RenderStyle & other , unsigned & changedContextSensitiveProperties ) const ; <NEW_LINE>
#endif <NEW_LINE>
SSL_SET_OPTIONS ( & mysql_connection ) ; <NEW_LINE>
|| ( ret == ERROR_UNAVAIL_MVBUF_T ) <NEW_LINE> || ( ret == ERROR_INV_SPS_PPS_T ) ) <NEW_LINE>
copy_fields ( s , s1 , golden_frame , keyframe ) ; <NEW_LINE>
isoclns_print ( ndo , p + 1 , length - 1 ) ; <NEW_LINE>
inline AutoCompartment ( JSContext * cx , JSObject * target ) ; <NEW_LINE>inline ~ AutoCompartment ( ) ; <NEW_LINE>
} <NEW_LINE>
SOW_FLAG = PARTIALLY_TRANSPARENT << 1 , <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>SHADOWING_FORBIDDEN = SOW_FLAG << 1 } ; <NEW_LINE>
err = TEMP_FAILURE_RETRY ( nanosleep ( & delay , & delay ) ) ; <NEW_LINE>
CHECK_EQ ( mImg -> fmt , VPX_IMG_FMT_I420 ) ; <NEW_LINE>
uint64_t allocSize = numEntries * 2 * ( uint64_t ) sizeof ( uint32_t ) ; <NEW_LINE>
<NEW_LINE>
file = fopen_safe ( " / tmp / keepalived . json" , "w" ) ; <NEW_LINE>
bool <NEW_LINE>Zone::hasMarkedCompartments ( ) <NEW_LINE> { <NEW_LINE>for ( CompartmentsInZoneIter comp ( this ) ; ! comp . done ( ) ; comp . next ( ) ) { <NEW_LINE>if ( comp -> marked ) <NEW_LINE>return true ; <NEW_LINE> } <NEW_LINE>return false ; <NEW_LINE> }
return read_chunked_trailers ( ctx , f , b , <NEW_LINE>conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ) ; <NEW_LINE>
vp9_hex_search ( x , & ref_full , step_param , x -> errorperbit , 0 , <NEW_LINE>cond_cost_list ( cpi , cost_list ) , <NEW_LINE> & v_fn_ptr , 0 , ref_mv , dst_mv ) ;
if ( CONFIG_IS_ENABLED ( CMD_CLS ) ) <NEW_LINE>run_command ( "cls" , 0 ) ; <NEW_LINE>
NS_ENSURE_STATE ( index != controls . NoIndex ) ; <NEW_LINE>
nsWindow * containerWindow = GetContainerWindow ( ) ; <NEW_LINE>if ( ! gFocusWindow && containerWindow ) { <NEW_LINE>
MockPrinter * printer ( ) ;
<NEW_LINE>rv = DecodeSomeData ( mSourceData . Length ( ) - mBytesDecoded , DECODE_SYNC ) ; <NEW_LINE>CONTAINER_ENSURE_SUCCESS ( rv ) ; <NEW_LINE>
if ( ( info_ptr -> valid & PNG_INFO_tIME ) != 0 && <NEW_LINE> ( png_ptr -> mode & PNG_WROTE_tIME ) == 0 ) <NEW_LINE>
<NEW_LINE>
#endif <NEW_LINE>
& unit_type ) != 0 ) <NEW_LINE>
const double whiteY = e -> red . Y + e -> green . Y + e -> blue . Y ; <NEW_LINE>
AutoPushJSContext cx ( aDocument -> GetScriptGlobalObject ( ) -> <NEW_LINE>GetContext ( ) -> GetNativeContext ( ) ) ; <NEW_LINE>
const vpx_prob vp9_kf_partition_probs [ PARTITION_CONTEXTS ] <NEW_LINE>
#define PACKAGE_VERSION "2 . 12 . 6"
global -> codec -> fourcc , <NEW_LINE>pixel_aspect_ratio ) ; <NEW_LINE>
fetch_context -> DispatchWillSendRequest ( 1 , request , response , Resource::kRaw , <NEW_LINE>initiator_info ) ; <NEW_LINE>
xmlXPathNodeSetKeepLast ( ctxt -> value -> nodesetval ) ; <NEW_LINE>
<NEW_LINE>
void HandleSeeking ( const gfx::Point & location ) ; <NEW_LINE>
return frameLoaderClient && frameLoaderClient -> allowAutoplay ( true ) ; <NEW_LINE>
fprintf ( stderr , " ( % d ) , " , pageout ) ; <NEW_LINE>
<NEW_LINE>
const uint8_t * srcY = ( const uint8_t * ) mImg -> planes [ VPX_PLANE_Y ] ; <NEW_LINE>const uint8_t * srcU = ( const uint8_t * ) mImg -> planes [ VPX_PLANE_U ] ; <NEW_LINE>const uint8_t * srcV = ( const uint8_t * ) mImg -> planes [ VPX_PLANE_V ] ; <NEW_LINE>size_t srcYStride = mImg -> stride [ VPX_PLANE_Y ] ; <NEW_LINE>size_t srcUStride = mImg -> stride [ VPX_PLANE_U ] ; <NEW_LINE>size_t srcVStride = mImg -> stride [ VPX_PLANE_V ] ; <NEW_LINE>
bool hasSource ( ) const { return ! m_sources . empty ( ) ; } <NEW_LINE>
if ( gData -> stateStackTop ) <NEW_LINE> -- gData -> stateStackTop ; <NEW_LINE>
cgc . cmd [ 9 ] = cgc . buflen & 0xff ; <NEW_LINE>
memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; <NEW_LINE>
fStorage = ( SkRegion::RunType * ) sk_malloc_canfail ( fStorageCount , sizeof ( SkRegion::RunType ) ) ; <NEW_LINE>
XPCAutoRequest ar ( cx ) ; <NEW_LINE>
SSLCertErrorHandler ( const base::WeakPtr < Delegate > & delegate , <NEW_LINE>
PHP_FUNCTION ( locale_get_display_region ) <NEW_LINE>
#endif <NEW_LINE>
memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE>
redirect_response , resource_ -> GetType ( ) , <NEW_LINE>options . initiator_info ) ;
js_Atomize ( JSContext * cx , const char * bytes , size_t length , uintN flags ) ; <NEW_LINE>
rv = nsContentUtils::ASCIIToLower ( aFormat , lowercaseFormat ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) { <NEW_LINE>return rv ; <NEW_LINE> } <NEW_LINE>
const image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE>
# ifdef PNG_SET_USER_LIMITS_SUPPORTED <NEW_LINE>if ( png_ptr -> user_chunk_malloc_max > 0 && <NEW_LINE>png_ptr -> user_chunk_malloc_max < limit ) <NEW_LINE>limit = png_ptr -> user_chunk_malloc_max ; <NEW_LINE># elif PNG_USER_CHUNK_MALLOC_MAX > 0 <NEW_LINE>if ( PNG_USER_CHUNK_MALLOC_MAX < limit ) <NEW_LINE>limit = PNG_USER_CHUNK_MALLOC_MAX ; <NEW_LINE># endif <NEW_LINE>
void unsafe_ocall_malloc ( size_t size , uint8_t ** ret ) { <NEW_LINE>
#define SELFTEST_PORT	QRIO_GPIO_A <NEW_LINE>
uint64_t allocSize = mTimeToSampleCount * 2 * ( uint64_t ) sizeof ( uint32_t ) ; <NEW_LINE>
BufferMeta * bufferMeta = new BufferMeta ( graphicBuffer , portIndex ) ; <NEW_LINE>
#include "imgRequestProxy . h" <NEW_LINE>
<NEW_LINE>
if ( ! pusher . Push ( mContext ) ) <NEW_LINE>
#line 1335 "ext / standard / var_unserializer . c" <NEW_LINE>
mutt_bcache_commit ( pop_data -> bcache , cache_id ( h -> data ) ) ; <NEW_LINE>
size_t descLen = StringSize ( & data [ 5 ] , size - 5 , encoding ) ; <NEW_LINE>if ( descLen > size - 5 ) { <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE>
const int * src [ FLACParser::kMaxChannels ] , <NEW_LINE>
PREDICTION_MODE modes [ 4 ] ; <NEW_LINE>
extern void vp8_rd_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , <NEW_LINE>int recon_yoffset , int recon_uvoffset , <NEW_LINE>int * returnrate , int * returndistortion , <NEW_LINE>int * returnintra , int mb_row , int mb_col ) ; <NEW_LINE>
XDRScriptState * state ; <NEW_LINE> } ; <NEW_LINE><NEW_LINE>class XDRScriptState { <NEW_LINE>public: <NEW_LINE>XDRScriptState ( JSXDRState * x ) ; <NEW_LINE> ~ XDRScriptState ( ) ; <NEW_LINE><NEW_LINE>JSXDRState * xdr ; <NEW_LINE>const char * filename ; <NEW_LINE>bool filenameSaved ; <NEW_LINE>XDRAtoms atoms ; <NEW_LINE>XDRAtomsHashMap atomsMap ; <NEW_LINE>
<NEW_LINE>static already_AddRefed < nsTimerImpl > PostTimerEvent ( <NEW_LINE>already_AddRefed < nsTimerImpl > aTimerRef ) ; <NEW_LINE>
base_size = sizeof ( path -> p [ 0 ] ) * npts ; <NEW_LINE>size = offsetof ( PATH , p [ 0 ] ) + base_size ; <NEW_LINE><NEW_LINE><NEW_LINE>if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) <NEW_LINE>ereport ( ERROR , <NEW_LINE> ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , <NEW_LINE>errmsg ( "too many points requested" ) ) ) ; <NEW_LINE><NEW_LINE>
u64 nr , <NEW_LINE>
YV12_BUFFER_CONFIG ** frames , <NEW_LINE>
dir = GSF_IS_INFILE_TAR ( subdir ) <NEW_LINE> ? GSF_INFILE_TAR ( subdir ) <NEW_LINE>: dir ; <NEW_LINE>
nsCOMPtr < nsIPrincipal > mOriginPrincipal ; <NEW_LINE>
u_int atype , const u_char * pptr , u_int len , const unsigned attr_set_level ) <NEW_LINE>
if ( ! skip ) { <NEW_LINE>PS_ADD_VARL ( name , namelen ) ; <NEW_LINE> } <NEW_LINE>
if ( frame_size > LONG_MAX || frame_size <= 0 ) <NEW_LINE>
findBufferHeader ( msg . u . extended_buffer_data . buffer , kPortIndexOutput ) ; <NEW_LINE>if ( buffer == NULL ) { <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE>
while ( fscanf ( maps , " % * x - % * x % * s % zx % 5s % ld % 1023s\n" , <NEW_LINE> & offset , device , & inode , file ) == 4 ) { <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
if ( strlen ( str ) > MAXDATELEN ) <NEW_LINE>
int client_socket = TEMP_FAILURE_RETRY ( accept ( listen_socket_ , NULL , NULL ) ) ; <NEW_LINE>
xmlSchemaSetParserErrors ( ctxt , testErrorHandler , testErrorHandler , <NEW_LINE>ctxt ) ; <NEW_LINE>
if ( ( ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ) < 0 ) { <NEW_LINE>
if ( ! mIsDestroying ) { <NEW_LINE>nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>mFrameConstructor -> CreateNeededFrames ( ) ; <NEW_LINE>mFrameConstructor -> ProcessPendingRestyles ( ) ; <NEW_LINE> } <NEW_LINE>
if ( x & ( 1U << ( unsigned int ) i ) ) return i ; <NEW_LINE>
if ( i . isIon ( ) ) <NEW_LINE>continue ; <NEW_LINE>StackFrame * fp = i . interpFrame ( ) ; <NEW_LINE>if ( fp -> isFunctionFrame ( ) && fp -> script ( ) == script ) { <NEW_LINE>
COMPUTED_STYLE_MAP_ENTRY_LAYOUT ( _moz_border_radius_bottomLeft , BorderRadiusBottomLeft ) , <NEW_LINE>COMPUTED_STYLE_MAP_ENTRY_LAYOUT ( _moz_border_radius_bottomRight , BorderRadiusBottomRight ) , <NEW_LINE>COMPUTED_STYLE_MAP_ENTRY_LAYOUT ( _moz_border_radius_topLeft , BorderRadiusTopLeft ) , <NEW_LINE>COMPUTED_STYLE_MAP_ENTRY_LAYOUT ( _moz_border_radius_topRight , BorderRadiusTopRight ) , <NEW_LINE>
mouse . x = point . screenPosition ( ) . x ( ) ; <NEW_LINE>mouse . y = point . screenPosition ( ) . y ( ) ; <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
AutoPushJSContext jscontext ( context -> GetNativeContext ( ) ) ; <NEW_LINE>
#ifndef PNG_INDEX_SUPPORTED <NEW_LINE>if ( ( png_ptr -> flags & PNG_FLAG_ROW_INIT ) != 0 ) <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>WORD16 ai2_level_arr [ 19 ] ; <NEW_LINE>WORD16 * i2_level_arr = & ai2_level_arr [ 3 ] ; <NEW_LINE>
<NEW_LINE>
JS_PSGS ( "customNative" , its_get_customNative , its_set_customNative , JSPROP_ENUMERATE ) , <NEW_LINE>JS_PS_END <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
if ( l >= ( len - o - 4 ) ) { <NEW_LINE>
IPC_MESSAGE_ROUTED2 ( ViewHostMsg_GoToEntryAtOffset , <NEW_LINE>int , <NEW_LINE>bool )
timeout -> mPrincipal , timeout -> mPrincipal , <NEW_LINE>filename , lineNo , <NEW_LINE>
savesegment ( fs , fs_selector ) ; <NEW_LINE>savesegment ( gs , gs_selector ) ; <NEW_LINE>
npTouchEvent . points [ i ] . touchId = event . m_points [ i ] . id ( ) ; <NEW_LINE>npTouchEvent . points [ i ] . clientX = event . m_points [ i ] . screenPosition ( ) . x ( ) ; <NEW_LINE>npTouchEvent . points [ i ] . clientY = event . m_points [ i ] . screenPosition ( ) . y ( ) ; <NEW_LINE>npTouchEvent . points [ i ] . screenX = event . m_points [ i ] . screenPosition ( ) . x ( ) ; <NEW_LINE>npTouchEvent . points [ i ] . screenY = event . m_points [ i ] . screenPosition ( ) . y ( ) ; <NEW_LINE>npTouchEvent . points [ i ] . pageX = event . m_points [ i ] . pixelViewportPosition ( ) . x ( ) ; <NEW_LINE>npTouchEvent . points [ i ] . pageY = event . m_points [ i ] . pixelViewportPosition ( ) . y ( ) ; <NEW_LINE>
if ( L_ICANON ( tty ) && ! L_EXTPROC ( tty ) ) <NEW_LINE>
const long long id = ReadID ( pReader , pos , len ) ; <NEW_LINE>if ( id < 0 || ( pos + len ) > stop ) <NEW_LINE>return false ; <NEW_LINE>
<NEW_LINE>
nsCOMPtr < nsPIDOMWindow > window = static_cast < nsPIDOMWindow * > <NEW_LINE> ( nsGlobalWindow::GetInnerWindowWithId ( mRequest -> InnerWindowID ( ) ) ) ; <NEW_LINE>
ippSetGroupTag ( job -> attrs , & attr , IPP_TAG_JOB ) ; <NEW_LINE>ippSetName ( job -> attrs , & attr , "job - originating - user - name" ) ; <NEW_LINE>
vdev -> ctx = kcalloc ( nvec , sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <NEW_LINE>
if ( inliningDepth_ >= maxInlineDepth ) <NEW_LINE>
if ( ( MagickSizeType ) bmp_info . number_colors > GetBlobSize ( image ) ) <NEW_LINE>
scale = adjust_scale ( scale ) ; <NEW_LINE>
bool drainOneOutputBuffer ( int32_t picId , uint8_t * data ) ; <NEW_LINE>
{ <NEW_LINE>zval dval ; <NEW_LINE>dval = ** zval_affine_elem ; <NEW_LINE>zval_copy_ctor ( & dval ) ; <NEW_LINE>convert_to_double ( & dval ) ; <NEW_LINE>affine [ i ] = Z_DVAL ( dval ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>FinishAndStoreOverflow ( & aDesiredSize ) ; <NEW_LINE><NEW_LINE>
<NEW_LINE>
memcpy ( serial -> value , priv -> cac_id , serial -> len ) ; <NEW_LINE>
const sp < IMediaPlayerService > service ( getService ( ) ) ; <NEW_LINE>
if ( get4 ( ) == 0x48454150 <NEW_LINE>#ifdef LIBRAW_LIBRARY_BUILD <NEW_LINE> && ( save + hlen ) >= 0 && ( save + hlen ) <= ifp -> size ( ) <NEW_LINE>#endif <NEW_LINE> ) <NEW_LINE>
} else if ( runLength == fragmentLength && <NEW_LINE>frame -> GetNextSibling ( ) ) { <NEW_LINE>
new ( std::nothrow ) ContentCompression * [ compression_count ] ; <NEW_LINE>
#include "extensions / browser / guest_view / guest_view_manager . h" <NEW_LINE>
bool isOutOfFlowPositioned ( ) const { return m_bitfields . positioned ( ) ; } <NEW_LINE>bool isInFlowPositioned ( ) const { return m_bitfields . relPositioned ( ) ; } <NEW_LINE>
<NEW_LINE>
m_mainThreadProxy -> postTask ( createMainThreadTask ( this , & CCLayerTreeHostTest::endTest ) ) ; <NEW_LINE>
? js_SafeSetPropertyById ( cx , unsafeObj , scopeFun , interned_id , vp ) <NEW_LINE>: js_SafeGetPropertyById ( cx , unsafeObj , scopeFun , interned_id , vp ) ; <NEW_LINE>
FLAC__int32 const * mWriteBuffer [ kMaxChannels ] ; <NEW_LINE>
#define B43_DMA0_RX_BUFFERSIZE		 ( B43_DMA0_RX_FRAMEOFFSET + IEEE80211_MAX_FRAME_LEN ) <NEW_LINE>
aAddrStr . Truncate ( ) ; <NEW_LINE>
#endif
class WebContents ; <NEW_LINE>
conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE>
ASSERT ( isFloatingOrOutOfFlowPositioned ( ) ) ; <NEW_LINE>
{ <NEW_LINE>xref = ( MagickOffsetType * ) RelinquishMagickMemory ( xref ) ; <NEW_LINE>ThrowWriterException ( ResourceLimitError , <NEW_LINE>"MemoryAllocationFailed" ) ; <NEW_LINE> } <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
size_t nchars , idstrlength , gsoplength , vlength , vsharplength , curlen ; <NEW_LINE>
if ( pending_vrdisplay_raf_ && ! display_blurred_ ) { <NEW_LINE>
while ( indexw < width && collen > 0 ) <NEW_LINE>
if ( syscall_nr < 0 || syscall_nr >= NR_syscalls ) <NEW_LINE>
! capable_wrt_inode_uidgid ( VFS_I ( ip ) , CAP_FSETID ) ) <NEW_LINE>
if ( data_len > MT_PACKET_LEN - 4 - packet -> size ) { <NEW_LINE>
<NEW_LINE><NEW_LINE>nsCOMPtr < nsIDocShellTreeItem > dsti ( do_QueryInterface ( aContainer ) ) ; <NEW_LINE>if ( dsti ) { <NEW_LINE>PRBool isMsgPane = PR_FALSE ; <NEW_LINE>dsti -> NameEquals ( NS_LITERAL_STRING ( "messagepane" ) . get ( ) , & isMsgPane ) ; <NEW_LINE>if ( isMsgPane ) { <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE><NEW_LINE>
<NEW_LINE>
if ( oldChild -> isOutOfFlowPositioned ( ) && owner -> childrenInline ( ) ) <NEW_LINE>
pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int32_t ) ) { <NEW_LINE>
for ( uint32_t c = mGIFStruct . width ; c > 0 ; c -- ) { <NEW_LINE> * -- to = cmap [ * -- from ] ; <NEW_LINE>
memcpy ( dst , src , 8 ) ; <NEW_LINE><NEW_LINE>
goto exit ; <NEW_LINE>
if ( ! mCanvasElement && ! mDocShell ) { <NEW_LINE>NS_ERROR ( "No canvas element and no docshell in GetImageData ! ! ! " ) ; <NEW_LINE>return NS_ERROR_DOM_SECURITY_ERR ; <NEW_LINE> } <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( mCanvasElement && <NEW_LINE>mCanvasElement -> IsWriteOnly ( ) && <NEW_LINE> ! nsContentUtils::IsCallerTrustedForRead ( ) ) <NEW_LINE> { <NEW_LINE>
apr_size_t len , int linelimit ) <NEW_LINE>
#include "base / callback_old . h" <NEW_LINE>
lir -> insStorei ( INS_CONSTPTR ( NULL ) , lirbuf -> state , offsetof ( InterpState , nativeVp ) ) ; <NEW_LINE>
<NEW_LINE>
kvm_iommu_unmap_pages ( kvm , memslot ) ; <NEW_LINE>
} else if ( new_size != 0 ) { <NEW_LINE>
ScanAsSpace ( c ) ) { <NEW_LINE>
allowLoad = CheckJavaCodebase ( ) ; <NEW_LINE>
} else { <NEW_LINE>
SensorReadingSharedBuffer * GetSensorReadingSharedBufferForType ( <NEW_LINE>
nsresult rv = proxyEnv . getOrSetFakeOrigin ( ( nsCSecurityContext * ) securityContext ) ; <NEW_LINE>if ( NS_SUCCEEDED ( rv ) ) <NEW_LINE>rv = secureEnv -> CallMethod ( method -> mReturnType , obj , method -> mMethodID , args , & outValue , securityContext ) ; <NEW_LINE>
const LayoutUnit cw = isOutOfFlowPositioned ( ) ? containingBlockLogicalWidthForPositioned ( toRenderBoxModelObject ( container ( ) ) ) : containingBlockLogicalWidthForContent ( ) ; <NEW_LINE>
void SetScrollbarEnabled ( nsIContent * aContent , nscoord aMaxPos ) ; <NEW_LINE>
registerMockedHttpURLLoad ( "pageserializer / green_rectangle . svg" ) ; <NEW_LINE>
IPC_STRUCT_MEMBER ( GURL , opener_security_origin )
<NEW_LINE>
state = nfs4_do_open ( dir , & path , fmode , flags , sattr , cred ) ; <NEW_LINE>
} ; <NEW_LINE>
new nsDOMDataTransfer ( NS_DRAGDROP_START , false , - 1 ) ; <NEW_LINE>
buf = g_malloc0 ( size ) ; <NEW_LINE>
if ( ! fval . isObject ( ) || ! fval . toObject ( ) . is < JSFunction > ( ) || <NEW_LINE> ! fval . toObject ( ) . as < JSFunction > ( ) . isNative ( ) || <NEW_LINE> ! fval . toObject ( ) . as < JSFunction > ( ) . jitInfo ( ) ) <NEW_LINE> { <NEW_LINE>RootedObject thisObj ( cx , & args . thisv ( ) . toObject ( ) ) ; <NEW_LINE>JSObject * thisp = JSObject::thisObject ( cx , thisObj ) ; <NEW_LINE>if ( ! thisp ) <NEW_LINE>return false ; <NEW_LINE>args . setThis ( ObjectValue ( * thisp ) ) ; <NEW_LINE> } <NEW_LINE>
static LPCWSTR delayDLLs [ ] = { L"wsock32 . dll" , L"crypt32 . dll" , <NEW_LINE>L"cryptsp . dll" , L"cryptbase . dll" , <NEW_LINE>L"msasn1 . dll" , L"userenv . dll" , <NEW_LINE>L"secur32 . dll" } ; <NEW_LINE><NEW_LINE>
static const interp_kernel filteredinterp_filters500 [ ( 1 << SUBPEL_BITS ) ] = { <NEW_LINE>
void vp9_encode_mv ( VP9_COMP * cpi , vpx_writer * w , <NEW_LINE>
bool RenderMenuList::multiple ( ) const <NEW_LINE>
void SetRenderer ( int process_host_id , <NEW_LINE>
mContent -> GetAttr ( kNameSpaceID_None , nsGkAtoms::data , data ) && <NEW_LINE> ! data . IsEmpty ( ) ) { <NEW_LINE>
if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' && <NEW_LINE>strcmp ( conn_opt -> keyword , "dbname" ) != 0 ) <NEW_LINE>
<NEW_LINE>
ThrowPDFException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE>
} <NEW_LINE>if ( mCachedBandPosition == prevRect ) { <NEW_LINE><NEW_LINE>SetCachedBandPosition ( band ) ; <NEW_LINE>
for ( ObjectValueMap::Range r = table -> map . all ( ) ; ! r . empty ( ) ; r . popFront ( ) ) { <NEW_LINE>
static void read_frame_reference_mode_probs ( VP9_COMMON * cm , vpx_reader * r ) { <NEW_LINE>FRAME_CONTEXT * const fc = cm -> fc ; <NEW_LINE>
<NEW_LINE>if ( group_leader -> ctx -> task != ctx -> task ) <NEW_LINE>goto err_context ; <NEW_LINE><NEW_LINE><NEW_LINE>if ( group_leader -> cpu != event -> cpu ) <NEW_LINE>
} else if ( mozilla::dom::IsDOMClass ( js::GetObjectJSClass ( obj ) ) && <NEW_LINE>mozilla::dom::DOMJSClass::FromJSClass ( <NEW_LINE>js::GetObjectJSClass ( obj ) ) -> mDOMObjectIsISupports ) { <NEW_LINE>
mprWriteJsonObj ( route -> config , "app . http . auth . auto . abilities" , job ) ; <NEW_LINE>
* best_mv = tmp_mv ; <NEW_LINE>
if ( pCmdData == NULL || <NEW_LINE>cmdSize != ( sizeof ( effect_param_t ) + sizeof ( int32_t ) + sizeof ( int16_t ) ) || <NEW_LINE>pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int32_t ) ) { <NEW_LINE>
const TransformPaintPropertyNode & scroll_offset ) ; <NEW_LINE>
p -> data + p -> psize , <NEW_LINE>p -> vsize ) ; <NEW_LINE>
mask_16x16_1 | mask_8x8_1 | mask_4x4_1 | mask_4x4_int_1 ; <NEW_LINE>mask ; mask >> = 1 ) { <NEW_LINE>
while ( ! kthread_freezable_should_stop ( NULL ) ) { <NEW_LINE><NEW_LINE>if ( signal_pending ( current ) ) <NEW_LINE>flush_signals ( current ) ; <NEW_LINE>
if ( ( bitmap_caret + ( encoded_pixels * pixel_block_size ) ) > image_block_size <NEW_LINE> || buffer_caret + ( encoded_pixels * pixel_block_size ) > rle_size ) { <NEW_LINE>
if ( ! _gdImageWBMPCtx ( im , fg , out ) ) { <NEW_LINE>rv = gdDPExtractData ( out , size ) ; <NEW_LINE> } else { <NEW_LINE>rv = NULL ; <NEW_LINE> } <NEW_LINE>
png_ptr = png_create_read_struct ( png_get_libpng_ver ( NULL ) , NULL , NULL , <NEW_LINE>NULL ) ; <NEW_LINE>
Ar = GetCacheViewVirtualPixels ( Ar_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE>Ai = GetCacheViewVirtualPixels ( Ai_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE>Br = GetCacheViewVirtualPixels ( Br_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE>Bi = GetCacheViewVirtualPixels ( Bi_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE>
} else if ( ( value = mprReadJson ( rx -> params , key ) ) != 0 ) { <NEW_LINE>
if ( ! PS ( use_only_cookies ) && ! PS ( id ) && <NEW_LINE>
mObj = UnwrapArray ( obj ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>inline void ComputeData ( ) const { <NEW_LINE>MOZ_ASSERT ( inited ( ) ) ; <NEW_LINE>if ( ! mComputed ) { <NEW_LINE>GetLengthAndData ( mObj , & mLength , & mData ) ; <NEW_LINE>mComputed = true ; <NEW_LINE> } <NEW_LINE>
swap ( tr -> trace_buffer . buffer , tr -> max_buffer . buffer ) ; <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
vpx_active_map_t map = { 0 , 0 , 0 } ; <NEW_LINE>
SCLogDebug ( "FIXME: DecodeTunnel: protocol % " PRIu32 " not supported . " , proto ) ; <NEW_LINE>
vp9_coeff_stats * coef_branch_ct , <NEW_LINE>vp9_coeff_probs_model * coef_probs ) { <NEW_LINE>vp9_coeff_count * coef_counts = cpi -> td . rd_counts . coef_counts [ tx_size ] ; <NEW_LINE>
if ( * src == '\\' && src [ 1 ] ) { <NEW_LINE>
ALOGE ( "b / 29421675 , nFilledLen overflow % llu w % u h % u" , <NEW_LINE> ( unsigned long long ) nFilledLen , width , height ) ; <NEW_LINE>
if ( c == EOF ) <NEW_LINE>
_wfopen_s ( & fp , path , L"rb" ) ; <NEW_LINE>
INT64_FIELDS_COUNT = INT64_FIELDS_END , <NEW_LINE>ID_FIELDS_BEGIN = INT64_FIELDS_END , <NEW_LINE>
url::Origin origin ; <NEW_LINE>
stream -> bufbase_ = JAS_CAST ( jas_uchar * , buf ) ; <NEW_LINE>
BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; <NEW_LINE>
mDecodingMonitor ( "RasterImage Decoding Monitor" ) , <NEW_LINE>
nickname = NULL ; <NEW_LINE>
iadst16_dspr2 ( outptr , temp_out ) ; <NEW_LINE>
NODE_NEEDS_FRAME | <NEW_LINE>NODE_CHROME_ONLY_ACCESS ) ) || <NEW_LINE>
<NEW_LINE><NEW_LINE>bool result = mPusher . Push ( mCx , nsCxPusher::REQUIRE_SCRIPT_CONTEXT ) ; <NEW_LINE>
void vp8_pack_tokens ( vp8_writer * w , const TOKENEXTRA * p , int xcount ) <NEW_LINE>
Frames = ReadBlobXXXLong ( image2 ) ; <NEW_LINE>if ( Frames == 0 ) <NEW_LINE>ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE>
rc = foreach_shareopt ( shareopts , get_linux_shareopts_cb , <NEW_LINE>
if ( clone_info != ( ImageInfo * ) NULL ) <NEW_LINE>clone_info = DestroyImageInfo ( clone_info ) ; <NEW_LINE>
int i , hasAdditionalBlocks , <NEW_LINE>
{ 0 , 0 , txFnStartEmbed , txFnEndEmbed } , <NEW_LINE>
ascii = safe_calloc ( str_len ) ; <NEW_LINE>
const vpx_prob vp9_kf_uv_mode_prob [ INTRA_MODES ] [ INTRA_MODES - 1 ] = { <NEW_LINE>
if ( ctxt -> instate != XML_PARSER_EOF ) <NEW_LINE>ctxt -> instate = state ; <NEW_LINE>
memset ( cpi -> frames , 0 , max_frames * sizeof ( YV12_BUFFER_CONFIG * ) ) ; <NEW_LINE>
<NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
const guchar * token , * next_token ; <NEW_LINE>
bool <NEW_LINE>
#line 1238 "ext / standard / var_unserializer . c" <NEW_LINE>
obj -> moveDenseArrayElements ( 0 , 1 , obj -> getDenseArrayInitializedLength ( ) - 1 ) ; <NEW_LINE>
<NEW_LINE>
nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>
const Entry & new_entry , <NEW_LINE>AddressListDeltaType delta ) ; <NEW_LINE>
memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
char buf [ L_BUFSIZE ] ; <NEW_LINE>
JSClass * jsclazz = si ? si -> GetJSClass ( ) : Jsvalify ( & XPC_WN_NoHelper_JSClass . base ) ; <NEW_LINE>
if ( ( png_ptr -> mng_features_permitted & PNG_FLAG_MNG_FILTER_64 ) != 0 && <NEW_LINE>
<NEW_LINE>
const gfx::Size & output_size , <NEW_LINE>
virtual void TabDetachedAt ( content::WebContents * contents , <NEW_LINE>int index ) OVERRIDE ; <NEW_LINE>
memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE>
dy %= CDG_SCREEN_HEIGHT ; <NEW_LINE>dx %= CDG_SCREEN_WIDTH ; <NEW_LINE>
if ( GetStyleSheet ( ) ) { <NEW_LINE>nsCOMPtr < nsIDOMStyleSheet > ss ( do_QueryInterface ( GetStyleSheet ( ) ) ) ; <NEW_LINE>
#include "base / profiler / scoped_profile . h" <NEW_LINE>
if ( set_location ( png_ptr , my_user_chunk_data , have_sTER ) != 0 ) <NEW_LINE>
return SetUTCTime ( cx , obj , TIMECLIP ( result ) , vp ) ; <NEW_LINE>
int64 offset , int64 content_length , const base::Closure & job_canceller ) ; <NEW_LINE>
<NEW_LINE>
int test_main ( int argc , char ** argv ) ;
ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ; <NEW_LINE>if ( ret == - 1 ) <NEW_LINE>goto trunc ; <NEW_LINE>if ( ret == TRUE ) <NEW_LINE>
<NEW_LINE><NEW_LINE>pixels -> ComputeLengthAndData ( ) ; <NEW_LINE><NEW_LINE>uint32_t dataByteLen = pixels -> Length ( ) ; <NEW_LINE>
class VP9Picture : public base::RefCountedThreadSafe < VP9Picture > { <NEW_LINE>
if ( gamma_correction != 0 ) <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>void Document::InitContentSecurityPolicy ( <NEW_LINE>ContentSecurityPolicy * csp , <NEW_LINE>const ContentSecurityPolicy * policy_to_inherit ) { <NEW_LINE>
char combname [ L_BUFSIZE ] ; <NEW_LINE>
bufsize = MIN ( file -> size , sizeof buf ) ; <NEW_LINE>
nsXULContentUtils::MakeElementID ( this , nsDependentCString ( uri ) , id ) ; <NEW_LINE><NEW_LINE>if ( id . IsEmpty ( ) ) <NEW_LINE>continue ; <NEW_LINE>
for ( size_t i = 0 ; i < 4 ; ++ i ) { <NEW_LINE>
#include "platform / mediastream / MediaStreamSource . h" <NEW_LINE>
if ( HeapOverflowSanityCheck ( count , quantum ) != MagickFalse ) <NEW_LINE>
-- src ; <NEW_LINE>
HeapObjectHeader::fromPayload ( payload ) -> checkHeader ( ) ; <NEW_LINE>
char key [ 33 ] ; <NEW_LINE>snprintf ( key , sizeof ( key ) , "a = framesize: % lu" , PT ) ; <NEW_LINE>if ( PT > 9999999 ) { <NEW_LINE>android_errorWriteLog ( 0x534e4554 , "25747670" ) ; <NEW_LINE> } <NEW_LINE>
NS_NewOuterWindowProxy ( cx , xpc_UnmarkGrayObject ( newInnerWindow -> mJSObject ) ) ; <NEW_LINE>
void FireChromeDOMEvent ( nsIPresContext * aPresContext , const nsAString & aDOMEventName ) ; <NEW_LINE>
codebook * b , oggpack_buffer * opb , int maptype ) { <NEW_LINE>
<NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
for ( i = 0 ; i < max_value ; i ++ ) { <NEW_LINE>snprintf ( cur_key_name , 30 , " % s % d" , key_name , i ) ; <NEW_LINE>
C ( INVALID_VALUE , 	"Invalid value ( did you forget quotes ) ? " ) , \ <NEW_LINE>C ( NO_FILTER , 		"No filter found" ) , <NEW_LINE>
#define MAX_VIDEO_WIDTH 4000 <NEW_LINE>#define MAX_VIDEO_HEIGHT 3000 <NEW_LINE>
<NEW_LINE>
nsIIOService * serv , nsIPrincipal * principal , <NEW_LINE>JSObject ** scriptObjp ) ; <NEW_LINE>
<NEW_LINE>
CHAR_LEN_TABLE ( Big5CharLenTable ) , <NEW_LINE>
( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error && <NEW_LINE> ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) <NEW_LINE>
virtual void WriteInternal ( const char * aBuffer , uint32_t aCount , DecodeStrategy aStrategy ) ; <NEW_LINE>
PRUint64 countlong = ( aCount + 2 ) / 3 * 4 ; <NEW_LINE>if ( countlong + aOffset > PR_UINT32_MAX ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE><NEW_LINE>PRUint32 count = PRUint32 ( countlong ) ; <NEW_LINE><NEW_LINE>
unlock_page ( page ) ; <NEW_LINE>out_release: <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
<NEW_LINE>
BOOL pnm2png ( FILE * pnm_file , FILE * png_file , FILE * alpha_file , BOOL interlace , <NEW_LINE>BOOL alpha ) ; <NEW_LINE>
thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ; <NEW_LINE>
GetJSProtoObject ( ) const { return xpc_UnmarkGrayObject ( mJSProtoObject ) ; } <NEW_LINE>
( void ) ResetMagickMemory ( imbuf , background_color_index , ( size_t ) imsx * imsy ) ; <NEW_LINE>
std::make_unique < CanonicalCookie > ( <NEW_LINE>
static void show_psnr ( struct stream_state * stream , double peak ) { <NEW_LINE>
memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE>
MOCK_CONST_METHOD0 ( GetOriginalProfilePrefs , PrefService * ( ) ) ; <NEW_LINE>
int ret = TEMP_FAILURE_RETRY ( poll ( pfds , ts [ h ] . poll_count , - 1 ) ) ; <NEW_LINE>
#define RUN_SECCOMP_DIR	" / run / firejail / mnt / seccomp" <NEW_LINE>#define RUN_SECCOMP_LIST	" / run / firejail / mnt / seccomp / seccomp . list"	 <NEW_LINE>#define RUN_SECCOMP_PROTOCOL	" / run / firejail / mnt / seccomp / seccomp . protocol"	 <NEW_LINE>#define RUN_SECCOMP_CFG	" / run / firejail / mnt / seccomp / seccomp"			 <NEW_LINE>#define RUN_SECCOMP_32		" / run / firejail / mnt / seccomp / seccomp . 32"		 <NEW_LINE>#define RUN_SECCOMP_MDWX	" / run / firejail / mnt / seccomp / seccomp . mdwx"		 <NEW_LINE>#define RUN_SECCOMP_BLOCK_SECONDARY	" / run / firejail / mnt / seccomp / seccomp . block_secondary"	 <NEW_LINE>#define RUN_SECCOMP_POSTEXEC	" / run / firejail / mnt / seccomp / seccomp . postexec"		 <NEW_LINE>
if ( isExtensible ( ) ) <NEW_LINE>d . lengthAndFlags = buildLengthAndFlags ( length ( ) , FIXED_FLAGS ) ; <NEW_LINE>
#line 971 "ext / standard / var_unserializer . c" <NEW_LINE>
if ( ! EnsureStringLength ( output , resultLen ) ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE>
last mod: $ Id: ogg . h 17098 2010 - 03 - 29 05:35:11Z gmaxwell $ <NEW_LINE>
if ( theme ( ) -> shouldSnapBackToDragOrigin ( this , evt ) ) { <NEW_LINE>if ( m_scrollableArea ) <NEW_LINE>m_scrollableArea -> scrollToOffsetWithoutAnimation ( m_orientation , m_dragOrigin ) ; <NEW_LINE> } else { <NEW_LINE>
ReentrantMonitorAutoEnter lock ( mDecodingMonitor ) ; <NEW_LINE>
mSerial = issueSerial ( ) ; <NEW_LINE><NEW_LINE>
friend class base::RefCountedThreadSafe < VP9Picture > ; <NEW_LINE>
delete [ ] additional_ ; <NEW_LINE>
while ( 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) ) <NEW_LINE>
if ( inliningDepth_ == 0 ) { <NEW_LINE>
if ( png_colorspace_set_sRGB ( png_ptr , & info_ptr -> colorspace , <NEW_LINE>srgb_intent ) != 0 ) <NEW_LINE>
nsIContent * content = mElements [ i ] ; <NEW_LINE>
nsCOMPtr < nsPIDOMWindow > mWindow ; <NEW_LINE>
if ( ss -> ssl3 . hs . ws != wait_cert_verify ) { <NEW_LINE>
#include "components / search_provider_logos / logo_service_impl . h" <NEW_LINE>
thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ; <NEW_LINE>
GlyphCache::Loader::Loader ( const Face & face ) <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
DummyVideoSource ( ) <NEW_LINE>: img_ ( NULL ) , <NEW_LINE>limit_ ( 100 ) , <NEW_LINE>width_ ( 80 ) , <NEW_LINE>height_ ( 64 ) , <NEW_LINE>format_ ( VPX_IMG_FMT_I420 ) { <NEW_LINE>ReallocImage ( ) ; <NEW_LINE>
<NEW_LINE>SINGLE_AND_MULTI_THREAD_TEST_F ( CCLayerTreeHostTestShortlived2 ) <NEW_LINE>
( ( long long ) i * SQUASHFS_METADATA_SIZE ) ) ; <NEW_LINE>
if ( diff . needsFullLayout ( ) ) { <NEW_LINE>
void BaseRenderingContext2D::SetOriginTaintedByContent ( ) { <NEW_LINE>SetOriginTainted ( ) ; <NEW_LINE>origin_tainted_by_content_ = true ; <NEW_LINE>
const TX_SIZE tx_size_uv = get_uv_tx_size_impl ( tx_size_y , block_size , 1 , 1 ) ; <NEW_LINE>
DebugOnly < nsresult > result = mOmxDecoder -> Play ( ) ; <NEW_LINE>
AutoPushJSContext cx ( scx ? scx -> GetNativeContext ( ) : nullptr ) ; <NEW_LINE>
<NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
ReentrantMonitorAutoEnter lock ( aImg -> mDecodingMonitor ) ; <NEW_LINE>
void * srcbuf = cx -> malloc_ ( getByteLength ( tarray ) ) ; <NEW_LINE>
switch ( executionMode ) { <NEW_LINE>case SequentialExecution: <NEW_LINE>if ( cx -> zone ( ) -> needsBarrier ( ) ) <NEW_LINE>ionScript -> toggleBarriers ( true ) ; <NEW_LINE>break ; <NEW_LINE>case ParallelExecution: <NEW_LINE><NEW_LINE>break ; <NEW_LINE>default: <NEW_LINE>JS_NOT_REACHED ( "No such execution mode" ) ; <NEW_LINE> } <NEW_LINE>
ENGINE_SET_INVALID_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
HKEY baseKey = nullptr ; <NEW_LINE>
if ( ! s_check_rem ( s , length ) ) <NEW_LINE> { <NEW_LINE>rdp_protocol_error ( "cssp_read_tsrequest ( ) , consume of token from stream would overrun" , <NEW_LINE> & packet ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>s_realloc ( token , length ) ; <NEW_LINE>s_reset ( token ) ; <NEW_LINE>
void UpdateRasterSource ( scoped_refptr < RasterSource > raster_source , <NEW_LINE>Region * new_invalidation , <NEW_LINE>const PictureLayerTilingSet * pending_set ) ; <NEW_LINE>
char * p , * q ; <NEW_LINE>
if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || <NEW_LINE>pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
nsFrameState whichTextRunState = <NEW_LINE>startFrame -> GetTextRun ( nsTextFrame::eInflated ) == aTextRun <NEW_LINE> ? TEXT_IN_TEXTRUN_USER_DATA <NEW_LINE>: TEXT_IN_UNINFLATED_TEXTRUN_USER_DATA ; <NEW_LINE>startFrame -> AddStateBits ( whichTextRunState ) ; <NEW_LINE>
#endif
txCheckParam * checkParam = <NEW_LINE>static_cast < txCheckParam * > ( aState . popPtr ( aState . eCheckParam ) ) ; <NEW_LINE>
<NEW_LINE>class MemoryObjectInfo ; <NEW_LINE><NEW_LINE>
friend class base::RefCountedThreadSafe < VP8Picture > ; <NEW_LINE>
#ifdef DEBUG <NEW_LINE><NEW_LINE>#define PARENT_WAIT 30000 <NEW_LINE>#else <NEW_LINE>#define PARENT_WAIT 10000 <NEW_LINE>#endif <NEW_LINE>
if ( png_ptr != NULL && info_ptr != NULL && <NEW_LINE> ( info_ptr -> valid & PNG_INFO_sRGB ) != 0 && file_srgb_intent != NULL ) <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) <NEW_LINE> { <NEW_LINE>for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) <NEW_LINE> { <NEW_LINE>ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; <NEW_LINE> } <NEW_LINE>else <NEW_LINE> { <NEW_LINE>ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <NEW_LINE>u4_payload_size ) ; <NEW_LINE> } <NEW_LINE>
#include "platform / mediastream / MediaStreamSource . h" <NEW_LINE>
#include "platform / win / HWndDC . h" <NEW_LINE>
ret = get_tmp_filename ( tmp_filename , sizeof ( tmp_filename ) ) ; <NEW_LINE>if ( ret < 0 ) { <NEW_LINE>return ret ; <NEW_LINE> } <NEW_LINE>
cx -> compartment -> wrap ( cx , props ) ) ; <NEW_LINE>
in_what -> stride ) ; <NEW_LINE>
ConfirmationRequired display_confirmation , <NEW_LINE>SyncPromoUI::Source source ) ; <NEW_LINE>
#ifndef BASE_TIME_CLOCK_H_ <NEW_LINE>#define BASE_TIME_CLOCK_H_ <NEW_LINE>
ReportBadReturn ( cx , tc , pn , JSREPORT_WARNING | JSREPORT_STRICT , <NEW_LINE>
memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ; <NEW_LINE>
if ( m_provisionalDocumentLoader ) { <NEW_LINE>FrameNavigationDisabler navigationDisabler ( * m_frame ) ; <NEW_LINE>detachDocumentLoader ( m_provisionalDocumentLoader ) ; <NEW_LINE> }
fprintf ( STDERR , " % lu bytes at % p\n" , <NEW_LINE> ( unsigned long ) pinfo -> size , pinfo -> pointer ) ; <NEW_LINE>
#ifndef BASE_TIME_TICK_CLOCK_H_ <NEW_LINE>#define BASE_TIME_TICK_CLOCK_H_ <NEW_LINE>
if ( XDRAtomsHashMap::Ptr p = xdr -> state -> atomsMap . lookup ( atom ) ) <NEW_LINE>
if ( aParams . isObject ( ) ) { <NEW_LINE>
retval = htc_request_check_hdrs ( sp , hp ) ; <NEW_LINE>
#include " . / vpx_dsp_rtcd . h" <NEW_LINE>
snprintf ( buf , L_BUFSIZE , <NEW_LINE>
ND_TCHECK ( dp [ 0 ] ) ; <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
if ( buffer + 24 > endbuffer ) { <NEW_LINE>
if ( ! document ( ) . contentSecurityPolicy ( ) -> allowFormAction ( <NEW_LINE>submission -> action ( ) ) ) { <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
strncpy ( rl . type , "larval" , sizeof ( rl . type ) ) ; <NEW_LINE>
RefPtr < TestNode > imp = WTF::getPtr ( proxyImp -> location ( ) ) ; <NEW_LINE>
if ( ! _gdImageGifCtx ( im , out ) ) { <NEW_LINE>rv = gdDPExtractData ( out , size ) ; <NEW_LINE> } else { <NEW_LINE>rv = NULL ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
COS_LOOKUP_I_SHIFT ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>KEYBOARD_EXPORT extern const char kSmartVirtualKeyboard [ ] ; <NEW_LINE><NEW_LINE><NEW_LINE>KEYBOARD_EXPORT extern const char kSmartVirtualKeyboardEnabled [ ] ; <NEW_LINE><NEW_LINE><NEW_LINE>KEYBOARD_EXPORT extern const char kSmartVirtualKeyboardDisabled [ ] ; <NEW_LINE>
bool ms_verify_authorizer ( <NEW_LINE>Connection * con , <NEW_LINE>int peer_type , <NEW_LINE>int protocol , <NEW_LINE>ceph::bufferlist & authorizer , <NEW_LINE>ceph::bufferlist & authorizer_reply , <NEW_LINE>bool & isvalid , <NEW_LINE>CryptoKey & session_key , <NEW_LINE>std::unique_ptr < AuthAuthorizerChallenge > * challenge ) override ; <NEW_LINE>
mozAutoRemovableBlockerRemover blockerRemover ( container -> GetOwnerDoc ( ) ) ; <NEW_LINE>
static void watchdog_overflow_callback ( struct perf_event * event , <NEW_LINE>
void SetRenderer ( int process_host_id , <NEW_LINE>
rootPresContext -> RequestUpdatePluginGeometry ( ) ; <NEW_LINE>
if ( width == 0 || height == 0 ) { <NEW_LINE>DummyFramebufferOperation ( "readPixels" ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
#include "third_party / blink / renderer / platform / graphics / paint / property_tree_state . h" <NEW_LINE>
SetUTCTime ( cx , obj , UTC ( local ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>PRBool multipart = PR_TRUE ; <NEW_LINE>if ( NS_SUCCEEDED ( mImageLoad -> GetIsMultiPartChannel ( & multipart ) ) && ! multipart ) { <NEW_LINE>nsresult result = mImage -> SetDiscardable ( "image / jpeg" ) ; <NEW_LINE>if ( NS_FAILED ( result ) ) { <NEW_LINE>mState = JPEG_ERROR ; <NEW_LINE>PR_LOG ( gJPEGDecoderAccountingLog , PR_LOG_DEBUG , <NEW_LINE> ( " ( could not set image container to discardable ) " ) ) ; <NEW_LINE>return result ; <NEW_LINE> } <NEW_LINE>
HeapObjectHeader::fromPayload ( m_raw ) -> checkHeader ( ) ; <NEW_LINE>
ErrorResult rv ; <NEW_LINE>output = event -> GetOutputBuffer ( rv ) -> GetThreadSharedChannelsForRate ( cx ) ; <NEW_LINE>
return cx -> compartment -> wrap ( cx , & srcArgs . rval ( ) ) ; <NEW_LINE>
mDecodingMonitor . AssertCurrentThreadIn ( ) ; <NEW_LINE>
memcpy ( cpi -> segment_feature_data , feature_data , sizeof ( cpi -> segment_feature_data ) ) ; <NEW_LINE>
map -> Add ( wn -> GetScope ( ) -> GetWrapperMap ( ) , wrappedObj , outerObj ) ; <NEW_LINE>
goto out_release ; <NEW_LINE>
NS_ENSURE_STATE ( pusher . Push ( ctx , nsCxPusher::ALWAYS_PUSH ) ) ; <NEW_LINE>
const vpx_prob vp9_pareto8_full [ COEFF_PROB_MODELS ] [ MODEL_NODES ] = { <NEW_LINE>
vpx_fixed_buf_t cx_data_dst_buf ; <NEW_LINE>
if ( flattens_inherited_transform != other . flattens_inherited_transform || <NEW_LINE>
void vp9_setup_dst_planes ( struct macroblockd_plane planes [ MAX_MB_PLANE ] , <NEW_LINE>const YV12_BUFFER_CONFIG * src , <NEW_LINE>
const GURL & requestor_url ) ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
int ret = TEMP_FAILURE_RETRY ( write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ) ; <NEW_LINE>
out: <NEW_LINE>dput ( dentry ) ; <NEW_LINE>mntput ( mqueue_mnt ) ; <NEW_LINE>
ENGINE_SET_INVALID_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <NEW_LINE>
if ( ! mCopyToOmx ) { <NEW_LINE>
last mod: $ Id: lpc . h 16037 2009 - 05 - 26 21:10:58Z xiphmont $ <NEW_LINE>
free ( now ) ; <NEW_LINE>
ThrowDCMException ( CorruptImageError , <NEW_LINE>
last mod: $ Id: codec . h 16037 2009 - 05 - 26 21:10:58Z xiphmont $ <NEW_LINE>
memcpy ( ImmediateDataAddress ( this ) , _value , <NEW_LINE>ComputeEffectiveDataSize ( buffer ) ) ; <NEW_LINE>DCHECK_GE ( ComputeDataSize ( ) , ComputeEffectiveDataSize ( buffer ) ) ; <NEW_LINE>char * pointer = reinterpret_cast < char * > ( ImmediateDataAddress ( this ) ) + <NEW_LINE>ComputeEffectiveDataSize ( buffer ) ; <NEW_LINE>memset ( pointer , 0 , ComputeDataSize ( ) - ComputeEffectiveDataSize ( buffer ) ) ; <NEW_LINE>
delete [ ] header ; <NEW_LINE>
SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
jas_uchar buf [ RAS_MAGICLEN ] ; <NEW_LINE>
} <NEW_LINE>
tcmur_unregister_dbus_handler ( handler ) ; <NEW_LINE>
} while ( fp != target && ( fp = JS_FrameIterator ( cx , & fp ) ) != nsnull ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( parentFrame -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) { <NEW_LINE>nsPlaceholderFrame * placeholderFrame = <NEW_LINE>state . mFrameManager -> GetPlaceholderFrameFor ( parentFrame ) ; <NEW_LINE>NS_ASSERTION ( placeholderFrame , "No placeholder for out - of - flow ? " ) ; <NEW_LINE>parentFrame = placeholderFrame -> GetParent ( ) ; <NEW_LINE> } else { <NEW_LINE>parentFrame = parentFrame -> GetParent ( ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
NS_RUNTIMEABORT ( "ReadbackManager: Task thread did not shutdown in 5 seconds . " ) ; <NEW_LINE>
mHTMLDocument = do_QueryInterface ( aDoc ) ; <NEW_LINE>
tok , next , & next , XML_FALSE , XML_FALSE ) ; <NEW_LINE>
memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <NEW_LINE>
scoped_refptr < const ComputedStyle > root_element_style_ ; <NEW_LINE>
return mount_entry_on_generic ( mntent , path , rootfs -> mount ) ; <NEW_LINE>
SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
float * valuelist ; <NEW_LINE>
OwnPtr < InspectorResourceAgent > resourceAgentPtr ( InspectorResourceAgent::create ( m_pageAgent ) ) ; <NEW_LINE>
for ( i = 0 ; i < oxcf -> number_of_layers && i < VPX_TS_MAX_LAYERS ; ++ i ) <NEW_LINE>
@stability Evolving <NEW_LINE>
WriteUIntSize ( writer , segment_size , 8 ) || writer -> Position ( pos ) ) <NEW_LINE>
if ( isnonalpha ( c ) != 0 ) <NEW_LINE>
memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <NEW_LINE>
memcpy ( & tmp_frame , & first_frame , sizeof ( first_frame ) ) ; <NEW_LINE>
if ( ! attachedStub && ShouldAttachGetElemTypedArray ( obj , idval , cache . output ( ) ) ) { <NEW_LINE>if ( ! cache . attachTypedArrayElement ( cx , ion , obj , idval ) ) <NEW_LINE>return false ; <NEW_LINE>attachedStub = true ; <NEW_LINE>
ClearCloneReadInfo ( StructuredCloneReadInfo & aReadInfo ) ; <NEW_LINE><NEW_LINE>static void <NEW_LINE>ClearCloneWriteInfo ( StructuredCloneWriteInfo & aWriteInfo ) ; <NEW_LINE>
#if CONFIG_SPATIAL_SVC <NEW_LINE>#include "vpx / vp8cx . h" <NEW_LINE>#include "vpx / vpx_encoder . h" <NEW_LINE>#endif <NEW_LINE><NEW_LINE>
if ( ( err = TEMP_FAILURE_RETRY ( ioctl ( fd , TUNSETIFF , ( void * ) & ifr ) ) ) < 0 ) <NEW_LINE>
nsLayoutUtils::IGNORE_PAINT_SUPPRESSION | nsLayoutUtils::IGNORE_CROSS_DOC | <NEW_LINE>
PrefChangeRegistrar registrar_ ; <NEW_LINE><NEW_LINE>
for ( i = 0 ; ( i + 7 ) < sec -> size ; i += 8 ) { <NEW_LINE>
if ( i + bs > ( int ) rec -> length ) <NEW_LINE>
if ( yych <= ' / ' ) goto yy18 ; <NEW_LINE>if ( yych >= ' ; ' ) goto yy18 ; <NEW_LINE>
return TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ; <NEW_LINE>
AutoPushJSContext cx ( scriptContext -> GetNativeContext ( ) ) ; <NEW_LINE>
} else <NEW_LINE>memset ( kdata , 0 , _IOC_SIZE ( cmd ) ) ; <NEW_LINE><NEW_LINE>
NS_ENSURE_STATE ( pusher . Push ( cx , nsCxPusher::ALWAYS_PUSH ) ) ; <NEW_LINE>
strncpy ( rcipher . type , "cipher" , sizeof ( rcipher . type ) ) ; <NEW_LINE>
s -> frame -> nb_samples = s -> frames * MPA_FRAME_SIZE ; <NEW_LINE>
if ( ( base_format & PNG_FORMAT_FLAG_ALPHA ) != 0 ) <NEW_LINE>
enableHyperlinkAuditing , enableFullscreen , enableDNSPrefetching , <NEW_LINE>enableSpellChecking ; <NEW_LINE>
WRITE32 ( 0 ) ; <NEW_LINE>
unsigned int x , y ; <NEW_LINE>volatile unsigned int ip = 0 ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
already_AddRefed < WebGLUniformLocation > GetUniformLocationObject ( WebGLProgram * prog , GLint glLocation ) ; <NEW_LINE>
couldRecur ( v , subarr1 . get ( ) ) , <NEW_LINE>
int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] , int this_mode , <NEW_LINE>const MV_REFERENCE_FRAME ref_frames [ 2 ] ) { <NEW_LINE>if ( ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && <NEW_LINE>frame_mv [ this_mode ] [ ref_frames [ 0 ] ] . as_int == 0 && <NEW_LINE> ( ref_frames [ 1 ] == NONE || <NEW_LINE>frame_mv [ this_mode ] [ ref_frames [ 1 ] ] . as_int == 0 ) ) { <NEW_LINE>int rfc = mode_context [ ref_frames [ 0 ] ] ; <NEW_LINE>
last mod: $ Id: framing . c 17269 2010 - 06 - 04 05:39:45Z xiphmont $ <NEW_LINE>
nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE>
if ( XrayUtils::IsTransparent ( cx , wrapper , id ) ) { <NEW_LINE>
JSString * str = Int32ToString ( cx , JSID_TO_INT ( id ) ) ; <NEW_LINE>
nsTArray < nsCOMPtr < nsIDOMElement > > spanCellList ; <NEW_LINE>
flags , notecount ) ; <NEW_LINE>
for ( ; ; ) <NEW_LINE>
MarkupFormatter::appendComment ( result , PageSerializer::markOfTheWebDeclaration ( document ( ) . url ( ) ) ) ; <NEW_LINE>
( header . colormap_entries == 0 ) ) <NEW_LINE>
already_AddRefed < DOMSVGPathSeg > GetItem ( uint32_t index , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE>already_AddRefed < DOMSVGPathSeg > IndexedGetter ( uint32_t index , bool & found , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE>
* to a file so it could be read back and the hmac recomputed <NEW_LINE> * and verified . doesn't seem to be a way for both encoding <NEW_LINE>
if ( vector . insertAt ( ( size_t ) 0 , size ) < 0 ) { <NEW_LINE>vector . clear ( ) ; <NEW_LINE> } <NEW_LINE>if ( data . read ( vector . editArray ( ) , size ) != NO_ERROR ) { <NEW_LINE>vector . clear ( ) ; <NEW_LINE>android_errorWriteWithInfoLog ( 0x534e4554 , "62872384" , - 1 , NULL , 0 ) ; <NEW_LINE> } <NEW_LINE>
NS_ENSURE_TRUE ( mCallback . ToJSObject ( ) , JS_FALSE ) ; <NEW_LINE>JSAutoCompartment ac ( mCx , mCallback . ToJSObject ( ) ) ; <NEW_LINE>JS::Rooted < JSObject * > global ( mCx , JS_GetGlobalForScopeChain ( mCx ) ) ; <NEW_LINE>
if ( ! V8ScriptRunner::callInternalFunction ( v8::Local < v8::Function > ::Cast ( initializeFunction ) , holder , 0 , 0 , isolate ) . ToLocal ( & result ) ) { <NEW_LINE>
return mElements . SafeObjectAt ( aIndex ) ; <NEW_LINE>
if ( u4_numCoeffs > 64 ) <NEW_LINE> { <NEW_LINE>return IMPEG2D_MB_TEX_DECODE_ERR ; <NEW_LINE> } <NEW_LINE>
TestInterfaceNode * impl = V8TestInterfaceNode::toImpl ( holder ) ; <NEW_LINE>
for ( col = 0 ; col < imagewidth && colb < imagew ; col += tw ) {
CONTENT_EXPORT void OnAllowBindings ( int enabled_bindings_flags ) ; <NEW_LINE>
result = append_key_value ( loc_name , hash_arr , LOC_LANG_TAG ) ; <NEW_LINE>
zlib -> file_bits = 24 ; <NEW_LINE>
if ( ! js_XDRScriptAndSubscripts ( xdr , & fun -> u . i . script ) ) <NEW_LINE>
if ( ( abs ( x ) * dequant_ptr [ rc != 0 ] > abs ( coeff [ rc ] ) * mul ) && <NEW_LINE> ( abs ( x ) * dequant_ptr [ rc != 0 ] < abs ( coeff [ rc ] ) * mul + <NEW_LINE>dequant_ptr [ rc != 0 ] ) ) <NEW_LINE>
if ( ! logicalHeightLength . isPercent ( ) || replaced -> isOutOfFlowPositioned ( ) || replaced -> document ( ) -> inQuirksMode ( ) ) <NEW_LINE>
void SetQuotes ( PRBool aNotify ) ; <NEW_LINE>
if ( ( diff . needsRepaint ( ) || diff . needsLayout ( ) ) && node ( ) <NEW_LINE> && ( isHTMLHtmlElement ( * node ( ) ) || isHTMLBodyElement ( * node ( ) ) ) ) { <NEW_LINE>
if ( png_ptr -> read_buffer != 0 ) <NEW_LINE>
<NEW_LINE>already_AddRefed < nsIDOMSVGLength > GetItemAt ( uint32_t aIndex ) ; <NEW_LINE>
inline void SetDestroyJSContextInDestructor ( ) ; <NEW_LINE>
static INLINE void right_shift_8x8 ( __m128i * res , const int bit ) { <NEW_LINE>
last mod: $ Id: lookup_data . h 16037 2009 - 05 - 26 21:10:58Z xiphmont $ <NEW_LINE>
qemu_get_be32s ( f , & nb_cpus ) ; <NEW_LINE>if ( opp -> nb_cpus != nb_cpus ) { <NEW_LINE>return - EINVAL ; <NEW_LINE> } <NEW_LINE>assert ( nb_cpus > 0 && nb_cpus <= MAX_CPU ) ; <NEW_LINE>
nsCOMPtr < nsIContent > content = do_QueryInterface ( mCanvasElement ) ; <NEW_LINE>
AutoObjectRooter tvr ( cx , obj ) ; <NEW_LINE>
gpio_dev -> pctrl = devm_pinctrl_register ( & pdev -> dev , & amd_pinctrl_desc , <NEW_LINE>gpio_dev ) ; <NEW_LINE>
if ( last_row != ( unsigned char * ) NULL ) <NEW_LINE>last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row ) ; <NEW_LINE>
if ( mIsDocumentObserver ) { <NEW_LINE><NEW_LINE><NEW_LINE>if ( aType >= Flush_ContentAndNotify ) { <NEW_LINE>FlushTags ( ) ; <NEW_LINE> } <NEW_LINE>else { <NEW_LINE>FlushText ( PR_FALSE ) ; <NEW_LINE> } <NEW_LINE>
if ( tlen < 1U + oid_len ) { <NEW_LINE>
<NEW_LINE>
memset ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <NEW_LINE>
static INLINE void write_buffer_4x4 ( tran_low_t * output , __m128i * res ) { <NEW_LINE>
MOZ_ASSERT ( ! IsWrapper ( obj ) || <NEW_LINE>GetProxyHandler ( obj ) == & XrayWaiver || <NEW_LINE>js::GetObjectClass ( obj ) -> ext . innerObject , <NEW_LINE>"wrapped object passed to rewrap" ) ; <NEW_LINE>MOZ_ASSERT ( JS_GetClass ( obj ) != & XrayUtils::HolderClass , "trying to wrap a holder" ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
if ( equalIgnoringASCIICase ( object -> getAttribute ( aria_hiddenAttr ) , "true" ) ) <NEW_LINE>
pval *= fixed_divide [ count [ k ] ] ; <NEW_LINE>
else if ( ps_dec -> u4_first_slice_in_pic ) <NEW_LINE>
<NEW_LINE>
++ len_req ; <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
int i , s , t ; <NEW_LINE>
mArray [ i ] -> GetRange ( getter_AddRefs ( myRange ) ) ; <NEW_LINE>aSelState -> mArray [ i ] -> GetRange ( getter_AddRefs ( itsRange ) ) ; <NEW_LINE>
NotifyTimeDependentsParams params = { this , container } ; <NEW_LINE>
profile_size = ( ( png_uint_32 ) ( * ( pC ) << 24 ) ) | <NEW_LINE> ( ( png_uint_32 ) ( * ( pC + 1 ) << 16 ) ) | <NEW_LINE> ( ( png_uint_32 ) ( * ( pC + 2 ) << 8 ) ) | <NEW_LINE> ( ( png_uint_32 ) ( * ( pC + 3 ) ) ) ; <NEW_LINE>
{ <NEW_LINE>nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>mFrameConstructor -> ProcessPendingRestyles ( ) ; <NEW_LINE> } <NEW_LINE>
nullptr , <NEW_LINE>
! validated_urls_ . Contains ( resource -> Url ( ) ) ) { <NEW_LINE>
inline bool SafeAddUint32 ( uint32 a , uint32 b , uint32 * dst ) { <NEW_LINE>
<NEW_LINE>rv = xpc -> CreateSandbox ( cx , nullptr , getter_AddRefs ( sandbox ) ) ; <NEW_LINE>
return vpx_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ; <NEW_LINE>
<NEW_LINE>
v8::Local < v8::Object > creationContext ( thisValue . v8Value ( ) . As < v8::Object > ( ) ) ; <NEW_LINE>
return js_calloc_members ( items , size ) ; <NEW_LINE>
nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>
const scoped_refptr < VideoFrame > & frame ) ;
{ <NEW_LINE>if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) <NEW_LINE>return count ; <NEW_LINE><NEW_LINE>switch ( c ) <NEW_LINE>
<NEW_LINE>
#include "vpx / vpx_codec . h" <NEW_LINE>#include "vp9 / common / vp9_seg_common . h" <NEW_LINE>
ogg_packet * op ) { <NEW_LINE>
if ( ! sb || ( EXT4_SB ( sb ) -> s_journal && <NEW_LINE>EXT4_SB ( sb ) -> s_journal -> j_flags & JBD2_ABORT ) ) <NEW_LINE>
SetUTCTime ( cx , obj , UTC ( local ) ) ; <NEW_LINE>
if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { <NEW_LINE>vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; <NEW_LINE>vec [ 0 ] . len = hlen ; <NEW_LINE>ND_PRINT ( ( ndo , " , checksum 0x % 04x ( % scorrect ) , length % u" , <NEW_LINE>EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , <NEW_LINE>in_cksum ( vec , 1 ) ? "in" : "" , <NEW_LINE>hlen ) ) ; <NEW_LINE> } <NEW_LINE>
jas_matind_t i ; <NEW_LINE>jas_matind_t j ; <NEW_LINE>
<NEW_LINE>return NS_ERROR_DOM_BAD_URI ; <NEW_LINE>
#ifdef CURLDEBUG <NEW_LINE>assert ( strlen ( work ) <= sizeof ( work ) ) ; <NEW_LINE>#endif <NEW_LINE>
if ( containsFocusedShadowElement ( ) ) <NEW_LINE>
for ( size_t i = 0 ; i < 4 ; ++ i ) { <NEW_LINE>
#ifndef BASE_MESSAGE_LOOP_MESSAGE_PUMP_DISPATCHER_H_ <NEW_LINE>#define BASE_MESSAGE_LOOP_MESSAGE_PUMP_DISPATCHER_H_ <NEW_LINE>
struct perf_sample_data * data , <NEW_LINE>
if ( have_shift == 0 ) <NEW_LINE>
conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE>
BrowserContext * browser_context_ ; <NEW_LINE>StoragePartition * storage_partition_ ; <NEW_LINE>
size = MIN ( count , self -> buffer_size - self -> buffer_offset % self -> chunkSize ) ; <NEW_LINE>memcpy ( buf , self -> buffer + self -> buffer_offset % self -> chunkSize , size ) ; <NEW_LINE>
memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE>
fclose ( fp ) ; <NEW_LINE>
int insn_idx , int prev_insn_idx , <NEW_LINE>bool speculative ) <NEW_LINE>
<NEW_LINE>
PropertyTreeState properties ;
nsresult SetUpDocument ( DocumentFlavor aFlavor , <NEW_LINE>const char * aCharset , <NEW_LINE>const char * aContentType , <NEW_LINE>nsIDOMDocument ** aResult , <NEW_LINE>nsIChannel ** aChannel , <NEW_LINE>nsIStreamListener ** aListener ) ; <NEW_LINE>
<NEW_LINE>NS_DECL_CYCLE_COLLECTING_ISUPPORTS <NEW_LINE><NEW_LINE>NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS ( nsCanvasRenderingContext2D , nsIDOMCanvasRenderingContext2D ) <NEW_LINE>
AudioBuffer::Create ( mNode -> Context ( ) , aNumberOfChannels , <NEW_LINE>mNode -> BufferSize ( ) , <NEW_LINE>mNode -> Context ( ) -> SampleRate ( ) , cx , aRv ) ; <NEW_LINE>MOZ_ASSERT ( buffer || aRv . ErrorCode ( ) == NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE>
do_QueryInterface ( content -> FindFirstNonChromeOnlyAccessContent ( ) ) ; <NEW_LINE>
if ( olen != 2 ) { <NEW_LINE>ND_PRINT ( ( ndo , "ERROR: Option Length != 2 Bytes ( % u ) " , olen ) ) ; <NEW_LINE> } else { <NEW_LINE>unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ; <NEW_LINE> } <NEW_LINE>
offset > 0 && ! NS_IS_SPACE ( mTitle [ offset - 1 ] ) ) { <NEW_LINE>
if ( ( png_ptr -> row_number & 0x01 ) == 0 ) <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_CONTEXT_SWITCHES , 1 , NULL , 0 ) ; <NEW_LINE>
const unsigned long len = php_mysqlnd_net_field_length ( & p ) ; <NEW_LINE>if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { <NEW_LINE>php_error_docref ( NULL , E_WARNING , "Malformed server packet . Field length pointing "MYSQLND_SZ_T_SPEC <NEW_LINE>" bytes after end of packet" , ( p + len ) - packet_end - 1 ) ; <NEW_LINE>DBG_RETURN ( FAIL ) ; <NEW_LINE> } <NEW_LINE>
if ( diff . needsFullLayout ( ) ) <NEW_LINE>
JS_EnterCompartment ( cx , global ) ; <NEW_LINE>return true ; <NEW_LINE>
static VPX_INLINE void mem_put_le16 ( void * vmem , MEM_VALUE_T val ) { <NEW_LINE>
int32_t offset = 0 , noffset = 0 ; <NEW_LINE>
<NEW_LINE>
static void fadst8_sse2 ( __m128i * in ) { <NEW_LINE>
<NEW_LINE>if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) <NEW_LINE>goto done ; <NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
virtual void DeleteSharedWorker ( const GURL & worker , <NEW_LINE>const std::string & name , <NEW_LINE>const url::Origin & constructor_origin ) ; <NEW_LINE>
void SetNext ( nsTreeColumn * aNext ) { <NEW_LINE>NS_ASSERTION ( ! mNext , "already have a next sibling" ) ; <NEW_LINE>NS_IF_ADDREF ( mNext = aNext ) ; <NEW_LINE> } <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
const sp < IMediaPlayerService > service ( getMediaPlayerService ( ) ) ; <NEW_LINE>
ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <NEW_LINE> & ps_codec -> s_parse . s_bitstrm , <NEW_LINE>slice_qp , <NEW_LINE>cabac_init_idc , <NEW_LINE> & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; <NEW_LINE>if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) <NEW_LINE> { <NEW_LINE>ps_codec -> i4_slice_error = 1 ; <NEW_LINE>end_of_slice_flag = 1 ; <NEW_LINE>ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
int fd = - 1 ; <NEW_LINE>
cmdShell = ssplit ( & buf [ 2 ] , "\r\n" , NULL ) ; <NEW_LINE>
class CoordinatorImpl : public Coordinator , <NEW_LINE>public mojom::Coordinator , <NEW_LINE>public mojom::HeapProfilerHelper { <NEW_LINE>
int hineighbor [ VIF_POSIT + 2 ] ; <NEW_LINE>
if ( tmsglen < conflen ) { <NEW_LINE>if ( sealalg != 0xffff ) <NEW_LINE>xfree ( plain ) ; <NEW_LINE> * minor_status = 0 ; <NEW_LINE>return ( GSS_S_DEFECTIVE_TOKEN ) ; <NEW_LINE> } <NEW_LINE>padlen = plain [ tmsglen - 1 ] ; <NEW_LINE>if ( tmsglen - conflen < padlen ) { <NEW_LINE><NEW_LINE>padlen = 0 ; <NEW_LINE>bad_pad = 1 ; <NEW_LINE> } <NEW_LINE>token . length = tmsglen - conflen - padlen ; <NEW_LINE>
#if ENABLE_BGP_VNC_ATTR <NEW_LINE>
<NEW_LINE>#elif defined ( CONFIG_KM_SUSE2 ) <NEW_LINE>#define CONFIG_HOSTNAME			"kmsuse2" <NEW_LINE>
look -> sorted_index [ i + 1 ] , fits + i , <NEW_LINE>n , info ) ; <NEW_LINE>
int mbedtls_ecdsa_sign_det ( mbedtls_ecp_group * grp , mbedtls_mpi * r , <NEW_LINE>mbedtls_mpi * s , const mbedtls_mpi * d , <NEW_LINE>const unsigned char * buf , size_t blen , <NEW_LINE>mbedtls_md_type_t md_alg ) ; <NEW_LINE><NEW_LINE>int mbedtls_ecdsa_sign_det_ext ( mbedtls_ecp_group * grp , mbedtls_mpi * r , <NEW_LINE>mbedtls_mpi * s , const mbedtls_mpi * d , <NEW_LINE>const unsigned char * buf , size_t blen , <NEW_LINE>mbedtls_md_type_t md_alg , <NEW_LINE>int ( * f_rng_blind ) ( void * , unsigned char * , <NEW_LINE>size_t ) , <NEW_LINE>void * p_rng_blind ) ; <NEW_LINE>
unsigned int zero_mv_sse = UINT_MAX , best_sse = UINT_MAX , <NEW_LINE>best_rd_sse = UINT_MAX ; <NEW_LINE>
if ( frame_size > LONG_MAX || frame_size <= 0 ) <NEW_LINE>
<NEW_LINE>
uint16 bitspersample = 1 , samplesperpixel = 1 ; <NEW_LINE>
static void Create ( int render_process_id , <NEW_LINE>int render_frame_id , <NEW_LINE>MediaStreamManager * media_stream_manager , <NEW_LINE>mojom::MediaStreamDispatcherHostRequest request ) ; <NEW_LINE>
SH_ENFORCE_PACKING_RESTRICTIONS = 0x0800 , <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>SH_CLAMP_INDIRECT_ARRAY_BOUNDS = 0x1000 <NEW_LINE>
guint16 pcs_count , akms_count , pmkid_count ; <NEW_LINE>guint i ; <NEW_LINE>
nsCOMPtr < nsIDocument > doc = <NEW_LINE>nsContentUtils::GetDocumentFromScriptContext ( mScriptContext ) ; <NEW_LINE>
if ( mem == NULL || mem -> pointer ( ) == NULL ) { <NEW_LINE>return NO_MEMORY ; <NEW_LINE> } <NEW_LINE>
if ( image -> channel_map [ channel ] . traits == UndefinedPixelTrait ) <NEW_LINE>
break ; <NEW_LINE>
#include "vpx_dsp / prob . h" <NEW_LINE>
round = ( vpx_codec_pts_t ) 10000000 <NEW_LINE>
void RequestUpdatePluginGeometry ( ) ; <NEW_LINE>
const int er_y = MAX ( src -> y_width + 16 , ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) ) <NEW_LINE> - src -> y_crop_width ; <NEW_LINE>const int eb_y = MAX ( src -> y_height + 16 , ALIGN_POWER_OF_TWO ( src -> y_height , 6 ) ) <NEW_LINE> - src -> y_crop_height ; <NEW_LINE>
if ( error || colspan < 0 || colspan > MAX_COLSPAN ) <NEW_LINE>
if ( buf_len < record_len || record_len < 4 ) { <NEW_LINE>
if ( ! EnsureStringLength ( aString , length ) ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE><NEW_LINE>
if ( zone -> wasGCStarted ( ) ) { <NEW_LINE>
return xpc_UnmarkGrayContext ( mContext ) ; <NEW_LINE>
if ( js_doregexec ( J , re -> prog , text , & m , 0 ) ) { <NEW_LINE>
ippSetString ( job -> attrs , & attr , 1 , attr -> values [ 0 ] . string . text ) ; <NEW_LINE>
struct control * control = voidcast ( struct control * , file -> alloc_ptr ) ; <NEW_LINE>
if ( win && win -> mWidgetListener ) { <NEW_LINE>if ( aIsActivate ) { <NEW_LINE>win -> mWidgetListener -> WindowActivated ( ) ; <NEW_LINE> } else { <NEW_LINE>if ( ! win -> BlurEventsSuppressed ( ) ) { <NEW_LINE>win -> mWidgetListener -> WindowDeactivated ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
const image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE>
static int ecdsa_sign_internal ( mbedtls_ecp_group * grp , mbedtls_mpi * r , <NEW_LINE>mbedtls_mpi * s , const mbedtls_mpi * d , <NEW_LINE>const unsigned char * buf , size_t blen , <NEW_LINE>int ( * f_rng ) ( void * , unsigned char * , size_t ) , <NEW_LINE>void * p_rng , <NEW_LINE>int ( * f_rng_blind ) ( void * , unsigned char * , <NEW_LINE>size_t ) , <NEW_LINE>void * p_rng_blind ) <NEW_LINE>
#line 605 "ext / standard / var_unserializer . re" <NEW_LINE>
# ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED <NEW_LINE>
int64_t bound = Max ( a , b ) ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( ! lhs . isDecimal ( ) && ! rhs . isDecimal ( ) ) <NEW_LINE> -- bound ; <NEW_LINE><NEW_LINE>
return ! r -> isInline ( ) && r -> isRenderBlock ( ) && ! r -> isFloatingOrOutOfFlowPositioned ( ) && ! r -> isBody ( ) ; <NEW_LINE>
vorbis_info_psy_global * gi , <NEW_LINE>float * data , <NEW_LINE>envelope_band * bands , <NEW_LINE>envelope_filter_state * filters ) { <NEW_LINE>
#include "chrome / browser / autocomplete / autocomplete_provider . h" <NEW_LINE>
if ( ! doapr_outch ( sbuffer , buffer , & currlen , maxlen , <NEW_LINE>va_arg ( args , int ) ) ) <NEW_LINE>return 0 ; <NEW_LINE>
void utf16_to_utf8 ( const char16_t * src , size_t src_len , char * dst , size_t dst_len ) <NEW_LINE>
if ( avoidsFloats ( ) || isRoot ( ) || isRenderView ( ) || isFloatingOrOutOfFlowPositioned ( ) || isTableCell ( ) ) { <NEW_LINE>
if ( aInputTrack -> IsEnded ( ) ) { <NEW_LINE>TrackTicks inputEndTicks = aInputTrack -> TimeToTicksRoundDown ( inputEnd ) ; <NEW_LINE>if ( aInputTrack -> GetEnd ( ) <= inputEndTicks ) { <NEW_LINE>inputTrackEndPoint = aInputTrack -> GetEnd ( ) ; <NEW_LINE>
#include "proxygen / lib / utils / Base64 . h" <NEW_LINE><NEW_LINE>
private chromeos::BluetoothInputClient::Observer , <NEW_LINE>private chromeos::BluetoothAgentServiceProvider::Delegate { <NEW_LINE>
CopyTexSubImage2D_base ( target , level , format , xoffset , yoffset , x , y , width , height , true ) ; <NEW_LINE>
#ifndef BASE_ANDROID_JAVA_HANDLER_THREAD_H_ <NEW_LINE>#define BASE_ANDROID_JAVA_HANDLER_THREAD_H_ <NEW_LINE>
"websocket" , <NEW_LINE>"csp_report" , <NEW_LINE>"xslt" } ; <NEW_LINE>
const image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE>
nsOverflowContinuationTracker::AutoFinish fini ( & tracker , kidFrame ) ; <NEW_LINE>
const unsigned int outmax = ( 1U << out_depth ) - 1 ; <NEW_LINE>
@stability Stable <NEW_LINE>
already_AddRefed < nsIDOMSVGNumber > GetItem ( uint32_t index , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE>already_AddRefed < nsIDOMSVGNumber > IndexedGetter ( uint32_t index , bool & found , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
#include "vp9 / encoder / vp9_encoder . h" <NEW_LINE>
void OnRefreshTokenAvailableFromSource ( const std::string & account_id , <NEW_LINE>bool is_refresh_token_valid , <NEW_LINE>const std::string & source ) override ; <NEW_LINE>void OnRefreshTokenRevokedFromSource ( const std::string & account_id , <NEW_LINE>const std::string & source ) override ; <NEW_LINE>
<NEW_LINE>bool IsContextualCardsBarIntegrationEnabled ( ) ; <NEW_LINE>
. Build ( ) , <NEW_LINE>SetSelectionData::Builder ( ) <NEW_LINE> . SetShouldCloseTyping ( true ) <NEW_LINE> . SetShouldClearTypingStyle ( true ) <NEW_LINE> . SetShouldShowHandle ( true ) <NEW_LINE>
bool GetURLAndTitle ( FilenameToURLPolicy policy , <NEW_LINE>GURL * url , <NEW_LINE>base::string16 * title ) const ; <NEW_LINE>
<NEW_LINE>if ( err == MP_OKAY ) { <NEW_LINE>if ( mp_iszero ( k ) == MP_YES ) <NEW_LINE>err = MP_ZERO_E ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
@stability Evolving <NEW_LINE>
" try -- i420 or -- yv12 or -- rawvideo . \n" ) ; <NEW_LINE>
#include "nsAutoPtr . h" <NEW_LINE>
nsAutoPtr < ModuleEntry > entry ( new ModuleEntry ( mContext ) ) ; <NEW_LINE>
{ <NEW_LINE>Adjustment = ( cpi -> current_gf_interval - 1 ) * Adjustment ; <NEW_LINE><NEW_LINE>if ( Adjustment > ( 10 * cpi -> this_frame_target ) / 100 ) <NEW_LINE>Adjustment = ( 10 * cpi -> this_frame_target ) / 100 ; <NEW_LINE>cpi -> this_frame_target += Adjustment ; <NEW_LINE> } <NEW_LINE>
d0u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 0 ] ) ; <NEW_LINE>d1u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 1 ] ) ; <NEW_LINE>
nsresult rv = proxyEnv . getOrSetFakeOrigin ( ( nsCSecurityContext * ) securityContext ) ; <NEW_LINE>if ( NS_SUCCEEDED ( rv ) ) <NEW_LINE>rv = secureEnv -> CallStaticMethod ( method -> mReturnType , clazz , method -> mMethodID , args , & outValue , securityContext ) ; <NEW_LINE>
uint32_t * track_size ; <NEW_LINE>
if ( shell -> FrameManager ( ) -> GetPlaceholderFrameFor ( mOutOfFlowFrame ) ) { <NEW_LINE>NS_ERROR ( "Placeholder relationship should have been torn down ; see " <NEW_LINE>"comments in nsPlaceholderFrame . h . Unregistering ourselves , " <NEW_LINE>"but this might cause our out - of - flow to be unable to destroy " <NEW_LINE>"itself properly . Not that it could anyway , with us dead . " ) ; <NEW_LINE>shell -> FrameManager ( ) -> UnregisterPlaceholderFrame ( this ) ; <NEW_LINE> } <NEW_LINE>
#endif <NEW_LINE>#endif
<NEW_LINE>NS_DECL_CYCLE_COLLECTING_ISUPPORTS <NEW_LINE><NEW_LINE>NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS ( nsCanvasRenderingContext2D , nsIDOMCanvasRenderingContext2D ) <NEW_LINE>
<NEW_LINE>
res = ctx -> iface -> dec . get_si ( get_alg_priv ( ctx ) , si ) ; <NEW_LINE>
#define YYTABLE_NINF - 95 <NEW_LINE>
static VPX_INLINE void mem_put_le32 ( void * vmem , MEM_VALUE_T val ) { <NEW_LINE>
if ( aParentCanvas && ! SafeToCreateCanvas3DContext ( aParentCanvas ) ) <NEW_LINE>
htmlParserNodeInfo node_info = { NULL , 0 , 0 , 0 , 0 } ; <NEW_LINE>
static mp_err <NEW_LINE>
status = register_pernet_subsys ( & sctp_defaults_ops ) ; <NEW_LINE>if ( status ) <NEW_LINE>goto err_register_defaults ; <NEW_LINE>status = sctp_v4_protosw_init ( ) ; <NEW_LINE>
int Segment::TestFrame ( uint64 track_number , uint64 frame_timestamp_ns , <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
jas_uchar buf [ PGX_MAGICLEN ] ; <NEW_LINE>
jas_iccprof_t * jas_iccprof_createfrombuf ( jas_uchar * buf , int len ) <NEW_LINE>
<NEW_LINE>
if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) { <NEW_LINE>
<NEW_LINE>
error = gl -> GetAndClearError ( ) ; <NEW_LINE>
FreeLineBox ( lineBox ) ; <NEW_LINE>
void setNeedsTransformUpdate ( ) override ; <NEW_LINE>
ChildIterator iter , last ; <NEW_LINE>for ( ChildIterator::Init ( mContent , & iter , & last ) ; <NEW_LINE>iter != last ; <NEW_LINE> ++ iter ) { <NEW_LINE>if ( ( * iter ) -> Tag ( ) == nsGkAtoms::listitem ) <NEW_LINE>
if ( isWritingModeRoot ( ) && ! isOutOfFlowPositioned ( ) ) <NEW_LINE>
* bp ++ = ( png_byte ) value ; <NEW_LINE>
if ( ( pendingCount == pendingCapacity ) && ! growPendingArray ( cx ) ) <NEW_LINE>return ; <NEW_LINE>
TEMP_FAILURE_RETRY ( send ( client_socket_ , "btsnoop\0\0\0\0\1\0\0\x3\xea" , 16 , 0 ) ) ; <NEW_LINE>
SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
<NEW_LINE>int index = ( sy + y ) * CDG_SCREEN_PITCH + ( sx + x ) ; <NEW_LINE>if ( index >= CDG_SCREEN_PITCH * CDG_SCREEN_HEIGHT ) <NEW_LINE>return 0 ; <NEW_LINE><NEW_LINE>uint8_t * p = & p_cdg -> p_screen [ index ] ; <NEW_LINE><NEW_LINE>
for ( size_t index = 1 ; index < array -> Count ( ) ; ++ index ) { <NEW_LINE>
while ( ! cb -> isRenderView ( ) && ! cb -> isBody ( ) && ! cb -> isTableCell ( ) && ! cb -> isOutOfFlowPositioned ( ) && cb -> style ( ) -> logicalHeight ( ) . isAuto ( ) ) { <NEW_LINE>
{ <NEW_LINE>nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>sh -> InitialReflow ( r . width , r . height ) ; <NEW_LINE> } <NEW_LINE>
enum { FIXNUM_WIDTH = ( ( 8 * sizeof ( native_int ) ) - TAG_SHIFT - 1 ) } ; <NEW_LINE>enum { <NEW_LINE>FIXNUM_MAX = ( ( ( native_int ) 1 << FIXNUM_WIDTH ) - 1 ) , <NEW_LINE>FIXNUM_MIN = - ( ( ( native_int ) 1 << FIXNUM_WIDTH ) - 1 ) <NEW_LINE> } ; <NEW_LINE>
mpz_powm_sec ( v , v , key -> e , key -> n ) ; <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
if ( widget -> mInDtor ) { <NEW_LINE>
key = mprReadJson ( params , "id" ) ; <NEW_LINE>
if ( ! ss -> opt . noCache && sid -> cached == never_cached ) <NEW_LINE>
FormData * httpBody = documentLoader -> request ( ) . httpBody ( ) ; <NEW_LINE>
return ralg -> seedsize ; <NEW_LINE>
if ( count != sizeof ( iris_info . filler ) ) <NEW_LINE>ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE>
{ <NEW_LINE> ( void ) ThrowMagickException ( _exception , GetMagickModule ( ) , <NEW_LINE>OptionError , "ImageSequenceRequired" , "` % s'" , option ) ; <NEW_LINE>new_images = DestroyImage ( new_images ) ; <NEW_LINE>status = MagickFalse ; <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
bool is_valid_ssl , <NEW_LINE>bool is_browser_window_active ) ; <NEW_LINE>
if ( o -> isBlockFlow ( ) && ! style ( ) -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
nsSMILTimedElement * mElement ; <NEW_LINE>
vpx_codec_iface_name ( global -> codec -> codec_interface ( ) ) ) ; <NEW_LINE>fprintf ( stderr , "Source file: % s File Type: % s Format: % s\n" , <NEW_LINE>input -> filename , <NEW_LINE>file_type_to_string ( input -> file_type ) , <NEW_LINE>image_format_to_string ( input -> fmt ) ) ; <NEW_LINE>
ippSetValueTag ( job -> attrs , & attr , IPP_TAG_KEYWORD ) ; <NEW_LINE>ippSetString ( job -> attrs , & attr , 0 , "no - hold" ) ; <NEW_LINE>
Ar = GetCacheViewVirtualPixels ( Ar_view , 0 , y , <NEW_LINE>MagickMax ( Ar_image -> columns , Cr_image -> columns ) , 1 , exception ) ; <NEW_LINE>Ai = GetCacheViewVirtualPixels ( Ai_view , 0 , y , <NEW_LINE>MagickMax ( Ai_image -> columns , Ci_image -> columns ) , 1 , exception ) ; <NEW_LINE>Br = GetCacheViewVirtualPixels ( Br_view , 0 , y , <NEW_LINE>MagickMax ( Br_image -> columns , Cr_image -> columns ) , 1 , exception ) ; <NEW_LINE>Bi = GetCacheViewVirtualPixels ( Bi_view , 0 , y , <NEW_LINE>MagickMax ( Bi_image -> columns , Ci_image -> columns ) , 1 , exception ) ; <NEW_LINE>
js_DestroyScriptFromGC ( cx , script , data ) ; <NEW_LINE>
#include "vp8 / common / common . h" <NEW_LINE>
ResourceRequestBlockedReason , <NEW_LINE>Resource::Type ) const override { } <NEW_LINE>
virtual void Log ( QualityMetric metric , <NEW_LINE>const std::string & experiment_id ) const ; <NEW_LINE>
if ( dir_len > PATH_MAX ) <NEW_LINE> { <NEW_LINE>uwsgi_log ( "invalid path size: % d ( max % d ) \n" , dir_len , PATH_MAX ) ; <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE>char * src = uwsgi_concat2n ( dir , dir_len , "" , 0 ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>enum class LinuxCapability { <NEW_LINE>kCapSysChroot , <NEW_LINE>kCapSysAdmin , <NEW_LINE> } ; <NEW_LINE><NEW_LINE>
strncpy ( rrng . type , "rng" , sizeof ( rrng . type ) ) ; <NEW_LINE>
var = vpx_variance16x16 <NEW_LINE>
else if ( Ustrcmp ( argrest , "Mr" ) == 0 ) <NEW_LINE><NEW_LINE>if ( received_protocol ) <NEW_LINE> { <NEW_LINE>fprintf ( stderr , "received_protocol is set already\n" ) ; <NEW_LINE>exit ( EXIT_FAILURE ) ; <NEW_LINE> } <NEW_LINE>else received_protocol = argv [ ++ i ] ;
std::cout << " GenerateWord32 and Crop\n" ; <NEW_LINE>
<NEW_LINE>
class CORE_EXPORT CSSPaintValue : public CSSImageGeneratorValue { <NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
already_AddRefed < nsIDOMSVGLength > GetItem ( uint32_t index , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE>already_AddRefed < nsIDOMSVGLength > IndexedGetter ( uint32_t index , bool & found , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE>
mElements . AppendObject ( aContent ) ; <NEW_LINE>
DCHECK ( m_sources . count ( AutoplaySource::Method ) ) ; <NEW_LINE><NEW_LINE>DEFINE_STATIC_LOCAL ( <NEW_LINE>CustomCountHistogram , durationHistogram , <NEW_LINE> ( "Media . Video . Autoplay . Muted . PlayMethod . OffscreenDuration" , 1 , <NEW_LINE>maxOffscreenDurationUmaMS , offscreenDurationUmaBucketCount ) ) ; <NEW_LINE>durationHistogram . count ( boundedTime ) ; <NEW_LINE><NEW_LINE>
nsresult rv = proxyEnv . getOrSetFakeOrigin ( ( nsCSecurityContext * ) securityContext ) ; <NEW_LINE>if ( NS_SUCCEEDED ( rv ) ) <NEW_LINE>secureEnv -> SetStaticField ( field -> mFieldType , clazz , field -> mFieldID , value , securityContext ) ; <NEW_LINE>
if ( _gdImageWebpCtx ( im , out , - 1 ) ) { <NEW_LINE>rv = NULL ; <NEW_LINE> } else { <NEW_LINE>rv = gdDPExtractData ( out , size ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
<NEW_LINE>if ( ! params . no_increment_hotp && must_advance_counter ) { <NEW_LINE>
<NEW_LINE>
#ifdef PNG_WRITE_OPTIMIZE_CMF_SUPPORTED <NEW_LINE>if ( ( png_ptr -> mode & PNG_HAVE_IDAT ) == 0 && <NEW_LINE>png_ptr -> compression_type == PNG_COMPRESSION_TYPE_BASE ) <NEW_LINE>optimize_cmf ( data , png_image_size ( png_ptr ) ) ; <NEW_LINE>#endif <NEW_LINE>
class BASE_API MemoryMappedFile { <NEW_LINE>
InitContentSecurityPolicy ( nullptr , policy_to_inherit ) ; <NEW_LINE>
#include "vp8 / encoder / quantize . h" <NEW_LINE>
if ( isChromeDoc && useXULCache ) { <NEW_LINE>
( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ;
mutable Mutex generator_mutex_ ; <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
<NEW_LINE>
png_byte hi , lo ; <NEW_LINE><NEW_LINE>hi = * ( sp ) ++ ; lo = * ( sp ) ++ ; <NEW_LINE>red = ( png_uint_16 ) ( ( hi << 8 ) | ( lo ) ) ; <NEW_LINE>hi = * ( sp ) ++ ; lo = * ( sp ) ++ ; <NEW_LINE>green = ( png_uint_16 ) ( ( hi << 8 ) | ( lo ) ) ; <NEW_LINE>hi = * ( sp ) ++ ; lo = * ( sp ) ++ ; <NEW_LINE>blue = ( png_uint_16 ) ( ( hi << 8 ) | ( lo ) ) ; <NEW_LINE>
<NEW_LINE>NS_IF_RELEASE ( mSecureEnv ) ; <NEW_LINE>
void ptrace_triggered ( struct perf_event * bp , <NEW_LINE>
<NEW_LINE>if ( i . isIon ( ) ) <NEW_LINE>continue ; <NEW_LINE>if ( i . interpFrame ( ) == fp ) <NEW_LINE>
if ( argc < 1 ) { <NEW_LINE>js_ReportMissingArg ( cx , vp , 0 ) ; <NEW_LINE>return JS_FALSE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
FireChromeDOMEvent ( mPresContext , mIsActive ? active : inactive ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) ; <NEW_LINE>
DistillerUIHandle * distiller_ui_handle , <NEW_LINE>
<NEW_LINE>
BlockEntry ** const entries = new ( std::nothrow ) BlockEntry * [ entries_size ] ; <NEW_LINE>if ( entries == NULL ) <NEW_LINE>return - 1 ; <NEW_LINE>
memset ( str , 0 , MAX_APN_LENGTH + 1 ) ; <NEW_LINE>
( ! hasAllowUntrustedAttr && ! mIsBoundToChrome && ! mUsingXBLScope ) ) && <NEW_LINE>
" % CE % B1 % CE % B2" , true } , <NEW_LINE>
if ( ! ArrayBufferObject::neuterViews ( cx , buffer , newHeader -> elements ( ) ) ) <NEW_LINE>
SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
virtual void TabDetachedAt ( content::WebContents * contents , <NEW_LINE>int index ) OVERRIDE ; <NEW_LINE>
const uint32_t max_stack = 1000000 ; <NEW_LINE>if ( count > max_stack ) return 0 ; <NEW_LINE>return max_stack - count ; <NEW_LINE>
test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuedouble ; <NEW_LINE>test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuedouble ; <NEW_LINE>test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuedouble ; <NEW_LINE>
XPCAutoRequest ar ( mContext ) ; <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
CHAR_LEN_TABLE ( EUCTWCharLenTable ) , <NEW_LINE>
<NEW_LINE><NEW_LINE>
if ( STATE_FIRST_CALL == mState && * aSrcLength < 2 ) <NEW_LINE> { <NEW_LINE>nsresult res = ( * aSrcLength == 0 ) ? NS_OK : NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> * aSrcLength = 0 ; <NEW_LINE> * aDestLength = 0 ; <NEW_LINE>return res ; <NEW_LINE> } <NEW_LINE>
if ( ( png_ptr -> row_number & 0x01 ) != 0 || png_ptr -> width < 2 ) <NEW_LINE>
uint64 surface_handle , <NEW_LINE>
number_pixels = ( MagickSizeType ) columns * rows ; <NEW_LINE>if ( ( number_pixels * sizeof ( uint32 ) ) != ( MagickSizeType ) ( ( size_t ) <NEW_LINE> ( number_pixels * sizeof ( uint32 ) ) ) ) <NEW_LINE> { <NEW_LINE>TIFFClose ( tiff ) ; <NEW_LINE>ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> } <NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_INVERT_ALPHA ) != 0 ) <NEW_LINE>
if ( arg >= cdi -> capacity ) <NEW_LINE>
return vp9_pattern_search_sad ( x , ref_mv , search_param , sad_per_bit , <NEW_LINE>do_init_search , cost_list , vfp , use_mvcost , <NEW_LINE>center_mv , best_mv , <NEW_LINE>bigdia_num_candidates , bigdia_candidates ) ; <NEW_LINE>
int dev_get_valid_name ( struct net * net , struct net_device * dev , <NEW_LINE>const char * name ) <NEW_LINE>
int num = snprintf ( outfilename , sizeof ( outfilename ) , " % s_ % 05d . j2k" , argv [ 2 ] , snum ) ; <NEW_LINE>if ( num >= sizeof ( outfilename ) ) { <NEW_LINE>fprintf ( stderr , "maximum length of output prefix exceeded\n" ) ; <NEW_LINE>return 1 ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
bool IsHandleVisible ( ) const { return is_handle_visible_ ; } <NEW_LINE>
sProperties , sFunctions , NULL , NULL ) ; <NEW_LINE>if ( ! proto ) { <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE><NEW_LINE>JS::Rooted < JSObject * > ctor ( aCx , JS_GetConstructor ( aCx , proto ) ) ; <NEW_LINE>if ( ! ctor ) { <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( ! dom::DefineConstants ( aCx , ctor , sStaticConstants ) || <NEW_LINE> ! dom::DefineConstants ( aCx , proto , sStaticConstants ) ) { <NEW_LINE>
ScriptState * script_state = ScriptState::ForCurrentRealm ( args ) ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
GPMF_KEY_TOTAL_SAMPLES = 	MAKEID ( 'T' , 'S' , 'M' , 'P' ) , <NEW_LINE>GPMF_KEY_TIME_OFFSET = 		MAKEID ( 'T' , 'I' , 'M' , 'O' ) , <NEW_LINE>GPMF_KEY_TIMING_OFFSET = 	MAKEID ( 'T' , 'I' , 'M' , 'O' ) , <NEW_LINE>GPMF_KEY_TIME_STAMP = 		MAKEID ( 'S' , 'T' , 'M' , 'P' ) , <NEW_LINE>GPMF_KEY_TIME_STAMPS = 		MAKEID ( 'S' , 'T' , 'P' , 'S' ) , <NEW_LINE>
<NEW_LINE>
<NEW_LINE><NEW_LINE>nsRefPtr < DOMSVGPointList > animVal = <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ; <NEW_LINE>
<NEW_LINE>
if ( renderer -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
<NEW_LINE>#if defined ( __CYGWIN__ ) <NEW_LINE>
err = TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ) ; <NEW_LINE>
kernel = ( float * ) AcquireQuantumMemory ( MagickMax ( image -> rows , image -> columns ) + 1 , <NEW_LINE>
printstr ( & pp , " < form method = \"POST\" action = \" / U\" enctype = \"application / x - www - form - urlencoded\" > < textarea cols = \"80\" rows = \"30\" name = \"conffile\" > " ) ; <NEW_LINE>
JS_ASSERT ( size_t ( idx ) < xdr -> state -> atoms . length ( ) ) ; <NEW_LINE> * atomp = xdr -> state -> atoms [ idx ] ; <NEW_LINE>
name = ssplit ( sclone ( name ) , "#" , ( char ** ) & criteria ) ; <NEW_LINE>
u_int i ; <NEW_LINE>
SensorReadingSharedBuffer * reading_buffer_ ; <NEW_LINE>
if ( ESTIMATE_MAX_GLYPHS ( mLength ) > MAX_UNISCRIBE_LENGTH ) { <NEW_LINE>
#include "compiler / compilerdebug . h" <NEW_LINE>
uint64_t alloc_size ; <NEW_LINE><NEW_LINE>align = ( 1 << xcs ) - 1 ; <NEW_LINE>w = ( d_w + align ) & ~ align ; <NEW_LINE>align = ( 1 << ycs ) - 1 ; <NEW_LINE>h = ( d_h + align ) & ~ align ; <NEW_LINE><NEW_LINE>s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; <NEW_LINE>s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; <NEW_LINE>stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; <NEW_LINE>alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? ( uint64_t ) h * s * bps / 8 <NEW_LINE>: ( uint64_t ) h * s ; <NEW_LINE>
uint32 rows , uint32 cols , int outskew , int64 inskew ) <NEW_LINE>
NLSF_Q15 [ i ] = silk_max_int ( NLSF_Q15 [ i ] , silk_ADD_SAT16 ( NLSF_Q15 [ i - 1 ] , NDeltaMin_Q15 [ i ] ) ) ; <NEW_LINE>
nsCOMPtr < nsINode > parent = adoptedNode -> GetNodeParent ( ) ; <NEW_LINE>
aBuffer = buffer ; <NEW_LINE>
void SetRenderer ( int process_host_id , <NEW_LINE>
if ( ( chunk_size > SIZE_MAX ) || ( SIZE_MAX - chunk_size <= size ) ) { <NEW_LINE>
& scal_height ) != 0 ) <NEW_LINE>
&& ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) ) <NEW_LINE>
jsval listenerVal = listeners [ index ] ; <NEW_LINE>
ber_parse_header ( STREAM s , int tagval , uint32 * length ) <NEW_LINE>
Rooted < GlobalObject * > global ( cx ) ; <NEW_LINE> { <NEW_LINE>AutoCompartment ac ( cx , compartment ) ; <NEW_LINE>global = GlobalObject::create ( cx , Valueify ( clasp ) ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
m . command = CMD_NONE ; <NEW_LINE>
if ( temp == - 1 || temp >= info -> partvals ) goto eopbreak ; <NEW_LINE>
CURLMcode error = CURLM_OK ; <NEW_LINE>
n = dn_expand ( answer -> qb2 , end , cp , name , ( sizeof name ) - 2 ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>bool IsCorsCrossOrigin ( ) const ;
if ( ProcessFlashMessageDelayed ( win , inst , hWnd , msg , wParam , lParam ) ) <NEW_LINE>
AutoPushJSContext cx ( sc -> GetNativeContext ( ) ) ; <NEW_LINE>
oggpack_buffer * opb ) { <NEW_LINE>
experimental_webgl_enabled ( false ) { <NEW_LINE>
nsWindow * window ; <NEW_LINE>GetContainerWindow ( & window ) ; <NEW_LINE>
AutoSafeJSContext cx ; <NEW_LINE>
long do_shmat ( int shmid , char __user * shmaddr , int shmflg , <NEW_LINE>ulong * raddr , unsigned long shmlba ) <NEW_LINE>
#include "vp9 / encoder / vp9_encoder . h" <NEW_LINE>
pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , <NEW_LINE>size + EXTRA_BS_OFFSET ) ; <NEW_LINE>
if ( ( png_ptr -> transformations & PNG_USER_TRANSFORM ) != 0 ) <NEW_LINE>
PRUint32 numElementsToUpload = NS_MIN ( location_object -> mArrayLength , JS_GetTypedArrayLength ( wa ) / cnt ) ; \ <NEW_LINE>gl -> f##name ( location , numElementsToUpload , ( ptrType * ) JS_GetTypedArrayData ( wa ) ) ; \ <NEW_LINE>
bool result = mPusher . Push ( mCx , nsCxPusher::ALWAYS_PUSH ) ; <NEW_LINE>
notImplemented ( ) ; <NEW_LINE>
#include "platform / win / SystemInfo . h" <NEW_LINE>
* inputLeft = inLeft / 2 ; <NEW_LINE> * outputLeft = outLeft ; <NEW_LINE>
int64_t aTimeThreshold ) <NEW_LINE>
length = length * BezierQuantum ; <NEW_LINE>
nsRefPtr < nsResizeDropdownAtFinalPosition > resize = <NEW_LINE>new nsResizeDropdownAtFinalPosition ( this ) ; <NEW_LINE>if ( NS_SUCCEEDED ( aPresContext -> PresShell ( ) -> PostReflowCallback ( resize ) ) ) { <NEW_LINE><NEW_LINE><NEW_LINE>resize . forget ( ) ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>if ( offset < lastThisPopped ) { <NEW_LINE> * pbaseobj = NULL ; <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
ReadParam ( m , iter , & p -> experimental_webgl_enabled ) ; <NEW_LINE>
flags |= JSON_SORT_KEYS ; <NEW_LINE><NEW_LINE>if ( getenv ( "HASHSEED" ) ) <NEW_LINE>json_object_seed ( getenv_int ( "HASHSEED" ) ) ; <NEW_LINE>
if ( isOutOfFlowPositioned ( ) && newStyle -> hasStaticBlockPosition ( isHorizontalWritingMode ( ) ) && oldStyle -> marginBefore ( ) != newStyle -> marginBefore ( ) <NEW_LINE>
virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result , <NEW_LINE>nsIChannel ** channel ) ; <NEW_LINE>
image = ( Image * ) RelinquishMagickMemory ( image ) ; <NEW_LINE>
row_stride , colormap ) != 0 ) <NEW_LINE>
if ( s -> content . valid && s -> content . type == string ) { <NEW_LINE>if ( smatch ( s -> name . value . string , "REMOTE_HOST" ) || <NEW_LINE>smatch ( s -> name . value . string , "HTTP_AUTHORIZATION" ) || <NEW_LINE>smatch ( s -> name . value . string , "IFS" ) || <NEW_LINE>smatch ( s -> name . value . string , "CDPATH" ) || <NEW_LINE>smatch ( s -> name . value . string , "PATH" ) || <NEW_LINE>sstarts ( s -> name . value . string , "LD_" ) ) { <NEW_LINE>continue ; <NEW_LINE> } <NEW_LINE>envp [ n ++ ] = sfmt ( " % s % s = % s" , ME_GOAHEAD_CGI_PREFIX , <NEW_LINE>s -> name . value . string , s -> content . value . string ) ; <NEW_LINE>
outHeader -> nFilledLen = frameSize ; <NEW_LINE>
if ( pCmdData == NULL || ( cmdSize < ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ) || <NEW_LINE>pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int32_t ) ) { <NEW_LINE>
<NEW_LINE>
xmlThreadParams * params = ( xmlThreadParams * ) private_data ; <NEW_LINE>const char * filename = params -> filename ; <NEW_LINE>
BASE_API bool CreateShortcutLink ( const wchar_t * source , <NEW_LINE>const wchar_t * destination , <NEW_LINE>const wchar_t * working_dir , <NEW_LINE>const wchar_t * arguments , <NEW_LINE>const wchar_t * description , <NEW_LINE>const wchar_t * icon , <NEW_LINE>int icon_index , <NEW_LINE>const wchar_t * app_id ) ;
& trans_color ) != 0 ) <NEW_LINE>
kFlex1 = ( 12 << 8 ) + 37 <NEW_LINE>
int bytes_read = TEMP_FAILURE_RETRY ( read ( reader -> inbound_fd , buffer -> data , reader -> buffer_size ) ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
strncpy ( raead . type , "aead" , sizeof ( raead . type ) ) ; <NEW_LINE>strncpy ( raead . geniv , aead -> geniv ? : " < built - in > " , sizeof ( raead . geniv ) ) ; <NEW_LINE>
#endif <NEW_LINE>
if ( ! code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP ) { <NEW_LINE>
result = js_regexec ( re -> prog , text , & m , opts ) ; <NEW_LINE>if ( result < 0 ) <NEW_LINE>js_error ( J , "regexec failed" ) ; <NEW_LINE>if ( result == 0 ) { <NEW_LINE>
static const float vwin4096 [ 2048 ] = { <NEW_LINE>
static void perf_event_output ( struct perf_event * event , <NEW_LINE>
} else if ( ctx -> frame_workers == NULL ) { <NEW_LINE>
delete [ ] encryption -> sig_key_id ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
MOZ_CRASH ( ) ; <NEW_LINE>
#include "third_party / blink / public / web / devtools_frontend . mojom . h" <NEW_LINE>
<NEW_LINE><NEW_LINE>deflateInit ( & mUpstreamZlib , Z_NO_COMPRESSION ) ; <NEW_LINE>
#else <NEW_LINE>typedef unsigned long long uint64 ; <NEW_LINE>typedef long long int64 ; <NEW_LINE>
major = ssplit ( sclone ( version ) , " . " , & minor ) ; <NEW_LINE>minor = ssplit ( minor , " . " , & patch ) ; <NEW_LINE>
DummyFramebufferOperation ( "readPixels" ) ; <NEW_LINE>return ; <NEW_LINE>
int gpu_host_id ( ) const { return gpu_host_id_ ; } <NEW_LINE>base::ProcessId gpu_pid ( ) const { return channel_ -> peer_pid ( ) ; } <NEW_LINE>
if ( perf_event_overflow ( event , & data , regs ) ) <NEW_LINE>
if ( STATE_FIRST_CALL == mState && * aSrcLength < 2 ) <NEW_LINE> { <NEW_LINE> * aSrcLength = 0 ; <NEW_LINE> * aDestLength = 0 ; <NEW_LINE>return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> } <NEW_LINE>
tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <NEW_LINE>
mDecodingMonitor . AssertCurrentThreadIn ( ) ; <NEW_LINE>
IsHTMLIntegrationPointForEndTag ( token ) || <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
void UpdateRegisteredIds ( const ObjectIdSet & ids ) ;
delete [ ] encryption -> signature ; <NEW_LINE>
struct GPU_EXPORT LevelInfo { <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , sfar ) ; <NEW_LINE>
const int64 cluster_offset = <NEW_LINE>cluster_list_ [ 0 ] -> size_position ( ) - GetUIntSize ( kMkvCluster ) ; <NEW_LINE>
res = AdoptNodeIntoOwnerDoc ( container , aNewChild ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( res , res ) ; <NEW_LINE>
data_encoding = P_FILE ; <NEW_LINE>
str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count + 1 , sizeof ( * str ) ) ; <NEW_LINE>
delete [ ] compression_entries_ ; <NEW_LINE>
v8::Local < v8::String > key = v8String ( isolate , "privateScriptController" ) ; <NEW_LINE><NEW_LINE>if ( global -> HasOwnProperty ( context , key ) . ToChecked ( ) ) { <NEW_LINE>v8::Local < v8::Value > privateScriptController = <NEW_LINE>global -> Get ( context , key ) . ToLocalChecked ( ) ; <NEW_LINE>CHECK ( privateScriptController -> IsObject ( ) ) ; <NEW_LINE>
buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) ] = '\0' ; <NEW_LINE>
page -> GetChromeClient ( ) . Focus ( incumbent_window -> GetFrame ( ) ) ; <NEW_LINE>
fname_len = spprintf ( & fname , 0 , " % s % c % s" , test , DEFAULT_SLASH , intern -> u . dir . entry . d_name ) ; <NEW_LINE>
Loader ( const Face & face ) ; <NEW_LINE>
crypt_password = crypt ( password , user_password ) ; <NEW_LINE>if ( crypt_password == NULL ) <NEW_LINE> { <NEW_LINE>pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication failed" ) ; <NEW_LINE>return - 1 ; <NEW_LINE> } <NEW_LINE>if ( strcmp ( user_password , crypt_password ) != 0 ) <NEW_LINE>
ret = put_user ( task_thread_info ( child ) -> tp_value [ 0 ] , <NEW_LINE>
JS_STATIC_ASSERT ( ! ( EXTENSIBLE_FLAGS & DEPENDENT_FLAGS ) ) ; <NEW_LINE>left . d . lengthAndFlags = bits ^ ( EXTENSIBLE_FLAGS | DEPENDENT_FLAGS ) ; <NEW_LINE>
str = Int32ToString ( cx , v . toInt32 ( ) ) ; <NEW_LINE>
nsresult InstallImplementation ( nsXBLBinding * aBinding ) ; <NEW_LINE>
WORD32 impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) <NEW_LINE>
msg -> msg_namelen	 = sizeof ( * sipx ) ; <NEW_LINE>
<NEW_LINE>if ( ! lhs -> isInfinite ( ) || ! rhs -> isInfinite ( ) ) <NEW_LINE> * emptyRange = true ; <NEW_LINE>
ap_log_cerror ( APLOG_MARK , APLOG_DEBUG , 0 , session -> c , <NEW_LINE>
void SetObserver ( JNIEnv * env , <NEW_LINE>const base::android::JavaParamRef < jobject > & obj , <NEW_LINE>const base::android::JavaParamRef < jobject > & j_observer , <NEW_LINE>jint num_sites ) ; <NEW_LINE>
void ChromeClientImpl::Focus ( LocalFrame * calling_frame ) { <NEW_LINE>if ( web_view_ -> Client ( ) ) { <NEW_LINE>web_view_ -> Client ( ) -> DidFocus ( <NEW_LINE>calling_frame ? WebLocalFrameImpl::FromFrame ( calling_frame ) : nullptr ) ; <NEW_LINE> } <NEW_LINE>
AudioDeviceThread audio_thread_ ; <NEW_LINE>
virtual void WriteInternal ( const char * aBuffer , uint32_t aCount , DecodeStrategy aStrategy ) ; <NEW_LINE>
BlobRegistry::unregisterBlobURL ( m_urlForReading ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>bool WouldTaintOrigin ( ) ;
if ( HeapOverflowSanityCheck ( count , quantum ) != MagickFalse ) <NEW_LINE>
<NEW_LINE>bool argPacked = ! argTypes -> hasObjectFlags ( cx , types::OBJECT_FLAG_NON_PACKED_ARRAY ) ; <NEW_LINE>bool thisPacked = ! thisTypes -> hasObjectFlags ( cx , types::OBJECT_FLAG_NON_PACKED_ARRAY ) ; <NEW_LINE>if ( ! ( thisPacked && ! argPacked ) ) <NEW_LINE>return compileArrayConcat ( thisTypes , argTypes , thisValue , arg ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
if ( ! IsAtomsCompartment ( compartment ( ) ) && compartment ( ) -> wrap ( this , & value ) ) <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
mResultArrayBuffer = nullptr ; <NEW_LINE>NS_DROP_JS_OBJECTS ( this , nsDOMFileReader ) ; <NEW_LINE>
std::unique_ptr < EffectPaintPropertyNode > Clone ( ) const { <NEW_LINE>return base::WrapUnique ( <NEW_LINE>new EffectPaintPropertyNode ( Parent ( ) , State ( state_ ) ) ) ; <NEW_LINE>
#include "third_party / blink / renderer / platform / graphics / paint / property_tree_state . h" <NEW_LINE>
MonitorAutoLock mon ( mMonitor ) ; <NEW_LINE>return mAudioClock . GetPositionUnlocked ( ) ; <NEW_LINE>
if ( ! child -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
uint32_t deltaSmpl = captureSize <NEW_LINE> + pContext -> mConfig . inputCfg . samplingRate * latencyMs / 1000 ; <NEW_LINE><NEW_LINE><NEW_LINE>if ( deltaSmpl > CAPTURE_BUF_SIZE ) { <NEW_LINE>android_errorWriteLog ( 0x534e4554 , "31781965" ) ; <NEW_LINE>deltaSmpl = CAPTURE_BUF_SIZE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>int32_t capturePoint = pContext -> mCaptureIdx - deltaSmpl ; <NEW_LINE><NEW_LINE>
RefPtr < TestNode > imp = WTF::getPtr ( proxyImp -> locationWithPerWorldBindings ( ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>mGIFStruct . images_decoded ++ ; <NEW_LINE><NEW_LINE>
info -> grouping = oggpack_read ( opb , 24 ) + 1 ; <NEW_LINE>info -> partitions = ( char ) ( oggpack_read ( opb , 6 ) + 1 ) ; <NEW_LINE>info -> groupbook = ( unsigned char ) oggpack_read ( opb , 8 ) ; <NEW_LINE>
if ( ! isOutOfFlowPositioned ( ) ) { <NEW_LINE>
nsWeakPtr mContent ; <NEW_LINE>
#line 643 "ext / standard / var_unserializer . re" <NEW_LINE>
IDBObjectStore::ClearCloneReadInfo ( mCloneReadInfo ) ; <NEW_LINE>
char * endHeaders , * headers , * key , * value ; <NEW_LINE>
void DidFocus ( blink::WebLocalFrame * calling_frame ) override ; <NEW_LINE>
ModuleEntry ( JSContext * cx ) : mozilla::Module ( ) , obj ( cx ) , thisObjectKey ( cx ) { <NEW_LINE>
if ( legend ) <NEW_LINE>ConsiderChildOverflow ( aDesiredSize . mOverflowAreas , legend ) ; <NEW_LINE>if ( inner ) <NEW_LINE>ConsiderChildOverflow ( aDesiredSize . mOverflowAreas , inner ) ; <NEW_LINE>
CheckedInt < uint32_t > newlen ( rdata . sb . length ( ) ) ; <NEW_LINE>newlen += leftlen ; <NEW_LINE>newlen += replen ; <NEW_LINE>if ( ! newlen . isValid ( ) ) { <NEW_LINE>js_ReportAllocationOverflow ( cx ) ; <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE>if ( ! rdata . sb . reserve ( newlen . value ( ) ) ) <NEW_LINE>
execDepth = GetScriptExecDepth ( obj ) ; <NEW_LINE>
if ( m_state != OMX_StateExecuting && <NEW_LINE>m_state != OMX_StatePause && <NEW_LINE>m_state != OMX_StateIdle ) { <NEW_LINE>
conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE>
if ( ( ( st_entry * ) stack -> elements [ i ] ) -> data <NEW_LINE> && ( ( st_entry * ) stack -> elements [ i ] ) -> type != ST_FIELD ) { <NEW_LINE>
#endif <NEW_LINE>
if ( policyOIDTag == ev -> oid_tag ) { <NEW_LINE>addToCertListIfTrusted ( certList , ev -> cert ) ; <NEW_LINE> } <NEW_LINE>
localname = NULL ; <NEW_LINE>goto done ; <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
password = mprReadJson ( child , "password" ) ; <NEW_LINE>roles = getList ( mprReadJsonObj ( child , "roles" ) ) ; <NEW_LINE>
ret = sscanf ( argv [ i ] + 1 , "protos = % 490s" , buf ) ; <NEW_LINE>
shapes ( alloc ) , <NEW_LINE>visiting ( false ) <NEW_LINE>
#line 1143 "ext / standard / var_unserializer . c" <NEW_LINE>
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] = { L'\0' } ; <NEW_LINE>wcsncpy ( updateStatusFilePath , updateDirPath , MAX_PATH ) ; <NEW_LINE>
const char * <NEW_LINE>
if ( ! err && msg -> msg_name ) { <NEW_LINE>struct sockaddr_at * sat = msg -> msg_name ; <NEW_LINE>sat -> sat_family = AF_APPLETALK ; <NEW_LINE>sat -> sat_port = ddp -> deh_sport ; <NEW_LINE>sat -> sat_addr . s_node = ddp -> deh_snode ; <NEW_LINE>sat -> sat_addr . s_net = ddp -> deh_snet ; <NEW_LINE>msg -> msg_namelen = sizeof ( * sat ) ; <NEW_LINE>
if ( png_rtran_ok ( png_ptr , 0 ) == 0 || background_color == NULL ) <NEW_LINE>
#endif <NEW_LINE>
status = OpenBlob ( image_info , image , WriteBinaryBlobMode , & image -> exception ) ; <NEW_LINE>
bool IsKeyframe ( ) const { return frame_type == KEYFRAME ; } <NEW_LINE>
fd = cups_open ( filename , <NEW_LINE>O_RDWR | O_CREAT | O_APPEND | O_LARGEFILE | O_BINARY ) ; <NEW_LINE>
<NEW_LINE>InterpState * state = tracecx -> interpState ; <NEW_LINE>state -> builtinStatus |= JSBUILTIN_BAILED ; <NEW_LINE>state -> deepBailSp = state -> sp ; <NEW_LINE>
if ( TEMP_FAILURE_RETRY ( ioctl ( slot -> fd , FIONREAD , size ) ) == 0 ) { <NEW_LINE>
for ( size_t i = 0 , i_end = array -> Count ( ) ; i < i_end ; ++ i ) { <NEW_LINE>
if ( ! WriteEbmlElement ( writer , kMkvMaxBlockAdditionID , <NEW_LINE>
xmlXPathObjectPtr obj = NULL ; <NEW_LINE>
if ( ( png_ptr -> transformations & PNG_COMPOSE ) != 0 ) <NEW_LINE>
masm . loadFromTypedArray ( arrayType , source , output ( ) . valueReg ( ) , allowDoubleResult ( ) , <NEW_LINE>
if ( ! pusher . Push ( mContext , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ) <NEW_LINE>
typedef png_libpng_version_1_6_20 Your_png_h_is_not_version_1_6_20 ;
strncpy ( the_url , evt -> navigate . to_url , sizeof ( the_url ) - 1 ) ; <NEW_LINE>the_url [ sizeof ( the_url ) - 1 ] = 0 ; <NEW_LINE>
<NEW_LINE><NEW_LINE>PRBool isSystem ; <NEW_LINE>nsCOMPtr < nsIScriptSecurityManager > secMan = <NEW_LINE>do_GetService ( NS_SCRIPTSECURITYMANAGER_CONTRACTID ) ; <NEW_LINE>if ( secMan && <NEW_LINE>NS_SUCCEEDED ( secMan -> IsSystemPrincipal ( ownerPrincipal , <NEW_LINE> & isSystem ) ) && <NEW_LINE> ! isSystem ) { <NEW_LINE>channel -> SetOwner ( aOwner ) ; <NEW_LINE> } <NEW_LINE>
bool isDeprecatedFlexItem ( ) const { return ! isInline ( ) && ! isFloatingOrOutOfFlowPositioned ( ) && parent ( ) && parent ( ) -> isDeprecatedFlexibleBox ( ) ; } <NEW_LINE>
bool wrapInAnonymousSection = ! child -> isOutOfFlowPositioned ( ) ; <NEW_LINE>
if ( ( fd = TEMP_FAILURE_RETRY ( accept ( sfd , ( struct sockaddr * ) & remote , & len ) ) ) == - 1 ) <NEW_LINE>
bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride ) <NEW_LINE> + mvsad_err_cost ( x , best_mv , & fcenter_mv , sad_per_bit ) ; <NEW_LINE>
if ( mContentViewer ) { <NEW_LINE>nsCOMPtr < nsIContentViewer > cv = mContentViewer ; <NEW_LINE>cv -> Stop ( ) ; <NEW_LINE> } <NEW_LINE>
trunc: <NEW_LINE>ND_PRINT ( ( ndo , " % s" , icmp6_tstr ) ) ; <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
<NEW_LINE>decryption_failed_or_bad_record_mac = 1 ; <NEW_LINE>
XPCAutoRequest ar ( mContext ) ; <NEW_LINE>
NS_IF_ADDREF ( * canvas = mCanvasElement . get ( ) ) ; <NEW_LINE>
isoclns_print ( ndo , p , l2info . length ) ; <NEW_LINE>
if ( * payload_len ) { <NEW_LINE>if ( ! ( new_payload = ast_realloc ( session -> payload , ( session -> payload_len + * payload_len ) ) ) ) { <NEW_LINE>ast_log ( LOG_WARNING , "Failed allocation: % p , % zu , % "PRIu64"\n" , <NEW_LINE>session -> payload , session -> payload_len , * payload_len ) ; <NEW_LINE> * payload_len = 0 ; <NEW_LINE>ast_websocket_close ( session , 1009 ) ; <NEW_LINE>return 0 ; <NEW_LINE> } <NEW_LINE><NEW_LINE>session -> payload = new_payload ; <NEW_LINE>memcpy ( ( session -> payload + session -> payload_len ) , ( * payload ) , ( * payload_len ) ) ; <NEW_LINE>session -> payload_len += * payload_len ; <NEW_LINE> } else if ( ! session -> payload_len && session -> payload ) { <NEW_LINE>ast_free ( session -> payload ) ; <NEW_LINE>session -> payload = NULL ; <NEW_LINE> } <NEW_LINE>
-> PostTask ( <NEW_LINE>BLINK_FROM_HERE , <NEW_LINE>CrossThreadBind ( & ScriptProcessorHandler::FireProcessEvent , <NEW_LINE>WrapRefPtr ( this ) , double_buffer_index_ ) ) ; <NEW_LINE>
return 1 ; <NEW_LINE>
if ( EVP_CipherInit_ex ( ctx , cipher , NULL , NULL , NULL , - 1 ) != 1 ) <NEW_LINE>
if ( bits_left == 0 ) ENSURE_BITS ( 16 ) ; <NEW_LINE>
# ifdef PNG_WRITE_INTERLACING_SUPPORTED <NEW_LINE>int passes = png_set_interlace_handling ( png_ptr ) ; <NEW_LINE># else <NEW_LINE>int passes = 1 ; <NEW_LINE># endif <NEW_LINE>
#endif <NEW_LINE>
AutoPushJSContext cx ( sctx -> GetNativeContext ( ) ) ; <NEW_LINE>
memset ( l , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <NEW_LINE>
AssertIsRooted ( ) ; <NEW_LINE>
va_list args ) { <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
if ( png_set_text_2 ( png_ptr , info_ptr , & text , 1 ) != 0 ) <NEW_LINE>
<NEW_LINE>cmdSize > ( sizeof ( effect_param_t ) + sizeof ( int32_t ) + sizeof ( int32_t ) ) || <NEW_LINE>cmdSize < ( sizeof ( effect_param_t ) + sizeof ( int32_t ) + sizeof ( int16_t ) ) || <NEW_LINE>pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int32_t ) ) { <NEW_LINE>
last mod: $ Id: os_types . h 17287 2010 - 06 - 10 13:42:06Z tterribe $ <NEW_LINE>
const SelectionInDOMTree & , <NEW_LINE>
uint32_t sampleRate = 0 ; <NEW_LINE>
void vp9_choose_segmap_coding_method ( VP9_COMMON * cm , MACROBLOCKD * xd ) { <NEW_LINE>
#ifndef CONTENT_RENDERER_DEVTOOLS_AGENT_FILTER_H_ <NEW_LINE>#define CONTENT_RENDERER_DEVTOOLS_AGENT_FILTER_H_ <NEW_LINE>
if ( ! origin_tainted_by_content_ && ! canvas_pattern -> OriginClean ( ) ) { <NEW_LINE>SetOriginTaintedByContent ( ) ; <NEW_LINE>
return TEMP_FAILURE_RETRY ( write ( fd , & event , sizeof ( event ) ) ) ; <NEW_LINE>
#line 985 "ext / standard / var_unserializer . c" <NEW_LINE>
if ( _y4m -> bit_depth == 8 ) <NEW_LINE>_y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ; <NEW_LINE>else <NEW_LINE>_y4m -> dst_buf = ( unsigned char * ) malloc ( 2 * _y4m -> dst_buf_sz ) ; <NEW_LINE><NEW_LINE>if ( _y4m -> aux_buf_sz > 0 ) <NEW_LINE>_y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ; <NEW_LINE>
if ( ( color_type & PNG_COLOR_MASK_ALPHA ) != 0 ) <NEW_LINE>
<NEW_LINE>
r = TEMP_FAILURE_RETRY ( send ( p_dcb -> p_scb -> socket_id [ 1 ] , p_dcb -> p_rx_pkt , data_size , 0 ) ) ; <NEW_LINE>
FILE_RCSID ( "@ ( # ) $ File: readelf . c , v 1 . 157 2019 / 01 / 02 19:44:14 christos Exp $ " ) <NEW_LINE>
if ( ! curr -> isFloatingOrOutOfFlowPositioned ( ) ) { <NEW_LINE>
static VPX_INLINE void mem_put_be16 ( void * vmem , MEM_VALUE_T val ) { <NEW_LINE>
d -> m_touchEventHandler -> handleTouchPoint ( point , modifiers ) ; <NEW_LINE>
if ( cur [ 0 ] && cur [ 0 ] -> clazz && cur [ 0 ] -> clazz -> get_interface ) <NEW_LINE>
fPtr = count ? ( T * ) sk_malloc_throw ( count , sizeof ( T ) ) : nullptr ; <NEW_LINE>
static bool subsumes ( JSCompartment * a , JSCompartment * b ) ; <NEW_LINE>
<NEW_LINE>argv [ -- argc ] = JSVAL_VOID ; <NEW_LINE>
#endif <NEW_LINE>
#define nginx_version 9002 <NEW_LINE>#define NGINX_VERSION "0 . 9 . 2" <NEW_LINE>
strncpy ( mixer_vols [ n ] . name , name , 32 ) ; <NEW_LINE>
const int mask_shift = subsampling_factor ? 4 : 8 ; <NEW_LINE>const int mask_cutoff = subsampling_factor ? 0xf : 0xff ; <NEW_LINE>const int lfl_forward = subsampling_factor ? 4 : 8 ; <NEW_LINE>
if ( mColorMask == 0xFF ) { <NEW_LINE>for ( PRUint32 c = mGIFStruct . width ; c > 0 ; c -- ) { <NEW_LINE> * -- to = cmap [ * -- from ] ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE><NEW_LINE>PRUint8 mask = mColorMask ; <NEW_LINE>for ( PRUint32 c = mGIFStruct . width ; c > 0 ; c -- ) { <NEW_LINE> * -- to = cmap [ ( * -- from ) & mask ] ; <NEW_LINE> } <NEW_LINE>
#include "vpx_dsp / variance . h" <NEW_LINE>
status = SetImageExtent ( image , image -> columns , image -> rows ) ; <NEW_LINE>if ( status == MagickFalse ) <NEW_LINE> { <NEW_LINE>InheritException ( exception , & image -> exception ) ; <NEW_LINE>return ( DestroyImageList ( image ) ) ; <NEW_LINE> } <NEW_LINE>
memcpy ( & t_above_s , & t_above , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>memcpy ( & t_left_s , & t_left , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>
} else if ( ! obj -> isFloatingOrOutOfFlowPositioned ( ) && ! obj -> isRunIn ( ) ) <NEW_LINE>
if ( ! Stream_EnsureRemainingCapacity ( data_in , dataLength ) ) <NEW_LINE>
OpenManifestEntryResource ( const std::string & target_url , <NEW_LINE>
snprintf ( buf , L_BUFSIZE , " % s . data . % d" , gplot -> rootname , gplot -> nplots ) ; <NEW_LINE>
memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( cost_list ) { <NEW_LINE>calc_int_cost_list ( x , ref_mv , sadpb , fn_ptr , dst_mv , cost_list ) ; <NEW_LINE> } <NEW_LINE>
if ( ( png_ptr -> flags & PNG_FLAG_ZLIB_CUSTOM_STRATEGY ) != 0 ) <NEW_LINE>
#define PARSE_STRING						\ <NEW_LINE>s = parse_field ( ndo , & parse , & parselen , & truncated ) ; 	\ <NEW_LINE>if ( truncated ) goto trunc ; 				\ <NEW_LINE>
void utf32_to_utf8 ( const char32_t * src , size_t src_len , char * dst , size_t dst_len ) <NEW_LINE>
static void init_mode_probs ( FRAME_CONTEXT * fc ) { <NEW_LINE>
while ( pair ) { <NEW_LINE>
<NEW_LINE>
if ( ! mCxPusher . Push ( cx ) ) { <NEW_LINE>
AutoPushJSContext cx ( scx -> GetNativeContext ( ) ) ; <NEW_LINE>
: mOutputHandler ( nsnull ) , <NEW_LINE>mResultHandler ( nsnull ) , <NEW_LINE>mStylesheet ( aStylesheet ) , <NEW_LINE>
bond_dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;
if ( key_length_sizes [ i ] >= key_len && <NEW_LINE>
#include "platform / mediastream / MediaStreamSource . h" <NEW_LINE>
<NEW_LINE>if ( act_size > MT_PACKET_LEN - packet -> size ) { <NEW_LINE>
! js_data . isObject ( ) ) <NEW_LINE>
if ( ent2 -> data == NULL ) { <NEW_LINE>
if ( newChild -> isFloatingOrOutOfFlowPositioned ( ) ) { <NEW_LINE>
void OnReadImageReply ( const SkBitmap & bitmap , IPC::Message * reply_msg ) ; <NEW_LINE>
newEntry = new ModuleEntry ( callercx ) ; <NEW_LINE>
p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) ; <NEW_LINE>
#ifndef BASE_NUMERICS_SAFE_MATH_H_ <NEW_LINE>#define BASE_NUMERICS_SAFE_MATH_H_ <NEW_LINE>
if ( h . isPercent ( ) ) { <NEW_LINE>LayoutUnit availableHeight ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( isPositioned ( ) ) <NEW_LINE>availableHeight = containingBlockLogicalHeightForPositioned ( containingBlock ( ) ) ; <NEW_LINE>else <NEW_LINE>availableHeight = containingBlock ( ) -> availableLogicalHeight ( ) ; <NEW_LINE>return computeContentBoxLogicalHeight ( h . calcValue ( availableHeight ) ) ; <NEW_LINE> }
do ret = TEMP_FAILURE_RETRY ( recv ( sock_fd , buf , r , MSG_WAITALL ) ) ; <NEW_LINE>
nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>
mAppUnitsPerInch ( 0 ) <NEW_LINE>
LayoutUnit minX = std::min ( rect . x ( ) , m_layoutOverflow . x ( ) ) ; <NEW_LINE>LayoutUnit minY = std::min ( rect . y ( ) , m_layoutOverflow . y ( ) ) ; <NEW_LINE><NEW_LINE>m_layoutOverflow . setWidth ( maxX - minX ) ; <NEW_LINE>m_layoutOverflow . setHeight ( maxY - minY ) ; <NEW_LINE>m_layoutOverflow . setX ( maxX - m_layoutOverflow . width ( ) ) ; <NEW_LINE>m_layoutOverflow . setY ( maxY - m_layoutOverflow . height ( ) ) ; <NEW_LINE>
DECLARE_ALIGNED ( 16 , unsigned short , FData2 [ 24 * 24 ] ) ; <NEW_LINE>
iter . GetContainer ( ) -> MarkLineDirty ( iter . GetLine ( ) , iter . GetLineList ( ) ) ; <NEW_LINE>
if ( m_parent ) { <NEW_LINE>HeapObjectHeader::fromPayload ( m_parent ) -> checkHeader ( ) ; <NEW_LINE> } <NEW_LINE>
void SetShouldSendResourceTimingInfoToParent ( bool value ) { <NEW_LINE>should_send_resource_timing_info_to_parent_ = value ; <NEW_LINE>
if ( touches [ i ] . state ( ) != BlackBerry::Platform::TouchPoint::TouchReleased ) { <NEW_LINE>
if ( ! vpx_codec_peek_stream_info ( decoder -> codec_interface ( ) , <NEW_LINE>
if ( err < 0 ) <NEW_LINE>
rxent -> serviceId = EXTRACT_16BITS ( & rxh -> serviceId ) ; <NEW_LINE>
kindInt ( Ion ) , <NEW_LINE>pendingRecompilation ( false ) <NEW_LINE>
for ( i = 1 ; ( i < ( ssize_t ) number_vertices ) && ( length >= 0 . 0 ) ; i ++ ) <NEW_LINE>
#include "vpx_dsp / prob . h" <NEW_LINE>
THIS_FUNCTION_IS_DEPRECATED ( extern struct json_object * json_object_object_get ( struct json_object * obj , <NEW_LINE>const char * key ) ) ; <NEW_LINE>
vorbis_comment * vc , <NEW_LINE>ogg_packet * op , <NEW_LINE>ogg_packet * op_comm , <NEW_LINE>ogg_packet * op_code ) { <NEW_LINE>
RefPtr < SharedBuffer > fullData = readFile ( layoutTestResourcesDir , "animated - 10color . gif" ) ; <NEW_LINE>
#line 683 "ext / standard / var_unserializer . re" <NEW_LINE>
const input_method::ImeConfigValue & value ) = 0 ;
#ifndef CONTENT_SHELL_BROWSER_LAYOUT_TEST_LAYOUT_TEST_ANDROID_H_ <NEW_LINE>#define CONTENT_SHELL_BROWSER_LAYOUT_TEST_LAYOUT_TEST_ANDROID_H_ <NEW_LINE>
#ifdef DEBUG <NEW_LINE><NEW_LINE>#define PARENT_WAIT 30000 <NEW_LINE>#else <NEW_LINE>#define PARENT_WAIT 10000 <NEW_LINE>#endif <NEW_LINE>
<NEW_LINE>if ( ! prev || ! mmget_still_valid ( mm ) || expand_stack ( prev , addr ) ) <NEW_LINE>
Copyright ( c ) 2010 - 2016 , Linux Foundation . All rights reserved . <NEW_LINE>
if ( ! FireClipboardEvent ( NS_PASTE , aSelectionType ) ) <NEW_LINE>
#ifndef BASE_TEST_SIMPLE_TEST_CLOCK_H_ <NEW_LINE>#define BASE_TEST_SIMPLE_TEST_CLOCK_H_ <NEW_LINE>
# error "libpng requires an unsigned 32 - bit ( or more ) type" <NEW_LINE>
ITS_CUSTOM , ITS_CUSTOMRDONLY <NEW_LINE>
PRInt32 start = macro_start ; \ <NEW_LINE>PRInt32 end = macro_end ; \ <NEW_LINE>if ( start > end ) { \ <NEW_LINE>end = start ; \ <NEW_LINE> } \ <NEW_LINE>nsTreeRange * macro_new_range = new nsTreeRange ( macro_selection , start , end ) ; \ <NEW_LINE>
isoclns_print ( ndo , p + 1 , length - 1 ) ; <NEW_LINE>
if ( equalIgnoringASCIICase ( getAttribute ( aria_hiddenAttr ) , "false" ) ) <NEW_LINE>
AutoPushJSContext cx ( nsContentUtils::GetContextFromDocument ( this ) ) ; <NEW_LINE>
png_set_read_user_transform_fn ( read_ptr , read_user_callback ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( parentFrame -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) { <NEW_LINE>nsPlaceholderFrame * placeholderFrame = <NEW_LINE>state . mFrameManager -> GetPlaceholderFrameFor ( parentFrame ) ; <NEW_LINE>NS_ASSERTION ( placeholderFrame , "No placeholder for out - of - flow ? " ) ; <NEW_LINE>parentFrame = placeholderFrame -> GetParent ( ) ; <NEW_LINE> } else { <NEW_LINE>parentFrame = parentFrame -> GetParent ( ) ; <NEW_LINE> } <NEW_LINE>
if ( context && <NEW_LINE>
thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ; <NEW_LINE>
const long long id = ReadID ( m_pReader , idpos , len ) ; <NEW_LINE>
#line 1268 "ext / standard / var_unserializer . c" <NEW_LINE>
m_blobDataHandles . set ( blob -> uuid ( ) , blob -> blobDataHandle ( ) ) ; <NEW_LINE>
uint8_t intra_only ; <NEW_LINE>uint8_t last_intra_only ; <NEW_LINE>
<NEW_LINE>VERIFY ( ::SetParent ( mWnd , nsnull ) ) ; <NEW_LINE>
if ( std::isnan ( cue -> startTime ( ) ) || std::isnan ( cue -> endTime ( ) ) ) <NEW_LINE>
void StopForTest ( ) ; <NEW_LINE>private: <NEW_LINE>
ippSetString ( job -> attrs , & jformat , 0 , mimetype ) ; <NEW_LINE>
tiff_pixels = ( unsigned char * ) AcquireMagickMemory ( MagickMax ( <NEW_LINE>TIFFScanlineSize ( tiff ) , ( size_t ) ( image -> columns * samples_per_pixel * <NEW_LINE>pow ( 2 . 0 , ceil ( log ( bits_per_sample ) / log ( 2 . 0 ) ) ) ) ) ) ; <NEW_LINE>
MOZ_ASSERT ( js::IsObjectInContextCompartment ( scope , ctx ) ) ; <NEW_LINE>
SetPixelViaPixelInfo ( enhance_image , & pixel , q ) ; <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_CPU_MIGRATIONS , 1 , NULL , 0 ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
result = mRedoStack . Pop ( getter_AddRefs ( tx ) ) ; <NEW_LINE>
int				byte_count = 0 , count = 0 ; <NEW_LINE>
#define EXSLTPUBVAR extern <NEW_LINE>
growBuffer ( buffer , i + XML_PARSER_BUFFER_SIZE ) ; <NEW_LINE>
static const char * const cfg = " -- force - target = armv8 - linux - gcc -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect -- disable - install - docs -- size - limit = 4096x3072" ; <NEW_LINE>
kMaxValue = 114 <NEW_LINE>
for ( i = 0 ; i < SERDES_MAX ; i ++ ) { <NEW_LINE>
return mPump || mWaitingOnAsyncRedirect ; <NEW_LINE>
if ( frame_size <= 0 ) <NEW_LINE>
if ( m -> msg_name ) <NEW_LINE>m -> msg_name = address ; <NEW_LINE>
<NEW_LINE>if ( mUpdateCount > 0 ) { <NEW_LINE> -- mUpdateCount ; <NEW_LINE> } <NEW_LINE>
JSObject ** aClassObject , bool * aNew ) ; <NEW_LINE>
png_charp text = NULL ; <NEW_LINE><NEW_LINE>if ( prefix_size + expanded_size > prefix_size && <NEW_LINE>prefix_size + expanded_size < 0xffffffffU ) <NEW_LINE> { <NEW_LINE>text = png_malloc_warn ( png_ptr , prefix_size + expanded_size + 1 ) ; <NEW_LINE> } <NEW_LINE>
aTargetClassObject , aTargetIsNew ) ; <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
perror ( "malloc" ) ; <NEW_LINE>return NULL ; <NEW_LINE>
if ( endptr - buf <= 12 ) <NEW_LINE>
#endif <NEW_LINE>#endif
if ( ! CanForciblyDiscard ( ) || mDecoder || mAnim ) <NEW_LINE>
if ( ! InstCast ( aNPP ) -> CallPStreamNotifyConstructor ( <NEW_LINE>sn , url , NullableString ( aTarget ) , true , <NEW_LINE>nsCString ( aBuffer , aLength ) , aIsFile , & err ) ) { <NEW_LINE>NS_RUNTIMEABORT ( "StreamNotify constructor failed" ) ; <NEW_LINE> } <NEW_LINE>
jas_ulonglong tmp ; <NEW_LINE>
bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; <NEW_LINE>
jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP ; <NEW_LINE>
#include "platform / win / HWndDC . h" <NEW_LINE>#include "platform / win / SystemInfo . h" <NEW_LINE>
EbmlMasterElementSize ( kMkvEditionEntry , payload_size ) + payload_size ; <NEW_LINE>
void SetRenderer ( int process_host_id , <NEW_LINE>
from = mprReadJson ( child , "from" ) ; <NEW_LINE>to = mprReadJson ( child , "to" ) ; <NEW_LINE>status = mprReadJson ( child , "status" ) ; <NEW_LINE>
#define MUS_SZ 4 <NEW_LINE>uint8_t mus_event [ MUS_SZ ] = { 0 , 0 , 0 , 0 } ; <NEW_LINE>
( subsumes ( js::GetObjectCompartment ( wrapper ) , <NEW_LINE>js::GetObjectCompartment ( obj ) ) || <NEW_LINE>
static int <NEW_LINE>
virtual void AcceleratedSurfaceNew ( int32 width_in_pixel , <NEW_LINE>int32 height_in_pixel , <NEW_LINE>uint64 surface_id , <NEW_LINE>const std::string & mailbox_name ) OVERRIDE ; <NEW_LINE>virtual void AcceleratedSurfaceRelease ( ) OVERRIDE ; <NEW_LINE>
size_t cryptosize ; <NEW_LINE><NEW_LINE>if ( __builtin_mul_overflow ( sizeof ( size_t ) * 2 , numsubsamples , & cryptosize ) || <NEW_LINE>__builtin_add_overflow ( cryptosize , sizeof ( AMediaCodecCryptoInfo ) , & cryptosize ) ) { <NEW_LINE>ALOGE ( "crypto size overflow" ) ; <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE>
if ( at_start != 0 ) <NEW_LINE>
memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ; <NEW_LINE>
snprintf ( buf , sizeof ( buf ) , " % s - % d" , filename , dec_ctx -> frame_number ) ; <NEW_LINE>
nsRefPtr < nsPresContext > presContext = <NEW_LINE>static_cast < nsPresContext * > ( instance_data ) ; <NEW_LINE>
ret_value = 0 ; <NEW_LINE>goto to_exit ; <NEW_LINE>
if ( have_alpha != 0 ) <NEW_LINE>
if ( ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) != 0 ) <NEW_LINE>
m_pCues = new ( std::nothrow ) Cues ( this , pos , size , idpos , element_size ) ; <NEW_LINE>if ( m_pCues == NULL ) <NEW_LINE>return - 1 ; <NEW_LINE>
if ( ! pentry ) <NEW_LINE>CrashAtUnhandlableOOM ( "OOM in ConstraintTypeSet::sweep" ) ; <NEW_LINE> * pentry = object ; <NEW_LINE>
standard_test ( png_store * const psIn , png_uint_32 const id , <NEW_LINE>
<NEW_LINE>TEST_F ( CCLayerTreeHostTestScrollSimple , runMultiThread ) <NEW_LINE>
ND_TCHECK2 ( bp [ hlen ] , 16 ) ; <NEW_LINE>
if ( rh . command == RELAY_COMMAND_BEGIN_DIR && <NEW_LINE>circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) {
ippSetString ( con -> request , & username , 0 , RemoteRoot ) ; <NEW_LINE>
bool hasAlwaysVisibleElements = m_highlightNode || m_eventTargetNode || m_highlightQuad || ! m_size . isEmpty ( ) || m_drawViewSize ; <NEW_LINE>
if ( JS_UNLIKELY ( newBump < oldBump ) ) <NEW_LINE>return NULL ; <NEW_LINE><NEW_LINE>JS_ASSERT ( canAllocUnaligned ( n ) ) ; <NEW_LINE>
for ( i = 0 ; i < hashsize ( hashtable -> order ) ; i ++ ) <NEW_LINE>
ScheduleStateMachine ( ) ; <NEW_LINE>
SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
ret = x509parse_crt_der ( ssl -> session_negotiate -> peer_cert , <NEW_LINE>ssl -> in_msg + i , n ) ; <NEW_LINE>
case 0x58595a20: <NEW_LINE>case 0x4c616220: <NEW_LINE>
AutoPushJSContext cx ( mContext -> GetNativeContext ( ) ) ; <NEW_LINE>
<NEW_LINE>
#endif <NEW_LINE>
if ( s && s >= filename ) { <NEW_LINE>
image -> colormap = ( PixelPacket * ) AcquireQuantumMemory ( image -> colors + 1 , <NEW_LINE>sizeof ( * image -> colormap ) ) ; <NEW_LINE>if ( image -> colormap == ( PixelPacket * ) NULL ) <NEW_LINE>
if ( isOutOfFlowPositioned ( ) ) <NEW_LINE>
#ifndef CHROME_BROWSER_CHROMEOS_AUDIO_AUDIO_MIXER_ALSA_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_AUDIO_AUDIO_MIXER_ALSA_H_ <NEW_LINE>
<NEW_LINE>JS_FRIEND_API ( JSBool ) <NEW_LINE>DefaultValue ( JSContext * cx , HandleObject obj , JSType hint , MutableHandleValue vp ) ; <NEW_LINE><NEW_LINE>
best_ref_index = ref_index ; <NEW_LINE>
AutoPushJSContext cx ( aContext -> GetNativeContext ( ) ) ; <NEW_LINE>
#endif <NEW_LINE>
void OnCheckForCancel ( int32 preview_ui_id , <NEW_LINE>
if ( ! _dopr ( & hugebufp , & dynbuf , & hugebufsize , & retlen , & ignored , format , <NEW_LINE>args ) ) { <NEW_LINE>OPENSSL_free ( dynbuf ) ; <NEW_LINE>return - 1 ; <NEW_LINE> } <NEW_LINE>
if ( Z_TYPE_PP ( var2 ) != IS_DOUBLE ) { <NEW_LINE>zval dval ; <NEW_LINE>dval = ** var ; <NEW_LINE>zval_copy_ctor ( & dval ) ; <NEW_LINE>convert_to_double ( & dval ) ; <NEW_LINE>matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ; <NEW_LINE> } else { <NEW_LINE>matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ; <NEW_LINE> } <NEW_LINE>
#define BUFFSIZE 326 <NEW_LINE>
rxent -> serviceId == EXTRACT_16BITS ( & rxh -> serviceId ) && <NEW_LINE>
<NEW_LINE><NEW_LINE>vp [ 2 + -- argc ] = JSVAL_VOID ; <NEW_LINE>
#line 990 "ext / standard / var_unserializer . c" <NEW_LINE>
gfx::NativeView parent_view , <NEW_LINE>
if ( Lut != NULL ) cmsPipelineFree ( Lut ) ; <NEW_LINE>
void MaybeGrantAccess ( const ChromeViewHostMsg_GetPluginInfo_Status & status , <NEW_LINE>const FilePath & path ) const ; <NEW_LINE>
if ( strcmp ( key_name , LOC_LANG_TAG ) != 0 && <NEW_LINE>
#ifndef CHROME_BROWSER_UI_FIND_BAR_FIND_TAB_HELPER_H_ <NEW_LINE>#define CHROME_BROWSER_UI_FIND_BAR_FIND_TAB_HELPER_H_ <NEW_LINE>
<NEW_LINE>
qrio_set_gpio ( QRIO_GPIO_A , FPGA_PROG_L , 1 ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>std::string GetKeyboardOverlayId ( const std::string & input_method_id ) ;
prev_slice_incomplete_flag = 1 ; <NEW_LINE>ASSERT ( ps_codec -> s_parse . i4_cur_slice_idx == 1 ) ; <NEW_LINE>
m . command = CMD_NONE ; <NEW_LINE>
mTrailers = new nsHttpHeaderArray ( ) ; <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
string16 GetHeading ( const std::string & extension_name ) const ; <NEW_LINE>
const png_byte colour_type , const png_byte bit_depth , <NEW_LINE>const int palette_number , <NEW_LINE>const int interlace_type , const double file_gamma , <NEW_LINE>const double screen_gamma , const png_byte sbit , <NEW_LINE>const int use_input_precision , const int scale16 ) <NEW_LINE>
zval		 * subpats ; <NEW_LINE>
if ( status != noErr || offset >= aLength ) <NEW_LINE>
<NEW_LINE>
dlen = ceph_x_decrypt ( secret , p , end , & dbuf , 0 ) ; <NEW_LINE>
lir -> insStorei ( INS_NULL ( ) , lirbuf -> state , offsetof ( InterpState , nativeVp ) ) ; <NEW_LINE>
if ( perf_event_overflow ( event , & data , regs ) ) <NEW_LINE>
void vp9_iht8x8_add ( TX_TYPE tx_type , const tran_low_t * input , uint8_t * dest , <NEW_LINE>
const int output_encoding = ( output_format & PNG_FORMAT_FLAG_LINEAR ) != 0 ? <NEW_LINE>
RefPtr < DocumentFragment > fragment = WebCore::createContextualFragment ( markup , toElement ( element ) , AllowScriptingContentAndDoNotMarkAlreadyStarted ) ; <NEW_LINE>
private: <NEW_LINE>
ssize_t ret = TEMP_FAILURE_RETRY ( read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ) ; <NEW_LINE>
nsIDocument * doc = GetCurrentEventContent ( ) ? <NEW_LINE>
zend_alter_ini_entry ( LOCALE_INI_NAME , sizeof ( LOCALE_INI_NAME ) , locale_name , len , PHP_INI_USER , PHP_INI_STAGE_RUNTIME ) ; <NEW_LINE>
JSObject * obj = ( ( nsJSObjWrapper * ) npobj ) -> mJSObj ; <NEW_LINE>if ( ! JS_WrapObject ( cx , & obj ) ) { <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE>return obj ; <NEW_LINE>
onReset ( ) ; <NEW_LINE>
if ( ld -> buffer_size < words * 4 ) <NEW_LINE>ld -> bytes_left = 0 ; <NEW_LINE>else <NEW_LINE>ld -> bytes_left = ld -> buffer_size - words * 4 ; <NEW_LINE>
#endif
nsCAutoString channelContentType ; <NEW_LINE>channel -> GetContentType ( channelContentType ) ; <NEW_LINE>mIsUnsafe = ! ( contentType . Equals ( channelContentType ) && <NEW_LINE> ( contentType . EqualsLiteral ( "application / java - archive" ) || <NEW_LINE>contentType . EqualsLiteral ( "application / x - jar" ) ) ) ; <NEW_LINE>
# error "libpng requires a signed 32 - bit ( or more ) type" <NEW_LINE>
{ 0 } , <NEW_LINE>
& v_fn_ptr , 0 , mv_sf -> subpel_iters_per_step , <NEW_LINE>cond_cost_list ( cpi , cost_list ) , <NEW_LINE>NULL , NULL , <NEW_LINE> & distortion , & sse , NULL , 0 , 0 ) ; <NEW_LINE>
if ( result == 0 ) <NEW_LINE>
if ( diff . needsFullLayout ( ) || ! oldStyle ) <NEW_LINE>
mutt_bcache_del ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) ) ; <NEW_LINE>
<NEW_LINE>
ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ; <NEW_LINE>
settings . udpport = 0 ; <NEW_LINE>
det_ctx -> discontinue_matching = 1 ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
if ( pn && onlyXML ) { <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ) ; <NEW_LINE>
} else if ( fDecimalQuantity -> getMagnitude ( ) != INT32_MIN && std::abs ( fDecimalQuantity -> getMagnitude ( ) ) < 5 ) { <NEW_LINE>
nsTextFrame * framesToRemove = nsnull ; <NEW_LINE>
return ( - 1 ) ; <NEW_LINE>
for ( size_t i = 0 , i_end = array -> Count ( ) ; i < i_end ; ++ i ) { <NEW_LINE>
DBG_RETURN ( ret ) ; <NEW_LINE>
if ( ! js_SafeCallFunctionValue ( cx , JSVAL_TO_OBJECT ( v ) , scopeFun , <NEW_LINE>OBJECT_TO_JSVAL ( funToCall ) , argc , argv , <NEW_LINE>rval ) ) { <NEW_LINE>
doRemoveChild ( aNotify ) ; <NEW_LINE>
<NEW_LINE>
<NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
RANGE_CHECK ( cfg , g_timebase . num , 1 , 1000000000 ) ; <NEW_LINE>
sas_eh_finish_cmd ( cmd ) ; <NEW_LINE>
<NEW_LINE>if ( header_line [ i ] == '\n' || header_line [ i ] == '\r' ) { <NEW_LINE>
<NEW_LINE>argv [ -- argc ] = JSVAL_VOID ; <NEW_LINE>
JSCompartment::markRoots ( JSTracer * trc ) <NEW_LINE>
nsrefcnt AddRef ( ) { <NEW_LINE>if ( mRefCnt == PR_UINT32_MAX ) { <NEW_LINE>NS_WARNING ( "refcount overflow , leaking object" ) ; <NEW_LINE>return mRefCnt ; <NEW_LINE> } <NEW_LINE>return ++ mRefCnt ; <NEW_LINE> } <NEW_LINE>
if ( ( s = stok ( property , ": \t" , & e ) ) == 0 ) { <NEW_LINE>return result ; <NEW_LINE> } <NEW_LINE>
1 , regs , 0 ) ; <NEW_LINE>
#define OK 0 <NEW_LINE>#define ERROR 1 <NEW_LINE>#define NOT_FOUND - ENOENT <NEW_LINE>#define SN_EVENT_LOG_ID 0x534e4554 <NEW_LINE>
if ( ! o -> isOutOfFlowPositioned ( ) && ( o -> isReplaced ( ) || o -> isFloating ( ) ) ) { <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( aDeclaration != mDeclaration ) { <NEW_LINE>mDeclaration = aDeclaration ; <NEW_LINE> } <NEW_LINE>
owner = do_QueryInterface ( ssm -> GetCxSubjectPrincipal ( cx ) ) ; <NEW_LINE>
udpmsg . msg_iovlen = 2 ; <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
safe_print ( value , valsz , "\"\\" ) ; <NEW_LINE>
syslog ( LOG_WARNING , _ ( " ( % d ) Unhandeled control packet type: % d , length: % d" ) , curconn -> seskey , cpkt . cptype , cpkt . length ) ; <NEW_LINE>
last_pts_ ( 0 ) { <NEW_LINE><NEW_LINE>cfg_ . g_threads = 1 ; <NEW_LINE> } <NEW_LINE>
fname_len = strlen ( fname ) ; <NEW_LINE>
CHECK_PIXEL_PTR ( 2 * byte_run ) ; <NEW_LINE>
ret = sort_idmaps ( & new_map ) ; <NEW_LINE>if ( ret < 0 ) <NEW_LINE>goto out ; <NEW_LINE><NEW_LINE>
stdnm = & object_prototype_names [ i ] ; <NEW_LINE>
& red_x , & red_y , & green_x , & green_y , & blue_x , & blue_y ) != 0 ) <NEW_LINE>
URLRequestContext * context ( ) { return context_ ; } <NEW_LINE>
xdr -> state = NULL ; <NEW_LINE>
NS_ASSERTION ( aScriptOwner , "This should never be null ! " ) ; <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
void usage_exit ( void ) { <NEW_LINE>
#if defined ( __cplusplus ) <NEW_LINE># if ! defined ( __STDC_FORMAT_MACROS ) <NEW_LINE># define __STDC_FORMAT_MACROS <NEW_LINE># endif <NEW_LINE># if ! defined ( __STDC_LIMIT_MACROS ) <NEW_LINE># define __STDC_LIMIT_MACROS <NEW_LINE># endif <NEW_LINE>#endif <NEW_LINE><NEW_LINE>
if ( PNG_CHUNK_ANCILLARY ( png_ptr -> chunk_name ) != 0 ) <NEW_LINE>
if ( mDrawingarea ) { <NEW_LINE>g_object_set_data ( G_OBJECT ( mDrawingarea -> clip_window ) , <NEW_LINE>"nsWindow" , NULL ) ; <NEW_LINE>g_object_set_data ( G_OBJECT ( mDrawingarea -> inner_window ) , <NEW_LINE>"nsWindow" , NULL ) ; <NEW_LINE><NEW_LINE>g_object_set_data ( G_OBJECT ( mDrawingarea -> clip_window ) , <NEW_LINE>"mozdrawingarea" , NULL ) ; <NEW_LINE>g_object_set_data ( G_OBJECT ( mDrawingarea -> inner_window ) , <NEW_LINE>"mozdrawingarea" , NULL ) ; <NEW_LINE><NEW_LINE>g_object_unref ( mDrawingarea ) ; <NEW_LINE>mDrawingarea = nsnull ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
167 , 75 , 137 , 138 , 76 , 94 , 78 , 181 , 203 , 192 , <NEW_LINE>141 , 140 , 190 , 125 , 196 , 144 , 179 , 186 , 187 , 79 , <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>nsresult nsIDNService::stringPrep ( const nsAString & in , nsAString & out , <NEW_LINE>PRBool allowUnassigned ) <NEW_LINE>
if ( IsFrozen ( ) ) {
<NEW_LINE><NEW_LINE>void Reset ( ) ; <NEW_LINE>
goto errout_free ; <NEW_LINE>
if ( ( s -> version & 0xFF00 ) == ( version & 0xFF00 ) ) <NEW_LINE><NEW_LINE>s -> version = ( unsigned short ) version ; <NEW_LINE>
char buf [ ME_MAX_FNAME + 1 ] ; <NEW_LINE>
already_AddRefed < dom::SVGTransform > GetItem ( uint32_t index , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE>already_AddRefed < dom::SVGTransform > IndexedGetter ( uint32_t index , bool & found , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE>
rv = NS_OpenURI ( this , nsnull , mURL , nsnull , nsnull , this ) ; <NEW_LINE>
#endif <NEW_LINE>
app -> company = ssplit ( slower ( ME_COMPANY ) , " " , NULL ) ; <NEW_LINE>
int rc , sep ; <NEW_LINE>
controller ( ) -> enqueue ( array ) ; <NEW_LINE>m_streamNeedsMore = controller ( ) -> desiredSize ( ) > 0 ; <NEW_LINE>
key = ssplit ( pair , " = " , & value ) ; <NEW_LINE>
cpi -> common . Width * cpi -> common . Height ; <NEW_LINE>
std::unique_ptr < icu::Transliterator > diacritic_remover_ ; <NEW_LINE>std::unique_ptr < icu::Transliterator > extra_confusable_mapper_ ; <NEW_LINE>
if ( curr -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
<NEW_LINE><NEW_LINE>SkPath::Convexity convexity = SkPath::kConvex_Convexity ; <NEW_LINE>if ( numPoints == 4 ) <NEW_LINE>convexity = SkPath::kUnknown_Convexity ; <NEW_LINE>path -> setConvexity ( convexity ) ; <NEW_LINE>
if ( child -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
: ProfileSyncService ( factory , profile , test_user ) , <NEW_LINE>
status = - EPERM ; <NEW_LINE> } else { <NEW_LINE>
FixGrayBits ( true ) ; <NEW_LINE>
* last_row , <NEW_LINE>
TRACK_RUN_IN_THIS_SCOPED_REGION ( member_func ) ; \ <NEW_LINE>
#include "third_party / blink / public / web / window_features . mojom - forward . h" <NEW_LINE>
last mod: $ Id: smallft . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE>
virtual void Focus ( LocalFrame * ) = 0 ; <NEW_LINE>
class BASE_EXPORT FidlInterfaceRequest { <NEW_LINE>
<NEW_LINE>if ( ! mProcessStyle || keyAtom != nsGkAtoms::style ) { <NEW_LINE>continue ; <NEW_LINE> } <NEW_LINE>
prior = mprReadJsonObj ( params , keyword ) ; <NEW_LINE>#if ME_EJS_PRODUCT <NEW_LINE><NEW_LINE>
<NEW_LINE>
#line 708 "ext / standard / var_unserializer . re" <NEW_LINE>
fd = TEMP_FAILURE_RETRY ( open ( uinput_dev_path [ x ] , O_RDWR ) ) ; <NEW_LINE>
nsnull ) ; <NEW_LINE><NEW_LINE>if ( ! wrapperObj || <NEW_LINE> ! ::JS_SetParent ( cx , wrapperObj , <NEW_LINE>wrappedNative -> GetScope ( ) -> GetGlobalJSObject ( ) ) || <NEW_LINE> ! ::JS_SetPrototype ( cx , wrapperObj , nsnull ) ) { <NEW_LINE>
nsWindow * window ; <NEW_LINE>GetContainerWindow ( & window ) ; <NEW_LINE>
ScriptState * script_state = ScriptState::ForCurrentRealm ( args ) ; <NEW_LINE>
btsnd_hcic_pin_code_neg_reply ( p_bda ) ; <NEW_LINE>return ; <NEW_LINE>
{ <NEW_LINE>nsCxPusher pusher ; <NEW_LINE>pusher . PushNull ( ) ; <NEW_LINE>rv = serializer -> SerializeToStream ( aDoc , output , aCharset ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> } <NEW_LINE>
nsCOMPtr < nsIContent > content = do_QueryReferent ( mContent ) ; <NEW_LINE>nsCOMPtr < EventTarget > windowRoot = content -> OwnerDoc ( ) -> GetWindow ( ) -> GetTopWindowRoot ( ) ; <NEW_LINE>nsContentUtils::DispatchTrustedEvent ( content -> OwnerDoc ( ) , <NEW_LINE>
if ( space_left <= 1 ) <NEW_LINE>return ( buf ) ; <NEW_LINE>string_size = strlcpy ( bufp , sepstr , space_left ) ; <NEW_LINE>if ( string_size >= space_left ) <NEW_LINE>return ( buf ) ; <NEW_LINE>bufp += string_size ; <NEW_LINE>space_left - = string_size ; <NEW_LINE>if ( space_left <= 1 ) <NEW_LINE>return ( buf ) ; <NEW_LINE>string_size = strlcpy ( bufp , lp -> s , space_left ) ; <NEW_LINE>if ( string_size >= space_left ) <NEW_LINE>return ( buf ) ; <NEW_LINE>bufp += string_size ; <NEW_LINE>space_left - = string_size ; <NEW_LINE>
if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { <NEW_LINE>mb2_cache_entry_put ( ext2_mb_cache , ce ) ; <NEW_LINE>unlock_buffer ( bh ) ; <NEW_LINE>brelse ( bh ) ; <NEW_LINE>goto again ; <NEW_LINE> } else if ( le32_to_cpu ( HDR ( bh ) -> h_refcount ) > <NEW_LINE>
virtual void TabDetachedAt ( content::WebContents * contents , <NEW_LINE>int index ) OVERRIDE ; <NEW_LINE>
<NEW_LINE>if ( aKey != ed -> mFFC -> mFocusedInputNode ) { <NEW_LINE>const_cast < nsINode * > ( aKey ) -> RemoveMutationObserver ( ed -> mFFC ) ; <NEW_LINE> } <NEW_LINE>
make_size ( png_store * const ps , png_byte const colour_type , int bdlo , <NEW_LINE>int const bdhi ) <NEW_LINE>
chrome_browser_net::DataReductionRequestType data_reduction_type ) ; <NEW_LINE>
return UnderlyingSourceBase::hasPendingActivity ( ) ; <NEW_LINE>
: cfg_ ( cfg ) , flags_ ( 0 ) , deadline_ ( deadline ) , init_done_ ( false ) { <NEW_LINE>memset ( & decoder_ , 0 , sizeof ( decoder_ ) ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>Decoder ( vpx_codec_dec_cfg_t cfg , const vpx_codec_flags_t flag , <NEW_LINE>unsigned long deadline ) <NEW_LINE>: cfg_ ( cfg ) , flags_ ( flag ) , deadline_ ( deadline ) , init_done_ ( false ) { <NEW_LINE>
if ( strlen ( str ) > MAXDATELEN ) <NEW_LINE>
} else if ( kea_def -> ephemeral ) { <NEW_LINE>rv = ssl3_SendServerKeyExchange ( ss ) ; <NEW_LINE>if ( rv != SECSuccess ) { <NEW_LINE>return rv ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
if ( container ) { <NEW_LINE>
size_t j , len = apdu . resp [ i + 1 ] ; <NEW_LINE>
UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id , u1_mb_aff_flag = 0 ; <NEW_LINE>
scale = adjust_scale ( scale ) ; <NEW_LINE>
<NEW_LINE>#if defined ( OS_MACOSX ) <NEW_LINE><NEW_LINE><NEW_LINE>IPC_MESSAGE_CONTROL1 ( ChromeUtilityMsg_AnalyzeDmgFileForDownloadProtection , <NEW_LINE>IPC::PlatformFileForTransit ) <NEW_LINE>#endif <NEW_LINE>#endif <NEW_LINE>
xmlChar out [ 16 ] ; <NEW_LINE>
<NEW_LINE>
if ( optimize == 0 ) <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
if ( verbose != 0 ) <NEW_LINE>
( url_Encoded ? " ( " : "" ) , ( url_Encoded ? url_Encoded : "" ) , ( url_Encoded ? " ) " : "" ) ) ; <NEW_LINE><NEW_LINE>free ( url_Encoded ) ; <NEW_LINE>
HasUnreachableGCThings ( JSContext * cx , TreeFragment * f ) <NEW_LINE> { <NEW_LINE>
eWOFF_warn_no_such_table = 0x4000 <NEW_LINE>
value = ( unsigned int ) buffer [ 0 ] << 24 ; <NEW_LINE>value |= ( unsigned int ) buffer [ 1 ] << 16 ; <NEW_LINE>value |= ( unsigned int ) buffer [ 2 ] << 8 ; <NEW_LINE>value |= ( unsigned int ) buffer [ 3 ] ; <NEW_LINE>quantum . unsigned_value = value & 0xffffffff ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
if ( segment_stop >= 0 && pos > segment_stop ) <NEW_LINE>return E_FILE_FORMAT_INVALID ;
static void performCheckpoint ( v8::Isolate * ) ; <NEW_LINE>
if ( pm ) { <NEW_LINE>
_y4m -> bps = 16 ; <NEW_LINE>
nsCOMPtr < nsIURI > uriToLoad = mURIToLoad ; <NEW_LINE>rv = mDocShell -> LoadURI ( uriToLoad , loadInfo , flags , false ) ; <NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_SWAP_ALPHA ) != 0 ) <NEW_LINE>
#include "base / callback_old . h" <NEW_LINE>
{ <NEW_LINE>i_temp = ih264d_read_mmco_commands ( ps_dec ) ; <NEW_LINE>if ( i_temp < 0 ) <NEW_LINE> { <NEW_LINE>return ERROR_DBP_MANAGER_T ; <NEW_LINE> } <NEW_LINE>ps_dec -> u4_bitoffset = i_temp ; <NEW_LINE> } <NEW_LINE>
memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE>
nsCOMPtr < nsIContent > content = do_QueryReferent ( mContent ) ; <NEW_LINE>if ( content ) { <NEW_LINE>doc = content -> OwnerDoc ( ) ; <NEW_LINE>
if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || <NEW_LINE>
nsIconDecoder::WriteInternal ( const char * aBuffer , uint32_t aCount , DecodeStrategy ) <NEW_LINE>
NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * kdelegate , void * val ) = 0 ; <NEW_LINE>
#endif <NEW_LINE>
mLoadedDocuments . init ( txXPathNodeUtils::getOwnerDocument ( aNode ) ) ; <NEW_LINE>
memset ( ylptr , mb_ppl , 16 ) ; <NEW_LINE>memset ( uvlptr , mb_ppl , 8 ) ; <NEW_LINE>
virtual PrefService * GetOriginalProfilePrefs ( ) const ;
std::cout << " GenerateWord32 and Crop\n" ;
header -> checkHeader ( ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( NS_FAILED ( mIOThread -> Shutdown ( ) ) ) { <NEW_LINE>NS_WARNING ( "Failed to shutdown IO thread ! " ) ; <NEW_LINE> } <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
void set_is_cors_cross_origin ( bool is_cors_cross_origin ) ;
jspReplaceWithOrAddToRoot ( lhs , rhs ) ; <NEW_LINE>
if ( dot < cosConeAngle ) dot = 0 ; <NEW_LINE>float tmp = pow ( dot , specularExponent ) ; <NEW_LINE>color = NS_RGB ( PRUint8 ( NS_GET_R ( lightColor ) * tmp ) , <NEW_LINE>PRUint8 ( NS_GET_G ( lightColor ) * tmp ) , <NEW_LINE>PRUint8 ( NS_GET_B ( lightColor ) * tmp ) ) ; <NEW_LINE>
jas_uchar * dp ; <NEW_LINE>
if ( mem == NULL ) <NEW_LINE>
nsRefPtr < MediaResource > mResource ; <NEW_LINE>
#line 505 "ext / standard / var_unserializer . re" <NEW_LINE>
while ( ( ( RAW != 0 ) && ( ( RAW != ' ] ' ) || ( NXT ( 1 ) != ' ] ' ) || <NEW_LINE> ( NXT ( 2 ) != ' > ' ) ) ) && ( ctxt -> instate != XML_PARSER_EOF ) ) { <NEW_LINE>
if ( test_opt ( sb , DIOREAD_NOLOCK ) ) { <NEW_LINE>ext4_msg ( sb , KERN_WARNING , "dioread_nolock option is " <NEW_LINE>"not supported with nobh mode" ) ; <NEW_LINE>goto failed_mount_wq ; <NEW_LINE> } <NEW_LINE>
xref -> entries = safe_calloc ( xref -> n_entries * sizeof ( struct _xref_entry ) ) ; <NEW_LINE>
XPCWrappedNativeJSClass * clasp = <NEW_LINE> ( XPCWrappedNativeJSClass * ) js::GetObjectClass ( cur ) ; <NEW_LINE>
if ( childrenInline ( ) && ! newChild -> isInline ( ) && ! newChild -> isFloatingOrOutOfFlowPositioned ( ) ) { <NEW_LINE>
AutoAtomicIncrement incr ( & cx -> runtime -> inOOMReport ) ; <NEW_LINE>
: mMarkedForDeath ( false ) <NEW_LINE> , mUsingXBLScope ( false ) <NEW_LINE> , mPrototypeBinding ( aBinding ) <NEW_LINE>
static const uint32_t ISO2022JPCharLenTable [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; <NEW_LINE>
image -> columns = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0 . 5 ) ; <NEW_LINE>
if ( ! last -> isText ( ) && last -> style ( ) -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
#endif <NEW_LINE>
if ( png_image_begin_read_from_file ( & image , argv [ 1 ] ) != 0 ) <NEW_LINE>
gr_face * face = gr_make_face_with_ops ( & dummyFace , & face_handle::ops , 0 ) ; <NEW_LINE>
sctp_copy_descendant ( newsk , oldsk ) ;
( ( ci -> blocksizes [ v -> lW ] / 4 + <NEW_LINE>ci -> blocksizes [ v -> W ] / 4 ) >> hs ) ; <NEW_LINE>
if ( that -> colour_type == PNG_COLOR_TYPE_RGB_ALPHA ) <NEW_LINE>that -> colour_type = PNG_COLOR_TYPE_RGB ; <NEW_LINE>else if ( that -> colour_type == PNG_COLOR_TYPE_GRAY_ALPHA ) <NEW_LINE>that -> colour_type = PNG_COLOR_TYPE_GRAY ; <NEW_LINE><NEW_LINE><NEW_LINE>
while ( ! cb -> isRenderView ( ) && ! cb -> isBody ( ) && ! cb -> isTableCell ( ) && ! cb -> isOutOfFlowPositioned ( ) && cb -> style ( ) -> logicalHeight ( ) . isAuto ( ) ) { <NEW_LINE>
<NEW_LINE>#define STREAMTCP_STREAM_FLAG_RST_RECV 0x800
ACPI_STATUS ReturnStatus = AE_OK ; <NEW_LINE>BOOLEAN Ascending = TRUE ; <NEW_LINE>
<NEW_LINE>
WCHAR installDir [ MAX_PATH + 1 ] = { L'\0' } ; <NEW_LINE>
if ( mCachedBandPosition == rect ) { <NEW_LINE><NEW_LINE>SetCachedBandPosition ( band ) ; <NEW_LINE> } <NEW_LINE>
IPC_MESSAGE_ROUTED3 ( PluginMsg_HandleURLRequestReply , <NEW_LINE>unsigned long , <NEW_LINE>GURL , <NEW_LINE>int ) <NEW_LINE><NEW_LINE>IPC_MESSAGE_ROUTED2 ( PluginMsg_HTTPRangeRequestReply , <NEW_LINE>unsigned long , <NEW_LINE>int ) <NEW_LINE>
int vp9_quantizer_to_qindex ( int quantizer ) ; <NEW_LINE><NEW_LINE>int vp9_qindex_to_quantizer ( int qindex ) ; <NEW_LINE><NEW_LINE>
SeekHead:: ~ SeekHead ( ) { } <NEW_LINE>
const int anon_tls_kx_order [ ] = { <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
void DidFocus ( blink::WebLocalFrame * calling_frame ) override ; <NEW_LINE>
input_method::ImePropertyList ime_properties_ ; <NEW_LINE>input_method::InputMethodDescriptor current_input_method_ ; <NEW_LINE>input_method::InputMethodDescriptor previous_input_method_ ; <NEW_LINE>
#define XSLTPUBVAR extern <NEW_LINE>
#define DOUBLEFAULT_STACK 1 <NEW_LINE>#define NMI_STACK 2 <NEW_LINE>#define DEBUG_STACK 3 <NEW_LINE>#define MCE_STACK 4 <NEW_LINE>#define N_EXCEPTION_STACKS 4 <NEW_LINE>
mozilla::WeakPtr < nsOfflineCacheUpdateOwner > mOwner ; <NEW_LINE>
int no_tmp_rsa = 0 , no_dhe = 0 , nocert = 0 ; <NEW_LINE>
mStack . Push ( cx , nsCxPusher::ALWAYS_PUSH ) ; <NEW_LINE>
va_list args ) <NEW_LINE>
TEMP_FAILURE_RETRY ( usleep ( ms * 1000 ) ) ; <NEW_LINE>
make_errors ( png_modifier * const pm , png_byte const colour_type , <NEW_LINE>int bdlo , int const bdhi ) <NEW_LINE>
MBEDTLS_MPI_CHK ( mbedtls_ecp_gen_privkey ( grp , & k , f_rng , p_rng ) ) ; <NEW_LINE><NEW_LINE>MBEDTLS_MPI_CHK ( mbedtls_ecp_mul ( grp , & R , & k , & grp -> G , <NEW_LINE>f_rng_blind , p_rng_blind ) ) ; <NEW_LINE>
const QString tmp_dir = " / var / cache / deepin - clone" ; <NEW_LINE>
<NEW_LINE>extern loopfilter_y_neon vp8_mbloop_filter_horizontal_edge_y_neon ; <NEW_LINE>extern loopfilter_y_neon vp8_mbloop_filter_vertical_edge_y_neon ; <NEW_LINE>
size_t alloc_size = 0 ; <NEW_LINE><NEW_LINE>if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) <NEW_LINE>return TEE_ERROR_OVERFLOW ; <NEW_LINE><NEW_LINE>params = malloc ( alloc_size ) ; <NEW_LINE>
case 0x6e6d636c: <NEW_LINE>
GtkWidget * widget = <NEW_LINE>get_gtk_widget_for_gdk_window ( plugin_window ) ; <NEW_LINE>
kenter ( " % % % d , % s , ' % * . * s' , % zu" , <NEW_LINE>key -> serial , key -> description , <NEW_LINE> ( int ) datalen , ( int ) datalen , data , datalen ) ; <NEW_LINE>
record_and_restart ( event , val , regs ) ; <NEW_LINE>
if ( ! parser -> tokenStream . seek ( position , tokenStream ) ) <NEW_LINE>return false ; <NEW_LINE>
return ( SkipDXTMipmaps ( image , dds_info , 16 , exception ) ) ; <NEW_LINE>
for ( ii = 0 ; ii < file -> sec_attr_len / 2 && ii < sizeof ops_DF ; ii ++ ) { <NEW_LINE>
m_blobDataHandles . set ( file -> uuid ( ) , file -> blobDataHandle ( ) ) ; <NEW_LINE>
if ( rec_hdr . hdr . incl_len > WTAP_MAX_PACKET_SIZE ) { <NEW_LINE>
if ( ! surface || cairo_surface_status ( surface ) ) <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
nsCOMPtr < nsIDocument > doc = mContent -> GetCurrentDoc ( ) ; <NEW_LINE>
NS_DEFINE_CLASSINFO_DATA ( DocumentFragment , nsNodeSH , NODE_SCRIPTABLE_FLAGS ) <NEW_LINE>
<NEW_LINE>if ( length > MT_PACKET_LEN - packet -> size ) { <NEW_LINE>
size_t num_samples ; <NEW_LINE><NEW_LINE>JAS_DBGLOG ( 100 , ( "jpg_decode ( % p , \" % s\" ) \n" , in , optstr ) ) ; <NEW_LINE>
<NEW_LINE>
int npasses = set_write_interlace_handling ( pp , interlace_type ) ; <NEW_LINE>
test_standard ( png_modifier * const pm , png_byte const colour_type , <NEW_LINE>int bdlo , int const bdhi ) <NEW_LINE>
if ( ( png_ptr -> row_number & 0x07 ) != 0 || png_ptr -> width < 5 ) <NEW_LINE>
if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE>
perf_swevent_event ( bp , 1 , & sample , regs ) ; <NEW_LINE>
HeapObjectHeader::fromPayload ( t ) -> checkHeader ( ) ; <NEW_LINE>
if ( result == 0 ) <NEW_LINE>
<NEW_LINE>virtual void DidStopLoading ( ) OVERRIDE ; <NEW_LINE>virtual void RenderViewGone ( ) OVERRIDE ; <NEW_LINE><NEW_LINE>
for ( i = 0 ; i < length && * data ; i ++ , data ++ ) <NEW_LINE>
{ <NEW_LINE>nsCxPusher pusher ; <NEW_LINE>pusher . PushNull ( ) ; <NEW_LINE>rv = serializer -> SerializeToStream ( doc , output , aCharset ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> } <NEW_LINE>
ZEND_FETCH_RESOURCE ( pm , php_mcrypt * , & mcryptind , - 1 , "MCrypt" , le_mcrypt ) ; <NEW_LINE>
int <NEW_LINE>
<NEW_LINE>#include < jasper / jas_config . h > <NEW_LINE><NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
#include "chrome / browser / chromeos / input_method / ibus_controller . h" <NEW_LINE>
if ( oldStyle && parent ( ) && diff . needsFullLayout ( ) && oldStyle -> position ( ) != newStyle . position ( ) ) { <NEW_LINE>
if ( prevBlock -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
<NEW_LINE><NEW_LINE>WebKit::WebFrame * GetFrameByRemoteID ( int remote_frame_id ) ; <NEW_LINE>
#line 590 "ext / standard / var_unserializer . re" <NEW_LINE>
nsCxPusher mCxPusher ; <NEW_LINE><NEW_LINE>
if ( XDRAtomsHashMap::Ptr p = xdr -> atomsMap -> lookup ( atom ) ) <NEW_LINE>
option = ssplit ( option , " = \t , " , & ovalue ) ; <NEW_LINE>
const unsigned int i = this -> palette_index ; <NEW_LINE>
static ngx_int_t ngx_http_test_precondition ( ngx_http_request_t * r ) ; <NEW_LINE>static ngx_int_t ngx_http_test_not_modified ( ngx_http_request_t * r ) ; <NEW_LINE>
if ( credit < 0 ) { <NEW_LINE>long n_pages ; <NEW_LINE><NEW_LINE>n_pages = min ( - credit , si_mem_available ( ) ) ; <NEW_LINE>state = decrease_reservation ( n_pages , GFP_BALLOON ) ; <NEW_LINE>if ( state == BP_DONE && n_pages != - credit && <NEW_LINE>n_pages < totalreserve_pages ) <NEW_LINE>state = BP_EAGAIN ; <NEW_LINE> } <NEW_LINE>
if ( ! src_addr ) <NEW_LINE>src_addr = ep_alloc ( ADDR_MAX_LEN ) ; <NEW_LINE><NEW_LINE>if ( ! dst_addr ) <NEW_LINE>dst_addr = ep_alloc ( ADDR_MAX_LEN ) ; <NEW_LINE>
SSL_SET_OPTIONS ( & mysql ) ; <NEW_LINE>
gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; <NEW_LINE>gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ; <NEW_LINE>
nsGopherChannel::OpenContentStream ( PRBool async , nsIInputStream ** result , <NEW_LINE>nsIChannel ** channel ) <NEW_LINE>
rc = fsmVerify ( fpath , fi , & sb ) ; <NEW_LINE>
weight = ( ssize_t ) StringToUnsignedLong ( option ) ; <NEW_LINE>
return ( png_byte ) ( value & 0xff ) ; <NEW_LINE>
<NEW_LINE>
<NEW_LINE>nsContentUtils::AddScriptRunner ( <NEW_LINE>NS_NewRunnableMethod ( this , & nsXULTemplateBuilder::UninitFalse ) ) ; <NEW_LINE>
if ( atBeforeSideOfBlock && logicalTop == newLogicalTop && allowsPaginationStrut ( ) ) {
void SetRenderer ( int process_host_id , <NEW_LINE>
JSObject * jso = to -> GetJSObjectPreserveColor ( ) ; <NEW_LINE>
long long UnserializeUInt ( IMkvReader * pReader , long long pos , long long size ) { <NEW_LINE>if ( ! pReader || pos < 0 || ( size <= 0 ) || ( size > 8 ) ) <NEW_LINE>
} else { <NEW_LINE><NEW_LINE>if ( handler == NULL ) <NEW_LINE>handler = xmlFindCharEncodingHandler ( "HTML" ) ; <NEW_LINE>if ( handler == NULL ) <NEW_LINE>handler = xmlFindCharEncodingHandler ( "ascii" ) ; <NEW_LINE>
static int CVE_2014_5471_isofs_read_inode ( struct inode * inode , int relocated ) <NEW_LINE>
if ( equalIgnoringASCIICase ( getAttribute ( aria_hiddenAttr ) , "false" ) ) <NEW_LINE>
MetadataTags ** aTags ) <NEW_LINE>
if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) >= GetBlobSize ( image ) ) <NEW_LINE>
set1 -> nodeTab [ set1 -> nodeNr ++ ] = n2 ; <NEW_LINE>
AutoPushJSContext jscontext ( context -> GetNativeContext ( ) ) ; <NEW_LINE>
if ( ! mIsSystemXHR && <NEW_LINE>
TEMP_FAILURE_RETRY ( recv ( signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ) ; <NEW_LINE>
if ( aNewParent && ! JS_SetParent ( ccx , wrapper -> GetFlatJSObject ( ) , aNewParent ) ) <NEW_LINE>
memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ; <NEW_LINE>
vpx_mse16x16 ( orig + col , orig_stride , <NEW_LINE>
while ( longindex = - 1 , ( c = getopt_long ( argc , argv , ":vhlndu:DRS:f:p:i:mM::g::Gt::" <NEW_LINE>
BASE_API std::ostream & operator << ( std::ostream & out , const wchar_t * wstr ) ; <NEW_LINE>
public nsStubMutationObserver , <NEW_LINE>public nsIDocument_MOZILLA_1_9_2_BRANCH <NEW_LINE>
jas_uchar inbuffer ; <NEW_LINE>
cmdSize < sizeof ( effect_param_t ) || <NEW_LINE>pReplyData == NULL || replySize == NULL || <NEW_LINE>
clazz , swap , 4 , flags , notecount ) ; <NEW_LINE>
static int <NEW_LINE>dccp_print_option ( netdissect_options * ndo , const u_char * option , u_int hlen ) <NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_BGR ) != 0 ) <NEW_LINE>
distortion = vpx_variance16x16 <NEW_LINE>
atable -> arev = newrev ; <NEW_LINE>
#include "core / fileapi / BlobRegistry . h" <NEW_LINE>
if ( ! ( buf = jas_alloc3 ( bufsize , numcols , sizeof ( jpc_fix_t ) ) ) ) { <NEW_LINE>
XPCAutoRequest ar ( mContext ) ; <NEW_LINE>
conn -> m -> local_tx_end ( conn , this_func , result == NULL ? FAIL:PASS TSRMLS_CC ) ; <NEW_LINE>
NS_ENSURE_NATIVE_COLUMN ( aCol ) ; <NEW_LINE>
int iSC ; <NEW_LINE>if ( len < 1 + iACLen ) <NEW_LINE>break ; <NEW_LINE>iSC = buf [ iOffset + iACLen ] ; <NEW_LINE>
<NEW_LINE>
return equalIgnoringASCIICase ( toElement ( node ) -> getAttribute ( roleAttr ) , role ) ; <NEW_LINE>
DECLARE_ALIGNED ( 16 , unsigned char , FData2 [ 24 * 24 ] ) ; <NEW_LINE>
tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <NEW_LINE>if ( ! tmp2 ) <NEW_LINE>free ( tmp ) ; <NEW_LINE>tmp = tmp2 ; <NEW_LINE>
jspReplaceWithOrAddToRoot ( forStatement , indexValue ) ; <NEW_LINE>
CheckedNumeric < unsigned > totalBytes = options . cropRect . width ( ) ; <NEW_LINE>
size_t size , off_t fsize , int mach , int strtab , int * flags , <NEW_LINE>uint16_t * notecount ) <NEW_LINE>
if ( doc -> psvi == XSLT_RVT_FUNC_RESULT ) <NEW_LINE>doc -> psvi = XSLT_RVT_LOCAL ; <NEW_LINE>
set_intr_gate ( X86_TRAP_SS , stack_segment ) ; <NEW_LINE>
if ( header -> bDescriptorType == type && header -> bLength >= minsize ) { <NEW_LINE>
ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; <NEW_LINE>
sandbox_flags_ ( kSandboxNone ) , <NEW_LINE>did_load_non_empty_document_ ( false ) { } <NEW_LINE>
<NEW_LINE>
static void yv12_copy_partial_frame ( YV12_BUFFER_CONFIG * src_ybc , <NEW_LINE>YV12_BUFFER_CONFIG * dst_ybc ) <NEW_LINE>
CompositableHost * compositableHost = compositableParent -> GetCompositableHost ( ) ; <NEW_LINE>if ( compositableHost -> GetType ( ) != COMPOSITABLE_CONTENT_SINGLE && <NEW_LINE>compositableHost -> GetType ( ) != COMPOSITABLE_CONTENT_DOUBLE ) <NEW_LINE> { <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE>DeprecatedContentHostBase * content = static_cast < DeprecatedContentHostBase * > ( compositableHost ) ; <NEW_LINE>
Microtask::performCheckpoint ( V8PerIsolateData::mainThreadIsolate ( ) ) ; <NEW_LINE>
JSObject ** aTargetClassObject , <NEW_LINE>bool * aTargetIsNew ) <NEW_LINE>
vorbis_info_floor * infoX , <NEW_LINE>vorbis_look_floor0 * look ) { <NEW_LINE>
for ( size_t index = 1 ; index < array -> Count ( ) ; ++ index ) { <NEW_LINE>
if ( ! result -> isOutOfFlowPositioned ( ) && ( result -> isText ( ) || result -> isFloating ( ) || result -> isReplaced ( ) || result -> isRenderInline ( ) ) ) <NEW_LINE>
if ( ! gWorkingDir . isEmpty ( ) ) { <NEW_LINE>QDir ( ) . mkpath ( gWorkingDir ) ; <NEW_LINE>QFile::setPermissions ( gWorkingDir , <NEW_LINE>QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
index = hash & hashmask ( hashtable -> order ) ; <NEW_LINE>
bool result = mPusher . Push ( mCx ) ; <NEW_LINE>
content::BrowserContext * context_ ; <NEW_LINE>
( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) != 0 ) <NEW_LINE>
<NEW_LINE>
class HistoryModelWorker : public browser_sync::ModelSafeWorker { <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
} JSVAL_ALIGNMENT jsval_layout ; <NEW_LINE>
if ( compose != 0 ) <NEW_LINE>
}
RefPtr < TestNode > imp = WTF::getPtr ( proxyImp -> locationReplaceable ( ) ) ; <NEW_LINE>
NS_ENSURE_NATIVE_COLUMN ( aCol ) ; <NEW_LINE>
void ptrace_triggered ( struct perf_event * bp , <NEW_LINE>
const MB_MODE_INFO * const above_mbmi = xd -> above_mbmi ; <NEW_LINE>const MB_MODE_INFO * const left_mbmi = xd -> left_mbmi ; <NEW_LINE>const int above_in_image = xd -> up_available ; <NEW_LINE>const int left_in_image = xd -> left_available ;
EXPECT_TRUE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE>EXPECT_TRUE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE>EXPECT_TRUE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE>EXPECT_TRUE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE>EXPECT_TRUE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE>
<NEW_LINE><NEW_LINE>static bool MatchesImplicitRules ( const GURL & url ) ; <NEW_LINE>private: <NEW_LINE>
nsAutoCauseReflowNotifier reflowNotifier ( this ) ; <NEW_LINE>
bool hasClip ( ) const { return isOutOfFlowPositioned ( ) && style ( ) -> hasClip ( ) ; } <NEW_LINE>
uint64 void_entry_size = size - 1 - GetCodedUIntSize ( size - 1 ) ; <NEW_LINE>uint64 void_size = <NEW_LINE>EbmlMasterElementSize ( kMkvVoid , void_entry_size ) + void_entry_size ; <NEW_LINE>
#ifndef BASE_DEFERRED_SEQUENCED_TASK_RUNNER_H_ <NEW_LINE>#define BASE_DEFERRED_SEQUENCED_TASK_RUNNER_H_ <NEW_LINE>
NS_ENSURE_STATE ( pusher . Push ( ctx ) ) ; <NEW_LINE>
if ( imageBitmap ) { <NEW_LINE>resolver -> resolve ( imageBitmap ) ; <NEW_LINE> } else { <NEW_LINE>v8::Isolate * isolate = ScriptState::current ( ) -> isolate ( ) ; <NEW_LINE>resolver -> reject ( ScriptValue ( v8::Null ( isolate ) , isolate ) ) ; <NEW_LINE> } <NEW_LINE>
if ( curr -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
case 0x73636e72: <NEW_LINE>case 0x6d6e7472: <NEW_LINE>
NS_ConvertUTF16toUTF8 ( source ) . get ( ) , 1 , <NEW_LINE>returnString , rval ) ; <NEW_LINE>
for ( valueEnd = str ; * valueEnd ; ++ valueEnd ) { <NEW_LINE>if ( * valueEnd == '\\' && * ( valueEnd + 1 ) ) <NEW_LINE>
<NEW_LINE>
if ( ! origin_tainted_by_content_ && ! canvas_pattern -> OriginClean ( ) ) <NEW_LINE>SetOriginTaintedByContent ( ) ; <NEW_LINE>
nsContentUtils::AddScriptRunner ( <NEW_LINE>NS_NEW_RUNNABLE_METHOD ( nsXULTemplateBuilder , this , UninitTrue ) ) ; <NEW_LINE>
memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ; <NEW_LINE>
memset ( mbr_ei [ i ] . segment_counts , 0 , sizeof ( mbr_ei [ i ] . segment_counts ) ) ; <NEW_LINE>
protected: <NEW_LINE>friend class AudioClock ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>int64_t GetPositionInFramesUnlocked ( ) ; <NEW_LINE><NEW_LINE>
<NEW_LINE>dst = ! IS_ERR ( rt ) ? & rt -> dst : NULL ; <NEW_LINE>sk_dst_set ( sk , dst ) ; <NEW_LINE><NEW_LINE>
if ( ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) != 0 ) <NEW_LINE>
extern void show_object_with_name ( FILE * , struct object * , const char * ) ; <NEW_LINE>
static void php_mb_regex_free_cache ( php_mb_regex_t ** pre ) <NEW_LINE>
nscoord newHeight ; <NEW_LINE>PRInt32 rows ; <NEW_LINE>if ( visibleHeight <= availableHeight ) { <NEW_LINE><NEW_LINE>rows = GetNumberOfOptions ( ) ; <NEW_LINE>mNumDisplayRows = clamped ( rows , 1 , kMaxDropDownRows ) ; <NEW_LINE>if ( mNumDisplayRows == rows ) { <NEW_LINE>newHeight = visibleHeight ; <NEW_LINE> } else { <NEW_LINE>newHeight = mNumDisplayRows * heightOfARow ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE>rows = availableHeight / heightOfARow ; <NEW_LINE>mNumDisplayRows = clamped ( rows , 1 , kMaxDropDownRows ) ; <NEW_LINE>newHeight = mNumDisplayRows * heightOfARow ; <NEW_LINE> } <NEW_LINE>
imap_quote_string ( term , sizeof ( term ) , pat -> p . str , false ) ; <NEW_LINE>
scale = adjust_scale ( scale ) ; <NEW_LINE>
#line 1087 "ext / standard / var_unserializer . c" <NEW_LINE>
<NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ; <NEW_LINE>
@stability Stable <NEW_LINE>
#endif
r = safe_mount ( "cgroup_root" , path , "tmpfs" , <NEW_LINE>MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , <NEW_LINE>"size = 10240k , mode = 755" , <NEW_LINE>root ) ; <NEW_LINE>
XPCAutoRequest ar ( mContext ) ; <NEW_LINE>
next_char = get_next_char ( charset , old , oldlen , cursor , & status ) ; <NEW_LINE>
MOZ_ASSERT ( bracketPart . IsEmpty ( ) , "SplitLastSquareBracket must be called with empty bracketPart string" ) ; <NEW_LINE><NEW_LINE>if ( string . IsEmpty ( ) ) <NEW_LINE>return false ; <NEW_LINE><NEW_LINE>
NS_ASSERTION ( js::GetGlobalForObjectCrossCompartment ( obj ) == newScope , <NEW_LINE>"Wrong scope , this is really bad ! " ) ; <NEW_LINE>
RefPtr < SharedBuffer > testData = readFile ( decodersTestingDir , "bad - code . gif" ) ; <NEW_LINE>
#include "media / audio / audio_device_thread . h" <NEW_LINE>
long	num_head = 0 ; <NEW_LINE>
if ( __perf_event_overflow ( event , throttle , <NEW_LINE>
#endif
: m_haveInitializedSecurityOrigin ( false ) <NEW_LINE>
mCachedRootElement = nullptr ; <NEW_LINE>
oggpack_buffer * b , int n , int point ) { <NEW_LINE>
unsigned int pixel_limit ; <NEW_LINE>
if ( ! EnsureStringLength ( output , resultLen ) ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE>
if ( ! cx -> cycleDetectorSet . init ( ) ) { <NEW_LINE>
ND_PRINT ( ( ndo , " % s" , tstr ) ) ; <NEW_LINE>
#if defined ( PNG_WRITE_SUPPORTED ) && \ <NEW_LINE>defined ( PNG_WRITE_FILTER_SUPPORTED ) <NEW_LINE>if ( interlace_preserved != 0 ) <NEW_LINE>
return 1 ; <NEW_LINE>
if ( ( png_ptr -> do_filter ) == PNG_NO_FILTERS ) <NEW_LINE>
bool OutputFasterPlayback ( uint8 * dest , int input_step , int output_step ) ;
<NEW_LINE>
if ( file -> file_type == FILE_TYPE_GEOMETRY ) { <NEW_LINE>log_vrb ( ctx , 1 , <NEW_LINE>"Geometry sections are not supported ; ignoring\n" ) ; <NEW_LINE> } else { <NEW_LINE>log_err ( ctx , "Cannot define % s in a keymap file\n" , <NEW_LINE>xkb_file_type_to_string ( file -> file_type ) ) ; <NEW_LINE> } <NEW_LINE>
if ( aStrategy == DECODE_SYNC && aImg -> mDecoder -> NeedsNewFrame ( ) ) { <NEW_LINE>
CheckedInt < uint32_t > newlen ( rdata . sb . length ( ) ) ; <NEW_LINE>newlen += leftlen ; <NEW_LINE>newlen += replen ; <NEW_LINE>if ( ! newlen . isValid ( ) ) { <NEW_LINE>js_ReportAllocationOverflow ( cx ) ; <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE>if ( ! rdata . sb . reserve ( newlen . value ( ) ) ) <NEW_LINE>
<NEW_LINE>
svc_rdma_send_error ( rdma_xprt , & rmsgp -> rm_xid , ret ) ; <NEW_LINE>
while ( next_format ( & colour_type , & bit_depth , & palette_number , <NEW_LINE>pm -> test_lbg_gamma_transform , pm -> test_tRNS ) ) <NEW_LINE>
nsTreeColumns::InvalidateColumns ( ) ; <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
ObjectValueMap::Ptr ptr = weakmap -> map . lookup ( key ) ; <NEW_LINE>
static int cost_segmap ( int * segcounts , vpx_prob * probs ) { <NEW_LINE>
if ( png_image_write_init ( image ) != 0 ) <NEW_LINE>
class KeyboardLibrary ; <NEW_LINE>
if ( png_sig_cmp ( info_ptr -> signature , num_checked , num_to_check ) != 0 ) <NEW_LINE>
appendAttribute ( out , element , Attribute ( frameOwnerURLAttributeName ( * frameOwner ) , url . string ( ) ) , namespaces ) ; <NEW_LINE>
memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <NEW_LINE>memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; <NEW_LINE>memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; <NEW_LINE>
} <NEW_LINE>
lastProp = bindings . callObjectShape ( cx ) ; <NEW_LINE>
static int release_vp9_frame_buffer ( void * cb_priv , <NEW_LINE>vpx_codec_frame_buffer_t * fb ) { <NEW_LINE>
if ( ! m_frame ) <NEW_LINE>return true ; <NEW_LINE>Frame * parent = m_frame -> tree ( ) . parent ( ) ; <NEW_LINE>while ( parent ) { <NEW_LINE>if ( ! parent -> securityContext ( ) -> getSecurityOrigin ( ) -> isPotentiallyTrustworthy ( ) ) <NEW_LINE>return false ; <NEW_LINE>parent = parent -> tree ( ) . parent ( ) ; <NEW_LINE> } <NEW_LINE>
if ( used_address && msg_sys -> msg_name && <NEW_LINE>used_address -> name_len == msg_sys -> msg_namelen && <NEW_LINE> ! memcmp ( & used_address -> name , msg_sys -> msg_name , <NEW_LINE>
<NEW_LINE>
#line 1589 "dcraw / dcraw . c" <NEW_LINE>
goto bail ; <NEW_LINE>
if ( hash == 0 || key == 0 ) { <NEW_LINE>assert ( hash && key ) ; <NEW_LINE>
u64 seqnum ; <NEW_LINE>
xsh_size , clazz , swap , 4 , flags , notecount ) ; <NEW_LINE>
dom::Uint8ClampedArray * aArray , <NEW_LINE>
#define FC_NUM_CASE_FOLD	288 <NEW_LINE>
ret = TEMP_FAILURE_RETRY ( sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ) ; <NEW_LINE>
int cond_len , then_len , else_len , jump_len ; <NEW_LINE>
ColorMapObject * map ; <NEW_LINE>
png_int_32 i = ( ( png_int_32 ) ( ( * ( buf ) ) & 0xff ) << 24 ) + <NEW_LINE> ( ( png_int_32 ) ( ( * ( buf + 1 ) ) & 0xff ) << 16 ) + <NEW_LINE> ( ( png_int_32 ) ( ( * ( buf + 2 ) ) & 0xff ) << 8 ) + <NEW_LINE> ( ( png_int_32 ) ( ( * ( buf + 3 ) ) & 0xff ) ) ; <NEW_LINE>
let file = getMaintSvcDir ( ) ; <NEW_LINE>
: wp -> setter ( cx , obj , userid , vp ) ) ; <NEW_LINE>
strncpy ( v -> Prefix , Prefix , sizeof ( v -> Prefix ) - 1 ) ; <NEW_LINE>strncpy ( v -> Suffix , Suffix , sizeof ( v -> Suffix ) - 1 ) ; <NEW_LINE>
<NEW_LINE>
new ( std::nothrow ) ContentEncryption * [ encryption_count ] ; <NEW_LINE>
tok , next , & next , XML_FALSE , XML_TRUE ) ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
NS_IMPL_ISUPPORTS ( nsSHEntry , nsISHContainer , nsISHEntry_ESR38 , nsISHEntry , nsISHEntryInternal ) <NEW_LINE>
TestInterfaceNode * impl = V8TestInterfaceNode::toImpl ( holder ) ; <NEW_LINE>
if ( ! page || ! page -> isPageVisible ( ) ) <NEW_LINE>
relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , layer_hint ) ; <NEW_LINE>
cwd_skip = strlen ( cwd ) + 1 ; <NEW_LINE>
<NEW_LINE>
case SPL_FS_DIR: <NEW_LINE>
delete [ ] content_encoding_entries_ ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
void OnGoToEntryAtOffset ( RenderViewHostImpl * source , <NEW_LINE>int offset , <NEW_LINE>bool has_user_gesture ) ; <NEW_LINE>
frame_ssim2 = vpx_calc_ssim ( cpi -> Source , <NEW_LINE> & cm -> post_proc_buffer , & weight ) ; <NEW_LINE>
int ret = 0 , probe_size , buf_offset = 0 ; <NEW_LINE>
TEMP_FAILURE_RETRY ( select ( sockfd [ 0 ] + 1 , & read_fds , NULL , NULL , & timeout ) ) ; <NEW_LINE>
#line 875 "ext / standard / var_unserializer . c" <NEW_LINE>
#endif <NEW_LINE>
int noffset = ( P [ i ] . name - datap ) ; <NEW_LINE>int voffset = ( P [ i ] . value - datap ) ; <NEW_LINE>if ( noffset < 0 || noffset > maxitems || voffset < 0 || voffset > maxitems ) <NEW_LINE>throw LIBRAW_EXCEPTION_IO_CORRUPT ; <NEW_LINE>int maxnsize = maxitems - ( P [ i ] . name - datap ) ; <NEW_LINE>int maxvsize = maxitems - ( P [ i ] . value - datap ) ; <NEW_LINE>utf2char ( P [ i ] . name , name , MIN ( maxnsize , sizeof ( name ) ) ) ; <NEW_LINE>utf2char ( P [ i ] . value , value , MIN ( maxvsize , sizeof ( value ) ) ) ; <NEW_LINE>
image -> rows = bitmap . bmHeight ; <NEW_LINE> } <NEW_LINE>status = SetImageExtent ( image , image -> columns , image -> rows ) ; <NEW_LINE>if ( status == MagickFalse ) <NEW_LINE> { <NEW_LINE>InheritException ( exception , & image -> exception ) ; <NEW_LINE>return ( DestroyImageList ( image ) ) ; <NEW_LINE>
pusher . Push ( cx ) ; <NEW_LINE>
<NEW_LINE>return parse_cosine_packet ( wth -> fh , & wth -> phdr , wth -> frame_buffer , <NEW_LINE>line , err , err_info ) ; <NEW_LINE>
TraceRecorder::emitNativeCall ( JSSpecializedNative * sn , uintN argc , LIns * args [ ] , bool rooted ) <NEW_LINE>
if ( terminate != 0 ) <NEW_LINE>
#include "platform / win / HWndDC . h" <NEW_LINE>#include "platform / win / SystemInfo . h" <NEW_LINE>
int npasses = set_write_interlace_handling ( pp , interlace_type ) ; <NEW_LINE>
nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>
( void ) CopyMagickMemory ( last_row , one_row , bytes_per_row ) ; <NEW_LINE>
ProxyArray array ; <NEW_LINE>array . AppendElement ( proxy -> asWeakPtr ( ) ) ; <NEW_LINE>
# define TOLOWER ( x ) ( ( ( x ) < 0 || ( x ) > 255 ) ? ( x ) :mspack_tolower_map [ ( x ) ] )
return RemapAllWrappersForObject ( cx , obj , obj ) ; <NEW_LINE>
memset ( frame_stats -> mb_stats , 0 , <NEW_LINE>cm -> mb_rows * cm -> mb_cols * sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ; <NEW_LINE>
if ( haveRead >= capacity ) { <NEW_LINE><NEW_LINE>if ( ! self -> mBuffer . SetCapacity ( haveRead + 1 , fallible_t ( ) ) ) { <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
#include "vpx / vpx_codec . h" <NEW_LINE>static const char * const cfg = " -- target = armv7 - android - gcc -- disable - runtime - cpu - detect -- sdk - path = / usr / local / google / home / vigneshv / Downloads / android - ndk - r10 -- disable - neon -- disable - neon - asm -- disable - examples -- disable - docs -- enable - realtime - only -- disable - webm - io" ; <NEW_LINE>
DoDeletingFrameSubtree ( aFrameManager , aDestroyQueue , <NEW_LINE>aRemovedFrame , childFrame ) ; <NEW_LINE>if ( childListName ) { <NEW_LINE>DoDeletingOverflowContainers ( aFrameManager , aDestroyQueue , <NEW_LINE>aRemovedFrame , childFrame ) ; <NEW_LINE> } <NEW_LINE>
void OnDidGetDefaultPageLayout ( const printing::PageSizeMargins & page_layout , <NEW_LINE>const gfx::Rect & printable_area , <NEW_LINE>bool has_custom_page_size_style ) ;
uint64_t size = strtoull ( param , & endptr , 0 ) ; <NEW_LINE>
bool csrf_found = false ; <NEW_LINE><NEW_LINE>
LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ; <NEW_LINE>l_row -- ; l_column -- ; <NEW_LINE>
MEDIA_EXPORT extern const char kEnableAudioMixer [ ] ; <NEW_LINE>
std::make_unique < CanonicalCookie > ( <NEW_LINE>
IDBObjectStore::ClearCloneReadInfo ( mCloneReadInfos [ index ] ) ; <NEW_LINE>
memcpy ( ( pbi -> mt_yabove_row [ mb_row + 1 ] + 32 + mb_col * 16 ) , ( xd -> dst . y_buffer + 15 * recon_y_stride ) , 16 ) ; <NEW_LINE>memcpy ( ( pbi -> mt_uabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . u_buffer + 7 * recon_uv_stride ) , 8 ) ; <NEW_LINE>memcpy ( ( pbi -> mt_vabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . v_buffer + 7 * recon_uv_stride ) , 8 ) ; <NEW_LINE>
if ( entry . oid_tag == oid_tag ) { <NEW_LINE>addToCertListIfTrusted ( certList , entry . cert ) ; <NEW_LINE> } <NEW_LINE>
if ( preferred == 0 ) <NEW_LINE>
jas_matrix_t * jas_seq2d_create ( jas_matind_t xstart , jas_matind_t ystart , <NEW_LINE>jas_matind_t xend , jas_matind_t yend ) <NEW_LINE>
#line 610 "ext / standard / var_unserializer . re" <NEW_LINE>
<NEW_LINE><NEW_LINE>
#include "nsTArray . h" <NEW_LINE>#include "nsIWeakReference . h" <NEW_LINE>#include "nsIWeakReferenceUtils . h" <NEW_LINE>
<NEW_LINE>tmp = range + 6 ; <NEW_LINE>num_ranges = 1 ; <NEW_LINE>while ( * ++ tmp ) <NEW_LINE>if ( * tmp == ' , ' ) <NEW_LINE>if ( ++ num_ranges > 10 ) <NEW_LINE>return 0 ; <NEW_LINE>
if ( png_colorspace_set_endpoints ( png_ptr , & info_ptr -> colorspace , <NEW_LINE> & XYZ , 2 ) != 0 ) <NEW_LINE>
RefPtr < DocumentFragment > fragment = createContextualFragment ( markup , toHTMLElement ( parent ) , AllowScriptingContent ) ; <NEW_LINE>
SetExnPrivate ( cx , exnObject , priv ) ; <NEW_LINE>
ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <NEW_LINE>
const char * filename , PRInt32 lineNo , PRBool returnString , <NEW_LINE>jsval * rval ) <NEW_LINE>
ccx -> SetDestroyJSContextInDestructor ( ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>result . mDataRect . IntersectRect ( result . mDataRect , <NEW_LINE>nsIntRect ( nsIntPoint ( ) , scaledSize ) ) ; <NEW_LINE><NEW_LINE>
<NEW_LINE>
if ( ! ND_TTEST2 ( * TPA ( ap ) , PROTO_LEN ( ap ) ) ) { <NEW_LINE>
#line 4152 "dcraw / dcraw . c" <NEW_LINE>
const std::string & name ( ) const { return name_ ; } <NEW_LINE><NEW_LINE>metrics::OmniboxEventProto_ProviderType AsOmniboxEventProviderType ( ) const ;
AutoPushJSContext cx ( scriptContext -> GetNativeContext ( ) ) ; <NEW_LINE>
alphablending_bak = im -> alphaBlendingFlag ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
#line 1162 "ext / standard / var_unserializer . c" <NEW_LINE>
( DOM_DEFAULT_SCRIPTABLE_FLAGS & <NEW_LINE> ~ nsIXPCScriptable::ALLOW_PROP_MODS_TO_PROTOTYPE ) ) <NEW_LINE>
default: { <NEW_LINE>TProtocolException::throwInvalidSkipType ( arg_type ) ; <NEW_LINE> } <NEW_LINE>
class BASE_API SharedMemory { <NEW_LINE>
ND_PRINT ( ( ndo , " % s" , tstr ) ) ; <NEW_LINE>
while ( ( ( NXT ( 0 ) != limit ) && <NEW_LINE> ( IS_CHAR ( c ) ) && ( c != ' < ' ) ) && <NEW_LINE> ( ctxt -> instate != XML_PARSER_EOF ) ) { <NEW_LINE>
if ( aPseudoFrames . mColGroup . mFrame ) { <NEW_LINE>rv = ProcessPseudoFrame ( aPresContext , aPseudoFrames . mColGroup , <NEW_LINE>aHighestFrame ) ; <NEW_LINE>if ( nsLayoutAtoms::tableColGroupFrame == aHighestType ) return rv ; <NEW_LINE>
Mutex mLock ; <NEW_LINE>
ovs_assert ( rule -> state != RULE_INSERTED ) ; <NEW_LINE>
payload_pos_ = writer_header_ -> Position ( ) ; <NEW_LINE>
#line 501 "ext / standard / var_unserializer . c" <NEW_LINE>
#endif <NEW_LINE>
char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; <NEW_LINE>if ( ! buf ) { <NEW_LINE>return - 1 ; <NEW_LINE> } <NEW_LINE>
memcpy ( dst_y , src_y , ystride * linestocopy ) ; <NEW_LINE>
r -> proto_num = HTTP_VERSION ( 1 , 0 ) ; <NEW_LINE>r -> protocol = apr_pstrdup ( r -> pool , "HTTP / 1 . 0" ) ; <NEW_LINE>
__perf_sw_event ( event_id , nr , regs , addr ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>PRUint32 itemSize = sizeof ( PRUint32 ) + mNKeys * sizeof ( TxObject * ) ; <NEW_LINE>if ( mNKeys > ( PR_UINT32_MAX - sizeof ( PRUint32 ) ) / sizeof ( TxObject * ) || <NEW_LINE>len >= PR_UINT32_MAX / itemSize ) { <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE><NEW_LINE>void * mem = PR_Malloc ( len * itemSize ) ; <NEW_LINE>
char * outname = create_output_name ( f [ i ] -> filename ) ; <NEW_LINE>
TWO_PASS * const twopass = & svc -> layer_context [ i ] . twopass ; <NEW_LINE>
if ( curr -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
memcpy ( & first_frame , this_frame , sizeof ( * this_frame ) ) ; <NEW_LINE>
if ( cpi -> temporal_layer_id >= 0 ) { <NEW_LINE>layer = cpi -> temporal_layer_id ; <NEW_LINE> } else { <NEW_LINE>layer = cpi -> oxcf . layer_id [ <NEW_LINE>cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ; <NEW_LINE> } <NEW_LINE>
kidReflowState . SetComputedHeight ( aReflowState . ComputedHeight ( ) ) ; <NEW_LINE>
probes::ExitScript ( cx , script , script -> function ( ) , REGS . fp ( ) -> hasPushedSPSFrame ( ) ) ; <NEW_LINE>
if ( numChannels < chansSpecified || numChannels < 1 || numChannels > 256 ) { <NEW_LINE>
GCInfoTable::Get ( ) <NEW_LINE> . GCInfoFromIndex ( header -> GcInfoIndex ( ) ) <NEW_LINE>
doRemoveChild ( true ) ; <NEW_LINE>
PHP_FUNCTION ( locale_get_display_language ) <NEW_LINE>
if ( ( png_ptr -> transformations & PNG_RGB_TO_GRAY ) != 0 ) <NEW_LINE>
static int isofs_read_inode ( struct inode * , int relocated ) ; <NEW_LINE>
if ( png_ptr -> idat_size == 0 ) <NEW_LINE> { <NEW_LINE>PNG_PUSH_SAVE_BUFFER_IF_LT ( 4 ) <NEW_LINE>
if ( ! renderer ( ) -> isOutOfFlowPositioned ( ) && renderer ( ) -> parent ( ) ) { <NEW_LINE>
ssplit ( key , " = " , & value ) ; <NEW_LINE>
if ( index >= MAX_SUPPORTED_TV_TIMING ) <NEW_LINE>
typedef signed char int8_t ; <NEW_LINE>
delete [ ] cue_entries_ ; <NEW_LINE>
if ( fragChildren . ref ( ) . ElementAt ( i ) -> GetParentNode ( ) ) { <NEW_LINE>
const long long id = ReadID ( m_pReader , idpos , len ) ; <NEW_LINE>if ( id < 0 ) <NEW_LINE>return NULL ; <NEW_LINE>
if ( RefPtr < DocumentFragment > fragment = createFragmentForInnerOuterHTML ( html , this , ec ) ) <NEW_LINE>
if ( pos > stop ) <NEW_LINE>return E_FILE_FORMAT_INVALID ; <NEW_LINE>
WebRequestProxyingURLLoaderFactory ( void * browser_context , <NEW_LINE>content::ResourceContext * resource_context , <NEW_LINE>InfoMap * info_map ) ; <NEW_LINE>
if ( ! GetCurrentEventContent ( ) || ! GetCurrentEventFrame ( ) || <NEW_LINE>
Total += vpx_mse16x16 ( src + j , source -> y_stride , <NEW_LINE>dst + j , dest -> y_stride , & sse ) ; <NEW_LINE>
<NEW_LINE>nsContentUtils::TriggerLink ( mContent , aPresContext , uri , <NEW_LINE>EmptyString ( ) , PR_TRUE , PR_TRUE ) ; <NEW_LINE>
if ( content && content -> OwnerDoc ( ) && content -> OwnerDoc ( ) -> GetWindow ( ) ) { <NEW_LINE>nsCOMPtr < EventTarget > windowRoot = content -> OwnerDoc ( ) -> GetWindow ( ) -> GetTopWindowRoot ( ) ; <NEW_LINE>
@stability Evolving <NEW_LINE>
if ( sec_attr == NULL || sec_attr_len ) { <NEW_LINE>
JS_CAST_NATIVE_TO ( its_get_customNative , JSPropertyOp ) , <NEW_LINE>JS_CAST_NATIVE_TO ( its_set_customNative , JSStrictPropertyOp ) , <NEW_LINE>
virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result , <NEW_LINE>nsIChannel ** channel ) ; <NEW_LINE>
mDecoder ( aDecoder ) , <NEW_LINE>
#include "platform / mediastream / MediaStreamSource . h" <NEW_LINE>
<NEW_LINE>
AutoPushJSContext cx ( GetJSContext ( ) ) ; <NEW_LINE>
struct hns_roce_ib_alloc_ucontext_resp resp = { } ; <NEW_LINE>
strncpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <NEW_LINE>strncpy ( ualg -> cru_driver_name , alg -> cra_driver_name , <NEW_LINE>sizeof ( ualg -> cru_driver_name ) ) ; <NEW_LINE>strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , <NEW_LINE>sizeof ( ualg -> cru_module_name ) ) ; <NEW_LINE><NEW_LINE>ualg -> cru_type = 0 ; <NEW_LINE>ualg -> cru_mask = 0 ; <NEW_LINE>
memset ( & bsi , 0 , sizeof ( bsi ) ) ; <NEW_LINE>
NS_IMPL_CYCLE_COLLECTION_4 ( TextTrackManager , mMediaElement , mTextTracks , <NEW_LINE>
msg -> msg_namelen = 0 ; <NEW_LINE><NEW_LINE>
if ( strlen ( location ) < 8 || ( strncasecmp ( location , "http: <NEW_LINE>strncasecmp ( location , "https: <NEW_LINE>strncasecmp ( location , "ftp: <NEW_LINE>strncasecmp ( location , "ftps: <NEW_LINE>
if ( XrayUtils::IsTransparent ( cx , wrapper , id ) ) { <NEW_LINE>
return 1 ; <NEW_LINE>
if ( safe_mount ( console -> name , path , "none" , MS_BIND , 0 , rootfs -> mount ) ) { <NEW_LINE>
{ <NEW_LINE>write_info = DestroyImageInfo ( write_info ) ; <NEW_LINE>ThrowWriterException ( CorruptImageError , "ImageTypeNotSupported" ) ; <NEW_LINE> } <NEW_LINE>
PRUint32 * aLineno , JSPrincipals * aPrincipals ) <NEW_LINE>
memcpy ( cpi -> active_map , map , rows * cols ) ; <NEW_LINE>
nsCOMPtr < nsIContent > activeContent ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>
jas_uchar magicbuf [ MIF_MAGICLEN ] ; <NEW_LINE>
<NEW_LINE><NEW_LINE>
REProgState * curState = NULL ; <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
jas_uchar * dataptr ; <NEW_LINE>
GtkWidget * owningWidget = GetMozContainerWidget ( ) ; <NEW_LINE>
filenameWasSaved = JS_FALSE ; <NEW_LINE>
NotifyRollupGeometryChange ( gRollupListener ) ; <NEW_LINE>
PLATFORM_EXPORT WindowsVersion windowsVersion ( int * major = 0 , int * minor = 0 ) ; <NEW_LINE>
for ( i = 0 ; i < 17 ; i ++ ) <NEW_LINE>s [ ( i + rows ) * pitch ] = s [ ( rows - 1 ) * pitch ] ; <NEW_LINE>
name = mprReadJson ( child , "name" ) ; <NEW_LINE>value = mprReadJson ( child , "value" ) ; <NEW_LINE>not = smatch ( mprReadJson ( child , "equals" ) , "true" ) ? 0 : HTTP_ROUTE_NOT ; <NEW_LINE>
if ( oldStyle && parent ( ) && diff . needsFullLayout ( ) && oldStyle -> position ( ) != newStyle . position ( ) <NEW_LINE>
int contextual_cards_version ) ; <NEW_LINE>
virtual void OnChannelConnected ( int32 peer_pid ) OVERRIDE ; <NEW_LINE>
nsresult rv = aImg -> DecodeSomeData ( chunkSize , aStrategy ) ; <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
rc = usb_submit_urb ( urb , GFP_ATOMIC ) ; <NEW_LINE>if ( rc < 0 ) { <NEW_LINE>kfree ( buf ) ; <NEW_LINE>usb_free_urb ( urb ) ; <NEW_LINE> } <NEW_LINE>
PRInt32 aType , bool aNoParentTraversal , <NEW_LINE>
void read_png ( FILE * fp , int sig_read ) <NEW_LINE>
memset ( above_ctx , partition_context_lookup [ subsize ] . above , bs ) ; <NEW_LINE>memset ( left_ctx , partition_context_lookup [ subsize ] . left , bs ) ; <NEW_LINE>
frame . pushSynced ( knownPushedType ( 0 ) ) ; <NEW_LINE>
unsigned debugOffset ( ) { return m_buffer . debugOffset ( ) ; } <NEW_LINE>
TypedArrayObjectStorage ( JSObject * obj ) : mObj ( obj ) <NEW_LINE>
fmt = ssplit ( token , ": \t\r\n" , & token ) ; <NEW_LINE>
AutoPushJSContext cx ( sc -> GetNativeContext ( ) ) ; <NEW_LINE>
uint8_t ip6r0_segleft ; <NEW_LINE>uint32_t ip6r0_reserved ; <NEW_LINE>
probes::ExitScript ( cx , script , script -> function ( ) , REGS . fp ( ) -> hasPushedSPSFrame ( ) ) ; <NEW_LINE>
j = ( x * szy + y * sz + z ) * size + b ; <NEW_LINE>if ( j >= 0 && j < elements * size ) { <NEW_LINE>
# ifdef PNG_READ_INTERLACING_SUPPORTED <NEW_LINE>int passes = png_set_interlace_handling ( png_ptr ) ; <NEW_LINE># else <NEW_LINE>int passes = png_get_interlace_type ( png_ptr , info_ptr ) == <NEW_LINE>PNG_INTERLACE_ADAM7 ? PNG_INTERLACE_ADAM7_PASSES : 1 ; <NEW_LINE># endif <NEW_LINE>
JSPROP_READONLY | JSPROP_PERMANENT | <NEW_LINE> ( mJSAttributes & JSPROP_ENUMERATE ) ; <NEW_LINE>
<NEW_LINE>
BUG_ON ( ret == - EEXIST || ret == - EOVERFLOW ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( ( GetStateBits ( ) & TEXT_IN_TEXTRUN_USER_DATA ) || <NEW_LINE> ! mPrevContinuation || <NEW_LINE>
PlatformSensorAmbientLightMac ( SensorReadingSharedBuffer * reading_buffer , <NEW_LINE>
value = flooru ( 65535 * pow ( value / 65535 . , conv ) + . 5 ) ; <NEW_LINE>
AutoInfallibleTArray < TemplateRule , 10 > mTemplateRules ; <NEW_LINE>
} \ <NEW_LINE>JS_FRIEND_API ( JSObject * ) js::Unwrap ## Name ## Array ( JSObject * obj ) \ <NEW_LINE> { \ <NEW_LINE>obj = CheckedUnwrap ( obj ) ; \ <NEW_LINE>if ( ! obj ) \ <NEW_LINE>return nullptr ; \ <NEW_LINE>const Class * clasp = obj -> getClass ( ) ; \ <NEW_LINE>if ( clasp == & TypedArrayObject::classes [ TypedArrayObjectTemplate < NativeType > ::ArrayTypeID ( ) ] ) \ <NEW_LINE>return obj ; \ <NEW_LINE>return nullptr ; \ <NEW_LINE> } \ <NEW_LINE>JS_FRIEND_DATA ( const js::Class * const ) js::detail::Name ## ArrayClassPtr = \ <NEW_LINE> & js::TypedArrayObject::classes [ TypedArrayObjectTemplate < NativeType > ::ArrayTypeID ( ) ] ; <NEW_LINE>
<NEW_LINE>
munmap ( m_pInput_pmem [ index ] . buffer , m_pInput_pmem [ index ] . size ) ; <NEW_LINE>m_pInput_pmem [ index ] . buffer = NULL ; <NEW_LINE>
<NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
static int isofs_read_inode ( struct inode * inode , int relocated ) <NEW_LINE>
<NEW_LINE>req . len = ast_str_strlen ( req . data ) ; <NEW_LINE>
if ( diff . needsFullLayout ( ) && s_canPropagateFloatIntoSibling && ! canPropagateFloatIntoSibling && hasOverhangingFloats ( ) ) { <NEW_LINE>
if ( IsFrameTreeTooDeep ( aReflowState , aMetrics , aStatus ) ) { <NEW_LINE>
if ( ( ! floatToRemove && child -> isFloatingOrOutOfFlowPositioned ( ) ) || ! child -> isRenderBlock ( ) ) <NEW_LINE>
cx = JSContextForPluginInstance ( reinterpret_cast < nsIPluginInstance * > ( mJavaClient ) ) ; <NEW_LINE>if ( ! cx ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>AutoPushJSContext autopush ( securitySupports , cx ) ; <NEW_LINE>if ( NS_FAILED ( autopush . ResultOfPush ( ) ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>
<NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_STRIP_16 ) != 0 ) <NEW_LINE>
if ( uint32_t ( offset ) > length ( tarray ) || len > length ( tarray ) - offset ) { <NEW_LINE>
public InfoBarView { <NEW_LINE>
if ( ( ret = insert_vm_struct ( mm , vma ) ) ) { <NEW_LINE>up_write ( & mm -> mmap_sem ) ; <NEW_LINE>kmem_cache_free ( vm_area_cachep , vma ) ; <NEW_LINE>return ret ; <NEW_LINE> } <NEW_LINE>
EbmlMasterElementSize ( kMkvSeekHead , total_entry_size ) + <NEW_LINE>total_entry_size ; <NEW_LINE>
xmlRelaxNGSetValidErrors ( ctxt , testErrorHandler , testErrorHandler , ctxt ) ; <NEW_LINE>
v [ i ] += v [ i - 1 ] ; <NEW_LINE>
unsigned long		tp_value [ 2 ] ; <NEW_LINE>
if ( ZEND_SIZE_T_INT_OVFL ( str_len ) ) { <NEW_LINE>
void SetInlineInstallWebstoreData ( const std::string & localized_user_count , <NEW_LINE>
<NEW_LINE>
ap_input_mode_t mode , apr_read_type_e block , <NEW_LINE>apr_off_t readbytes ) <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { <NEW_LINE>fprintf ( stderr , "Input url % s is too long , truncating to % d chars . \n" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; <NEW_LINE>strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; <NEW_LINE>the_url [ sizeof ( the_url ) - 1 ] = 0 ; <NEW_LINE> } <NEW_LINE>else { <NEW_LINE>strcpy ( the_url , url_arg ) ; <NEW_LINE> } <NEW_LINE>
return InternalLoad2 ( errorPageURI , nullptr , nullptr , mozilla::net::RP_Default , <NEW_LINE>nullptr , INTERNAL_LOAD_FLAGS_INHERIT_OWNER , nullptr , <NEW_LINE>nullptr , NullString ( ) , nullptr , nullptr , LOAD_ERROR_PAGE , <NEW_LINE>nullptr , true , NullString ( ) , this , nullptr , nullptr , <NEW_LINE>nullptr ) ; <NEW_LINE>
if ( isdigit ( ( unsigned char ) string [ 0 ] ) || string [ 0 ] == ' - ' || string [ 0 ] == ' + ' ) { <NEW_LINE>while ( * ++ string && isdigit ( ( unsigned char ) * string ) ) <NEW_LINE>
rv = WriteToDecoder ( aBuffer , aCount , DECODE_SYNC ) ; <NEW_LINE>
if ( _scale == INT32_MIN ) { <NEW_LINE>result . append ( { u" - 2147483648" , - 1 } ) ; <NEW_LINE>return result ; <NEW_LINE> } else if ( _scale < 0 ) { <NEW_LINE>
<NEW_LINE>int res , i , indexes , index_bytes ; <NEW_LINE>unsigned int ids ; <NEW_LINE>long long bytes ; <NEW_LINE>
insertText ( document , text , frame -> selection ( ) . selectionInDOMTree ( ) , options , <NEW_LINE>composition , isIncrementalInsertion ) ; <NEW_LINE>
<NEW_LINE>
void neuter ( ObjectElements * newHeader , JSContext * cx ) ;
vpx_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; <NEW_LINE>vpx_write ( w , pred_flag , pred_prob ) ; <NEW_LINE>
if ( id == GetRTStringByIndex ( cx , XPCJSRuntime::IDX_WRAPPED_JSOBJECT ) ) { <NEW_LINE>return JS_TRUE ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( id == GetRTStringByIndex ( cx , XPCJSRuntime::IDX_TO_STRING ) ) { <NEW_LINE> * objp = obj ; <NEW_LINE>return JS_DefineFunction ( cx , obj , "toString" , <NEW_LINE>XPC_NW_toString , 0 , 0 ) != nsnull ; <NEW_LINE>
const int maxsamples = ARRAY_LEN ( buf ) - ( AST_FRIENDLY_OFFSET / sizeof ( buf [ 0 ] ) ) ; <NEW_LINE>
PassRefPtr < DocumentFragment > createFragmentForInnerOuterHTML ( const String & markup , Element * contextElement , ExceptionCode & ec ) <NEW_LINE>
if ( ! newChild -> isInline ( ) && ! newChild -> isFloatingOrOutOfFlowPositioned ( ) ) {
args -> m_cx = GetScriptContextFromJSContext ( cx ) ; <NEW_LINE>
int exp_b10 ; <NEW_LINE>
void * dst = storage ( ) ; <NEW_LINE>if ( ! dst ) { <NEW_LINE>ALOGE ( "Couldn't allocate % zu bytes for item" , size ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>memcpy ( dst , data , size ) ; <NEW_LINE>
int projected_buffer_level ; <NEW_LINE>
if ( layout_type >= LAYOUT_TYPE_MAX || <NEW_LINE> ! ( exp -> ex_layout_types & ( 1 << layout_type ) ) ) { <NEW_LINE>
#pragma warning ( disable : 4996 ) <NEW_LINE>
AutoPushJSContext cx ( GetJSContext ( ) ) ; <NEW_LINE>
nsIListBoxObject * listBoxBody = nsnull ; <NEW_LINE>CallQueryInterface ( yeahBaby , & listBoxBody ) ; <NEW_LINE>NS_ENSURE_TRUE ( listBoxBody && <NEW_LINE>static_cast < nsListBoxBodyFrame * > ( listBoxBody ) -> SetBoxObject ( this ) , <NEW_LINE>nsnull ) ; <NEW_LINE>mListBoxBody = listBoxBody ; <NEW_LINE>
if ( is_ICC_signature ( value ) != 0 ) <NEW_LINE>
conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE>
SetQuotes ( PR_FALSE ) ; <NEW_LINE>
dxtrace ( printk ( KERN_DEBUG "Creating index: inode % lu\n" , dir -> i_ino ) ) ; <NEW_LINE>
const PRInt32 kMaxDropDownRows = 20 ; <NEW_LINE>
memcpy ( output , input , sizeof ( output [ 0 ] ) * length ) ; <NEW_LINE>
int num , size_t size , off_t fsize , int sh_num , int * flags , <NEW_LINE>uint16_t * notecount ) <NEW_LINE>
rv = aState . pushPtr ( checkParam , aState . eCheckParam ) ; <NEW_LINE>
virtual ~ OfflineLoadPage ( ) ; <NEW_LINE>
write_webm_file_footer ( & stream -> ebml ) ; <NEW_LINE>
FireImageDOMEvent ( nsIContent * aContent , PRUint32 aMessage ) <NEW_LINE>
return GraphicsJNI::createBitmap ( env , bitmap . detach ( ) , buffer , <NEW_LINE>getPremulBitmapCreateFlags ( isMutable ) , NULL , NULL , density ) ; <NEW_LINE>
SECOidTag hashid ; <NEW_LINE>
AutoPushJSContext cx ( aScriptContext -> GetNativeContext ( ) ) ; <NEW_LINE>
doc = node -> OwnerDoc ( ) ; <NEW_LINE>global = doc -> GetScriptGlobalObject ( ) ; <NEW_LINE>
if ( half_vert && y + half_vert < s -> avctx -> height ) <NEW_LINE>
if ( png_muldiv ( & result , a , times , divisor ) != 0 ) <NEW_LINE>
<NEW_LINE>bool is_cors_cross_origin ( ) const { return is_cors_cross_origin_ ; }
MakeContinuationsNonFluidUpParentChain ( frame , next ) ; <NEW_LINE>
if ( at_start != 0 ) <NEW_LINE>
Eina_Bool ewk_view_scale_set ( Evas_Object * ewkView , float scaleFactor , Evas_Coord scrollX , Evas_Coord scrollY ) <NEW_LINE>
( png_ptr -> num_palette != 0 || <NEW_LINE> ( png_ptr -> mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE ) == 0 ) && <NEW_LINE>
if ( len > 0 ) { <NEW_LINE><NEW_LINE>ptr = realloc ( priv -> EF_C_DevAut , len ) ; <NEW_LINE>if ( ptr ) { <NEW_LINE>memcpy ( ptr , efbin , len ) ; <NEW_LINE>priv -> EF_C_DevAut = ptr ; <NEW_LINE>priv -> EF_C_DevAut_len = len ; <NEW_LINE> } <NEW_LINE>
static int64_t ivf_header_pos = 0 ; <NEW_LINE>
if ( set_location ( png_ptr , my_user_chunk_data , have_vpAg ) == 0 ) <NEW_LINE>
u_char showspi , showsomedata ; <NEW_LINE>
nsInputStreamChannel::OpenContentStream ( PRBool async , nsIInputStream ** result , <NEW_LINE>nsIChannel ** channel ) <NEW_LINE>
{ <NEW_LINE>DestroyJNG ( chunk , & color_image , & color_image_info , <NEW_LINE> & alpha_image , & alpha_image_info ) ; <NEW_LINE>ThrowReaderException ( CorruptImageError , <NEW_LINE>"NegativeOrZeroImageSize" ) ; <NEW_LINE> } <NEW_LINE>
# else <NEW_LINE>
bool RemoveMessageAndDispatchPluginEvent ( UINT aFirstMsg , UINT aLastMsg ) const ; <NEW_LINE>
if ( len < 0 || len > MAX_RDS_RADIO_TEXT ) { <NEW_LINE>
double in = 0 . 0 , out = 0 . 0 ; <NEW_LINE>
<NEW_LINE>InterpState * state = tracecx -> interpState ; <NEW_LINE>state -> builtinStatus |= JSBUILTIN_BAILED ; <NEW_LINE>state -> deepBailSp = state -> sp ; <NEW_LINE>
static const float FLOOR1_fromdB_INV_LOOKUP [ 256 ] = { <NEW_LINE>
if ( ( offset < 0 ) || <NEW_LINE> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( JS_IsExceptionPending ( cx ) ) <NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
if ( safe_mount ( dirname , cgpath , "none" , MS_BIND , 0 , root ) ) { <NEW_LINE>
std::unique_ptr < WebRunnerContentBrowserClient > browser_client_ ; <NEW_LINE>
nsCOMPtr < nsIContent > content = do_QueryReferent ( mContent ) ; <NEW_LINE>nsIAtom * atom = content -> Tag ( ) ; <NEW_LINE>
if ( elements != emptyObjectElements ) <NEW_LINE>cx -> free_ ( getElementsHeader ( ) ) ; <NEW_LINE>
<NEW_LINE>void Reset ( ) ; <NEW_LINE>
ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01591 ) <NEW_LINE>"Read content - length of % " APR_OFF_T_FMT <NEW_LINE>" is larger than the configured limit" <NEW_LINE>" of % " APR_OFF_T_FMT , ctx -> limit_used , ctx -> limit ) ; <NEW_LINE>
res = HSM_COM_CONX_ERR ; goto cleanup ;
#include "mozilla / dom / BindingUtils . h" <NEW_LINE>
const long long id = ReadID ( m_pReader , pos , len ) ; <NEW_LINE>if ( id != 0x0F43B675 ) <NEW_LINE>
XML_Bool haveMore , XML_Bool allowClosingDoctype ) ; <NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
#ifndef CHROME_BROWSER_CHROMEOS_POWER_BRIGHTNESS_OBSERVER_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_POWER_BRIGHTNESS_OBSERVER_H_ <NEW_LINE>
int32 preview_ui_id ; <NEW_LINE>
<NEW_LINE>
<NEW_LINE>mp4 -> filepos += len ; <NEW_LINE>LongSeek ( mp4 , qtsize - 8 - len ) ; <NEW_LINE>
ChildIterator iter , last ; <NEW_LINE>ChildIterator::Init ( mContent , & iter , & last ) ; <NEW_LINE>if ( last . position ( ) > 0 ) { <NEW_LINE>iter . seek ( last . position ( ) - 1 ) ; <NEW_LINE>nsIContent * lastChild = * iter ; <NEW_LINE>
NS_ENSURE_NATIVE_COLUMN ( aCol ) ; <NEW_LINE>
cert = SECU_FindCertByNicknameOrFilename ( handle , name , ascii , <NEW_LINE>NULL ) ; <NEW_LINE>
if ( cpi -> sf . mv . auto_mv_step_size ) { <NEW_LINE>
<NEW_LINE>void RegisterForDevicePolicy ( const std::string & owner_email , <NEW_LINE>const std::string & token , <NEW_LINE>TokenType token_type ) ;
return narrowPrecisionToFloat ( sqrt ( ( ctm . xScaleSquared ( ) + ctm . yScaleSquared ( ) ) / 2 ) ) ; <NEW_LINE>
tmp_rd = rd_pick_best_sub8x8_mode ( cpi , x , <NEW_LINE> & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] , <NEW_LINE>second_ref , best_yrd , & rate , & rate_y , <NEW_LINE> & distortion , & skippable , & total_sse , <NEW_LINE> ( int ) this_rd_thresh , seg_mvs , bsi , 0 , <NEW_LINE>mi_row , mi_col ) ; <NEW_LINE>
<NEW_LINE>bool needs_scroll_styles_ ; <NEW_LINE><NEW_LINE><NEW_LINE>bool in_size_move_loop_ ; <NEW_LINE>
return ( size_t ) ( ( double ) php_ifd_get32s ( value , motorola_intel ) / s_den ) ; <NEW_LINE>
#include "platform / mediastream / MediaStreamSource . h" <NEW_LINE>
MarkLineDirty ( prevSibLine , lineList ) ; <NEW_LINE>
ChildIterator iter , last ; <NEW_LINE>PRUint32 i = 0 ; <NEW_LINE>for ( ChildIterator::Init ( mContent , & iter , & last ) ; <NEW_LINE>iter != last && i < 100 ; <NEW_LINE> ++ iter , ++ i ) { <NEW_LINE>nsIContent * child = ( * iter ) ; <NEW_LINE>
aBuilder -> MarkAsBroken ( NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE>
static const l_int32 L_BUFSIZE = 512 ; <NEW_LINE>
strncpy ( rblkcipher . type , "ablkcipher" , sizeof ( rblkcipher . type ) ) ; <NEW_LINE>strncpy ( rblkcipher . geniv , alg -> cra_ablkcipher . geniv ? : " < default > " , <NEW_LINE>sizeof ( rblkcipher . geniv ) ) ; <NEW_LINE>
if ( ( dp = mprReadJsonObj ( dest , trimmedName ) ) == 0 ) { <NEW_LINE>
if ( OBJ_IS_NATIVE ( obj2 ) ) <NEW_LINE>JS_UNLOCK_OBJ ( cx , obj2 ) ; <NEW_LINE>
if ( ( ulen > SIZE_T_MAX / 4 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <NEW_LINE>
ReportBadReturn ( JSContext * cx , JSTreeContext * tc , JSParseNode * pn , uintN flags , uintN errnum , <NEW_LINE>
memcpy ( & last_frame , this_frame , sizeof ( * this_frame ) ) ; <NEW_LINE>
memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE>
nsTreeColumns::InvalidateColumns ( ) ; <NEW_LINE>
if ( text_len != 0 ) <NEW_LINE>
bool Equals ( const FormatType & other ) const ; <NEW_LINE><NEW_LINE>
int shift = VP8_BD_VALUE_SIZE - CHAR_BIT - ( count + CHAR_BIT ) ; <NEW_LINE>
#include "base / callback_old . h" <NEW_LINE>
{ <NEW_LINE>colormap_index = ( ssize_t * ) RelinquishMagickMemory ( colormap_index ) ; <NEW_LINE>ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , <NEW_LINE>image -> filename ) ; <NEW_LINE> } <NEW_LINE>
OriginClearCompleted ( const nsACString & aPattern ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( ! ( interval . high ( ) < node -> data ( ) . low ( ) ) ) { <NEW_LINE>
#include "compiler / compilerdebug . h" <NEW_LINE>
file_fmttime ( p -> l + m -> num_mask , 0 , tbuf ) ) == - 1 ) <NEW_LINE>
* dp = ( png_byte ) ( 255 - * ( sp ++ ) ) ; <NEW_LINE>
buf = ctx -> iface -> enc . get_glob_hdrs ( get_alg_priv ( ctx ) ) ; <NEW_LINE>
ND_PRINT ( ( ndo , " % s" , rpl_tstr ) ) ; <NEW_LINE>
* rowp ++ = * -- stackp & mColorMask ; <NEW_LINE>
NEED_OP ( t , 0 ) ; <NEW_LINE>
if ( m_scrollableArea ) <NEW_LINE>m_scrollableArea -> scrollToOffsetWithoutAnimation ( m_orientation , newPosition ) ; <NEW_LINE>
if ( arr1 . get ( ) == arr2 . get ( ) ) { <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( check && ! seen . insert ( ( void * ) arr1 . get ( ) ) . second ) { <NEW_LINE>raise_warning ( "array_replace_recursive ( ) : recursion detected" ) ; <NEW_LINE>return ; <NEW_LINE>
if ( currentNode -> renderStyle ( ) -> visualInvalidationDiff ( * startingStyle , context ) . hasNoChange ( ) && ! context ) <NEW_LINE>
TLSMessage msg { } ;
ND_TCHECK_32BITS ( p + 2 ) ; <NEW_LINE>
void OpenURL ( SiteInstance * site_instance , <NEW_LINE>
QueueCheckPluginStopEvent ( ) ; <NEW_LINE>
DCHECK ( ! GCInfoTable::Get ( ) <NEW_LINE> . GCInfoFromIndex ( previous_header -> GcInfoIndex ( ) ) <NEW_LINE> -> HasFinalizer ( ) ) ; <NEW_LINE>
u32 count , now ; <NEW_LINE>
fd = open ( authfile , O_RDONLY | O_CLOEXEC | O_NOCTTY ) ; <NEW_LINE>
const GCInfo * info = <NEW_LINE>GCInfoTable::Get ( ) . GCInfoFromIndex ( header -> GcInfoIndex ( ) ) ; <NEW_LINE>
stripsperplane = TIFFhowmany_32_maxuint_compat ( td -> td_imagelength , rowsperstrip ) ; <NEW_LINE>
ND_PRINT ( ( ndo , " [ | esis ] " ) ) ; <NEW_LINE>
if ( ! PS ( use_only_cookies ) && ! PS ( id ) && <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
bool ShouldReuseDefaultView ( const KURL & , const ContentSecurityPolicy * ) const ; <NEW_LINE>
size_t count = GLES2Util::CalcClearBufferuivDataCount ( buffer ) ; <NEW_LINE>DCHECK_LE ( count , 4u ) ; <NEW_LINE>if ( count == 0 ) { <NEW_LINE>SetGLErrorInvalidEnum ( "glClearBufferuiv" , buffer , "buffer" ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
if ( profile == NULL ) <NEW_LINE> { <NEW_LINE>ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA ; <NEW_LINE>goto exit ; <NEW_LINE> } <NEW_LINE><NEW_LINE>
PNG_PUSH_SAVE_BUFFER_IF_FULL <NEW_LINE>
class FloatInfo { <NEW_LINE>public: <NEW_LINE>FloatInfo ( const nsIFrame * aFrame , nscoord aWidth ) <NEW_LINE>: mFrame ( aFrame ) , mWidth ( aWidth ) <NEW_LINE> { } <NEW_LINE>const nsIFrame * Frame ( ) const { return mFrame ; } <NEW_LINE>nscoord Width ( ) const { return mWidth ; } <NEW_LINE><NEW_LINE>private: <NEW_LINE>const nsIFrame * mFrame ; <NEW_LINE>nscoord mWidth ; <NEW_LINE> } ; <NEW_LINE><NEW_LINE>nsTArray < FloatInfo > floats ; <NEW_LINE>
SetUTCTime ( cx , obj , UTC ( local ) ) ; <NEW_LINE>
#ifndef BASE_PROCESS_PROCESS_H_ <NEW_LINE>#define BASE_PROCESS_PROCESS_H_ <NEW_LINE>
#endif <NEW_LINE>
memset ( accumulator , 0 , 384 * sizeof ( unsigned int ) ) ; <NEW_LINE>memset ( count , 0 , 384 * sizeof ( unsigned short ) ) ; <NEW_LINE>
#ifdef PNG_MNG_FEATURES_SUPPORTED
case 0x6c696e6b:
Microtask::performCheckpoint ( m_workerThread -> isolate ( ) ) ; <NEW_LINE>
dom::Uint8ClampedArray * aArray , <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>return xpc::WrapperFactory::WaiveXrayAndWrap ( cx , args . mutableThisv ( ) . address ( ) ) && <NEW_LINE>JS::CallNonGenericMethod < ValueHasISupportsPrivate , FieldSetterImpl > <NEW_LINE>
delete [ ] encryption -> key_id ; <NEW_LINE>
nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
& x -> mbmi_ext -> ref_mvs [ second_ref_frame ] [ 0 ] : NULL ; <NEW_LINE>
bool permissive ; <NEW_LINE>
const PRUint8 nsSMILTimedElement::sMaxUpdateIntervalRecursionDepth = 20 ; <NEW_LINE>
if ( nPortIndex < drv_ctx . op_buf . actualcount && <NEW_LINE>BITMASK_PRESENT ( & m_out_bm_count , nPortIndex ) ) { <NEW_LINE>
if ( bufp == buf ) <NEW_LINE>
const int * src [ FLACParser::kMaxChannels ] , <NEW_LINE>
if ( whitespaceCount ) { <NEW_LINE>offset += whitespaceCount ; <NEW_LINE>length - = whitespaceCount ; <NEW_LINE><NEW_LINE>if ( NS_UNLIKELY ( offset > GetContentEnd ( ) ) ) { <NEW_LINE>SetLength ( offset - GetContentOffset ( ) , & aLineLayout , <NEW_LINE>ALLOW_FRAME_CREATION_AND_DESTRUCTION ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
for ( size_t i = 0 , i_end = array -> Count ( ) ; i < i_end ; ++ i ) { <NEW_LINE>
<NEW_LINE><NEW_LINE>
if ( HasFontSizeInflation ( ) ) { <NEW_LINE>ClearTextRun ( nsnull , nsTextFrame::eNotInflated ) ; <NEW_LINE> } <NEW_LINE>
CERTCertificate * the_cert = <NEW_LINE>SECU_FindCertByNicknameOrFilename ( handle , name , ascii , NULL ) ; <NEW_LINE>if ( ! the_cert ) { <NEW_LINE>SECU_PrintError ( progName , "Could not find cert: % s\n" , name ) ; <NEW_LINE>return SECFailure ; <NEW_LINE> } <NEW_LINE>
&& ! renderer ( ) -> isOutOfFlowPositioned ( ) <NEW_LINE>
char buf [ L_BUFSIZE ] ; <NEW_LINE>
delete [ ] cluster_list_ ; <NEW_LINE>
JS_ASSERT ( inliningDepth_ > 0 ) ; <NEW_LINE>
if ( ! mGlyphs . SetLength ( mMaxGlyphs ) || <NEW_LINE> ! mAttr . SetLength ( mMaxGlyphs ) ) { <NEW_LINE>return E_OUTOFMEMORY ; <NEW_LINE> } <NEW_LINE>
* ( -- dp ) = hi_filler ; <NEW_LINE>
ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>void dispatchEventAndLoadEnd ( const AtomicString & ) ; <NEW_LINE><NEW_LINE>void handleDidFailGeneric ( ) ; <NEW_LINE><NEW_LINE>void handleNetworkError ( ) ; <NEW_LINE><NEW_LINE>void handleDidCancel ( ) ; <NEW_LINE><NEW_LINE>void handleDidTimeout ( ) ; <NEW_LINE>
DeleteRefToAnonymousNode ( mPositioningShadow , bodyContent , ps ) ; <NEW_LINE>
u32 supp [ 3 ] ; <NEW_LINE><NEW_LINE>memcpy ( supp , nfsd_suppattrs [ minorversion ] , sizeof ( supp ) ) ; <NEW_LINE>supp [ 0 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD0 ; <NEW_LINE>supp [ 1 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD1 ; <NEW_LINE>supp [ 2 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD2 ; <NEW_LINE><NEW_LINE>status = nfsd4_encode_bitmap ( xdr , supp [ 0 ] , supp [ 1 ] , supp [ 2 ] ) ; <NEW_LINE>
hstartrow = ( numrows + 1 - parity ) >> 1 ; <NEW_LINE><NEW_LINE>m = numrows - hstartrow ; <NEW_LINE>
if ( child -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
mPort ( 0 ) , <NEW_LINE>mIsCertIssuerBlacklisted ( PR_FALSE ) <NEW_LINE>
@stability Evolving <NEW_LINE>
0 , <NEW_LINE>NULL , <NEW_LINE>NULL , <NEW_LINE>NULL , <NEW_LINE>NULL , <NEW_LINE>NULL , <NEW_LINE>NULL , <NEW_LINE>NULL <NEW_LINE>
r = vt_verify_kbmode ( fd ) ; <NEW_LINE>
nsComboboxControlFrame * nsComboboxControlFrame::sFocused = nsnull ; <NEW_LINE>
} else if ( cmd ) { <NEW_LINE><NEW_LINE>
if ( read != entry . uncompressed_filesize || read <= 8 ) { <NEW_LINE>
<NEW_LINE>count = NS_MIN ( NS_MIN ( count , aCount ) , PR_UINT32_MAX - 1 ) ; <NEW_LINE>
SetUTCTime ( cx , obj , UTC ( local ) ) ; <NEW_LINE>
bool waiveXrays = wantXrays && ! securityWrapper && waiveXrayFlag ; <NEW_LINE>
const GURL & url , <NEW_LINE>const char * method , <NEW_LINE>const char * buf , <NEW_LINE>int len , <NEW_LINE>const char * range_info , <NEW_LINE>
uint32_t data_siz ; <NEW_LINE>
extern void show_object_with_name ( FILE * , struct object * , const char * ) ; <NEW_LINE>
static const char * const cfg = " -- target = mips32 - linux - gcc -- enable - dspr2 -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect -- disable - install - docs -- size - limit = 4096x3072" ; <NEW_LINE>
option = ssplit ( option , " = \t , " , & ovalue ) ; <NEW_LINE>
if ( curr -> renderer ( ) -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
BLOCK_SIZE comp_inter_joint_search_thresh ;
location = mprReadJson ( prop , "location" ) ; <NEW_LINE>level = ( int ) stoi ( mprReadJson ( prop , "level" ) ) ; <NEW_LINE>backup = ( int ) stoi ( mprReadJson ( prop , "backup" ) ) ; <NEW_LINE>anew = smatch ( mprReadJson ( prop , "anew" ) , "true" ) ; <NEW_LINE>size = ( ssize ) httpGetNumber ( mprReadJson ( prop , "size" ) ) ; <NEW_LINE>timestamp = httpGetNumber ( mprReadJson ( prop , "timestamp" ) ) ; <NEW_LINE>
JSContext * cx ; <NEW_LINE>if ( ( cx = nsContentUtils::GetCurrentJSContext ( ) ) ) { <NEW_LINE>nsIScriptSecurityManager * ssm = nsContentUtils::GetSecurityManager ( ) ; <NEW_LINE>NS_ENSURE_STATE ( ssm ) ; <NEW_LINE><NEW_LINE>nsresult rv = ssm -> CheckLoadURIFromScript ( cx , aURI ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> } <NEW_LINE>
#define PACKAGE_STRING "fontconfig 2 . 12 . 6" <NEW_LINE>
if ( size < 0 ) return ( NULL ) ; <NEW_LINE>
ScriptValue constraints , <NEW_LINE>
if ( ! ArrayBufferObject::neuterViews ( cx , buffer , newHeader -> elements ( ) ) ) { <NEW_LINE>
void SetRenderer ( int process_host_id , <NEW_LINE>
* temp = * ( temp - r -> bpp ) ; <NEW_LINE>temp += 1 ; <NEW_LINE>count - = 1 ; <NEW_LINE>
group = ssplit ( tok , ":" , & perms ) ; <NEW_LINE>
if ( png_ptr != NULL ) <NEW_LINE>
# if PNG_LIBPNG_VER >= 10700 && \ <NEW_LINE> ! defined ( PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED ) <NEW_LINE>if ( option < PNG_HANDLE_CHUNK_IF_SAFE ) <NEW_LINE># endif <NEW_LINE>png_set_keep_unknown_chunks ( d -> png_ptr , option , NULL , - 1 ) ; <NEW_LINE><NEW_LINE>
size_t fname_len ; <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
if ( ( png_ptr -> transformations & ( PNG_COMPOSE | PNG_RGB_TO_GRAY ) ) != 0 ) <NEW_LINE>
AutoPushJSContext cx ( sc -> GetNativeContext ( ) ) ; <NEW_LINE>
if ( ! ok ) <NEW_LINE>RETURN_ERROR_A ( "obj -> lookupProperty failed in JSOP_IN" ) ; <NEW_LINE><NEW_LINE>
for ( j = 0 ; j < cfg -> searches_per_step ; j += 4 ) { <NEW_LINE>
#define XMLPUBVAR extern <NEW_LINE>
<NEW_LINE>
return start ( ) . deprecatedNode ( ) && ! start ( ) . deprecatedNode ( ) -> isShadowRoot ( ) ? start ( ) . deprecatedNode ( ) -> nonBoundaryShadowTreeRootNode ( ) : 0 ; <NEW_LINE>
ResourceRequestBlockedReason , <NEW_LINE>Resource::Type ) const = 0 ; <NEW_LINE>
CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ; <NEW_LINE>
ASSERT ( ! child || ! child -> isRubyText ( ) || ! child -> isFloatingOrOutOfFlowPositioned ( ) ) ; <NEW_LINE>
res = entry -> fn ( ( vpx_codec_alg_priv_t * ) ctx -> priv , ap ) ; <NEW_LINE>
void SendJavaScriptStream ( const GURL & url , <NEW_LINE>const std::string & result , <NEW_LINE>bool success , <NEW_LINE>int notify_id ) ; <NEW_LINE>
if ( atBeforeSideOfBlock && oldTop == result && ! isOutOfFlowPositioned ( ) && ! isTableCell ( ) ) {
@stability Evolving <NEW_LINE>
if ( ! IsSystemXHR ( ) && <NEW_LINE>
nsRefPtr < QuotaObject > result ; <NEW_LINE>
const char * response = "401 Unauthorized" ; <NEW_LINE>const char * reqheader = "Authorization" ; <NEW_LINE>const char * respheader = "WWW - Authenticate" ; <NEW_LINE>
char client_key_text [ 41 ] ; <NEW_LINE>
#include "base / callback_old . h" <NEW_LINE>
static const float vwin256 [ 128 ] = { <NEW_LINE>
status = SetImageExtent ( image , image -> columns , image -> rows ) ; <NEW_LINE>if ( status == MagickFalse ) <NEW_LINE> { <NEW_LINE>InheritException ( exception , & image -> exception ) ; <NEW_LINE>return ( DestroyImageList ( image ) ) ; <NEW_LINE> } <NEW_LINE>
if ( unlikely ( get_dumpable ( current -> mm ) != SUID_DUMP_USER ) ) { 	\
&& mHasTimeToSample ; <NEW_LINE>
<NEW_LINE>virtual void StopCasting ( ) = 0 ; <NEW_LINE>
if ( inet_opt ) <NEW_LINE>inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . optlen ;
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
std::make_unique < CanonicalCookie > ( <NEW_LINE>
"xmlMallocAtomicLoc : Unsigned overflow\n" ) ; <NEW_LINE>
#line 7532 "dcraw / dcraw . c"
nsContentUtils::AddScriptRunner ( <NEW_LINE>new FocusBlurEvent ( aTarget , aType , aPresShell -> GetPresContext ( ) , <NEW_LINE>aWindowRaised ) ) ; <NEW_LINE>
MOZ_ASSERT ( ! IsWrapper ( obj ) || <NEW_LINE>GetProxyHandler ( obj ) == & XrayWaiver || <NEW_LINE>js::GetObjectClass ( obj ) -> ext . innerObject , <NEW_LINE>"wrapped object passed to rewrap" ) ; <NEW_LINE>MOZ_ASSERT ( JS_GetClass ( obj ) != & XrayUtils::HolderClass , "trying to wrap a holder" ) ; <NEW_LINE>
nsCOMPtr < nsIDOMDocument > domDoc = win -> GetExtantDocument ( ) ; <NEW_LINE>
#ifndef CHROME_BROWSER_CHROMEOS_AUDIO_AUDIO_MIXER_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_AUDIO_AUDIO_MIXER_H_ <NEW_LINE>
BlobRegistry::registerBlobURL ( scriptExecutionContext -> securityOrigin ( ) , m_urlForReading , blob -> url ( ) ) ; <NEW_LINE>
#include " . / vpx_encoder . h"
snprintf ( psz_remote , sizeof ( psz_remote ) , "\\\\ % s\\ % s" , psz_server , psz_share ) ; <NEW_LINE>
size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) ; <NEW_LINE>
@stability Evolving <NEW_LINE>
<NEW_LINE>
&& objlen > 1 && obj [ 0 ] == 0x00 ) { <NEW_LINE>
int16_t vp9_dc_quant ( int qindex , int delta , vpx_bit_depth_t bit_depth ) ; <NEW_LINE>int16_t vp9_ac_quant ( int qindex , int delta , vpx_bit_depth_t bit_depth ) ; <NEW_LINE>
if ( ! EnsureStringLength ( aDest , Distance ( aSrcStart , aSrcEnd ) ) ) { <NEW_LINE>aDest . Truncate ( ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>
int32 , <NEW_LINE>
return ClassicScript::Create ( <NEW_LINE>source_code , base_url , options_ , <NEW_LINE>resource -> CalculateAccessControlStatus ( <NEW_LINE>GetElement ( ) -> GetDocument ( ) . GetSecurityOrigin ( ) ) ) ; <NEW_LINE>
page -> GetChromeClient ( ) . Focus ( & active_frame ) ; <NEW_LINE>
goto softfail ; <NEW_LINE>
newlen = x -> area_size * 6 / 5 ; <NEW_LINE>if ( newlen == x -> area_size ) <NEW_LINE>
if ( recip != 0 ) d = 1 / d ; <NEW_LINE>
if ( bin -> methods [ i ] . class_id > bin -> header . types_size ) { <NEW_LINE>
if ( png_rtran_ok ( png_ptr , 0 ) == 0 ) <NEW_LINE>
if ( ! EnsureStringLength ( mBuf , len + aCount ) ) <NEW_LINE>
return voice_interaction_enabled_ && voice_interaction_context_enabled_ && <NEW_LINE>assistant_allowed_state_ == mojom::AssistantAllowedState::ALLOWED ; <NEW_LINE>
if ( worker -> IsChromeWorker ( ) ) { <NEW_LINE>if ( ! chromeworker::InitClass ( aCx , global , workerProto , false ) || <NEW_LINE> ! DefineChromeWorkerFunctions ( aCx , global ) || <NEW_LINE> ! DefineOSFileConstants ( aCx , global ) ) { <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE>
BASE_API WindowsArchitecture GetWindowsArchitecture ( ) ; <NEW_LINE>
nsCOMPtr < nsINode > parent = node -> GetParentNode ( ) ; <NEW_LINE>
inliningDepth_ ) ) ; <NEW_LINE>
SecurityClient security ; <NEW_LINE>
"noscript" , 	"script" , NULL , <NEW_LINE>
Result AskUserForSettings ( gfx::NativeView parent_view , int max_pages , <NEW_LINE>
if ( ( color_type & PNG_COLOR_MASK_ALPHA ) != 0 ) <NEW_LINE>
LayoutPoint contentPos ( documentContentPosition ) ; <NEW_LINE>
if ( mStyle . size == 0 . 0 ) { <NEW_LINE>
<NEW_LINE>
<NEW_LINE>return skip ( c , body_size + 2 , MSG_JOB_TOO_BIG ) ; <NEW_LINE>
cycleDetectorSet ( thisDuringConstruction ( ) ) , <NEW_LINE>
if ( ! child -> renderer ( ) -> isOutOfFlowPositioned ( ) ) { <NEW_LINE>
return throwError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
{ 0xd16d73c1 , 0xe0f7 , 0x415c , \ <NEW_LINE> { 0xbd , 0x68 , 0x9c , 0x1f , 0x93 , 0xb8 , 0x73 , 0x7a } } <NEW_LINE>
#line 861 "ext / standard / var_unserializer . c" <NEW_LINE>
nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE>
#include "chrome / browser / chromeos / input_method / ibus_controller . h" <NEW_LINE>
#ifndef BASE_NUMERICS_SAFE_CONVERSIONS_IMPL_H_ <NEW_LINE>#define BASE_NUMERICS_SAFE_CONVERSIONS_IMPL_H_ <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
new_selection , <NEW_LINE>SetSelectionData::Builder ( options ) <NEW_LINE> . SetShouldShowHandle ( GetFrame ( ) . Selection ( ) . IsHandleVisible ( ) ) <NEW_LINE> . Build ( ) ) ;
int len = 0 ; <NEW_LINE>
{ 0 , jsatomid ( 0 ) } , NULL , NULL , 0 , 0 , 0 , <NEW_LINE>
ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; <NEW_LINE>
nsnull , <NEW_LINE>JSPROP_PERMANENT | <NEW_LINE>JSPROP_READONLY | <NEW_LINE>JSPROP_ENUMERATE ) ; <NEW_LINE>
Microtask::performCheckpoint ( m_isolate ) ; <NEW_LINE>
if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER && mByteLength ) { <NEW_LINE>
void * buffer , float * ) ; <NEW_LINE>
bool success , <NEW_LINE>int notify_id ) = 0 ; <NEW_LINE>
if ( chunk_num >= chm -> num_chunks ) return NULL ; <NEW_LINE>
rv = ExtractData ( type , params , getter_AddRefs ( stream ) , fallbackToPNG ) ; <NEW_LINE>
if ( equalIgnoringASCIICase ( getAttribute ( aria_readonlyAttr ) , "true" ) ) <NEW_LINE>
if ( xd -> mode_info_context -> mbmi . ref_frame >= LAST_FRAME ) { <NEW_LINE>const MV_REFERENCE_FRAME ref = xd -> mode_info_context -> mbmi . ref_frame ; <NEW_LINE>xd -> pre . y_buffer = ref_buffer [ ref ] [ 0 ] + recon_yoffset ; <NEW_LINE>xd -> pre . u_buffer = ref_buffer [ ref ] [ 1 ] + recon_uvoffset ; <NEW_LINE>xd -> pre . v_buffer = ref_buffer [ ref ] [ 2 ] + recon_uvoffset ; <NEW_LINE> } else { <NEW_LINE><NEW_LINE>xd -> pre . y_buffer = 0 ; <NEW_LINE>xd -> pre . u_buffer = 0 ; <NEW_LINE>xd -> pre . v_buffer = 0 ; <NEW_LINE> } <NEW_LINE>
if ( IsFrameTreeTooDeep ( aReflowState , aMetrics , aStatus ) ) { <NEW_LINE>
XPCAutoRequest ar ( mContext ) ; <NEW_LINE>
Microtask::performCheckpoint ( mainThreadIsolate ( ) ) ; <NEW_LINE>
if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] && <NEW_LINE>cfg -> rc_target_bitrate > 0 ) <NEW_LINE>
ErrorCode setupAlternativeOffsets ( PatternAlternative * alternative , unsigned currentCallFrameSize , unsigned initialInputPosition , unsigned * callFrameSizeOut ) <NEW_LINE>
php_array_merge_recursive ( seen , <NEW_LINE>couldRecur ( v , subarr1 ) , <NEW_LINE>subarr1 , <NEW_LINE>
vpx_write ( w , sign , mvcomp -> sign ) ; <NEW_LINE>
ReportBadReturn ( context , tc , pn , JSREPORT_ERROR , <NEW_LINE>
return emitNativeCall ( sn , argc , args , false ) ; <NEW_LINE>
if ( ( color_type & PNG_COLOR_MASK_COLOR ) != 0 ) <NEW_LINE>
ND_TCHECK ( lshp -> ls_length ) ; <NEW_LINE>
return ReportCompileErrorNumber ( cx , TS ( tc -> parser ) , pn , flags , errnum , name . ptr ( ) ) ; <NEW_LINE>
( void ) strncpy ( ( char * ) q , buffer , extent ) ; <NEW_LINE>q += extent ; <NEW_LINE>
( void ) memcpy ( clone_info -> pixels , cache_info -> pixels , cache_info -> columns * <NEW_LINE>cache_info -> rows * sizeof ( * cache_info -> pixels ) ) ; <NEW_LINE>
pusher . Push ( cx ) ; <NEW_LINE>
NS_WARNING ( "cannot set username on no - auth url" ) ; <NEW_LINE>
strncpy ( rblkcipher . type , "givcipher" , sizeof ( rblkcipher . type ) ) ; <NEW_LINE>strncpy ( rblkcipher . geniv , alg -> cra_ablkcipher . geniv ? : " < built - in > " , <NEW_LINE>sizeof ( rblkcipher . geniv ) ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ; <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ;
SetExnPrivate ( cx , copyobj , copy ) ; <NEW_LINE>
if ( ! mPauseState ) { <NEW_LINE>MaybeStartSampling ( aRefreshDriver ) ; <NEW_LINE>
<NEW_LINE>
mDocument -> NodePrincipal ( ) , <NEW_LINE>mDocument -> NodePrincipal ( ) , <NEW_LINE>url . get ( ) , aRequest -> mLineNo , <NEW_LINE>aRequest -> mJSVersion , nsnull , & isUndefined ) ; <NEW_LINE>
memset ( x , 0 , num * size ) ; <NEW_LINE>
tcmur_register_dbus_handler ( handler ) ; <NEW_LINE>
if ( JAS_CAST ( jas_ulong , jas_stream_tell ( tmpstream ) ) != ms -> len ) { <NEW_LINE>
<NEW_LINE><NEW_LINE>
if ( size < 0 ) return ( NULL ) ; <NEW_LINE>
RefPtr < SharedBuffer > data = readFile ( layoutTestResourcesDir , "animated . gif" ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>while ( encode_frame ( & codec , NULL , - 1 , writer ) ) { } <NEW_LINE>
thread -> tp_value [ 0 ] = regs -> ARM_r0 ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>WORD16 ai2_level_arr [ 7 ] ; <NEW_LINE>WORD16 * i2_level_arr = & ai2_level_arr [ 3 ] ; <NEW_LINE>
extern void isoclns_print ( netdissect_options * , const u_char * , u_int ) ; <NEW_LINE>
const int * src [ FLACParser::kMaxChannels ] , <NEW_LINE>
FILE_RCSID ( "@ ( # ) $ File: file . c , v 1 . 159 2014 / 11 / 28 02:46:39 christos Exp $ " ) <NEW_LINE>
delete [ ] displays_ ; <NEW_LINE>
. SetShouldShowHandle ( true ) <NEW_LINE>
while ( next_format ( & colour_type , & bit_depth , & palette_number , <NEW_LINE>pm -> test_lbg_gamma_threshold , pm -> test_tRNS ) ) <NEW_LINE>if ( palette_number < 2 ) <NEW_LINE>
return TEMP_FAILURE_RETRY ( send ( ts [ h ] . cmd_fdw , cmd_send , size_send , 0 ) ) == size_send ; <NEW_LINE>
ENGINE_SET_INVALID_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <NEW_LINE>
const uint64 size = <NEW_LINE>EbmlMasterElementSize ( kMkvContentEncoding , encoding_size ) + encoding_size ; <NEW_LINE>
int n = MIN ( sizeof ( clear_buffer ) , data_sz ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE>
else if ( jsvIsArrayBuffer ( var ) ) jsiConsolePrintf ( " % s " , jswGetBasicObjectName ( var ) ? jswGetBasicObjectName ( var ) :"unknown ArrayBuffer" ) ; <NEW_LINE>
<NEW_LINE>if ( skipPull && aState . mNextInFlow ) { <NEW_LINE>NS_ASSERTION ( heightConstrained , "Height should be constrained here\n" ) ; <NEW_LINE>if ( IS_TRUE_OVERFLOW_CONTAINER ( aState . mNextInFlow ) ) <NEW_LINE>NS_FRAME_SET_OVERFLOW_INCOMPLETE ( aState . mReflowStatus ) ; <NEW_LINE>else <NEW_LINE>NS_FRAME_SET_INCOMPLETE ( aState . mReflowStatus ) ; <NEW_LINE> } <NEW_LINE>
return ( - 1 ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>if ( ! height || ! width ) { <NEW_LINE>height = m_screenHeight ; <NEW_LINE>width = m_screenWidth ; <NEW_LINE>if ( ! height || ! width ) <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE>
if ( mTree ) <NEW_LINE>mFirstRange -> Invalidate ( mTree ) ; <NEW_LINE>delete mFirstRange ; <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;
unsigned int channels = <NEW_LINE> ( image -> format & PNG_FORMAT_FLAG_COLOR ) != 0 ? 3 : 1 ; <NEW_LINE>
#include "vpx / vpx_codec . h" <NEW_LINE>static const char * const cfg = " -- force - target = mips32 - android - gcc -- disable - runtime - cpu - detect -- sdk - path = / usr / local / google / home / vigneshv / Downloads / android - ndk - r10 -- disable - examples -- disable - docs -- enable - realtime - only -- disable - webm - io" ; <NEW_LINE>
unsigned long resource_id , const GURL & url , int notify_id ) ; <NEW_LINE>virtual webkit_glue::WebPluginResourceClient * CreateSeekableResourceClient ( <NEW_LINE>unsigned long resource_id , int range_request_id ) ; <NEW_LINE>
if ( ! ( * sp -> encodepfunc ) ( tif , bp , cc ) ) <NEW_LINE>return 0 ; <NEW_LINE>
<NEW_LINE><NEW_LINE>NS_IMETHODIMP nsBMPEncoder::GetImageBufferUsed ( PRUint32 * aOutputSize ) <NEW_LINE>
RefPtr < SharedBuffer > data = readFile ( layoutTestResourcesDir , "animated . gif" ) ; <NEW_LINE>
if ( need_close || TEMP_FAILURE_RETRY ( ioctl ( slot -> fd , FIONREAD , & size ) ) != 0 || ! size ) <NEW_LINE>
NS_ASSERTION ( ! ( contentTextLength < end - start ) , <NEW_LINE>"Frame offsets don't fit in content" ) ; <NEW_LINE>fragmentLength = NS_MIN ( contentTextLength , end - start ) ; <NEW_LINE>
tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <NEW_LINE>if ( ! tmp2 ) <NEW_LINE>free ( tmp ) ; <NEW_LINE>tmp = tmp2 ; <NEW_LINE>
* aNumBytes = mLength ; <NEW_LINE>
insert_hIST ( png_structp png_ptr , png_infop info_ptr , int nparams , <NEW_LINE>png_charpp params ) <NEW_LINE>
if ( png_ptr != NULL && info_ptr != NULL ) <NEW_LINE>
#line 917 "ext / standard / var_unserializer . c" <NEW_LINE>
return V8Proxy::throwNotEnoughArgumentsError ( args . GetIsolate ( ) ) ; <NEW_LINE>
IDBObjectStore::ClearCloneReadInfo ( mCloneReadInfo ) ; <NEW_LINE>
bool seek ( const Position & pos , const TokenStream & other ) ; <NEW_LINE>
if ( rp ) { <NEW_LINE>memset ( & rcp2 , 0 , sizeof ( rcp2 ) ) ; <NEW_LINE>rcp2 . ip = rp -> ip ; <NEW_LINE>rcp2 . at = rp -> at ; <NEW_LINE>rcp2 . flags = rp -> flags ; <NEW_LINE> } <NEW_LINE>
JSString * str = Int32ToString ( cx , JSID_TO_INT ( id ) ) ; <NEW_LINE>
_gdImageWebpCtx ( im , out , quality ) ; <NEW_LINE>
std::cout << " GenerateWord32 and Crop\n" ; <NEW_LINE>
return 1 ; <NEW_LINE>
ast_variables_destroy ( cookies ) ; <NEW_LINE>
<NEW_LINE>DISALLOW_COPY_AND_ASSIGN ( StructPtr ) ; <NEW_LINE>
u_char password [ 66 ] ; <NEW_LINE>
cert_sig = sig_verify ( ctx , cert -> signature , cert -> sig_len , cert -> sig_type , <NEW_LINE>
<NEW_LINE>if ( buf_size > CDG_HEADER_SIZE ) <NEW_LINE>bytestream_get_buffer ( & buf , cdg_data , buf_size - CDG_HEADER_SIZE ) ; <NEW_LINE>
if ( * object + size < * object || * object + size > bplist -> offset_table ) { <NEW_LINE>PLIST_BIN_ERR ( " % s: BPLIST_DICT data bytes point outside of valid range\n" , __func__ ) ; <NEW_LINE>
XPCAutoRequest ar ( mContext ) ; <NEW_LINE>
if ( ( jp2_image -> comps [ 0 ] . dx == 0 ) || ( jp2_image -> comps [ 0 ] . dy == 0 ) || <NEW_LINE> ( jp2_image -> comps [ 0 ] . dx != jp2_image -> comps [ i ] . dx ) || <NEW_LINE> ( jp2_image -> comps [ 0 ] . dy != jp2_image -> comps [ i ] . dy ) || <NEW_LINE> ( jp2_image -> comps [ 0 ] . prec != jp2_image -> comps [ i ] . prec ) || <NEW_LINE> ( jp2_image -> comps [ 0 ] . sgnd != jp2_image -> comps [ i ] . sgnd ) ) <NEW_LINE>
strncpy ( raead . type , "nivaead" , sizeof ( raead . type ) ) ; <NEW_LINE>strncpy ( raead . geniv , aead -> geniv , sizeof ( raead . geniv ) ) ; <NEW_LINE>
static const float vwin2048 [ 1024 ] = { <NEW_LINE>
if ( code || bad_pad ) { <NEW_LINE>
return mElements . SafeObjectAt ( aIndex ) ; <NEW_LINE>
if ( mListener && ! mCanceled ) { <NEW_LINE>
for ( i = 1 ; i <= lpc_order && i < nb_samples ; i ++ ) <NEW_LINE>
oggpack_buffer * b ) { <NEW_LINE>
if ( ! cxPusher . Push ( cx ) ) { <NEW_LINE>
goto have_file ; <NEW_LINE>
virtual void SyncShare ( sessions::SyncSession * session , <NEW_LINE>
void OnDidPrintPage ( const PrintHostMsg_DidPrintPage_Params & params ) ; <NEW_LINE><NEW_LINE><NEW_LINE>void UpdateForPrintedPage ( const PrintHostMsg_DidPrintPage_Params & params , <NEW_LINE>bool has_valid_page_data , <NEW_LINE>std::unique_ptr < base::SharedMemory > shared_buf ) ; <NEW_LINE><NEW_LINE><NEW_LINE>void OnComposePdfDone ( const PrintHostMsg_DidPrintPage_Params & params , <NEW_LINE>mojom::PdfCompositor::Status status , <NEW_LINE>mojo::ScopedSharedBufferHandle handle ) ; <NEW_LINE>
goto trunc ; <NEW_LINE>
const gfx::Rect & viewport , <NEW_LINE>const gfx::Rect & clip , <NEW_LINE>const gfx::Rect & viewport_rect_for_tile_priority , <NEW_LINE>const gfx::Transform & transform_for_tile_priority , <NEW_LINE>
<NEW_LINE>#if defined ( __CYGWIN__ ) <NEW_LINE>
CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ; <NEW_LINE>
if ( ! WriteEbmlMasterElement ( writer , kMkvContentEncodings , <NEW_LINE>
if ( ! CanEffectlesslyCallLookupGenericOnObject ( cx , obj , id ) ) <NEW_LINE>
u8 files [ SC_MAX_EXT_APDU_BUFFER_SIZE ] ; <NEW_LINE>
CHAR_LEN_TABLE ( HZCharLenTable ) , <NEW_LINE>
! JS_XDRCStringOrNull ( xdr , ( char ** ) & script -> filename ) || <NEW_LINE>
if ( s -> predictor == MEDIAN && avctx -> pix_fmt == AV_PIX_FMT_YUV422P && avctx -> width % 4 ) { <NEW_LINE>av_log ( avctx , AV_LOG_ERROR , "width must be a multiple of 4 this colorspace and predictor\n" ) ; <NEW_LINE>return AVERROR_INVALIDDATA ; <NEW_LINE> } <NEW_LINE>
if ( nPortIndex < m_sOutPortDef . nBufferCountActual && <NEW_LINE>BITMASK_PRESENT ( & m_out_bm_count , nPortIndex ) ) { <NEW_LINE>
#endif <NEW_LINE>#else <NEW_LINE>
if ( ! cxPusher . Push ( cx , nsCxPusher::REQUIRE_SCRIPT_CONTEXT ) ) { <NEW_LINE>
if ( PNG_CHUNK_ANCILLARY ( png_ptr -> chunk_name ) != 0 ) <NEW_LINE>
<NEW_LINE><NEW_LINE>
IPC::Message * init_done_msg ) ; <NEW_LINE>
nsGIFDecoder2::WriteInternal ( const char * aBuffer , uint32_t aCount , DecodeStrategy ) <NEW_LINE>
<NEW_LINE>#define for_each_leaf_cfs_rq ( rq , cfs_rq ) \ <NEW_LINE>list_for_each_entry_rcu ( cfs_rq , & rq -> leaf_cfs_rq_list , leaf_cfs_rq_list ) <NEW_LINE>
SecurityServer security ; <NEW_LINE>
<NEW_LINE><NEW_LINE>bool BindInstance ( ) WARN_UNUSED_RESULT ; <NEW_LINE>bool UnbindInstance ( ) WARN_UNUSED_RESULT ; <NEW_LINE>
if ( equalIgnoringASCIICase ( getAttribute ( aria_pressedAttr ) , "true" ) || <NEW_LINE>equalIgnoringASCIICase ( getAttribute ( aria_pressedAttr ) , "mixed" ) ) <NEW_LINE>
termPQExpBuffer ( & user_specification ) ; <NEW_LINE>
<NEW_LINE>
last mod: $ Id $ <NEW_LINE>
for ( size_t i = 1 , i_end = arr -> Count ( ) ; i < i_end ; ++ i ) { <NEW_LINE>
if ( ' % ' == * ptr && ptr [ 1 ] ) { <NEW_LINE>
void AddDefaultProxyBypassRules ( ) override ; <NEW_LINE>
SetSelection ( SelectionInDOMTree::Builder ( ) . SelectAllChildren ( * root ) . Build ( ) , <NEW_LINE>SetSelectionData::Builder ( ) <NEW_LINE> . SetShouldCloseTyping ( true ) <NEW_LINE> . SetShouldClearTypingStyle ( true ) <NEW_LINE> . SetShouldShowHandle ( IsHandleVisible ( ) ) <NEW_LINE>
XDRAtoms * atoms ; <NEW_LINE>XDRAtomsHashMap * atomsMap ; <NEW_LINE>
if ( curr -> isFloatingOrOutOfFlowPositioned ( ) ) <NEW_LINE>
if ( strict != 0 ) <NEW_LINE>
if ( ( value = stok ( value , "'\"" , NULL ) ) == 0 ) { <NEW_LINE>return 0 ; <NEW_LINE> } <NEW_LINE>
zend_error ( E_ERROR , " % s" , message ) ; <NEW_LINE>
return OFPERR_OFPGMFC_BAD_TYPE ; <NEW_LINE>
if ( ! desc_chunk || ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <NEW_LINE>
return TEMP_FAILURE_RETRY ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) ) == sizeof ( cmd ) ; <NEW_LINE>
if ( diff . hasNoChange ( ) ) <NEW_LINE>
kvm_read_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , <NEW_LINE>sizeof ( u32 ) ) ; <NEW_LINE>
while ( isdigit ( ( unsigned char ) * s ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) ) <NEW_LINE>
to_r = req::strndup ( to . data ( ) , to_len ) ; <NEW_LINE>
masm . storeValue ( NullValue ( ) , frame . addressOf ( origThis ) ) ; <NEW_LINE>
retval = bprm_change_interp ( interp , bprm ) ; <NEW_LINE>if ( retval < 0 ) <NEW_LINE>return retval ;
<NEW_LINE>extern void <NEW_LINE>js_GCMarkSharpMap ( JSContext * cx , JSSharpObjectMap * map ) ; <NEW_LINE><NEW_LINE>
uint32_t offset ; <NEW_LINE>if ( ! ToUint32 ( cx , args [ 0 ] , & offset ) ) <NEW_LINE>
strncpy ( rkpp . type , "kpp" , sizeof ( rkpp . type ) ) ; <NEW_LINE>
NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * kdelegate , void * val ) ; <NEW_LINE>
ReportBadReturn ( context , tc , pn , JSREPORT_ERROR , <NEW_LINE>
void jas_seq2d_bindsub ( jas_matrix_t * s , jas_matrix_t * s1 , jas_matind_t xstart , <NEW_LINE>jas_matind_t ystart , jas_matind_t xend , jas_matind_t yend ) ;
struct VpxEncoderConfig * global , <NEW_LINE>const struct VpxRational * pixel_aspect_ratio ) { <NEW_LINE>
if ( png_ptr != NULL ) <NEW_LINE>png_ptr -> user_chunk_cache_max = user_chunk_cache_max ; <NEW_LINE>
rv = principal -> GetJSPrincipals ( cx , & jsPrincipals ) ; <NEW_LINE>
( void ) TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <NEW_LINE>
<NEW_LINE>
IDBObjectStore::ClearCloneReadInfo ( mCloneReadInfo ) ; <NEW_LINE>
PRBool isIPaddr = cert_IsIPAddr ( hn ) ; <NEW_LINE>if ( isIPaddr ) { <NEW_LINE>if ( PORT_Strcasecmp ( hn , cn ) == 0 ) { <NEW_LINE>rv = SECSuccess ; <NEW_LINE> } else { <NEW_LINE>PORT_SetError ( SSL_ERROR_BAD_CERT_DOMAIN ) ; <NEW_LINE>rv = SECFailure ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE>rv = cert_TestHostName ( cn , hn ) ; <NEW_LINE> } <NEW_LINE>
client -> dumpClient ( fd , args ) ; <NEW_LINE>
if ( png_rtran_ok ( png_ptr , 0 ) == 0 ) <NEW_LINE>
return fm -> MoveFocus ( nsnull , this , nsIFocusManager::MOVEFOCUS_FORWARD , <NEW_LINE>nsIFocusManager::FLAG_NOPARENTFRAME , <NEW_LINE>
alu_dbl ( src1 , negImm , negDest , negOp , sc , c ) ) <NEW_LINE>
qcms_transform * transform = gfxPlatform::GetCMSRGBTransform ( ) ; <NEW_LINE>if ( transform ) <NEW_LINE>gfxPlatform::TransformPixel ( c , cms , transform ) ; <NEW_LINE>
httpSetParam ( conn , "controller" , ssplit ( sclone ( rx -> target ) , " - " , & actionName ) ) ; <NEW_LINE>
const internal::LocalSiteCharacteristicsDataImpl * impl_for_testing ( ) const { <NEW_LINE>return impl_ . get ( ) ; <NEW_LINE>
mCachedMaxUshortElement = FindMaxElementInSubArray < GLushort > ( mByteLength >> 1 , 0 ) ; <NEW_LINE>
key = ssplit ( arg , " = " , & value ) ; <NEW_LINE>
s -> dec_table , quantvals , s , opb , maptype ) ) return 1 ; <NEW_LINE>
if ( ! send && ! SSL_READ_ETM ( ssl ) && FIPS_mode ( ) ) <NEW_LINE>
if ( colb > iskew ) { <NEW_LINE>
ippSetValueTag ( job -> attrs , & attr , IPP_TAG_KEYWORD ) ; <NEW_LINE>ippSetString ( job -> attrs , & attr , 0 , "no - hold" ) ; <NEW_LINE>
GenerateGetTypedArrayElement ( cx , masm , attacher , tarr , idval , object ( ) , index ( ) , output ( ) , <NEW_LINE>allowDoubleResult ( ) ) ; <NEW_LINE>
int process_host_id_ ; <NEW_LINE>
printf ( "gamma % f: maximum 8 - bit error % f\n" , g , maxerr ) ; <NEW_LINE>
rootPC -> RequestUpdatePluginGeometry ( ) ; <NEW_LINE>
if ( gfxPlatform::GetPlatform ( ) -> UseHarfBuzzForScript ( aScript ) || <NEW_LINE> ( gfxWindowsPlatform::WindowsOSVersion ( ) < <NEW_LINE>gfxWindowsPlatform::kWindowsVista && <NEW_LINE>ScriptShapingType ( aScript ) == SHAPING_INDIC && <NEW_LINE> ! Preferences::GetBool ( "gfx . font_rendering . winxp - indic - uniscribe" , <NEW_LINE>false ) ) ) { <NEW_LINE>
return ( SkipDXTMipmaps ( image , dds_info , 16 , exception ) ) ; <NEW_LINE>
vpx_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; <NEW_LINE>
if ( equalIgnoringASCIICase ( getAttribute ( aria_disabledAttr ) , "true" ) ) <NEW_LINE>
if ( ( PRUint64 ) capacity * elemSize > size_type ( - 1 ) / 2 ) { <NEW_LINE>
JS_FRIEND_API ( JSBool ) <NEW_LINE>
<NEW_LINE>if ( ( shmflg & SHM_RND ) && addr >= shmlba ) <NEW_LINE>addr &= ~ ( shmlba - 1 ) ; <NEW_LINE>
SetUpIO ( ) ; <NEW_LINE>
mContent = do_GetWeakReference ( aContent ) ; <NEW_LINE>
if ( gData -> stateStackTop ) <NEW_LINE> -- gData -> stateStackTop ; <NEW_LINE>
ERREXIT ( cinfo , JERR_PPM_OUTOFRANGE ) ; <NEW_LINE>
mCollector -> FixGrayBits ( wantAllTraces ) ; <NEW_LINE>
if ( nicks == " * " && bufferInfo . type ( ) == BufferInfo::ChannelBuffer ) { <NEW_LINE>
goto failed_mount_wq ; <NEW_LINE>
const base::string16 & site_identity_details ( ) const { <NEW_LINE>return site_identity_details_ ; <NEW_LINE>
nsresult nsDocShellBackwardsEnumerator::BuildArrayRecursive ( nsIDocShellTreeItem * inItem , nsTArray < nsWeakPtr > & inItemArray ) <NEW_LINE>
rv = WrapNative ( cx , xpc_UnmarkGrayObject ( frameWin -> GetGlobalJSObject ( ) ) , <NEW_LINE>frame , & NS_GET_IID ( nsIDOMWindow ) , true , & v , <NEW_LINE>
SynthesizeSlowNativeFrame ( state , cx , innermost ) ; <NEW_LINE>
if ( png_crc_finish ( png_ptr , 0 ) != 0 ) <NEW_LINE>
<NEW_LINE>LogMessageIfVerbose ( "validateProgram: implemented as a no - operation on Mac to work around crashes" ) ; <NEW_LINE>return NS_OK ; <NEW_LINE>
} else if ( ReadableStreamOperations::isReadableStream ( scriptState , bodyValue ) ) { <NEW_LINE>bodyBuffer = new BodyStreamBuffer ( scriptState , bodyValue ) ; <NEW_LINE>
if ( NS_SUCCEEDED ( rv ) ) { <NEW_LINE><NEW_LINE><NEW_LINE>rv = BuildNormalizedSpec ( spec ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( NS_FAILED ( rv ) ) { <NEW_LINE>Clear ( ) ; <NEW_LINE>return rv ; <NEW_LINE> } <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
mInDtor = PR_FALSE ; <NEW_LINE>
delete [ ] name ; <NEW_LINE>
TransformChange calculateLocalTransform ( ) override ; <NEW_LINE>
ND_TCHECK ( p [ 3 ] ) ; <NEW_LINE>
nsCOMPtr < nsINode > oldParent = newContent -> GetNodeParent ( ) ; <NEW_LINE>
int count = TEMP_FAILURE_RETRY ( recv ( fd , buffer , L2CAP_MAX_SDU_LENGTH , <NEW_LINE>MSG_NOSIGNAL | MSG_DONTWAIT ) ) ; <NEW_LINE>
DISALLOW_COPY_AND_ASSIGN ( WiFiDisplayMediaDatagramPacket ) ; <NEW_LINE>
m_pOutput_pmem [ i ] . buffer = NULL ; <NEW_LINE>
xmlGenericError , xmlGenericError , NULL ) ; <NEW_LINE>
<NEW_LINE>
#include "nsIPKCS11 . h" <NEW_LINE>
RETURN_TRUE <NEW_LINE>
NS_ABORT_IF_FALSE ( size >= 0 && size <= PR_INT32_MAX , "Size out of range . " ) ; <NEW_LINE>nsresult rv = gMediaCache -> ReadCacheFile ( offset , aBuffer + count , PRInt32 ( size ) , & bytes ) ; <NEW_LINE>
nsresult nsIDNService::decodeACE ( const nsACString & in , nsACString & out , <NEW_LINE>PRBool allowUnassigned ) <NEW_LINE>
DSA_Signature_Operation ( const DSA_PrivateKey & dsa , <NEW_LINE>const std::string & emsa , <NEW_LINE>RandomNumberGenerator & rng ) : <NEW_LINE>
return random_nextDouble ( cx ) ; <NEW_LINE>
int res = 0 ; <NEW_LINE>
NS_ASSERTION ( mResolutionPhase == nsForwardReference::eStart , <NEW_LINE>"nested ResolveForwardReferences ( ) " ) ; <NEW_LINE><NEW_LINE>
if ( alpha_mode != kNoAlpha && alpha_mode != kAlpha ) <NEW_LINE>
void OnNetworkFetcherComplete ( int net_error , int64_t content_size ) ; <NEW_LINE>
if ( segment_stop >= 0 && pos > segment_stop ) <NEW_LINE>return E_FILE_FORMAT_INVALID ; <NEW_LINE>
frame_table = ( guint32 * ) g_try_malloc ( frame_table_length ) ; <NEW_LINE>if ( frame_table_length != 0 && frame_table == NULL ) { <NEW_LINE> * err = ENOMEM ; <NEW_LINE>return - 1 ; <NEW_LINE> } <NEW_LINE>
if ( status == nlm_lck_denied_grace_period ) { <NEW_LINE><NEW_LINE>nlmsvc_insert_block ( block , 10 * HZ ) ; <NEW_LINE> } else { <NEW_LINE><NEW_LINE>nlmsvc_unlink_block ( block ) ; <NEW_LINE>
ctx -> iface -> destroy ( ( vpx_codec_alg_priv_t * ) ctx -> priv ) ; <NEW_LINE>
bool ReplyToRenderer ( ) ;
memset ( lowercasePath , 0 , ( filePathLen + 2 ) * sizeof ( WCHAR ) ) ; <NEW_LINE>wcsncpy ( lowercasePath , filePath , filePathLen + 1 ) ; <NEW_LINE>
} <NEW_LINE>
CHECK_PIXEL_PTR ( 2 * byte_run ) ; <NEW_LINE>
if ( p -> eobs [ block ] > 0 ) { <NEW_LINE>#if CONFIG_VP9_HIGHBITDEPTH <NEW_LINE>if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <NEW_LINE>x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>#endif <NEW_LINE>x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <NEW_LINE> } <NEW_LINE>
found = ( unsigned char * ) php_memnstr ( ( char * ) haystack + noffset , ( char * ) needle , needle_len , ( char * ) haystack + haystack_len ) ; <NEW_LINE>
if ( ( png_ptr -> flags & PNG_FLAG_ROW_INIT ) == 0 ) <NEW_LINE>
rv = principal -> GetJSPrincipals ( cx , & jsPrincipals ) ; <NEW_LINE>
RenderViewHost * render_view_host ( ) ; <NEW_LINE>
<NEW_LINE>
return throwVMError ( exec , createNotEnoughArgumentsError ( exec ) ) ; <NEW_LINE>
WCHAR path [ MAX_PATH + sizeof ( "sensor . dll" ) ] ; <NEW_LINE>if ( GetSystemDirectoryW ( path , MAX_PATH ) ) { <NEW_LINE>wcscat ( path , L"sensor . dll" ) ; <NEW_LINE>mLibrary = LoadLibraryW ( path ) ; <NEW_LINE> } <NEW_LINE>
UINT32 count = bitmapUpdate -> number * 2 ; <NEW_LINE>BITMAP_DATA * newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , <NEW_LINE>sizeof ( BITMAP_DATA ) * count ) ; <NEW_LINE>
FILE_RCSID ( "@ ( # ) $ File: magic . c , v 1 . 90 2014 / 12 / 04 15:56:46 christos Exp $ " ) <NEW_LINE>
MutexTryLocker tryLocker ( m_processLock ) ; <NEW_LINE>if ( tryLocker . locked ( ) ) <NEW_LINE>return m_reverb ? m_reverb -> latencyFrames ( ) / static_cast < double > ( sampleRate ( ) ) : 0 ; <NEW_LINE><NEW_LINE><NEW_LINE>return std::numeric_limits < double > ::infinity ( ) ; <NEW_LINE>
if ( png_set_text_2 ( png_ptr , info_ptr , & text_info , 1 ) != 0 ) <NEW_LINE>
if ( ! FireClipboardEvent ( NS_PASTE , aSelectionType ) ) <NEW_LINE>
if ( ( fd = TEMP_FAILURE_RETRY ( open ( clonedev , O_RDWR ) ) ) < 0 ) <NEW_LINE>
perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , <NEW_LINE>
detach ( ) ; <NEW_LINE>
Ar = GetCacheViewVirtualPixels ( Ar_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE>Ai = GetCacheViewVirtualPixels ( Ai_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE>Br = GetCacheViewVirtualPixels ( Br_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE>Bi = GetCacheViewVirtualPixels ( Bi_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE>
frameView -> setNeedsUpdateWidgetPositions ( ) ; <NEW_LINE>
int ( * enable ) ( bool guest_mode ) ; <NEW_LINE>
AssertIsOnIOThread ( ) ; <NEW_LINE>
#line 615 "ext / standard / var_unserializer . re" <NEW_LINE>
return INT64_MAX ; <NEW_LINE>
#line 189 "hex_grammar . c" <NEW_LINE>
if ( ! EnsureStringLength ( buffer , outUnicodeLen ) ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE>
zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , " % s" , error ) ; <NEW_LINE>
static const color_encoding test_encodings [ ] = <NEW_LINE>
( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) != 0 ) <NEW_LINE>
if ( ( transforms & PNG_TRANSFORM_SWAP_ALPHA ) != 0 ) <NEW_LINE>
<NEW_LINE>gamepad . numAxes = 0 ; <NEW_LINE>
scale = adjust_scale ( scale ) ; <NEW_LINE>
if ( aDispatchPendingEvents && ! Destroyed ( ) ) { <NEW_LINE>
( png_int_32 ) info_ptr -> x_pixels_per_unit ) != 0 ) <NEW_LINE>
p_fm_config_conx_hdlt	hdl = NULL ; <NEW_LINE>
length = ( MagickSizeType ) ( unsigned char ) ReadBlobByte ( image ) ; <NEW_LINE>
ret = fscrypt_get_encryption_info ( dir ) ; <NEW_LINE>
mParams . mEventSymbol == nsGkAtoms::repeatEvent || <NEW_LINE>mParams . mEventSymbol == nsGkAtoms::beginEvent || <NEW_LINE>mParams . mEventSymbol == nsGkAtoms::endEvent ) ) { <NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
register struct bsnamemem * tp ; <NEW_LINE>
if ( hdr -> hdr . incl_len > wth -> snapshot_length ) { <NEW_LINE>g_warning ( "pcap: File has packet larger than file's snapshot length . " ) ; <NEW_LINE>
const int v = ( int ) ( . 5 + 256 * gaussian ( sigma , 0 , i ) ) ; <NEW_LINE>
<NEW_LINE>
if ( pixel . red <= GetQuantumRange ( depth ) ) <NEW_LINE>pixel . red = scale [ pixel . red ] ; <NEW_LINE>if ( pixel . green <= GetQuantumRange ( depth ) ) <NEW_LINE>pixel . green = scale [ pixel . green ] ; <NEW_LINE>if ( pixel . blue <= GetQuantumRange ( depth ) ) <NEW_LINE>pixel . blue = scale [ pixel . blue ] ; <NEW_LINE>
h -> ref_count [ 1 ] = 1 ; <NEW_LINE>
if ( mprWriteJsonObj ( app -> config , key , abilities ) < 0 ) { <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
length = ( gint ) tvb_ensure_length_remaining ( tvb , offset ) ; <NEW_LINE>
if ( mprReadJson ( prop , " [ @ = c ] " ) ) { <NEW_LINE>
s -> close ( s ) ; <NEW_LINE>
AutoPushJSContext cx ( context -> GetNativeContext ( ) ) ; <NEW_LINE>
} else if ( s -> bit_depth == 1 && s -> bits_per_pixel == 1 ) { <NEW_LINE>
scoped_ptr < input_method::InputMethodDescriptors > input_method_descriptors_ ; <NEW_LINE>
header -> checkHeader ( ) ; <NEW_LINE>
memcpy ( & cpi -> common . lfc , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <NEW_LINE>
if ( mDurationUs > 0 && mDataSource -> getSize ( & size ) == OK ) { <NEW_LINE>
#define PNG_FORMAT_FLAG_LINEAR 0x04U <NEW_LINE>
Control ( ctrl_id , arg , VPX_CODEC_OK ) ; <NEW_LINE>
uint64 Segment::AddAudioTrack ( int32 sample_rate , int32 channels , int32 number ) { <NEW_LINE>
if ( png_get_sRGB ( read_ptr , read_info_ptr , & intent ) != 0 ) <NEW_LINE>
number = image . ncolors ; <NEW_LINE>for ( i = 0 ; i < number ; i ++ ) { <NEW_LINE>if ( ! image . colorTable [ i ] . c_color ) { <NEW_LINE>goto done ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>
nsCOMPtr < nsINode > parent = node -> GetNodeParent ( ) ; <NEW_LINE>
<NEW_LINE>
<NEW_LINE>if ( ! mIsDestroying ) { <NEW_LINE>nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>mFrameConstructor -> CreateNeededFrames ( ) ; <NEW_LINE>mFrameConstructor -> ProcessPendingRestyles ( ) ; <NEW_LINE> } <NEW_LINE>
cxPusher . Push ( aCx , nsCxPusher::REQUIRE_SCRIPT_CONTEXT ) ; <NEW_LINE>
int n = ( int ) MIN ( sizeof ( clear_buffer ) , data_end - data ) ; <NEW_LINE>
bool success , <NEW_LINE>int notify_id ) ; <NEW_LINE>
Jump done = masm . jump ( ) ; <NEW_LINE>
int byte_alignment ; <NEW_LINE>int skip_loop_filter ; <NEW_LINE>
if ( curr -> renderer ( ) -> isOutOfFlowPositioned ( ) ) <NEW_LINE>
if ( aJavaURI || thisContent -> NodeInfo ( ) -> Equals ( nsGkAtoms::applet ) ) { <NEW_LINE>
PHPAPI void php_stat ( const char * filename , size_t filename_length , int type , zval * return_value ) <NEW_LINE>
return <NEW_LINE># if PNG_LIBPNG_VER >= 10700 <NEW_LINE>colour_type != PNG_COLOR_TYPE_PALETTE && <NEW_LINE># endif <NEW_LINE> ( colour_type & PNG_COLOR_MASK_ALPHA ) == 0 ; <NEW_LINE>
void StopCasting ( ) override ; <NEW_LINE>
static int get_minq_index ( double maxq , double x3 , double x2 , double x1 , <NEW_LINE>vpx_bit_depth_t bit_depth ) { <NEW_LINE>
pattern = mprReadJson ( child , "pattern" ) ; <NEW_LINE>
HistoryProvider ( AutocompleteProviderListener * listener , <NEW_LINE>
NS_ASSERTION ( mContentOffset < PRInt32 ( aContent -> GetText ( ) -> GetLength ( ) ) , <NEW_LINE>
r . Scale ( 1 / kernelX , 1 / kernelY ) ; <NEW_LINE>
nsIFormControlFrame * formControlFrame = GetFormControlFrame ( PR_TRUE ) ; <NEW_LINE>
# define rint ( x ) ( floor ( ( x ) + 0 . 5f ) ) <NEW_LINE>
<NEW_LINE>
{ <NEW_LINE>ignore_depth ++ ; <NEW_LINE> ( void ) DestroyXMLTreeAttributes ( attributes ) ; <NEW_LINE> } <NEW_LINE>
run_cmd ( tty_fd , xfr_cmd , fname ) ; <NEW_LINE>
if ( length == ( png_uint_32 ) png_sRGB_checks [ i ] . length && <NEW_LINE>intent == ( png_uint_32 ) png_sRGB_checks [ i ] . intent ) <NEW_LINE>
#include "base / macros . h" <NEW_LINE>
if ( TEMP_FAILURE_RETRY ( poll ( & pfd , 1 , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) ) == 0 ) <NEW_LINE>
void CommitPendingTransaction ( const gfx::Rect & damage_rect , <NEW_LINE>SwapCompletionCallback completion_callback , <NEW_LINE>
#define MagickSVNRevision "18670M" <NEW_LINE>
if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { <NEW_LINE>
if ( NS_FAILED ( HandleEventSubType ( ls , * aDOMEvent , aCurrentTarget , <NEW_LINE>aPusher ) ) ) { <NEW_LINE>
if ( global -> getJSClass ( ) != & js_dummy_class && obj -> getParent ( ) != global ) { <NEW_LINE>
if ( * valueEnd == '\\' && * ( valueEnd + 1 ) ) <NEW_LINE>
const sp < IMediaPlayerService > service ( getMediaPlayerService ( ) ) ; <NEW_LINE>
jas_matind_t i ; <NEW_LINE>jas_matind_t j ; <NEW_LINE>
yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <NEW_LINE>
class BlobRegistry { <NEW_LINE>
: NON_EXPORTED_BASE ( public base::NonThreadSafe ) { <NEW_LINE>
friend class base::RefCountedThreadSafe < H264Picture > ; <NEW_LINE>
static BOOL nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , <NEW_LINE>
public SSLErrorHandler::Delegate , <NEW_LINE>public base::SupportsWeakPtr < ResourceDispatcherHostImpl > { <NEW_LINE>
NS_RELEASE ( offlineCacheUpdate ) ; <NEW_LINE>
"truncated pcapng dump file ; tried to read % " PRIsize " bytes , only got % " PRIsize , <NEW_LINE>
# if PNG_LIBPNG_VER >= 10700 && \ <NEW_LINE> ! defined ( PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED ) <NEW_LINE>if ( option < PNG_HANDLE_CHUNK_IF_SAFE ) <NEW_LINE># endif <NEW_LINE>png_set_keep_unknown_chunks ( d -> png_ptr , option , NULL , 0 ) ; <NEW_LINE><NEW_LINE>
TRACK_RUN_IN_THIS_SCOPED_REGION ( member_func ) ; \ <NEW_LINE>
bhi * data . blue_coefficient + 2 . / 32768 + out_qe ; <NEW_LINE>
<NEW_LINE><NEW_LINE>if ( ! IndexToId ( cx , i - 1 , & id2 ) ) <NEW_LINE>return JS_FALSE ; <NEW_LINE><NEW_LINE>
col_sum [ c ] - = adjustment ; <NEW_LINE>
CHECK_PIXEL_PTR ( byte_run * 2 ) ; <NEW_LINE>
<NEW_LINE>void ClearTextRun ( nsTextFrame * aStartContinuation = nsnull ) ; <NEW_LINE>
l2 = php_strnlen ( buffer + 2 + l1 + 1 , length - 2 - l1 - 1 ) ; <NEW_LINE>
if ( ! mThisObjects . put ( tableScript , JS::Heap < JSObject * > ( obj ) ) ) { <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE>
<NEW_LINE>
TransformChange calculateLocalTransform ( ) override ; <NEW_LINE>
typedef png_libpng_version_1_6_20 Your_png_h_is_not_version_1_6_20 ; <NEW_LINE>#endif <NEW_LINE>
isoclns_print ( ndo , p , length ) ; <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>xpc_UnmarkGrayObject ( aCallback ) ; <NEW_LINE>mRootedCallable . construct ( cx , aCallback ) ; <NEW_LINE><NEW_LINE>
return ! obj -> isFloatingOrOutOfFlowPositioned ( ) && ! obj -> isRunIn ( ) <NEW_LINE> && obj -> isBlockFlow ( ) && obj -> style ( ) -> height ( ) . isAuto ( ) <NEW_LINE> && ( ! obj -> isDeprecatedFlexibleBox ( ) || obj -> style ( ) -> boxOrient ( ) == VERTICAL ) ; <NEW_LINE>
if ( pv -> context == NULL ) <NEW_LINE> { <NEW_LINE>pv -> context = avcodec_alloc_context3 ( codec ) ; <NEW_LINE> } <NEW_LINE>
static int __perf_event_overflow ( struct perf_event * event , <NEW_LINE>
DidInstallNewDocument ( document , reason ) ;
StyleDifference diff ; <NEW_LINE>
last mod: $ Id $ <NEW_LINE>
&& ( _equal = strchr ( tok , ' = ' ) ) <NEW_LINE> && ( strlen ( _equal ) > 1 ) ) { <NEW_LINE>
<NEW_LINE><NEW_LINE><NEW_LINE>virtual bool ShouldSwapProcessesForNavigation ( SiteInstance * site_instance , <NEW_LINE>const GURL & current_url , <NEW_LINE>
( row_info -> color_type & PNG_COLOR_MASK_COLOR ) == 0 ) <NEW_LINE>
if ( verbose != 0 ) <NEW_LINE>
. llseek = ftrace_filter_lseek , <NEW_LINE>
<NEW_LINE>
if ( ( * rp >> padding ) != 0 ) <NEW_LINE>
nsresult InitBasic ( ) ; <NEW_LINE>
if ( image_info -> ping != MagickFalse ) goto Finish ; <NEW_LINE>status = SetImageExtent ( image , image -> columns , image -> rows ) ; <NEW_LINE>if ( status == MagickFalse ) <NEW_LINE> { <NEW_LINE>InheritException ( exception , & image -> exception ) ; <NEW_LINE>return ( DestroyImageList ( image ) ) ; <NEW_LINE> } <NEW_LINE>
static void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <NEW_LINE>
<NEW_LINE>down_read ( & vcpu -> kvm -> slots_lock ) ; <NEW_LINE>if ( gfn_to_memslot ( vcpu -> kvm , sregs -> cr3 >> PAGE_SHIFT ) ) <NEW_LINE>vcpu -> arch . cr3 = sregs -> cr3 ; <NEW_LINE>else <NEW_LINE>set_bit ( KVM_REQ_TRIPLE_FAULT , & vcpu -> requests ) ; <NEW_LINE>up_read ( & vcpu -> kvm -> slots_lock ) ; <NEW_LINE>
