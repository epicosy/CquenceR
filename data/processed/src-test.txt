<START_VULN> class NonThreadSafeImpl { <NEW_LINE> <END_VULN> public: <NEW_LINE> ~ NonThreadSafeImpl ( ) ;
static BT_HDR * create_pbuf ( UINT16 len , UINT8 * data ) <NEW_LINE> { <NEW_LINE> <START_VULN> BT_HDR * p_buf = GKI_getbuf ( ( UINT16 ) ( len + BTA_HH_MIN_OFFSET + sizeof ( BT_HDR ) ) ) ; <NEW_LINE> <END_VULN> if ( p_buf ) { <NEW_LINE> UINT8 * pbuf_data ;
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> DOMStringList * listArg ( toDOMStringList ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
<START_VULN> bool ResolveShortcut ( FilePath * path ) ; <NEW_LINE> <END_VULN>
void firstRectForCharacterInSelectedRange ( const uint64_t characterPosition , WebCore::IntRect & resultRect ) ; <NEW_LINE> void getSelectedText ( WTF::String & ) ; <NEW_LINE> <START_VULN> void gestureWillBegin ( const WebCore::IntPoint & point , bool & canBeginPanning ) ; <NEW_LINE>void gestureDidScroll ( const WebCore::IntSize & size ) ; <NEW_LINE> <END_VULN> void gestureDidEnd ( ) ; <NEW_LINE> #endif
} <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifndef PNG_STDIO_SUPPORTED
png_set_progressive_read_fn ( mPNG , static_cast < png_voidp > ( this ) , <NEW_LINE> nsPNGDecoder::info_callback , <NEW_LINE> nsPNGDecoder::row_callback , <NEW_LINE> nsPNGDecoder::end_callback ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> <START_VULN> nsPNGDecoder::WriteInternal ( const char * aBuffer , uint32_t aCount ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ABORT_IF_FALSE ( ! HasError ( ) , "Shouldn't call WriteInternal after error ! " ) ; <NEW_LINE> if ( IsSizeDecode ( ) ) { <NEW_LINE> if ( mHeaderBytesRead == BYTES_NEEDED_FOR_DIMENSIONS )
#include "core / platform / graphics / FontCache . h" <NEW_LINE> #include "core / platform / graphics / GraphicsContext . h" <NEW_LINE> #include "core / platform / graphics / skia / SkiaFontWin . h" <NEW_LINE> <START_VULN> #include "core / platform / win / HWndDC . h" <NEW_LINE> <END_VULN> #include "platform / LayoutTestSupport . h" <NEW_LINE> #include "platform / SharedBuffer . h" <NEW_LINE> #include "public / platform / Platform . h" <NEW_LINE> #include "public / platform / win / WebSandboxSupport . h" <NEW_LINE> #include "wtf / PassOwnPtr . h"
if ( entry -> location . rva + entry -> location . data_size > obj -> b -> length ) { <NEW_LINE> <START_VULN> eprintf ( " [ ERROR ] Size Mismatch - Stream data is larger than file size ! \n" ) ; <NEW_LINE> <END_VULN> return false ; <NEW_LINE> }
} <NEW_LINE> static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx , <NEW_LINE> <START_VULN> int ctr_id , <NEW_LINE>va_list args ) <NEW_LINE> <END_VULN> { <NEW_LINE> int update = va_arg ( args , int ) ; <NEW_LINE> vp8_update_entropy ( ctx -> cpi , update ) ;
struct user_namespace * ns , int cap ) ; <NEW_LINE> extern bool capable ( int cap ) ; <NEW_LINE> extern bool ns_capable ( struct user_namespace * ns , int cap ) ; <NEW_LINE> <START_VULN> extern bool inode_capable ( const struct inode * inode , int cap ) ; <NEW_LINE> <END_VULN> extern bool file_ns_capable ( const struct file * file , struct user_namespace * ns , int cap ) ;
ContextualSearchParams ( int version , <NEW_LINE> const std::string & selection , <NEW_LINE> const std::string & base_page_url , <NEW_LINE> <START_VULN> int now_on_tap_version ) ; <NEW_LINE> <END_VULN> ContextualSearchParams ( int version ,
{ <NEW_LINE> const short * HFilter ; <NEW_LINE> const short * VFilter ; <NEW_LINE> <START_VULN> DECLARE_ALIGNED_ARRAY ( 4 , short , FData , 24 * 16 ) ; <NEW_LINE> <END_VULN> HFilter = vp8_sub_pel_filters [ xoffset ] ; <NEW_LINE> VFilter = vp8_sub_pel_filters [ yoffset ] ;
int bytes_written = 0 ; <NEW_LINE> register int i ; <NEW_LINE> register guint8 * s_ptr , * m_ptr ; <NEW_LINE> <START_VULN> gint16 msdu_length , actual_octets ; <NEW_LINE> <END_VULN> guint8 flow_seq ; <NEW_LINE> guint64 s_time = LL_ZERO , e_time = LL_ZERO ;
q4u8 = vld1q_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; <NEW_LINE> q5u8 = vld1q_u8 ( src_ptr ) ; <NEW_LINE> <START_VULN> d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ; <NEW_LINE>d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ; <NEW_LINE> <END_VULN> q6u16 = vmull_u8 ( vget_low_u8 ( q1u8 ) , d0u8 ) ; <NEW_LINE> q7u16 = vmull_u8 ( vget_low_u8 ( q2u8 ) , d0u8 ) ;
s [ 0 ] = _mm_add_epi16 ( p [ 0 ] , t [ 1 ] ) ; <NEW_LINE> s [ 1 ] = _mm_sub_epi16 ( p [ 0 ] , t [ 1 ] ) ; <NEW_LINE> <START_VULN> s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ; <NEW_LINE>s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; <NEW_LINE>s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ; <NEW_LINE>s [ 5 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; <NEW_LINE> <END_VULN> s [ 6 ] = _mm_sub_epi16 ( p [ 7 ] , t [ 6 ] ) ; <NEW_LINE> s [ 7 ] = _mm_add_epi16 ( p [ 7 ] , t [ 6 ] ) ;
BufferMeta * bufferMeta = ( BufferMeta * ) ( header -> pAppPrivate ) ; <NEW_LINE> sp < ABuffer > data = bufferMeta -> getBuffer ( <NEW_LINE> <START_VULN> header , portIndex == kPortIndexInput , false ) ; <NEW_LINE> <END_VULN> bufferMeta -> setNativeHandle ( nativeHandle ) ; <NEW_LINE> if ( mMetadataType [ portIndex ] == kMetadataBufferTypeNativeHandleSource <NEW_LINE> && data -> capacity ( ) >= sizeof ( VideoNativeHandleMetadata ) ) {
mail_fetchstructure ( vms -> mailstream , vms -> msgArray [ vms -> curmsg ] , & body ) ; <NEW_LINE> <START_VULN> if ( body -> nested . part -> next && body -> nested . part -> next -> body . parameter -> value ) { <NEW_LINE> <END_VULN> attachedfilefmt = ast_strdupa ( body -> nested . part -> next -> body . parameter -> value ) ; <NEW_LINE> } else { <NEW_LINE> ast_log ( LOG_ERROR , "There is no file attached to this IMAP message . \n" ) ;
next -> next = NULL ; <NEW_LINE> fprintf ( stderr , "\t % lu bytes @ % p\n" , <NEW_LINE> <START_VULN> ( unsigned long ) next -> size , ( PNG_CONST void * ) ( next + 1 ) ) ; <NEW_LINE> <END_VULN>
nsec = rtc_time ( ) * sgi_clock_period <NEW_LINE> + sgi_clock_offset . tv_nsec ; <NEW_LINE> <START_VULN> tp -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & tp -> tv_nsec ) <NEW_LINE> + sgi_clock_offset . tv_sec ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> } ;
nsresult <NEW_LINE> OpenDatabaseHelper::CreateDatabaseConnection ( <NEW_LINE> nsIFile * aDBFile , <NEW_LINE> nsIFile * aFMDirectory , <NEW_LINE> const nsAString & aName , <NEW_LINE> const nsACString & aOrigin , <NEW_LINE> mozIStorageConnection ** aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "OpenDatabaseHelper::CreateDatabaseConnection" ) ; <NEW_LINE> nsresult rv ; <NEW_LINE> bool exists ; <NEW_LINE> if ( IndexedDatabaseManager::InLowDiskSpaceMode ( ) ) {
extern "C" { <NEW_LINE> #endif <NEW_LINE> <START_VULN> void vp9_temporal_filter_prepare ( VP9_COMP * cpi , int distance ) ; <NEW_LINE>void vp9_configure_arnr_filter ( VP9_COMP * cpi , <NEW_LINE>const unsigned int frames_to_arnr , <NEW_LINE>const int group_boost ) ; <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> }
#endif <NEW_LINE> if ( provider == "base" || provider . empty ( ) ) <NEW_LINE> <START_VULN> return std::unique_ptr < PK_Ops::Signature > ( new ECDSA_Signature_Operation ( * this , params ) ) ; <NEW_LINE> <END_VULN> throw Provider_Not_Found ( algo_name ( ) , provider ) ; <NEW_LINE> }
fgot = php_stream_read ( ImageInfo -> infile , ImageInfo -> Thumbnail . data , ImageInfo -> Thumbnail . size ) ; <NEW_LINE> if ( fgot < ImageInfo -> Thumbnail . size ) { <NEW_LINE> EXIF_ERRLOG_THUMBEOF ( ImageInfo ) <NEW_LINE> } <NEW_LINE> <START_VULN> exif_thumbnail_build ( ImageInfo TSRMLS_CC ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef EXIF_DEBUG <NEW_LINE> exif_error_docref ( NULL EXIFERR_CC , ImageInfo , E_NOTICE , "Read next IFD ( THUMBNAIL ) done" ) ;
} <NEW_LINE> if ( strncasecmp ( resource -> scheme , "http" , sizeof ( "http" ) ) && strncasecmp ( resource -> scheme , "https" , sizeof ( "https" ) ) ) { <NEW_LINE> <START_VULN> if ( ! context || <NEW_LINE> <END_VULN> php_stream_context_get_option ( context , wrapper -> wops -> label , "proxy" , & tmpzval ) == FAILURE || <NEW_LINE> Z_TYPE_PP ( tmpzval ) != IS_STRING || <NEW_LINE> Z_STRLEN_PP ( tmpzval ) <= 0 ) {
#define COL_FROM_ID ( id ) ( ( png_byte ) ( ( id ) & 0x7U ) ) <NEW_LINE> #define DEPTH_FROM_ID ( id ) ( ( png_byte ) ( ( ( id ) >> 3 ) & 0x1fU ) ) <NEW_LINE> #define PALETTE_FROM_ID ( id ) ( ( ( id ) >> 8 ) & 0x1f ) <NEW_LINE> <START_VULN> #define INTERLACE_FROM_ID ( id ) ( ( int ) ( ( ( id ) >> 13 ) & 0x3 ) ) <NEW_LINE> <END_VULN> #define DO_INTERLACE_FROM_ID ( id ) ( ( int ) ( ( ( id ) >> 15 ) & 1 ) ) <NEW_LINE> #define WIDTH_FROM_ID ( id ) ( ( ( id ) >> 16 ) & 0xff ) <NEW_LINE> #define HEIGHT_FROM_ID ( id ) ( ( ( id ) >> 24 ) & 0xff )
int j ; <NEW_LINE> for ( j = 0 ; j < a -> num_values ; j ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> body [ j ] = XMALLOC ( VarLenData , 1 ) ; <NEW_LINE>body [ j ] -> len = a -> values [ j ] . len ; <NEW_LINE>body [ j ] -> data = CHECKED_XCALLOC ( unsigned char , a -> values [ j ] . len ) ; <NEW_LINE>memmove ( body [ j ] -> data , a -> values [ j ] . data . buf , body [ j ] -> len ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return body ; <NEW_LINE> }
case PNG_COLOR_TYPE_PALETTE: <NEW_LINE> { <NEW_LINE> <START_VULN> PNG_CONST unsigned int index = component ( row , x , 0 , bit_depth , 1 ) ; <NEW_LINE> <END_VULN> png_colorp palette = NULL ; <NEW_LINE> int num_palette = 0 ;
<START_VULN> if ( full_quantize ) <NEW_LINE> <END_VULN> { <NEW_LINE> int j = num_palette ;
} else { <NEW_LINE> intern -> _path_len = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( intern -> _path ) { <NEW_LINE> efree ( intern -> _path ) ; <NEW_LINE> }
void init_context_counters ( void ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memset ( context_counters , 0 , sizeof ( context_counters ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void print_context_counters ( )
modification = ! ! mAttrsAndChildren . GetAttr ( attrName -> LocalName ( ) , <NEW_LINE> attrName -> NamespaceID ( ) ) ; <NEW_LINE> } <NEW_LINE> nsAttrValue newValue ( aObservable ) ; <NEW_LINE> return SetAttrAndNotify ( attrName -> NamespaceID ( ) , attrName -> LocalName ( ) , <NEW_LINE> attrName -> GetPrefix ( ) , EmptyString ( ) , newValue , <NEW_LINE> <START_VULN> modification , hasListeners , PR_TRUE ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> PRBool <NEW_LINE> nsSVGElement::IsEventName ( nsIAtom * aName ) <NEW_LINE> {
m2 [ i ] = Z_DVAL_PP ( tmp ) ; <NEW_LINE> break ; <NEW_LINE> case IS_STRING: <NEW_LINE> <START_VULN> convert_to_double_ex ( tmp ) ; <NEW_LINE>m2 [ i ] = Z_DVAL_PP ( tmp ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> default: <NEW_LINE> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Invalid type for element % i" , i ) ;
#include "chrome / browser / ui / browser_navigator_params . h" <NEW_LINE> #include "content / public / common / referrer . h" <NEW_LINE> <START_VULN> #include "third_party / blink / public / mojom / window_features / window_features . mojom . h" <NEW_LINE> <END_VULN> #include "ui / base / window_open_disposition . h" <NEW_LINE> #include "url / gurl . h" <NEW_LINE> #include "url / origin . h"
mp4 -> videolength = ( float ) ( ( double ) mp4 -> trak_clockcount / ( double ) mp4 -> trak_clockdemon ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <NEW_LINE> <END_VULN> NESTSIZE ( qtsize ) ; <NEW_LINE> }
class nsContentUtils <NEW_LINE> { <NEW_LINE> typedef mozilla::dom::Element Element ; <NEW_LINE> public: <NEW_LINE> static nsresult Init ( ) ; <NEW_LINE> <START_VULN> static nsresult GetContextAndScopes ( nsIDocument * aOldDocument , <NEW_LINE>nsIDocument * aNewDocument , <NEW_LINE>JSContext ** aCx , JSObject ** aOldScope , <NEW_LINE>JSObject ** aNewScope ) ; <NEW_LINE> <END_VULN> static nsresult ReparentContentWrappersInScope ( nsIScriptGlobalObject * aOldScope , <NEW_LINE> nsIScriptGlobalObject * aNewScope ) ;
* ( dp ++ ) = ( png_byte ) ( ( w >> 8 ) & 0xff ) ; <NEW_LINE> * ( dp ++ ) = ( png_byte ) ( w & 0xff ) ; <NEW_LINE> <START_VULN> if ( have_alpha ) <NEW_LINE> <END_VULN> { <NEW_LINE> * ( dp ++ ) = * ( sp ++ ) ; <NEW_LINE> * ( dp ++ ) = * ( sp ++ ) ;
memcpy ( curconn -> terminal_type , cpkt . data , act_size = ( cpkt . length > 30 - 1 ? 30 - 1 : cpkt . length ) ) ; <NEW_LINE> curconn -> terminal_type [ act_size ] = 0 ; <NEW_LINE> <START_VULN> } else if ( cpkt . cptype == MT_CPTYPE_PASSWORD ) { <NEW_LINE> <END_VULN> #if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) <NEW_LINE> mlock ( curconn -> trypassword , 17 ) ;
while ( buf < maxbuf ) { <NEW_LINE> const u_char * buf2 ; <NEW_LINE> depth ++ ; <NEW_LINE> <START_VULN> buf2 = smb_fdata ( ndo , buf , fmt , maxbuf , unicodestr ) ; <NEW_LINE> <END_VULN> depth -- ; <NEW_LINE> if ( buf2 == NULL ) <NEW_LINE> return ( NULL ) ;
else <NEW_LINE> { <NEW_LINE> vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> q += 16 ;
ProxyJNIEnv & proxyEnv = GetProxyEnv ( env ) ; <NEW_LINE> nsISecureEnv * secureEnv = GetSecureEnv ( env ) ; <NEW_LINE> nsISecurityContext * securityContext = proxyEnv . getContext ( ) ; <NEW_LINE> <START_VULN> nsresult result ; <NEW_LINE>result = secureEnv -> CallStaticMethod ( jvoid_type , clazz , method -> mMethodID , args , & unusedValue , securityContext ) ; <NEW_LINE> <END_VULN> NS_IF_RELEASE ( securityContext ) ; <NEW_LINE> }
UpdateListIndicesFromIndex ( animVal -> mItems , aIndex + 1 ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> DOMSVGNumberList::MaybeRemoveItemFromAnimValListAt ( PRUint32 aIndex ) <NEW_LINE> { <NEW_LINE> NS_ABORT_IF_FALSE ( ! IsAnimValList ( ) , "call from baseVal to animVal" ) ; <NEW_LINE> <START_VULN> DOMSVGNumberList * animVal = mAList -> mAnimVal ; <NEW_LINE> <END_VULN> if ( ! animVal || mAList -> IsAnimating ( ) ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> NS_ABORT_IF_FALSE ( animVal -> mItems . Length ( ) == mItems . Length ( ) , <NEW_LINE> "animVal list not in sync ! " ) ;
return CallQueryInterface ( val , aValue ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> #define COMPUTED_STYLE_MAP_ENTRY ( _prop , _method ) \ <NEW_LINE> <START_VULN> { eCSSProperty_##_prop , & nsComputedDOMStyle::Get##_method } <NEW_LINE> <END_VULN> const nsComputedDOMStyle::ComputedStyleMapEntry * <NEW_LINE> nsComputedDOMStyle::GetQueryablePropertyMap ( PRUint32 * aLength ) <NEW_LINE> { <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( appearance , Appearance ) ,
vp8_denoiser_free ( denoiser ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> vpx_memset ( denoiser -> yv12_running_avg [ i ] . buffer_alloc , 0 , <NEW_LINE>denoiser -> yv12_running_avg [ i ] . frame_size ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> denoiser -> yv12_mc_running_avg . flags = 0 ;
int CVE_2014_8541_ff_mjpeg_decode_sof ( MJpegDecodeContext * s ) <NEW_LINE> { <NEW_LINE> <START_VULN> int len , nb_components , i , width , height , pix_fmt_id , ret ; <NEW_LINE> <END_VULN> int h_count [ MAX_COMPONENTS ] ; <NEW_LINE> int v_count [ MAX_COMPONENTS ] ;
RUN_CALLBACK ( LIBRAW_PROGRESS_DARK_FRAME , 1 , 2 ) ; <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> <START_VULN> #line 10213 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> #ifndef NO_LCMS <NEW_LINE> void CLASS apply_profile ( const char * input , const char * output ) <NEW_LINE> {
PRUint32 resultLen = inputLen ; <NEW_LINE> <START_VULN> output . SetLength ( resultLen ) ; <NEW_LINE> <END_VULN> nsAString::iterator out_iter ; <NEW_LINE> output . BeginWriting ( out_iter ) ;
u4_nz_cols |= 1 << ( u4_pos & 0x7 ) ; <NEW_LINE> u4_nz_rows |= 1 << ( u4_pos >> 0x3 ) ; <NEW_LINE> <START_VULN> } <NEW_LINE>if ( u4_numCoeffs > 64 ) <NEW_LINE> { <NEW_LINE>return IMPEG2D_MB_TEX_DECODE_ERR ; <NEW_LINE> <END_VULN> } <NEW_LINE> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len )
if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { <NEW_LINE> <START_VULN> if ( ( tf = fopen ( tfile -> file_path , "w" ) ) ) { <NEW_LINE> <END_VULN> fprintf ( tf , " % d\n" , track_file_init_value ) ; <NEW_LINE> fclose ( tf ) ; <NEW_LINE> }
if ( doInterrupt ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> result = item -> UndoTransaction ( aTxMgr ) ; <NEW_LINE> if ( NS_SUCCEEDED ( result ) ) { <NEW_LINE> <START_VULN> result = mUndoStack -> Pop ( & item ) ; <NEW_LINE> <END_VULN> if ( NS_SUCCEEDED ( result ) ) { <NEW_LINE> result = mRedoStack -> Push ( item ) ; <NEW_LINE> }
#include "core / platform / PlatformMouseEvent . h" <NEW_LINE> #include "core / platform / Scrollbar . h" <NEW_LINE> #include "core / platform / graphics / GraphicsContext . h" <NEW_LINE> <START_VULN> #include "core / platform / win / SystemInfo . h" <NEW_LINE> <END_VULN> #include "platform / LayoutTestSupport . h" <NEW_LINE> #include "public / platform / Platform . h" <NEW_LINE> #include "public / platform / WebRect . h" <NEW_LINE> #include "public / platform / win / WebThemeEngine . h"
{ <NEW_LINE> ether_setup ( dev ) ; <NEW_LINE> <START_VULN> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <NEW_LINE> <END_VULN> dev -> netdev_ops = & macvlan_netdev_ops ; <NEW_LINE> dev -> destructor = free_netdev ; <NEW_LINE> dev -> header_ops = & macvlan_hard_header_ops ,
DevToolsAgentHostImpl * host ) ; <NEW_LINE> void Wire ( UberDispatcher * dispatcher ) override ; <NEW_LINE> <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) override ; <NEW_LINE> void TargetCrashed ( ) ;
if ( avctx -> height * istride == avpkt -> size ) { <NEW_LINE> <START_VULN> int linesize = ( avctx -> width * avctx -> bits_per_coded_sample + 7 ) / 8 ; <NEW_LINE> <END_VULN> uint8_t * ptr = s -> frame -> data [ 0 ] ; <NEW_LINE> uint8_t * buf = avpkt -> data + ( avctx -> height - 1 ) * istride ; <NEW_LINE> int i , j ;
if ( new_palette . entries == NULL ) <NEW_LINE> { <NEW_LINE> <START_VULN> png_warning ( png_ptr , "sPLT chunk requires too much memory" ) ; <NEW_LINE>return ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef PNG_POINTER_INDEXING_SUPPORTED
continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ptrace ( PTRACE_ATTACH , tid , 0 , 0 ) < 0 ) { <NEW_LINE> <END_VULN> ALOGE ( "debuggerd: ptrace attach to % d failed: % s" , tid , strerror ( errno ) ) ; <NEW_LINE> continue ; <NEW_LINE> }
<START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> bool IsNested ( ) const ; <NEW_LINE> private: <NEW_LINE> friend class Delegate ;
clusters [ i ] = cluster_list_ [ i ] ; <NEW_LINE> } <NEW_LINE> <START_VULN> delete [ ] cluster_list_ ; <NEW_LINE> <END_VULN> cluster_list_ = clusters ; <NEW_LINE> cluster_list_capacity_ = new_capacity ;
JSObject * obj = rt -> gcWeakMapList ; <NEW_LINE> while ( obj ) { <NEW_LINE> WeakMap * table = fromJSObject ( obj ) ; <NEW_LINE> <START_VULN> for ( js::HashMap < JSObject * , Value > ::Enum e ( table -> map ) ; ! e . empty ( ) ; e . popFront ( ) ) { <NEW_LINE> <END_VULN> if ( IsAboutToBeFinalized ( cx , e . front ( ) . key ) ) <NEW_LINE> e . removeFront ( ) ; <NEW_LINE> }
return false ; <NEW_LINE> HeapObjectHeader * header = HeapObjectHeader::fromPayload ( address ) ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> NormalPageArena * arena = static_cast < NormalPage * > ( page ) -> arenaForNormalPage ( ) ; <NEW_LINE> bool succeed = arena -> expandObject ( header , newSize ) ; <NEW_LINE> if ( succeed )
<START_VULN> #ifndef BASE_EVENT_TYPES_H <NEW_LINE>#define BASE_EVENT_TYPES_H <NEW_LINE> <END_VULN> #include "build / build_config . h"
modification_reset ( d . pm -> modifications ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> pp = set_modifier_for_read ( d . pm , & pi , d . this . id , name ) ; <NEW_LINE> standard_palette_init ( & d . this ) ;
#define DTK_DATE_M ( DTK_M ( YEAR ) | DTK_M ( MONTH ) | DTK_M ( DAY ) ) <NEW_LINE> #define DTK_TIME_M ( DTK_M ( HOUR ) | DTK_M ( MINUTE ) | DTK_ALL_SECS_M ) <NEW_LINE> <START_VULN> #define MAXDATELEN 63 <NEW_LINE>#define MAXDATEFIELDS 25 <NEW_LINE>#define TOKMAXLEN 10 <NEW_LINE> <END_VULN> typedef struct
void Revoke ( ) { <NEW_LINE> if ( mPresShell ) { <NEW_LINE> mPresShell -> GetPresContext ( ) -> RefreshDriver ( ) -> <NEW_LINE> RemoveRefreshObserver ( this , Flush_Display ) ; <NEW_LINE> mPresShell = nullptr ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> virtual void WillRefresh ( mozilla::TimeStamp aTime ) MOZ_OVERRIDE { <NEW_LINE> <START_VULN> if ( mPresShell ) <NEW_LINE>mPresShell -> ProcessSynthMouseMoveEvent ( mFromScroll ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> private: <NEW_LINE> PresShell * mPresShell ; <NEW_LINE> bool mFromScroll ; <NEW_LINE> } ; <NEW_LINE> void ProcessSynthMouseMoveEvent ( bool aFromScroll ) ; <NEW_LINE> void QueryIsActive ( ) ;
png_inforp info_ptr ) , PNG_EMPTY ) ; <NEW_LINE> # endif <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_GAMMA_SUPPORTED
if ( ! op && ! adv ) return ( 1 ) ; <NEW_LINE> { <NEW_LINE> int size = os -> lacing_vals [ ptr ] & 0xff ; <NEW_LINE> <START_VULN> int bytes = size ; <NEW_LINE> <END_VULN> int eos = os -> lacing_vals [ ptr ] & 0x200 ; <NEW_LINE> int bos = os -> lacing_vals [ ptr ] & 0x100 ; <NEW_LINE> while ( size == 255 ) { <NEW_LINE> int val = os -> lacing_vals [ ++ ptr ] ; <NEW_LINE> size = val & 0xff ; <NEW_LINE> if ( val & 0x200 ) eos = 0x200 ; <NEW_LINE> bytes += size ;
{ <NEW_LINE> png_debug1 ( 1 , "in % s retrieval function" , "hIST" ) ; <NEW_LINE> <START_VULN> if ( png_ptr != NULL && info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_hIST ) <NEW_LINE> && hist != NULL ) <NEW_LINE> <END_VULN> { <NEW_LINE> * hist = info_ptr -> hist ; <NEW_LINE> return ( PNG_INFO_hIST ) ;
obj_sz = 0 ; <NEW_LINE> total_sz = 0 ; <NEW_LINE> n_blks = 1 ; <NEW_LINE> <START_VULN> data = malloc ( blk_sz * n_blks ) ; <NEW_LINE>memset ( data , 0 , blk_sz * n_blks ) ; <NEW_LINE> <END_VULN> stream = 0 ;
} <NEW_LINE> while ( -- count > 0 ) ; <NEW_LINE> <START_VULN> printf ( " % d tests including % d overflows , % d passed , % d failed ( % d 64 bit " <NEW_LINE> <END_VULN> "errors ) \n" , tested , overflow , passed , error , error64 ) ; <NEW_LINE> return 0 ; <NEW_LINE> }
#include "third_party / blink / public / mojom / devtools / console_message . mojom . h" <NEW_LINE> #include "third_party / blink / public / mojom / permissions / permission_status . mojom . h" <NEW_LINE> #include "third_party / blink / public / mojom / renderer_preferences . mojom . h" <NEW_LINE> <START_VULN> #include "third_party / blink / public / mojom / window_features / window_features . mojom . h" <NEW_LINE> <END_VULN> #include "third_party / blink / public / platform / web_drag_operation . h" <NEW_LINE> #include "third_party / blink / public / platform / web_history_scroll_restoration_type . h" <NEW_LINE> #include "third_party / blink / public / platform / web_point . h" <NEW_LINE> #include "third_party / blink / public / platform / web_rect . h" <NEW_LINE> #include "third_party / blink / public / platform / web_security_style . h" <NEW_LINE> #include "third_party / blink / public / platform / web_url_request . h" <NEW_LINE> #include "ui / accessibility / ax_event . h" <NEW_LINE> #include "ui / accessibility / ax_node_data . h" <NEW_LINE> #include "ui / accessibility / ax_relative_bounds . h"
{ <NEW_LINE> char * filein , * str , * tempfile , * prestring , * outprotos , * protostr ; <NEW_LINE> const char * spacestr = " " ; <NEW_LINE> <START_VULN> char buf [ L_BUF_SIZE ] ; <NEW_LINE> <END_VULN> l_uint8 * allheaders ; <NEW_LINE> l_int32 i , maxindex , in_line , nflags , protos_added , firstfile , len , ret ; <NEW_LINE> size_t nbytes ;
proto ) ; \ <NEW_LINE> } \ <NEW_LINE> JS_FRIEND_API ( JSBool ) JS_Is ## Name ## Array ( JSObject * obj ) \ <NEW_LINE> { \ <NEW_LINE> if ( ! ( obj = CheckedUnwrap ( obj ) ) ) \ <NEW_LINE> return false ; \ <NEW_LINE> Class * clasp = obj -> getClass ( ) ; \ <NEW_LINE> return ( clasp == & TypedArray::classes [ TypedArrayTemplate < NativeType > ::ArrayTypeID ( ) ] ) ; \ <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Int8 , int8_t ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Uint8 , uint8_t ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Uint8Clamped , uint8_clamped ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Int16 , int16_t ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Uint16 , uint16_t ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Int32 , int32_t ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Uint32 , uint32_t )
void ResolveWithNothing ( ScriptPromiseResolver * ) ; <NEW_LINE> void ResolveWithPhotoSettings ( ScriptPromiseResolver * ) ; <NEW_LINE> void ResolveWithPhotoCapabilities ( ScriptPromiseResolver * ) ; <NEW_LINE> <START_VULN> void ResolveWithMediaTrackConstraints ( MediaTrackConstraints , <NEW_LINE> <END_VULN> ScriptPromiseResolver * ) ; <NEW_LINE> Member < MediaStreamTrack > stream_track_ ;
{ <NEW_LINE> zend_object_handle handle = Z_OBJ_HANDLE_P ( zobject ) ; <NEW_LINE> zend_object_store_bucket * obj_bucket = & EG ( objects_store ) . object_buckets [ handle ] ; <NEW_LINE> <START_VULN> <NEW_LINE>obj_bucket -> bucket . obj . handlers = Z_OBJ_HT_P ( zobject ) ; ; <NEW_LINE> <END_VULN> obj_bucket -> destructor_called = 1 ; <NEW_LINE> }
pn3 = pn2 -> pn_left ; <NEW_LINE> type = PN_TYPE ( pn3 ) ; <NEW_LINE> cg -> flags |= TCF_IN_FOR_INIT ; <NEW_LINE> if ( TokenKindIsDecl ( type ) && ! js_EmitTree ( cx , cg , pn3 ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> cg -> flags &= ~ TCF_IN_FOR_INIT ; <NEW_LINE> <START_VULN> if ( ! js_EmitTree ( cx , cg , pn2 -> pn_right ) ) <NEW_LINE>return JS_FALSE ; <NEW_LINE> <END_VULN> JS_ASSERT ( pn -> pn_op == JSOP_ITER ) ; <NEW_LINE> if ( js_Emit2 ( cx , cg , JSOP_ITER , ( uint8 ) pn -> pn_iflags ) < 0 )
RANGE_CHECK_HI ( cfg , g_threads , 64 ) ; <NEW_LINE> RANGE_CHECK_HI ( cfg , g_lag_in_frames , MAX_LAG_BUFFERS ) ; <NEW_LINE> RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ; <NEW_LINE> <START_VULN> RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; <NEW_LINE>RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; <NEW_LINE> <END_VULN> RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ; <NEW_LINE> RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ; <NEW_LINE> RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ;
{ <NEW_LINE> png_color_8p sig_bit ; <NEW_LINE> <START_VULN> if ( png_get_sBIT ( read_ptr , read_info_ptr , & sig_bit ) ) <NEW_LINE> <END_VULN> png_set_sBIT ( write_ptr , write_info_ptr , sig_bit ) ; <NEW_LINE> } <NEW_LINE> #endif
clone_info = CloneDrawInfo ( ( ImageInfo * ) NULL , draw_info ) ; <NEW_LINE> clone_info -> stroke_width = 0 . 0 ; <NEW_LINE> <START_VULN> clone_info -> stroke . alpha = ( Quantum ) TransparentAlpha ; <NEW_LINE> <END_VULN> status &= DrawPolygonPrimitive ( image , clone_info , primitive_info , <NEW_LINE> exception ) ; <NEW_LINE> clone_info = DestroyDrawInfo ( clone_info ) ;
mWriteRequested = false ; <NEW_LINE> mWriteHeader = frame -> header ; <NEW_LINE> <START_VULN> mWriteBuffer = buffer ; <NEW_LINE> <END_VULN> mWriteCompleted = true ; <NEW_LINE> return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ; <NEW_LINE> } else {
if ( sad_array [ t ] < bestsad ) { <NEW_LINE> const MV this_mv = { best_mv -> row + ss [ i ] . mv . row , <NEW_LINE> best_mv -> col + ss [ i ] . mv . col } ; <NEW_LINE> <START_VULN> sad_array [ t ] += mvsad_err_cost ( & this_mv , & fcenter_mv , <NEW_LINE>mvjsadcost , mvsadcost , sad_per_bit ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( sad_array [ t ] < bestsad ) { <NEW_LINE> bestsad = sad_array [ t ] ; <NEW_LINE> best_site = i ;
void mdct_init ( mdct_lookup * lookup , int n ) { <NEW_LINE> int * bitrev = _ogg_malloc ( sizeof ( * bitrev ) * ( n / 4 ) ) ; <NEW_LINE> DATA_TYPE * T = _ogg_malloc ( sizeof ( * T ) * ( n + n / 4 ) ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> int i ; <NEW_LINE> int n2 = n >> 1 ; <NEW_LINE> int log2n = lookup -> log2n = rint ( log ( ( float ) n ) / log ( 2 . f ) ) ; <NEW_LINE> lookup -> n = n ; <NEW_LINE> lookup -> trig = T ; <NEW_LINE> lookup -> bitrev = bitrev ;
if ( frameLoader -> shouldInterruptLoadForXFrameOptions ( content , url ( ) , requestIdentifier ) ) { <NEW_LINE> String message = "Refused to display '" + url ( ) . elidedString ( ) + "' in a frame because it set 'X - Frame - Options' to '" + content + "' . " ; <NEW_LINE> frameLoader -> stopAllLoaders ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>frame -> navigationScheduler ( ) -> scheduleLocationChange ( securityOrigin ( ) , "data:text / html , < p > < / p > " , String ( ) ) ; <NEW_LINE> <END_VULN> addConsoleMessage ( SecurityMessageSource , ErrorMessageLevel , message , requestIdentifier ) ; <NEW_LINE> } <NEW_LINE> }
if ( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA ) <NEW_LINE> { <NEW_LINE> <START_VULN> * flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED ; <NEW_LINE>return ( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( mbedtls_x509_time_is_past ( & child -> valid_to ) )
f -> r -> server -> limit_req_fieldsize ) ; <NEW_LINE> } <NEW_LINE> if ( rv != APR_SUCCESS ) { <NEW_LINE> <START_VULN> ap_log_rerror ( <NEW_LINE>APLOG_MARK , APLOG_INFO , rv , f -> r , APLOGNO ( 01590 ) "Error reading chunk % s " , ( APR_ENOSPC == rv ) ? " ( overflow ) " : "" ) ; <NEW_LINE> <END_VULN> return rv ; <NEW_LINE> } <NEW_LINE> }
nsIContentSink ) <NEW_LINE> NS_INTERFACE_TABLE_TAIL_INHERITING ( nsContentSink ) <NEW_LINE> NS_IMPL_ADDREF_INHERITED ( nsHtml5TreeOpExecutor , nsContentSink ) <NEW_LINE> NS_IMPL_RELEASE_INHERITED ( nsHtml5TreeOpExecutor , nsContentSink ) <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED ( nsHtml5TreeOpExecutor , nsContentSink ) <NEW_LINE> <START_VULN> NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY ( mOwnedElements ) <NEW_LINE> <END_VULN> NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED ( nsHtml5TreeOpExecutor , nsContentSink ) <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY ( mOwnedElements ) <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_UNLINK_END <NEW_LINE> class nsHtml5ExecutorReflusher : public nsRunnable <NEW_LINE> {
|| s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma <NEW_LINE> || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc <NEW_LINE> || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> s -> mb_width = h -> sps . mb_width ; <NEW_LINE> s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ;
} <NEW_LINE> * rval = STRING_TO_JSVAL ( str ) ; <NEW_LINE> return JS_TRUE ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> - <NEW_LINE> <END_VULN> 1 . 4 . 1
char * & dst = * dst_ptr ; <NEW_LINE> <START_VULN> delete [ ] dst ; <NEW_LINE> <END_VULN> dst = NULL ; <NEW_LINE> if ( src == NULL )
#define BASE_PROCESS_PROCESS_H_ <NEW_LINE> #include "base / base_export . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "base / process / process_handle . h" <NEW_LINE> #include "base / time / time . h" <NEW_LINE> #include "build / build_config . h"
size = ( sizeof ( macroblockLayer_t ) + 63 ) & ~ 0x3F ; <NEW_LINE> <START_VULN> pStorage -> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size ) ; <NEW_LINE> <END_VULN> if ( ! pStorage -> mbLayer ) <NEW_LINE> return HANTRO_NOK ;
} <NEW_LINE> const ContentEncoding::ContentCompression * <NEW_LINE> <START_VULN> ContentEncoding::GetCompressionByIndex ( unsigned long idx ) const { <NEW_LINE> <END_VULN> const ptrdiff_t count = compression_entries_end_ - compression_entries_ ; <NEW_LINE> assert ( count >= 0 ) ;
SECStatus rv ; <NEW_LINE> SSL3WaitState ws = ss -> ssl3 . hs . ws ; <NEW_LINE> SSL_TRC ( 3 , ( " % d: SSL3 [ % d ] : handle server_hello_done handshake" , <NEW_LINE> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> if ( ws != wait_hello_done && <NEW_LINE> <START_VULN> ws != wait_server_cert && <NEW_LINE>ws != wait_server_key && <NEW_LINE> <END_VULN> ws != wait_cert_request ) { <NEW_LINE> SSL3_SendAlert ( ss , alert_fatal , unexpected_message ) ; <NEW_LINE> PORT_SetError ( SSL_ERROR_RX_UNEXPECTED_HELLO_DONE ) ; <NEW_LINE> return SECFailure ; <NEW_LINE> } <NEW_LINE> rv = ssl3_SendClientSecondRound ( ss ) ;
<START_VULN> ResourceRequestInfoImpl * CreateRequestInfo ( <NEW_LINE>int child_id , <NEW_LINE>int render_view_route_id , <NEW_LINE>int render_frame_route_id , <NEW_LINE>PreviewsState previews_state , <NEW_LINE>bool download , <NEW_LINE>ResourceContext * context ) ; <NEW_LINE> <END_VULN> enum HttpAuthRelationType {
#endif <NEW_LINE> nbytes = * lengthp ; <NEW_LINE> <START_VULN> if ( js_CStringsAreUTF8 || useCESU8 ) { <NEW_LINE>if ( ! js_InflateUTF8StringToBuffer ( cx , bytes , nbytes , NULL , & nchars , <NEW_LINE>useCESU8 ) ) <NEW_LINE> <END_VULN> goto bad ; <NEW_LINE> chars = ( jschar * ) cx -> malloc_ ( ( nchars + 1 ) * sizeof ( jschar ) ) ; <NEW_LINE> if ( ! chars )
} <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> outerpc -> blockidGen = funpc . blockidGen ; <NEW_LINE> parser -> tokenStream . tell ( & position ) ; <NEW_LINE> <START_VULN> tokenStream . seek ( position , parser -> tokenStream ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> pn -> pn_funbox = funbox ; <NEW_LINE> if ( ! addFreeVariablesFromLazyFunction ( fun , pc ) ) <NEW_LINE> return false ; <NEW_LINE> pn -> pn_blockid = outerpc -> blockid ( ) ;
return false ; <NEW_LINE> JSObject * wrapperProto = JS_GetPrototype ( wrapper ) ; <NEW_LINE> if ( ! vp -> isUndefined ( ) || ! wrapperProto ) <NEW_LINE> return true ; <NEW_LINE> <START_VULN> JSAutoEnterCompartment ac ; <NEW_LINE>if ( ! ac . enter ( cx , wrapper ) ) <NEW_LINE>return false ; <NEW_LINE> <END_VULN> return js::GetGeneric ( cx , wrapperProto , receiver , id , vp ) ; <NEW_LINE> } <NEW_LINE> }
( 17 - 126 * mul + 273 * mul2 - 164 * mul3 ) / 12096 , <NEW_LINE> } ; <NEW_LINE> <START_VULN> double mat_freq [ 13 ] ; <NEW_LINE> <END_VULN> memcpy ( mat_freq , kernel , sizeof ( kernel ) ) ; <NEW_LINE> memset ( mat_freq + 4 , 0 , sizeof ( mat_freq ) - sizeof ( kernel ) ) ; <NEW_LINE> int n = 6 ;
struct State { <NEW_LINE> <START_VULN> scoped_refptr < const TransformPaintPropertyNode > local_transform_space ; <NEW_LINE> <END_VULN> FloatRoundedRect clip_rect ; <NEW_LINE> base::Optional < FloatRoundedRect > clip_rect_excluding_overlay_scrollbars ; <NEW_LINE> scoped_refptr < const RefCountedPath > clip_path ;
png_read_data ( png_ptr , crc_bytes , 4 ) ; <NEW_LINE> <START_VULN> if ( need_crc ) <NEW_LINE> <END_VULN> { <NEW_LINE> crc = png_get_uint_32 ( crc_bytes ) ; <NEW_LINE> return ( ( int ) ( crc != png_ptr -> crc ) ) ;
int thick = im -> thick ; <NEW_LINE> if ( color == gdAntiAliased ) { <NEW_LINE> <START_VULN> <NEW_LINE>gdImageAALine ( im , x1 , y1 , x2 , y2 , im -> AA_color ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
stat = yajl_parse_complete ( hand ) ; <NEW_LINE> if ( stat != yajl_status_ok && <NEW_LINE> <START_VULN> stat != yajl_status_insufficient_data ) <NEW_LINE> <END_VULN> { <NEW_LINE> unsigned char * str = yajl_get_error ( hand , 1 , data , dataSize ) ; <NEW_LINE> fprintf ( stderr , ( const char * ) str ) ;
void OnDestroy ( ) ; <NEW_LINE> <START_VULN> void OnTexturesCreated ( std::vector < int > textures ) ; <NEW_LINE> <END_VULN> GpuChannel * channel_ ; <NEW_LINE> IPC::Message::Sender * sender_ ;
NS_ENSURE_TRUE ( handler , NS_ERROR_FAILURE ) ; <NEW_LINE> } <NEW_LINE> if ( handler ) { <NEW_LINE> JS::Rooted < JSObject * > boundHandler ( cx ) ; <NEW_LINE> JS::Rooted < JSObject * > scope ( cx , listener -> GetEventScope ( ) ) ; <NEW_LINE> context -> BindCompiledEventHandler ( mTarget , scope , handler , & boundHandler ) ; <NEW_LINE> <START_VULN> if ( listener -> EventName ( ) == nsGkAtoms::onerror && win ) { <NEW_LINE> <END_VULN> nsRefPtr < OnErrorEventHandlerNonNull > handlerCallback = <NEW_LINE> new OnErrorEventHandlerNonNull ( boundHandler ) ; <NEW_LINE> listener -> SetHandler ( handlerCallback ) ; <NEW_LINE> } else if ( listener -> EventName ( ) == nsGkAtoms::onbeforeunload && win ) { <NEW_LINE> nsRefPtr < BeforeUnloadEventHandlerNonNull > handlerCallback = <NEW_LINE> new BeforeUnloadEventHandlerNonNull ( boundHandler ) ; <NEW_LINE> listener -> SetHandler ( handlerCallback ) ; <NEW_LINE> } else {
lnet_notify_locked ( lp , ! ni , alive , when ) ; <NEW_LINE> <START_VULN> lnet_ni_notify_locked ( ni , lp ) ; <NEW_LINE> <END_VULN> lnet_peer_decref_locked ( lp ) ;
#include "base / synchronization / lock . h" <NEW_LINE> #include "base / threading / thread_checker . h" <NEW_LINE> #include "components / scheduler / child / task_queue_selector . h" <NEW_LINE> <START_VULN> #include "components / scheduler / child / time_source . h" <NEW_LINE> <END_VULN> #include "components / scheduler / scheduler_export . h" <NEW_LINE> namespace base { <NEW_LINE> namespace trace_event { <NEW_LINE> class ConvertableToTraceFormat ; <NEW_LINE> class TracedValue ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> namespace scheduler {
int vp9_get_pred_context_single_ref_p1 ( const MACROBLOCKD * xd ) { <NEW_LINE> int pred_context ; <NEW_LINE> <START_VULN> const MB_MODE_INFO * const above_mbmi = get_mbmi ( get_above_mi ( xd ) ) ; <NEW_LINE>const MB_MODE_INFO * const left_mbmi = get_mbmi ( get_left_mi ( xd ) ) ; <NEW_LINE>const int has_above = above_mbmi != NULL ; <NEW_LINE>const int has_left = left_mbmi != NULL ; <NEW_LINE> <END_VULN>
if ( totalLogicalHeight < pageLogicalHeightAtNewOffset ) <NEW_LINE> wantsStrutOnBlock = true ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( ! wantsStrutOnBlock || block . isOutOfFlowPositioned ( ) ) <NEW_LINE>return false ; <NEW_LINE>LayoutBlock * containingBlock = block . containingBlock ( ) ; <NEW_LINE>return containingBlock && containingBlock -> isLayoutBlockFlow ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void LayoutBlockFlow::adjustLinePositionForPagination ( RootInlineBox & lineBox , LayoutUnit & delta )
* <NEW_LINE> <START_VULN> if ( ssl3_ExtensionNegotiated ( ss , ssl_session_ticket_xtn ) && sid == NULL ) { <NEW_LINE> <END_VULN> ssl3_RegisterServerHelloExtensionSender ( ss , <NEW_LINE> ssl_session_ticket_xtn , ssl3_SendSessionTicketXtn ) ; <NEW_LINE> } <NEW_LINE> if ( sid != NULL ) { <NEW_LINE> rv = ssl3_InitPendingCipherSpec ( ss , NULL ) ; <NEW_LINE> if ( rv != SECSuccess ) {
if ( min != max ) { <NEW_LINE> if ( min != 0 ) { <NEW_LINE> masm . add32 ( Imm32 ( min ) , temp ) ; <NEW_LINE> if ( ! bailoutIf ( Assembler::Overflow , lir -> snapshot ( ) ) ) <NEW_LINE> return false ; <NEW_LINE> int32_t diff ; <NEW_LINE> if ( SafeSub ( max , min , & diff ) ) <NEW_LINE> max = diff ; <NEW_LINE> else <NEW_LINE> masm . sub32 ( Imm32 ( min ) , temp ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>masm . cmp32 ( temp , Imm32 ( 0 ) ) ; <NEW_LINE>if ( ! bailoutIf ( Assembler::LessThan , lir -> snapshot ( ) ) ) <NEW_LINE>return false ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( max != 0 ) {
if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { <NEW_LINE> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , <NEW_LINE> tmp ) { <NEW_LINE> if ( request -> ssids [ i ] . ssid_len > <NEW_LINE> IEEE80211_MAX_SSID_LEN ) { <NEW_LINE> err = - EINVAL ; <NEW_LINE> goto out_free ; <NEW_LINE> } <NEW_LINE> memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , <NEW_LINE> nla_len ( attr ) ) ; <NEW_LINE> <START_VULN> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <NEW_LINE> <END_VULN> i ++ ; <NEW_LINE> } <NEW_LINE> }
} <NEW_LINE> static inline JSBool <NEW_LINE> CallWithoutStatics ( JSContext * cx , JSObject * obj , jsval fval , uintN argc , <NEW_LINE> jsval * argv , jsval * rval ) <NEW_LINE> { <NEW_LINE> JSRegExpStatics statics ; <NEW_LINE> JSTempValueRooter tvr ; <NEW_LINE> <START_VULN> js_SaveRegExpStatics ( cx , & statics , & tvr ) ; <NEW_LINE>JS_ClearRegExpStatics ( cx ) ; <NEW_LINE> <END_VULN> JSStackFrame * fp = JS_SaveFrameChain ( cx ) ; <NEW_LINE> uint32 options = <NEW_LINE> JS_SetOptions ( cx , JS_GetOptions ( cx ) | JSOPTION_DONT_REPORT_UNCAUGHT ) ; <NEW_LINE> JSBool ok = ::JS_CallFunctionValue ( cx , obj , fval , argc , argv , rval ) ; <NEW_LINE> JS_SetOptions ( cx , options ) ; <NEW_LINE> JS_RestoreFrameChain ( cx , fp ) ; <NEW_LINE> js_RestoreRegExpStatics ( cx , & statics , & tvr ) ; <NEW_LINE> return ok ;
#ifndef UserMediaClientImpl_h <NEW_LINE> #define UserMediaClientImpl_h <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "modules / mediastream / UserMediaClient . h" <NEW_LINE> #include "wtf / PassRefPtr . h" <NEW_LINE> namespace WebCore {
jsuint newlen ; <NEW_LINE> JSObject * newarr ; <NEW_LINE> #ifdef __GNUC__ <NEW_LINE> newlen = 0 ; <NEW_LINE> newarr = NULL ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> jsint start = 0 , end = length , step = 1 ; <NEW_LINE> <END_VULN> switch ( mode ) { <NEW_LINE> case REDUCE_RIGHT: <NEW_LINE> start = length - 1 , end = - 1 , step = - 1 ; <NEW_LINE> case REDUCE: <NEW_LINE> if ( length == 0 && argc == 1 ) { <NEW_LINE> JS_ReportErrorNumber ( cx , js_GetErrorMessage , NULL ,
GC_PLUGIN_IGNORE ( "http: <NEW_LINE> Persistent < Element > m_keepAlive ; <NEW_LINE> <START_VULN> Timer < ImageLoader > m_derefElementTimer ; <NEW_LINE> <END_VULN> AtomicString m_failedLoadURL ; <NEW_LINE> WeakPtr < Task > m_pendingTask ; <NEW_LINE> std::unique_ptr < IncrementLoadEventDelayCount > m_loadDelayCounter ;
perf_event_header__init_id ( & throttle_event . header , & sample , event ) ; <NEW_LINE> ret = perf_output_begin ( & handle , event , <NEW_LINE> <START_VULN> throttle_event . header . size , 1 , 0 ) ; <NEW_LINE> <END_VULN> if ( ret ) <NEW_LINE> return ;
EXT4_FREE_BLOCKS_FORGET ) ; <NEW_LINE> } else { <NEW_LINE> le32_add_cpu ( & BHDR ( bh ) -> h_refcount , - 1 ) ; <NEW_LINE> <START_VULN> if ( ce ) <NEW_LINE>mb_cache_entry_release ( ce ) ; <NEW_LINE> <END_VULN> ea_bdebug ( bs -> bh , "modifying in - place" ) ; <NEW_LINE> error = ext4_xattr_set_entry ( i , s ) ; <NEW_LINE> if ( ! error ) {
vorbis_info * vi = v -> vi ; <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> int hs = ci -> halfrate_flag ; <NEW_LINE> private_state * b = v -> backend_state ; <NEW_LINE> if ( b -> window [ W ] - 1 < 0 ) return NULL ; <NEW_LINE> return _vorbis_window_get ( b -> window [ W ] - hs ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
break ; <NEW_LINE> } <NEW_LINE> <START_VULN> vpx_memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ; <NEW_LINE> <END_VULN> old_boost_score = boost_score ; <NEW_LINE> }
sz = pdf -> xrefs [ i ] . end - ftell ( fp ) ; <NEW_LINE> <START_VULN> buf = malloc ( sz + 1 ) ; <NEW_LINE> <END_VULN> SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , "Failed to load / Root . \n" ) ; <NEW_LINE> buf [ sz ] = '\0' ; <NEW_LINE> if ( ! ( c = strstr ( buf , " / Root" ) ) )
y_zbin [ QINDEX_RANGE ] [ 8 ] ) ; <NEW_LINE> DECLARE_ALIGNED ( 16 , int16_t , y_round [ QINDEX_RANGE ] [ 8 ] ) ; <NEW_LINE> DECLARE_ALIGNED ( 16 , int16_t , uv_quant [ QINDEX_RANGE ] [ 8 ] ) ; <NEW_LINE> DECLARE_ALIGNED ( 16 , int16_t , uv_quant_shift [ QINDEX_RANGE ] [ 8 ] ) ; <NEW_LINE> DECLARE_ALIGNED ( 16 , int16_t , uv_zbin [ QINDEX_RANGE ] [ 8 ] ) ; <NEW_LINE> DECLARE_ALIGNED ( 16 , int16_t , uv_round [ QINDEX_RANGE ] [ 8 ] ) ; <NEW_LINE> <START_VULN> <NEW_LINE>#if CONFIG_ALPHA <NEW_LINE>DECLARE_ALIGNED ( 16 , int16_t , a_quant [ QINDEX_RANGE ] [ 8 ] ) ; <NEW_LINE>DECLARE_ALIGNED ( 16 , int16_t , a_quant_shift [ QINDEX_RANGE ] [ 8 ] ) ; <NEW_LINE>DECLARE_ALIGNED ( 16 , int16_t , a_zbin [ QINDEX_RANGE ] [ 8 ] ) ; <NEW_LINE>DECLARE_ALIGNED ( 16 , int16_t , a_round [ QINDEX_RANGE ] [ 8 ] ) ; <NEW_LINE>#endif <NEW_LINE> <END_VULN> } QUANTS ; <NEW_LINE> void vp9_regular_quantize_b_4x4 ( MACROBLOCK * x , int plane , int block ,
return - EINVAL ; <NEW_LINE> dout ( "ceph_x_decrypt len % d\n" , len ) ; <NEW_LINE> <START_VULN> ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen , <NEW_LINE> * p , len ) ; <NEW_LINE> <END_VULN> if ( ret ) <NEW_LINE> return ret ; <NEW_LINE> if ( head . struct_v != 1 || le64_to_cpu ( head . magic ) != CEPHX_ENC_MAGIC )
<START_VULN> test_pixel . have_tRNS = dp -> this . is_transparent ; <NEW_LINE> <END_VULN> test_pixel . red_sBIT = test_pixel . green_sBIT = test_pixel . blue_sBIT = <NEW_LINE> test_pixel . alpha_sBIT = test_pixel . sample_depth ;
void vp9_disable_segmentation ( struct segmentation * seg ) { <NEW_LINE> seg -> enabled = 0 ; <NEW_LINE> <START_VULN> } <NEW_LINE><NEW_LINE>void vp9_set_segmentation_map ( VP9_COMP * cpi , unsigned char * segmentation_map ) { <NEW_LINE>struct segmentation * const seg = & cpi -> common . seg ; <NEW_LINE><NEW_LINE><NEW_LINE>vpx_memcpy ( cpi -> segmentation_map , segmentation_map , <NEW_LINE> ( cpi -> common . mi_rows * cpi -> common . mi_cols ) ) ; <NEW_LINE><NEW_LINE><NEW_LINE>seg -> update_map = 1 ; <NEW_LINE>seg -> update_data = 1 ; <NEW_LINE> <END_VULN> } <NEW_LINE> void vp9_set_segment_data ( struct segmentation * seg ,
scoped_refptr < PermissionSet > UnpackPermissionSet ( <NEW_LINE> <START_VULN> const api::permissions::Permissions & permissions , std::string * error ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
if ( context -> hasStrictOption ( ) && <NEW_LINE> ( ~ tc -> flags & ( TCF_RETURN_EXPR | TCF_RETURN_VOID ) ) == 0 && <NEW_LINE> <START_VULN> ! ReportBadReturn ( context , tc , JSREPORT_WARNING | JSREPORT_STRICT , <NEW_LINE> <END_VULN> JSMSG_NO_RETURN_VALUE , <NEW_LINE> JSMSG_ANON_NO_RETURN_VALUE ) ) { <NEW_LINE> return NULL ;
mInScopeVariables . RemoveElementAt ( i ) ; <NEW_LINE> delete var ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> const txElementHandler * handler = <NEW_LINE> const_cast < const txElementHandler * > <NEW_LINE> <START_VULN> ( static_cast < txElementHandler * > ( popPtr ( ) ) ) ; <NEW_LINE> <END_VULN> rv = ( handler -> mEndFunction ) ( * this ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> if ( ! -- mElementContext -> mDepth ) { <NEW_LINE> mElementContext = static_cast < txElementContext * > ( popObject ( ) ) ; <NEW_LINE> }
RefPtr < DrawingBuffer > drawing_buffer = AdoptRef ( new DrawingBuffer ( <NEW_LINE> std::move ( context_provider ) , std::move ( extensions_util ) , client , <NEW_LINE> discard_framebuffer_supported , want_alpha_channel , premultiplied_alpha , <NEW_LINE> <START_VULN> preserve , web_gl_version , want_depth_buffer , want_stencil_buffer , <NEW_LINE> <END_VULN> chromium_image_usage , color_params ) ) ; <NEW_LINE> if ( ! drawing_buffer -> Initialize ( size , multisample_supported ) ) { <NEW_LINE> drawing_buffer -> BeginDestruction ( ) ;
png_ptr -> save_buffer_ptr += save_size ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( png_ptr -> idat_size && png_ptr -> current_buffer_size ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_size_t save_size = png_ptr -> current_buffer_size ; <NEW_LINE> png_uint_32 idat_size = png_ptr -> idat_size ;
\ ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** / <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < stdlib . h > <NEW_LINE> #include < math . h > <NEW_LINE> <START_VULN> #include < jasper / jas_config . h > <NEW_LINE> <END_VULN> #include < jasper / jas_types . h > <NEW_LINE> #include < jasper / jas_debug . h >
if ( mQueryProcessor ) <NEW_LINE> mQueryProcessor -> Done ( ) ; <NEW_LINE> mDataSource = nsnull ; <NEW_LINE> mDB = nsnull ; <NEW_LINE> mCompDB = nsnull ; <NEW_LINE> mRoot = nsnull ; <NEW_LINE> <START_VULN> Uninit ( PR_TRUE ) ; <NEW_LINE> <END_VULN> }
DEBUG_PRINT_LOW ( "free_buffer on i / p port - Port idx % u , actual cnt % u" , <NEW_LINE> nPortIndex , ( unsigned int ) m_sInPortDef . nBufferCountActual ) ; <NEW_LINE> <START_VULN> if ( nPortIndex < m_sInPortDef . nBufferCountActual ) { <NEW_LINE> <END_VULN> BITMASK_CLEAR ( & m_inp_bm_count , nPortIndex ) ; <NEW_LINE> free_input_buffer ( buffer ) ;
{ <NEW_LINE> one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; <NEW_LINE> if ( compressionType == PALM_COMPRESSION_SCANLINE ) <NEW_LINE> <START_VULN> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <NEW_LINE> <END_VULN> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; <NEW_LINE> } <NEW_LINE> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ )
mContext ( aContext ) , mDC ( aDC ) , mRangeString ( nsnull ) , mRangeLength ( 0 ) , <NEW_LINE> mItemString ( aString ) , mItemLength ( aLength ) , <NEW_LINE> mAlternativeString ( nsnull ) , mScriptItem ( aItem ) , <NEW_LINE> mScript ( aItem -> a . eScript ) , mGroup ( aGroup ) , <NEW_LINE> mNumGlyphs ( 0 ) , mMaxGlyphs ( ESTIMATE_MAX_GLYPHS ( aLength ) ) , <NEW_LINE> mFontSelected ( PR_FALSE ) , mForceGDIPlace ( PR_FALSE ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( mMaxGlyphs < 65535 , "UniscribeItem is too big , ScriptShape ( ) will fail ! " ) ; <NEW_LINE> <START_VULN> mGlyphs . SetLength ( mMaxGlyphs ) ; <NEW_LINE>mClusters . SetLength ( mItemLength + 1 ) ; <NEW_LINE>mAttr . SetLength ( mMaxGlyphs ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> ~ UniscribeItem ( ) { <NEW_LINE> free ( mAlternativeString ) ; <NEW_LINE> } <NEW_LINE> HRESULT ShapeUniscribe ( ) { <NEW_LINE> HRESULT rv ; <NEW_LINE> HDC shapeDC = nsnull ;
private: <NEW_LINE> SoundPool ( ) { } <NEW_LINE> bool startThreads ( ) ; <NEW_LINE> <START_VULN> void doLoad ( sp < Sample > & sample ) ; <NEW_LINE>sp < Sample > findSample ( int sampleID ) { return mSamples . valueFor ( sampleID ) ; } <NEW_LINE> <END_VULN> SoundChannel * findChannel ( int channelID ) ; <NEW_LINE> SoundChannel * findNextChannel ( int channelID ) ; <NEW_LINE> SoundChannel * allocateChannel_l ( int priority ) ;
SPL_METHOD ( FilesystemIterator , current ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
{ U32 max = MaxML ; <NEW_LINE> size_t const mostFrequent = HIST_countFast_wksp ( count , & max , mlCodeTable , nbSeq , workspace , wkspSize ) ; <NEW_LINE> <START_VULN> DEBUGLOG ( 5 , "Building ML table" ) ; <NEW_LINE> <END_VULN> nextEntropy -> fse . matchlength_repeatMode = prevEntropy -> fse . matchlength_repeatMode ; <NEW_LINE> MLtype = ZSTD_selectEncodingType ( & nextEntropy -> fse . matchlength_repeatMode , count , max , mostFrequent , nbSeq , MLFSELog , prevEntropy -> fse . matchlengthCTable , ML_defaultNorm , ML_defaultNormLog , ZSTD_defaultAllowed , strategy ) ; <NEW_LINE> assert ( ! ( MLtype < set_compressed && nextEntropy -> fse . matchlength_repeatMode != FSE_repeat_none ) ) ;
exit ( - 1 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ( * pkthdr ) -> len < ( * pkthdr ) -> caplen ) { <NEW_LINE>fprintf ( stderr , "safe_pcap_next_ex ERROR: Invalid packet length in % s: % s ( ) line % d: packet length % u is less than capture length % u\n" , <NEW_LINE> <END_VULN> file , funcname , line , ( * pkthdr ) -> len , ( * pkthdr ) -> caplen ) ; <NEW_LINE> exit ( - 1 ) ; <NEW_LINE> }
switch ( optname ) { <NEW_LINE> case TCP_MAXSEG: <NEW_LINE> <START_VULN> if ( val < 8 || val > MAX_TCP_WINDOW ) { <NEW_LINE> <END_VULN> err = - EINVAL ; <NEW_LINE> break ; <NEW_LINE> }
status_t OMXNodeInstance::sendCommand ( <NEW_LINE> OMX_COMMANDTYPE cmd , OMX_S32 param ) { <NEW_LINE> <START_VULN> const sp < GraphicBufferSource > & bufferSource ( getGraphicBufferSource ( ) ) ; <NEW_LINE> <END_VULN> if ( bufferSource != NULL && cmd == OMX_CommandStateSet ) { <NEW_LINE> if ( param == OMX_StateIdle ) {
int arnr_strength ; <NEW_LINE> int arnr_type ; <NEW_LINE> <START_VULN> struct vpx_fixed_buf two_pass_stats_in ; <NEW_LINE> <END_VULN> struct vpx_codec_pkt_list * output_pkt_list ; <NEW_LINE> vp8e_tuning tuning ;
if ( image_info -> number_scenes != 0 ) <NEW_LINE> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) <NEW_LINE> break ; <NEW_LINE> * magick = '\0' ; <NEW_LINE> <START_VULN> if ( bmp_info . ba_offset != 0 ) <NEW_LINE> { <NEW_LINE>offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; <NEW_LINE>if ( offset < 0 ) <NEW_LINE>ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> count = ReadBlob ( image , 2 , magick ) ; <NEW_LINE> if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) <NEW_LINE> {
} <NEW_LINE> if ( result && ! updaterIsCorrect ) { <NEW_LINE> <START_VULN> LOG_WARN ( ( "The updaters do not match , udpater will not run . " ) ) ; <NEW_LINE> <END_VULN> result = FALSE ; <NEW_LINE> }
newserv -> usn [ l ] = '\0' ; <NEW_LINE> p += l ; <NEW_LINE> DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <NEW_LINE> <START_VULN> if ( p + l > buf + n ) { <NEW_LINE> <END_VULN> syslog ( LOG_WARNING , "bad request ( length encoding ) " ) ; <NEW_LINE> goto error ; <NEW_LINE> }
{ <NEW_LINE> <START_VULN> cupsdSetString ( & attr -> values [ 0 ] . string . text , Classification ) ; <NEW_LINE> <END_VULN> cupsdLogJob ( job , CUPSD_LOG_NOTICE , "CLASSIFICATION FORCED " <NEW_LINE> "job - sheets = \" % s , none\" , "
container -> ClearCurrentFrame ( ) ; <NEW_LINE> } <NEW_LINE> mOmxDecoder . clear ( ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> bool MediaOmxReader::DecodeVideoFrame ( bool & aKeyframeSkip , <NEW_LINE> <START_VULN> int64_t aTimeThreshold ) <NEW_LINE> <END_VULN> { <NEW_LINE> uint32_t parsed = 0 , decoded = 0 ; <NEW_LINE> AbstractMediaDecoder::AutoNotifyDecoded autoNotify ( mDecoder , parsed , decoded ) ; <NEW_LINE> bool doSeek = mVideoSeekTimeUs != - 1 ; <NEW_LINE> if ( doSeek ) {
#include < common . h > <NEW_LINE> <START_VULN> #include " . . / common / common . h" <NEW_LINE>#include "kmp204x . h" <NEW_LINE> <END_VULN> #define DIRECT_OFF		0x18
<START_VULN> if ( ( routes = mprGetJsonObj ( prop , "routes" ) ) != 0 ) { <NEW_LINE> <END_VULN> parseRoutes ( route , key , routes ) ; <NEW_LINE> } <NEW_LINE> }
} <NEW_LINE> #if CONFIG_MULTITHREAD <NEW_LINE> <START_VULN> <NEW_LINE>if ( pbi -> decoding_thread_count > num_token_partitions - 1 ) <NEW_LINE>pbi -> decoding_thread_count = num_token_partitions - 1 ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> }
if ( ctx -> fragments . count == 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memset ( ( void * ) ctx -> fragments . ptrs , 0 , sizeof ( ctx -> fragments . ptrs ) ) ; <NEW_LINE>vpx_memset ( ctx -> fragments . sizes , 0 , sizeof ( ctx -> fragments . sizes ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ctx -> fragments . enabled && ! ( data == NULL && data_sz == 0 ) ) <NEW_LINE> {
{ <NEW_LINE> struct sock * s = unix_get_socket ( fp ) ; <NEW_LINE> if ( s ) { <NEW_LINE> struct unix_sock * u = unix_sk ( s ) ; <NEW_LINE> <START_VULN> spin_lock ( & unix_gc_lock ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { <NEW_LINE> BUG_ON ( ! list_empty ( & u -> link ) ) ; <NEW_LINE> list_add_tail ( & u -> link , & gc_inflight_list ) ;
nb_tests ++ ; <NEW_LINE> ctxt = xmlRelaxNGNewValidCtxt ( rng ) ; <NEW_LINE> xmlRelaxNGSetValidErrors ( ctxt , <NEW_LINE> <START_VULN> ( xmlRelaxNGValidityErrorFunc ) testErrorHandler , <NEW_LINE> ( xmlRelaxNGValidityWarningFunc ) testErrorHandler , <NEW_LINE>ctxt ) ; <NEW_LINE> <END_VULN> ret = xmlRelaxNGValidateDoc ( ctxt , doc ) ; <NEW_LINE> xmlRelaxNGFreeValidCtxt ( ctxt ) ; <NEW_LINE> if ( ret > 0 ) {
} <NEW_LINE> OBJ_TO_INNER_OBJECT ( cx , obj ) ; <NEW_LINE> if ( ! obj ) { <NEW_LINE> ok = JS_FALSE ; <NEW_LINE> goto out ; <NEW_LINE> } <NEW_LINE> if ( obj != callerScopeChain ) { <NEW_LINE> ok = js_CheckPrincipalsAccess ( cx , obj , <NEW_LINE> <START_VULN> caller -> script -> principals , <NEW_LINE> <END_VULN> cx -> runtime -> atomState . evalAtom ) ; <NEW_LINE> if ( ! ok ) <NEW_LINE> goto out ; <NEW_LINE> scopeobj = js_NewWithObject ( cx , obj , callerScopeChain , - 1 ) ; <NEW_LINE> if ( ! scopeobj ) { <NEW_LINE> ok = JS_FALSE ; <NEW_LINE> goto out ;
selReadStream ( FILE * fp ) <NEW_LINE> { <NEW_LINE> char * selname ; <NEW_LINE> <START_VULN> char linebuf [ L_BUF_SIZE ] ; <NEW_LINE> <END_VULN> l_int32 sy , sx , cy , cx , i , j , version , ignore ; <NEW_LINE> SEL * sel ;
else <NEW_LINE> parent = ::GetAncestor ( mWnd , GA_PARENT ) ; <NEW_LINE> #endif <NEW_LINE> if ( parent ) { <NEW_LINE> widget = GetNSWindowPtr ( parent ) ; <NEW_LINE> if ( widget ) { <NEW_LINE> <START_VULN> if ( widget -> mIsDestroying ) { <NEW_LINE> <END_VULN> widget = nsnull ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return widget ; <NEW_LINE> }
#ifdef NS_DEBUG <NEW_LINE> nsCOMPtr < nsISupports > targetSupp = do_QueryInterface ( aTarget ) ; <NEW_LINE> nsCOMPtr < nsISupports > native = <NEW_LINE> nsContentUtils::XPConnect ( ) -> GetNativeOfWrapper ( mContext , <NEW_LINE> JSVAL_TO_OBJECT ( v ) ) ; <NEW_LINE> NS_ASSERTION ( native == targetSupp , "Native should be the target ! " ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> * aRet = JSVAL_TO_OBJECT ( v ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsJSContext::CompileEventHandler ( nsIAtom * aName , <NEW_LINE> PRUint32 aArgCount ,
variable -> fragment = container ; <NEW_LINE> <START_VULN> container -> psvi = XSLT_RVT_VARIABLE ; <NEW_LINE> <END_VULN> oldOutput = ctxt -> output ; <NEW_LINE> oldInsert = ctxt -> insert ;
nsCOMPtr < nsIDeviceSensors > ac = do_GetService ( NS_DEVICE_SENSORS_CONTRACTID ) ; <NEW_LINE> if ( ac ) { <NEW_LINE> for ( uint32_t i = 0 ; i < mEnabledSensors . Length ( ) ; i ++ ) <NEW_LINE> ac -> AddWindowListener ( mEnabledSensors [ i ] , this ) ; <NEW_LINE> } <NEW_LINE> nsIScriptContext * scx = GetContextInternal ( ) ; <NEW_LINE> <START_VULN> JSContext * cx = scx ? scx -> GetNativeContext ( ) : nullptr ; <NEW_LINE> <END_VULN> mozilla::dom::workers::ResumeWorkersForWindow ( cx , this ) ; <NEW_LINE> TimeStamp now = TimeStamp::Now ( ) ; <NEW_LINE> #ifdef DEBUG
} <NEW_LINE> } <NEW_LINE> <START_VULN> static void local_socket_close_locked ( asocket * s ) { <NEW_LINE>D ( "entered local_socket_close_locked . LS ( % d ) fd = % d" , s -> id , s -> fd ) ; <NEW_LINE> <END_VULN> if ( s -> peer ) { <NEW_LINE> D ( "LS ( % d ) : closing peer . peer -> id = % d peer -> fd = % d" , s -> id , s -> peer -> id , s -> peer -> fd ) ;
static v8::Handle < v8::Value > setValueAndClosePopupCallback ( const v8::Arguments & args ) <NEW_LINE> { <NEW_LINE> if ( args . Length ( ) < 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> DOMWindow * imp = V8DOMWindow::toNative ( args . Data ( ) -> ToObject ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( int , intValue , toInt32 ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , stringValue , MAYBE_MISSING_PARAMETER ( args , 1 , DefaultIsUndefined ) ) ;
int vorbis_synthesis_pcmout ( vorbis_dsp_state * v , float ** * pcm ) { <NEW_LINE> vorbis_info * vi = v -> vi ; <NEW_LINE> if ( v -> pcm_returned > - 1 && v -> pcm_returned < v -> pcm_current ) { <NEW_LINE> if ( pcm ) { <NEW_LINE> int i ; <NEW_LINE> for ( i = 0 ; i < vi -> channels ; i ++ ) <NEW_LINE> <START_VULN> v -> pcmret [ i ] = v -> pcm [ i ] + v -> pcm_returned ; <NEW_LINE> <END_VULN> * pcm = v -> pcmret ; <NEW_LINE> } <NEW_LINE> return ( v -> pcm_current - v -> pcm_returned ) ; <NEW_LINE> } <NEW_LINE> return ( 0 ) ; <NEW_LINE> } <NEW_LINE> int vorbis_synthesis_read ( vorbis_dsp_state * v , int n ) {
#define YIELD_PROCESSOR __asm__ __volatile__ ( "pause" ) <NEW_LINE> #elif CPU ( ARM ) || CPU ( ARM64 ) <NEW_LINE> #define YIELD_PROCESSOR __asm__ __volatile__ ( "yield" ) <NEW_LINE> <START_VULN> #elif defined ( __mips__ ) && __mips_isa_rev >= 2 <NEW_LINE> <END_VULN> #define YIELD_PROCESSOR __asm__ __volatile__ ( "pause" ) <NEW_LINE> #endif <NEW_LINE> #endif
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeContentView::GetColumnProperties ( nsITreeColumn * aCol , nsISupportsArray * aProperties ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ENSURE_ARG_POINTER ( aCol ) ; <NEW_LINE> <END_VULN> NS_ENSURE_ARG_POINTER ( aProperties ) ; <NEW_LINE> nsCOMPtr < nsIDOMElement > element ; <NEW_LINE> aCol -> GetElement ( getter_AddRefs ( element ) ) ; <NEW_LINE> nsAutoString properties ; <NEW_LINE> element -> GetAttribute ( NS_LITERAL_STRING ( "properties" ) , properties ) ; <NEW_LINE> if ( ! properties . IsEmpty ( ) )
} <NEW_LINE> processed ++ ; <NEW_LINE> } else if ( afi == AF_INET6 ) { <NEW_LINE> <START_VULN> if ( ! ND_TTEST2 ( * tptr , 1 ) ) <NEW_LINE> <END_VULN> return ( 0 ) ; <NEW_LINE> status_byte = * ( tptr ++ ) ; <NEW_LINE> bit_length = * ( tptr ++ ) ;
Return current file position * / <NEW_LINE> SPL_METHOD ( SplFileObject , ftell ) <NEW_LINE> { <NEW_LINE> <START_VULN> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <END_VULN> long ret = php_stream_tell ( intern -> u . file . stream ) ; <NEW_LINE> if ( ret == - 1 ) {
return ; <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " [ | icmp6 ] " ) ) ; <NEW_LINE> <END_VULN> }
if ( max + 6 . f > flr [ i ] ) { <NEW_LINE> oc = oc >> p -> shiftoc ; <NEW_LINE> if ( oc >= P_BANDS ) oc = P_BANDS - 1 ; <NEW_LINE> if ( oc < 0 ) oc = 0 ; <NEW_LINE> seed_curve ( seed , <NEW_LINE> <START_VULN> curves [ oc ] , <NEW_LINE>max , <NEW_LINE>p -> octave [ i ] - p -> firstoc , <NEW_LINE>p -> total_octave_lines , <NEW_LINE>p -> eighth_octave_lines , <NEW_LINE>dBoffset ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> static void seed_chase ( float * seeds , int linesper , long n ) { <NEW_LINE> long * posstack = alloca ( n * sizeof ( * posstack ) ) ; <NEW_LINE> float * ampstack = alloca ( n * sizeof ( * ampstack ) ) ; <NEW_LINE> long stack = 0 ;
#endif <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE>#if defined ( _WIN32 ) && defined ( __CYGWIN__ ) <NEW_LINE> <END_VULN> #undef XMLPUBFUN <NEW_LINE> #undef XMLPUBVAR <NEW_LINE> #undef XMLCALL
const Pickle & data ) = 0 ; <NEW_LINE> virtual bool GetString ( base::string16 * data ) const = 0 ; <NEW_LINE> <START_VULN> virtual bool GetURLAndTitle ( GURL * url , base::string16 * title ) const = 0 ; <NEW_LINE> <END_VULN> virtual bool GetFilename ( base::FilePath * path ) const = 0 ; <NEW_LINE> virtual bool GetFilenames ( <NEW_LINE> std::vector < FileInfo > * file_names ) const = 0 ;
return nullptr ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } while ( ( doc = doc -> GetParentDocument ( ) ) ) ; <NEW_LINE> nsCOMPtr < nsINode > parent = adoptedNode -> GetParentNode ( ) ; <NEW_LINE> if ( parent ) { <NEW_LINE> <START_VULN> parent -> RemoveChildAt ( parent -> IndexOf ( adoptedNode ) , true ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> case nsIDOMNode::DOCUMENT_NODE: <NEW_LINE> { <NEW_LINE> rv . Throw ( NS_ERROR_DOM_NOT_SUPPORTED_ERR ) ; <NEW_LINE> return nullptr ;
{ <NEW_LINE> return style -> display ( ) == TABLE || style -> display ( ) == INLINE_TABLE || style -> display ( ) == RUN_IN <NEW_LINE> || style -> display ( ) == INLINE_BLOCK || style -> display ( ) == INLINE_BOX || isAtShadowBoundary ( e ) <NEW_LINE> <START_VULN> || style -> isFloating ( ) || style -> isPositioned ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void StyleResolver::adjustRenderStyle ( RenderStyle * style , RenderStyle * parentStyle , Element * e )
if ( aState ) { <NEW_LINE> JSObject * proto ; <NEW_LINE> if ( nsIXPConnectJSObjectHolder * holder = wsh -> GetOuterRealProto ( ) ) { <NEW_LINE> holder -> GetJSObject ( & proto ) ; <NEW_LINE> } else { <NEW_LINE> proto = nsnull ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! JS_SetPrototype ( cx , mJSObject , proto ) ) { <NEW_LINE> <END_VULN> NS_ERROR ( "can't set prototype" ) ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> if ( ! JS_DefineProperty ( cx , newInnerWindow -> mJSObject , "window" , <NEW_LINE> OBJECT_TO_JSVAL ( mJSObject ) , <NEW_LINE> JS_PropertyStub , JS_StrictPropertyStub , <NEW_LINE> JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT ) ) {
ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE> image -> columns = width ; <NEW_LINE> image -> rows = height ; <NEW_LINE> <START_VULN> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) <NEW_LINE>if ( depth >= 64 ) <NEW_LINE>break ; <NEW_LINE> <END_VULN> image -> depth = depth ; <NEW_LINE> status = SetImageExtent ( image , image -> columns , image -> rows ) ; <NEW_LINE> if ( status == MagickFalse )
} <NEW_LINE> std::unique_ptr < PK_Ops::Signature > <NEW_LINE> <START_VULN> ECDSA_PrivateKey::create_signature_op ( RandomNumberGenerator & , <NEW_LINE> <END_VULN> const std::string & params , <NEW_LINE> const std::string & provider ) const <NEW_LINE> {
if ( key_size > type_props -> max_size ) <NEW_LINE> return TEE_ERROR_NOT_SUPPORTED ; <NEW_LINE> <START_VULN> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <NEW_LINE> <END_VULN> if ( ! params ) <NEW_LINE> return TEE_ERROR_OUT_OF_MEMORY ; <NEW_LINE> res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_params , param_count ,
JSRetainPtr < JSStringRef > AccessibilityUIElement::stringValue ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE>return JSStringCreateWithCharacters ( 0 , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JSRetainPtr < JSStringRef > AccessibilityUIElement::language ( )
{ <NEW_LINE> INC_STATS ( "DOM . Float64Array . foo" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> Float64Array * imp = V8Float64Array::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( Float32Array * , array , V8Float32Array::HasInstance ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ? V8Float32Array::toNative ( v8::Handle < v8::Object > ::Cast ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) : 0 ) ; <NEW_LINE> return toV8 ( imp -> foo ( array ) , args . GetIsolate ( ) ) ;
} <NEW_LINE> #endif <NEW_LINE> void RunScript ( nsIContent * aScriptElement ) ; <NEW_LINE> void Reset ( ) ; <NEW_LINE> inline void HoldElement ( nsIContent * aContent ) { <NEW_LINE> <START_VULN> mOwnedElements . AppendObject ( aContent ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void DropHeldElements ( ) ;
void <NEW_LINE> <START_VULN> nsBoxFrame::FireDOMEvent ( nsIPresContext * aPresContext , const nsAString & aDOMEventName ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( mContent ) { <NEW_LINE> unchanged:
goto err ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( cs > CQSPI_MAX_CHIPSELECT ) { <NEW_LINE> <END_VULN> dev_err ( dev , "Chip select % d out of range . \n" , cs ) ; <NEW_LINE> goto err ; <NEW_LINE> }
perf_event_header__init_id ( & task_event -> event_id . header , & sample , event ) ; <NEW_LINE> ret = perf_output_begin ( & handle , event , <NEW_LINE> <START_VULN> task_event -> event_id . header . size , 0 , 0 ) ; <NEW_LINE> <END_VULN> if ( ret ) <NEW_LINE> goto out ;
<START_VULN> #ifndef BASE_DEFAULT_TICK_CLOCK_H_ <NEW_LINE>#define BASE_DEFAULT_TICK_CLOCK_H_ <NEW_LINE> <END_VULN> #include "base / base_export . h" <NEW_LINE> #include "base / compiler_specific . h"
if ( block_inside_limit < 1 ) <NEW_LINE> block_inside_limit = 1 ; <NEW_LINE> <START_VULN> vpx_memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ; <NEW_LINE>vpx_memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) , <NEW_LINE>SIMD_WIDTH ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
virtual gfxFontEntry * MakePlatformFont ( const gfxProxyFontEntry * aProxyEntry , <NEW_LINE> const PRUint8 * aFontData , <NEW_LINE> PRUint32 aLength ) ; <NEW_LINE> <START_VULN> virtual PRBool DownloadableFontsEnabled ( ) ; <NEW_LINE> <END_VULN> #define LOG ( args ) PR_LOG ( gUserFontsLog , PR_LOG_DEBUG , args ) <NEW_LINE> #define LOG_ENABLED ( ) PR_LOG_TEST ( gUserFontsLog , PR_LOG_DEBUG ) <NEW_LINE> static PRUint64 sFontSetGeneration = LL_INIT ( 0 , 0 ) ;
if ( smartData -> frame ) { <NEW_LINE> WebCore::FrameLoaderClientEfl * flc = _ewk_frame_loader_efl_get ( smartData -> frame ) ; <NEW_LINE> flc -> setWebFrame ( 0 ) ; <NEW_LINE> <START_VULN> smartData -> frame -> loader ( ) -> detachFromParent ( ) ; <NEW_LINE>smartData -> frame -> loader ( ) -> cancelAndClear ( ) ; <NEW_LINE> <END_VULN> smartData -> frame = 0 ; <NEW_LINE> }
int32_t DownmixLib_Create ( const effect_uuid_t * uuid , <NEW_LINE> <START_VULN> int32_t sessionId , <NEW_LINE>int32_t ioId , <NEW_LINE> <END_VULN> effect_handle_t * pHandle ) { <NEW_LINE> int ret ; <NEW_LINE> int i ;
{ <NEW_LINE> if ( ! GPMF_VALID_FOURCC ( qttag ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <NEW_LINE> <END_VULN> NESTSIZE ( lastsize - 8 ) ; <NEW_LINE> continue ;
params = httpGetParams ( conn ) ; <NEW_LINE> assert ( params ) ; <NEW_LINE> for ( ITERATE_ITEMS ( rx -> files , file , index ) ) { <NEW_LINE> <START_VULN> mprSetJson ( params , sfmt ( "FILE_ % d_FILENAME" , index ) , file -> filename ) ; <NEW_LINE>mprSetJson ( params , sfmt ( "FILE_ % d_CLIENT_FILENAME" , index ) , file -> clientFilename ) ; <NEW_LINE>mprSetJson ( params , sfmt ( "FILE_ % d_CONTENT_TYPE" , index ) , file -> contentType ) ; <NEW_LINE>mprSetJson ( params , sfmt ( "FILE_ % d_NAME" , index ) , file -> name ) ; <NEW_LINE>mprSetJson ( params , sfmt ( "FILE_ % d_SIZE" , index ) , sfmt ( " % zd" , file -> size ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> if ( conn -> http -> envCallback ) {
#pragma once <NEW_LINE> #include "base / basictypes . h" <NEW_LINE> <START_VULN> #include "base / callback . h" <NEW_LINE> <END_VULN> #include "base / memory / scoped_ptr . h" <NEW_LINE> #include "base / synchronization / lock . h" <NEW_LINE> #include "base / synchronization / waitable_event . h"
if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <NEW_LINE> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) <NEW_LINE> break ; <NEW_LINE> <START_VULN> status = SetImageExtent ( image , image -> columns , image -> rows ) ; <NEW_LINE>if ( status == MagickFalse ) <NEW_LINE> { <NEW_LINE>InheritException ( exception , & image -> exception ) ; <NEW_LINE>return ( DestroyImageList ( image ) ) ; <NEW_LINE> } <NEW_LINE> <END_VULN>
if ( s -> s3 -> tmp . key_block_length != 0 ) <NEW_LINE> return ( 1 ) ; <NEW_LINE> <START_VULN> if ( ! ssl_cipher_get_evp <NEW_LINE> ( s -> session , & c , & hash , & mac_type , & mac_secret_size , & comp , <NEW_LINE>SSL_USE_ETM ( s ) ) ) { <NEW_LINE> <END_VULN> SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , SSL_R_CIPHER_OR_HASH_UNAVAILABLE ) ; <NEW_LINE> return ( 0 ) ; <NEW_LINE> }
temp_in [ i * 4 + j ] = out [ j * 4 + i ] ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> vp9_idct4_columns_add_blk_dspr2 ( & temp_in [ 0 ] , dest , dest_stride ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case ADST_ADST: <NEW_LINE> for ( i = 0 ; i < 4 ; ++ i ) {
<START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>virtual void LastPluginRefWasDeleted ( bool instance_destroyed ) ; <NEW_LINE> <END_VULN> private:
{ <NEW_LINE> INC_STATS ( "DOM . TestActiveDOMObject . postMessage" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestActiveDOMObject * imp = V8TestActiveDOMObject::toNative ( args . Holder ( ) ) ; <NEW_LINE> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , message , MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ; <NEW_LINE> imp -> postMessage ( message ) ;
for ( int i = 0 ; i < pipe_size ; i ++ ) { <NEW_LINE> int fd = recv_fd ( afdt_fd ) ; <NEW_LINE> if ( fd < 0 ) { <NEW_LINE> <START_VULN> fprintf ( fout , "error\n % d\n" , EPROTO ) ; <NEW_LINE> <END_VULN> fflush ( fout ) ; <NEW_LINE> close_fds ( pkeys ) ; <NEW_LINE> return ;
static int <NEW_LINE> image_transform_png_set_rgb_to_gray_add ( image_transform * this , <NEW_LINE> <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE> <END_VULN> { <NEW_LINE> UNUSED ( bit_depth )
this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; <NEW_LINE> CHECK_POINT <NEW_LINE> this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <NEW_LINE> <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <NEW_LINE> <END_VULN> CHECK_BETTER <NEW_LINE> } <NEW_LINE> }
<START_VULN> IPC_STRUCT_TRAITS_MEMBER ( preview_ui_addr ) <NEW_LINE> <END_VULN> IPC_STRUCT_TRAITS_MEMBER ( preview_request_id )
while ( vct_issp ( * p ) ) <NEW_LINE> p ++ ; <NEW_LINE> hh [ n ++ ] = p ; <NEW_LINE> <START_VULN> while ( ! vct_iscrlf ( * p ) ) <NEW_LINE> <END_VULN> p ++ ; <NEW_LINE> q = p ; <NEW_LINE> p += vct_skipcrlf ( p ) ;
case 2: <NEW_LINE> s -> smart_selftest_count ++ ; <NEW_LINE> if ( s -> smart_selftest_count > 21 ) { <NEW_LINE> <START_VULN> s -> smart_selftest_count = 0 ; <NEW_LINE> <END_VULN> } <NEW_LINE> n = 2 + ( s -> smart_selftest_count - 1 ) * 24 ; <NEW_LINE> s -> smart_selftest_data [ n ] = s -> sector ;
return length ; <NEW_LINE> } <NEW_LINE> <START_VULN> int get_down2_steps ( int in_length , int out_length ) { <NEW_LINE> <END_VULN> int steps = 0 ; <NEW_LINE> int proj_in_length ; <NEW_LINE> while ( ( proj_in_length = get_down2_length ( in_length , 1 ) ) >= out_length ) {
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> c * ( toc ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
nsAutoPtr < CacheEntry > & aValue , <NEW_LINE> void * aUserData ) <NEW_LINE> { <NEW_LINE> PRTime * now = static_cast < PRTime * > ( aUserData ) ; <NEW_LINE> aValue -> PurgeExpired ( * now ) ; <NEW_LINE> if ( aValue -> mHeaders . IsEmpty ( ) && <NEW_LINE> <START_VULN> aValue -> mHeaders . IsEmpty ( ) ) { <NEW_LINE> <END_VULN> PR_REMOVE_LINK ( aValue ) ; <NEW_LINE> return PL_DHASH_REMOVE ; <NEW_LINE> } <NEW_LINE> return PL_DHASH_NEXT ; <NEW_LINE> }
char delimiter = ' , ' , enclosure = '"' , escape = '\\' ; <NEW_LINE> char * delim = NULL , * enclo = NULL , * esc = NULL ; <NEW_LINE> int d_len = 0 , e_len = 0 , esc_len = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , " | sss" , & delim , & d_len , & enclo , & e_len , & esc , & esc_len ) == SUCCESS ) { <NEW_LINE> switch ( ZEND_NUM_ARGS ( ) ) <NEW_LINE> {
int32_t start , end , increment ; <NEW_LINE> <START_VULN> if ( mContent -> IsHTML ( ) && <NEW_LINE>mContent -> IsInHTMLDocument ( ) ) { <NEW_LINE> <END_VULN> start = numRealAttrs - 1 ; <NEW_LINE> end = - 1 ; <NEW_LINE> increment = - 1 ; <NEW_LINE> } else { <NEW_LINE> start = 0 ; <NEW_LINE> end = numRealAttrs ;
if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( perf_event_overflow ( event , 0 , data , regs ) ) <NEW_LINE> <END_VULN> mipspmu -> disable_event ( idx ) ; <NEW_LINE> }
static JSValue setDataViewMember ( ExecState * exec , DataView * imp , DataViewAccessType type ) <NEW_LINE> { <NEW_LINE> if ( exec -> argumentCount ( ) < 2 ) <NEW_LINE> <START_VULN> return throwError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> unsigned byteOffset = exec -> argument ( 0 ) . toUInt32 ( exec ) ; <NEW_LINE> if ( exec -> hadException ( ) )
png_crc_read ( png_ptr , buf , 9 ) ; <NEW_LINE> <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> offset_x = png_get_int_32 ( buf ) ;
png_chunk_benign_error ( png_const_structrp png_ptr , png_const_charp <NEW_LINE> error_message ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> flags & PNG_FLAG_BENIGN_ERRORS_WARN ) <NEW_LINE> <END_VULN> png_chunk_warning ( png_ptr , error_message ) ; <NEW_LINE> else
uint32_t length ( ) const { <NEW_LINE> JS_ASSERT ( hasSourceData ( ) ) ; <NEW_LINE> return length_ ; <NEW_LINE> } <NEW_LINE> bool argumentsNotIncluded ( ) const { <NEW_LINE> JS_ASSERT ( hasSourceData ( ) ) ; <NEW_LINE> return argumentsNotIncluded_ ; <NEW_LINE> } <NEW_LINE> <START_VULN> const jschar * chars ( JSContext * cx , const SourceDataCache::AutoSuppressPurge & asp ) ; <NEW_LINE> <END_VULN> JSFlatString * substring ( JSContext * cx , uint32_t start , uint32_t stop ) ; <NEW_LINE> void addSizeOfIncludingThis ( mozilla::MallocSizeOf mallocSizeOf , <NEW_LINE> JS::ScriptSourceInfo * info ) const ; <NEW_LINE> template < XDRMode mode > <NEW_LINE> bool performXDR ( XDRState < mode > * xdr ) ;
score = 0 ; <NEW_LINE> ret = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> pd . buf_size += ret ; <NEW_LINE> <END_VULN> pd . buf = & buf [ offset ] ; <NEW_LINE> memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ) ;
const String & SourceText ( ) ; <NEW_LINE> <START_VULN> AccessControlStatus CalculateAccessControlStatus ( ) const ; <NEW_LINE> <END_VULN> private: <NEW_LINE> class ScriptResourceFactory : public ResourceFactory {
p = PushLongPixel ( MSBEndian , p , & count ) ; <NEW_LINE> if ( id == 0x0000040f ) <NEW_LINE> { <NEW_LINE> <START_VULN> ( void ) CopyMagickMemory ( q , q + PSDQuantum ( count ) + 12 , length - <NEW_LINE> ( PSDQuantum ( count ) + 12 ) - ( q - datum ) ) ; <NEW_LINE>SetStringInfoLength ( bim_profile , length - ( PSDQuantum ( count ) + 12 ) ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> } <NEW_LINE> p += count ;
NS_ASSERTION ( aReflowState . availableWidth != NS_UNCONSTRAINEDSIZE , <NEW_LINE> "shouldn't happen anymore" ) ; <NEW_LINE> aDesiredSize . width = aReflowState . availableWidth ; <NEW_LINE> <START_VULN> aDesiredSize . height = aReflowState . availableHeight != NS_UNCONSTRAINEDSIZE <NEW_LINE> ? aReflowState . availableHeight <NEW_LINE> <END_VULN> : kidHeight ; <NEW_LINE> nsHTMLReflowState reflowState ( aReflowState ) ; <NEW_LINE> nsPoint offset = AdjustReflowStateForScrollbars ( & reflowState ) ; <NEW_LINE> #ifdef DEBUG
if ( certutil . commands [ cmd_ListCerts ] . activated ) { <NEW_LINE> rv = ListCerts ( certHandle , name , slot , <NEW_LINE> certutil . options [ opt_BinaryDER ] . activated , <NEW_LINE> certutil . options [ opt_ASCIIForIO ] . activated , <NEW_LINE> ( outFile ) ? outFile : PR_STDOUT , & pwdata ) ; <NEW_LINE> goto shutdown ; <NEW_LINE> } <NEW_LINE> if ( certutil . commands [ cmd_DumpChain ] . activated ) { <NEW_LINE> <START_VULN> rv = DumpChain ( certHandle , name ) ; <NEW_LINE> <END_VULN> goto shutdown ; <NEW_LINE> } <NEW_LINE> if ( certutil . commands [ cmd_ListKeys ] . activated ) { <NEW_LINE> rv = ListKeys ( slot , name , 0 , keytype , PR_FALSE , <NEW_LINE> & pwdata ) ; <NEW_LINE> goto shutdown ;
#define UNSTORE16_INT ( ptr , val ) ( val = load_16_be ( ptr ) ) <NEW_LINE> #define UNSTORE32_INT ( ptr , val ) ( val = load_32_be ( ptr ) ) <NEW_LINE> <START_VULN> #define KDB_TL_USER_INFO 0x7ffe <NEW_LINE> <END_VULN> #define KDB_TL_PRINCTYPE 0x01 <NEW_LINE> #define KDB_TL_PRINCCOUNT 0x02
void RequestDecode ( RasterImage * aImg ) ; <NEW_LINE> <START_VULN> void DecodeABitOf ( RasterImage * aImg ) ; <NEW_LINE> <END_VULN>
case ' > ': <NEW_LINE> len = format ? 14 : 4 ; <NEW_LINE> ds += len - 1 ; <NEW_LINE> <START_VULN> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <NEW_LINE> <END_VULN> if ( NULL == tmp ) <NEW_LINE> {
die_codec ( codec , "Failed to set active map" ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void encode_frame ( vpx_codec_ctx_t * codec , <NEW_LINE>vpx_image_t * img , <NEW_LINE>int frame_index , <NEW_LINE>VpxVideoWriter * writer ) { <NEW_LINE> <END_VULN> vpx_codec_iter_t iter = NULL ; <NEW_LINE> const vpx_codec_cx_pkt_t * pkt = NULL ; <NEW_LINE> const vpx_codec_err_t res = vpx_codec_encode ( codec , img , frame_index , 1 , 0 ,
<START_VULN> #ifndef BASE_ANDROID_LIBRARY_LOADER_HOOKS_H_ <NEW_LINE>#define BASE_ANDROID_LIBRARY_LOADER_HOOKS_H_ <NEW_LINE> <END_VULN> #include < jni . h >
if ( setjmp ( cpi -> common . error . jmp ) ) <NEW_LINE> { <NEW_LINE> cpi -> common . error . setjmp = 0 ; <NEW_LINE> return VPX_CODEC_CORRUPT_FRAME ; <NEW_LINE> } <NEW_LINE> cpi -> common . error . setjmp = 1 ; <NEW_LINE> <START_VULN> #if HAVE_NEON <NEW_LINE>#if CONFIG_RUNTIME_CPU_DETECT <NEW_LINE>if ( cm -> cpu_caps & HAS_NEON ) <NEW_LINE>#endif <NEW_LINE> { <NEW_LINE>vp8_push_neon ( store_reg ) ; <NEW_LINE> } <NEW_LINE>#endif <NEW_LINE><NEW_LINE> <END_VULN> vpx_usec_timer_start ( & cmptimer ) ; <NEW_LINE> cpi -> source = NULL ;
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> } <NEW_LINE> }
static INLINE void txfrm_block_to_raster_xy ( BLOCK_SIZE plane_bsize , <NEW_LINE> TX_SIZE tx_size , int block , <NEW_LINE> int * x , int * y ) { <NEW_LINE> <START_VULN> const int bwl = b_width_log2 ( plane_bsize ) ; <NEW_LINE> <END_VULN> const int tx_cols_log2 = bwl - tx_size ; <NEW_LINE> const int tx_cols = 1 << tx_cols_log2 ; <NEW_LINE> const int raster_mb = block >> ( tx_size << 1 ) ;
if ( buf . chainLength ( ) < ( cursor - buf . front ( ) ) + length ) { <NEW_LINE> return folly::none ; <NEW_LINE> } <NEW_LINE> <START_VULN> length += <NEW_LINE>sizeof ( ContentType ) + sizeof ( ProtocolVersion ) + sizeof ( uint16_t ) ; <NEW_LINE>buf . trimStart ( length ) ; <NEW_LINE> <END_VULN> continue ; <NEW_LINE> } else if ( msg . type != ContentType::change_cipher_spec ) { <NEW_LINE> skipEncryptedRecords_ = false ;
TEST ( GIFImageDecoderTest , badInitialCode ) <NEW_LINE> { <NEW_LINE> <START_VULN> RefPtr < SharedBuffer > testData = readFile ( " / Source / platform / image - decoders / testing / bad - initial - code . gif" ) ; <NEW_LINE> <END_VULN> ASSERT_TRUE ( testData . get ( ) ) ; <NEW_LINE> OwnPtr < GIFImageDecoder > testDecoder ( createDecoder ( ) ) ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> if ( isPositioned ( ) ) { <NEW_LINE> <END_VULN> for ( RenderObject * curr = parent ( ) ; curr ; curr = curr -> parent ( ) ) { <NEW_LINE> if ( curr -> isRenderBlock ( ) ) <NEW_LINE> toRenderBlock ( curr ) -> removePositionedObject ( this ) ;
extern const char kEnablePageVisibility [ ] ; <NEW_LINE> extern const char kUseInProcCommandBuffer [ ] ; <NEW_LINE> <START_VULN> extern const char kWebViewSanboxedRenderer [ ] ; <NEW_LINE> <END_VULN> }
#endif <NEW_LINE> <START_VULN> void <NEW_LINE>mono_reflection_destroy_dynamic_method ( MonoReflectionDynamicMethod * mb ) <NEW_LINE> { <NEW_LINE>g_assert ( mb ) ; <NEW_LINE><NEW_LINE>if ( mb -> mhandle ) <NEW_LINE>mono_runtime_free_method ( <NEW_LINE>mono_object_get_domain ( ( MonoObject * ) mb ) , mb -> mhandle ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> }
} <NEW_LINE> JS_PUBLIC_API ( JSObject * ) <NEW_LINE> JS_GetScriptedGlobal ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> ScriptFrameIter i ( cx ) ; <NEW_LINE> if ( i . done ( ) ) <NEW_LINE> return cx -> global ( ) ; <NEW_LINE> <START_VULN> return & i . fp ( ) -> global ( ) ; <NEW_LINE> <END_VULN> }
mSuppressInterruptibleReflows = true ; <NEW_LINE> MaybeScheduleReflow ( ) ; <NEW_LINE> } <NEW_LINE> nsRootPresContext * rootPC = mPresContext -> GetRootPresContext ( ) ; <NEW_LINE> if ( rootPC ) { <NEW_LINE> <START_VULN> rootPC -> RequestUpdatePluginGeometry ( target ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return ! interrupted ; <NEW_LINE> } <NEW_LINE> #ifdef DEBUG <NEW_LINE> void <NEW_LINE> PresShell::DoVerifyReflow ( )
#if JS_HAS_XML_SUPPORT <NEW_LINE> <START_VULN> if ( pn && onlyXML ) { <NEW_LINE> <END_VULN> parser . reportErrorNumber ( NULL , JSREPORT_ERROR , JSMSG_XML_WHOLE_PROGRAM ) ; <NEW_LINE> goto out ; <NEW_LINE> } <NEW_LINE> #endif
if ( ! transformToString ( sourceNode , resultMIMEType , resultString , resultEncoding ) ) <NEW_LINE> return 0 ; <NEW_LINE> <START_VULN> return createFragmentFromSource ( resultString , resultMIMEType , outputDoc ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void XSLTProcessor::setParameter ( const String & , const String & localName , const String & value )
res_dp += cmd ; <NEW_LINE> res_sz - = cmd ; <NEW_LINE> <START_VULN> } <NEW_LINE>else { <NEW_LINE><NEW_LINE> <END_VULN> goto fail ; <NEW_LINE> } <NEW_LINE> }
BLOCK_SIZE bsize ) { <NEW_LINE> VP9_COMMON * const cm = & cpi -> common ; <NEW_LINE> const int mis = cm -> mi_stride ; <NEW_LINE> <START_VULN> int row8x8_remaining = tile -> mi_row_end - mi_row ; <NEW_LINE>int col8x8_remaining = tile -> mi_col_end - mi_col ; <NEW_LINE> <END_VULN> int block_row , block_col ; <NEW_LINE> MODE_INFO * mi_upper_left = cm -> mi + mi_row * mis + mi_col ; <NEW_LINE> int bh = num_8x8_blocks_high_lookup [ bsize ] ;
Track * const track = track_entries_ [ i ] ; <NEW_LINE> delete track ; <NEW_LINE> } <NEW_LINE> <START_VULN> delete [ ] track_entries_ ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
prot . readListEnd ( ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> default: <NEW_LINE>return ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
#ifdef PNG_WRITE_zTXt_SUPPORTED <NEW_LINE> PNG_INTERNAL_FUNCTION ( void , png_write_zTXt , ( png_structrp png_ptr , png_const_charp <NEW_LINE> <START_VULN> key , png_const_charp text , png_size_t text_len , int compression ) , PNG_EMPTY ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef PNG_WRITE_iTXt_SUPPORTED
#endif <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
bool ms_verify_authorizer ( Connection * con , int peer_type , <NEW_LINE> <START_VULN> int protocol , bufferlist & authorizer , <NEW_LINE>bufferlist & authorizer_reply , <NEW_LINE>bool & isvalid , CryptoKey & session_key ) override { <NEW_LINE> <END_VULN> isvalid = true ; <NEW_LINE> return true ;
if ( fun ) <NEW_LINE> CheckNewScriptProperties ( cx , type , fun ) ; <NEW_LINE> #if JS_HAS_XML_SUPPORT <NEW_LINE> if ( obj -> isXML ( ) && ! type -> unknownProperties ( ) ) <NEW_LINE> type -> flags |= OBJECT_FLAG_UNKNOWN_MASK ; <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> <START_VULN> TypeObject * type = proto -> getNewType ( cx ) ; <NEW_LINE>if ( ! type ) <NEW_LINE>return NULL ; <NEW_LINE>AddTypeProperty ( cx , type , "length" , Type::Int32Type ( ) ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( ! DefineConstructorAndPrototype ( cx , global , JSProto_String , ctor , proto ) ) <NEW_LINE> return NULL ; <NEW_LINE> if ( ! JS_DefineFunctions ( cx , global , string_functions ) )
DocumentLoader * , <NEW_LINE> ResourceRequest & , <NEW_LINE> const ResourceResponse & redirect_response , <NEW_LINE> <START_VULN> const FetchInitiatorInfo & ) ; <NEW_LINE> <END_VULN> void DidReceiveResourceResponse ( unsigned long identifier , <NEW_LINE> DocumentLoader * , <NEW_LINE> const ResourceResponse & ,
#endif <NEW_LINE> <START_VULN> if ( transforms & PNG_TRANSFORM_SWAP_ENDIAN ) <NEW_LINE> <END_VULN> #ifdef PNG_READ_SWAP_SUPPORTED <NEW_LINE> png_set_swap ( png_ptr ) ; <NEW_LINE> #else
NS_HIDDEN_ ( PRBool ) URIEquals ( const URL & aOther ) const ; <NEW_LINE> nsCOMPtr < nsIURI > mURI ; <NEW_LINE> nsStringBuffer * mString ; <NEW_LINE> nsCOMPtr < nsIURI > mReferrer ; <NEW_LINE> nsCOMPtr < nsIPrincipal > mOriginPrincipal ; <NEW_LINE> <START_VULN> void AddRef ( ) { ++ mRefCnt ; } <NEW_LINE>void Release ( ) { if ( -- mRefCnt == 0 ) delete this ; } <NEW_LINE> <END_VULN> protected: <NEW_LINE> nsrefcnt mRefCnt ; <NEW_LINE> } ; <NEW_LINE> struct Image : public URL {
static void locationWithExceptionAttributeSetter ( v8::Local < v8::Value > jsValue , const v8::PropertyCallbackInfo < void > & info ) <NEW_LINE> { <NEW_LINE> TestObjectPython * proxyImp = V8TestObjectPython::toNative ( info . Holder ( ) ) ; <NEW_LINE> <START_VULN> TestNode * imp = WTF::getPtr ( proxyImp -> locationWithException ( ) ) ; <NEW_LINE> <END_VULN> if ( ! imp ) <NEW_LINE> return ; <NEW_LINE> V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID ( V8StringResource < > , cppValue , jsValue ) ;
{ <NEW_LINE> nsListBoxBodyFrame * listBoxBodyFrame = <NEW_LINE> MaybeGetListBoxBodyFrame ( aContainer , aChild ) ; <NEW_LINE> if ( listBoxBodyFrame ) { <NEW_LINE> if ( aOperation == CONTENT_REMOVED ) { <NEW_LINE> if ( ! aChildFrame || aChildFrame -> GetParent ( ) == listBoxBodyFrame ) { <NEW_LINE> <START_VULN> listBoxBodyFrame -> OnContentRemoved ( aPresContext , aChildFrame , <NEW_LINE>aIndexInContainer ) ; <NEW_LINE> <END_VULN> return PR_TRUE ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> listBoxBodyFrame -> OnContentInserted ( aPresContext , aChild ) ; <NEW_LINE> return PR_TRUE ;
int linenoiseHistorySave ( const char * filename ) { <NEW_LINE> <START_VULN> FILE * fp = fopen ( filename , "wt" ) ; <NEW_LINE> <END_VULN> if ( fp == NULL ) { <NEW_LINE> return - 1 ; <NEW_LINE> }
#undef DEFINE_EMPTY_PROTOCOL <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
size_t length ; <NEW_LINE> gchar * ret = NULL ; <NEW_LINE> <START_VULN> f = fopen ( filepath , "rb" ) ; <NEW_LINE> <END_VULN> if ( f ) { <NEW_LINE> fseek ( f , 0 , SEEK_END ) ; <NEW_LINE> length = ( size_t ) ftell ( f ) ;
mAdvances [ i ] = partialWidthArray [ i ] - lastWidth ; <NEW_LINE> lastWidth = partialWidthArray [ i ] ; <NEW_LINE> mOffsets [ i ] . du = mOffsets [ i ] . dv = 0 ; <NEW_LINE> } <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> HRESULT Place ( ) { <NEW_LINE> <START_VULN> mOffsets . SetLength ( mNumGlyphs ) ; <NEW_LINE>mAdvances . SetLength ( mNumGlyphs ) ; <NEW_LINE> <END_VULN> if ( mForceGDIPlace ) <NEW_LINE> return PlaceGDI ( ) ; <NEW_LINE> PRBool allCJK = PR_TRUE ;
int tox , toy ; <NEW_LINE> int ncR , ncG , ncB ; <NEW_LINE> toy = dstY ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( y = srcY ; y < ( srcY + h ) ; y ++ ) { <NEW_LINE> tox = dstX ; <NEW_LINE> for ( x = srcX ; x < ( srcX + w ) ; x ++ ) {
static PRBool sIsInitialized ; <NEW_LINE> static PRBool sDidShutdown ; <NEW_LINE> static PRInt32 sContextCount ; <NEW_LINE> static PRTime sMaxScriptRunTime ; <NEW_LINE> static PRTime sMaxChromeScriptRunTime ; <NEW_LINE> <START_VULN> static nsIScriptSecurityManager * sSecurityManager ; <NEW_LINE> <END_VULN> static nsICollation * gCollation ; <NEW_LINE> static nsIUnicodeDecoder * gDecoder ;
new_images = RemoveFirstImageFromList ( images ) ; <NEW_LINE> source_image = RemoveFirstImageFromList ( images ) ; <NEW_LINE> if ( source_image == ( Image * ) NULL ) <NEW_LINE> <START_VULN> break ; <NEW_LINE> <END_VULN> if ( source_image -> geometry != ( char * ) NULL )
<START_VULN> static void _php_mb_regex_set_options ( OnigOptionType options , OnigSyntaxType * syntax , OnigOptionType * prev_options , OnigSyntaxType ** prev_syntax TSRMLS_DC ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( prev_options != NULL ) { <NEW_LINE> * prev_options = MBREX ( regex_default_options ) ;
case SEI_USER_DATA_REGISTERED_ITU_T_T35: <NEW_LINE> ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; <NEW_LINE> <START_VULN> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <NEW_LINE>u4_payload_size ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> default:
png_free ( png_ptr , new_palette . entries ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_READ_tRNS_SUPPORTED <NEW_LINE> void
nsIDocument * document = GetOwnerDoc ( ) ; <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> <START_VULN> if ( document && ( win = document -> GetInnerWindow ( ) ) ) { <NEW_LINE> <END_VULN> nsCOMPtr < nsPIDOMEventTarget > piTarget ( do_QueryInterface ( win ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( piTarget , NS_ERROR_FAILURE ) ;
temp_area + i * dest_pitch , 1 , hratio , dest_width ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
bytesRead = offset ; <NEW_LINE> <START_VULN> SkAutoFree buffer ( sk_malloc_flags ( size , 0 ) ) ; <NEW_LINE> <END_VULN> if ( ! buffer ) { <NEW_LINE> SkCodecPrintf ( "Warning: OOM trying to create embedded stream . \n" ) ; <NEW_LINE> break ;
memset ( & ifr , 0 , sizeof ( ifr ) ) ; <NEW_LINE> strncpy ( ifr . ifr_name , devname , IFNAMSIZ - 1 ) ; <NEW_LINE> <START_VULN> err = ioctl ( sk , SIOCGIFHWADDR , & ifr ) ; <NEW_LINE> <END_VULN> if ( err < 0 ) <NEW_LINE> { <NEW_LINE> BTIF_TRACE_ERROR ( "Could not get network hardware for interface: % s , errno: % s" , devname , strerror ( errno ) ) ;
req::vector < String > sitems ; <NEW_LINE> sitems . reserve ( size ) ; <NEW_LINE> <START_VULN> int len = 0 ; <NEW_LINE>int lenDelim = delim . size ( ) ; <NEW_LINE> <END_VULN> for ( ArrayIter iter ( items ) ; iter ; ++ iter ) { <NEW_LINE> sitems . emplace_back ( iter . second ( ) . toString ( ) ) ; <NEW_LINE> len += sitems . back ( ) . size ( ) + lenDelim ;
if ( limit_val != - 1 ) <NEW_LINE> limit_val -- ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> last_match = & subject [ offsets [ 1 ] ] ; <NEW_LINE> next_offset = offsets [ 1 ] ;
vi -> background_blue = b ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> else <NEW_LINE> <END_VULN> vi -> do_background = 0 ; <NEW_LINE> if ( vi -> do_background == 0 )
: base_ ( other . base_ ) , <NEW_LINE> extent_ ( other . extent_ ) , <NEW_LINE> affinity_ ( other . affinity_ ) , <NEW_LINE> <START_VULN> is_directional_ ( other . is_directional_ ) , <NEW_LINE>is_handle_visible_ ( other . is_handle_visible_ ) <NEW_LINE> <END_VULN> #if DCHECK_IS_ON ( ) <NEW_LINE> , <NEW_LINE> dom_tree_version_ ( other . dom_tree_version_ )
_preextrapolate_helper ( v ) ; <NEW_LINE> [ at least ] a few full blocks of zeroes at the end . * / <NEW_LINE> <START_VULN> vorbis_analysis_buffer ( v , ci -> blocksizes [ 1 ] * 3 ) ; <NEW_LINE> <END_VULN> v -> eofflag = v -> pcm_current ; <NEW_LINE> v -> pcm_current += ci -> blocksizes [ 1 ] * 3 ; <NEW_LINE> for ( i = 0 ; i < vi -> channels ; i ++ ) { <NEW_LINE> if ( v -> eofflag > order * 2 ) { <NEW_LINE> long n ;
RenderBox ( Node * ) ; <NEW_LINE> virtual ~ RenderBox ( ) ; <NEW_LINE> <START_VULN> virtual bool requiresLayer ( ) const OVERRIDE { return isRoot ( ) || isPositioned ( ) || isRelPositioned ( ) || isTransparent ( ) || hasOverflowClip ( ) || hasTransform ( ) || hasHiddenBackface ( ) || hasMask ( ) || hasReflection ( ) || hasFilter ( ) || style ( ) -> specifiesColumns ( ) ; } <NEW_LINE> <END_VULN> RenderBox * firstChildBox ( ) const ;
class MenuButton ; <NEW_LINE> } <NEW_LINE> <START_VULN> class BeforeTranslateInfoBar <NEW_LINE>: public TranslateInfoBarBase , <NEW_LINE>public views::ViewMenuDelegate { <NEW_LINE> <END_VULN> public: <NEW_LINE> explicit BeforeTranslateInfoBar ( TranslateInfoBarDelegate * delegate ) ; <NEW_LINE> virtual ~ BeforeTranslateInfoBar ( ) ;
static void copyMono8 ( <NEW_LINE> short * dst , <NEW_LINE> <START_VULN> const int * const * src , <NEW_LINE> <END_VULN> unsigned nSamples , <NEW_LINE> unsigned ) { <NEW_LINE> for ( unsigned i = 0 ; i < nSamples ; ++ i ) {
const struct scale_factors * sf ) { <NEW_LINE> if ( src != NULL ) { <NEW_LINE> int i ; <NEW_LINE> <START_VULN> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <NEW_LINE>src -> alpha_buffer } ; <NEW_LINE>const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <NEW_LINE>src -> alpha_stride } ; <NEW_LINE><NEW_LINE> <END_VULN> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { <NEW_LINE> struct macroblockd_plane * const pd = & xd -> plane [ i ] ; <NEW_LINE> setup_pred_plane ( & pd -> pre [ idx ] , buffers [ i ] , strides [ i ] , mi_row , mi_col ,
mpz_mod ( u1 , u1 , key -> q ) ; <NEW_LINE> mpz_mul ( u2 , r , w ) ; <NEW_LINE> mpz_mod ( u2 , u2 , key -> q ) ; <NEW_LINE> <START_VULN> mpz_powm ( v1 , key -> g , u1 , key -> p ) ; <NEW_LINE>mpz_powm ( v2 , key -> y , u2 , key -> p ) ; <NEW_LINE> <END_VULN> mpz_mul ( w , v1 , v2 ) ; <NEW_LINE> mpz_mod ( w , w , key -> p ) ; <NEW_LINE> mpz_mod ( w , w , key -> q ) ;
ClearVisitingFlag ( data [ n ] ) ; <NEW_LINE> data = f -> linkedTrees . data ( ) ; <NEW_LINE> length = f -> linkedTrees . length ( ) ; <NEW_LINE> for ( unsigned n = 0 ; n < length ; ++ n ) <NEW_LINE> ClearVisitingFlag ( data [ n ] ) ; <NEW_LINE> } <NEW_LINE> static bool <NEW_LINE> <START_VULN> HasUnreachableGCThings ( JSContext * cx , TreeFragment * f ) <NEW_LINE> { <NEW_LINE>bool hasUnrechable = HasUnreachableGCThingsImpl ( cx , f ) ; <NEW_LINE> <END_VULN> ClearVisitingFlag ( f ) ; <NEW_LINE> return hasUnrechable ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> TraceMonitor::sweep ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( ! ontrace ( ) ) ; <NEW_LINE> debug_only_print0 ( LC_TMTracer , "Purging fragments with dead things" ) ;
#include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> <START_VULN> #include "arm . h" <NEW_LINE> <END_VULN> static int arm_cpu_env_flags ( int * flags ) { <NEW_LINE> char * env ;
<START_VULN> Copyright ( c ) 2013 , The Linux Foundation . All rights reserved . <NEW_LINE> <END_VULN> Redistribution and use in source and binary forms , with or without <NEW_LINE> modification , are permitted provided that the following conditions are met:
<START_VULN> nsCOMPtr < nsIContent > content = <NEW_LINE>do_QueryInterface ( static_cast < nsIDOMHTMLCanvasElement * > ( mCanvasElement ) ) ; <NEW_LINE> <END_VULN> if ( ! content && ! mDocShell ) { <NEW_LINE> NS_WARNING ( "Canvas element must be an nsIContent and non - null or a docshell must be provided" ) ; <NEW_LINE> return NS_ERROR_FAILURE ;
#include < stddef . h > <NEW_LINE> #include < utility > <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "mojo / public / cpp / bindings / lib / array_internal . h" <NEW_LINE> #include "mojo / public / cpp / bindings / lib / bindings_internal . h" <NEW_LINE> #include "mojo / public / cpp / bindings / lib / template_util . h"
exit ( 1 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <NEW_LINE> <END_VULN> fprintf ( stdout , "BT adapter is up\n" ) ; <NEW_LINE> int rc = bt_interface -> create_bond ( & bt_remote_bdaddr , 0 ) ;
else if ( i > 15 && ( ! strncasecmp ( buf , "content - length:" , 15 ) ) ) { <NEW_LINE> sb = buf + 15 ; <NEW_LINE> while ( isspace ( * sb ) ) sb ++ ; <NEW_LINE> <START_VULN> contentlen = atoi ( sb ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else if ( i > 13 && ( ! strncasecmp ( buf , "content - type:" , 13 ) ) ) { <NEW_LINE> sb = buf + 13 ;
} <NEW_LINE> if ( ref_frame == INTRA_FRAME ) { <NEW_LINE> <START_VULN> if ( ! ( intra_y_mode_mask & ( 1 << this_mode ) ) ) <NEW_LINE>continue ; <NEW_LINE> <END_VULN> if ( this_mode != DC_PRED ) {
Codec codec , <NEW_LINE> VideoCodecProfile video_profile , <NEW_LINE> uint8_t video_level , <NEW_LINE> <START_VULN> gfx::ColorSpace::TransferID eotf , <NEW_LINE> <END_VULN> bool is_encrypted ) const ;
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> DOMStringList * arrayArg ( toDOMStringList ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
} ; <NEW_LINE> template < > struct APIClientTraits < WKBundlePageLoaderClient > { <NEW_LINE> <START_VULN> static const size_t interfaceSizesByVersion [ 3 ] ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> template < > struct APIClientTraits < WKBundlePageResourceLoadClient > {
add_next_index_stringl ( match_pair , str , len , 1 ) ; <NEW_LINE> add_next_index_long ( match_pair , offset ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( name ) { <NEW_LINE> zval_add_ref ( & match_pair ) ; <NEW_LINE> zend_hash_update ( Z_ARRVAL_P ( result ) , name , strlen ( name ) + 1 , & match_pair , sizeof ( zval * ) , NULL ) ;
JSVersion version = cx -> findVersion ( ) ; <NEW_LINE> nsCAutoString cachePath ; <NEW_LINE> cachePath . AppendPrintf ( "jssubloader / % d" , version ) ; <NEW_LINE> NS_PathifyURI ( uri , cachePath ) ; <NEW_LINE> if ( cache ) <NEW_LINE> rv = ReadCachedScript ( cache , cachePath , cx , & scriptObj ) ; <NEW_LINE> if ( ! scriptObj ) { <NEW_LINE> <START_VULN> rv = ReadScript ( uri , cx , target_obj , charset , ( char * ) uriStr . get ( ) , serv , & scriptObj ) ; <NEW_LINE> <END_VULN> writeScript = true ; <NEW_LINE> } <NEW_LINE> if ( NS_FAILED ( rv ) || ! scriptObj ) <NEW_LINE> return rv ; <NEW_LINE> ok = false ; <NEW_LINE> if ( scriptObj )
if ( ! result ) <NEW_LINE> result = x ; <NEW_LINE> <START_VULN> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> op = ( REOp ) * pc ++ ; <NEW_LINE> continue ;
intl_error_reset ( NULL TSRMLS_CC ) ; <NEW_LINE> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "s | s" , <NEW_LINE> <START_VULN> & loc_name , & loc_name_len , <NEW_LINE> <END_VULN> & disp_loc_name , & disp_loc_name_len ) == FAILURE ) <NEW_LINE> { <NEW_LINE> spprintf ( & msg , 0 , "locale_get_display_ % s : unable to parse input params" , tag_name ) ;
#define IS_XSLT_ELEM ( n ) \ <NEW_LINE> <START_VULN> ( ( ( n ) != NULL ) && ( ( n ) -> ns != NULL ) && \ <NEW_LINE> ( xmlStrEqual ( ( n ) -> ns -> href , XSLT_NAMESPACE ) ) ) <NEW_LINE> <END_VULN>
void RenderFlexibleBox::adjustAlignmentForChild ( RenderBox * child , LayoutUnit delta ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> LayoutUnit staticInlinePosition = child -> layer ( ) -> staticInlinePosition ( ) ; <NEW_LINE> LayoutUnit staticBlockPosition = child -> layer ( ) -> staticBlockPosition ( ) ; <NEW_LINE> LayoutUnit mainAxis = isColumnFlow ( ) ? staticBlockPosition : staticInlinePosition ;
std::cout << "FAILED:" ; <NEW_LINE> else <NEW_LINE> std::cout << "passed:" ; <NEW_LINE> <START_VULN> std::cout << " GenerateWord32 and Crop\n" ; <END_VULN> <NEW_LINE> <NEW_LINE> } <NEW_LINE> #endif
} <NEW_LINE> nsresult MediaOmxReader::Init ( MediaDecoderReader * aCloneDonor ) <NEW_LINE> { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult MediaOmxReader::ReadMetadata ( VideoInfo * aInfo , <NEW_LINE> <START_VULN> MetadataTags ** aTags ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ASSERTION ( mDecoder -> OnDecodeThread ( ) , "Should be on decode thread . " ) ; <NEW_LINE> * aTags = nullptr ; <NEW_LINE> if ( ! mOmxDecoder . get ( ) ) { <NEW_LINE> mOmxDecoder = new OmxDecoder ( mDecoder -> GetResource ( ) , mDecoder ) ; <NEW_LINE> mOmxDecoder -> Init ( ) ;
bool IsPointerLocked ( ) override { <NEW_LINE> return widget_test_client ( ) -> IsPointerLocked ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void DidFocus ( ) override { <NEW_LINE>view_test_client ( ) -> DidFocus ( ) ; <NEW_LINE>Base::DidFocus ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void SetToolTipText ( const blink::WebString & text , <NEW_LINE> blink::WebTextDirection hint ) override {
if ( ! rst ) <NEW_LINE> return 1 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return tor_memneq ( guard -> identity , rst -> exclude_id , DIGEST_LEN ) ; <NEW_LINE> }
max_screen_colors , histogram , 0 ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> png_set_invert_mono ( png_ptr ) ;
if ( ! parent -> isHTMLElement ( ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> RefPtr < DocumentFragment > fragment = Range::createDocumentFragmentForElement ( markup , toHTMLElement ( parent ) ) ; <NEW_LINE> <END_VULN> ExceptionCode exception = 0 ; <NEW_LINE> parent -> insertBefore ( fragment , m_element , exception ) ;
void FreeResources ( ) override ; <NEW_LINE> void CreateSensorInternal ( mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> const CreateSensorCallback & callback ) override ; <NEW_LINE> private:
UpdateChildCounts ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsContentSink::DidBuildModelImpl ( bool aTerminated ) <NEW_LINE> { <NEW_LINE> if ( mDocument ) { <NEW_LINE> <START_VULN> MOZ_ASSERT ( mDocument -> GetReadyStateEnum ( ) == <NEW_LINE> <END_VULN> nsIDocument::READYSTATE_LOADING , "Bad readyState" ) ; <NEW_LINE> mDocument -> SetReadyStateInternal ( nsIDocument::READYSTATE_INTERACTIVE ) ; <NEW_LINE> } <NEW_LINE> if ( mScriptLoader ) { <NEW_LINE> mScriptLoader -> ParsingComplete ( aTerminated ) ; <NEW_LINE> }
int res_unpack ( vorbis_info_residue * info , <NEW_LINE> <START_VULN> vorbis_info * vi , oggpack_buffer * opb ) { <NEW_LINE> <END_VULN> int j , k ; <NEW_LINE> codec_setup_info * ci = ( codec_setup_info * ) vi -> codec_setup ; <NEW_LINE> memset ( info , 0 , sizeof ( * info ) ) ;
} <NEW_LINE> sock_cmd_t cmd = { CMD_ADD_FD , fd , type , flags , user_id } ; <NEW_LINE> APPL_TRACE_DEBUG ( "adding fd: % d , flags:0x % x" , fd , flags ) ; <NEW_LINE> <START_VULN> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool btsock_thread_remove_fd_and_close ( int thread_handle , int fd )
float * ath ; <NEW_LINE> long * octave ; <NEW_LINE> long * bark ; <NEW_LINE> long firstoc ; <NEW_LINE> long shiftoc ; <NEW_LINE> int eighth_octave_lines ; <NEW_LINE> <START_VULN> int total_octave_lines ; <NEW_LINE> <END_VULN> long rate ; <NEW_LINE> float m_val ; <NEW_LINE> } vorbis_look_psy ; <NEW_LINE> extern void _vp_psy_init ( vorbis_look_psy * p , vorbis_info_psy * vi , <NEW_LINE> vorbis_info_psy_global * gi , int n , long rate ) ;
@param join String to use as the element join string . <NEW_LINE> @return String consisting of the joined hash values <NEW_LINE> @ingroup MprHash <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC char * mprHashToString ( MprHash * hash , cchar * join ) ;
} <NEW_LINE> mask = CloneImage ( image , layer_info -> mask . page . width , <NEW_LINE> layer_info -> mask . page . height , MagickFalse , exception ) ; <NEW_LINE> <START_VULN> mask -> matte = MagickFalse ; <NEW_LINE>channel_image = mask ; <NEW_LINE> <END_VULN> } <NEW_LINE> offset = TellBlob ( image ) ;
Element * element = getNode ( ) -> isElementNode ( ) ? toElement ( getNode ( ) ) <NEW_LINE> : getNode ( ) -> parentElement ( ) ; <NEW_LINE> if ( ! getLayoutObject ( ) && ( ! element || ! element -> isInCanvasSubtree ( ) ) && <NEW_LINE> <START_VULN> ! equalIgnoringCase ( getAttribute ( aria_hiddenAttr ) , "false" ) ) { <NEW_LINE> <END_VULN> if ( ignoredReasons ) <NEW_LINE> ignoredReasons -> push_back ( IgnoredReason ( AXNotRendered ) ) ; <NEW_LINE> return true ;
js::gc::MarkStringUnbarriered ( trc , & d . u1 . left , "left child" ) ; <NEW_LINE> js::gc::MarkStringUnbarriered ( trc , & d . s . u2 . right , "right child" ) ; <NEW_LINE> } <NEW_LINE> JS_ALWAYS_INLINE void <NEW_LINE> JSDependentString::init ( JSLinearString * base , const jschar * chars , size_t length ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( ! js::IsPoisonedPtr ( base ) ) ; <NEW_LINE> <START_VULN> d . lengthAndFlags = buildLengthAndFlags ( length , DEPENDENT_BIT ) ; <NEW_LINE> <END_VULN> d . u1 . chars = chars ; <NEW_LINE> d . s . u2 . base = base ; <NEW_LINE> JSString::writeBarrierPost ( d . s . u2 . base , & d . s . u2 . base ) ; <NEW_LINE> } <NEW_LINE> JS_ALWAYS_INLINE JSDependentString * <NEW_LINE> JSDependentString::new_ ( JSContext * cx , JSLinearString * base_ , const jschar * chars , size_t length ) <NEW_LINE> {
return ; <NEW_LINE> fprintf ( stderr , "Stream % d PSNR ( Overall / Avg / Y / U / V ) " , stream -> index ) ; <NEW_LINE> <START_VULN> ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , 255 . 0 , <NEW_LINE> <END_VULN> ( double ) stream -> psnr_sse_total ) ; <NEW_LINE> fprintf ( stderr , " % . 3f" , ovpsnr ) ;
jsval jsData ; <NEW_LINE> nsresult rv = aData -> GetAsJSVal ( & jsData ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , NS_ERROR_UNEXPECTED ) ; <NEW_LINE> JSAutoRequest ar ( aCx ) ; <NEW_LINE> JSAutoCompartment ac ( aCx , JS_GetGlobalObject ( aCx ) ) ; <NEW_LINE> JS_WrapValue ( aCx , & jsData ) ; <NEW_LINE> <START_VULN> nsCxPusher cxPusher ; <NEW_LINE>cxPusher . Push ( aCx , nsCxPusher::REQUIRE_SCRIPT_CONTEXT ) ; <NEW_LINE><NEW_LINE> <END_VULN> uint64_t * jsBytes = nullptr ; <NEW_LINE> bool success = JS_WriteStructuredClone ( aCx , jsData , & jsBytes , & mSize , <NEW_LINE> nullptr , nullptr , JSVAL_VOID ) ; <NEW_LINE> NS_ENSURE_STATE ( success ) ; <NEW_LINE> NS_ENSURE_STATE ( jsBytes ) ; <NEW_LINE> mData = ( uint64_t * ) malloc ( mSize ) ;
LayerTreeContext m_layerTreeContext ; <NEW_LINE> bool m_shouldSyncFrame ; <NEW_LINE> bool m_shouldSyncRootLayer ; <NEW_LINE> <START_VULN> void layerFlushTimerFired ( WebCore::Timer < LayerTreeCoordinator > * ) ; <NEW_LINE> <END_VULN> WebCore::Timer < LayerTreeCoordinator > m_layerFlushTimer ; <NEW_LINE> bool m_layerFlushSchedulingEnabled ; <NEW_LINE> uint64_t m_forceRepaintAsyncCallbackID ; <NEW_LINE> } ;
class nsWSAdmissionManager <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> <START_VULN> nsWSAdmissionManager ( ) : mConnectedCount ( 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> MOZ_COUNT_CTOR ( nsWSAdmissionManager ) ; <NEW_LINE> } <NEW_LINE> class nsOpenConn <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> nsOpenConn ( nsCString & addr , WebSocketChannel * channel )
int vp9_get_intra_inter_context ( const MACROBLOCKD * xd ) { <NEW_LINE> <START_VULN> const MB_MODE_INFO * const above_mbmi = get_mbmi ( get_above_mi ( xd ) ) ; <NEW_LINE>const MB_MODE_INFO * const left_mbmi = get_mbmi ( get_left_mi ( xd ) ) ; <NEW_LINE>const int has_above = above_mbmi != NULL ; <NEW_LINE>const int has_left = left_mbmi != NULL ; <NEW_LINE> <END_VULN> if ( has_above && has_left ) { <NEW_LINE> const int above_intra = ! is_inter_block ( above_mbmi ) ;
PRPackedBool mValid ; <NEW_LINE> PRPackedBool mOpaque ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>nsHTMLCanvasElement * mCanvasElement ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIDocShell > mDocShell ;
if ( ! result ) <NEW_LINE> result = x ; <NEW_LINE> <START_VULN> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> pc += GET_OFFSET ( pc ) ; <NEW_LINE> op = ( REOp ) * pc ++ ; <NEW_LINE> continue ;
headers = snclone ( content , data - content ) ; <NEW_LINE> data += 2 ; <NEW_LINE> for ( header = stok ( headers , "\n" , & tok ) ; header ; header = stok ( NULL , "\n" , & tok ) ) { <NEW_LINE> <START_VULN> key = stok ( header , ": " , & value ) ; <NEW_LINE> <END_VULN> if ( smatch ( key , "X - Status" ) ) { <NEW_LINE> conn -> tx -> status = ( int ) stoi ( value ) ; <NEW_LINE> } else {
else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) <NEW_LINE> ctx -> err = VPX_CODEC_INCAPABLE ; <NEW_LINE> else <NEW_LINE> <START_VULN> pkt = ctx -> iface -> enc . get_cx_data ( ctx -> priv -> alg_priv , iter ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( pkt && pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> GetAllHelper::ReleaseMainThreadObjects ( ) <NEW_LINE> { <NEW_LINE> for ( uint32_t index = 0 ; index < mCloneReadInfos . Length ( ) ; index ++ ) { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( <NEW_LINE>mCloneReadInfos [ index ] . mCloneBuffer ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> GetKeyHelper::ReleaseMainThreadObjects ( ) ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> GetAllHelper::PackArgumentsForParentProcess ( IndexRequestParams & aParams ) <NEW_LINE> { <NEW_LINE> FIXME_Bug_521898_index::GetAllParams params ;
const_iterator default_match ( ) const { return default_match_ ; } <NEW_LINE> <START_VULN> GURL alternate_nav_url ( ) const { return alternate_nav_url_ ; } <NEW_LINE> <END_VULN> void Reset ( ) ;
{ <NEW_LINE> while ( ! iterator . atEnd ( ) && ! requiresLineBox ( iterator , lineInfo , TrailingWhitespace ) ) { <NEW_LINE> RenderObject * object = iterator . m_obj ; <NEW_LINE> <START_VULN> if ( object -> isPositioned ( ) ) <NEW_LINE> <END_VULN> setStaticPositions ( m_block , toRenderBox ( object ) ) ; <NEW_LINE> else if ( object -> isFloating ( ) ) <NEW_LINE> m_block -> insertFloatingObject ( toRenderBox ( object ) ) ;
void vp8_setup_intra_recon_top_line ( YV12_BUFFER_CONFIG * ybf ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ; <NEW_LINE>vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <NEW_LINE>vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <NEW_LINE> <END_VULN> }
if ( ! my_login ( aTHX_ dbh , imp_dbh ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , <NEW_LINE>mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; <NEW_LINE> <END_VULN> return FALSE ; <NEW_LINE> }
case OMX_IndexParamPriorityMgmt: <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> OMX_PRIORITYMGMTTYPE * priorityMgmType = ( OMX_PRIORITYMGMTTYPE * ) paramData ; <NEW_LINE> DEBUG_PRINT_LOW ( "get_parameter: OMX_IndexParamPriorityMgmt" ) ; <NEW_LINE> memcpy ( priorityMgmType , & m_sPriorityMgmt , sizeof ( m_sPriorityMgmt ) ) ;
char * vorbis_comment_query ( vorbis_comment * vc , const char * tag , int count ) { <NEW_LINE> long i ; <NEW_LINE> int found = 0 ; <NEW_LINE> int taglen = strlen ( tag ) + 1 ; <NEW_LINE> char * fulltag = alloca ( taglen + 1 ) ; <NEW_LINE> strcpy ( fulltag , tag ) ; <NEW_LINE> strcat ( fulltag , " = " ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( i = 0 ; i < vc -> comments ; i ++ ) { <NEW_LINE> if ( ! tagcompare ( vc -> user_comments [ i ] , fulltag , taglen ) ) { <NEW_LINE> if ( count == found ) <NEW_LINE> return vc -> user_comments [ i ] + taglen ; <NEW_LINE> else <NEW_LINE> found ++ ; <NEW_LINE> }
m_waitingForCompositorAnimationStart . append ( m_pending [ i ] . first ) ; <NEW_LINE> } else { <NEW_LINE> for ( size_t i = 0 ; i < m_pending . size ( ) ; ++ i ) <NEW_LINE> <START_VULN> m_pending [ i ] . first -> setStartTime ( m_pending [ i ] . second ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> m_pending . clear ( ) ;
struct file ; <NEW_LINE> struct perf_sample_data ; <NEW_LINE> <START_VULN> typedef void ( * perf_overflow_handler_t ) ( struct perf_event * , int , <NEW_LINE> <END_VULN> struct perf_sample_data * , <NEW_LINE> struct pt_regs * regs ) ;
{ <NEW_LINE> } <NEW_LINE> } ; <NEW_LINE> <START_VULN> TEST_F ( CCLayerTreeHostTestShortlived1 , run ) <NEW_LINE> { <NEW_LINE>runTest ( ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> class CCLayerTreeHostTestShortlived2 : public CCLayerTreeHostTest {
uint8_t pin_len , bt_pin_code_t * pin_code ) <NEW_LINE> { <NEW_LINE> BTIF_TRACE_EVENT ( " % s: accept = % d" , __FUNCTION__ , accept ) ; <NEW_LINE> <START_VULN> if ( pin_code == NULL ) <NEW_LINE> <END_VULN> return BT_STATUS_FAIL ; <NEW_LINE> #if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) )
& tgt -> transited , & et , <NEW_LINE> krb5_principal_get_realm ( context , client_principal ) , <NEW_LINE> krb5_principal_get_realm ( context , server -> entry . principal ) , <NEW_LINE> <START_VULN> krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ; <NEW_LINE> <END_VULN> if ( ret ) <NEW_LINE> goto out ;
return BT_STATUS_SUCCESS ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int enable ( void ) { <NEW_LINE>LOG_INFO ( " % s" , __func__ ) ; <NEW_LINE> <END_VULN> if ( ! interface_ready ( ) ) <NEW_LINE> return BT_STATUS_NOT_READY ;
std::vector < std::wstring > TokenizeCommandLineToArray ( <NEW_LINE> const std::wstring & command_line ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> std::wstring GetSwitchValueFromCommandLine ( const std::wstring & command_line , <NEW_LINE> const std::wstring & switch_name ) ;
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> RefPtr < EntrySyncCallbackHelper > resolveURLHelper = EntrySyncCallbackHelper::create ( ) ; <NEW_LINE> <END_VULN> OwnPtr < AsyncFileSystemCallbacks > callbacks = ResolveURICallbacks::create ( resolveURLHelper -> successCallback ( ) , resolveURLHelper -> errorCallback ( ) , & worker ) ; <NEW_LINE> callbacks -> setShouldBlockUntilCompletion ( true ) ;
#ifdef PNG_READ_iCCP_SUPPORTED <NEW_LINE> PNG_INTERNAL_FUNCTION ( void , png_handle_iCCP , ( png_structrp png_ptr , <NEW_LINE> png_inforp info_ptr , png_uint_32 length ) , PNG_EMPTY ) ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_READ_iTXt_SUPPORTED <NEW_LINE> PNG_INTERNAL_FUNCTION ( void , png_handle_iTXt , ( png_structrp png_ptr ,
for ( iptr = 0 ; iptr < info_ptr -> height ; iptr ++ ) <NEW_LINE> info_ptr -> row_pointers [ iptr ] = png_voidcast ( png_bytep , <NEW_LINE> <START_VULN> png_malloc ( png_ptr , info_ptr -> rowbytes ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> png_read_image ( png_ptr , info_ptr -> row_pointers ) ;
uint32_t nsMutationGuard::sMutationCount = 0 ; <NEW_LINE> nsIContent * <NEW_LINE> nsIContent::FindFirstNonNativeAnonymous ( ) const <NEW_LINE> { <NEW_LINE> for ( const nsIContent * content = this ; content ; <NEW_LINE> content = content -> GetBindingParent ( ) ) { <NEW_LINE> <START_VULN> if ( ! content -> IsInNativeAnonymousSubtree ( ) ) { <NEW_LINE> <END_VULN> return const_cast < nsIContent * > ( content ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return nullptr ; <NEW_LINE> }
if ( clone_info -> stroke_pattern != ( Image * ) NULL ) <NEW_LINE> clone_info -> fill_pattern = CloneImage ( clone_info -> stroke_pattern , 0 , 0 , <NEW_LINE> MagickTrue , exception ) ; <NEW_LINE> <START_VULN> clone_info -> stroke . alpha = ( Quantum ) TransparentAlpha ; <NEW_LINE> <END_VULN> clone_info -> stroke_width = 0 . 0 ; <NEW_LINE> clone_info -> fill_rule = NonZeroRule ; <NEW_LINE> status = MagickTrue ;
JSFunctionSpec * fs ; <NEW_LINE> JSObject * tmp ; <NEW_LINE> if ( ! JS_GetReservedSlot ( cx , JSVAL_TO_OBJECT ( argv [ - 2 ] ) , 0 , & fsv ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> fs = ( JSFunctionSpec * ) JSVAL_TO_PRIVATE ( fsv ) ; <NEW_LINE> JS_ASSERT ( ( fs -> flags & ( JSFUN_FAST_NATIVE | JSFUN_GENERIC_NATIVE ) ) == <NEW_LINE> JSFUN_GENERIC_NATIVE ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( JSVAL_IS_PRIMITIVE ( argv [ 0 ] ) ) { <NEW_LINE> if ( ! js_ValueToObject ( cx , argv [ 0 ] , & tmp ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> argv [ 0 ] = OBJECT_TO_JSVAL ( tmp ) ; <NEW_LINE> }
{ <NEW_LINE> struct nfs4_opendata * opendata ; <NEW_LINE> <START_VULN> opendata = nfs4_opendata_alloc ( & ctx -> path , state -> owner , 0 , NULL ) ; <NEW_LINE> <END_VULN> if ( opendata == NULL ) <NEW_LINE> return ERR_PTR ( - ENOMEM ) ; <NEW_LINE> opendata -> state = state ;
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> UpgradeSchemaFrom10_0To11_0 ( mozIStorageConnection * aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "UpgradeSchemaFrom10_0To11_0" ) ; <NEW_LINE> nsresult rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( <NEW_LINE> "CREATE TEMPORARY TABLE temp_upgrade ( " <NEW_LINE> "id , " <NEW_LINE> "object_store_id , "
void DestroyRows ( PRInt32 & aRowsToLose ) ; <NEW_LINE> void ReverseDestroyRows ( PRInt32 & aRowsToLose ) ; <NEW_LINE> nsIBox * GetFirstItemBox ( PRInt32 aOffset , PRBool * aCreated ) ; <NEW_LINE> nsIBox * GetNextItemBox ( nsIBox * aBox , PRInt32 aOffset , PRBool * aCreated ) ; <NEW_LINE> PRBool ContinueReflow ( nscoord height ) ; <NEW_LINE> NS_IMETHOD ListBoxAppendFrames ( nsFrameList & aFrameList ) ; <NEW_LINE> NS_IMETHOD ListBoxInsertFrames ( nsIFrame * aPrevFrame , nsFrameList & aFrameList ) ; <NEW_LINE> void OnContentInserted ( nsPresContext * aPresContext , nsIContent * aContent ) ; <NEW_LINE> <START_VULN> void OnContentRemoved ( nsPresContext * aPresContext , nsIFrame * aChildFrame , PRInt32 aIndex ) ; <NEW_LINE> <END_VULN> void GetListItemContentAt ( PRInt32 aIndex , nsIContent ** aContent ) ; <NEW_LINE> void GetListItemNextSibling ( nsIContent * aListItem , nsIContent ** aContent , PRInt32 & aSiblingIndex ) ; <NEW_LINE> void PostReflowCallback ( ) ; <NEW_LINE> PRBool SetBoxObject ( nsPIBoxObject * aBoxObject ) <NEW_LINE> {
* ( element ++ ) = end ; <NEW_LINE> for ( int i = 0 ; i < NUM_VERTEX_DECL_CACHE_ENTRIES ; i ++ ) <NEW_LINE> { <NEW_LINE> VertexDeclCacheEntry * entry = & mVertexDeclCache [ i ] ; <NEW_LINE> if ( memcmp ( entry -> cachedElements , elements , ( element - elements ) * sizeof ( D3DVERTEXELEMENT9 ) ) == 0 && entry -> vertexDeclaration ) <NEW_LINE> { <NEW_LINE> entry -> lruCount = ++ mMaxLru ; <NEW_LINE> <START_VULN> device -> SetVertexDeclaration ( entry -> vertexDeclaration ) ; <NEW_LINE><NEW_LINE> <END_VULN> return GL_NO_ERROR ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> VertexDeclCacheEntry * lastCache = mVertexDeclCache ; <NEW_LINE> for ( int i = 0 ; i < NUM_VERTEX_DECL_CACHE_ENTRIES ; i ++ ) <NEW_LINE> {
if ( yych <= '9' ) goto yy91 ; <NEW_LINE> if ( yych != ' ; ' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 520 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> long id ;
static inline quint32 swapBgrToRgb ( quint32 pixel ) <NEW_LINE> { <NEW_LINE> <START_VULN> return ( ( pixel << 16 ) & 0xff0000 ) | ( ( pixel >> 16 ) & 0xff ) | ( pixel & 0xff00ff00 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #if USE ( ACCELERATED_COMPOSITING )
die ( "Weird page fault" , regs , SIGSEGV ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN>
NS_IF_ADDREF ( * aCrypto = mCrypto ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsGlobalWindow::GetPkcs11 ( nsIDOMPkcs11 ** aPkcs11 ) <NEW_LINE> { <NEW_LINE> <START_VULN> FORWARD_TO_OUTER ( GetPkcs11 , ( aPkcs11 ) , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE><NEW_LINE>if ( ! mPkcs11 ) { <NEW_LINE>mPkcs11 = do_CreateInstance ( kPkcs11ContractID ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>NS_IF_ADDREF ( * aPkcs11 = mPkcs11 ) ; <NEW_LINE><NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsGlobalWindow::GetControllers ( nsIControllers ** aResult ) <NEW_LINE> { <NEW_LINE> FORWARD_TO_OUTER ( GetControllers , ( aResult ) , NS_ERROR_NOT_INITIALIZED ) ;
} <NEW_LINE> JSContext * cx = scx ? scx -> GetNativeContext ( ) : nullptr ; <NEW_LINE> <START_VULN> return Push ( cx , ASSERT_SCRIPT_CONTEXT ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> nsCxPusher::RePush ( nsIDOMEventTarget * aCurrentTarget ) <NEW_LINE> { <NEW_LINE> if ( ! mPushedSomething ) { <NEW_LINE> return Push ( aCurrentTarget ) ; <NEW_LINE> }
int32 page_id_ ; <NEW_LINE> GURL url_ ; <NEW_LINE> GURL icon_url_ ; <NEW_LINE> <START_VULN> NotificationRegistrar registrar_ ; <NEW_LINE> <END_VULN>
void GetOverflowItems ( std::vector < LauncherItem > * items ) ; <NEW_LINE> <START_VULN> void ShowOverflowMenu ( ) ; <NEW_LINE> <END_VULN>
if ( ! argAtom || ! bindings . addArgument ( cx , argAtom , & dummy ) ) <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> JSFunction * fun = js_NewFunction ( cx , NULL , NULL , 0 , JSFUN_INTERPRETED , obj , funAtom ) ; <NEW_LINE> if ( ! fun ) <NEW_LINE> return NULL ; <NEW_LINE> <START_VULN> if ( ! frontend::CompileFunctionBody ( cx , fun , principals , & bindings , chars , length , <NEW_LINE>filename , lineno , version ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> if ( obj && funAtom && <NEW_LINE> ! obj -> defineGeneric ( cx , ATOM_TO_JSID ( funAtom ) , ObjectValue ( * fun ) , NULL , NULL , <NEW_LINE> JSPROP_ENUMERATE ) ) <NEW_LINE> {
return NS_ERROR_FAILURE ; <NEW_LINE> nsCOMPtr < nsIHttpChannel > httpChannel = do_QueryInterface ( mChannel ) ; <NEW_LINE> if ( ! httpChannel ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>bool privileged ; <NEW_LINE>if ( NS_FAILED ( IsCapabilityEnabled ( "UniversalXPConnect" , & privileged ) ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>if ( ! privileged ) { <NEW_LINE> <END_VULN> static const char * kInvalidHeaders [ ] = { <NEW_LINE> "accept - charset" , "accept - encoding" , "access - control - request - headers" , <NEW_LINE> "access - control - request - method" , "connection" , "content - length" , <NEW_LINE> "cookie" , "cookie2" , "content - transfer - encoding" , "date" , "dnt" , <NEW_LINE> "expect" , "host" , "keep - alive" , "origin" , "referer" , "te" , "trailer" , <NEW_LINE> "transfer - encoding" , "upgrade" , "user - agent" , "via" <NEW_LINE> } ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> UpgradeSchemaFrom12_0To13_0 ( mozIStorageConnection * aConnection , <NEW_LINE> bool * aVacuumNeeded ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "UpgradeSchemaFrom12_0To13_0" ) ; <NEW_LINE> nsresult rv ; <NEW_LINE> #if defined ( MOZ_WIDGET_ANDROID ) || defined ( MOZ_WIDGET_GONK ) <NEW_LINE> int32_t defaultPageSize ;
} <NEW_LINE> return ; <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " [ | icmp6 ] " ) ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
bool stretchesToViewport ( ) const <NEW_LINE> { <NEW_LINE> <START_VULN> return document ( ) -> inQuirksMode ( ) && style ( ) -> logicalHeight ( ) . isAuto ( ) && ! isFloatingOrPositioned ( ) && ( isRoot ( ) || isBody ( ) ) && ! document ( ) -> shouldDisplaySeamlesslyWithParent ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> virtual IntSize intrinsicSize ( ) const { return IntSize ( ) ; }
#ifdef USE_XIM <NEW_LINE> void <NEW_LINE> nsWindow::IMEInitData ( void ) <NEW_LINE> { <NEW_LINE> if ( mIMEData ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> nsWindow * win = IMEGetOwningWindow ( ) ; <NEW_LINE> <END_VULN> if ( ! win ) <NEW_LINE> return ; <NEW_LINE> mIMEData = win -> mIMEData ; <NEW_LINE> if ( ! mIMEData ) <NEW_LINE> return ; <NEW_LINE> mIMEData -> mRefCount ++ ; <NEW_LINE> }
<START_VULN> SyncBackendHost ( SyncFrontend * frontend , <NEW_LINE>Profile * profile , <NEW_LINE>const FilePath & profile_path , <NEW_LINE>const DataTypeController::TypeMap & data_type_controllers ) ; <NEW_LINE> <END_VULN> SyncBackendHost ( ) ;
base::TimeTicks initial_preview_start_time_ ; <NEW_LINE> <START_VULN> <NEW_LINE>std::string preview_ui_addr_str_ ; <NEW_LINE> <END_VULN> PrintPreviewHandler * handler_ ;
mImageMetadata . GetOrientation ( ) ) ; <NEW_LINE> } <NEW_LINE> void Decoder::InitInternal ( ) { } <NEW_LINE> <START_VULN> void Decoder::WriteInternal ( const char * aBuffer , uint32_t aCount ) { } <NEW_LINE> <END_VULN> void Decoder::FinishInternal ( ) { } <NEW_LINE> void <NEW_LINE> Decoder::PostSize ( int32_t aWidth ,
cur = ctxt -> context -> node ; <NEW_LINE> if ( cur == NULL ) <NEW_LINE> return ( NULL ) ; <NEW_LINE> <START_VULN> if ( cur -> type == XML_NAMESPACE_DECL ) <NEW_LINE>return ( NULL ) ; <NEW_LINE> <END_VULN> ctxt -> ancestor = cur -> parent ; <NEW_LINE> } <NEW_LINE> if ( cur -> type == XML_NAMESPACE_DECL )
Frame * frame = m_webPagePrivate -> focusedOrMainFrame ( ) ; <NEW_LINE> if ( frame && frame -> document ( ) ) { <NEW_LINE> <START_VULN> if ( frame -> document ( ) -> focusedNode ( ) && frame -> document ( ) -> focusedNode ( ) -> hasTagName ( HTMLNames::selectTag ) ) <NEW_LINE>return false ; <NEW_LINE> <END_VULN> if ( m_webPagePrivate -> m_inputHandler -> isInputMode ( ) && fromRange && toRange && ( fromRange -> startContainer ( ) == toRange -> startContainer ( ) ) )
#include "vpx / vpx_codec . h" <NEW_LINE> <START_VULN> static const char * const cfg = " -- target = armv6 - linux - gcc -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
if ( options & STREAM_WILL_CAST ) <NEW_LINE> chunk_size = php_stream_set_chunk_size ( stream , 1 ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;
while ( Z_TYPE_PP ( zdata_ptr ) == IS_ARRAY <NEW_LINE> && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & test_ptr ) <NEW_LINE> ) { <NEW_LINE> <START_VULN> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <NEW_LINE> <END_VULN> if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) {
return is_raw ; <NEW_LINE> } <NEW_LINE> <START_VULN> void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) { <NEW_LINE> <END_VULN> fprintf ( stderr , <NEW_LINE> " % d decoded frames / % d showed frames in % "PRId64" us ( % . 2f fps ) \r" , <NEW_LINE> frame_in , frame_out , dx_time ,
<START_VULN> #ifndef BASE_MAC_LIBDISPATCH_SEQUENCED_TASK_RUNNER_H_ <NEW_LINE>#define BASE_MAC_LIBDISPATCH_SEQUENCED_TASK_RUNNER_H_ <NEW_LINE> <END_VULN> #include < dispatch / dispatch . h >
else <NEW_LINE> poolDiscard ( & dtd -> pool ) ; <NEW_LINE> elementType -> prefix = prefix ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> return 1 ;
#include "base / macros . h" <NEW_LINE> #include "base / memory / ref_counted . h" <NEW_LINE> #include "base / single_thread_task_runner . h" <NEW_LINE> #include "base / synchronization / lock . h" <NEW_LINE> <START_VULN> #include "base / synchronization / read_write_lock . h" <NEW_LINE> <END_VULN> #include "base / threading / thread . h" <NEW_LINE> #include "base / time / time . h" <NEW_LINE> #include "media / midi / midi_export . h"
