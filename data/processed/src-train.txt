<TAB> <TAB> <TAB> <TAB> args . rmtblkcnt = xfs_attr3_rmt_blocks ( <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> args . dp -> i_mount , valuelen ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> retval = xfs_attr_rmtval_get ( & args ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> if ( retval ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> return retval ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> retval = context -> put_listent ( context , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> entry -> flags , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> name_rmt -> name , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ( int ) name_rmt -> namelen , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> valuelen , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> args . value ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> kmem_free ( args . value ) ; <NEW_LINE> <TAB> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> retval = context -> put_listent ( context ,
<TAB> <TAB> r = read_file ( p15card , ( u8 * ) "\x2F\x02" , efbin , & len , 1 ) ; <NEW_LINE> <TAB> <TAB> LOG_TEST_RET ( card -> ctx , r , "Skipping optional EF . C_DevAut" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE><TAB> <TAB> ptr = realloc ( priv -> EF_C_DevAut , len ) ; <NEW_LINE><TAB> <TAB> if ( ptr ) { <NEW_LINE><TAB> <TAB> <TAB> memcpy ( ptr , efbin , len ) ; <NEW_LINE><TAB> <TAB> <TAB> priv -> EF_C_DevAut = ptr ; <NEW_LINE><TAB> <TAB> <TAB> priv -> EF_C_DevAut_len = len ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> ptr = efbin ;
char * path_name ( struct strbuf * path , const char * name ) ; <NEW_LINE> <START_VULN> extern void show_object_with_name ( FILE * , struct object * , <NEW_LINE><TAB> <TAB> <TAB> <TAB> struct strbuf * , const char * ) ; <NEW_LINE> <END_VULN> extern void add_pending_object ( struct rev_info * revs , <NEW_LINE> <TAB> <TAB> <TAB> struct object * obj , const char * name ) ; <NEW_LINE> commit de1e67d0703894cb6ea782e36abb63976ab07e60 <NEW_LINE> Author : Jeff King < peff@peff . net > <NEW_LINE> Date : Thu Feb 11 17 : 28 : 36 2016 - 0500 <NEW_LINE> <TAB> list - objects : pass full pathname to callbacks <NEW_LINE> <TAB> When we find a blob at "a / b / c" , we currently pass this to <NEW_LINE> <TAB> our show_object_fn callbacks as two components : "a / b / " and <NEW_LINE> <TAB> "c" . Callbacks which want the full value then call <NEW_LINE> <TAB> path_name ( ) , which concatenates the two . But this is an <NEW_LINE> <TAB> inefficient interface ; the path is a strbuf , and we could <NEW_LINE> <TAB> simply append "c" to it temporarily , then roll back the <NEW_LINE> <TAB> length , without creating a new copy . <NEW_LINE> <TAB> So we could improve this by teaching the callsites of <NEW_LINE> <TAB> path_name ( ) this trick ( and there are only 3 ) . But we can <NEW_LINE> <TAB> also notice that no callback actually cares about the <NEW_LINE> <TAB> broken - down representation , and simply pass each callback <NEW_LINE> <TAB> the full path "a / b / c" as a string . The callback code becomes <NEW_LINE> <TAB> even simpler , then , as we do not have to worry about freeing <NEW_LINE> <TAB> an allocated buffer , nor rolling back our modification to <NEW_LINE> <TAB> the strbuf . <NEW_LINE> <TAB> This is theoretically less efficient , as some callbacks <NEW_LINE> <TAB> would not bother to format the final path component . But in <NEW_LINE> <TAB> practice this is not measurable . Since we use the same <NEW_LINE> <TAB> strbuf over and over , our work to grow it is amortized , and <NEW_LINE> <TAB> we really only pay to memcpy a few bytes . <NEW_LINE> <TAB> Signed - off - by : Jeff King < peff@peff . net > <NEW_LINE> <TAB> Signed - off - by : Junio C Hamano < gitster@pobox . com >
<TAB> if ( NS_FAILED ( targetBaseURI -> GetScheme ( targetScheme ) ) || <NEW_LINE> <TAB> <TAB> NS_FAILED ( sourceBaseURI -> SchemeIs ( targetScheme . get ( ) , & sameScheme ) ) || <NEW_LINE> <TAB> <TAB> ! sameScheme ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> return false ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> if ( targetScheme . EqualsLiteral ( "file" ) ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> if ( ! aStrictFileOriginPolicy ) <NEW_LINE> <TAB> <TAB> <TAB> return true ; <NEW_LINE> <TAB> <TAB> nsCOMPtr < nsIFileURL > sourceFileURL ( do_QueryInterface ( sourceBaseURI ) ) ; <NEW_LINE> <TAB> <TAB> nsCOMPtr < nsIFileURL > targetFileURL ( do_QueryInterface ( targetBaseURI ) ) ;
nsresult RequestDecodeIfNeeded ( nsresult aStatus , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> eShutdownIntent aIntent , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool aDone , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool aWasSize ) ; <NEW_LINE> nsresult WantDecodedFrames ( ) ; <NEW_LINE> nsresult SyncDecode ( ) ; <NEW_LINE> nsresult InitDecoder ( bool aDoSizeDecode ) ; <NEW_LINE> <START_VULN> nsresult WriteToDecoder ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE>nsresult DecodeSomeData ( uint32_t aMaxBytes ) ; <NEW_LINE> <END_VULN> bool IsDecodeFinished ( ) ; <NEW_LINE> TimeStamp mDrawStartTime ; <NEW_LINE> inline bool CanQualityScale ( const gfxSize & scale ) ; <NEW_LINE> inline bool CanScale ( GraphicsFilter aFilter , gfxSize aScale , uint32_t aFlags ) ; <NEW_LINE> struct ScaleResult <NEW_LINE> {
protected : <NEW_LINE> virtual void InitInternal ( ) ; <NEW_LINE> <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> virtual void FinishInternal ( ) ;
<TAB> newstate = nfs4_opendata_to_nfs4_state ( opendata ) ; <NEW_LINE> <TAB> if ( IS_ERR ( newstate ) ) <NEW_LINE> <TAB> <TAB> return PTR_ERR ( newstate ) ; <NEW_LINE> <START_VULN> <TAB> nfs4_close_state ( & opendata -> path , newstate , openflags ) ; <NEW_LINE> <END_VULN> <TAB> * res = newstate ; <NEW_LINE> <TAB> return 0 ; <NEW_LINE> }
<TAB> <TAB> pktinfo -> ipi_ifindex = 0 ; <NEW_LINE> <TAB> <TAB> pktinfo -> ipi_spec_dst . s_addr = 0 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> skb_dst_drop ( skb ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> int ip_setsockopt ( struct sock * sk , int level ,
<TAB> <TAB> transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; <NEW_LINE> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> if ( strpbrk ( mode , "awx + " ) ) { <NEW_LINE> <TAB> <TAB> <TAB> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP wrapper does not support writeable connections" ) ; <NEW_LINE> <TAB> <TAB> <TAB> php_url_free ( resource ) ;
<TAB> <TAB> <TAB> <TAB> "job - originating - user - name" , NULL , job -> username ) ; <NEW_LINE> else <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> attr -> group_tag = IPP_TAG_JOB ; <NEW_LINE><TAB> _cupsStrFree ( attr -> name ) ; <NEW_LINE><TAB> attr -> name = _cupsStrAlloc ( "job - originating - user - name" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( con -> username [ 0 ] || auth_info )
<TAB> <TAB> <TAB> <TAB> <TAB> int , __be16 ) ; <NEW_LINE> struct sctp_chunk * sctp_make_asconf_set_prim ( struct sctp_association * asoc , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> union sctp_addr * addr ) ; <NEW_LINE> <START_VULN> int sctp_verify_asconf ( const struct sctp_association * asoc , <NEW_LINE><TAB> <TAB> struct sctp_paramhdr * param_hdr , void * chunk_end , <NEW_LINE><TAB> <TAB> struct sctp_paramhdr ** errp ) ; <NEW_LINE> <END_VULN> struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> struct sctp_chunk * asconf ) ; <NEW_LINE> int sctp_process_asconf_ack ( struct sctp_association * asoc ,
static void opl3_setup_voice ( int dev , int voice , int chn ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> struct channel_info * info = <NEW_LINE><TAB> & synth_devs [ dev ] -> chn_info [ chn ] ; <NEW_LINE> <END_VULN> <TAB> opl3_set_instr ( dev , voice , info -> pgm_num ) ;
<TAB> void RequestDecode ( RasterImage * aImg ) ; <NEW_LINE> <START_VULN> <TAB> void DecodeABitOf ( RasterImage * aImg ) ; <NEW_LINE> <END_VULN>
<TAB> if ( current -> flags & PF_RANDOMIZE ) <NEW_LINE> <TAB> <TAB> random_factor = arch_mmap_rnd ( ) ; <NEW_LINE> <START_VULN> <TAB> mm -> mmap_legacy_base = mmap_legacy_base ( random_factor ) ; <NEW_LINE> <END_VULN> <TAB> if ( mmap_is_legacy ( ) ) { <NEW_LINE> <TAB> <TAB> mm -> mmap_base = mm -> mmap_legacy_base ;
<TAB> <TAB> struct nfsd4_getdeviceinfo * gdev ) <NEW_LINE> { <NEW_LINE> <TAB> struct xdr_stream * xdr = & resp -> xdr ; <NEW_LINE> <START_VULN> <TAB> const struct nfsd4_layout_ops * ops = <NEW_LINE><TAB> <TAB> nfsd4_layout_ops [ gdev -> gd_layout_type ] ; <NEW_LINE> <END_VULN> <TAB> u32 starting_len = xdr -> buf -> len , needed_len ; <NEW_LINE> <TAB> __be32 * p ;
<TAB> <TAB> if ( fd < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return - errno ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( mode > 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> r = fchmod ( fd , mode ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( r < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> return - errno ;
* <NEW_LINE> * <NEW_LINE> static bool SplitLastSquareBracket ( nsACString & string , nsCString & bracketPart ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> NS_ABORT_IF_FALSE ( bracketPart . Length ( ) == 0 , "SplitLastSquareBracket must be called with empty bracketPart string" ) ; <NEW_LINE> <END_VULN> <TAB> char * string_start = string . BeginWriting ( ) ; <NEW_LINE> <TAB> char * s = string_start + string . Length ( ) - 1 ; <NEW_LINE> <TAB> if ( * s != ' ] ' ) <NEW_LINE> <TAB> <TAB> return false ; <NEW_LINE> <TAB> while ( * s != ' [ ' && s != string_start ) <NEW_LINE> <TAB> <TAB> s -- ;
<TAB> return u_len + 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , <NEW_LINE><TAB> <TAB> int flen ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct ustr * filename , * unifilename ; <NEW_LINE> <TAB> int len = 0 ;
<TAB> <TAB> <TAB> long val ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ( j % 4 ) == 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> if ( getClientTypeByName ( v [ j ] ) == - 1 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> sdsfreesplitres ( v , vlen ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> goto badfmt ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
<TAB> <TAB> bb -> failbb -> prev = NULL ; <NEW_LINE> <TAB> <TAB> bb -> failbb = NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> R_FREE ( bb ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> R_API RList * r_anal_bb_list_new ( ) {
<TAB> dquot_disable ( sb , - 1 , DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED ) ; <NEW_LINE> <START_VULN> <TAB> ext2_xattr_put_super ( sb ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! ( sb -> s_flags & MS_RDONLY ) ) { <NEW_LINE> <TAB> <TAB> struct ext2_super_block * es = sbi -> s_es ;
<TAB> uep -> ue_size = undo_read_4c ( bi ) ; <NEW_LINE> <TAB> if ( uep -> ue_size > 0 ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> array = ( char_u ** ) U_ALLOC_LINE ( sizeof ( char_u * ) * uep -> ue_size ) ; <NEW_LINE> <END_VULN> <TAB> if ( array == NULL ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> * error = TRUE ;
<TAB> JS_ASSERT ( ( nb & pool -> mask ) == 0 ) ; <NEW_LINE> <START_VULN> <TAB> for ( a = pool -> current ; a -> avail + nb > a -> limit ; pool -> current = a ) { <NEW_LINE> <END_VULN> <TAB> <TAB> ap = & a -> next ; <NEW_LINE> <TAB> <TAB> if ( ! * ap ) {
p -> n = n ; <NEW_LINE> p -> rate = rate ; <NEW_LINE> p -> m_val = 1 . ; <NEW_LINE> if ( rate < 26000 ) p -> m_val = 0 ; <NEW_LINE> else if ( rate < 38000 ) p -> m_val = . 94 ; <NEW_LINE> else if ( rate > 46000 ) p -> m_val = 1 . 275 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( i = 0 , j = 0 ; i < MAX_ATH - 1 ; i + + ) { <NEW_LINE> <TAB> int endpos = rint ( fromOC ( ( i + 1 ) * . 125 - 2 . ) * 2 * n / rate ) ; <NEW_LINE> <TAB> float base = ATH [ i ] ; <NEW_LINE> <TAB> if ( j < endpos ) { <NEW_LINE> <TAB> float delta = ( ATH [ i + 1 ] - base ) / ( endpos - j ) ; <NEW_LINE> <TAB> for ( ; j < endpos && j < n ; j + + ) {
<TAB> * out = NULL ; <NEW_LINE> <TAB> * out_len = 0 ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { <NEW_LINE> <TAB> <TAB> giterr_set ( GITERR_INVALID , "failed to apply delta : base size does not match given data" ) ; <NEW_LINE> <TAB> <TAB> return - 1 ;
<TAB> uint32_t tag = track -> tag ; <NEW_LINE> <TAB> if ( track -> mode == MODE_MOV ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( track -> timescale > UINT16_MAX ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> tag = AV_RL32 ( "lpcm" ) ; <NEW_LINE> <TAB> <TAB> <TAB> version = 2 ;
virtual ~ nsXBLProtoImplMember ( ) { <NEW_LINE> <TAB> nsMemory : : Free ( mName ) ; <NEW_LINE> <TAB> NS_CONTENT_DELETE_LIST_MEMBER ( nsXBLProtoImplMember , this , mNext ) ; <NEW_LINE> } <NEW_LINE> nsXBLProtoImplMember * GetNext ( ) { return mNext ; } <NEW_LINE> void SetNext ( nsXBLProtoImplMember * aNext ) { mNext = aNext ; } <NEW_LINE> <START_VULN> virtual nsresult InstallMember ( nsIScriptContext * aContext , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIContent * aBoundElement , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aScriptObject , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aTargetClassObject , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsCString & aClassStr ) = 0 ; <NEW_LINE> <END_VULN> virtual nsresult CompileMember ( nsIScriptContext * aContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsCString & aClassStr , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aClassObject ) = 0 ; <NEW_LINE> virtual void Trace ( TraceCallback aCallback , void * aClosure ) const = 0 ; <NEW_LINE> virtual nsresult Write ( nsIScriptContext * aContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIObjectOutputStream * aStream )
<TAB> <TAB> offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> length = tvb_length_remaining ( tvb , offset ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + sizeof ( struct udp_hdr ) + length ) ; <NEW_LINE> <TAB> <TAB> nhdr_list -> next = NULL ; <NEW_LINE> <TAB> <TAB> nhdr_list -> proto = IP_PROTO_UDP ;
<TAB> if ( PASS == conn -> m -> local_tx_start ( conn , this_func TSRMLS_CC ) ) { <NEW_LINE> <TAB> <TAB> ret = conn -> m -> query ( conn , ( mode ) ? "SET AUTOCOMMIT = 1" : "SET AUTOCOMMIT = 0" , sizeof ( "SET AUTOCOMMIT = 1" ) - 1 TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <TAB> <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> DBG_RETURN ( ret ) ;
<TAB> s += 11 ; <NEW_LINE> <TAB> SKIPWS ( s ) ; <NEW_LINE> <TAB> ptmp = tmp ; <NEW_LINE> <START_VULN> <TAB> while ( isdigit ( ( unsigned char ) * s ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> * ptmp + + = * s + + ; <NEW_LINE> <TAB> * ptmp = '\0' ; <NEW_LINE> <TAB> if ( mutt_str_atol ( tmp , & h -> content_length ) < 0 )
<TAB> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <NEW_LINE> <TAB> if ( ret < 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> ops -> destroy ( dev ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> mutex_lock ( & kvm -> lock ) ; <NEW_LINE> <TAB> <TAB> list_del ( & dev -> vm_node ) ; <NEW_LINE> <TAB> <TAB> mutex_unlock ( & kvm -> lock ) ; <NEW_LINE> <TAB> <TAB> return ret ; <NEW_LINE> <TAB> }
<TAB> regs -> loadrs = 0 ; <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <TAB> regs -> r8 = get_dumpable ( current -> mm ) ; <TAB> <TAB> <TAB> \ <NEW_LINE> <TAB> regs -> r12 = new_sp - 16 ; <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <START_VULN> <TAB> if ( unlikely ( ! get_dumpable ( current -> mm ) ) ) { <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <END_VULN> int get_dumpable ( struct mm_struct * mm ) <NEW_LINE> { <NEW_LINE> <TAB> return __get_dumpable ( mm -> flags ) ;
<TAB> c1 = krb5_princ_component ( kctx , princ , 0 ) ; <NEW_LINE> <TAB> c2 = krb5_princ_component ( kctx , princ , 1 ) ; <NEW_LINE> <TAB> realm = krb5_princ_realm ( kctx , princ ) ; <NEW_LINE> <START_VULN> <TAB> if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 <NEW_LINE><TAB> && strncmp ( "kadmin" , c1 -> data , c1 -> length ) == 0 ) { <NEW_LINE><NEW_LINE><TAB> if ( strncmp ( "history" , c2 -> data , c2 -> length ) == 0 ) <NEW_LINE><TAB> goto fail_princ ; <NEW_LINE><TAB> else <NEW_LINE><TAB> success = 1 ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> fail_princ : <NEW_LINE> <TAB> if ( ! success ) {
<TAB> <TAB> atomic_dec ( & key -> user -> nkeys ) ; <NEW_LINE> <TAB> <TAB> atomic_inc ( & newowner -> nkeys ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> atomic_dec ( & key -> user -> nikeys ) ; <NEW_LINE> <TAB> <TAB> <TAB> atomic_inc ( & newowner -> nikeys ) ; <NEW_LINE> <TAB> <TAB> }
<TAB> ast_atomic_fetchadd_int ( & session_count , - 1 ) ; <NEW_LINE> <START_VULN> <TAB> if ( headers ) { <NEW_LINE><TAB> <TAB> ast_variables_destroy ( headers ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> if ( ser -> f ) { <NEW_LINE> <TAB> <TAB> fclose ( ser -> f ) ;
<TAB> <TAB> if ( optname != IPV6_RTHDR && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <START_VULN> <TAB> <TAB> opt = ipv6_renew_options ( sk , np -> opt , optname , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> ( struct ipv6_opt_hdr __user * ) optval , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> optlen ) ; <NEW_LINE> <TAB> <TAB> if ( IS_ERR ( opt ) ) {
<TAB> posix_acl_release ( argp -> acl_access ) ; <NEW_LINE> <TAB> posix_acl_release ( argp -> acl_default ) ; <NEW_LINE> <TAB> return nfserr ; <NEW_LINE> <START_VULN> out_drop_write : <NEW_LINE> <END_VULN> <TAB> fh_drop_write ( fh ) ; <NEW_LINE> out_errno : <NEW_LINE> <TAB> nfserr = nfserrno ( error ) ;
<TAB> if ( __ipv6_addr_needs_scope_id ( addr_type ) ) <NEW_LINE> <TAB> <TAB> iif = skb -> dev -> ifindex ; <NEW_LINE> <START_VULN> <TAB> else <NEW_LINE><TAB> <TAB> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <NEW_LINE> <END_VULN> <TAB> * <TAB> Must not send error if the source does not uniquely
<TAB> static gpol_ret ret ; <NEW_LINE> <TAB> kadm5_ret_t ret2 ; <NEW_LINE> <TAB> char * prime_arg , * funcname ; <NEW_LINE> <START_VULN> <TAB> gss_buffer_desc client_name , <NEW_LINE><TAB> <TAB> service_name ; <NEW_LINE> <END_VULN> <TAB> OM_uint32 minor_stat ; <NEW_LINE> <TAB> kadm5_principal_ent_rec caller_ent ; <NEW_LINE> <TAB> kadm5_server_handle_t handle ;
<TAB> for ( i = 1 ; i < view -> n ; + + i ) { <NEW_LINE> <TAB> <TAB> const struct user_regset * regset = & view -> regsets [ i ] ; <NEW_LINE> <TAB> <TAB> do_thread_regset_writeback ( t -> task , regset ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( regset -> core_note_type && <NEW_LINE> <END_VULN> <TAB> <TAB> ( ! regset -> active || regset -> active ( t -> task , regset ) ) ) { <NEW_LINE> <TAB> <TAB> <TAB> int ret ; <NEW_LINE> <TAB> <TAB> <TAB> size_t size = regset -> n * regset -> size ;
<TAB> <TAB> node = blk -> bp -> b_addr ; <NEW_LINE> <TAB> <TAB> dp -> d_ops -> node_hdr_from_disk ( & nodehdr , node ) ; <NEW_LINE> <TAB> <TAB> btree = dp -> d_ops -> node_tree_p ( node ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( be32_to_cpu ( btree -> hashval ) == lasthash ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> blk -> hashval = lasthash ; <NEW_LINE> <TAB> <TAB> btree [ blk -> index ] . hashval = cpu_to_be32 ( lasthash ) ;
<TAB> private : <NEW_LINE> <TAB> nsRefPtr < DecodeRequest > mRequest ; <NEW_LINE> <TAB> nsRefPtr < RasterImage > mImage ; <NEW_LINE> <TAB> } ; <NEW_LINE> private : <NEW_LINE> <START_VULN> <TAB> mozilla : : Mutex mThreadPoolMutex ; <NEW_LINE><TAB> nsCOMPtr < nsIThreadPool > mThreadPool ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> class DecodeDoneWorker : public nsRunnable <NEW_LINE> { <NEW_LINE> public :
<TAB> if ( argc == 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> while ( ( tmp = OBJ_GET_PARENT ( cx , obj ) ) != NULL ) <NEW_LINE><TAB> <TAB> <TAB> obj = tmp ; <NEW_LINE> <END_VULN> <TAB> } else { <NEW_LINE> <TAB> <TAB> if ( ! js_ValueToObject ( cx , argv [ 0 ] , & obj ) )
<TAB> <TAB> * ret_page = phys_to_page ( phys ) ; <NEW_LINE> <TAB> <TAB> ptr = ( void * ) val ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( flags & __GFP_ZERO ) <NEW_LINE><TAB> <TAB> <TAB> memset ( ptr , 0 , size ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return ptr ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 142 2018 / 05 / 24 18 : 08 : 01 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef BUILTIN_ELF
<TAB> clone_image -> colormap = ( PixelInfo * ) AcquireQuantumMemory ( length , <NEW_LINE> <TAB> <TAB> sizeof ( * clone_image -> colormap ) ) ; <NEW_LINE> <TAB> if ( clone_image -> colormap == ( PixelInfo * ) NULL ) <NEW_LINE> <START_VULN> <TAB> <TAB> ThrowImageException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <END_VULN> <TAB> ( void ) CopyMagickMemory ( clone_image -> colormap , image -> colormap , length * <NEW_LINE> <TAB> <TAB> sizeof ( * clone_image -> colormap ) ) ; <NEW_LINE> <TAB> }
#include < linux / mutex . h > <NEW_LINE> #include < net / sock . h > <NEW_LINE> <START_VULN> void unix_inflight ( struct file * fp ) ; <NEW_LINE>void unix_notinflight ( struct file * fp ) ; <NEW_LINE> <END_VULN> void unix_gc ( void ) ; <NEW_LINE> void wait_for_unix_gc ( void ) ; <NEW_LINE> struct sock * unix_get_socket ( struct file * filp ) ;
while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> int nbase = sscanf ( lbase , " % 255 [ ^ \r\n ] " , strbase ) ; <NEW_LINE><TAB> int ntest = sscanf ( ltest , " % 255 [ ^ \r\n ] " , strtest ) ; <NEW_LINE><TAB> assert ( nbase != 255 && ntest != 255 ) ; <NEW_LINE> <END_VULN> <TAB> if ( nbase != 1 || ntest != 1 ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> fprintf ( stderr , "could not parse line from files\n" ) ;
<TAB> if ( i + 1 < P_BANDS ) { <NEW_LINE> <TAB> <TAB> int l = 0 ; <NEW_LINE> <TAB> <TAB> k = i + 1 ; <NEW_LINE> <TAB> <TAB> for ( j = 0 ; j < EHMER_MAX ; j + + ) { <NEW_LINE> <TAB> <TAB> int lo_bin = fromOC ( j * . 125 + i * . 5 - 2 . 0625 ) / binHz ; <NEW_LINE> <TAB> <TAB> int hi_bin = fromOC ( j * . 125 + i * . 5 - 1 . 9375 ) / binHz + 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> if ( lo_bin < 0 ) lo_bin = 0 ; <NEW_LINE> <TAB> <TAB> if ( lo_bin > n ) lo_bin = n ; <NEW_LINE> <TAB> <TAB> if ( lo_bin < l ) l = lo_bin ; <NEW_LINE> <TAB> <TAB> if ( hi_bin < 0 ) hi_bin = 0 ; <NEW_LINE> <TAB> <TAB> if ( hi_bin > n ) hi_bin = n ; <NEW_LINE> <TAB> <TAB> for ( ; l < hi_bin && l < n ; l + + ) <NEW_LINE> <TAB> <TAB> <TAB> if ( brute_buffer [ l ] > workc [ k ] [ m ] [ j ] )
<TAB> struct sock * make ; <NEW_LINE> <TAB> struct rose_sock * make_rose ; <NEW_LINE> <TAB> struct rose_facilities_struct facilities ; <NEW_LINE> <START_VULN> <TAB> int n , len ; <NEW_LINE> <END_VULN> <TAB> skb -> sk = NULL ; <TAB> <TAB>
<TAB> <TAB> if ( in_atomic ( ) || ! mm ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto no_context ; <NEW_LINE> <START_VULN> <TAB> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN> <TAB> down_read ( & mm -> mmap_sem ) ;
<TAB> . mmap <TAB> <TAB> = generic_file_mmap , <NEW_LINE> <TAB> . fsync <TAB> <TAB> = noop_fsync , <NEW_LINE> <TAB> . splice_read <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> <TAB> . llseek <TAB> <TAB> = generic_file_llseek , <NEW_LINE> } ;
<TAB> <TAB> LANG_ID_MAC_KOREAN = 23 , <NEW_LINE> <TAB> <TAB> LANG_ID_MAC_POLISH = 25 , <NEW_LINE> <TAB> <TAB> LANG_ID_MAC_FARSI = 31 , <NEW_LINE> <TAB> <TAB> LANG_ID_MAC_SIMP_CHINESE = 33 , <NEW_LINE> <TAB> <TAB> LANG_ID_MAC_ROMANIAN = 37 , <NEW_LINE> <TAB> <TAB> LANG_ID_MAC_CZECH = 38 , <NEW_LINE> <TAB> <TAB> LANG_ID_MAC_SLOVAK = 39 , <NEW_LINE> <START_VULN> <TAB> <TAB> LANG_ID_MICROSOFT_EN_US = 0x0409 <NEW_LINE> <END_VULN> <TAB> } ; <NEW_LINE> <TAB> struct NameHeader { <NEW_LINE> <TAB> <TAB> mozilla : : AutoSwap_PRUint16 format ; <NEW_LINE> <TAB> <TAB> mozilla : : AutoSwap_PRUint16 count ; <NEW_LINE> <TAB> <TAB> mozilla : : AutoSwap_PRUint16 stringOffset ;
<TAB> info -> dev = dev ; <NEW_LINE> <TAB> usb_fill_bulk_urb ( urb , priv -> udev , usb_sndbulkpipe ( priv -> udev , 2 ) , <NEW_LINE> <TAB> <TAB> <TAB> hdr , skb -> len , rtl8187_tx_cb , skb ) ; <NEW_LINE> <START_VULN> <TAB> usb_submit_urb ( urb , GFP_ATOMIC ) ; <NEW_LINE> <END_VULN> <TAB> return 0 ; <NEW_LINE> }
long dim ; <NEW_LINE> long entries ; <NEW_LINE> long used_entries ; <NEW_LINE> const static_codebook * c ; <NEW_LINE> <START_VULN> float * valuelist ; <NEW_LINE> <END_VULN> ogg_uint32_t * codelist ; <NEW_LINE> int * dec_index ; <NEW_LINE> char * dec_codelengths ; <NEW_LINE> ogg_uint32_t * dec_firsttable ; <NEW_LINE> int dec_firsttablen ; <NEW_LINE> int dec_maxlength ;
<TAB> <TAB> if ( log_level ) { <NEW_LINE> <TAB> <TAB> <TAB> verbose ( " % d : " , insn_idx ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> print_bpf_insn ( insn ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> IPTOS_PREC_INTERNETCONTROL ) : <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> iph -> tos ; <NEW_LINE> <START_VULN> <TAB> if ( ip_options_echo ( & icmp_param . replyopts , skb_in ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> goto out_unlock ;
<TAB> <TAB> <TAB> phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> break ;
<TAB> case ACL_TYPE_ACCESS : <NEW_LINE> <TAB> <TAB> xattr_name = XATTR_NAME_POSIX_ACL_ACCESS ; <NEW_LINE> <TAB> <TAB> if ( acl ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <NEW_LINE><TAB> <TAB> <TAB> if ( err < 0 ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> return err ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> err = 0 ;
<TAB> <TAB> <TAB> <TAB> sk -> sk_socket -> ops = & inet_dgram_ops ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> sk -> sk_family = PF_INET ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> opt = xchg ( & np -> opt , NULL ) ; <NEW_LINE><TAB> <TAB> <TAB> if ( opt ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> pktopt = xchg ( & np -> pktoptions , NULL ) ; <NEW_LINE> <TAB> <TAB> <TAB> kfree_skb ( pktopt ) ;
<TAB> unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; <NEW_LINE> <TAB> int row_ptr = 0 ; <NEW_LINE> <START_VULN> <TAB> int pixel_ptr = 0 ; <NEW_LINE> <END_VULN> <TAB> int block_ptr ; <NEW_LINE> <TAB> int pixel_x , pixel_y ; <NEW_LINE> <TAB> int total_blocks ;
<TAB> <TAB> <TAB> <TAB> MAKE_STD_ZVAL ( http_header ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } else {
} <NEW_LINE> <START_VULN> bool f2fs_init_extent_tree ( struct inode * inode , struct f2fs_extent * i_ext ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <NEW_LINE> <TAB> struct extent_tree * et ;
<TAB> <TAB> <TAB> } else if ( src [ 1 ] == ' . ' ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( src [ 2 ] == ' / ' || src [ 2 ] == '\0' ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> archive_set_error ( & a -> archive , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ARCHIVE_ERRNO_MISC , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> "Path contains ' . . '" ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> return ( ARCHIVE_FAILED ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
<TAB> const cdf_sat_t * ssat , const cdf_stream_t * sst , <NEW_LINE> <TAB> cdf_secid_t sid , size_t len , cdf_stream_t * scn ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> size_t ss = CDF_SEC_SIZE ( h ) , i , j ; <NEW_LINE> <END_VULN> <TAB> scn -> sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ; <NEW_LINE> <TAB> scn -> sst_dirlen = len ;
{ <NEW_LINE> <TAB> static generic_ret ret ; <NEW_LINE> <TAB> char * prime_arg , * funcname ; <NEW_LINE> <START_VULN> <TAB> gss_buffer_desc client_name , service_name ; <NEW_LINE> <END_VULN> <TAB> OM_uint32 minor_stat ; <NEW_LINE> <TAB> kadm5_server_handle_t handle ;
<TAB> payload = NULL ; <NEW_LINE> <START_VULN> <TAB> if ( _payload ) { <NEW_LINE> <END_VULN> <TAB> <TAB> ret = - ENOMEM ; <NEW_LINE> <TAB> <TAB> payload = kmalloc ( plen , GFP_KERNEL ) ; <NEW_LINE> <TAB> <TAB> if ( ! payload )
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "CTR Counter block mode" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "rfc3686" ) ; <NEW_LINE> <END_VULN>
<TAB> void fCompileShader ( GLuint shader ) { <NEW_LINE> <TAB> <TAB> BEFORE_GL_CALL ; <NEW_LINE> <TAB> <TAB> mSymbols . fCompileShader ( shader ) ; <NEW_LINE> <TAB> <TAB> AFTER_GL_CALL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void raw_fCopyTexImage2D ( GLenum target , GLint level , GLenum internalformat , GLint x , GLint y , GLsizei width , GLsizei height , GLint border ) { <NEW_LINE> <TAB> <TAB> BEFORE_GL_CALL ; <NEW_LINE> <START_VULN> <TAB> <TAB> mSymbols . fCopyTexImage2D ( target , level , internalformat , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> x , FixYValue ( y , height ) , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> width , height , border ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> AFTER_GL_CALL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void raw_fCopyTexSubImage2D ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLint x , GLint y , GLsizei width , GLsizei height ) { <NEW_LINE> <TAB> <TAB> BEFORE_GL_CALL ; <NEW_LINE> <TAB> <TAB> mSymbols . fCopyTexSubImage2D ( target , level , xoffset , yoffset , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> x , FixYValue ( y , height ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> width , height ) ;
<TAB> atomic_dec ( & netbk -> netfront_count ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx ) ; <NEW_LINE> <END_VULN> static void make_tx_response ( struct xenvif * vif , <NEW_LINE> <TAB> <TAB> <TAB> struct xen_netif_tx_request * txp , <NEW_LINE> <TAB> <TAB> <TAB> s8 st ) ;
<TAB> <TAB> <TAB> <TAB> h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1 ; <NEW_LINE> <TAB> <TAB> <TAB> else <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> max [ 1 ] = 31 ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] ) {
<TAB> zend_llist_add_element ( & mh -> easyh , & tmp_val ) ; <NEW_LINE> <START_VULN> <TAB> RETURN_LONG ( ( zend_long ) curl_multi_add_handle ( mh -> multi , ch -> cp ) ) ; <NEW_LINE> <END_VULN> }
} <NEW_LINE> char * uwsgi_expand_path ( char * dir , int dir_len , char * ptr ) { <NEW_LINE> <START_VULN> <TAB> char src [ PATH_MAX + 1 ] ; <NEW_LINE><TAB> memcpy ( src , dir , dir_len ) ; <NEW_LINE><TAB> src [ dir_len ] = 0 ; <NEW_LINE> <END_VULN> <TAB> char * dst = ptr ; <NEW_LINE> <TAB> if ( ! dst ) <NEW_LINE> <TAB> <TAB> dst = uwsgi_malloc ( PATH_MAX + 1 ) ;
<TAB> . read_iter <TAB> = xfs_file_read_iter , <NEW_LINE> <TAB> . write_iter <TAB> = xfs_file_write_iter , <NEW_LINE> <TAB> . splice_read <TAB> = xfs_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = xfs_file_splice_write , <NEW_LINE> <END_VULN> <TAB> . unlocked_ioctl <TAB> = xfs_file_ioctl , <NEW_LINE> #ifdef CONFIG_COMPAT <NEW_LINE> <TAB> . compat_ioctl <TAB> = xfs_file_compat_ioctl ,
<TAB> else <NEW_LINE> <TAB> <TAB> size = offsetof ( struct fxregs_state , xmm_space [ 0 ] ) ; <NEW_LINE> <START_VULN> <TAB> return segmented_write ( ctxt , ctxt -> memop . addr . mem , & fx_state , size ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int fxrstor_fixup ( struct x86_emulate_ctxt * ctxt ,
<TAB> if ( ! err ) { <NEW_LINE> <TAB> <TAB> map_bh ( bh , inode -> i_sb , map . m_pblk ) ; <NEW_LINE> <TAB> <TAB> bh -> b_state = ( bh -> b_state & ~ F2FS_MAP_FLAGS ) | map . m_flags ; <NEW_LINE> <START_VULN> <TAB> <TAB> bh -> b_size = map . m_len << inode -> i_blkbits ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return err ; <NEW_LINE> }
<TAB> <TAB> return ( ARCHIVE_FATAL ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> filename [ filename_size + + ] = '\0' ; <NEW_LINE> <START_VULN> <TAB> filename [ filename_size + + ] = '\0' ; <NEW_LINE> <END_VULN>
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> reslevel -> log2_prec_height ) - <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ! reslevel -> band ) <NEW_LINE> <TAB> <TAB> <TAB> return AVERROR ( ENOMEM ) ;
<TAB> <TAB> ret = GSS_S_FAILURE ; <NEW_LINE> <TAB> <TAB> goto cleanup ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> sc -> ctx_handle = GSS_C_NO_CONTEXT ; <NEW_LINE> <TAB> * ctx = ( gss_ctx_id_t ) sc ; <NEW_LINE> <TAB> sc = NULL ;
<START_VULN> static int CVE_2014_5471_isofs_read_inode ( struct inode * inode ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct super_block * sb = inode -> i_sb ; <NEW_LINE> <TAB> struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ;
<TAB> inet -> inet_daddr = daddr ; <NEW_LINE> <TAB> inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ; <NEW_LINE> <START_VULN> <TAB> if ( inet -> opt ) <NEW_LINE><TAB> <TAB> inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; <NEW_LINE> <END_VULN> <TAB> tp -> rx_opt . mss_clamp = TCP_MSS_DEFAULT ;
<TAB> demux_sys_t * p_sys = p_demux -> p_sys ; <NEW_LINE> <TAB> block_t * p_block = tk -> p_sipr_packet ; <NEW_LINE> <START_VULN> <TAB> if ( p_sys -> i_buffer < tk -> i_frame_size ) <NEW_LINE> <END_VULN> <TAB> <TAB> return ; <NEW_LINE> <TAB> if ( ! p_block )
<TAB> sctp_v4_pf_init ( ) ; <NEW_LINE> <TAB> sctp_v6_pf_init ( ) ; <NEW_LINE> <START_VULN> <TAB> status = sctp_v4_protosw_init ( ) ; <NEW_LINE> <END_VULN> <TAB> if ( status ) <NEW_LINE> <TAB> <TAB> goto err_protosw_init ;
<TAB> if ( ! dbname && reuse_previous ) <NEW_LINE> <START_VULN> <TAB> <TAB> dbname = PQdb ( o_conn ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; <NEW_LINE> <TAB> <TAB> if ( ! hdr ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <END_VULN>
<TAB> unsigned int mc_saved_count = mc_saved_data -> mc_saved_count ; <NEW_LINE> <TAB> int i ; <NEW_LINE> <START_VULN> <TAB> while ( leftover ) { <NEW_LINE> <END_VULN> <TAB> <TAB> mc_header = ( struct microcode_header_intel * ) ucode_ptr ; <NEW_LINE> <TAB> <TAB> mc_size = get_totalsize ( mc_header ) ;
<TAB> <TAB> <TAB> intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE ) ; <NEW_LINE> <TAB> if ( ret ) <NEW_LINE> <TAB> <TAB> return - ERESTARTSYS ; <NEW_LINE> <START_VULN> <TAB> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <NEW_LINE><TAB> <TAB> smp_rmb ( ) ; <NEW_LINE><TAB> <TAB> return key -> reject_error ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> return key_validate ( key ) ; <NEW_LINE> } <NEW_LINE> EXPORT_SYMBOL ( wait_for_key_construction ) ;
mrb_bool failed = TRUE ; <NEW_LINE> mrb_get_args ( mrb , "o" , & orig ) ; <NEW_LINE> fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; <NEW_LINE> if ( fptr_copy != NULL ) { <NEW_LINE> <TAB> fptr_finalize ( mrb , fptr_copy , FALSE ) ; <NEW_LINE> <TAB> mrb_free ( mrb , fptr_copy ) ; <NEW_LINE> } <NEW_LINE> fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; <NEW_LINE> <START_VULN> fptr_orig = io_get_open_fptr ( mrb , orig ) ; <NEW_LINE> <END_VULN> DATA_TYPE ( copy ) = & mrb_io_type ; <NEW_LINE> DATA_PTR ( copy ) = fptr_copy ;
<TAB> if ( * firsthardlink < 0 ) { <NEW_LINE> <TAB> * firsthardlink = rpmfiFX ( fi ) ; <NEW_LINE> <START_VULN> <TAB> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <NEW_LINE> <END_VULN> <TAB> } else { <NEW_LINE> <TAB> char * fn = rpmfilesFN ( files , * firsthardlink ) ;
<TAB> struct xfs_buf <TAB> <TAB> * bp ; <NEW_LINE> <TAB> xfs_dablk_t <TAB> <TAB> lblkno = args -> rmtblkno ; <NEW_LINE> <TAB> __uint8_t <TAB> <TAB> * dst = args -> value ; <NEW_LINE> <START_VULN> <TAB> int <TAB> <TAB> <TAB> valuelen = args -> valuelen ; <NEW_LINE> <END_VULN> <TAB> int <TAB> <TAB> <TAB> nmap ; <NEW_LINE> <TAB> int <TAB> <TAB> <TAB> error ; <NEW_LINE> <TAB> int <TAB> <TAB> <TAB> blkcnt = args -> rmtblkcnt ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 45 2011 / 08 / 28 08 : 38 : 48 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include < assert . h >
<TAB> } <NEW_LINE> <TAB> offsets = ( int * ) safe_emalloc ( size_offsets , sizeof ( int ) , 0 ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> alloc_len = 2 * subject_len + 1 ; <NEW_LINE> <TAB> result = safe_emalloc ( alloc_len , sizeof ( char ) , 0 ) ;
<TAB> if ( fCon ) { <TAB> <TAB> <TAB> <NEW_LINE> <TAB> unsigned char <TAB> tCon ; <NEW_LINE> <TAB> unsigned char <TAB> tByte ; <NEW_LINE> <START_VULN> <TAB> unsigned char <TAB> tpiLen ; <NEW_LINE> <END_VULN> <TAB> tvbuff_t <TAB> <TAB> * tmp_tvb ; <NEW_LINE> <TAB> vHeader = 0 ; <TAB> <TAB>
<TAB> } <NEW_LINE> <TAB> update_open_stateid ( state , & data -> o_res . stateid , NULL , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> data -> o_arg . open_flags ) ; <NEW_LINE> <END_VULN> <TAB> iput ( inode ) ; <NEW_LINE> out : <NEW_LINE> <TAB> return state ;
<TAB> } <NEW_LINE> <TAB> if ( finish ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ( ! fifo -> skbuff -> data [ fifo -> skbuff -> len - 1 ] ) <NEW_LINE><TAB> <TAB> && ( fifo -> skbuff -> len > 3 ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( fifon == HFCUSB_D_RX ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> DBG ( HFCUSB_DBG_DCHANNEL ,
<TAB> if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) <NEW_LINE> <TAB> <TAB> return ; <NEW_LINE> <START_VULN> <TAB> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <NEW_LINE><TAB> data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ; <NEW_LINE><TAB> kunmap_atomic ( vapic ) ; <NEW_LINE> <END_VULN> <TAB> apic_set_tpr ( vcpu -> arch . apic , data & 0xff ) ; <NEW_LINE> }
<TAB> <TAB> if ( ( which & FPM_CLEANUP_CHILD ) == 0 && fpm_globals . parent_pid == getpid ( ) ) { <NEW_LINE> <TAB> <TAB> <TAB> fpm_scoreboard_free ( wp -> scoreboard ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> free ( wp -> config ) ; <NEW_LINE><TAB> <TAB> free ( wp -> user ) ; <NEW_LINE><TAB> <TAB> free ( wp -> home ) ; <NEW_LINE><TAB> <TAB> free ( wp ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> fpm_worker_all_pools = NULL ; <NEW_LINE> }
<TAB> <TAB> case htons ( PPP_IPV6 ) : <NEW_LINE> <TAB> <TAB> <TAB> goto ipv6 ; <NEW_LINE> <TAB> <TAB> default : <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> case htons ( ETH_P_TIPC ) : {
<TAB> <TAB> errstr = "Out of memory" ; <NEW_LINE> <TAB> <TAB> break ; <NEW_LINE> <TAB> case - EROFS : <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! sb || EXT4_SB ( sb ) -> s_journal -> j_flags & JBD2_ABORT ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> errstr = "Journal has aborted" ; <NEW_LINE> <TAB> <TAB> else <NEW_LINE> <TAB> <TAB> <TAB> errstr = "Readonly filesystem" ;
<TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> UnlockArena ( ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> PRUint32 sz = PR_MAX ( pool -> arenasize , nb ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> sz += sizeof * a + pool -> mask ; <NEW_LINE><TAB> <TAB> a = ( PLArena * ) PR_MALLOC ( sz ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( NULL != a ) { <NEW_LINE> <TAB> <TAB> <TAB> a -> limit = ( PRUword ) a + sz ; <NEW_LINE> <TAB> <TAB> <TAB> a -> base = a -> avail = ( PRUword ) PL_ARENA_ALIGN ( pool , a + 1 ) ; <NEW_LINE> <TAB> <TAB> <TAB> PL_MAKE_MEM_NOACCESS ( ( void * ) a -> avail , a -> limit - a -> avail ) ; <NEW_LINE> <TAB> <TAB> <TAB> rp = ( char * ) a -> avail ; <NEW_LINE> <TAB> <TAB> <TAB> a -> avail += nb ;
<TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> sprintf ( op -> buf_asm , "sparse - switch - payload % d" , array_size ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> size = 4 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> payload = 2 * ( array_size * 4 ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> len = 0 ;
#include "WrapperFactory . h" <NEW_LINE> class nsIPrincipal ; <NEW_LINE> namespace xpc { <NEW_LINE> class AccessCheck { <NEW_LINE> public : <NEW_LINE> <START_VULN> <TAB> static bool isSameOrigin ( JSCompartment * a , JSCompartment * b ) ; <NEW_LINE> <END_VULN> <TAB> static bool isChrome ( JSCompartment * compartment ) ; <NEW_LINE> <TAB> static bool callerIsChrome ( ) ; <NEW_LINE> <TAB> static nsIPrincipal * getPrincipal ( JSCompartment * compartment ) ; <NEW_LINE> <TAB> static bool isCrossOriginAccessPermitted ( JSContext * cx , JSObject * obj , jsid id , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> js : : Wrapper : : Action act ) ; <NEW_LINE> <TAB> static bool isSystemOnlyAccessPermitted ( JSContext * cx ) ; <NEW_LINE> <TAB> static bool isLocationObjectSameOrigin ( JSContext * cx , JSObject * wrapper ) ; <NEW_LINE> <TAB> static bool documentDomainMakesSameOrigin ( JSContext * cx , JSObject * obj ) ;
<TAB> int error ; <NEW_LINE> <TAB> jrdev = & pdev -> dev ; <NEW_LINE> <START_VULN> <TAB> jrpriv = kmalloc ( sizeof ( struct caam_drv_private_jr ) , <NEW_LINE><TAB> <TAB> <TAB> GFP_KERNEL ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! jrpriv ) <NEW_LINE> <TAB> <TAB> return - ENOMEM ;
destroy_bio ( struct bio * bio ) <NEW_LINE> { <NEW_LINE> <TAB> pthread_cond_destroy ( & bio -> bio_wait ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> free ( bio ) ; <NEW_LINE> }
<TAB> BUG_ON ( path [ depth ] . p_hdr == NULL ) ; <NEW_LINE> <START_VULN> <TAB> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <NEW_LINE> <END_VULN> <TAB> <TAB> && ext4_can_extents_be_merged ( inode , ex , newext ) ) { <NEW_LINE> <TAB> <TAB> ext_debug ( "append [ % d ] % d block to % d : [ % d ] % d ( from % llu ) \n" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ext4_ext_is_uninitialized ( newext ) ,
<TAB> } <NEW_LINE> <START_VULN> snprintf_func ( ecmd , TESTBUFSIZE , " % s % s - f % s % s % s % s % s % s % s" , <NEW_LINE> <END_VULN> <TAB> program_name , test_softcfg_str , <NEW_LINE> <TAB> has_adler32 ? "" : " - n " , <NEW_LINE> <TAB> has_apphead ? " - A = encode_apphead " : " - A = " ,
<TAB> <TAB> <TAB> if ( ( ret = parse_location ( s , p ) ) < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return ret ; <NEW_LINE> <TAB> <TAB> <TAB> * new_location = 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> } else if ( ! av_strcasecmp ( tag , "Content - Length" ) && s -> filesize == - 1 ) { <NEW_LINE><TAB> <TAB> <TAB> s -> filesize = strtoll ( p , NULL , 10 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } else if ( ! av_strcasecmp ( tag , "Content - Range" ) ) { <NEW_LINE> <TAB> <TAB> <TAB> parse_content_range ( h , p ) ; <NEW_LINE> <TAB> <TAB> } else if ( ! av_strcasecmp ( tag , "Accept - Ranges" ) &&
<TAB> if ( family == AF_INET ) { <NEW_LINE> <TAB> <TAB> struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; <NEW_LINE> <START_VULN> <TAB> <TAB> sin -> sin_family = AF_INET ; <NEW_LINE><TAB> <TAB> sin -> sin_port = 0 ; <NEW_LINE><TAB> <TAB> sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; <NEW_LINE><TAB> <TAB> memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <NEW_LINE><TAB> <TAB> * addr_len = sizeof ( * sin ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( isk -> cmsg_flags ) <NEW_LINE> <TAB> <TAB> <TAB> ip_cmsg_recv ( msg , skb ) ;
<TAB> free ( key_data ) ; <NEW_LINE> <TAB> if ( err != 0 ) { <NEW_LINE> <TAB> <TAB> if ( ret != NULL ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> for ( i = 0 ; i <= num_versions ; i + + ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> if ( ret [ i ] != NULL ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> free ( ret [ i ] ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> free ( ret ) ; <NEW_LINE> <TAB> <TAB> <TAB> ret = NULL ; <NEW_LINE> <TAB> <TAB> }
<TAB> } <NEW_LINE> } <NEW_LINE> <START_VULN> static void follow_dotdot ( struct nameidata * nd ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> if ( ! nd -> root . mnt ) <NEW_LINE> <TAB> <TAB> set_root ( nd ) ;
out1 [ 0 ] = '\0' ; <NEW_LINE> <START_VULN> declen = mutt_b64_decode ( out2 , out1 ) ; <NEW_LINE> <END_VULN> if ( ! TEST_CHECK ( declen == - 1 ) ) <NEW_LINE> { <NEW_LINE> <TAB> TEST_MSG ( "Expected : % zu" , - 1 ) ;
<TAB> <TAB> <TAB> if ( skb == NULL || skb_prev == NULL ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ip6_append_data_mtu ( & mtu , & maxfraglen , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> fragheaderlen , skb , rt ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> skb_prev = skb ;
static int CVE_2013_2547_crypto_report_one ( struct crypto_alg * alg , <NEW_LINE> <TAB> <TAB> <TAB> struct crypto_user_alg * ualg , struct sk_buff * skb ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <NEW_LINE><TAB> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <NEW_LINE><TAB> sizeof ( ualg -> cru_driver_name ) ) ; <NEW_LINE><TAB> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <NEW_LINE><TAB> CRYPTO_MAX_ALG_NAME ) ; <NEW_LINE> <END_VULN> <TAB> ualg -> cru_flags = alg -> cra_flags ; <NEW_LINE> <TAB> ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ;
<TAB> <TAB> { <NEW_LINE> <TAB> <TAB> assign ( 0 ) ; <NEW_LINE> <TAB> <TAB> return reinterpret_cast < void ** > ( & mRawPtr ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> void <NEW_LINE> <TAB> assign ( T * newPtr ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> NS_ABORT_IF_FALSE ( mRawPtr != newPtr || ! newPtr , "This makes no sense ! " ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> T * oldPtr = mRawPtr ; <NEW_LINE> <TAB> <TAB> mRawPtr = newPtr ; <NEW_LINE> <TAB> <TAB> delete oldPtr ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> free_xml ( op_reply ) ; <NEW_LINE> <TAB> <TAB> op_reply = NULL ; <NEW_LINE> <START_VULN> <TAB> } <NEW_LINE><NEW_LINE><TAB> if ( sync_timer -> ref > 0 ) { <NEW_LINE><TAB> <TAB> g_source_remove ( sync_timer -> ref ) ; <NEW_LINE><TAB> <TAB> sync_timer -> ref = 0 ; <NEW_LINE><TAB> } <NEW_LINE><TAB> if ( timer_expired ) { <NEW_LINE><TAB> <TAB> return - ETIME ; <NEW_LINE> <END_VULN> <TAB> }
<TAB> <TAB> <TAB> l_part_tile_size = 0 ; <NEW_LINE> <TAB> <TAB> <TAB> l_begin_data = p_data ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> p_manager ) ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return OPJ_FALSE ; <NEW_LINE> <TAB> <TAB> <TAB> }
} <NEW_LINE> if ( result && ! updaterIsCorrect ) { <NEW_LINE> <START_VULN> <TAB> LOG_WARN ( ( "The updaters do not match , udpater will not run . " ) ) ; <NEW_LINE> <END_VULN> <TAB> result = FALSE ; <NEW_LINE> }
<TAB> <TAB> blockstodecode = s -> samples ; <NEW_LINE> <START_VULN> <TAB> av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , <NEW_LINE><TAB> <TAB> <TAB> <TAB> 2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! s -> decoded_buffer ) <NEW_LINE> <TAB> <TAB> return AVERROR ( ENOMEM ) ; <NEW_LINE> <TAB> memset ( s -> decoded_buffer , 0 , s -> decoded_size ) ;
<TAB> msr . host_initiated = false ; <NEW_LINE> <TAB> svm -> next_rip = kvm_rip_read ( & svm -> vcpu ) + 2 ; <NEW_LINE> <START_VULN> <TAB> if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> trace_kvm_msr_write_ex ( ecx , data ) ; <NEW_LINE> <TAB> <TAB> kvm_inject_gp ( & svm -> vcpu , 0 ) ; <NEW_LINE> <TAB> } else {
#include < linux / buffer_head . h > <NEW_LINE> #include < linux / init . h > <NEW_LINE> #include < linux / slab . h > <NEW_LINE> <START_VULN> #include < linux / mbcache . h > <NEW_LINE> <END_VULN> #include < linux / quotaops . h > <NEW_LINE> #include < linux / rwsem . h > <NEW_LINE> #include < linux / security . h >
<TAB> <TAB> <TAB> <TAB> mTrans -> mConnection -> SetSecurityCallbacks ( mCallbacks ) ; <NEW_LINE> <TAB> <TAB> <TAB> return NS_OK ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> private : <NEW_LINE> <TAB> <TAB> nsRefPtr < nsHttpTransaction > mTrans ; <NEW_LINE> <TAB> <TAB> nsCOMPtr < nsIInterfaceRequestor > mCallbacks ; <NEW_LINE> <TAB> } ; <NEW_LINE> <START_VULN> <TAB> Mutex mCallbacksLock ; <NEW_LINE> <END_VULN> <TAB> nsCOMPtr < nsIInterfaceRequestor > mCallbacks ; <NEW_LINE> <TAB> nsCOMPtr < nsITransportEventSink > mTransportSink ; <NEW_LINE> <TAB> nsCOMPtr < nsIEventTarget > mConsumerTarget ; <NEW_LINE> <TAB> nsCOMPtr < nsISupports > mSecurityInfo ; <NEW_LINE> <TAB> nsCOMPtr < nsIAsyncInputStream > mPipeIn ; <NEW_LINE> <TAB> nsCOMPtr < nsIAsyncOutputStream > mPipeOut ; <NEW_LINE> <TAB> nsCOMPtr < nsILoadGroupConnectionInfo > mLoadGroupCI ;
<TAB> <TAB> goto do_confirm ; <NEW_LINE> back_from_confirm : <NEW_LINE> <START_VULN> <TAB> if ( inet -> hdrincl ) <NEW_LINE> <END_VULN> <TAB> <TAB> err = raw_send_hdrinc ( sk , & fl4 , msg , len , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> & rt , msg -> msg_flags , & ipc . sockc ) ;
<TAB> <TAB> * dptr + + = ROSE_GFI | lci1 ; <NEW_LINE> <TAB> <TAB> * dptr + + = lci2 ; <NEW_LINE> <TAB> <TAB> * dptr + + = frametype ; <NEW_LINE> <START_VULN> <TAB> <TAB> * dptr + + = 0xAA ; <NEW_LINE> <END_VULN> <TAB> <TAB> memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; <NEW_LINE> <TAB> <TAB> dptr += ROSE_ADDR_LEN ; <NEW_LINE> <TAB> <TAB> memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ;
<TAB> <TAB> mOffscreenTexture ( 0 ) , <NEW_LINE> <TAB> <TAB> mFlipped ( false ) , <NEW_LINE> <TAB> <TAB> mBlitProgram ( 0 ) , <NEW_LINE> <TAB> <TAB> mBlitFramebuffer ( 0 ) , <NEW_LINE> <TAB> <TAB> mOffscreenDrawFBO ( 0 ) , <NEW_LINE> <TAB> <TAB> mOffscreenReadFBO ( 0 ) , <NEW_LINE> <TAB> <TAB> mOffscreenColorRB ( 0 ) , <NEW_LINE> <TAB> <TAB> mOffscreenDepthRB ( 0 ) , <NEW_LINE> <START_VULN> <TAB> <TAB> mOffscreenStencilRB ( 0 ) <NEW_LINE> <END_VULN> #ifdef DEBUG <NEW_LINE> <TAB> <TAB> , mGLError ( LOCAL_GL_NO_ERROR ) <NEW_LINE> #endif <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> mUserData . Init ( ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> virtual ~ GLContext ( ) {
#define _TIF_SYSCALL_TRACEPOINT <TAB> ( 1 << TIF_SYSCALL_TRACEPOINT ) <NEW_LINE> #define _TIF_WORK_SYSCALL_ENTRY <TAB> ( _TIF_NOHZ | _TIF_SYSCALL_TRACE | <TAB> \ <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> _TIF_SYSCALL_AUDIT | _TIF_SYSCALL_TRACEPOINT ) <NEW_LINE> <END_VULN> #define _TIF_WORK_SYSCALL_EXIT <TAB> ( _TIF_NOHZ | _TIF_SYSCALL_TRACE | <TAB> \
<TAB> if ( PASS == conn -> m -> local_tx_start ( conn , this_func TSRMLS_CC ) ) { <NEW_LINE> <TAB> <TAB> ret = conn -> m -> query ( conn , "COMMIT" , sizeof ( "COMMIT" ) - 1 TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <TAB> <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> DBG_RETURN ( ret ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "CRC32c ( Castagnoli ) , sparc64 crc32c opcode accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "crc32c" ) ; <NEW_LINE> <END_VULN> #include "crop_devid . c"
void pid_ns_release_proc ( struct pid_namespace * ns ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> mntput ( ns -> proc_mnt ) ; <NEW_LINE> <END_VULN> }
<TAB> <TAB> if ( apic_x2apic_mode ( apic ) ) { <NEW_LINE> <TAB> <TAB> <TAB> new -> ldr_bits = 32 ; <NEW_LINE> <TAB> <TAB> <TAB> new -> cid_shift = 16 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> new -> cid_mask = new -> lid_mask = 0xffff ; <NEW_LINE> <END_VULN> <TAB> <TAB> } else if ( kvm_apic_sw_enabled ( apic ) && <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ! new -> cid_mask && <NEW_LINE> <TAB> <TAB> <TAB> <TAB> kvm_apic_get_reg ( apic , APIC_DFR ) == APIC_DFR_CLUSTER ) {
<TAB> <TAB> zend_throw_exception_ex ( NULL , 0 , "can not find class % s" , class_name -> val TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> zend_string * fname = swoole_string_init ( ZEND_STRL ( PG ( unserialize_callback_func ) ) ) ; <NEW_LINE> <TAB> Z_STR ( user_func ) = fname ; <NEW_LINE> <TAB> Z_TYPE_INFO ( user_func ) = IS_STRING_EX ;
protected : <NEW_LINE> inline void DoInit ( JSObject * obj ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> mObj = UnboxArray ( obj , & mLength , & mData ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> private :
<TAB> <TAB> <TAB> ioc -> aic -> exit ( ioc -> aic ) ; <NEW_LINE> <TAB> <TAB> cfq_exit ( ioc ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> put_io_context ( ioc ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> } <NEW_LINE> struct io_context * alloc_io_context ( gfp_t gfp_flags , int node )
<TAB> if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) <NEW_LINE> <TAB> <TAB> return ( retval ) ; <NEW_LINE> <START_VULN> <TAB> if ( appl_version && strcmp ( inbuf . data , appl_version ) ) { <NEW_LINE><TAB> <TAB> if ( ! problem ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> problem = KRB5_SENDAUTH_BADAPPLVERS ; <NEW_LINE> <TAB> <TAB> <TAB> response = 2 ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> <TAB> <TAB> retcode = - EFAULT ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto err_i1 ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ioctl -> flags & DRM_UNLOCKED ) <NEW_LINE> <TAB> <TAB> <TAB> retcode = func ( dev , kdata , file_priv ) ; <NEW_LINE> <TAB> <TAB> else {
<TAB> for ( tidno = 0 , tid = & an -> tid [ tidno ] ; <NEW_LINE> <TAB> tidno < IEEE80211_NUM_TIDS ; tidno + + , tid + + ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! tid -> sched ) <NEW_LINE><TAB> <TAB> <TAB> continue ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> <TAB> ac = tid -> ac ; <NEW_LINE> <TAB> <TAB> txq = ac -> txq ; <NEW_LINE> <TAB> <TAB> ath_txq_lock ( sc , txq ) ; <NEW_LINE> <TAB> <TAB> buffered = ath_tid_has_buffered ( tid ) ; <NEW_LINE> <TAB> <TAB> tid -> sched = false ;
<TAB> ret = - EIO ; <NEW_LINE> <TAB> if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) && <NEW_LINE> <START_VULN> <TAB> ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> goto invalid_key ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Camellia Cipher Algorithm , sparc64 camellia opcode accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "aes" ) ; <NEW_LINE> <END_VULN> #include "crop_devid . c"
<TAB> <TAB> <TAB> txp -> size -= data_len ; <NEW_LINE> <TAB> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> xen_netbk_idx_release ( netbk , pending_idx ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> if ( txp -> flags & XEN_NETTXF_csum_blank )
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA256 Secure Hash Algorithm , Supplemental SSE3 accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha256" ) ; <NEW_LINE>MODULE_ALIAS ( "sha224" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> fl6 . fl6_sport = inet -> inet_sport ; <NEW_LINE> <TAB> <TAB> security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; <NEW_LINE> <TAB> <TAB> if ( IS_ERR ( dst ) ) {
<START_VULN> <NEW_LINE> <END_VULN> #define MEDIATYPE_TYPEMAX <TAB> 64 <TAB>
<TAB> <TAB> <TAB> if ( TRC -> count == 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> compute_curve_gamma_table_type0 ( gamma_table ) ; <NEW_LINE> <TAB> <TAB> <TAB> } else if ( TRC -> count == 1 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> compute_curve_gamma_table_type1 ( gamma_table , u8Fixed8Number_to_float ( TRC -> data [ 0 ] ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> compute_curve_gamma_table_type2 ( gamma_table , TRC -> data , TRC -> count ) ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PK11SlotInfo ** slot , bool willEscrow ) <NEW_LINE> { <NEW_LINE> JSString * jsString ; <NEW_LINE> <START_VULN> JSAutoByteString params , keyGenAlg ; <NEW_LINE> <END_VULN> int keySize ; <NEW_LINE> nsresult rv ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : #ifdef jail to whip a few platforms into the UNIX ideal . <NEW_LINE> <START_VULN> last mod : $ Id : os . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifdef HAVE_CONFIG_H <NEW_LINE> #include "config . h" <NEW_LINE> #endif <NEW_LINE> #include < math . h >
<TAB> <TAB> <TAB> if ( newmap ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> atable -> amap = newmap ; <NEW_LINE> <TAB> <TAB> <TAB> if ( newrev ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> atable -> amap = newrev ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> memset ( & newmap [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : floor backend 1 implementation <NEW_LINE> <START_VULN> last mod : $ Id : floor1 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
<TAB> <TAB> if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) <NEW_LINE> <TAB> <TAB> <TAB> return ( retval ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( strcmp ( inbuf . data , sendauth_version ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> problem = KRB5_SENDAUTH_BADAUTHVERS ; <NEW_LINE> <TAB> <TAB> <TAB> response = 1 ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> <TAB> parse_profile_level_id ( s , h264_data , value ) ; <NEW_LINE> <TAB> } else if ( ! strcmp ( attr , "sprop - parameter - sets" ) ) { <NEW_LINE> <TAB> <TAB> int ret ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( value [ strlen ( value ) - 1 ] == ' , ' ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> av_log ( s , AV_LOG_WARNING , "Missing PPS in sprop - parameter - sets , ignoring\n" ) ; <NEW_LINE> <TAB> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> goto out ; <NEW_LINE> <START_VULN> <TAB> skb -> mac . raw = skb -> data ; <NEW_LINE> <END_VULN> <TAB> skb_reserve ( skb , MAX_HEADER + sizeof ( struct iphdr ) ) ; <NEW_LINE> <TAB> if ( rta [ RTA_SRC - 1 ] )
<TAB> if ( likely ( atomic_inc_not_zero ( & sk -> sk_refcnt ) ) ) { <NEW_LINE> <TAB> <TAB> * skb_hwtstamps ( skb ) = * hwtstamps ; <NEW_LINE> <START_VULN> <TAB> <TAB> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> sock_put ( sk ) ; <NEW_LINE> <TAB> } <NEW_LINE> }
} <NEW_LINE> void StaticVertexBuffer : : reserveRequiredSpace ( ) <NEW_LINE> { <NEW_LINE> <TAB> if ( ! mVertexBuffer && mBufferSize == 0 ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> D3DPOOL pool = getDisplay ( ) -> getBufferPool ( D3DUSAGE_WRITEONLY ) ; <NEW_LINE> <TAB> <TAB> HRESULT result = mDevice -> CreateVertexBuffer ( mRequiredSpace , D3DUSAGE_WRITEONLY , 0 , pool , & mVertexBuffer , NULL ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> if ( FAILED ( result ) ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> ERR ( "Out of memory allocating a vertex buffer of size % lu . " , mRequiredSpace ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> mBufferSize = mRequiredSpace ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> else if ( mVertexBuffer && mBufferSize >= mRequiredSpace )
<TAB> bool skipWhitespace ; <NEW_LINE> <TAB> nscoord trailingWhitespace ; <NEW_LINE> <START_VULN> <TAB> nsTArray < nsIFrame * > floats ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> struct InlineMinWidthData : public InlineIntrinsicWidthData { <NEW_LINE> <TAB> InlineMinWidthData ( ) <NEW_LINE> <TAB> : trailingTextFrame ( nullptr ) <NEW_LINE> <TAB> , atStartOfLine ( true ) <NEW_LINE> <TAB> { }
<TAB> } <NEW_LINE> <TAB> if ( sax != NULL ) { <NEW_LINE> <START_VULN> <TAB> <TAB> memset ( sax , 0 , sizeof ( sax ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> sax -> sax25_family = AF_NETROM ; <NEW_LINE> <TAB> <TAB> skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , <NEW_LINE> <TAB> <TAB> <TAB> AX25_ADDR_LEN ) ;
<TAB> WebGLContextOptions mOptions ; <NEW_LINE> <TAB> PRPackedBool mInvalidated ; <NEW_LINE> <TAB> PRPackedBool mResetLayer ; <NEW_LINE> <TAB> PRPackedBool mVerbose ; <NEW_LINE> <TAB> PRPackedBool mOptionsFrozen ; <NEW_LINE> <TAB> WebGLuint mActiveTexture ; <NEW_LINE> <START_VULN> <TAB> WebGLenum mSynthesizedGLError ; <NEW_LINE> <END_VULN> <TAB> PRBool mShaderValidation ; <NEW_LINE> <TAB> PRInt32 mGLMaxVertexAttribs ; <NEW_LINE> <TAB> PRInt32 mGLMaxTextureUnits ; <NEW_LINE> <TAB> PRInt32 mGLMaxTextureSize ;
<TAB> <TAB> <TAB> shader -> DecrementAttachCount ( ) ; <NEW_LINE> <TAB> <TAB> <TAB> return PR_TRUE ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> return PR_FALSE ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> PRBool HasAttachedShaderOfType ( GLenum shaderType ) { <NEW_LINE> <TAB> <TAB> for ( PRUint32 i = 0 ; i < mAttachedShaders . Length ( ) ; + + i ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( mAttachedShaders [ i ] -> ShaderType ( ) == shaderType ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> return PR_TRUE ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> return PR_FALSE ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> PRBool HasBothShaderTypesAttached ( ) { <NEW_LINE> <TAB> <TAB> return
<TAB> <TAB> n = 0 ; <NEW_LINE> <TAB> <TAB> quantum = 0 ; <NEW_LINE> <START_VULN> <TAB> <TAB> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x += 2 ) <NEW_LINE> <END_VULN> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> for ( i = 0 ; i < 4 ; i + + ) <NEW_LINE> <TAB> <TAB> <TAB> {
<TAB> int line_count ; <NEW_LINE> <TAB> int http_code ; <NEW_LINE> <START_VULN> <TAB> int64_t chunksize ; <NEW_LINE><TAB> int64_t off , end_off , filesize ; <NEW_LINE> <END_VULN> <TAB> char * location ; <NEW_LINE> <TAB> HTTPAuthState auth_state ; <NEW_LINE> <TAB> HTTPAuthState proxy_auth_state ;
<TAB> if ( len < ndp_msg_type_info ( msg_type ) -> raw_struct_size ) <NEW_LINE> <TAB> <TAB> return false ; <NEW_LINE> <START_VULN> <TAB> return true ; <NEW_LINE> <END_VULN> } <NEW_LINE> static struct ndp_msg * ndp_msg_alloc ( void )
bool mFullScreen ; <NEW_LINE> void * mJavaView ; <NEW_LINE> #endif <NEW_LINE> nsPluginNativeWindow * mPluginWindow ; <NEW_LINE> nsRefPtr < nsNPAPIPluginInstance > mInstance ; <NEW_LINE> nsObjectFrame * mObjectFrame ; <NEW_LINE> <START_VULN> nsIContent * mContent ; <NEW_LINE> <END_VULN> nsCString mDocumentBase ; <NEW_LINE> bool mWidgetCreationComplete ; <NEW_LINE> nsCOMPtr < nsIWidget > mWidget ; <NEW_LINE> nsRefPtr < nsPluginHost > mPluginHost ; <NEW_LINE> #ifdef XP_MACOSX <NEW_LINE> NP_CGContext mCGPluginPortCopy ; <NEW_LINE> int32_t mInCGPaintLevel ;
#include "nsTArray . h" <NEW_LINE> #include "imgFrame . h" <NEW_LINE> #include "nsThreadUtils . h" <NEW_LINE> #include "DecodeStrategy . h" <NEW_LINE> #include "DiscardTracker . h" <NEW_LINE> #include "Orientation . h" <NEW_LINE> #include "nsIObserver . h" <NEW_LINE> #include "mozilla / MemoryReporting . h" <NEW_LINE> #include "mozilla / TimeStamp . h" <NEW_LINE> #include "mozilla / StaticPtr . h" <NEW_LINE> #include "mozilla / WeakPtr . h" <NEW_LINE> <START_VULN> #include "mozilla / Mutex . h" <NEW_LINE> <END_VULN> #ifdef DEBUG <NEW_LINE> #include "imgIContainerDebug . h" <NEW_LINE> #endif <NEW_LINE> class nsIInputStream ; <NEW_LINE> class nsIThreadPool ; <NEW_LINE> class nsIRequest ;
#endif <NEW_LINE> #ifndef M_PI <NEW_LINE> # define M_PI ( 3 . 1415926536f ) <NEW_LINE> #endif <NEW_LINE> #if defined ( _WIN32 ) && ! defined ( __SYMBIAN32__ ) <NEW_LINE> # include < malloc . h > <NEW_LINE> <START_VULN> # define rint ( x ) ( floor ( ( x ) + 0 . 5f ) ) <NEW_LINE> <END_VULN> # define NO_FLOAT_MATH_LIB <NEW_LINE> # define FAST_HYPOT ( a , b ) sqrt ( ( a ) * ( a ) + ( b ) * ( b ) ) <NEW_LINE> #endif <NEW_LINE> #if defined ( __SYMBIAN32__ ) && defined ( __WINS__ ) <NEW_LINE> void * _alloca ( size_t size ) ; <NEW_LINE> # define alloca _alloca <NEW_LINE> #endif
<TAB> const uint8_t * eod = ( data + size ) ; <NEW_LINE> <TAB> uint32_t flag , mask ; <NEW_LINE> <TAB> uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; <NEW_LINE> <START_VULN> <TAB> unsigned int x , y ; <NEW_LINE> <END_VULN> <TAB> char * ip0 , * ip1 , * ip2 , * ip3 ; <NEW_LINE> <TAB> flag = 0 ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 58 2014 / 05 / 13 16 : 41 : 06 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include < assert . h >
<TAB> <TAB> <TAB> <TAB> <TAB> struct icmp_bxm * param ) <NEW_LINE> { <NEW_LINE> <TAB> struct flowi4 fl4 = { <NEW_LINE> <START_VULN> <TAB> <TAB> . daddr = ( param -> replyopts . srr ? <NEW_LINE><TAB> <TAB> <TAB> param -> replyopts . faddr : iph -> saddr ) , <NEW_LINE> <END_VULN> <TAB> <TAB> . saddr = saddr , <NEW_LINE> <TAB> <TAB> . flowi4_tos = RT_TOS ( tos ) , <NEW_LINE> <TAB> <TAB> . flowi4_proto = IPPROTO_ICMP ,
int yr_re_fast_exec ( <NEW_LINE> <TAB> uint8_t * code , <NEW_LINE> <TAB> uint8_t * input_data , <NEW_LINE> <START_VULN> <TAB> size_t input_size , <NEW_LINE> <END_VULN> <TAB> int flags , <NEW_LINE> <TAB> RE_MATCH_CALLBACK_FUNC callback , <NEW_LINE> <TAB> void * callback_args )
: . . . . . . . . . . . . . . ___ | | <NEW_LINE> : . ''' |` / \ | | <NEW_LINE> : . . . . . ''' | / ` . . . . \| . . . | <NEW_LINE> : . . . . . . . . . . . . . . . . . . . . . . . . . |___|___|___| <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> |Sl |Sr |endW <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> | | |endSr <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> | |beginSr <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> | |endSl <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> |beginSl <NEW_LINE><TAB> <TAB> <TAB> |beginW <NEW_LINE> <END_VULN> #ifndef WORD_ALIGN <NEW_LINE> #define WORD_ALIGN 8 <NEW_LINE> #endif
<TAB> daddr = ipc . addr = rt -> rt_src ; <NEW_LINE> <TAB> ipc . opt = NULL ; <NEW_LINE> <TAB> ipc . tx_flags = 0 ; <NEW_LINE> <START_VULN> <TAB> if ( icmp_param -> replyopts . optlen ) { <NEW_LINE><TAB> <TAB> ipc . opt = & icmp_param -> replyopts ; <NEW_LINE><TAB> <TAB> if ( ipc . opt -> srr ) <NEW_LINE><TAB> <TAB> <TAB> daddr = icmp_param -> replyopts . faddr ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> struct flowi4 fl4 = {
unsigned int X509v3_addr_get_afi ( const IPAddressFamily * f ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return ( ( f != NULL && <NEW_LINE><TAB> <TAB> <TAB> f -> addressFamily != NULL && f -> addressFamily -> data != NULL ) <NEW_LINE><TAB> <TAB> <TAB> ? ( ( f -> addressFamily -> data [ 0 ] << 8 ) | ( f -> addressFamily -> data [ 1 ] ) ) <NEW_LINE><TAB> <TAB> <TAB> : 0 ) ; <NEW_LINE> <END_VULN> }
<START_VULN> void * sys_call_table [ __NR_syscalls ] __aligned ( 4096 ) = { <NEW_LINE> <END_VULN> <TAB> [ 0 . . . __NR_syscalls - 1 ] = sys_ni_syscall , <NEW_LINE> #include < asm / unistd . h > <NEW_LINE> } ;
<TAB> * xcfdata , <NEW_LINE> <TAB> * xcfodata ; <NEW_LINE> <START_VULN> xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ; <NEW_LINE> <END_VULN> if ( xcfdata == ( XCFPixelInfo * ) NULL ) <NEW_LINE> <TAB> ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , <NEW_LINE> <TAB> image -> filename ) ;
<TAB> pkiDebug ( "pkinit_verify_padata : entered ! \n" ) ; <NEW_LINE> <TAB> if ( data == NULL || data -> length <= 0 || data -> contents == NULL ) { <NEW_LINE> <START_VULN> <TAB> <TAB> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return ; <NEW_LINE> <TAB> }
<TAB> case OZ_GET_DESC_RSP : { <NEW_LINE> <TAB> <TAB> <TAB> struct oz_get_desc_rsp * body = <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ( struct oz_get_desc_rsp * ) usb_hdr ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> int data_len = elt -> length - <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> sizeof ( struct oz_get_desc_rsp ) + 1 ; <NEW_LINE><TAB> <TAB> <TAB> u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; <NEW_LINE><TAB> <TAB> <TAB> u16 total_size = <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> oz_dbg ( ON , "USB_REQ_GET_DESCRIPTOR - cnf\n" ) ; <NEW_LINE> <TAB> <TAB> <TAB> oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id ,
<TAB> } <NEW_LINE> <TAB> n = EXTRACT_32BITS ( & prep -> pp_n ) ; <NEW_LINE> <TAB> ps = ( const struct pgstate * ) ( prep + 1 ) ; <NEW_LINE> <START_VULN> <TAB> while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> const struct id_off * io , * ie ; <NEW_LINE> <TAB> <TAB> char c = ' < ' ;
static int nntp_hcache_namer ( const char * path , char * dest , size_t destlen ) <NEW_LINE> { <NEW_LINE> <START_VULN> return snprintf ( dest , destlen , " % s . hcache" , path ) ; <NEW_LINE> <END_VULN> }
{ <NEW_LINE> <TAB> HTTPContext * s = h -> priv_data ; <NEW_LINE> <TAB> URLContext * old_hd = s -> hd ; <NEW_LINE> <START_VULN> <TAB> int64_t old_off = s -> off ; <NEW_LINE> <END_VULN> <TAB> uint8_t old_buf [ BUFFER_SIZE ] ; <NEW_LINE> <TAB> int old_buf_size , ret ; <NEW_LINE> <TAB> AVDictionary * options = NULL ;
<TAB> struct drm_i915_gem_exec_object2 * exec2_list = NULL ; <NEW_LINE> <TAB> int ret ; <NEW_LINE> <START_VULN> <TAB> if ( args -> buffer_count < 1 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> DRM_DEBUG ( "execbuf2 with % d buffers\n" , args -> buffer_count ) ; <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> }
<START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN>
<TAB> <TAB> <TAB> const wbxml_decoding * map ) <NEW_LINE> { <NEW_LINE> <TAB> guint32 tvb_len = tvb_reported_length ( tvb ) ; <NEW_LINE> <START_VULN> <TAB> guint32 off = offset ; <NEW_LINE> <END_VULN> <TAB> guint32 len ; <NEW_LINE> <TAB> guint str_len ; <NEW_LINE> <TAB> guint32 ent ;
<TAB> zend_vspprintf ( & message , 0 , format , va ) ; <NEW_LINE> <TAB> if ( fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { <NEW_LINE> <START_VULN> <TAB> <TAB> zend_throw_error ( exception_ce , message ) ; <NEW_LINE> <END_VULN> <TAB> } else { <NEW_LINE> <TAB> <TAB> zend_error ( E_ERROR , " % s" , message ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> sun_info . length || ! sun_info . length ) <NEW_LINE> <TAB> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <TAB> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; <NEW_LINE> <START_VULN> <TAB> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && <NEW_LINE><TAB> <TAB> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) <NEW_LINE> <END_VULN> <TAB> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE> <TAB> bytes_per_line = sun_info . width * sun_info . depth ; <NEW_LINE> <TAB> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax (
<TAB> up = nla_data ( rp ) ; <NEW_LINE> <TAB> ulen = xfrm_replay_state_esn_len ( up ) ; <NEW_LINE> <START_VULN> <TAB> if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 )
<TAB> uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; <NEW_LINE> <TAB> int i , plane , vsub = desc -> log2_chroma_h ; <NEW_LINE> <START_VULN> <TAB> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ; <NEW_LINE> <TAB> <TAB> uint8_t * data = frame -> data [ plane ] ; <NEW_LINE> <TAB> <TAB> int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT ( inlink -> h , vsub ) : inlink -> h ;
#include "file . h" <NEW_LINE> #ifndef <TAB> lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : softmagic . c , v 1 . 187 2014 / 05 / 13 16 : 42 : 17 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <TAB> <NEW_LINE> #include "magic . h"
<TAB> <TAB> case CIPSO_V4_TAG_LOCAL : <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( ! ( skb -> dev -> flags & IFF_LOOPBACK ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> err_offset = opt_iter ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto validate_return_locked ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> int ret = 0 ; <NEW_LINE> <TAB> ve -> stretch + + ; <NEW_LINE> <TAB> if ( ve -> stretch > VE_MAXSTRETCH * 2 ) <NEW_LINE> <TAB> ve -> stretch = VE_MAXSTRETCH * 2 ; <NEW_LINE> <TAB> for ( i = 0 ; i < ve -> ch ; i + + ) { <NEW_LINE> <TAB> float * pcm = v -> pcm [ i ] + ve -> searchstep * ( j ) ; <NEW_LINE> <START_VULN> <TAB> ret |= _ve_amp ( ve , gi , pcm , ve -> band , ve -> filter + i * VE_BANDS , j ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> ve -> mark [ j + VE_POST ] = 0 ; <NEW_LINE> <TAB> if ( ret & 1 ) { <NEW_LINE> <TAB> ve -> mark [ j ] = 1 ; <NEW_LINE> <TAB> ve -> mark [ j + 1 ] = 1 ; <NEW_LINE> <TAB> }
class nsContentUtils <NEW_LINE> { <NEW_LINE> typedef mozilla : : dom : : Element Element ; <NEW_LINE> public : <NEW_LINE> static nsresult Init ( ) ; <NEW_LINE> <START_VULN> static nsresult GetContextAndScopes ( nsIDocument * aOldDocument , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIDocument * aNewDocument , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSContext ** aCx , JSObject ** aOldScope , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject ** aNewScope ) ; <NEW_LINE> <END_VULN> static nsresult ReparentContentWrappersInScope ( nsIScriptGlobalObject * aOldScope , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIScriptGlobalObject * aNewScope ) ;
<TAB> e . endian = d [ 0 ] == 'I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG ; <NEW_LINE> <START_VULN> <TAB> ifd = iw_get_ui32_e ( & d [ 4 ] , e . endian ) ; <NEW_LINE> <END_VULN> <TAB> iwjpeg_scan_exif_ifd ( rctx , & e , ifd ) ; <NEW_LINE> }
<TAB> <TAB> image -> storage_class = PseudoClass ; <NEW_LINE> <TAB> <TAB> image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( EOFBlob ( image ) != MagickFalse ) <NEW_LINE><TAB> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE><TAB> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <NEW_LINE> <END_VULN> <TAB> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) <NEW_LINE> <TAB> <TAB> break ; <NEW_LINE> <TAB> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;
<TAB> <TAB> <TAB> for ( j = 0 ; j < 2 ; j + + ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> band -> prec = av_malloc_array ( reslevel -> num_precincts_x * <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ( uint64_t ) reslevel -> num_precincts_y , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> sizeof ( * band -> prec ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ! band -> prec )
<TAB> <TAB> return NULL ; <NEW_LINE> <TAB> <TAB> } ; <NEW_LINE> <START_VULN> <TAB> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <NEW_LINE> <END_VULN> <TAB> { <TAB> sf_errno = SFE_MALLOC_FAILED ; <NEW_LINE> <TAB> <TAB> return <TAB> NULL ; <NEW_LINE> <TAB> <TAB> } ;
<TAB> len = ( * p ) [ 0 ] << 8 | ( * p ) [ 1 ] ; <NEW_LINE> <TAB> * p += 2 ; <NEW_LINE> <START_VULN> <TAB> if ( ( * p ) + len > end ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> <TAB> MBEDTLS_SSL_DEBUG_MSG ( 1 , ( "bad server key exchange message " <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> " ( psk_identity_hint length ) " ) ) ;
<TAB> <TAB> <TAB> <TAB> if ( limit_val != - 1 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> limit_val -- ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> last_match = & subject [ offsets [ 1 ] ] ; <NEW_LINE> <TAB> <TAB> <TAB> next_offset = offsets [ 1 ] ;
<TAB> NS_HIDDEN_ ( PRBool ) URIEquals ( const URL & aOther ) const ; <NEW_LINE> <TAB> nsCOMPtr < nsIURI > mURI ; <NEW_LINE> <TAB> nsStringBuffer * mString ; <NEW_LINE> <TAB> nsCOMPtr < nsIURI > mReferrer ; <NEW_LINE> <TAB> nsCOMPtr < nsIPrincipal > mOriginPrincipal ; <NEW_LINE> <START_VULN> <TAB> void AddRef ( ) { + + mRefCnt ; } <NEW_LINE><TAB> void Release ( ) { if ( -- mRefCnt == 0 ) delete this ; } <NEW_LINE> <END_VULN> protected : <NEW_LINE> <TAB> nsrefcnt mRefCnt ; <NEW_LINE> } ; <NEW_LINE> struct Image : public URL {
<START_VULN> #define LIST_POISON1 ( ( void * ) 0x00100100 + POISON_POINTER_DELTA ) <NEW_LINE>#define LIST_POISON2 ( ( void * ) 0x00200200 + POISON_POINTER_DELTA ) <NEW_LINE> <END_VULN>
<TAB> tsk -> flags |= PF_EXITPIDONE ; <NEW_LINE> <TAB> if ( tsk -> io_context ) <NEW_LINE> <START_VULN> <TAB> <TAB> exit_io_context ( ) ; <NEW_LINE> <END_VULN> <TAB> if ( tsk -> splice_pipe ) <NEW_LINE> <TAB> <TAB> __free_pipe_info ( tsk -> splice_pipe ) ;
<TAB> <TAB> return rc ; <NEW_LINE> <TAB> rc = assign_eip_far ( ctxt , ctxt -> src . val , & new_desc ) ; <NEW_LINE> <START_VULN> <TAB> if ( rc != X86EMUL_CONTINUE ) { <NEW_LINE><TAB> <TAB> WARN_ON ( ctxt -> mode != X86EMUL_MODE_PROT64 ) ; <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS ) ; <NEW_LINE><TAB> <TAB> return rc ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> return rc ; <NEW_LINE> }
static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> u16 selector , int seg , u8 cpl , bool in_task_switch ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct desc_struct seg_desc , old_desc ; <NEW_LINE> <TAB> u8 dpl , rpl ;
<TAB> <TAB> <TAB> <TAB> return - E2BIG ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> env -> used_maps [ env -> used_map_cnt + + ] = map ; <NEW_LINE><NEW_LINE><TAB> <TAB> <TAB> bpf_map_inc ( map , false ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> fdput ( f ) ; <NEW_LINE> next_insn : <NEW_LINE> <TAB> <TAB> <TAB> insn + + ;
<TAB> char * fn = rpmfilesFN ( files , firsthardlink ) ; <NEW_LINE> <START_VULN> <TAB> rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ; <NEW_LINE> <END_VULN> <TAB> firsthardlink = - 1 ; <NEW_LINE> <TAB> free ( fn ) ; <NEW_LINE> <TAB> }
<TAB> . open = ftrace_notrace_open , <NEW_LINE> <TAB> . read = seq_read , <NEW_LINE> <TAB> . write = ftrace_notrace_write , <NEW_LINE> <START_VULN> <TAB> . llseek = ftrace_regex_lseek , <NEW_LINE> <END_VULN> <TAB> . release = ftrace_regex_release , <NEW_LINE> } ;
#define CEPH_MSGR_TAG_SEQ 13 <NEW_LINE> #define CEPH_MSGR_TAG_KEEPALIVE2 14 <NEW_LINE> #define CEPH_MSGR_TAG_KEEPALIVE2_ACK 15 <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 60 2014 / 05 / 21 13 : 04 : 38 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include < assert . h >
<TAB> <TAB> STATE_UNINITIALIZED , <NEW_LINE> <TAB> <TAB> STATE_INITIALIZED , <NEW_LINE> <TAB> <TAB> STATE_CHECKING , <NEW_LINE> <TAB> <TAB> STATE_DOWNLOADING , <NEW_LINE> <TAB> <TAB> STATE_CANCELLED , <NEW_LINE> <TAB> <TAB> STATE_FINISHED <NEW_LINE> <TAB> } mState ; <NEW_LINE> <START_VULN> <TAB> nsOfflineCacheUpdateOwner * mOwner ; <NEW_LINE> <END_VULN> <TAB> bool mAddedItems ; <NEW_LINE> <TAB> bool mPartialUpdate ; <NEW_LINE> <TAB> bool mOnlyCheckUpdate ; <NEW_LINE> <TAB> bool mSucceeded ; <NEW_LINE> <TAB> bool mObsolete ; <NEW_LINE> <TAB> nsCString mUpdateDomain ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : bitrate tracking and management <NEW_LINE> <START_VULN> last mod : $ Id : bitrate . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_BITRATE_H_ <NEW_LINE> #define _V_BITRATE_H_ <NEW_LINE> #include "vorbis / codec . h" <NEW_LINE> #include "codec_internal . h"
<TAB> void prependToViews ( ArrayBufferViewObject * viewsHead ) ; <NEW_LINE> <START_VULN> <TAB> void neuter ( JSContext * cx ) ; <NEW_LINE> <END_VULN> <TAB> static void trace ( JSTracer * trc , JSObject * obj ) ; <NEW_LINE> } ;
<TAB> } <NEW_LINE> <TAB> free ( prime_arg ) ; <NEW_LINE> <START_VULN> <TAB> gss_release_buffer ( & minor_stat , & client_name ) ; <NEW_LINE><TAB> gss_release_buffer ( & minor_stat , & service_name ) ; <NEW_LINE> <END_VULN> exit_func : <NEW_LINE> <TAB> free_server_handle ( handle ) ; <NEW_LINE> <TAB> return & ret ; <NEW_LINE> }
<TAB> q . rt_waiter = & rt_waiter ; <NEW_LINE> <TAB> q . requeue_pi_key = & key2 ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> ret = futex_wait_setup ( uaddr , val , fshared , & q , & hb ) ; <NEW_LINE> <TAB> if ( ret ) <NEW_LINE> <TAB> <TAB> goto out_key2 ;
<TAB> } <NEW_LINE> <START_VULN> <TAB> ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ; <NEW_LINE> <END_VULN> <TAB> pd = ws_buffer_start_ptr ( buf ) ;
<TAB> NS_ConvertUTF16toUTF8 utf8str ( reinterpret_cast < const PRUnichar * > ( chars ) ) ; <NEW_LINE> #ifdef ANDROID <NEW_LINE> <START_VULN> <TAB> __android_log_print ( ANDROID_LOG_INFO , "Gecko" , utf8str . get ( ) ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> <TAB> fputs ( utf8str . get ( ) , stdout ) ; <NEW_LINE> <TAB> fflush ( stdout ) ;
<TAB> for ( ; num ; num -- ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( pread ( fd , xph_addr , xph_sizeof , off ) == - 1 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> file_badread ( ms ) ; <NEW_LINE> <TAB> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> <TAB> }
<TAB> duprintf ( "check_compat_entry_size_and_hooks % p\n" , e ) ; <NEW_LINE> <TAB> if ( ( unsigned long ) e % __alignof__ ( struct compat_ip6t_entry ) != 0 || <NEW_LINE> <START_VULN> <TAB> ( unsigned char * ) e + sizeof ( struct compat_ip6t_entry ) >= limit ) { <NEW_LINE> <END_VULN> <TAB> <TAB> duprintf ( "Bad offset % p , limit = % p\n" , e , limit ) ; <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> unsigned long long hard , soft ; <NEW_LINE> <TAB> <TAB> <TAB> int soft_seconds ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( class == - 1 ) { <NEW_LINE><TAB> <TAB> <TAB> <TAB> err = "Unrecognized client limit class" ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> goto loaderr ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> hard = memtoll ( argv [ 2 ] , NULL ) ;
<TAB> tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; <NEW_LINE> <TAB> tcp_hdrlen = tcph -> doff * 4 ; <NEW_LINE> <START_VULN> <TAB> if ( len < tcp_hdrlen ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) {
<TAB> <TAB> unsigned long nr_segs , loff_t * poffset ) <NEW_LINE> { <NEW_LINE> <TAB> unsigned long nr_pages , i ; <NEW_LINE> <START_VULN> <TAB> size_t copied , len , cur_len ; <NEW_LINE> <END_VULN> <TAB> ssize_t total_written = 0 ; <NEW_LINE> <TAB> loff_t offset ; <NEW_LINE> <TAB> struct iov_iter it ;
<TAB> <TAB> goto err ; <NEW_LINE> <TAB> for ( j = 0 ; j < numpipes ; j + + ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( SSL_USE_ETM ( s ) && mac_size != 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> outbuf [ j ] + wr [ j ] . length , 1 ) < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto err ;
<TAB> <TAB> int2store ( buffer , ( unsigned int ) option ) ; <NEW_LINE> <TAB> <TAB> ret = conn -> m -> simple_command ( conn , COM_SET_OPTION , buffer , sizeof ( buffer ) , PROT_EOF_PACKET , FALSE , TRUE TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> DBG_RETURN ( ret ) ;
<TAB> <TAB> break ; <NEW_LINE> <TAB> case SKFP_CLR_STATS : <TAB> <NEW_LINE> <TAB> <TAB> if ( ! capable ( CAP_NET_ADMIN ) ) { <NEW_LINE> <TAB> <TAB> <TAB> memset ( & lp -> MacStat , 0 , sizeof ( lp -> MacStat ) ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> } else { <NEW_LINE><TAB> <TAB> <TAB> status = - EPERM ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> break ; <NEW_LINE> <TAB> default :
<TAB> <TAB> phar_obj -> arc . archive -> ufp = pass . fp ; <NEW_LINE> <TAB> <TAB> phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } else {
<TAB> <TAB> JAS_CAST ( int , pchg -> lyrnoend ) ; + + pi -> lyrno ) { <NEW_LINE> <TAB> <TAB> <TAB> for ( pi -> compno = pchg -> compnostart , pi -> picomp = <NEW_LINE> <TAB> <TAB> <TAB> & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; + + pi -> compno , + + pi -> picomp ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
<TAB> <TAB> <TAB> <TAB> ( u8 * ) & settings -> beacon . head [ ie_offset ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> settings -> beacon . head_len - ie_offset , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> WLAN_EID_SSID ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! ssid_ie ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> <TAB> memcpy ( ssid_le . SSID , ssid_ie -> data , ssid_ie -> len ) ;
<TAB> <TAB> <TAB> w_align = 4 ; <NEW_LINE> <TAB> <TAB> <TAB> h_align = 4 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> if ( s -> codec_id == AV_CODEC_ID_JV ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> w_align = 8 ; <NEW_LINE> <TAB> <TAB> <TAB> h_align = 8 ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> ( void ) WriteBlobString ( image , buffer ) ; <NEW_LINE> <TAB> <TAB> ( void ) CopyMagickString ( tuple , " ( " , MagickPathExtent ) ; <NEW_LINE> <TAB> <TAB> if ( pixel . colorspace == GRAYColorspace ) <NEW_LINE> <START_VULN> <TAB> <TAB> ConcatenateColorComponent ( & pixel , GrayPixelChannel , compliance , <NEW_LINE><TAB> <TAB> <TAB> tuple ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> else <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> ConcatenateColorComponent ( & pixel , RedPixelChannel , compliance , tuple ) ;
<START_VULN> <TAB> assert ( n >= 0 && n < 32 ) ; <NEW_LINE> <END_VULN> <TAB> v = 0 ;
module_init ( sha256_s390_init ) ; <NEW_LINE> module_exit ( sha256_s390_fini ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha256" ) ; <NEW_LINE>MODULE_ALIAS ( "sha224" ) ; <NEW_LINE> <END_VULN> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA256 and SHA224 Secure Hash Algorithm" ) ;
<TAB> <TAB> <TAB> vA = ( int ) buf [ 1 ] ; <NEW_LINE> <TAB> <TAB> <TAB> vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <NEW_LINE> <TAB> <TAB> <TAB> vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> sprintf ( str , " { v % i . . v % i } , [ % 04x ] " , vC , vC + vA - 1 , vB ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> strasm = r_str_concat ( strasm , str ) ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> case fmtoptinvokeVS :
<TAB> <TAB> sig_len = ( p [ 0 ] << 8 ) | p [ 1 ] ; <NEW_LINE> <TAB> <TAB> p += 2 ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( end != p + sig_len ) <NEW_LINE> <END_VULN> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> MBEDTLS_SSL_DEBUG_MSG ( 1 , ( "bad server key exchange message" ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> mbedtls_ssl_send_alert_message ( ssl , MBEDTLS_SSL_ALERT_LEVEL_FATAL ,
<TAB> alternative_input ( <NEW_LINE> <TAB> <TAB> "1 : " XRSTOR , <NEW_LINE> <START_VULN> <TAB> <TAB> "1 : " XRSTORS , <NEW_LINE> <END_VULN> <TAB> <TAB> X86_FEATURE_XSAVES , <NEW_LINE> <TAB> <TAB> "D" ( fx ) , "m" ( * fx ) , "a" ( lmask ) , "d" ( hmask ) <NEW_LINE> <TAB> <TAB> : "memory" ) ;
<TAB> int length ; <NEW_LINE> <TAB> length = strlen ( filename ) ; <NEW_LINE> <START_VULN> <TAB> if ( length > 0 ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> <TAB> if ( ( filename [ 0 ] == '\"' ) && ( filename [ length - 1 ] == '\"' ) ) <NEW_LINE> <TAB> <TAB> <TAB> return weechat_strndup ( filename + 1 , length - 2 ) ;
<TAB> s += 11 ; <NEW_LINE> <TAB> SKIPWS ( s ) ; <NEW_LINE> <TAB> ptmp = tmp ; <NEW_LINE> <START_VULN> <TAB> while ( isdigit ( ( unsigned char ) * s ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> * ptmp + + = * s + + ; <NEW_LINE> <TAB> * ptmp = '\0' ; <NEW_LINE> <TAB> if ( mutt_str_atol ( tmp , & h -> content_length ) < 0 ) <NEW_LINE> commit 1b0f0d0988e6df4e32e9f4bf8780846ea95d4485 <NEW_LINE> Author : JerikoOne < jeriko . one@gmx . us > <NEW_LINE> Date : Sat Jul 7 14 : 03 : 46 2018 - 0500 <NEW_LINE> <TAB> Don't overflow stack buffer in msg_parse_fetch
<TAB> <TAB> <TAB> if ( strcmp ( keyring -> description , name ) != 0 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( ! skip_perm_check && <NEW_LINE><TAB> <TAB> <TAB> key_permission ( make_key_ref ( keyring , 0 ) , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> KEY_NEED_SEARCH ) < 0 ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <END_VULN>
static int CVE_2013_2548_crypto_report_one ( struct crypto_alg * alg , <NEW_LINE> <TAB> <TAB> <TAB> struct crypto_user_alg * ualg , struct sk_buff * skb ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <NEW_LINE><TAB> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <NEW_LINE><TAB> sizeof ( ualg -> cru_driver_name ) ) ; <NEW_LINE><TAB> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <NEW_LINE><TAB> CRYPTO_MAX_ALG_NAME ) ; <NEW_LINE> <END_VULN> <TAB> ualg -> cru_flags = alg -> cra_flags ; <NEW_LINE> <TAB> ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ;
static int rtnl_fill_link_ifmap ( struct sk_buff * skb , struct net_device * dev ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> struct rtnl_link_ifmap map = { <NEW_LINE><TAB> <TAB> . mem_start = dev -> mem_start , <NEW_LINE><TAB> <TAB> . mem_end = dev -> mem_end , <NEW_LINE><TAB> <TAB> . base_addr = dev -> base_addr , <NEW_LINE><TAB> <TAB> . irq = dev -> irq , <NEW_LINE><TAB> <TAB> . dma = dev -> dma , <NEW_LINE><TAB> <TAB> . port = dev -> if_port , <NEW_LINE><TAB> } ; <NEW_LINE> <END_VULN> <TAB> if ( nla_put ( skb , IFLA_MAP , sizeof ( map ) , & map ) ) <NEW_LINE> <TAB> <TAB> return - EMSGSIZE ;
<TAB> <TAB> PHPDBG_G ( flags ) |= PHPDBG_IS_INITIALIZING ; <NEW_LINE> <TAB> <TAB> zend_try { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> phpdbg_init ( init_file , init_file_len , init_file_default ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( bp_tmp ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> PHPDBG_G ( flags ) |= PHPDBG_DISCARD_OUTPUT ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> phpdbg_string_init ( bp_tmp ) ;
<TAB> <TAB> unsigned char __user * ured ; <NEW_LINE> <TAB> <TAB> unsigned char __user * ugreen ; <NEW_LINE> <TAB> <TAB> unsigned char __user * ublue ; <NEW_LINE> <START_VULN> <TAB> <TAB> int index , count , i ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( get_user ( index , & c -> index ) || <NEW_LINE> <TAB> <TAB> __get_user ( count , & c -> count ) ||
<TAB> NS_DECL_ISUPPORTS_INHERITED <NEW_LINE> <TAB> NS_DECL_NSIPROXIEDCHANNEL <NEW_LINE> <TAB> nsIProxyInfo * ProxyInfo ( ) { return mProxyInfo ; } <NEW_LINE> protected : <NEW_LINE> <TAB> virtual ~ nsGopherChannel ( ) { } <NEW_LINE> <START_VULN> <TAB> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result ) ; <NEW_LINE> <END_VULN> <TAB> virtual PRBool GetStatusArg ( nsresult status , nsString & statusArg ) ; <NEW_LINE> private : <NEW_LINE> <TAB> nsresult SendRequest ( nsIOutputStream * stream ) ; <NEW_LINE> <TAB> nsCOMPtr < nsIProxyInfo > mProxyInfo ; <NEW_LINE> } ;
<TAB> int ret = 0 ; <NEW_LINE> <TAB> bool unlisted = false ; <NEW_LINE> <START_VULN> <TAB> if ( po -> fanout ) <NEW_LINE><TAB> <TAB> return - EINVAL ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> lock_sock ( sk ) ; <NEW_LINE> <TAB> spin_lock ( & po -> bind_lock ) ; <NEW_LINE> <TAB> rcu_read_lock ( ) ; <NEW_LINE> <TAB> if ( name ) { <NEW_LINE> <TAB> <TAB> dev = dev_get_by_name_rcu ( sock_net ( sk ) , name ) ; <NEW_LINE> <TAB> <TAB> if ( ! dev ) {
<TAB> fl6 . daddr = sk -> sk_v6_daddr ; <NEW_LINE> <START_VULN> <TAB> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <NEW_LINE> <END_VULN> <TAB> rcu_read_unlock ( ) ; <NEW_LINE> <TAB> return res ; <NEW_LINE> }
<TAB> va_start ( argptr , format ) ; <NEW_LINE> <TAB> while ( ( c = * format + + ) ) <NEW_LINE> <START_VULN> <TAB> { <TAB> switch ( c ) <NEW_LINE> <END_VULN> <TAB> <TAB> { <TAB> case ' ' : <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> break ;
{ <NEW_LINE> <TAB> rtnl_link_unregister ( & ipgre_tap_ops ) ; <NEW_LINE> <TAB> rtnl_link_unregister ( & ipgre_link_ops ) ; <NEW_LINE> <START_VULN> <TAB> unregister_pernet_device ( & ipgre_net_ops ) ; <NEW_LINE> <END_VULN> <TAB> if ( inet_del_protocol ( & ipgre_protocol , IPPROTO_GRE ) < 0 ) <NEW_LINE> <TAB> <TAB> printk ( KERN_INFO "ipgre close : can't remove protocol\n" ) ; <NEW_LINE> } <NEW_LINE> module_init ( ipgre_init ) ;
<TAB> <TAB> if ( ! lfi ) <NEW_LINE> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <START_VULN> <TAB> <TAB> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) <NEW_LINE> <TAB> <TAB> <TAB> goto out_ok ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> gdCtxPrintf ( out , " } ; \n" ) ; <NEW_LINE> <END_VULN> }
<TAB> le16_to_cpu ( entry -> e_value_offs ) + size > inode -> i_sb -> s_blocksize ) <NEW_LINE> <TAB> <TAB> goto bad_block ; <NEW_LINE> <START_VULN> <TAB> if ( ext2_xattr_cache_insert ( bh ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> ea_idebug ( inode , "cache insert failed" ) ; <NEW_LINE> <TAB> if ( buffer ) { <NEW_LINE> <TAB> <TAB> error = - ERANGE ;
<TAB> retval = copy_strings_kernel ( 1 , & i_name , bprm ) ; <NEW_LINE> <TAB> if ( retval ) return retval ; <NEW_LINE> <TAB> bprm -> argc + + ; <NEW_LINE> <START_VULN> <TAB> bprm -> interp = interp ; <NEW_LINE> <END_VULN> <TAB> file = open_exec ( interp ) ;
static gboolean netscreen_seek_read ( wtap * wth , gint64 seek_off , <NEW_LINE> <TAB> struct wtap_pkthdr * phdr , Buffer * buf , <NEW_LINE> <TAB> int * err , gchar ** err_info ) ; <NEW_LINE> <START_VULN> static int parse_netscreen_rec_hdr ( struct wtap_pkthdr * phdr , const char * line , <NEW_LINE><TAB> char * cap_int , gboolean * cap_dir , char * cap_dst , <NEW_LINE><TAB> int * err , gchar ** err_info ) ; <NEW_LINE>static gboolean parse_netscreen_hex_dump ( FILE_T fh , int pkt_len , <NEW_LINE><TAB> const char * cap_int , const char * cap_dst , struct wtap_pkthdr * phdr , <NEW_LINE><TAB> Buffer * buf , int * err , gchar ** err_info ) ; <NEW_LINE> <END_VULN> static int parse_single_hex_dump_line ( char * rec , guint8 * buf , <NEW_LINE> <TAB> guint byte_offset ) ;
<TAB> <TAB> <TAB> guint32 offset , guint32 str_tbl , guint8 level , guint8 * codepage_attr ) <NEW_LINE> { <NEW_LINE> <TAB> guint32 tvb_len = tvb_reported_length ( tvb ) ; <NEW_LINE> <START_VULN> <TAB> guint32 off = offset ; <NEW_LINE> <END_VULN> <TAB> guint32 len ; <NEW_LINE> <TAB> guint str_len ; <NEW_LINE> <TAB> guint32 ent ;
} <NEW_LINE> else if ( enc == ENCBASE64 ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ; <NEW_LINE><TAB> int dlen = mutt_b64_decode ( out , it ) ; <NEW_LINE> <END_VULN> <TAB> if ( dlen == - 1 ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> FREE ( & out ) ;
Compatible Regular Expression library . It defines the things POSIX says should <NEW_LINE> be there . I hope . <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> Copyright ( c ) 1997 - 2007 University of Cambridge <NEW_LINE> <END_VULN> -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - <NEW_LINE> Redistribution and use in source and binary forms , with or without
<TAB> <TAB> <TAB> <TAB> <TAB> goto inval ; <NEW_LINE> <TAB> <TAB> <TAB> } else if ( uref -> usage_index >= field -> report_count ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto inval ; <NEW_LINE> <START_VULN> <NEW_LINE><TAB> <TAB> <TAB> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <NEW_LINE><TAB> <TAB> <TAB> <TAB> ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || <NEW_LINE><TAB> <TAB> <TAB> <TAB> uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> goto inval ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> switch ( cmd ) { <NEW_LINE> <TAB> <TAB> case HIDIOCGUSAGE : <NEW_LINE> <TAB> <TAB> <TAB> uref -> value = field -> value [ uref -> usage_index ] ;
<TAB> <TAB> <TAB> status_buf , KLSI_STATUSBUF_LEN , <NEW_LINE> <TAB> <TAB> <TAB> 10000 <NEW_LINE> <TAB> <TAB> <TAB> ) ; <NEW_LINE> <START_VULN> <TAB> if ( rc < 0 ) <NEW_LINE><TAB> <TAB> dev_err ( & port -> dev , "Reading line status failed ( error = % d ) \n" , <NEW_LINE><TAB> <TAB> <TAB> rc ) ; <NEW_LINE><TAB> else { <NEW_LINE> <END_VULN> <TAB> <TAB> status = get_unaligned_le16 ( status_buf ) ; <NEW_LINE> <TAB> <TAB> dev_info ( & port -> serial -> dev -> dev , "read status % x % x\n" ,
int sfgets ( void ) <NEW_LINE> { <NEW_LINE> <TAB> struct pollfd pfd ; <NEW_LINE> <TAB> int pollret ; <NEW_LINE> <TAB> ssize_t readnb ; <NEW_LINE> <TAB> signed char seen_r = 0 ; <NEW_LINE> <START_VULN> <TAB> static size_t scanned ; <NEW_LINE><TAB> static size_t readnbd ; <NEW_LINE> <END_VULN> <TAB> if ( scanned > ( size_t ) 0U ) { <NEW_LINE> <TAB> <TAB> readnbd -= scanned ;
int vorbis_synthesis_lapout ( vorbis_dsp_state * v , float ** * pcm ) { <NEW_LINE> vorbis_info * vi = v -> vi ; <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> <START_VULN> int hs = ci -> halfrate_flag ; <NEW_LINE><NEW_LINE> <END_VULN> int n = ci -> blocksizes [ v -> W ] >> ( hs + 1 ) ; <NEW_LINE> int n0 = ci -> blocksizes [ 0 ] >> ( hs + 1 ) ; <NEW_LINE> int n1 = ci -> blocksizes [ 1 ] >> ( hs + 1 ) ; <NEW_LINE> int i , j ; <NEW_LINE> if ( v -> pcm_returned < 0 ) return 0 ; <NEW_LINE> if ( ( v -> lW ^ v -> W ) == 1 ) { <NEW_LINE> <TAB> for ( j = 0 ; j < vi -> channels ; j + + ) { <NEW_LINE> <TAB> float * s = v -> pcm [ j ] ; <NEW_LINE> <TAB> float * d = v -> pcm [ j ] + ( n1 - n0 ) / 2 ; <NEW_LINE> <TAB> for ( i = ( n1 + n0 ) / 2 - 1 ; i >= 0 ; -- i ) <NEW_LINE> <TAB> <TAB> d [ i ] = s [ i ] ;
<TAB> if ( ( sess != NULL ) && <NEW_LINE> <TAB> <TAB> ( s -> enc_read_ctx != NULL ) && <NEW_LINE> <START_VULN> <TAB> <TAB> ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) && ! SSL_USE_ETM ( s ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> unsigned char * mac = NULL ; <NEW_LINE> <TAB> <TAB> unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ;
#define OFFT_MAX ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) <NEW_LINE> #define LINELEN 256 <TAB> <NEW_LINE> <START_VULN> #define BUFSIZE ( 1024 * 1024 ) <NEW_LINE> <END_VULN> #define DIFFPAGESIZE 4096 <NEW_LINE> #define F_READONLY 1 <NEW_LINE> #define F_MULTIFILE 2 <TAB>
<TAB> . lock <TAB> <TAB> = gfs2_lock , <NEW_LINE> <TAB> . flock <TAB> <TAB> = gfs2_flock , <NEW_LINE> <TAB> . splice_read <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> <TAB> . setlease <TAB> = gfs2_setlease , <NEW_LINE> <TAB> . fallocate <TAB> = gfs2_fallocate , <NEW_LINE> } ;
SH_DEPENDENCY_GRAPH = 0x0400 , <NEW_LINE> <START_VULN> SH_ENFORCE_PACKING_RESTRICTIONS = 0x0800 <NEW_LINE> <END_VULN> } ShCompileOptions ; <NEW_LINE> COMPILER_EXPORT int ShInitialize ( ) ;
<START_VULN> <TAB> <TAB> <TAB> * mtu = dst_mtu ( rt -> dst . path ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> * maxfraglen = ( ( * mtu - fragheaderlen ) & ~ 7 ) <NEW_LINE> <TAB> <TAB> <TAB> + fragheaderlen - sizeof ( struct frag_hdr ) ;
<TAB> n = e -> band [ j ] . end ; <NEW_LINE> <TAB> e -> band [ j ] . window = _ogg_malloc ( n * sizeof ( * e -> band [ 0 ] . window ) ) ; <NEW_LINE> <TAB> for ( i = 0 ; i < n ; i + + ) { <NEW_LINE> <TAB> e -> band [ j ] . window [ i ] = sin ( ( i + . 5 ) / n * M_PI ) ; <NEW_LINE> <TAB> e -> band [ j ] . total += e -> band [ j ] . window [ i ] ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> e -> band [ j ] . total = 1 . / e -> band [ j ] . total ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> e -> filter = _ogg_calloc ( VE_BANDS * ch , sizeof ( * e -> filter ) ) ; <NEW_LINE> e -> mark = _ogg_calloc ( e -> storage , sizeof ( * e -> mark ) ) ; <NEW_LINE> } <NEW_LINE> void _ve_envelope_clear ( envelope_lookup * e ) { <NEW_LINE> int i ; <NEW_LINE> mdct_clear ( & e -> mdct ) ;
<TAB> CRM_CHECK ( client != NULL , return TRUE ) ; <NEW_LINE> <TAB> CRM_CHECK ( update_msg != NULL , return TRUE ) ; <NEW_LINE> <START_VULN> <TAB> if ( client -> ipc == NULL ) { <NEW_LINE> <END_VULN> <TAB> <TAB> crm_warn ( "Skipping client with NULL channel" ) ; <NEW_LINE> <TAB> <TAB> return FALSE ; <NEW_LINE> <TAB> }
void test_base64_decode ( void ) <NEW_LINE> { <NEW_LINE> char buffer [ 16 ] ; <NEW_LINE> <START_VULN> int len = mutt_b64_decode ( buffer , encoded ) ; <NEW_LINE> <END_VULN> if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) <NEW_LINE> { <NEW_LINE> <TAB> TEST_MSG ( "Expected : % zu" , sizeof ( clear ) - 1 ) ;
<TAB> key_payload_reserve ( key , 0 ) ; <NEW_LINE> <START_VULN> <TAB> if ( key_is_instantiated ( key ) && <NEW_LINE> <END_VULN> <TAB> ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) <NEW_LINE> <TAB> <TAB> vfs_truncate ( path , 0 ) ; <NEW_LINE> }
1 , <NEW_LINE> - 533200896 , 1611661312 , 4 , 0 , <NEW_LINE> partial_quantlist1 , <NEW_LINE> NULL , NULL , NULL , <NEW_LINE> 0 <NEW_LINE> } ; <NEW_LINE> static float test4_result [ ] = { - 3 , - 3 , - 3 , 4 , - 3 , - 3 , - 1 , - 3 , - 3 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , 4 , - 3 , 4 , 4 , - 3 , - 1 , 4 , - 3 , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , - 1 , - 3 , 4 , - 1 , - 3 , - 1 , - 1 , - 3 , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , - 3 , 4 , 4 , - 3 , 4 , - 1 , - 3 , 4 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , 4 , 4 , 4 , 4 , 4 , - 1 , 4 , 4 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , - 1 , 4 , 4 , - 1 , 4 , - 1 , - 1 , 4 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , - 3 , - 1 , 4 , - 3 , - 1 , - 1 , - 3 , - 1 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , 4 , - 1 , 4 , 4 , - 1 , - 1 , 4 , - 1 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , - 1 , - 1 , 4 , - 1 , - 1 , - 1 , - 1 , - 1 } ;
<TAB> if ( PASS == conn -> m -> local_tx_start ( conn , this_func TSRMLS_CC ) ) { <NEW_LINE> <TAB> <TAB> ret = conn -> m -> query ( conn , "ROLLBACK" , sizeof ( "ROLLBACK" ) - 1 TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <TAB> <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> DBG_RETURN ( ret ) ;
compact_pixels = ( unsigned char * ) NULL ; <NEW_LINE> if ( next_image -> compression == RLECompression ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> compact_pixels = ( unsigned char * ) AcquireQuantumMemory ( 2 * channels * <NEW_LINE><TAB> <TAB> next_image -> columns , packet_size * sizeof ( * compact_pixels ) ) ; <NEW_LINE> <END_VULN> <TAB> if ( compact_pixels == ( unsigned char * ) NULL ) <NEW_LINE> <TAB> <TAB> ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> char name [ 256 ] ; <NEW_LINE> <TAB> <TAB> <TAB> strcpy ( name , hdr -> prefix ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> strcat ( name , hdr -> name ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> entry . filename_len = strlen ( hdr -> prefix ) + 100 ; <NEW_LINE> <TAB> <TAB> <TAB> if ( name [ entry . filename_len - 1 ] == ' / ' ) {
#else <NEW_LINE> <START_VULN> static inline zend_ulong realpath_cache_key ( const char * path , int path_len ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> register zend_ulong h ; <NEW_LINE> <TAB> const char * e = path + path_len ;
<TAB> iph -> daddr = rt -> rt_dst ; <NEW_LINE> <START_VULN> <TAB> if ( opt && opt -> optlen ) { <NEW_LINE><TAB> <TAB> iph -> ihl += opt -> optlen >> 2 ; <NEW_LINE><TAB> <TAB> ip_options_build ( skb , opt , inet -> inet_daddr , rt , 0 ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> ip_select_ident_more ( iph , & rt -> dst , sk ,
<TAB> <TAB> <TAB> <TAB> acked <TAB> : 1 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> no_srccheck : 1 ; <NEW_LINE> <TAB> kmemcheck_bitfield_end ( flags ) ; <NEW_LINE> <START_VULN> <TAB> struct ip_options <TAB> * opt ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> static inline struct inet_request_sock * inet_rsk ( const struct request_sock * sk )
<TAB> dir == - 1 -> result <= off <NEW_LINE> <TAB> dir == 0 -> result == off <NEW_LINE> <TAB> dir == 1 -> result >= off * / <NEW_LINE> <START_VULN> static RFlagsAtOffset * r_flag_get_nearest_list ( RFlag * f , ut64 off , int dir ) { <NEW_LINE> <END_VULN> <TAB> RFlagsAtOffset * flags = NULL ; <NEW_LINE> <TAB> RFlagsAtOffset key ; <NEW_LINE> <TAB> key . off = off ;
<TAB> <TAB> char radio_text [ MAX_RDS_RADIO_TEXT + 1 ] ; <NEW_LINE> <TAB> <TAB> len = control -> size - 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( len > MAX_RDS_RADIO_TEXT ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> rval = - ERANGE ; <NEW_LINE> <TAB> <TAB> <TAB> goto exit ; <NEW_LINE> <TAB> <TAB> }
if ( ! op && ! adv ) return ( 1 ) ; <NEW_LINE> { <NEW_LINE> <TAB> int size = os -> lacing_vals [ ptr ] & 0xff ; <NEW_LINE> <START_VULN> <TAB> int bytes = size ; <NEW_LINE> <END_VULN> <TAB> int eos = os -> lacing_vals [ ptr ] & 0x200 ; <NEW_LINE> <TAB> int bos = os -> lacing_vals [ ptr ] & 0x100 ; <NEW_LINE> <TAB> while ( size == 255 ) { <NEW_LINE> <TAB> int val = os -> lacing_vals [ + + ptr ] ; <NEW_LINE> <TAB> size = val & 0xff ; <NEW_LINE> <TAB> if ( val & 0x200 ) eos = 0x200 ; <NEW_LINE> <TAB> bytes += size ;
#define _NGINX_H_INCLUDED_ <NEW_LINE> <START_VULN> #define nginx_version 9001 <NEW_LINE>#define NGINX_VERSION "0 . 9 . 1" <NEW_LINE> <END_VULN> #define NGINX_VER "nginx / " NGINX_VERSION <NEW_LINE> #define NGINX_VAR "NGINX"
<TAB> if ( IsAnimValList ( ) ) { <NEW_LINE> <TAB> Element ( ) -> FlushAnimations ( ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return LengthNoFlush ( ) ; <NEW_LINE> } <NEW_LINE> void Clear ( ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < DOMSVGPathSeg > Initialize ( DOMSVGPathSeg & aNewItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & aError ) ; <NEW_LINE> <START_VULN> DOMSVGPathSeg * GetItem ( uint32_t aIndex , ErrorResult & aError ) <NEW_LINE> { <NEW_LINE><TAB> bool found ; <NEW_LINE><TAB> DOMSVGPathSeg * item = IndexedGetter ( aIndex , found , aError ) ; <NEW_LINE><TAB> if ( ! found ) { <NEW_LINE><TAB> aError . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; <NEW_LINE><TAB> } <NEW_LINE><TAB> return item ; <NEW_LINE> } <NEW_LINE>DOMSVGPathSeg * IndexedGetter ( uint32_t aIndex , bool & found , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & aError ) ; <NEW_LINE> <END_VULN> already_AddRefed < DOMSVGPathSeg > InsertItemBefore ( DOMSVGPathSeg & aNewItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t aIndex , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < DOMSVGPathSeg > ReplaceItem ( DOMSVGPathSeg & aNewItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t aIndex , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < DOMSVGPathSeg > RemoveItem ( uint32_t aIndex , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & aError ) ;
<TAB> return 0 ; <NEW_LINE> fail : <NEW_LINE> <START_VULN> <TAB> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <NEW_LINE> <END_VULN> <TAB> return ret < 0 ? ret : - EIO ; <NEW_LINE> }
<TAB> found = 0 ; <NEW_LINE> <TAB> while ( ( box = jp2_box_get ( in ) ) ) { <NEW_LINE> <TAB> <TAB> if ( jas_getdbglevel ( ) >= 1 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> jas_eprintf ( "box type % s\n" , box -> info -> name ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> switch ( box -> type ) { <NEW_LINE> <TAB> <TAB> case JP2_BOX_JP2C :
{ <NEW_LINE> <START_VULN> <TAB> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> enum {
#include "udf_sb . h" <NEW_LINE> <START_VULN> static int udf_translate_to_linux ( uint8_t * , uint8_t * , int , uint8_t * , int ) ; <NEW_LINE> <END_VULN> static int udf_char_to_ustr ( struct ustr * dest , const uint8_t * src , int strlen ) <NEW_LINE> {
<START_VULN> static int udp_push_pending_frames ( struct sock * sk ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct udp_sock * up = udp_sk ( sk ) ; <NEW_LINE> <TAB> struct inet_sock * inet = inet_sk ( sk ) ;
<TAB> if ( ( ISOFS_SB ( inode -> i_sb ) -> s_rock_offset == - 1 ) <NEW_LINE> <TAB> && ( ISOFS_SB ( inode -> i_sb ) -> s_rock == 2 ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> result = parse_rock_ridge_inode_internal ( de , inode , 14 ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return result ; <NEW_LINE> }
<TAB> <TAB> exit ( 1 ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> struct stat sb ; <NEW_LINE> <START_VULN> <TAB> char * pathname = RUNTIME_PATH " / lock / lxc / var / lib / lxc / " ; <NEW_LINE> <END_VULN> <TAB> ret = stat ( pathname , & sb ) ; <NEW_LINE> <TAB> if ( ret != 0 ) { <NEW_LINE> <TAB> <TAB> fprintf ( stderr , " % d : filename % s not created\n" , __LINE__ ,
#endif <NEW_LINE> #ifdef CONFIG_XFS_RT <NEW_LINE> <START_VULN> #define XFS_IS_REALTIME_INODE ( ip ) ( ( ip ) -> i_d . di_flags & XFS_DIFLAG_REALTIME ) <NEW_LINE> <END_VULN> #else <NEW_LINE> #define XFS_IS_REALTIME_INODE ( ip ) ( 0 ) <NEW_LINE> #endif
<TAB> case TIOCGSID : <NEW_LINE> <TAB> <TAB> return tiocgsid ( tty , real_tty , p ) ; <NEW_LINE> <TAB> case TIOCGETD : <NEW_LINE> <START_VULN> <TAB> <TAB> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <NEW_LINE> <END_VULN> <TAB> case TIOCSETD : <NEW_LINE> <TAB> <TAB> return tiocsetd ( tty , p ) ; <NEW_LINE> <TAB> case TIOCVHANGUP :
<TAB> case EXPR_INVERT : <NEW_LINE> <TAB> case EXPR_NOT : <NEW_LINE> <START_VULN> <TAB> <TAB> ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ok ) <NEW_LINE> <TAB> <TAB> <TAB> * set_rtrn = ! * set_rtrn ; <NEW_LINE> <TAB> <TAB> return ok ;
<TAB> char line [ MAX_URL_SIZE ] ; <NEW_LINE> <TAB> int err = 0 ; <NEW_LINE> <START_VULN> <TAB> s -> chunksize = - 1 ; <NEW_LINE> <END_VULN> <TAB> for ( ; ; ) { <NEW_LINE> <TAB> <TAB> if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 )
remote_path_check : <NEW_LINE> <START_VULN> <TAB> if ( ! rc && cifs_sb -> prepathlen && tcon ) { <NEW_LINE> <END_VULN> <TAB> <TAB> full_path = cifs_build_path_to_root ( cifs_sb , tcon ) ; <NEW_LINE> <TAB> <TAB> if ( full_path == NULL ) {
} <NEW_LINE> SECStatus <NEW_LINE> ssl3_HandleNewSessionTicket ( sslSocket * ss , SSL3Opaque * b , PRUint32 length ) <NEW_LINE> { <NEW_LINE> <TAB> SECStatus rv ; <NEW_LINE> <TAB> SECItem ticketData ; <NEW_LINE> <START_VULN> <TAB> SSL_TRC ( 3 , ( " % d : SSL3 [ % d ] : handle session_ticket handshake" , <NEW_LINE><TAB> <TAB> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> <END_VULN> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ! ss -> ssl3 . hs . newSessionTicket . ticket . data ) ; <NEW_LINE> <TAB> PORT_Assert ( ! ss -> ssl3 . hs . receivedNewSessionTicket ) ; <NEW_LINE> <TAB> if ( ss -> ssl3 . hs . ws != wait_new_session_ticket ) {
<TAB> TEST_MSG ( "Expected : % zu" , exp ) ; <NEW_LINE> <TAB> TEST_MSG ( "Actual : % zu" , enclen ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> declen = mutt_b64_decode ( out2 , out1 ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! TEST_CHECK ( declen == i ) ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> TEST_MSG ( "Expected : % zu" , i ) ;
} <NEW_LINE> if ( b < 0 . ) return - sqrt ( a * a + b * b ) ; <NEW_LINE> if ( - a > b ) return - sqrt ( a * a + b * b ) ; <NEW_LINE> return sqrt ( b * b + a * a ) ; <NEW_LINE> } <NEW_LINE> float ** _vp_quantize_couple_memo ( vorbis_block * vb , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> vorbis_info_psy_global * g , <NEW_LINE><TAB> <TAB> <TAB> <TAB> vorbis_look_psy * p , <NEW_LINE><TAB> <TAB> <TAB> <TAB> vorbis_info_mapping0 * vi , <NEW_LINE><TAB> <TAB> <TAB> <TAB> float ** mdct ) { <NEW_LINE> <END_VULN> int i , j , n = p -> n ; <NEW_LINE> float ** ret = _vorbis_block_alloc ( vb , vi -> coupling_steps * sizeof ( * ret ) ) ; <NEW_LINE> int limit = g -> coupling_pointlimit [ p -> vi -> blockflag ] [ PACKETBLOBS / 2 ] ; <NEW_LINE> for ( i = 0 ; i < vi -> coupling_steps ; i + + ) { <NEW_LINE> <TAB> float * mdctM = mdct [ vi -> coupling_mag [ i ] ] ; <NEW_LINE> <TAB> float * mdctA = mdct [ vi -> coupling_ang [ i ] ] ;
<TAB> * <NEW_LINE> <TAB> * <NEW_LINE> <TAB> * <NEW_LINE> <START_VULN> void Write ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> void Finish ( RasterImage : : eShutdownIntent aShutdownIntent ) ;
<TAB> . fsync <TAB> <TAB> = exofs_file_fsync , <NEW_LINE> <TAB> . flush <TAB> <TAB> = exofs_flush , <NEW_LINE> <TAB> . splice_read <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> } ; <NEW_LINE> const struct inode_operations exofs_file_inode_operations = {
<TAB> <TAB> <TAB> <TAB> parent_inode , & key , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> BTRFS_FT_DIR , index ) ; <NEW_LINE> <START_VULN> <TAB> BUG_ON ( ret == - EEXIST ) ; <NEW_LINE> <END_VULN> <TAB> if ( ret ) { <NEW_LINE> <TAB> <TAB> btrfs_abort_transaction ( trans , root , ret ) ; <NEW_LINE> <TAB> <TAB> goto fail ; <NEW_LINE> commit 9c52057c698fb96f8f07e7a4bcf4801a092bda89 <NEW_LINE> Author : Chris Mason < chris . mason@fusionio . com > <NEW_LINE> Date : Mon Dec 17 14 : 26 : 57 2012 - 0500 <NEW_LINE> <TAB> Btrfs : fix hash overflow handling <NEW_LINE> <TAB> The handling for directory crc hash overflows was fairly obscure , <NEW_LINE> <TAB> split_leaf returns EOVERFLOW when we try to extend the item and that is <NEW_LINE> <TAB> supposed to bubble up to userland . For a while it did so , but along the <NEW_LINE> <TAB> way we added better handling of errors and forced the FS readonly if we <NEW_LINE> <TAB> hit IO errors during the directory insertion . <NEW_LINE> <TAB> Along the way , we started testing only for EEXIST and the EOVERFLOW case <NEW_LINE> <TAB> was dropped . The end result is that we may force the FS readonly if we <NEW_LINE> <TAB> catch a directory hash bucket overflow . <NEW_LINE> <TAB> This fixes a few problem spots . First I add tests for EOVERFLOW in the <NEW_LINE> <TAB> places where we can safely just return the error up the chain . <NEW_LINE> <TAB> btrfs_rename is harder though , because it tries to insert the new <NEW_LINE> <TAB> directory item only after it has already unlinked anything the rename <NEW_LINE> <TAB> was going to overwrite . Rather than adding very complex logic , I added <NEW_LINE> <TAB> a helper to test for the hash overflow case early while it is still safe <NEW_LINE> <TAB> to bail out . <NEW_LINE> <TAB> Snapshot and subvolume creation had a similar problem , so they are using <NEW_LINE> <TAB> the new helper now too . <NEW_LINE> <TAB> Signed - off - by : Chris Mason < chris . mason@fusionio . com > <NEW_LINE> <TAB> Reported - by : Pascal Junod < pascal@junod . info >
<TAB> <TAB> goto out ; <NEW_LINE> <TAB> raw = bpf_any_get ( inode -> i_private , * type ) ; <NEW_LINE> <START_VULN> <TAB> touch_atime ( & path ) ; <NEW_LINE> <END_VULN> <TAB> path_put ( & path ) ; <NEW_LINE> <TAB> return raw ;
<TAB> phar_flush ( phar_obj -> arc . archive , NULL , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> <TAB> if ( GC_IS_RECURSIVE ( ht ) ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> ( ( SBucketType * ) ( buffer -> buffer + p ) ) -> data_type = IS_NULL ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> php_error_docref ( NULL TSRMLS_CC , E_NOTICE , "the array has cycle ref" ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> else
<TAB> <TAB> <TAB> <TAB> SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> GetPixelIndex ( image , q ) , q ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> q += GetPixelChannels ( image ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> x + + ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
<TAB> <TAB> <TAB> if ( rc == pcmk_ok ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> rc = cib -> cmds -> set_connection_dnotify ( cib , mon_cib_connection_destroy ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( rc == - EPROTONOSUPPORT ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> print_as ( "Notification setup failed , won't be able to reconnect after failure" ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> if ( as_console ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> sleep ( 2 ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> }
<TAB> err = sock_do_ioctl ( net , sock , cmd , ( unsigned long ) & ktv ) ; <NEW_LINE> <TAB> set_fs ( old_fs ) ; <NEW_LINE> <TAB> if ( ! err ) <NEW_LINE> <START_VULN> <TAB> <TAB> err = compat_put_timeval ( up , & ktv ) ; <NEW_LINE> <END_VULN> <TAB> return err ; <NEW_LINE> }
<TAB> } <NEW_LINE> } ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha512" ) ; <NEW_LINE> <END_VULN> static int sha384_init ( struct shash_desc * desc ) <NEW_LINE> {
<TAB> TraceMonitor * tm = & JS_THREAD_DATA ( cx ) -> traceMonitor ; <NEW_LINE> <TAB> JS_ASSERT ( tm -> codeAlloc && tm -> dataAlloc && tm -> traceAlloc ) ; <NEW_LINE> <TAB> if ( bytes > 1 G ) <NEW_LINE> <TAB> <TAB> bytes = 1 G ; <NEW_LINE> <TAB> if ( bytes < 128 K ) <NEW_LINE> <TAB> <TAB> bytes = 128 K ; <NEW_LINE> <TAB> tm -> maxCodeCacheBytes = bytes ; <NEW_LINE> } <NEW_LINE> <START_VULN> void <NEW_LINE> <END_VULN> InitJIT ( TraceMonitor * tm ) <NEW_LINE> { <NEW_LINE> #if defined JS_JIT_SPEW <NEW_LINE> <TAB> tm -> profAlloc = NULL ; <NEW_LINE> <TAB> if ( ! did_we_set_up_debug_logging ) { <NEW_LINE> <TAB> <TAB> InitJITLogController ( ) ; <NEW_LINE> <TAB> <TAB> did_we_set_up_debug_logging = true ; <NEW_LINE> <TAB> }
<TAB> size = 1 ; <NEW_LINE> <TAB> for ( i = 0 ; i < cpp ; i + + ) <NEW_LINE> <START_VULN> <TAB> <TAB> size *= 94 ; <NEW_LINE> <END_VULN> <TAB> if ( ncolors <= 0 || ncolors > size ) { <NEW_LINE> <TAB> <TAB> av_log ( avctx , AV_LOG_ERROR , "invalid number of colors : % d\n" , ncolors ) ;
nsXBLProtoImplMethod ( const PRUnichar * aName ) ; <NEW_LINE> virtual ~ nsXBLProtoImplMethod ( ) ; <NEW_LINE> void AppendBodyText ( const nsAString & aBody ) ; <NEW_LINE> void AddParameter ( const nsAString & aName ) ; <NEW_LINE> void SetLineNumber ( uint32_t aLineNumber ) ; <NEW_LINE> <START_VULN> virtual nsresult InstallMember ( nsIScriptContext * aContext , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIContent * aBoundElement , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aScriptObject , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aTargetClassObject , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsCString & aClassStr ) ; <NEW_LINE> <END_VULN> virtual nsresult CompileMember ( nsIScriptContext * aContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsCString & aClassStr , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aClassObject ) ; <NEW_LINE> virtual void Trace ( TraceCallback aCallback , void * aClosure ) const ; <NEW_LINE> nsresult Read ( nsIScriptContext * aContext , nsIObjectInputStream * aStream ) ; <NEW_LINE> virtual nsresult Write ( nsIScriptContext * aContext , nsIObjectOutputStream * aStream ) ;
{ <NEW_LINE> int len = strlen ( buffer ) ; <NEW_LINE> <START_VULN> if ( ( len + * stringlen ) > * stralloc ) { <NEW_LINE> <END_VULN> <TAB> char * newptr = realloc ( string , * stralloc * 2 ) ; <NEW_LINE> <TAB> if ( newptr ) { <NEW_LINE> <TAB> string = newptr ;
<TAB> return ret ; <NEW_LINE> } <NEW_LINE> <START_VULN> static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct fsnotify_group * group ;
{ <NEW_LINE> <TAB> int64_t l ; <NEW_LINE> <TAB> int digit ; <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> l = 0 ; <NEW_LINE> <TAB> while ( char_cnt -- > 0 ) { <NEW_LINE> <TAB> <TAB> if ( * p >= '0' && * p <= '7' )
#define MAX_SHARE_SIZE 64 <TAB> <NEW_LINE> #define MAX_USERNAME_SIZE 32 <TAB> <NEW_LINE> <START_VULN> #define MAX_PASSWORD_SIZE 16 <NEW_LINE> <END_VULN> #define CIFS_MIN_RCV_POOL 4
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : channel mapping 0 implementation <NEW_LINE> <START_VULN> last mod : $ Id : mapping0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h >
<TAB> unsigned int payload ; <NEW_LINE> <TAB> unsigned int padding = 16 ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> hbtype = * p + + ; <NEW_LINE><TAB> n2s ( p , payload ) ; <NEW_LINE><TAB> pl = p ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> if ( s -> msg_callback ) <NEW_LINE> <TAB> <TAB> s -> msg_callback ( 0 , s -> version , TLS1_RT_HEARTBEAT , <NEW_LINE> <TAB> <TAB> <TAB> & s -> s3 -> rrec . data [ 0 ] , s -> s3 -> rrec . length , <NEW_LINE> <TAB> <TAB> <TAB> s , s -> msg_callback_arg ) ; <NEW_LINE> <TAB> if ( hbtype == TLS1_HB_REQUEST ) <NEW_LINE> <TAB> <TAB> {
#include "vm / RegExpObject . h" <NEW_LINE> #include "jsscopeinlines . h" <NEW_LINE> namespace js { <NEW_LINE> inline <NEW_LINE> Bindings : : Bindings ( JSContext * cx ) <NEW_LINE> <START_VULN> <TAB> : lastBinding ( NULL ) , nargs ( 0 ) , nvars ( 0 ) , nupvars ( 0 ) <NEW_LINE> <END_VULN> { } <NEW_LINE> inline void <NEW_LINE> Bindings : : transfer ( JSContext * cx , Bindings * bindings ) <NEW_LINE> { <NEW_LINE> <TAB> JS_ASSERT ( ! lastBinding ) ; <NEW_LINE> <TAB> JS_ASSERT ( ! bindings -> lastBinding || ! bindings -> lastBinding -> inDictionary ( ) ) ;
<TAB> rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ; <NEW_LINE> <START_VULN> done : <NEW_LINE> <END_VULN> <TAB> if ( ctxt -> rip_relative ) <NEW_LINE> <TAB> <TAB> ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; <NEW_LINE> <TAB> return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ; <NEW_LINE> }
<START_VULN> <TAB> struct dump_dir * dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! dd ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> error_msg_and_die ( "Error creating problem directory ' % s'" , path ) ;
static int <NEW_LINE> test_make_inputs ( xd3_stream * stream , xoff_t * ss_out , xoff_t * ts_out ) <NEW_LINE> { <NEW_LINE> <START_VULN> usize_t ts = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ; <NEW_LINE>usize_t ss = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ; <NEW_LINE> <END_VULN> uint8_t * buf = ( uint8_t * ) malloc ( ts + ss ) , * sbuf = buf , * tbuf = buf + ss ; <NEW_LINE> usize_t sadd = 0 , sadd_max = ( usize_t ) ( ss * TEST_ADD_RATIO ) ; <NEW_LINE> FILE * tf = NULL , * sf = NULL ;
<TAB> { <NEW_LINE> <TAB> c = XBMInteger ( image , hex_digits ) ; <NEW_LINE> <TAB> if ( c < 0 ) <NEW_LINE> <START_VULN> <TAB> <TAB> break ; <NEW_LINE> <END_VULN> <TAB> * p + += ( unsigned char ) c ; <NEW_LINE> <TAB> if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) <NEW_LINE> <TAB> <TAB> * p + += ( unsigned char ) ( c >> 8 ) ;
DBUG_PRINT ( "my" , ( "org_name : ' % s' tmp_name : ' % s' MyFlags : % d" , <NEW_LINE> <TAB> <TAB> org_name , tmp_name , MyFlags ) ) ; <NEW_LINE> <START_VULN> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <NEW_LINE><TAB> goto end ; <NEW_LINE> <END_VULN> if ( MyFlags & MY_REDEL_MAKE_BACKUP ) <NEW_LINE> { <NEW_LINE> <TAB> char name_buff [ FN_REFLEN + 20 ] ;
<TAB> <TAB> phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> else { <NEW_LINE> <TAB> <TAB> <TAB> sg_req_info_t * rinfo ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> GFP_KERNEL ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( ! rinfo ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return - ENOMEM ; <NEW_LINE> <TAB> <TAB> <TAB> read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ;
<TAB> <TAB> <TAB> <TAB> const char * buf , size_t count ) <NEW_LINE> { <NEW_LINE> <TAB> struct platform_device * pdev = to_platform_device ( dev ) ; <NEW_LINE> <START_VULN> <TAB> char * driver_override , * old = pdev -> driver_override , * cp ; <NEW_LINE> <END_VULN> <TAB> if ( count > PATH_MAX ) <NEW_LINE> <TAB> <TAB> return - EINVAL ;
typedef void vorbis_info_residue ; <NEW_LINE> typedef void vorbis_info_mapping ; <NEW_LINE> #include "psy . h" <NEW_LINE> #include "bitrate . h" <NEW_LINE> typedef struct private_state { <NEW_LINE> <START_VULN> envelope_lookup * ve ; <NEW_LINE> <END_VULN> int window [ 2 ] ; <NEW_LINE> vorbis_look_transform ** transform [ 2 ] ; <NEW_LINE> drft_lookup fft_look [ 2 ] ; <NEW_LINE> int modebits ; <NEW_LINE> vorbis_look_floor ** flr ; <NEW_LINE> vorbis_look_residue ** residue ; <NEW_LINE> vorbis_look_psy * psy ;
<TAB> mail_fetchstructure ( vms -> mailstream , vms -> msgArray [ vms -> curmsg ] , & body ) ; <NEW_LINE> <START_VULN> <TAB> if ( body -> nested . part -> next && body -> nested . part -> next -> body . parameter -> value ) { <NEW_LINE> <END_VULN> <TAB> <TAB> attachedfilefmt = ast_strdupa ( body -> nested . part -> next -> body . parameter -> value ) ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> ast_log ( LOG_ERROR , "There is no file attached to this IMAP message . \n" ) ;
struct inode ; <TAB> <TAB> <NEW_LINE> <START_VULN> extern int parse_rock_ridge_inode ( struct iso_directory_record * , struct inode * ) ; <NEW_LINE> <END_VULN> extern int get_rock_ridge_filename ( struct iso_directory_record * , char * , struct inode * ) ; <NEW_LINE> extern int isofs_name_translate ( struct iso_directory_record * , char * , struct inode * ) ;
<TAB> <TAB> struct iphdr _iph ; <NEW_LINE> ip : <NEW_LINE> <TAB> <TAB> iph = skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , & _iph ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! iph ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <TAB> <TAB> if ( ip_is_fragment ( iph ) )
<TAB> <TAB> kvm_machine_check ( ) ; <NEW_LINE> <START_VULN> <TAB> if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR && <NEW_LINE><TAB> ( exit_intr_info & INTR_INFO_VALID_MASK ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> kvm_before_handle_nmi ( & vmx -> vcpu ) ; <NEW_LINE> <TAB> <TAB> asm ( "int $ 2" ) ; <NEW_LINE> <TAB> <TAB> kvm_after_handle_nmi ( & vmx -> vcpu ) ;
<TAB> XPCCompartmentSet & GetCompartmentSet ( ) <NEW_LINE> <TAB> <TAB> { return mCompartmentSet ; } <NEW_LINE> <TAB> XPCLock * GetMapLock ( ) const { return mMapLock ; } <NEW_LINE> <TAB> JSBool OnJSContextNew ( JSContext * cx ) ; <NEW_LINE> <START_VULN> <TAB> JSBool DeferredRelease ( nsISupports * obj ) ; <NEW_LINE> <END_VULN> <TAB> JSBool GetDoingFinalization ( ) const { return mDoingFinalization ; } <NEW_LINE> <TAB> enum {
<TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> offset = param_end_offset ; <NEW_LINE> <TAB> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> tokenlen = param_end_offset - next_offset + 1 ; <NEW_LINE><TAB> <TAB> <TAB> proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , <NEW_LINE><TAB> <TAB> <TAB> <TAB> " % s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ) ; <NEW_LINE><TAB> <TAB> <TAB> offset = param_end_offset ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> }
void SetDirectionFromNewTextNode ( nsIContent * aTextNode ) ; <NEW_LINE> <START_VULN> void ResetDirectionSetByTextNode ( nsTextNode * aTextNode ) ; <NEW_LINE> <END_VULN> void SetDirectionalityFromValue ( mozilla : : dom : : Element * aElement , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsAString & aValue , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool aNotify ) ;
<TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> q [ i ] = ClampToQuantum ( pixel ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> p += GetPixelChannels ( composite_image ) ; <NEW_LINE> <TAB> channels = GetPixelChannels ( composite_image ) ;
static long mem_seek ( jas_stream_obj_t * obj , long offset , int origin ) <NEW_LINE> { <NEW_LINE> <TAB> jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; <NEW_LINE> <START_VULN> <TAB> long newpos ; <NEW_LINE> <END_VULN> <TAB> JAS_DBGLOG ( 100 , ( "mem_seek ( % p , % ld , % d ) \n" , obj , offset , origin ) ) ; <NEW_LINE> <TAB> switch ( origin ) {
<TAB> <TAB> l_data_size = ( OPJ_UINT32 ) ( l_tilec -> x1 - l_tilec -> x0 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ( ( ( OPJ_UINT32 ) - 1 ) / l_data_size ) < ( OPJ_UINT32 ) ( l_tilec -> y1 - l_tilec -> y0 ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> opj_event_msg ( manager , EVT_ERROR , "Not enough memory for tile data\n" ) ; <NEW_LINE> <TAB> <TAB> <TAB> return OPJ_FALSE ; <NEW_LINE> <TAB> <TAB> }
{ <NEW_LINE> <TAB> char obj_txt [ 128 ] ; <NEW_LINE> <START_VULN> <TAB> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <NEW_LINE><TAB> BIO_write ( bio , obj_txt , len ) ; <NEW_LINE><TAB> BIO_write ( bio , "\n" , 1 ) ; <NEW_LINE> <END_VULN> <TAB> return 1 ; <NEW_LINE> }
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ULONG virtioFlags , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> tCompletePhysicalAddress * pPacketPages , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ULONG ulPacketLength , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ULONG ulDataOffset ) ; <NEW_LINE> <END_VULN> void ParaNdis_CallOnBugCheck ( PARANDIS_ADAPTER * pContext ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> gss_buffer_t interprocess_token ) <NEW_LINE> { <NEW_LINE> <TAB> OM_uint32 maj ; <NEW_LINE> <START_VULN> <TAB> iakerb_ctx_id_t ctx = ( iakerb_ctx_id_t ) context_handle ; <NEW_LINE> <END_VULN> <TAB> if ( ! ctx -> established )
<TAB> static char efbuf [ 100 ] ; <NEW_LINE> <TAB> my_regex_t re ; <NEW_LINE> <START_VULN> <TAB> sprintf ( efbuf , "REG_ % s" , name ) ; <NEW_LINE> <END_VULN> <TAB> assert ( strlen ( efbuf ) < sizeof ( efbuf ) ) ; <NEW_LINE> <TAB> re . re_endp = efbuf ; <NEW_LINE> <TAB> ( void ) my_regerror ( REG_ATOI , & re , efbuf , sizeof ( efbuf ) ) ;
<TAB> <TAB> pr_debug ( "src = % pI6 - " , & fl6 -> saddr ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! asoc || saddr ) <NEW_LINE> <TAB> <TAB> goto out ;
<TAB> if ( ret != GNUTLS_E_SUCCESS ) <NEW_LINE> <TAB> <TAB> inf_gnutls_set_error ( & error , ret ) ; <NEW_LINE> <START_VULN> <TAB> else if ( verify & GNUTLS_CERT_INVALID ) <NEW_LINE><TAB> <TAB> inf_gnutls_certificate_verification_set_error ( & error , verify ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> }
<TAB> case S_IFREG : <NEW_LINE> <TAB> case S_IFLNK : <NEW_LINE> <TAB> case S_IFDIR : <NEW_LINE> <START_VULN> <TAB> <TAB> switch ( dip -> di_format ) { <NEW_LINE><TAB> <TAB> case XFS_DINODE_FMT_LOCAL : <NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> if ( S_ISREG ( mode ) ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> return __this_address ; <NEW_LINE><TAB> <TAB> <TAB> if ( di_size > XFS_DFORK_DSIZE ( dip , mp ) ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> return __this_address ; <NEW_LINE><TAB> <TAB> <TAB> if ( dip -> di_nextents ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> return __this_address ; <NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> case XFS_DINODE_FMT_EXTENTS : <NEW_LINE><TAB> <TAB> case XFS_DINODE_FMT_BTREE : <NEW_LINE><TAB> <TAB> <TAB> break ; <NEW_LINE><TAB> <TAB> default : <NEW_LINE><TAB> <TAB> <TAB> return __this_address ; <NEW_LINE><TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> case 0 :
<TAB> <TAB> <TAB> <TAB> <TAB> + + ptr ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> if ( strcmp ( ptr , "get " ) && strcmp ( ptr , "gets " ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> conn_set_state ( c , conn_closing ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> return 1 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
<TAB> <TAB> if ( ! tx_ring ) <NEW_LINE> <TAB> <TAB> <TAB> prb_shutdown_retire_blk_timer ( po , rb_queue ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> release_sock ( sk ) ; <NEW_LINE> <END_VULN> <TAB> if ( pg_vec ) <NEW_LINE> <TAB> <TAB> free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; <NEW_LINE> out : <NEW_LINE> <TAB> return err ; <NEW_LINE> }
<TAB> ut64 <TAB> data ; <NEW_LINE> <TAB> st64 <TAB> sdata ; <NEW_LINE> <TAB> ut64 <TAB> reference ; <NEW_LINE> <START_VULN> <TAB> struct str_structt { <NEW_LINE> <END_VULN> <TAB> <TAB> char <TAB> * string ; <NEW_LINE> <TAB> <TAB> ut64 <TAB> offset ; <NEW_LINE> <TAB> } str_struct ;
<TAB> && iso9660 -> seenJoliet ) { <NEW_LINE> <TAB> <TAB> vd = & ( iso9660 -> joliet ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <NEW_LINE> <END_VULN> <TAB> <TAB> skipsize -= iso9660 -> current_position ; <NEW_LINE> <TAB> <TAB> skipsize = __archive_read_consume ( a , skipsize ) ; <NEW_LINE> <TAB> <TAB> if ( skipsize < 0 )
<TAB> size_t len ; <NEW_LINE> <TAB> if ( level >= ms -> c . len ) { <NEW_LINE> <START_VULN> <TAB> <TAB> len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? <NEW_LINE> <TAB> <TAB> malloc ( len ) : <NEW_LINE> <TAB> <TAB> realloc ( ms -> c . li , len ) ) ;
<TAB> . write_iter <TAB> <TAB> = generic_file_write_iter , <NEW_LINE> <TAB> . fsync <TAB> <TAB> <TAB> = noop_fsync , <NEW_LINE> <TAB> . splice_read <TAB> <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> <TAB> . llseek <TAB> <TAB> <TAB> = generic_file_llseek , <NEW_LINE> } ;
<TAB> <TAB> p -> daddr = * daddr ; <NEW_LINE> <TAB> <TAB> atomic_set ( & p -> refcnt , 1 ) ; <NEW_LINE> <TAB> <TAB> atomic_set ( & p -> rid , 0 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> atomic_set ( & p -> ip_id_count , secure_ip_id ( daddr -> addr . a4 ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> p -> tcp_ts_stamp = 0 ; <NEW_LINE> <TAB> <TAB> p -> metrics [ RTAX_LOCK - 1 ] = INETPEER_METRICS_NEW ; <NEW_LINE> <TAB> <TAB> p -> rate_tokens = 0 ;
<TAB> <TAB> return error ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN> <TAB> destreg = ( opcode >> 4 ) & 0x3f ; <NEW_LINE> <TAB> if ( user_mode ( regs ) ) {
<TAB> incode = code ; <NEW_LINE> <START_VULN> <TAB> if ( code >= max_code ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> * sp + + = firstcode ; <NEW_LINE> <TAB> code = oldcode ;
<START_VULN> <TAB> if ( ns_capable ( ns -> parent , cap_setid ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return true ; <NEW_LINE> <TAB> return false ;
<TAB> <TAB> <TAB> sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; <NEW_LINE> <TAB> <TAB> <TAB> + + ny ; + + nr ; + + ng ; + + nb ; + + cb ; + + cr ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> if ( j < maxw ) <NEW_LINE> <END_VULN> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; <NEW_LINE> <TAB> <TAB> <TAB> + + y ; + + r ; + + g ; + + b ;
{ <NEW_LINE> <TAB> int <TAB> <TAB> i ; <NEW_LINE> <TAB> u_entry_T <TAB> * uep ; <NEW_LINE> <START_VULN> <TAB> char_u <TAB> ** array ; <NEW_LINE> <END_VULN> <TAB> char_u <TAB> * line ; <NEW_LINE> <TAB> int <TAB> <TAB> line_len ;
<TAB> kdb -> fail_auth_count = 0 ; <NEW_LINE> <TAB> if ( keyblocks ) { <NEW_LINE> <START_VULN> <TAB> <TAB> ret = decrypt_key_data ( handle -> context , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> kdb -> n_key_data , kdb -> key_data , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> keyblocks , n_keys ) ; <NEW_LINE> <TAB> <TAB> if ( ret ) <NEW_LINE> <TAB> <TAB> <TAB> goto done ;
op -> e_o_s = 0 ; <NEW_LINE> op -> granulepos = 0 ; <NEW_LINE> op -> packetno = 1 ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> int vorbis_analysis_headerout ( vorbis_dsp_state * v , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> vorbis_comment * vc , <NEW_LINE><TAB> <TAB> <TAB> ogg_packet * op , <NEW_LINE><TAB> <TAB> <TAB> ogg_packet * op_comm , <NEW_LINE><TAB> <TAB> <TAB> ogg_packet * op_code ) { <NEW_LINE> <END_VULN> int ret = OV_EIMPL ; <NEW_LINE> vorbis_info * vi = v -> vi ; <NEW_LINE> oggpack_buffer opb ; <NEW_LINE> private_state * b = v -> backend_state ; <NEW_LINE> if ( ! b ) { <NEW_LINE> <TAB> ret = OV_EFAULT ; <NEW_LINE> <TAB> goto err_out ;
<TAB> <TAB> <TAB> int32_t i32 ; <NEW_LINE> <TAB> <TAB> <TAB> uint32_t u32 ; <NEW_LINE> <TAB> <TAB> <TAB> JSWhyMagic why ; <NEW_LINE> <TAB> <TAB> } payload ; <NEW_LINE> <TAB> } s ; <NEW_LINE> <TAB> double asDouble ; <NEW_LINE> <TAB> void * asPtr ; <NEW_LINE> <TAB> size_t asWord ; <NEW_LINE> <START_VULN> } jsval_layout ; <NEW_LINE> <END_VULN> # endif <NEW_LINE> #endif <NEW_LINE> JS_STATIC_ASSERT ( sizeof ( jsval_layout ) == 8 ) ; <NEW_LINE> #if JS_BITS_PER_WORD == 32
int vorbis_synthesis_headerin ( vorbis_info * vi , vorbis_comment * vc , ogg_packet * op ) { <NEW_LINE> oggpack_buffer opb ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( op ) { <NEW_LINE> <TAB> oggpack_readinit ( & opb , op -> packet , op -> bytes ) ; <NEW_LINE> <TAB> { <NEW_LINE> <TAB> char buffer [ 6 ] ; <NEW_LINE> <TAB> int packtype = oggpack_read ( & opb , 8 ) ;
<TAB> rcu_read_lock ( ) ; <NEW_LINE> <TAB> dev = dev_get_by_index_rcu ( sock_net ( sk ) , pkt_sk ( sk ) -> ifindex ) ; <NEW_LINE> <TAB> if ( dev ) <NEW_LINE> <START_VULN> <TAB> <TAB> strlcpy ( uaddr -> sa_data , dev -> name , 15 ) ; <NEW_LINE> <END_VULN> <TAB> else <NEW_LINE> <TAB> <TAB> memset ( uaddr -> sa_data , 0 , 14 ) ; <NEW_LINE> <TAB> rcu_read_unlock ( ) ;
<TAB> if ( io -> flag != EXT4_IO_UNWRITTEN ) <NEW_LINE> <TAB> <TAB> return ret ; <NEW_LINE> <START_VULN> <TAB> if ( offset + size <= i_size_read ( inode ) ) <NEW_LINE><TAB> <TAB> ret = ext4_convert_unwritten_extents ( inode , offset , size ) ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> if ( ret < 0 ) { <NEW_LINE> <TAB> <TAB> printk ( KERN_EMERG " % s : failed to convert unwritten" <NEW_LINE> <TAB> <TAB> <TAB> "extents to written extents , error is % d"
<TAB> <TAB> } <NEW_LINE> <TAB> } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { <NEW_LINE> <TAB> <TAB> if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return AVERROR_INVALIDDATA ; <NEW_LINE> <TAB> <TAB> for ( i = 0 ; i < length / 2 ; i + + ) {
bool is_checkpointed_data ( struct f2fs_sb_info * sbi , block_t blkaddr ) ; <NEW_LINE> void refresh_sit_entry ( struct f2fs_sb_info * sbi , block_t old , block_t new ) ; <NEW_LINE> void stop_discard_thread ( struct f2fs_sb_info * sbi ) ; <NEW_LINE> <START_VULN> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) ; <NEW_LINE> <END_VULN> void clear_prefree_segments ( struct f2fs_sb_info * sbi , struct cp_control * cpc ) ; <NEW_LINE> void release_discard_addrs ( struct f2fs_sb_info * sbi ) ; <NEW_LINE> int npages_for_summary_flush ( struct f2fs_sb_info * sbi , bool for_ra ) ;
class TlsHandshakeFilter : public TlsRecordFilter { <NEW_LINE> public : <NEW_LINE> TlsHandshakeFilter ( ) { } <NEW_LINE> protected : <NEW_LINE> virtual bool FilterRecord ( uint8_t content_type , uint16_t version , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const DataBuffer & input , DataBuffer * output ) ; <NEW_LINE> virtual bool FilterHandshake ( uint16_t version , uint8_t handshake_type , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const DataBuffer & input , DataBuffer * output ) = 0 ; <NEW_LINE> private : <NEW_LINE> <START_VULN> bool CheckDtls ( TlsParser & parser , size_t length ) ; <NEW_LINE> <END_VULN> size_t ApplyFilter ( uint16_t version , uint8_t handshake_type , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> const DataBuffer & record , DataBuffer * output , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> size_t length_offset , size_t value_offset , bool * changed ) ; <NEW_LINE> } ; <NEW_LINE> class TlsInspectorRecordHandshakeMessage : public TlsHandshakeFilter { <NEW_LINE> public :
<TAB> struct list_head <TAB> list ; <TAB> <TAB> <NEW_LINE> <TAB> struct inode <TAB> <TAB> * inode ; <TAB> <TAB> <NEW_LINE> <TAB> unsigned int <TAB> <TAB> flag ; <TAB> <TAB> <NEW_LINE> <START_VULN> <TAB> int <TAB> <TAB> <TAB> error ; <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> loff_t <TAB> <TAB> <TAB> offset ; <TAB> <TAB> <NEW_LINE> <TAB> ssize_t <TAB> <TAB> <TAB> size ; <TAB> <TAB> <NEW_LINE> <TAB> struct work_struct <TAB> work ; <TAB> <TAB>
<TAB> d = M_fs_path_mac_tmpdir ( ) ; <NEW_LINE> #else <NEW_LINE> <TAB> const char * const_temp ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> # ifdef HAVE_SECURE_GETENV <NEW_LINE> <TAB> const_temp = secure_getenv ( "TMPDIR" ) ; <NEW_LINE> # else
<TAB> int b = buf [ 0 ] & 0x7 ; <NEW_LINE> <TAB> int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ; <NEW_LINE> <START_VULN> <TAB> RAnalOp next_op ; <NEW_LINE> <END_VULN>
<TAB> <TAB> for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; <NEW_LINE> <TAB> <TAB> bit < bm -> depth ; <NEW_LINE> <TAB> <TAB> bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( rq -> q == hctx -> queue ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> fn ( hctx , rq , data , reserved ) ; <NEW_LINE> <TAB> <TAB> }
<TAB> struct list_head s_es_list ; <TAB> <NEW_LINE> <TAB> long s_es_nr_inode ; <NEW_LINE> <TAB> struct ext4_es_stats s_es_stats ; <NEW_LINE> <START_VULN> <TAB> struct mb_cache * s_mb_cache ; <NEW_LINE> <END_VULN> <TAB> spinlock_t s_es_lock ____cacheline_aligned_in_smp ;
<TAB> gint crc_length = 0 ; <NEW_LINE> <START_VULN> <TAB> src_addr = ep_alloc ( ADDR_MAX_LEN ) ; <NEW_LINE><TAB> dst_addr = ep_alloc ( ADDR_MAX_LEN ) ; <NEW_LINE> <END_VULN> <TAB> pinfo -> srcport = pinfo -> destport = 0xffffffff ;
<TAB> vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; <NEW_LINE> <TAB> vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; <NEW_LINE> <TAB> vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; <NEW_LINE> <START_VULN> <TAB> vmcs_write16 ( HOST_FS_SELECTOR , kvm_read_fs ( ) ) ; <NEW_LINE><TAB> vmcs_write16 ( HOST_GS_SELECTOR , kvm_read_gs ( ) ) ; <NEW_LINE> <END_VULN> <TAB> vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; <NEW_LINE> #ifdef CONFIG_X86_64 <NEW_LINE> <TAB> rdmsrl ( MSR_FS_BASE , a ) ;
<TAB> int post , err ; <NEW_LINE> <TAB> char headers [ HTTP_HEADERS_SIZE ] = "" ; <NEW_LINE> <TAB> char * authstr = NULL , * proxyauthstr = NULL ; <NEW_LINE> <START_VULN> <TAB> int64_t off = s -> off ; <NEW_LINE> <END_VULN> <TAB> int len = 0 ; <NEW_LINE> <TAB> const char * method ; <NEW_LINE> <TAB> int send_expect_100 = 0 ;
<TAB> <TAB> psf_binheader_readf ( psf , "j" , dword - bytesread ) ; <NEW_LINE> <TAB> if ( map_info -> channel_map != NULL ) <NEW_LINE> <START_VULN> <TAB> { <TAB> size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> free ( psf -> channel_map ) ;
#define MAJOR_VERSION 0 <NEW_LINE> #define MINOR_VERSION 0 <NEW_LINE> #define BUILD_VERSION 0 <NEW_LINE> <START_VULN> #define BUILD_REVISION 740 <NEW_LINE> <END_VULN> #define STRINGIFY ( x ) #x <NEW_LINE> #define MACRO_STRINGIFY ( x ) STRINGIFY ( x ) <NEW_LINE> #define REVISION_STRING MACRO_STRINGIFY ( BUILD_REVISION ) <NEW_LINE> #define VERSION_STRING MACRO_STRINGIFY ( MAJOR_VERSION ) " . " MACRO_STRINGIFY ( MINOR_VERSION ) " . " MACRO_STRINGIFY ( BUILD_VERSION ) " . " MACRO_STRINGIFY ( BUILD_REVISION )
float secs = ( float ) n / vi -> rate ; <NEW_LINE> amp += secs * gi -> ampmax_att_per_sec ; <NEW_LINE> if ( amp < - 9999 ) amp = - 9999 ; <NEW_LINE> return ( amp ) ; <NEW_LINE> } <NEW_LINE> static void couple_lossless ( float A , float B , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> float * qA , float * qB ) { <NEW_LINE> <END_VULN> int test1 = fabs ( * qA ) > fabs ( * qB ) ; <NEW_LINE> test1 -= fabs ( * qA ) < fabs ( * qB ) ; <NEW_LINE> if ( ! test1 ) test1 = ( ( fabs ( A ) > fabs ( B ) ) << 1 ) - 1 ; <NEW_LINE> if ( test1 == 1 ) { <NEW_LINE> <TAB> * qB = ( * qA > 0 . f ? * qA - * qB : * qB - * qA ) ; <NEW_LINE> } else { <NEW_LINE> <TAB> float temp = * qB ;
<TAB> return res ; <NEW_LINE> } <NEW_LINE> <START_VULN> mp_err <NEW_LINE> <END_VULN> ec_GFp_pt_add_jm_aff ( const mp_int * px , const mp_int * py , const mp_int * pz , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> const mp_int * paz4 , const mp_int * qx , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> const mp_int * qy , mp_int * rx , mp_int * ry , mp_int * rz , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> mp_int * raz4 , mp_int scratch [ ] , const ECGroup * group ) <NEW_LINE> { <NEW_LINE> <TAB> mp_err res = MP_OKAY ; <NEW_LINE> <TAB> mp_int * A , * B , * C , * D , * C2 , * C3 ;
static __u8 * mr_report_fixup ( struct hid_device * hdev , __u8 * rdesc , <NEW_LINE> <TAB> <TAB> unsigned int * rsize ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> hid_info ( hdev , "fixing up button / consumer in HID report descriptor\n" ) ; <NEW_LINE> <TAB> <TAB> rdesc [ 30 ] = 0x0c ; <NEW_LINE> <TAB> }
#pragma prefast ( suppress : 30030 ) <TAB> <TAB> <NEW_LINE> <START_VULN> <TAB> CS_WINKERNEL_MEMBLOCK * block = ( CS_WINKERNEL_MEMBLOCK * ) ExAllocatePoolWithTag ( <NEW_LINE><TAB> <TAB> <TAB> NonPagedPool , size + sizeof ( CS_WINKERNEL_MEMBLOCK ) , CS_WINKERNEL_POOL_TAG ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! block ) { <NEW_LINE> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> <TAB> error_line ( "dsdiff file version = 0x % 08x" , version ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> else if ( ! strncmp ( dff_chunk_header . ckID , "PROP" , 4 ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> char * prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || <NEW_LINE> <TAB> <TAB> <TAB> <TAB> bcount != dff_chunk_header . ckDataSize ) {
<TAB> void PopulateJSClass ( JSBool isGlobal ) ; <NEW_LINE> <TAB> void Mark ( ) { mFlags . Mark ( ) ; } <NEW_LINE> <TAB> void Unmark ( ) { mFlags . Unmark ( ) ; } <NEW_LINE> <TAB> JSBool IsMarked ( ) const { return mFlags . IsMarked ( ) ; } <NEW_LINE> private : <NEW_LINE> <TAB> XPCNativeScriptableFlags mFlags ; <NEW_LINE> <START_VULN> <TAB> XPCNativeScriptableSharedJSClass mJSClass ; <NEW_LINE> <END_VULN> <TAB> JSBool mCanBeSlim ; <NEW_LINE> } ; <NEW_LINE> class XPCNativeScriptableInfo
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : window functions <NEW_LINE> <START_VULN> last mod : $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_WINDOW_ <NEW_LINE> #define _V_WINDOW_ <NEW_LINE> extern float * _vorbis_window_get ( int n ) ; <NEW_LINE> extern void _vorbis_apply_window ( float * d , int * winno , long * blocksizes ,
<TAB> . open = stack_trace_filter_open , <NEW_LINE> <TAB> . read = seq_read , <NEW_LINE> <TAB> . write = ftrace_filter_write , <NEW_LINE> <START_VULN> <TAB> . llseek = ftrace_regex_lseek , <NEW_LINE> <END_VULN> <TAB> . release = ftrace_regex_release , <NEW_LINE> } ;
<TAB> ret = gpiochip_add_data ( & gpio_dev -> gc , gpio_dev ) ; <NEW_LINE> <TAB> if ( ret ) <NEW_LINE> <START_VULN> <TAB> <TAB> goto out1 ; <NEW_LINE> <END_VULN> <TAB> ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> 0 , 0 , TOTAL_NUMBER_OF_PINS ) ;
static int CVE_2013_4534_openpic_load ( QEMUFile * f , void * opaque , int version_id ) <NEW_LINE> { <NEW_LINE> <TAB> OpenPICState * opp = ( OpenPICState * ) opaque ; <NEW_LINE> <START_VULN> <TAB> unsigned int i ; <NEW_LINE> <END_VULN> <TAB> if ( version_id != 1 ) { <NEW_LINE> <TAB> <TAB> return - EINVAL ;
#if defined ( MSDOS ) || defined ( WIN32 ) <NEW_LINE> <START_VULN> char * sanitize_dos_name ( char * file_name ) ; <NEW_LINE> <END_VULN> #if defined ( MSDOS ) && ( defined ( __DJGPP__ ) || defined ( __GO32__ ) )
<TAB> if ( r == 0 ) { <NEW_LINE> <TAB> num_records = oggplay_callback_info_prepare ( me , & info ) ; <NEW_LINE> <TAB> for ( i = 0 ; i < me -> num_tracks ; i + + ) { <NEW_LINE> <TAB> <TAB> me -> decode_data [ i ] -> active = 0 ; <NEW_LINE> <START_VULN> <TAB> <TAB> me -> active_tracks = 0 ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( info != NULL ) { <NEW_LINE> <TAB> <TAB> me -> callback ( me , num_records , info , me -> callback_user_ptr ) ; <NEW_LINE> <TAB> <TAB> oggplay_callback_info_destroy ( me , info ) ; <NEW_LINE> <TAB> } <NEW_LINE> decoder -> stream_info = OGGPLAY_STREAM_UNINITIALISED ;
<TAB> <TAB> fit_value [ i ] = val + predicted ; <NEW_LINE> <TAB> <TAB> fit_value [ look -> loneighbor [ i - 2 ] ] &= 0x7fff ; <NEW_LINE> <TAB> <TAB> fit_value [ look -> hineighbor [ i - 2 ] ] &= 0x7fff ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> fit_value [ i ] = predicted|0x8000 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return ( fit_value ) ; <NEW_LINE> } <NEW_LINE> eop : <NEW_LINE> return ( NULL ) ; <NEW_LINE> }
* <NEW_LINE> ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> <START_VULN> extern js : : Class XPC_WN_NoHelper_JSClass ; <NEW_LINE> <END_VULN> extern js : : Class XPC_WN_NoMods_WithCall_Proto_JSClass ; <NEW_LINE> extern js : : Class XPC_WN_NoMods_NoCall_Proto_JSClass ; <NEW_LINE> extern js : : Class XPC_WN_ModsAllowed_WithCall_Proto_JSClass ; <NEW_LINE> extern js : : Class XPC_WN_ModsAllowed_NoCall_Proto_JSClass ; <NEW_LINE> extern js : : Class XPC_WN_Tearoff_JSClass ; <NEW_LINE> extern js : : Class XPC_WN_NoHelper_Proto_JSClass ; <NEW_LINE> extern JSBool
<START_VULN> <TAB> <TAB> if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ! c -> reqtype ) {
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> data , hlen , & _keyid ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ! keyid ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( skb_flow_dissector_uses_key ( flow_dissector , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> FLOW_DISSECTOR_KEY_GRE_KEYID ) ) {
<TAB> len = data [ dp + + ] ; <NEW_LINE> <START_VULN> <TAB> if ( len <= 0x7f ) { <NEW_LINE><TAB> <TAB> dp += len ; <NEW_LINE><TAB> <TAB> goto next_tag ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) {
extern SECStatus ssl3_HandleHelloExtensions ( sslSocket * ss , <NEW_LINE> <TAB> <TAB> <TAB> SSL3Opaque ** b , PRUint32 * length ) ; <NEW_LINE> extern PRBool ssl3_ExtensionNegotiated ( sslSocket * ss , PRUint16 ex_type ) ; <NEW_LINE> extern void ssl3_SetSIDSessionTicket ( sslSessionID * sid , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> NewSessionTicket * session_ticket , <NEW_LINE><TAB> <TAB> <TAB> PRBool isTicketRenewal ) ; <NEW_LINE> <END_VULN> extern SECStatus ssl3_SendNewSessionTicket ( sslSocket * ss ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeys ( unsigned char * keyName , <NEW_LINE> <TAB> <TAB> <TAB> unsigned char * encKey , unsigned char * macKey ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeysPKCS11 ( SECKEYPrivateKey * svrPrivKey , <NEW_LINE> <TAB> <TAB> <TAB> SECKEYPublicKey * svrPubKey , void * pwArg , <NEW_LINE> <TAB> <TAB> <TAB> unsigned char * keyName , PK11SymKey ** aesKey , <NEW_LINE> <TAB> <TAB> <TAB> PK11SymKey ** macKey ) ;
<TAB> <TAB> release_sock ( sk ) ; <NEW_LINE> <TAB> <TAB> current_timeo = schedule_timeout ( current_timeo ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> BUG_ON ( sk != asoc -> base . sk ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> lock_sock ( sk ) ; <NEW_LINE> <TAB> <TAB> * timeo_p = current_timeo ;
<TAB> if ( ret == 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> zap = key -> payload . data [ 0 ] ; <NEW_LINE> <END_VULN> <TAB> <TAB> rcu_assign_keypointer ( key , upayload ) ; <NEW_LINE> <TAB> <TAB> key -> expiry = 0 ; <NEW_LINE> <TAB> }
<TAB> mutex_unlock ( & key_construction_mutex ) ; <NEW_LINE> <START_VULN> <TAB> if ( keyring ) <NEW_LINE> <END_VULN> <TAB> <TAB> __key_link_end ( keyring , & key -> index_key , edit ) ;
<TAB> return CONNECTION_PREFACE . len ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void parse_input ( h2o_http2_conn_t * conn ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> size_t http2_max_concurrent_requests_per_connection = conn -> super . ctx -> globalconf -> http2 . max_concurrent_requests_per_connection ; <NEW_LINE> <TAB> int perform_early_exit = 0 ;
{ <NEW_LINE> <TAB> static generic_ret ret ; <NEW_LINE> <TAB> char * prime_arg ; <NEW_LINE> <START_VULN> <TAB> gss_buffer_desc client_name , <NEW_LINE><TAB> <TAB> service_name ; <NEW_LINE> <END_VULN> <TAB> OM_uint32 minor_stat ; <NEW_LINE> <TAB> kadm5_server_handle_t handle ; <NEW_LINE> <TAB> restriction_t * rp ;
<TAB> <TAB> <TAB> SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; <NEW_LINE> <TAB> <TAB> if ( skb_is_err_queue ( skb ) && skb -> len && <NEW_LINE> <START_VULN> <TAB> <TAB> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> skb -> len , skb -> data ) ; <NEW_LINE> <TAB> }
<TAB> } <NEW_LINE> <TAB> n = num_mixer_volumes + + ; <NEW_LINE> <START_VULN> <TAB> strcpy ( mixer_vols [ n ] . name , name ) ; <NEW_LINE> <END_VULN> <TAB> if ( present ) <NEW_LINE> <TAB> <TAB> mixer_vols [ n ] . num = n ;
<TAB> <TAB> <TAB> <TAB> data += fraggap ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> pskb_trim_unique ( skb_prev , maxfraglen ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> copy = datalen - transhdrlen - fraggap ; <NEW_LINE><NEW_LINE><TAB> <TAB> <TAB> if ( copy < 0 ) { <NEW_LINE><TAB> <TAB> <TAB> <TAB> err = - EINVAL ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> kfree_skb ( skb ) ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> goto error ; <NEW_LINE><TAB> <TAB> <TAB> } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> err = - EFAULT ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> kfree_skb ( skb ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto error ;
<TAB> <TAB> uint32_t lineIndexToNum ( uint32_t lineIndex ) const { return lineIndex + initialLineNum_ ; } <NEW_LINE> <TAB> <TAB> uint32_t lineNumToIndex ( uint32_t lineNum ) const { return lineNum - initialLineNum_ ; } <NEW_LINE> <TAB> public : <NEW_LINE> <TAB> <TAB> SourceCoords ( ExclusiveContext * cx , uint32_t ln ) ; <NEW_LINE> <TAB> <TAB> void add ( uint32_t lineNum , uint32_t lineStartOffset ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> void fill ( const SourceCoords & other ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> bool isOnThisLine ( uint32_t offset , uint32_t lineNum ) const { <NEW_LINE> <TAB> <TAB> <TAB> uint32_t lineIndex = lineNumToIndex ( lineNum ) ; <NEW_LINE> <TAB> <TAB> <TAB> JS_ASSERT ( lineIndex + 1 < lineStartOffsets_ . length ( ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> return lineStartOffsets_ [ lineIndex ] <= offset && <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> offset < lineStartOffsets_ [ lineIndex + 1 ] ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> case ' % ' : <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> doapr_outch ( sbuffer , buffer , & currlen , maxlen , ch ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> case 'w' :
ScaleRequest * mScaleRequest ; <NEW_LINE> nsresult ShutdownDecoder ( eShutdownIntent aIntent ) ; <NEW_LINE> <START_VULN> void DoError ( ) ; <NEW_LINE> <END_VULN> bool CanDiscard ( ) ; <NEW_LINE> bool CanForciblyDiscard ( ) ; <NEW_LINE> bool DiscardingActive ( ) ; <NEW_LINE> bool StoringSourceData ( ) const ; <NEW_LINE> protected : <NEW_LINE> RasterImage ( imgStatusTracker * aStatusTracker = nullptr , nsIURI * aURI = nullptr ) ;
<TAB> int pixel_countdown ; <NEW_LINE> <TAB> unsigned char * pixels ; <NEW_LINE> <TAB> int pixel ; <NEW_LINE> <START_VULN> <TAB> int pixel_limit ; <NEW_LINE> <END_VULN> <TAB> s -> frame . reference = 1 ; <NEW_LINE> <TAB> s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;
<TAB> Address addressForDataRemat ( const FrameEntry * fe ) const ; <NEW_LINE> <START_VULN> <TAB> Address addressForInlineReturn ( ) const ; <NEW_LINE> <END_VULN> <TAB> inline StateRemat dataRematInfo ( const FrameEntry * fe ) const ;
static char * pool_strdup ( const char * s ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> char * r = pool_alloc ( strlen ( s ) + 1 ) ; <NEW_LINE><TAB> strcpy ( r , s ) ; <NEW_LINE> <END_VULN> <TAB> return r ; <NEW_LINE> }
static void get_nb10 ( ut8 * dbg_data , SCV_NB10_HEADER * res ) { <NEW_LINE> <TAB> const int nb10sz = 16 ; <NEW_LINE> <START_VULN> <TAB> memcpy ( res , dbg_data , nb10sz ) ; <NEW_LINE><TAB> res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int get_debug_info ( struct PE_ ( r_bin_pe_obj_t ) * bin , PE_ ( image_debug_directory_entry ) * dbg_dir_entry , ut8 * dbg_data , int dbg_data_len , SDebugInfo * res ) {
#endif <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> unsigned char * oe = op + t ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> NEED_OP ( t ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> op [ 0 ] = m_pos [ 0 ] ; <NEW_LINE> <TAB> <TAB> <TAB> op [ 1 ] = m_pos [ 1 ] ; <NEW_LINE> <TAB> <TAB> <TAB> op += 2 ;
<TAB> <TAB> char ps_name [ MAX_RDS_PS_NAME + 1 ] ; <NEW_LINE> <TAB> <TAB> len = control -> size - 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( len > MAX_RDS_PS_NAME ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> rval = - ERANGE ; <NEW_LINE> <TAB> <TAB> <TAB> goto exit ; <NEW_LINE> <TAB> <TAB> }
namespace xpc { <NEW_LINE> class WrapperFactory { <NEW_LINE> public : <NEW_LINE> <TAB> enum { WAIVE_XRAY_WRAPPER_FLAG = js : : Wrapper : : LAST_USED_FLAG << 1 , <NEW_LINE> <TAB> <TAB> <TAB> IS_XRAY_WRAPPER_FLAG = WAIVE_XRAY_WRAPPER_FLAG << 1 , <NEW_LINE> <TAB> <TAB> <TAB> SCRIPT_ACCESS_ONLY_FLAG = IS_XRAY_WRAPPER_FLAG << 1 , <NEW_LINE> <TAB> <TAB> <TAB> PARTIALLY_TRANSPARENT = SCRIPT_ACCESS_ONLY_FLAG << 1 , <NEW_LINE> <START_VULN> <TAB> <TAB> SOW_FLAG = PARTIALLY_TRANSPARENT << 1 } ; <NEW_LINE> <END_VULN> <TAB> static bool HasWrapperFlag ( JSObject * wrapper , uintN flag ) { <NEW_LINE> <TAB> <TAB> uintN flags = 0 ; <NEW_LINE> <TAB> <TAB> js : : UnwrapObject ( wrapper , & flags ) ; <NEW_LINE> <TAB> <TAB> return ! ! ( flags & flag ) ; <NEW_LINE> <TAB> }
<TAB> either version 2 of the License or ( at your option ) any later version . <NEW_LINE> #pragma once <NEW_LINE> #include "graphite2 / Types . h" <NEW_LINE> #define GR2_VERSION_MAJOR 1 <NEW_LINE> #define GR2_VERSION_MINOR 1 <NEW_LINE> <START_VULN> #define GR2_VERSION_BUGFIX 2 <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> extern "C" <NEW_LINE> { <NEW_LINE> #endif <NEW_LINE> typedef struct gr_face gr_face ; <NEW_LINE> typedef struct gr_font gr_font ;
<TAB> <TAB> return - EFAULT ; <NEW_LINE> <TAB> len = namelen ; <NEW_LINE> <START_VULN> <TAB> if ( namelen > 32 ) <NEW_LINE> <END_VULN> <TAB> <TAB> len = 32 ; <NEW_LINE> <TAB> down_read ( & uts_sem ) ;
#endif <NEW_LINE> <START_VULN> <TAB> cmd = zend_string_alloc ( 2 * l , 0 ) ; <NEW_LINE> <END_VULN> <TAB> for ( x = 0 , y = 0 ; x < l ; x + + ) { <NEW_LINE> <TAB> <TAB> int mb_len = php_mblen ( str + x , ( l - x ) ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : LSP ( also called LSF ) conversion routines <NEW_LINE> <START_VULN> last mod : $ Id : lsp . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> The LSP generation code is taken ( with minimal modification and a <NEW_LINE> few bugfixes ) from "On the Computation of the LSP Frequencies" by <NEW_LINE> Joseph Rothweiler ( see http : <NEW_LINE> The paper is available at : <NEW_LINE> http :
<TAB> u8 <TAB> same_flow : 1 ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> u8 <TAB> udp_mark : 1 ; <NEW_LINE> <END_VULN> <TAB> u8 <TAB> csum_valid : 1 ;
<TAB> __ip6_dst_store ( sk , dst , NULL , NULL ) ; <NEW_LINE> <TAB> icsk -> icsk_ext_hdr_len = 0 ; <NEW_LINE> <START_VULN> <TAB> if ( np -> opt != NULL ) <NEW_LINE><TAB> <TAB> icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> np -> opt -> opt_nflen ) ; <NEW_LINE> <END_VULN> <TAB> inet -> inet_dport = usin -> sin6_port ;
int do_adjtimex ( struct timex * txc ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> long mtemp , save_adjust , rem ; <NEW_LINE> <END_VULN> <TAB> s64 freq_adj ; <NEW_LINE> <TAB> int result ;
typedef struct FlatpakProxyClient FlatpakProxyClient ; <NEW_LINE> <START_VULN> <NEW_LINE>#define AUTH_END_INIT_OFFSET 2 <NEW_LINE>#define AUTH_END_STRING "\r\nBEGIN\r\n" <NEW_LINE> <END_VULN> typedef enum { <NEW_LINE> EXPECTED_REPLY_NONE ,
<TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> case ASF_DEMUX_DATA_TYPE_DWORD : { <NEW_LINE> <START_VULN> <TAB> <TAB> guint uint_val = GST_READ_UINT32_LE ( value ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> g_value_init ( & tag_value , G_TYPE_UINT ) ;
<TAB> if ( IS_ERR ( prog ) ) <NEW_LINE> <TAB> <TAB> return prog ; <NEW_LINE> <START_VULN> <TAB> atomic_inc ( & prog -> aux -> refcnt ) ; <NEW_LINE> <END_VULN> <TAB> fdput ( f ) ; <NEW_LINE> <TAB> return prog ;
<TAB> <TAB> case 2 : <NEW_LINE> <TAB> <TAB> <TAB> s -> smart_selftest_count + + ; <NEW_LINE> <TAB> <TAB> <TAB> if ( s -> smart_selftest_count > 21 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> s -> smart_selftest_count = 0 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> n = 2 + ( s -> smart_selftest_count - 1 ) * 24 ; <NEW_LINE> <TAB> <TAB> <TAB> s -> smart_selftest_data [ n ] = s -> sector ;
<TAB> char * ptr ; <NEW_LINE> <TAB> int err ; <NEW_LINE> <START_VULN> <TAB> file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! file ) <NEW_LINE> <TAB> <TAB> return - ENOMEM ;
<TAB> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> session -> payload = new_payload ; <NEW_LINE><TAB> <TAB> memcpy ( ( session -> payload + session -> payload_len ) , ( * payload ) , ( * payload_len ) ) ; <NEW_LINE><TAB> <TAB> session -> payload_len += * payload_len ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ! fin && session -> reconstruct && ( session -> payload_len < session -> reconstruct ) ) {
<TAB> <TAB> ast_mutex_init ( & s -> __lock ) ; <NEW_LINE> <TAB> <TAB> ast_mutex_lock ( & s -> __lock ) ; <NEW_LINE> <TAB> <TAB> s -> inuse = 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> s -> managerid = rand ( ) | ( unsigned long ) s ; <NEW_LINE> <END_VULN> <TAB> <TAB> AST_LIST_LOCK ( & sessions ) ; <NEW_LINE> <TAB> <TAB> AST_LIST_INSERT_HEAD ( & sessions , s , list ) ;
<TAB> key -> expiry = prep -> expiry ; <NEW_LINE> <START_VULN> <TAB> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> zap = dereference_key_locked ( key ) ; <NEW_LINE> <TAB> rcu_assign_keypointer ( key , prep -> payload . data [ 0 ] ) ; <NEW_LINE> <TAB> prep -> payload . data [ 0 ] = NULL ;
<TAB> <TAB> <TAB> return err ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( s -> chunksize >= 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ! s -> chunksize ) { <NEW_LINE> <TAB> <TAB> <TAB> char line [ 32 ] ;
<TAB> int errCode = SSL_ERROR_RX_MALFORMED_CERTIFICATE ; <NEW_LINE> <TAB> SECItem certItem ; <NEW_LINE> <TAB> SSL_TRC ( 3 , ( " % d : SSL3 [ % d ] : handle certificate handshake" , <NEW_LINE> <TAB> <TAB> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> <START_VULN> <TAB> if ( ( ss -> ssl3 . hs . ws != wait_server_cert ) && <NEW_LINE><TAB> ( ss -> ssl3 . hs . ws != wait_client_cert ) ) { <NEW_LINE><TAB> desc = unexpected_message ; <NEW_LINE><TAB> errCode = SSL_ERROR_RX_UNEXPECTED_CERTIFICATE ; <NEW_LINE><TAB> goto alert_loser ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( ss -> sec . peerCert != NULL ) { <NEW_LINE> <TAB> if ( ss -> sec . peerKey ) { <NEW_LINE> <TAB> SECKEY_DestroyPublicKey ( ss -> sec . peerKey ) ; <NEW_LINE> <TAB> ss -> sec . peerKey = NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> CERT_DestroyCertificate ( ss -> sec . peerCert ) ;
<TAB> <TAB> <TAB> if ( b_copy ) <NEW_LINE> <TAB> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> dy = ( dy + CDG_SCREEN_HEIGHT ) % CDG_SCREEN_HEIGHT ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> dy = ( dy + CDG_SCREEN_WIDTH ) % CDG_SCREEN_WIDTH ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> else <NEW_LINE> <TAB> <TAB> <TAB> {
<TAB> <TAB> <TAB> : clasp ( clasp ) , proto ( proto ) , parent ( parent ) , <NEW_LINE> <TAB> <TAB> <TAB> nfixed ( nfixed ) , baseFlags ( baseFlags ) <NEW_LINE> <TAB> <TAB> { } <NEW_LINE> <TAB> } ; <NEW_LINE> <TAB> inline InitialShapeEntry ( ) ; <NEW_LINE> <TAB> inline InitialShapeEntry ( const ReadBarriered < Shape > & shape , TaggedProto proto ) ; <NEW_LINE> <START_VULN> <TAB> inline Lookup getLookup ( ) ; <NEW_LINE> <END_VULN> <TAB> static inline HashNumber hash ( const Lookup & lookup ) ; <NEW_LINE> <TAB> static inline bool match ( const InitialShapeEntry & key , const Lookup & lookup ) ; <NEW_LINE> } ; <NEW_LINE> typedef HashSet < InitialShapeEntry , InitialShapeEntry , SystemAllocPolicy > InitialShapeSet ; <NEW_LINE> struct StackShape
<TAB> <TAB> zval_dtor ( * zcount ) ; <NEW_LINE> <TAB> <TAB> ZVAL_LONG ( * zcount , replace_count ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> }
mutt_str_strfcpy ( buf , "mailboxes \"" , sizeof ( buf ) ) ; <NEW_LINE> mutt_account_tourl ( & idata -> conn -> account , & url ) ; <NEW_LINE> <START_VULN> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <NEW_LINE> <END_VULN> url . path = errstr + 1 ; <NEW_LINE> url . path [ strlen ( url . path ) - 1 ] = '\0' ; <NEW_LINE> if ( mutt_str_strcmp ( url . user , ImapUser ) == 0 )
<TAB> } <NEW_LINE> <TAB> n = xmalloc ( len ) ; <NEW_LINE> <TAB> m = n + len - ( nlen + 1 ) ; <NEW_LINE> <START_VULN> <TAB> strcpy ( m , name ) ; <NEW_LINE> <END_VULN> <TAB> for ( p = path ; p ; p = p -> up ) { <NEW_LINE> <TAB> <TAB> if ( p -> elem_len ) { <NEW_LINE> <TAB> <TAB> <TAB> m -= p -> elem_len + 1 ;
<TAB> <TAB> <TAB> if ( is_limited_pmc ( i + 1 ) ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> <TAB> val = read_pmc ( i + 1 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( ( int ) val < 0 ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> write_pmc ( i + 1 , 0 ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> }
<START_VULN> <TAB> opt = xchg ( & np -> opt , NULL ) ; <NEW_LINE><TAB> if ( opt ) <NEW_LINE><TAB> <TAB> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> EXPORT_SYMBOL_GPL ( inet6_destroy_sock ) ;
<TAB> <TAB> struct bpf_map * map_ptr ; <TAB> <NEW_LINE> <TAB> } ; <NEW_LINE> <TAB> int ctx_field_size ; <NEW_LINE> <START_VULN> <TAB> int converted_op_size ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> #define MAX_USED_MAPS 64
<TAB> int error ; <NEW_LINE> <TAB> if ( type == ACL_TYPE_ACCESS ) { <NEW_LINE> <START_VULN> <TAB> <TAB> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <NEW_LINE><TAB> <TAB> if ( error < 0 ) <NEW_LINE><TAB> <TAB> <TAB> return 0 ; <NEW_LINE><TAB> <TAB> if ( error == 0 ) <NEW_LINE><TAB> <TAB> <TAB> acl = NULL ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> inode -> i_ctime = current_time ( inode ) ;
<TAB> <TAB> <TAB> krb5_free_error_message ( handle -> context , errmsg ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> gss_release_buffer ( & minor_stat , & client_name ) ; <NEW_LINE> <TAB> gss_release_buffer ( & minor_stat , & service_name ) ; <NEW_LINE> <START_VULN> exit_func : <NEW_LINE> <END_VULN> <TAB> free_server_handle ( handle ) ; <NEW_LINE> <TAB> return & ret ; <NEW_LINE> }
<TAB> <TAB> if ( color ) { <NEW_LINE> <TAB> <TAB> <TAB> memset ( s -> frame -> data [ 0 ] + y * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( half_vert ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> memset ( s -> frame -> data [ 0 ] + ( y + 1 ) * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> x += run_length ;
<TAB> if ( ! esize ) { <NEW_LINE> <START_VULN> <TAB> <TAB> rp [ 0 ] = 1 ; <NEW_LINE> <END_VULN> <TAB> <TAB> res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ; <NEW_LINE> <TAB> <TAB> res -> sign = 0 ; <NEW_LINE> <TAB> <TAB> goto leave ; <NEW_LINE> <TAB> }
<TAB> * <NEW_LINE> MOZ_WARN_UNUSED_RESULT bool ReplacePrep ( index_type aCutStart , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> size_type aCutLength , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> size_type aNewLength ) <NEW_LINE> { <NEW_LINE><TAB> aCutLength = XPCOM_MIN ( aCutLength , mLength - aCutStart ) ; <NEW_LINE><TAB> uint32_t newTotalLen = mLength - aCutLength + aNewLength ; <NEW_LINE><TAB> if ( aCutStart == mLength && Capacity ( ) > newTotalLen ) { <NEW_LINE><TAB> mFlags &= ~ F_VOIDED ; <NEW_LINE><TAB> mData [ newTotalLen ] = char_type ( 0 ) ; <NEW_LINE><TAB> mLength = newTotalLen ; <NEW_LINE><TAB> return true ; <NEW_LINE><TAB> } <NEW_LINE><TAB> return ReplacePrepInternal ( aCutStart , aCutLength , aNewLength , newTotalLen ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> MOZ_WARN_UNUSED_RESULT bool NS_FASTCALL ReplacePrepInternal (
void snd_usb_mixer_disconnect ( struct usb_mixer_interface * mixer ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> usb_kill_urb ( mixer -> urb ) ; <NEW_LINE><TAB> usb_kill_urb ( mixer -> rc_urb ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef CONFIG_PM
<TAB> <TAB> <TAB> <TAB> struct ext4_xattr_info * i , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> struct ext4_xattr_ibody_find * is ) ; <NEW_LINE> <START_VULN> extern struct mb_cache * ext4_xattr_create_cache ( char * name ) ; <NEW_LINE>extern void ext4_xattr_destroy_cache ( struct mb_cache * ) ; <NEW_LINE> <END_VULN> #ifdef CONFIG_EXT4_FS_SECURITY <NEW_LINE> extern int ext4_init_security ( handle_t * handle , struct inode * inode ,
<TAB> <TAB> idx = ( ( r -> CRm & 3 ) << 3 ) | ( r -> Op2 & 7 ) ; <NEW_LINE> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> BUG ( ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( ! pmu_counter_idx_valid ( vcpu , idx ) )
<TAB> return ret ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void ptrace_triggered ( struct perf_event * bp , int nmi , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> struct perf_sample_data * data , <NEW_LINE> <TAB> <TAB> <TAB> struct pt_regs * regs ) <NEW_LINE> {
<TAB> msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ; <NEW_LINE> <TAB> msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ; <NEW_LINE> <TAB> msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ; <NEW_LINE> <TAB> if ( peekonly ) { <NEW_LINE> <START_VULN> <TAB> <TAB> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> goto peekout ; <NEW_LINE> <TAB> }
<TAB> <TAB> s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; <NEW_LINE> <TAB> <TAB> s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; <NEW_LINE> <TAB> <TAB> s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sample seperation\n" ) ; <NEW_LINE> <TAB> <TAB> <TAB> return AVERROR_INVALIDDATA ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> tcp_fetch_timewait_stamp ( sk , dst ) ; <NEW_LINE> <TAB> icsk -> icsk_ext_hdr_len = 0 ; <NEW_LINE> <START_VULN> <TAB> if ( np -> opt ) <NEW_LINE><TAB> <TAB> icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> np -> opt -> opt_nflen ) ; <NEW_LINE> <END_VULN> <TAB> tp -> rx_opt . mss_clamp = IPV6_MIN_MTU - sizeof ( struct tcphdr ) - sizeof ( struct ipv6hdr ) ;
<TAB> <TAB> if ( r ) { <NEW_LINE> <TAB> <TAB> <TAB> printk ( KERN_ERR "kvm_iommu_map_address : " <NEW_LINE> <TAB> <TAB> <TAB> "iommu failed to map pfn = % llx\n" , pfn ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> kvm_unpin_pages ( kvm , pfn , page_size ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> goto unmap_pages ; <NEW_LINE> <TAB> <TAB> }
<START_VULN> #ifndef __ESCAPE_H <NEW_LINE>#define __ESCAPE_H <NEW_LINE> <END_VULN> #endif
<START_VULN> <TAB> <TAB> if ( ! SSL_USE_ETM ( s ) && mac_size != 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & ( outbuf [ j ] [ wr [ j ] . length + eivlen ] ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> 1 ) < 0 )
<TAB> p -> owner = sp ; <NEW_LINE> <TAB> atomic_inc ( & sp -> so_count ) ; <NEW_LINE> <TAB> p -> o_arg . fh = NFS_FH ( dir ) ; <NEW_LINE> <START_VULN> <TAB> p -> o_arg . open_flags = flags , <NEW_LINE> <END_VULN> <TAB> p -> o_arg . clientid = server -> nfs_client -> cl_clientid ; <NEW_LINE> <TAB> p -> o_arg . id = sp -> so_owner_id . id ; <NEW_LINE> <TAB> p -> o_arg . name = & p -> path . dentry -> d_name ;
#include < windows . h > <NEW_LINE> #include "nscore . h" <NEW_LINE> #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN <NEW_LINE> #include < dwmapi . h > <NEW_LINE> #endif <NEW_LINE> <START_VULN> #if defined ( WINCE ) || ( MOZ_WINSDK_TARGETVER == MOZ_NTDDI_WS03 ) <NEW_LINE> <END_VULN> struct MARGINS <NEW_LINE> { <NEW_LINE> int cxLeftWidth ; <NEW_LINE> int cxRightWidth ; <NEW_LINE> int cyTopHeight ; <NEW_LINE> int cyBottomHeight ; <NEW_LINE> } ; <NEW_LINE> #endif
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Camellia Cipher Algorithm , AES - NI / AVX optimized" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "camellia" ) ; <NEW_LINE>MODULE_ALIAS ( "camellia - asm" ) ; <NEW_LINE> <END_VULN>
OggPlayErrorCode <NEW_LINE> oggplay_data_handle_cmml_data ( OggPlayDecode * decode , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> unsigned char * data , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> long size ) { <NEW_LINE> OggPlayTextRecord * record = NULL ; <NEW_LINE> size_t record_size = sizeof ( OggPlayTextRecord ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE>if ( ( size < 0 ) || ( size + 1 < 0 ) ) { <NEW_LINE><TAB> return E_OGGPLAY_TYPE_OVERFLOW ; <NEW_LINE> } <NEW_LINE>size += 1 ; <NEW_LINE><NEW_LINE> <END_VULN> if <NEW_LINE> ( <NEW_LINE> <TAB> oggplay_check_add_overflow ( record_size , size , & record_size ) <NEW_LINE> <TAB> == <NEW_LINE> <TAB> E_OGGPLAY_TYPE_OVERFLOW <NEW_LINE> ) <NEW_LINE> { <NEW_LINE> <TAB> return E_OGGPLAY_TYPE_OVERFLOW ;
1 , <NEW_LINE> - 533200896 , 1611661312 , 4 , 1 , <NEW_LINE> partial_quantlist1 , <NEW_LINE> NULL , NULL , NULL , <NEW_LINE> 0 <NEW_LINE> } ; <NEW_LINE> static float test5_result [ ] = { - 3 , - 6 , - 9 , 4 , 1 , - 2 , - 1 , - 4 , - 7 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , 1 , - 2 , 4 , 8 , 5 , - 1 , 3 , 0 , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , - 4 , - 7 , 4 , 3 , 0 , - 1 , - 2 , - 5 , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , - 6 , - 2 , 4 , 1 , 5 , - 1 , - 4 , 0 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , 1 , 5 , 4 , 8 , 12 , - 1 , 3 , 7 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , - 4 , 0 , 4 , 3 , 7 , - 1 , - 2 , 2 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , - 6 , - 7 , 4 , 1 , 0 , - 1 , - 4 , - 5 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , 1 , 0 , 4 , 8 , 7 , - 1 , 3 , 2 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> - 3 , - 4 , - 5 , 4 , 3 , 2 , - 1 , - 2 , - 3 } ; <NEW_LINE> void run_test ( static_codebook * b , float * comp ) {
<TAB> <TAB> return - ENOMEM ; <NEW_LINE> <TAB> if ( client -> type == USER_CLIENT && info -> kernel ) { <NEW_LINE> <START_VULN> <TAB> <TAB> snd_seq_delete_port ( client , port -> addr . port ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( client -> type == KERNEL_CLIENT ) {
<TAB> <TAB> being short or long * / <NEW_LINE> <TAB> if ( v -> pcm_returned == - 1 ) { <NEW_LINE> <TAB> v -> pcm_returned = thisCenter ; <NEW_LINE> <TAB> v -> pcm_current = thisCenter ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> v -> pcm_returned = prevCenter ; <NEW_LINE> <TAB> v -> pcm_current = prevCenter + <NEW_LINE> <START_VULN> <TAB> ( ( ci -> blocksizes [ v -> lW ] / 4 + <NEW_LINE><TAB> ci -> blocksizes [ v -> W ] / 4 ) >> hs ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> } <NEW_LINE> <TAB> making sure our last packet doesn't end with added padding . If <NEW_LINE> <TAB> the last packet is partial , the number of samples we'll have to <NEW_LINE> <TAB> return will be past the vb -> granulepos .
<TAB> } <NEW_LINE> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> RETURN_FALSE ; <NEW_LINE> <TAB> }
<TAB> <TAB> break ; <NEW_LINE> <TAB> tag_value = ( ssize_t ) ReadProfileShort ( endian , q ) ; <NEW_LINE> <TAB> format = ( ssize_t ) ReadProfileShort ( endian , q + 2 ) ; <NEW_LINE> <START_VULN> <TAB> if ( ( format - 1 ) >= EXIF_NUM_FORMATS ) <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> components = ( ssize_t ) ReadProfileLong ( endian , q + 4 ) ; <NEW_LINE> <TAB> if ( components < 0 )
<TAB> } <NEW_LINE> } ; <NEW_LINE> <START_VULN> static OM_uint32 KRB5_CALLCONV <NEW_LINE> <END_VULN> krb5_gss_inquire_sec_context_by_oid ( OM_uint32 * minor_status , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const gss_ctx_id_t context_handle , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const gss_OID desired_object ,
<TAB> } <NEW_LINE> <TAB> ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <NEW_LINE> <START_VULN> <TAB> if ( ! ctx -> established ) { <NEW_LINE> <END_VULN> <TAB> <TAB> * minor_status = KG_CTX_INCOMPLETE ; <NEW_LINE> <TAB> <TAB> return ( GSS_S_NO_CONTEXT ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> args -> usb_sock = usb_sock ; <NEW_LINE> <START_VULN> <TAB> <TAB> args -> tcp = tcp_conn_accept ( tcp_socket ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( args -> tcp == NULL ) { <NEW_LINE> <TAB> <TAB> <TAB> ERR ( "Failed to open tcp connection" ) ; <NEW_LINE> <TAB> <TAB> <TAB> goto cleanup_thread ;
<START_VULN> <TAB> p = BuildTestPacket ( 1 , 8183 , 0 , 'A' , 71 ) ; <NEW_LINE> <END_VULN> <TAB> if ( p == NULL ) <NEW_LINE> <TAB> <TAB> goto end ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Blowfish Cipher Algorithm , asm optimized" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "blowfish" ) ; <NEW_LINE>MODULE_ALIAS ( "blowfish - asm" ) ; <NEW_LINE> <END_VULN>
DBUG_PRINT ( "my" , ( "org_name : ' % s' tmp_name : ' % s' MyFlags : % d" , <NEW_LINE> <TAB> <TAB> org_name , tmp_name , MyFlags ) ) ; <NEW_LINE> <START_VULN> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <NEW_LINE> <END_VULN> <TAB> goto end ; <NEW_LINE> if ( MyFlags & MY_REDEL_MAKE_BACKUP ) <NEW_LINE> {
{ <NEW_LINE> <TAB> GF_HandlerBox * p = ( GF_HandlerBox * ) a ; <NEW_LINE> <TAB> gf_isom_box_dump_start ( a , "HandlerBox" , trace ) ; <NEW_LINE> <START_VULN> <TAB> if ( p -> nameUTF8 && ( u32 ) p -> nameUTF8 [ 0 ] == strlen ( p -> nameUTF8 + 1 ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> fprintf ( trace , "hdlrType = \" % s\" Name = \" % s\" " , gf_4cc_to_str ( p -> handlerType ) , p -> nameUTF8 + 1 ) ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> fprintf ( trace , "hdlrType = \" % s\" Name = \" % s\" " , gf_4cc_to_str ( p -> handlerType ) , p -> nameUTF8 ) ;
<TAB> <TAB> <TAB> res_dp += cmd ; <NEW_LINE> <TAB> <TAB> <TAB> res_sz -= cmd ; <NEW_LINE> <START_VULN> <TAB> <TAB> } <NEW_LINE><TAB> <TAB> else { <NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> goto fail ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> }
<TAB> <TAB> freq_adj += time_freq ; <NEW_LINE> <TAB> <TAB> freq_adj = min ( freq_adj , ( s64 ) MAXFREQ_NSEC ) ; <NEW_LINE> <TAB> <TAB> time_freq = max ( freq_adj , ( s64 ) - MAXFREQ_NSEC ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> time_offset = div_long_long_rem_signed ( time_offset , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> NTP_INTERVAL_FREQ , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & rem ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> time_offset <<= SHIFT_UPDATE ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> }
} <NEW_LINE> static void <NEW_LINE> <START_VULN> mark_trusted_task_done ( GObject * source_object , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> GAsyncResult * res , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> gpointer user_data ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> MarkTrustedJob * job = user_data ;
<TAB> if ( num_head > 0 ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> uhp_table = ( u_header_T ** ) U_ALLOC_LINE ( <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> num_head * sizeof ( u_header_T * ) ) ; <NEW_LINE> <TAB> if ( uhp_table == NULL ) <NEW_LINE> <TAB> goto error ;
<TAB> <TAB> <TAB> define_sid = 0 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! PS ( id ) && <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> zend_hash_find ( & EG ( symbol_table ) , "_GET" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> sizeof ( "_GET" ) , ( void ** ) & data ) == SUCCESS && <NEW_LINE> <TAB> <TAB> <TAB> <TAB> Z_TYPE_PP ( data ) == IS_ARRAY &&
<TAB> <TAB> msg [ 0 ] -> msg_style == PAM_PROMPT_ECHO_ON ) ) { <NEW_LINE> <TAB> * resp = malloc ( sizeof ( struct pam_response ) ) ; <NEW_LINE> <TAB> assert ( * resp ) ; <NEW_LINE> <START_VULN> <TAB> ( * resp ) -> resp = calloc ( 1024 , 0 ) ; <NEW_LINE> <END_VULN> <TAB> struct termios termios = old_termios ; <NEW_LINE> <TAB> if ( msg [ 0 ] -> msg_style == PAM_PROMPT_ECHO_OFF ) { <NEW_LINE> <TAB> termios . c_lflag &= ~ ( ECHO|ECHONL ) ;
static freelist_idx_t next_random_slot ( union freelist_init_state * state ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return ( state -> list [ state -> pos + + ] + state -> rand ) % state -> count ; <NEW_LINE> <END_VULN> }
<TAB> <TAB> break ; <NEW_LINE> #endif <NEW_LINE> <TAB> case KVM_CAP_PPC_HTM : <NEW_LINE> <START_VULN> <TAB> <TAB> r = cpu_has_feature ( CPU_FTR_TM_COMP ) && <NEW_LINE><TAB> <TAB> is_kvmppc_hv_enabled ( kvm ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> default : <NEW_LINE> <TAB> <TAB> r = 0 ;
{ <NEW_LINE> uint32_t length ; <NEW_LINE> uint32_t flags ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> char c_string [ 1 ] ; <NEW_LINE> } SIZED_STRING ;
static void dns_resolver_describe ( const struct key * key , struct seq_file * m ) <NEW_LINE> { <NEW_LINE> <TAB> seq_puts ( m , key -> description ) ; <NEW_LINE> <START_VULN> <TAB> if ( key_is_instantiated ( key ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> int err = PTR_ERR ( key -> payload . data [ dns_key_error ] ) ; <NEW_LINE> <TAB> <TAB> if ( err )
<TAB> DefragInit ( ) ; <NEW_LINE> <START_VULN> <TAB> Packet * p1 = IPV6BuildTestPacket ( ip_id , 2 , 1 , 'C' , 8 ) ; <NEW_LINE><TAB> Packet * p2 = IPV6BuildTestPacket ( ip_id , 0 , 1 , 'A' , 8 ) ; <NEW_LINE><TAB> Packet * p3 = IPV6BuildTestPacket ( ip_id , 1 , 0 , 'B' , 8 ) ; <NEW_LINE> <END_VULN> <TAB> if ( p1 == NULL || p2 == NULL || p3 == NULL ) { <NEW_LINE> <TAB> <TAB> goto end ; <NEW_LINE> <TAB> }
<START_VULN> <TAB> <TAB> <TAB> cli_dbgmsg ( "Possible data corruption fixed\n" ) ; <NEW_LINE><TAB> <TAB> <TAB> p [ 8 ] = ' = ' ; <NEW_LINE> <END_VULN> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> if ( * p ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> cli_dbgmsg ( "messageAddArgument , ' % s' contains no ' = '\n" , p ) ;
{ <NEW_LINE> <TAB> int error ; <NEW_LINE> <TAB> struct dentry * dentry = NULL , * trap ; <NEW_LINE> <START_VULN> <TAB> const char * old_name ; <NEW_LINE> <END_VULN> <TAB> trap = lock_rename ( new_dir , old_dir ) ;
<TAB> <TAB> return mUploadStream ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void GetFTPEventSink ( nsCOMPtr < nsIFTPEventSink > & aResult ) ; <NEW_LINE> protected : <NEW_LINE> <TAB> virtual ~ nsFtpChannel ( ) { } <NEW_LINE> <START_VULN> <TAB> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result ) ; <NEW_LINE> <END_VULN> <TAB> virtual PRBool GetStatusArg ( nsresult status , nsString & statusArg ) ; <NEW_LINE> <TAB> virtual void OnCallbacksChanged ( ) ; <NEW_LINE> private : <NEW_LINE> <TAB> nsCOMPtr < nsIProxyInfo > mProxyInfo ; <NEW_LINE> <TAB> nsCOMPtr < nsIFTPEventSink > mFTPEventSink ; <NEW_LINE> <TAB> nsCOMPtr < nsIInputStream > mUploadStream ; <NEW_LINE> <TAB> PRUint64 mStartPos ;
<TAB> int t = info -> postlist [ k + 2 ] = oggpack_read ( opb , rangebits ) ; <NEW_LINE> <TAB> if ( t < 0 || t >= ( 1 << rangebits ) ) <NEW_LINE> <TAB> goto err_out ; <NEW_LINE> <TAB> } <NEW_LINE> } <NEW_LINE> info -> postlist [ 0 ] = 0 ; <NEW_LINE> info -> postlist [ 1 ] = 1 << rangebits ; <NEW_LINE> return ( info ) ; <NEW_LINE> err_out : <NEW_LINE> floor1_free_info ( info ) ; <NEW_LINE> return ( NULL ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int icomp ( const void * a , const void * b ) { <NEW_LINE>return ( ** ( int ** ) a - ** ( int ** ) b ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> static vorbis_look_floor * floor1_look ( vorbis_dsp_state * vd , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> vorbis_info_floor * in ) { <NEW_LINE> int * sortpointer [ VIF_POSIT + 2 ] ; <NEW_LINE> vorbis_info_floor1 * info = ( vorbis_info_floor1 * ) in ; <NEW_LINE> vorbis_look_floor1 * look = _ogg_calloc ( 1 , sizeof ( * look ) ) ; <NEW_LINE> int i , j , n = 0 ;
<TAB> if ( ! skb ) <NEW_LINE> <TAB> <TAB> return err ; <NEW_LINE> <START_VULN> <TAB> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <NEW_LINE><TAB> <TAB> msg -> msg_namelen = sizeof ( struct sockaddr_mISDN ) ; <NEW_LINE><TAB> <TAB> maddr = ( struct sockaddr_mISDN * ) msg -> msg_name ; <NEW_LINE> <END_VULN> <TAB> <TAB> maddr -> family = AF_ISDN ; <NEW_LINE> <TAB> <TAB> maddr -> dev = _pms ( sk ) -> dev -> id ; <NEW_LINE> <TAB> <TAB> if ( ( sk -> sk_protocol == ISDN_P_LAPD_TE ) ||
<TAB> size_t mjitDataSize ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> <TAB> bool inOOMReport ; <NEW_LINE> <END_VULN> #if defined ( MOZ_GCTIMER ) || defined ( JSGC_TESTPILOT ) <NEW_LINE> <TAB> struct GCData { <NEW_LINE> <TAB> <TAB> uint64 firstEnter ; <NEW_LINE> <TAB> <TAB> bool firstEnterValid ;
<TAB> if ( likely ( vbr != NULL ) ) { <NEW_LINE> <TAB> <TAB> svbranch = vbr -> value ; <NEW_LINE> <TAB> <TAB> trim ( & svbranch ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> dsize += svbranch . len ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( dsize < 256 ) dsize = 256 ;
<TAB> <TAB> if ( reserve ) { <NEW_LINE> <TAB> <TAB> <TAB> hugetlb_acct_memory ( h , - reserve ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> }
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_AUTHOR ( "Michal Ludvig" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha1 - all" ) ; <NEW_LINE>MODULE_ALIAS ( "sha256 - all" ) ; <NEW_LINE>MODULE_ALIAS ( "sha1 - padlock" ) ; <NEW_LINE>MODULE_ALIAS ( "sha256 - padlock" ) ; <NEW_LINE> <END_VULN>
<TAB> case SO_KEEPALIVE : <NEW_LINE> #ifdef CONFIG_INET <NEW_LINE> <START_VULN> <TAB> <TAB> if ( sk -> sk_protocol == IPPROTO_TCP ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> tcp_set_keepalive ( sk , valbool ) ; <NEW_LINE> #endif <NEW_LINE> <TAB> <TAB> sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ) ;
<TAB> <TAB> <TAB> struct oz_multiple_fixed * body = <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ( struct oz_multiple_fixed * ) data_hdr ; <NEW_LINE> <TAB> <TAB> <TAB> u8 * data = body -> data ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> / body -> unit_size ; <NEW_LINE> <TAB> <TAB> <TAB> while ( n -- ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint ,
<TAB> <TAB> if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0 <NEW_LINE> <START_VULN> <TAB> <TAB> || no_port_forwarding_flag || options . disable_forwarding ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> success = 0 ; <NEW_LINE> <TAB> <TAB> <TAB> packet_send_debug ( "Server has disabled port forwarding . " ) ; <NEW_LINE> <TAB> <TAB> } else {
<TAB> <TAB> <TAB> if ( s -> size - stream_ptr < n_blocks * 4 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return ; <NEW_LINE> <TAB> <TAB> <TAB> while ( n_blocks -- ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> block_ptr = row_ptr + pixel_ptr ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y + + ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> ADVANCE_BLOCK ( ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> break ;
<TAB> n = ( ( * p ) [ 0 ] << 8 ) | ( * p ) [ 1 ] ; <NEW_LINE> <TAB> * p += 2 ; <NEW_LINE> <START_VULN> <TAB> if ( n < 1 || n > 65535 || * p + n > end ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> <TAB> MBEDTLS_SSL_DEBUG_MSG ( 1 , ( "bad client key exchange message" ) ) ; <NEW_LINE> <TAB> <TAB> return ( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE ) ;
err_locked : <NEW_LINE> <TAB> if ( move_group ) <NEW_LINE> <START_VULN> <TAB> <TAB> mutex_unlock ( & gctx -> mutex ) ; <NEW_LINE> <END_VULN> <TAB> mutex_unlock ( & ctx -> mutex ) ; <NEW_LINE> <TAB> fput ( event_file ) ;
<TAB> { <TAB> SFE_BAD_CHUNK_MARKER <TAB> , "Error : Bad chunk marker . " } , <NEW_LINE> <TAB> { <TAB> SFE_BAD_CHUNK_DATA_PTR <TAB> , "Error : Bad data pointer in SF_CHUNK_INFO struct . " } , <NEW_LINE> <TAB> { <TAB> SFE_FILENAME_TOO_LONG <TAB> , "Error : Supplied filename too long . " } , <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> { <TAB> SFE_MAX_ERROR <TAB> <TAB> <TAB> , "Maximum error number . " } , <NEW_LINE> <TAB> { <TAB> SFE_MAX_ERROR + 1 <TAB> <TAB> , NULL }
<TAB> <TAB> <TAB> filetype -> type ) ; <NEW_LINE> <TAB> if ( format ) <NEW_LINE> <START_VULN> <TAB> { <NEW_LINE><TAB> _cupsStrFree ( format -> values [ 0 ] . string . text ) ; <NEW_LINE><NEW_LINE><TAB> format -> values [ 0 ] . string . text = _cupsStrAlloc ( mimetype ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> else <NEW_LINE> <TAB> ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_MIMETYPE , <NEW_LINE> <TAB> "document - format" , NULL , mimetype ) ;
<START_VULN> <TAB> ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ; <NEW_LINE><NEW_LINE><TAB> <NEW_LINE><TAB> usbnet_link_change ( dev , 0 , 0 ) ; <NEW_LINE><TAB> return ret ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void cdc_ncm_align_tail ( struct sk_buff * skb , size_t modulus , size_t remainder , size_t max )
if ( caught_signal ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> sleep ( 2 ) ; <NEW_LINE><TAB> kill ( child , SIGKILL ) ; <NEW_LINE><TAB> fprintf ( stderr , _ ( " . . . killed . \n" ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> *
<TAB> memcpy ( & kvm -> arch . vpit -> pit_state . channels , & ps -> channels , <NEW_LINE> <TAB> sizeof ( kvm -> arch . vpit -> pit_state . channels ) ) ; <NEW_LINE> <TAB> kvm -> arch . vpit -> pit_state . flags = ps -> flags ; <NEW_LINE> <START_VULN> <TAB> kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; <NEW_LINE> <END_VULN> <TAB> mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; <NEW_LINE> <TAB> return 0 ; <NEW_LINE> }
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> time_rec , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> delegated_cred_handle , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & exts ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( major_status == GSS_S_COMPLETE ) { <NEW_LINE><TAB> <TAB> <TAB> * context_handle = ctx -> gssc ; <NEW_LINE><TAB> <TAB> <TAB> ctx -> gssc = NULL ; <NEW_LINE><TAB> <TAB> <TAB> iakerb_release_context ( ctx ) ; <NEW_LINE><TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> <TAB> if ( mech_type != NULL ) <NEW_LINE> <TAB> <TAB> <TAB> * mech_type = ( gss_OID ) gss_mech_krb5 ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> <TAB> void __user * buffer , size_t * lenp , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> loff_t * ppos ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ; <NEW_LINE> <END_VULN> <TAB> if ( ret || ! write ) <NEW_LINE> <TAB> <TAB> return ret ;
<TAB> <TAB> return 1 ; <NEW_LINE> <TAB> case GSI_GET_HWRPB : <NEW_LINE> <START_VULN> <TAB> <TAB> if ( nbytes < sizeof ( * hwrpb ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> <TAB> if ( copy_to_user ( buffer , hwrpb , nbytes ) != 0 ) <NEW_LINE> <TAB> <TAB> <TAB> return - EFAULT ;
<TAB> * pred_rtrn = MATCH_EXACTLY ; <NEW_LINE> <TAB> if ( expr -> expr . op == EXPR_ACTION_DECL ) { <NEW_LINE> <TAB> <TAB> const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> action . name ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> log_err ( info -> ctx , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> "Illegal modifier predicate \" % s\" ; Ignored\n" , pred_txt ) ; <NEW_LINE> <TAB> <TAB> <TAB> return false ;
<TAB> init_cdrom_command ( & cgc , buf , sizeof ( buf ) , CGC_DATA_READ ) ; <NEW_LINE> <TAB> cgc . cmd [ 0 ] = GPCMD_READ_DVD_STRUCTURE ; <NEW_LINE> <TAB> cgc . cmd [ 7 ] = s -> type ; <NEW_LINE> <START_VULN> <TAB> cgc . cmd [ 9 ] = cgc . buflen = 0xff ; <NEW_LINE> <END_VULN> <TAB> if ( ( ret = cdo -> generic_packet ( cdi , & cgc ) ) ) <NEW_LINE> <TAB> <TAB> return ret ;
<TAB> <TAB> goto out ; <NEW_LINE> <TAB> if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) <NEW_LINE> <TAB> <TAB> goto out ; <NEW_LINE> <START_VULN> <TAB> if ( user_alloc && ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> if ( mem -> slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS ) <NEW_LINE> <TAB> <TAB> goto out ;
<TAB> if ( fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { <NEW_LINE> <TAB> <TAB> zend_throw_error ( exception_ce , message ) ; <NEW_LINE> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> zend_error ( E_ERROR , message ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> efree ( message ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> fdbname , fmtId ( dbtablespace ) ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> appendPQExpBuffer ( buf , "\\connect % s\n" , fdbname ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> if ( binary_upgrade )
} <NEW_LINE> int install_process_keyring_to_cred ( struct cred * new ) <NEW_LINE> { <NEW_LINE> <TAB> struct key * keyring ; <NEW_LINE> <TAB> if ( new -> process_keyring ) <NEW_LINE> <START_VULN> <TAB> <TAB> return - EEXIST ; <NEW_LINE> <END_VULN> <TAB> keyring = keyring_alloc ( "_pid" , new -> uid , new -> gid , new , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> KEY_POS_ALL | KEY_USR_VIEW ,
void dvb_usbv2_disconnect ( struct usb_interface * intf ) <NEW_LINE> { <NEW_LINE> <TAB> struct dvb_usb_device * d = usb_get_intfdata ( intf ) ; <NEW_LINE> <START_VULN> <TAB> const char * name = d -> name ; <NEW_LINE><TAB> struct device dev = d -> udev -> dev ; <NEW_LINE> <END_VULN> <TAB> dev_dbg ( & d -> udev -> dev , " % s : bInterfaceNumber = % d\n" , __func__ , <NEW_LINE> <TAB> <TAB> <TAB> intf -> cur_altsetting -> desc . bInterfaceNumber ) ;
<TAB> void removeWrapper ( js : : WrapperMap : : Ptr p ) { <NEW_LINE> <TAB> <TAB> crossCompartmentWrappers . remove ( p ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> struct WrapperEnum : public js : : WrapperMap : : Enum { <NEW_LINE> <TAB> <TAB> WrapperEnum ( JSCompartment * c ) : js : : WrapperMap : : Enum ( c -> crossCompartmentWrappers ) { } <NEW_LINE> <TAB> } ; <NEW_LINE> <START_VULN> <TAB> void mark ( JSTracer * trc ) ; <NEW_LINE> <END_VULN> <TAB> bool isDiscardingJitCode ( JSTracer * trc ) ; <NEW_LINE> <TAB> void sweep ( js : : FreeOp * fop , bool releaseTypes ) ; <NEW_LINE> <TAB> void sweepCrossCompartmentWrappers ( ) ; <NEW_LINE> <TAB> void purge ( ) ; <NEW_LINE> <TAB> void clearTables ( ) ; <NEW_LINE> <TAB> bool hasObjectMetadataCallback ( ) const { return objectMetadataCallback ; } <NEW_LINE> <TAB> void setObjectMetadataCallback ( js : : ObjectMetadataCallback callback ) ;
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> _iov = iov + ret ; <NEW_LINE> <TAB> <TAB> size = reg -> memory_size - addr + reg -> guest_phys_addr ; <NEW_LINE> <START_VULN> <TAB> <TAB> _iov -> iov_len = min ( ( u64 ) len , size ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> _iov -> iov_base = ( void __user * ) ( unsigned long ) <NEW_LINE> <TAB> <TAB> <TAB> ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ; <NEW_LINE> <TAB> <TAB> s += size ;
<TAB> <TAB> <TAB> <TAB> return - ENXIO ; <NEW_LINE> <TAB> <TAB> <TAB> fmt = ( * ( short * ) & event_rec [ 0 ] ) & 0xffff ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( err < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return err ;
<TAB> return ret ; <NEW_LINE> out_release_unlock : <NEW_LINE> <TAB> spin_unlock ( ptl ) ; <NEW_LINE> <START_VULN> out_release_nounlock : <NEW_LINE> <END_VULN> <TAB> if ( vm_shared ) <NEW_LINE> <TAB> <TAB> unlock_page ( page ) ; <NEW_LINE> <TAB> put_page ( page ) ; <NEW_LINE> <TAB> goto out ; <NEW_LINE> }
<START_VULN> <TAB> assert ( n >= 0 && n < 32 ) ; <NEW_LINE> <END_VULN> <TAB> assert ( ! ( v & ( ~ JAS_ONES ( n ) ) ) ) ;
( * JSGCCallback ) ( JSRuntime * rt , JSGCStatus status ) ; <NEW_LINE> typedef enum JSFinalizeStatus { <NEW_LINE> <TAB> JSFINALIZE_START , <NEW_LINE> <TAB> JSFINALIZE_END <NEW_LINE> } JSFinalizeStatus ; <NEW_LINE> typedef void <NEW_LINE> <START_VULN> ( * JSFinalizeCallback ) ( JSFreeOp * fop , JSFinalizeStatus status ) ; <NEW_LINE> <END_VULN> typedef void <NEW_LINE> ( * JSTraceDataOp ) ( JSTracer * trc , void * data ) ;
<TAB> struct pppol2tp_session * ps ; <NEW_LINE> <TAB> if ( level != SOL_PPPOL2TP ) <NEW_LINE> <START_VULN> <TAB> <TAB> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <NEW_LINE> <END_VULN> <TAB> if ( get_user ( len , optlen ) ) <NEW_LINE> <TAB> <TAB> return - EFAULT ;
<TAB> cli_dbgmsg ( "cli_scanxar : can't scan xar files , need libxml2 . \n" ) ; <NEW_LINE> #endif <NEW_LINE> <TAB> if ( cksum_fails + extract_errors != 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> cli_warnmsg ( "cli_scanxar : % u checksum errors and % u extraction errors , use -- debug for more info . \n" , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> cksum_fails , extract_errors ) ; <NEW_LINE> <TAB> }
<TAB> uint32_t * GetImageData ( ) ; <NEW_LINE> <TAB> int32_t GetCompressedImageSize ( ) const ; <NEW_LINE> <TAB> bool HasAlphaData ( ) const ; <NEW_LINE> <START_VULN> <TAB> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> <TAB> virtual void FinishInternal ( ) ; <NEW_LINE> private : <NEW_LINE> <TAB> NS_METHOD CalcBitShift ( ) ;
} <NEW_LINE> bool __net_get_random_once ( void * buf , int nbytes , bool * done , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> struct static_key * done_key ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> static DEFINE_SPINLOCK ( lock ) ; <NEW_LINE> <TAB> unsigned long flags ;
<TAB> memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; <NEW_LINE> <START_VULN> <TAB> len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ; <NEW_LINE><TAB> len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ; <NEW_LINE><TAB> if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ; <NEW_LINE> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> }
<TAB> else <NEW_LINE> <TAB> <TAB> seq_puts ( m , " [ anon ] " ) ; <NEW_LINE> <START_VULN> <TAB> if ( key_is_instantiated ( keyring ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> if ( keyring -> keys . nr_leaves_on_tree != 0 ) <NEW_LINE> <TAB> <TAB> <TAB> seq_printf ( m , " : % lu" , keyring -> keys . nr_leaves_on_tree ) ; <NEW_LINE> <TAB> <TAB> else
<TAB> UTF16_BIG_ENDIAN <NEW_LINE> } ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> extern int register_nls ( struct nls_table * ) ; <NEW_LINE> extern int unregister_nls ( struct nls_table * ) ; <NEW_LINE> extern struct nls_table * load_nls ( char * ) ;
<TAB> <TAB> <TAB> . data <TAB> <TAB> = & ipv6_devconf . mtu6 , <NEW_LINE> <TAB> <TAB> <TAB> . maxlen <TAB> <TAB> = sizeof ( int ) , <NEW_LINE> <TAB> <TAB> <TAB> . mode <TAB> <TAB> = 0644 , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> . proc_handler <TAB> = proc_dointvec , <NEW_LINE> <END_VULN> <TAB> <TAB> } , <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> . procname <TAB> = "accept_ra" ,
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "DES & Triple DES EDE Cipher Algorithms , sparc64 des opcode accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "des" ) ; <NEW_LINE> <END_VULN> #include "crop_devid . c"
<TAB> <TAB> if ( FAILURE == phar_copy_entry_fp ( oldentry , & newentry , & error TSRMLS_CC ) ) { <NEW_LINE> <TAB> <TAB> <TAB> efree ( newentry . filename ) ; <NEW_LINE> <TAB> <TAB> <TAB> php_stream_close ( newentry . fp ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> <TAB> return ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> status = PTR_ERR ( cred ) ; <NEW_LINE> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> state = nfs4_do_open ( dir , & path , flags , sattr , cred ) ; <NEW_LINE> <END_VULN> <TAB> d_drop ( dentry ) ; <NEW_LINE> <TAB> if ( IS_ERR ( state ) ) { <NEW_LINE> <TAB> <TAB> status = PTR_ERR ( state ) ;
<TAB> <TAB> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; <NEW_LINE> <TAB> <TAB> fl6 . flowi6_proto = IPPROTO_TCP ; <NEW_LINE> <TAB> <TAB> fl6 . daddr = ireq -> ir_v6_rmt_addr ; <NEW_LINE> <START_VULN> <TAB> <TAB> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> fl6 . saddr = ireq -> ir_v6_loc_addr ; <NEW_LINE> <TAB> <TAB> fl6 . flowi6_oif = sk -> sk_bound_dev_if ; <NEW_LINE> <TAB> <TAB> fl6 . flowi6_mark = ireq -> ir_mark ;
<TAB> <TAB> return parse_uid_node ( object , size ) ; <NEW_LINE> <TAB> case BPLIST_DICT : <NEW_LINE> <START_VULN> <TAB> <TAB> if ( * object + size > bplist -> offset_table ) { <NEW_LINE><TAB> <TAB> <TAB> PLIST_BIN_ERR ( " % s : BPLIST_REAL data bytes point outside of valid range\n" , __func__ ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> return parse_dict_node ( bplist , object , size ) ;
<START_VULN> struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct key * keyring ; <NEW_LINE> <TAB> int bucket ;
<TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> if ( copy_from_user ( & ( ( char * ) & ins ) [ offs ] , addr + offs , sizeof ( ins ) - offs ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - EFAULT ; <NEW_LINE> <TAB> if ( ins . channel < 0 || ins . channel >= SBFM_MAXINSTR )
#include "prprf . h" <NEW_LINE> int main ( ) <NEW_LINE> { <NEW_LINE> <TAB> double pi = 3 . 1415926 ; <NEW_LINE> <TAB> double e = 2 . 71828 ; <NEW_LINE> <TAB> double root2 = 1 . 414 ; <NEW_LINE> <START_VULN> <TAB> double nan = 0 . 0 / 0 . 0 ; <NEW_LINE> <END_VULN> <TAB> PR_fprintf ( PR_STDOUT , "pi is % f . \n" , pi ) ; <NEW_LINE> <TAB> PR_fprintf ( PR_STDOUT , "e is % f . \n" , e ) ; <NEW_LINE> <TAB> PR_fprintf ( PR_STDOUT , "The square root of 2 is % f . \n" , root2 ) ; <NEW_LINE> <TAB> PR_fprintf ( PR_STDOUT , "NaN is % f . \n" , nan ) ; <NEW_LINE> <TAB> PR_fprintf ( PR_STDOUT , "pi is % 301f . \n" , pi ) ; <NEW_LINE> <TAB> PR_fprintf ( PR_STDOUT , "e is % 65416 . 123f . \n" , e ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : maintain the info structure , info < -> header packets <NEW_LINE> <START_VULN> last mod : $ Id : info . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h >
<TAB> <TAB> <TAB> const char * last ; <TAB> <NEW_LINE> <TAB> <TAB> <TAB> const char * buf ; <TAB> <NEW_LINE> <TAB> <TAB> <TAB> const char * end ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> size_t lines , linecnt , bytecnt ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( s == NULL ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ms -> search . s_len = 0 ;
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> efree ( match_sets ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> efree ( offsets ) ; <NEW_LINE> <TAB> efree ( subpat_names ) ;
<TAB> <TAB> if ( ! strchr ( nm , ' . ' ) ) { <NEW_LINE> <TAB> <TAB> <TAB> if ( ( sscanf ( nm , " % 30d" , & x ) == 1 ) && ( x >= 0 ) && ( x <= 32 ) ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> ha -> netmask . s_addr = htonl ( 0xFFFFFFFF << ( 32 - x ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> else { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ast_log ( LOG_WARNING , "Invalid CIDR in % s\n" , stuff ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ast_free ( ha ) ;
<TAB> <TAB> exit ( 1 ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> for ( i = 0 ; i < TESTSIZE ; i + + ) <NEW_LINE> <TAB> if ( fabs ( qv [ i ] - iv [ i ] ) > . 000001 ) { <NEW_LINE> <TAB> <TAB> fprintf ( stderr , "read ( % g ) != written ( % g ) at position ( % ld ) \n" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> iv [ i ] , qv [ i ] , i ) ; <NEW_LINE> <TAB> <TAB> exit ( 1 ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> fprintf ( stderr , "OK\n" ) ; <NEW_LINE> <TAB> ptr + + ; <NEW_LINE> } <NEW_LINE> exit ( 0 ) ; <NEW_LINE> }
#include < stdlib . h > <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < string . h > <NEW_LINE> <START_VULN> #include "compiler / debug . h" <NEW_LINE> <END_VULN> #include "compiler / preprocessor / slglobals . h" <NEW_LINE> #undef malloc <NEW_LINE> #undef realloc <NEW_LINE> #undef free
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Camellia Cipher Algorithm , asm optimized" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "camellia" ) ; <NEW_LINE>MODULE_ALIAS ( "camellia - asm" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> return KADM5_BAD_MASK ; <NEW_LINE> <TAB> if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) <NEW_LINE> <TAB> <TAB> return KADM5_BAD_MASK ; <NEW_LINE> <TAB> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <NEW_LINE> <TAB> <TAB> return KADM5_BAD_MASK ; <NEW_LINE> <TAB> if ( ( mask & ~ ALL_PRINC_MASK ) ) <NEW_LINE> <TAB> <TAB> return KADM5_BAD_MASK ; <NEW_LINE> <START_VULN> <TAB> if ( entry == NULL ) <NEW_LINE><TAB> <TAB> return EINVAL ; <END_VULN>
<START_VULN> <TAB> stride = ( ps -> exceptions_per_area + 1 ) ; <NEW_LINE><TAB> next_free = + + ps -> next_free ; <NEW_LINE><TAB> if ( sector_div ( next_free , stride ) == 1 ) <NEW_LINE><TAB> <TAB> ps -> next_free + + ; <NEW_LINE> <END_VULN> <TAB> atomic_inc ( & ps -> pending_count ) ; <NEW_LINE> <TAB> return 0 ;
<TAB> PRArenaPool * poolp ; <NEW_LINE> <TAB> poolp = PORT_NewArena ( CRMF_DEFAULT_ARENA_SIZE ) ; <NEW_LINE> <TAB> if ( poolp == NULL ) { <NEW_LINE> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> newReqMsg = PORT_ArenaZNew ( poolp , CRMFCertReqMsg ) ; <NEW_LINE> <TAB> if ( newReqMsg == NULL ) { <NEW_LINE> <START_VULN> <TAB> <TAB> goto loser ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> newReqMsg -> poolp = poolp ; <NEW_LINE> <TAB> newReqMsg -> certReq = crmf_copy_cert_request ( poolp , srcReqMsg -> certReq ) ; <NEW_LINE> <TAB> if ( newReqMsg -> certReq == NULL ) { <NEW_LINE> <TAB> <TAB> goto loser ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> newReqMsg -> pop = crmf_copy_pop ( poolp , srcReqMsg -> pop ) ;
<TAB> <TAB> <TAB> <TAB> insn -> code , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> insn -> src_reg , insn -> imm ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> } else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) { <NEW_LINE><TAB> <TAB> <TAB> verbose ( " ( % 02x ) r % d = 0x % x\n" , <NEW_LINE><TAB> <TAB> <TAB> <TAB> insn -> code , insn -> dst_reg , insn -> imm ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> verbose ( "BUG_ld_ % 02x\n" , insn -> code ) ; <NEW_LINE> <TAB> <TAB> <TAB> return ;
<TAB> <TAB> return error ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN> <TAB> srcreg = ( opcode >> 4 ) & 0x3f ; <NEW_LINE> <TAB> if ( user_mode ( regs ) ) {
virtual bool UndoScope ( ) MOZ_OVERRIDE ; <NEW_LINE> virtual void SetUndoScope ( bool aUndoScope , mozilla : : ErrorResult & aError ) MOZ_OVERRIDE ; <NEW_LINE> nsresult ClearDataset ( ) ; <NEW_LINE> <START_VULN> nsSize GetWidthHeightForImage ( imgIRequest * aImageRequest ) ; <NEW_LINE> <END_VULN> NS_FORWARD_NSIDOMNODE_TO_NSINODE <NEW_LINE> NS_FORWARD_NSIDOMELEMENT_TO_GENERIC <NEW_LINE> NS_IMETHOD GetId ( nsAString & aId ) MOZ_FINAL { <NEW_LINE> <TAB> mozilla : : dom : : Element : : GetId ( aId ) ;
<TAB> } <NEW_LINE> <TAB> extra -> match_limit = PCRE_G ( backtrack_limit ) ; <NEW_LINE> <TAB> extra -> match_limit_recursion = PCRE_G ( recursion_limit ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> array_init ( return_value ) ;
<TAB> <TAB> if ( ! ( opt -> opt_nflen|opt -> opt_flen ) ) <NEW_LINE> <TAB> <TAB> <TAB> opt = NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ! opt ) <NEW_LINE><TAB> <TAB> opt = np -> opt ; <NEW_LINE> <END_VULN> <TAB> if ( flowlabel ) <NEW_LINE> <TAB> <TAB> opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; <NEW_LINE> <TAB> opt = ipv6_fixup_options ( & opt_space , opt ) ;
<TAB> sdb_num_set ( sdb , "link" , shdr -> sh_link , 0 ) ; <NEW_LINE> <TAB> sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; <NEW_LINE> <START_VULN> <TAB> for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; + + cnt ) { <NEW_LINE> <END_VULN> <TAB> <TAB> Sdb * sdb_verdef = sdb_new0 ( ) ; <NEW_LINE> <TAB> <TAB> char * vstart = ( ( char * ) defs ) + i ; <NEW_LINE> <TAB> <TAB> char key [ 32 ] = { 0 } ;
<TAB> frame -> width = w ; <NEW_LINE> <TAB> frame -> height = h ; <NEW_LINE> <START_VULN> <TAB> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> int hsub = s -> draw . hsub [ plane ] ; <NEW_LINE> <TAB> <TAB> int vsub = s -> draw . vsub [ plane ] ; <NEW_LINE> <TAB> <TAB> frame -> data [ plane ] += ( s -> x >> hsub ) * s -> draw . pixelstep [ plane ] +
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : residue backend 0 , 1 and 2 implementation <NEW_LINE> <START_VULN> last mod : $ Id : res0 . c 16327 2009 - 07 - 24 00 : 49 : 25Z xiphmont $ <NEW_LINE> <END_VULN>
<TAB> <TAB> goto error ; <NEW_LINE> <TAB> if ( IPV4_GET_IPTTL ( p ) != ttl ) <NEW_LINE> <TAB> <TAB> goto error ; <NEW_LINE> <START_VULN> <TAB> if ( IPV4_GET_IPPROTO ( p ) != IPPROTO_ICMP ) <NEW_LINE> <END_VULN> <TAB> <TAB> goto error ; <NEW_LINE> <TAB> return p ;
<TAB> fl6 . fl6_dport = usin -> sin6_port ; <NEW_LINE> <TAB> fl6 . fl6_sport = inet -> inet_sport ; <NEW_LINE> <START_VULN> <TAB> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <NEW_LINE> <END_VULN> <TAB> security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;
return mar_fpopen ( fp ) ; <NEW_LINE> } <NEW_LINE> #ifdef XP_WIN <NEW_LINE> MarFile * mar_wopen ( const wchar_t * path ) { <NEW_LINE> FILE * fp ; <NEW_LINE> <START_VULN> fp = _wfopen ( path , L"rb" ) ; <NEW_LINE> <END_VULN> if ( ! fp ) <NEW_LINE> <TAB> return NULL ; <NEW_LINE> return mar_fpopen ( fp ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> void mar_close ( MarFile * mar ) {
<TAB> { <NEW_LINE> <TAB> <TAB> MsgToEventLog ( M_SYSERR , TEXT ( "malloc failed" ) ) ; <NEW_LINE> <TAB> <TAB> ReturnLastError ( pipe , L"malloc" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> goto out ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> read = ReadPipeAsync ( pipe , data , bytes , 1 , & exit_event ) ;
<TAB> case ACL_TYPE_ACCESS : <NEW_LINE> <TAB> <TAB> xprefix = JFFS2_XPREFIX_ACL_ACCESS ; <NEW_LINE> <TAB> <TAB> if ( acl ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> umode_t mode = inode -> i_mode ; <NEW_LINE><TAB> <TAB> <TAB> rc = posix_acl_equiv_mode ( acl , & mode ) ; <NEW_LINE><TAB> <TAB> <TAB> if ( rc < 0 ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> return rc ; <NEW_LINE> <TAB> <TAB> <TAB> if ( inode -> i_mode != mode ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> struct iattr attr ;
<TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> cupsdSetString ( & attr -> values [ 0 ] . string . text , Classification ) ; <NEW_LINE> <END_VULN> <TAB> cupsdLogJob ( job , CUPSD_LOG_NOTICE , "CLASSIFICATION FORCED " <NEW_LINE> <TAB> <TAB> <TAB> "job - sheets = \" % s , none\" , "
<TAB> <TAB> <TAB> conn -> current_result = NULL ; <NEW_LINE> <TAB> <TAB> } while ( 0 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> conn -> m -> local_tx_end ( conn , this_func , result == NULL ? FAIL : PASS TSRMLS_CC ) ; <TAB> <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> DBG_RETURN ( result ) ; <NEW_LINE> }
<TAB> <TAB> if ( ( edges & 8 ) && \ <NEW_LINE> <TAB> <TAB> <TAB> s -> mb_y == ( ( s -> mb_height >> v -> field_mode ) - 1 ) ) \ <NEW_LINE> <TAB> <TAB> <TAB> mquant = - v -> altpq ; \ <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! mquant || mquant > 31 ) { \ <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> av_log ( v -> s . avctx , AV_LOG_ERROR , \ <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> "Overriding invalid mquant % d\n" , mquant ) ; \ <NEW_LINE> <TAB> <TAB> <TAB> mquant = 1 ; \
<TAB> <TAB> <TAB> goto out_unlock_free ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> ss_add ( msq , & s ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> ipc_rcu_getref ( msq ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> msg_unlock ( msq ) ; <NEW_LINE> <TAB> <TAB> schedule ( ) ;
<TAB> <TAB> <TAB> <TAB> const wbxml_decoding * map ) <NEW_LINE> { <NEW_LINE> <TAB> guint32 tvb_len = tvb_reported_length ( tvb ) ; <NEW_LINE> <START_VULN> <TAB> guint32 off = offset ; <NEW_LINE> <END_VULN> <TAB> guint32 len ; <NEW_LINE> <TAB> guint str_len ; <NEW_LINE> <TAB> guint32 ent ;
<TAB> int badop = 0 , bugs = 0 ; <NEW_LINE> <TAB> int ret = 1 ; <NEW_LINE> <TAB> int off = 0 ; <NEW_LINE> <START_VULN> <TAB> int no_tmp_rsa = 0 , nocert = 0 ; <NEW_LINE> <END_VULN> <TAB> int state = 0 ; <NEW_LINE> <TAB> SSL_METHOD * meth = NULL ; <NEW_LINE> #ifndef NO_DH
<TAB> if ( context && php_stream_context_get_option ( context , "http" , "header" , & tmpzval ) == SUCCESS ) { <NEW_LINE> <TAB> <TAB> tmp = NULL ; <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { <NEW_LINE> <TAB> <TAB> <TAB> HashPosition pos ; <NEW_LINE> <TAB> <TAB> <TAB> zval ** tmpheader = NULL ;
<TAB> wmem_tree_t * transactions ; <NEW_LINE> <TAB> usb_trans_info_t * usb_trans_info ; <NEW_LINE> <START_VULN> <TAB> void * class_data ; <TAB> <NEW_LINE> <END_VULN> <TAB> wmem_array_t * alt_settings ; <NEW_LINE> } ;
<TAB> return SECFailure ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return SECSuccess ; <NEW_LINE> } <NEW_LINE> static SECStatus <NEW_LINE> ValidateCert ( CERTCertDBHandle * handle , char * name , char * date , <NEW_LINE> <START_VULN> <TAB> char * certUsage , PRBool checkSig , PRBool logit , secuPWData * pwdata ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> SECStatus rv ; <NEW_LINE> <TAB> CERTCertificate * cert = NULL ; <NEW_LINE> <TAB> int64 timeBoundary ; <NEW_LINE> <TAB> SECCertificateUsage usage ; <NEW_LINE> <TAB> CERTVerifyLog reallog ; <NEW_LINE> <TAB> CERTVerifyLog * log = NULL ;
<TAB> ret = buf [ 1 ] ; <NEW_LINE> exit : <NEW_LINE> <START_VULN> <TAB> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <NEW_LINE> <END_VULN> <TAB> return ret ; <NEW_LINE> }
<TAB> struct inode * inode = d_inode ( dentry ) ; <NEW_LINE> <TAB> struct buffer_head * bh = NULL ; <NEW_LINE> <TAB> int error ; <NEW_LINE> <START_VULN> <TAB> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <NEW_LINE> <END_VULN> <TAB> ea_idebug ( inode , "buffer = % p , buffer_size = % ld" , <NEW_LINE> <TAB> <TAB> buffer , ( long ) buffer_size ) ;
<TAB> crm_send_remote_msg ( connection -> session , login , connection -> encrypted ) ; <NEW_LINE> <TAB> free_xml ( login ) ; <NEW_LINE> <START_VULN> <TAB> answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ; <NEW_LINE> <END_VULN> <TAB> crm_log_xml_trace ( answer , "Reply" ) ; <NEW_LINE> <TAB> if ( answer == NULL ) { <NEW_LINE> <TAB> <TAB> rc = - EPROTO ;
static void CVE_2011_2536_transmit_fake_auth_response ( struct sip_pvt * p , int sipmethod , struct sip_request * req , enum xmittype reliable ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> const char * response = "407 Proxy Authentication Required" ; <NEW_LINE><TAB> const char * reqheader = "Proxy - Authorization" ; <NEW_LINE><TAB> const char * respheader = "Proxy - Authenticate" ; <NEW_LINE> <END_VULN> <TAB> const char * authtoken ; <NEW_LINE> <TAB> struct ast_str * buf ; <NEW_LINE> <TAB> char * c ;
#ifndef _V_LOOKUP_H_ <NEW_LINE> #ifdef FLOAT_LOOKUP <NEW_LINE> extern float vorbis_coslook ( float a ) ; <NEW_LINE> extern float vorbis_invsqlook ( float a ) ; <NEW_LINE> extern float vorbis_invsq2explook ( int a ) ; <NEW_LINE> extern float vorbis_fromdBlook ( float a ) ; <NEW_LINE> #endif <NEW_LINE> #ifdef INT_LOOKUP <NEW_LINE> extern long vorbis_invsqlook_i ( long a , long e ) ; <NEW_LINE> extern long vorbis_coslook_i ( long a ) ; <NEW_LINE> extern float vorbis_fromdBlook_i ( long a ) ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #endif
bool IsPaused ( ) ; <NEW_LINE> int GetRate ( ) { return mOutRate ; } <NEW_LINE> int GetChannels ( ) { return mChannels ; } <NEW_LINE> int GetOutChannels ( ) { return mOutChannels ; } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE>nsresult EnsureTimeStretcherInitialized ( ) ; <NEW_LINE> <END_VULN> nsresult SetPlaybackRate ( double aPlaybackRate ) ; <NEW_LINE> nsresult SetPreservesPitch ( bool aPreservesPitch ) ; <NEW_LINE> private : <NEW_LINE> static void PrefChanged ( const char * aPref , void * aClosure ) ; <NEW_LINE> static double GetVolumeScale ( ) ; <NEW_LINE> static cubeb * GetCubebContext ( ) ; <NEW_LINE> static cubeb * GetCubebContextUnlocked ( ) ; <NEW_LINE> static uint32_t GetCubebLatency ( ) ; <NEW_LINE> static bool CubebLatencyPrefSet ( ) ;
} ; <NEW_LINE> static const struct gprefix pfx_0f_ae_7 = { <NEW_LINE> <START_VULN> <TAB> I ( 0 , em_clflush ) , N , N , N , <NEW_LINE> <END_VULN> } ; <NEW_LINE> static const struct group_dual group15 = { {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : toplevel libogg include <NEW_LINE> <START_VULN> last mod : $ Id : ogg . h 16051 2009 - 05 - 27 05 : 00 : 06Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _OGG_H <NEW_LINE> #define _OGG_H <NEW_LINE> #ifdef __cplusplus <NEW_LINE> extern "C" { <NEW_LINE> #endif
static struct kmem_cache * user_ns_cachep __read_mostly ; <NEW_LINE> <START_VULN> static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> struct uid_gid_map * map ) ; <NEW_LINE> static void set_cred_user_ns ( struct cred * cred , struct user_namespace * user_ns )
<TAB> <TAB> int i ; <NEW_LINE> <TAB> <TAB> out = in ; <NEW_LINE> <START_VULN> <TAB> <TAB> for ( i = 0 ; i < 4 && out -> data [ i ] ; i + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> int hsub = s -> draw . hsub [ i ] ; <NEW_LINE> <TAB> <TAB> <TAB> int vsub = s -> draw . vsub [ i ] ; <NEW_LINE> <TAB> <TAB> <TAB> out -> data [ i ] -= ( s -> x >> hsub ) * s -> draw . pixelstep [ i ] +
<START_VULN> mp_err <NEW_LINE> <END_VULN> ec_GFp_pt_dbl_jm ( const mp_int * px , const mp_int * py , const mp_int * pz , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> const mp_int * paz4 , mp_int * rx , mp_int * ry , mp_int * rz , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> mp_int * raz4 , mp_int scratch [ ] , const ECGroup * group ) <NEW_LINE> { <NEW_LINE> <TAB> mp_err res = MP_OKAY ; <NEW_LINE> <TAB> mp_int * t0 , * t1 , * M , * S ; <NEW_LINE> <TAB> t0 = & scratch [ 0 ] ;
<TAB> for ( i = 0 ; i < vi -> channels ; i + + ) { <NEW_LINE> <TAB> <TAB> int submap = info -> chmuxlist [ i ] ; <NEW_LINE> <TAB> <TAB> float * mdct = gmdct [ i ] ; <NEW_LINE> <TAB> <TAB> float * res = vb -> pcm [ i ] ; <NEW_LINE> <TAB> <TAB> int * ilogmask = ilogmaskch [ i ] = <NEW_LINE> <TAB> <TAB> _vorbis_block_alloc ( vb , n / 2 * sizeof ( ** gmdct ) ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> nonzero [ i ] = floor1_encode ( opb , vb , b -> flr [ info -> floorsubmap [ submap ] ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> floor_posts [ i ] [ k ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ilogmask ) ; <NEW_LINE> #if 0 <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> char buf [ 80 ] ; <NEW_LINE> <TAB> <TAB> sprintf ( buf , "maskI % c % d" , i ? 'R' : 'L' , k ) ; <NEW_LINE> <TAB> <TAB> float work [ n / 2 ] ;
<TAB> pch -> ppp = NULL ; <NEW_LINE> <TAB> pch -> chan = chan ; <NEW_LINE> <START_VULN> <TAB> pch -> chan_net = net ; <NEW_LINE> <END_VULN> <TAB> chan -> ppp = pch ; <NEW_LINE> <TAB> init_ppp_file ( & pch -> file , CHANNEL ) ; <NEW_LINE> <TAB> pch -> file . hdrlen = chan -> hdrlen ;
cleanup : <NEW_LINE> <TAB> if ( ce ) <NEW_LINE> <START_VULN> <TAB> <TAB> mb_cache_entry_release ( ce ) ; <NEW_LINE> <END_VULN> <TAB> brelse ( new_bh ) ; <NEW_LINE> <TAB> if ( ! ( bs -> bh && s -> base == bs -> bh -> b_data ) ) <NEW_LINE> <TAB> <TAB> kfree ( s -> base ) ;
static int em_ret ( struct x86_emulate_ctxt * ctxt ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> ctxt -> dst . type = OP_REG ; <NEW_LINE><TAB> ctxt -> dst . addr . reg = & ctxt -> _eip ; <NEW_LINE><TAB> ctxt -> dst . bytes = ctxt -> op_bytes ; <NEW_LINE><TAB> return em_pop ( ctxt ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int em_ret_far ( struct x86_emulate_ctxt * ctxt )
MODULE_DESCRIPTION ( "Cast6 Cipher Algorithm , AVX optimized" ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "cast6" ) ; <NEW_LINE> <END_VULN>
if ( ! my_login ( aTHX_ dbh , imp_dbh ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , <NEW_LINE><TAB> <TAB> <TAB> mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; <NEW_LINE> <END_VULN> <TAB> return FALSE ; <NEW_LINE> }
<TAB> void initPrepareCall ( MDefinition * start ) { <NEW_LINE> <TAB> <TAB> JS_ASSERT ( start -> isPrepareCall ( ) ) ; <NEW_LINE> <TAB> <TAB> return initOperand ( PrepareCallOperandIndex , start ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void initFunction ( MDefinition * func ) { <NEW_LINE> <TAB> <TAB> JS_ASSERT ( ! func -> isPassArg ( ) ) ; <NEW_LINE> <TAB> <TAB> return initOperand ( FunctionOperandIndex , func ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> MDefinition * getFunction ( ) const { <NEW_LINE> <TAB> <TAB> return getOperand ( FunctionOperandIndex ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void replaceFunction ( MInstruction * newfunc ) { <NEW_LINE> <TAB> <TAB> replaceOperand ( FunctionOperandIndex , newfunc ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void addArg ( size_t argnum , MPassArg * arg ) ;
<TAB> typename CalcOps : : result_type lhs = ComputeCalc ( arr -> Item ( 0 ) , aOps ) ; <NEW_LINE> <TAB> float rhs = aOps . ComputeNumber ( arr -> Item ( 1 ) ) ; <NEW_LINE> <TAB> return aOps . MergeMultiplicativeR ( CalcOps : : GetUnit ( aValue ) , lhs , rhs ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> case eCSSUnit_Calc_Minimum : <NEW_LINE> <TAB> case eCSSUnit_Calc_Maximum : { <NEW_LINE> <TAB> typename CalcOps : : input_array_type * arr = aValue . GetArrayValue ( ) ; <NEW_LINE> <TAB> typename CalcOps : : result_type result = ComputeCalc ( arr -> Item ( 0 ) , aOps ) ; <NEW_LINE> <START_VULN> <TAB> for ( PRUint32 i = 1 , i_end = arr -> Count ( ) ; i < i_end ; + + i ) { <NEW_LINE> <END_VULN> <TAB> <TAB> typename CalcOps : : result_type tmp = ComputeCalc ( arr -> Item ( i ) , aOps ) ; <NEW_LINE> <TAB> <TAB> result = aOps . MergeAdditive ( CalcOps : : GetUnit ( aValue ) , result , tmp ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return result ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> default : { <NEW_LINE> <TAB> return aOps . ComputeLeafValue ( aValue ) ; <NEW_LINE> <TAB> }
<TAB> stat = yajl_parse_complete ( hand ) ; <NEW_LINE> <TAB> if ( stat != yajl_status_ok && <NEW_LINE> <START_VULN> <TAB> stat != yajl_status_insufficient_data ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> <TAB> unsigned char * str = yajl_get_error ( hand , 1 , data , dataSize ) ; <NEW_LINE> <TAB> <TAB> fprintf ( stderr , ( const char * ) str ) ;
<TAB> } else if ( data [ 0 ] == WHITEHEAT_EVENT ) { <NEW_LINE> <TAB> <TAB> dev_dbg ( & urb -> dev -> dev , " % s - event received\n" , __func__ ) ; <NEW_LINE> <START_VULN> <TAB> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <NEW_LINE> <END_VULN> <TAB> <TAB> memcpy ( command_info -> result_buffer , & data [ 1 ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> urb -> actual_length - 1 ) ; <NEW_LINE> <TAB> <TAB> command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;
<TAB> <TAB> <TAB> fprintf ( fdest , " % c" , ( OPJ_UINT8 ) r ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ( i + 1 ) % w == 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> for ( ( pad = w % 4 ) ? ( 4 - w % 4 ) : 0 ; pad > 0 ; pad -- ) <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> fprintf ( fdest , " % c" , 0 ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> }
<TAB> return bdev ; <NEW_LINE> fail : <NEW_LINE> <START_VULN> <TAB> ext3_msg ( sb , "error : failed to open journal device % s : % ld" , <NEW_LINE> <END_VULN> <TAB> <TAB> __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ; <NEW_LINE> <TAB> return NULL ;
<TAB> else <NEW_LINE> <TAB> <TAB> h -> is_streamed = 1 ; <NEW_LINE> <START_VULN> <TAB> s -> filesize = - 1 ; <NEW_LINE> <END_VULN> <TAB> s -> location = av_strdup ( uri ) ; <NEW_LINE> <TAB> if ( ! s -> location ) <NEW_LINE> <TAB> <TAB> return AVERROR ( ENOMEM ) ;
<TAB> plgctx = pkinit_find_realm_context ( context , moddata , request -> server ) ; <NEW_LINE> <TAB> if ( plgctx == NULL ) { <NEW_LINE> <START_VULN> <TAB> <TAB> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return ; <NEW_LINE> <TAB> }
<TAB> . open = ftrace_filter_open , <NEW_LINE> <TAB> . read = seq_read , <NEW_LINE> <TAB> . write = ftrace_filter_write , <NEW_LINE> <START_VULN> <TAB> . llseek = ftrace_regex_lseek , <NEW_LINE> <END_VULN> <TAB> . release = ftrace_regex_release , <NEW_LINE> } ;
<TAB> bool isVector ( ) const { return size > 1 && ! matrix ; } <NEW_LINE> <TAB> bool isScalar ( ) const { return size == 1 && ! matrix && ! structure ; } <NEW_LINE> <TAB> TTypeList * getStruct ( ) const { return structure ; } <NEW_LINE> <TAB> void setStruct ( TTypeList * s ) { structure = s ; computeDeepestStructNesting ( ) ; } <NEW_LINE> <TAB> const TString & getTypeName ( ) const <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> assert ( typeName ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return * typeName ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void setTypeName ( const TString & n ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> typeName = NewPoolTString ( n . c_str ( ) ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> bool isField ( ) const { return fieldName != 0 ; }
<TAB> <TAB> ret = get_user_pages_fast ( uaddr , local_nr_pages , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ( iter -> type & WRITE ) != WRITE , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> & pages [ cur_page ] ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ret < local_nr_pages ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ret = - EFAULT ; <NEW_LINE> <TAB> <TAB> <TAB> goto out_unmap ; <NEW_LINE> <TAB> <TAB> }
<TAB> if ( IsAnimValList ( ) ) { <NEW_LINE> <TAB> Element ( ) -> FlushAnimations ( ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return LengthNoFlush ( ) ; <NEW_LINE> } <NEW_LINE> void Clear ( ErrorResult & error ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGNumber > Initialize ( nsIDOMSVGNumber * newItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> <START_VULN> nsIDOMSVGNumber * GetItem ( uint32_t index , ErrorResult & error ) <NEW_LINE> { <NEW_LINE><TAB> bool found ; <NEW_LINE><TAB> nsIDOMSVGNumber * item = IndexedGetter ( index , found , error ) ; <NEW_LINE><TAB> if ( ! found ) { <NEW_LINE><TAB> error . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; <NEW_LINE><TAB> } <NEW_LINE><TAB> return item ; <NEW_LINE> } <NEW_LINE>nsIDOMSVGNumber * IndexedGetter ( uint32_t index , bool & found , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> <END_VULN> already_AddRefed < nsIDOMSVGNumber > InsertItemBefore ( nsIDOMSVGNumber * newItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t index , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGNumber > ReplaceItem ( nsIDOMSVGNumber * newItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t index , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGNumber > RemoveItem ( uint32_t index , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ;
print_res_top ( result ) ; <NEW_LINE> if ( opt_show_keys ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> end = strmov ( strmov ( strmov ( query , "show keys from `" ) , table ) , "`" ) ; <NEW_LINE> <END_VULN> <TAB> if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> fprintf ( stderr , " % s : Cannot list keys in db : % s , table : % s : % s\n" ,
static int proc_connectinfo ( struct usb_dev_state * ps , void __user * arg ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> struct usbdevfs_connectinfo ci = { <NEW_LINE><TAB> <TAB> . devnum = ps -> dev -> devnum , <NEW_LINE><TAB> <TAB> . slow = ps -> dev -> speed == USB_SPEED_LOW <NEW_LINE><TAB> } ; <NEW_LINE> <END_VULN> <TAB> if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) <NEW_LINE> <TAB> <TAB> return - EFAULT ;
<TAB> ret = - EPERM ; <NEW_LINE> <START_VULN> <TAB> if ( ! new_idmap_permitted ( ns , cap_setid , & new_map ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> goto out ;
<TAB> bool new_is_dir = false ; <NEW_LINE> <TAB> unsigned max_links = new_dir -> i_sb -> s_max_links ; <NEW_LINE> <START_VULN> <TAB> if ( source == target ) <NEW_LINE> <END_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> error = may_delete ( old_dir , old_dentry , is_dir ) ;
<TAB> if ( index_key -> type == & key_type_keyring ) <NEW_LINE> <TAB> <TAB> up_write ( & keyring_serialise_link_sem ) ; <NEW_LINE> <START_VULN> <TAB> if ( edit && ! edit -> dead_leaf ) { <NEW_LINE><TAB> <TAB> key_payload_reserve ( keyring , <NEW_LINE><TAB> <TAB> <TAB> <TAB> keyring -> datalen - KEYQUOTA_LINK_BYTES ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> assoc_array_cancel_edit ( edit ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> up_write ( & keyring -> sem ) ;
<TAB> <TAB> the match again at the same point . If this fails ( picked up above ) we <NEW_LINE> <TAB> <TAB> advance to the next character . * / <NEW_LINE> <TAB> <TAB> g_notempty = ( offsets [ 1 ] == offsets [ 0 ] ) ? PCRE_NOTEMPTY | PCRE_ANCHORED : 0 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> start_offset = offsets [ 1 ] ; <NEW_LINE> <TAB> }
<TAB> void ErrorInvalidEnumInfo ( const char * info , WebGLenum enumvalue ) { <NEW_LINE> <TAB> <TAB> return ErrorInvalidEnum ( " % s : invalid enum value 0x % x" , info , enumvalue ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void ErrorOutOfMemory ( const char * fmt = 0 , . . . ) ; <NEW_LINE> <TAB> const char * ErrorName ( GLenum error ) ; <NEW_LINE> <TAB> bool IsTextureFormatCompressed ( GLenum format ) ; <NEW_LINE> <START_VULN> <TAB> void DummyFramebufferOperation ( const char * info ) ; <NEW_LINE> <END_VULN> <TAB> WebGLTexture * activeBoundTextureForTarget ( WebGLenum target ) { <NEW_LINE> <TAB> <TAB> return target == LOCAL_GL_TEXTURE_2D ? mBound2DTextures [ mActiveTexture ] <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> : mBoundCubeMapTextures [ mActiveTexture ] ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> already_AddRefed < CanvasLayer > GetCanvasLayer ( nsDisplayListBuilder * aBuilder , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> CanvasLayer * aOldLayer ,
<TAB> void * regs ; <NEW_LINE> <TAB> gpa_t vapic_addr ; <NEW_LINE> <START_VULN> <TAB> struct page * vapic_page ; <NEW_LINE> <END_VULN> <TAB> unsigned long pending_events ; <NEW_LINE> <TAB> unsigned int sipi_vector ; <NEW_LINE> } ;
<TAB> struct hlist_node node ; <NEW_LINE> <TAB> struct user_namespace * ns ; <NEW_LINE> <TAB> kuid_t uid ; <NEW_LINE> <START_VULN> <TAB> atomic_t count ; <NEW_LINE> <END_VULN> <TAB> atomic_t ucount [ UCOUNT_COUNTS ] ; <NEW_LINE> } ;
<TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> case 'h' : RBININFO ( "fields" , R_CORE_BIN_ACC_FIELDS , NULL , 0 ) ; break ; <NEW_LINE> <START_VULN> <TAB> <TAB> case 'l' : RBININFO ( "libs" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ; break ; <NEW_LINE> <END_VULN> <TAB> <TAB> case 'L' : <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> char * ptr = strchr ( input , ' ' ) ;
static const struct driver_info wwan_noarp_info = { <NEW_LINE> <TAB> . description = "Mobile Broadband Network Device ( NO ARP ) " , <NEW_LINE> <TAB> . flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> | FLAG_WWAN | FLAG_NOARP , <NEW_LINE> <END_VULN> <TAB> . bind = cdc_ncm_bind , <NEW_LINE> <TAB> . unbind = cdc_ncm_unbind , <NEW_LINE> <TAB> . manage_power = usbnet_manage_power ,
<TAB> nsIRunnable * mPendingInstantiateEvent ; <NEW_LINE> <TAB> nsCString mContentType ; <NEW_LINE> <START_VULN> <TAB> nsIChannel * mChannel ; <NEW_LINE> <END_VULN> <TAB> nsCOMPtr < nsIURI > mURI ; <NEW_LINE> <TAB> ObjectType mType : 16 ;
<TAB> r = sc_read_record ( card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; <NEW_LINE> <TAB> SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , "read document number failed" ) ; <NEW_LINE> <START_VULN> <TAB> buff [ r ] = '\0' ; <NEW_LINE> <END_VULN> <TAB> set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ; <NEW_LINE> <TAB> p15card -> tokeninfo -> flags = SC_PKCS15_TOKEN_PRN_GENERATION
<TAB> Sprinter sprinter ( cx ) ; <NEW_LINE> <TAB> sprinter . init ( ) ; <NEW_LINE> <TAB> size_t depth = 0 ; <NEW_LINE> <TAB> for ( StackIter i ( cx ) ; ! i . done ( ) ; + + i , + + depth ) { <NEW_LINE> <TAB> <TAB> if ( i . isScript ( ) ) { <NEW_LINE> <TAB> <TAB> <TAB> const char * filename = JS_GetScriptFilename ( cx , i . script ( ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> unsigned line = JS_PCToLineNumber ( cx , i . script ( ) , i . pc ( ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> sprinter . printf ( "# % d % 14p % s : % d ( % p @ % d ) \n" , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> depth , ( i . isIon ( ) ? 0 : i . fp ( ) ) , filename , line , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> i . script ( ) , i . pc ( ) - i . script ( ) -> code ) ; <NEW_LINE> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> sprinter . printf ( "# % d ? ? ? \n" , depth ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> fprintf ( stdout , " % s" , sprinter . string ( ) ) ; <NEW_LINE> }
<START_VULN> static int <NEW_LINE>dns_resolver_match ( const struct key * key , <NEW_LINE><TAB> <TAB> const struct key_match_data * match_data ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> int slen , dlen , ret = 0 ; <NEW_LINE> <TAB> const char * src = key -> description , * dsp = match_data -> raw_data ;
<TAB> struct sem_array * sma ; <NEW_LINE> <TAB> struct sem_undo_list * ulp ; <NEW_LINE> <TAB> struct sem_undo * un , * new ; <NEW_LINE> <START_VULN> <TAB> int nsems ; <NEW_LINE><TAB> int error ; <NEW_LINE> <END_VULN> <TAB> error = get_undo_list ( & ulp ) ; <NEW_LINE> <TAB> if ( error )
<TAB> <TAB> <TAB> pipe -> nrbufs = + + bufs ; <NEW_LINE> <TAB> <TAB> <TAB> pipe -> tmp_page = NULL ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> total_len -= chars ; <NEW_LINE><TAB> <TAB> <TAB> if ( ! total_len ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> if ( bufs < pipe -> buffers )
int <NEW_LINE> midi_synth_load_patch ( int dev , int format , const char __user * addr , <NEW_LINE> <START_VULN> <TAB> <TAB> int offs , int count , int pmgr_flag ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> int orig_dev = synth_devs [ dev ] -> midi_dev ;
{ <NEW_LINE> <TAB> FILE * fd ; <NEW_LINE> <TAB> char * tmpname = NULL ; <NEW_LINE> <START_VULN> <TAB> char * dir = " / etc" ; <NEW_LINE><TAB> if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { <NEW_LINE> <END_VULN> <TAB> <TAB> ulckpwdf ( ) ; <NEW_LINE> <TAB> <TAB> err ( EXIT_FAILURE , _ ( "can't open temporary file" ) ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> BIO_push ( out , etmp ) ; <NEW_LINE> <TAB> <TAB> etmp = NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> bio = in_bio ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> if ( data_body -> length > 0 )
<TAB> <TAB> <TAB> <TAB> } else if ( ( s -> bits_per_pixel == 1 || s -> bits_per_pixel == 2 || s -> bits_per_pixel == 4 || s -> bits_per_pixel == 8 ) && <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> s -> color_type == PNG_COLOR_TYPE_PALETTE ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> } else if ( s -> bit_depth == 1 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> avctx -> pix_fmt = AV_PIX_FMT_MONOBLACK ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } else if ( s -> bit_depth == 8 && <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA ) {
eWOFF_warn_checksum_mismatch = 0x0200 , <NEW_LINE> eWOFF_warn_misaligned_table = 0x0400 , <NEW_LINE> eWOFF_warn_trailing_data = 0x0800 , <NEW_LINE> eWOFF_warn_unpadded_table = 0x1000 , <NEW_LINE> <START_VULN> eWOFF_warn_removed_DSIG = 0x2000 <NEW_LINE> <END_VULN> } ; <NEW_LINE> #define WOFF_SUCCESS ( status ) ( ( ( uint32_t ) ( status ) & 0xff ) == eWOFF_ok ) <NEW_LINE> #define WOFF_FAILURE ( status ) ( ! WOFF_SUCCESS ( status ) )
static NS_HIDDEN_ ( nsresult ) Startup ( ) ; <NEW_LINE> static NS_HIDDEN_ ( void ) Shutdown ( ) ; <NEW_LINE> friend class TimerThread ; <NEW_LINE> friend struct TimerAdditionComparator ; <NEW_LINE> void Fire ( ) ; <NEW_LINE> <START_VULN> nsresult PostTimerEvent ( ) ; <NEW_LINE> <END_VULN> void SetDelayInternal ( uint32_t aDelay ) ; <NEW_LINE> NS_DECL_ISUPPORTS <NEW_LINE> NS_DECL_NSITIMER <NEW_LINE> int32_t GetGeneration ( ) { return mGeneration ; } <NEW_LINE> private :
<TAB> lock_mount_hash ( ) ; <NEW_LINE> <TAB> while ( ! hlist_empty ( & mp -> m_list ) ) { <NEW_LINE> <TAB> <TAB> mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> umount_tree ( mnt , 0 ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> unlock_mount_hash ( ) ; <NEW_LINE> <TAB> put_mountpoint ( mp ) ;
<TAB> void * reghash ; <NEW_LINE> <TAB> void * userdata ; <NEW_LINE> <TAB> JSScript * script ; <NEW_LINE> <START_VULN> <TAB> js : : XDRScriptState * state ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> extern JS_PUBLIC_API ( void )
static bool generic_new ( struct nf_conn * ct , const struct sk_buff * skb , <NEW_LINE> <TAB> <TAB> <TAB> unsigned int dataoff , unsigned int * timeouts ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return true ; <NEW_LINE> <END_VULN> } <NEW_LINE> #if IS_ENABLED ( CONFIG_NF_CT_NETLINK_TIMEOUT )
cdf_count_chain ( const cdf_sat_t * sat , cdf_secid_t sid , size_t size ) <NEW_LINE> { <NEW_LINE> <TAB> size_t i , j ; <NEW_LINE> <START_VULN> <TAB> cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ; <NEW_LINE> <END_VULN> <TAB> DPRINTF ( ( "Chain : " ) ) ; <NEW_LINE> <TAB> for ( j = i = 0 ; sid >= 0 ; i + + , j + + ) {
#endif <NEW_LINE> extern SECStatus ssl3_HandleHelloExtensions ( sslSocket * ss , <NEW_LINE> <TAB> <TAB> <TAB> SSL3Opaque ** b , PRUint32 * length ) ; <NEW_LINE> extern PRBool ssl3_ExtensionNegotiated ( sslSocket * ss , PRUint16 ex_type ) ; <NEW_LINE> <START_VULN> extern SECStatus ssl3_SetSIDSessionTicket ( sslSessionID * sid , <NEW_LINE><TAB> <TAB> <TAB> NewSessionTicket * session_ticket ) ; <NEW_LINE> <END_VULN> extern SECStatus ssl3_SendNewSessionTicket ( sslSocket * ss ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeys ( unsigned char * keyName , <NEW_LINE> <TAB> <TAB> <TAB> unsigned char * encKey , unsigned char * macKey ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeysPKCS11 ( SECKEYPrivateKey * svrPrivKey , <NEW_LINE> <TAB> <TAB> <TAB> SECKEYPublicKey * svrPubKey , void * pwArg , <NEW_LINE> <TAB> <TAB> <TAB> unsigned char * keyName , PK11SymKey ** aesKey , <NEW_LINE> <TAB> <TAB> <TAB> PK11SymKey ** macKey ) ;
<TAB> <TAB> <TAB> if ( amount < n_got || amount > UT32_MAX ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto out_error ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( got_table ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ut32 offset = 0 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> for ( i = 0 ; i < n_got ; offset += 4 , i + + ) {
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm , sparc64 sha1 opcode accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha1" ) ; <NEW_LINE> <END_VULN> #include "crop_devid . c"
<TAB> if ( skb -> ip_summed != CHECKSUM_COMPLETE ) <NEW_LINE> <TAB> <TAB> return ; <NEW_LINE> <START_VULN> <TAB> if ( offset != 0 ) <NEW_LINE><TAB> <TAB> csum = csum_sub ( csum , <NEW_LINE><TAB> <TAB> <TAB> <TAB> csum_partial ( skb_transport_header ( skb ) + tlen , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> offset , 0 ) ) ; <NEW_LINE> <END_VULN> <TAB> put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ; <NEW_LINE> }
#ifndef _TYPES_INCLUDED <NEW_LINE> #define _TYPES_INCLUDED <NEW_LINE> #include "compiler / BaseTypes . h" <NEW_LINE> #include "compiler / Common . h" <NEW_LINE> <START_VULN> #include "compiler / debug . h" <NEW_LINE> <END_VULN> class TType ; <NEW_LINE> struct TTypeLine { <NEW_LINE> <TAB> TType * type ; <NEW_LINE> <TAB> int line ; <NEW_LINE> rename from gfx / angle / src / compiler / debug . cpp <NEW_LINE> rename to gfx / angle / src / compiler / compilerdebug . cpp
<TAB> struct crypto_report_hash rhash ; <NEW_LINE> <TAB> struct shash_alg * salg = __crypto_shash_alg ( alg ) ; <NEW_LINE> <START_VULN> <TAB> snprintf ( rhash . type , CRYPTO_MAX_ALG_NAME , " % s" , "shash" ) ; <NEW_LINE> <END_VULN> <TAB> rhash . blocksize = alg -> cra_blocksize ; <NEW_LINE> <TAB> rhash . digestsize = salg -> digestsize ;
<TAB> NS_DECL_ISUPPORTS <NEW_LINE> <TAB> NS_DECL_NSIWEBGLPROGRAM <NEW_LINE> protected : <NEW_LINE> <TAB> WebGLuint mName ; <NEW_LINE> <TAB> PRPackedBool mDeleted ; <NEW_LINE> <TAB> PRPackedBool mDeletePending ; <NEW_LINE> <TAB> PRPackedBool mLinkStatus ; <NEW_LINE> <START_VULN> <TAB> nsTArray < WebGLShader * > mAttachedShaders ; <NEW_LINE> <END_VULN> <TAB> CheckedUint32 mGeneration ; <NEW_LINE> <TAB> nsRefPtrHashtable < nsUint32HashKey , WebGLUniformLocation > mMapUniformLocations ; <NEW_LINE> <TAB> GLint mUniformMaxNameLength ; <NEW_LINE> <TAB> GLint mAttribMaxNameLength ; <NEW_LINE> <TAB> GLint mUniformCount ; <NEW_LINE> <TAB> GLint mAttribCount ;
<TAB> <TAB> Z_PARAM_PATH ( filename , filename_len ) \ <NEW_LINE> <TAB> ZEND_PARSE_PARAMETERS_END ( ) ; \ <NEW_LINE> <TAB> \ <NEW_LINE> <START_VULN> <TAB> php_stat ( filename , ( php_stat_len ) filename_len , funcnum , return_value ) ; \ <NEW_LINE> <END_VULN> }
<TAB> if ( opt_verbose > 1 ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> sprintf ( query , "SELECT COUNT ( * ) FROM ` % s`" , row [ 0 ] ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! ( mysql_query ( mysql , query ) ) ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> if ( ( rresult = mysql_store_result ( mysql ) ) )
<TAB> <TAB> JS_STATIC_ASSERT ( sizeof ( JSValueTag ) == 4 ) ; <NEW_LINE> <TAB> <TAB> JS_STATIC_ASSERT ( sizeof ( JSBool ) == 4 ) ; <NEW_LINE> <TAB> <TAB> JS_STATIC_ASSERT ( sizeof ( JSWhyMagic ) <= 4 ) ; <NEW_LINE> <TAB> <TAB> JS_STATIC_ASSERT ( sizeof ( Value ) == 8 ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> friend jsval_layout ( : : JSVAL_TO_IMPL ) ( Value ) ; <NEW_LINE> <TAB> friend Value ( : : IMPL_TO_JSVAL ) ( jsval_layout l ) ; <NEW_LINE> <START_VULN> } JSVAL_ALIGNMENT ; <NEW_LINE> <END_VULN> inline bool <NEW_LINE> IsPoisonedValue ( const Value & v ) <NEW_LINE> { <NEW_LINE> <TAB> if ( v . isString ( ) ) <NEW_LINE> <TAB> <TAB> return IsPoisonedPtr ( v . toString ( ) ) ; <NEW_LINE> <TAB> if ( v . isObject ( ) ) <NEW_LINE> <TAB> <TAB> return IsPoisonedPtr ( & v . toObject ( ) ) ;
<TAB> nsec = rtc_time ( ) * sgi_clock_period <NEW_LINE> <TAB> <TAB> <TAB> + sgi_clock_offset . tv_nsec ; <NEW_LINE> <START_VULN> <TAB> tp -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & tp -> tv_nsec ) <NEW_LINE><TAB> <TAB> <TAB> + sgi_clock_offset . tv_sec ; <NEW_LINE> <END_VULN> <TAB> return 0 ; <NEW_LINE> } ;
<TAB> <TAB> <TAB> opt = NULL ; <NEW_LINE> <TAB> <TAB> connected = 0 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ! opt ) <NEW_LINE><TAB> <TAB> opt = np -> opt ; <NEW_LINE> <END_VULN> <TAB> if ( flowlabel ) <NEW_LINE> <TAB> <TAB> opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; <NEW_LINE> <TAB> opt = ipv6_fixup_options ( & opt_space , opt ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> return ZEND_HASH_APPLY_STOP ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> fname_len = ( php_stat_len ) strlen ( fname ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> save = fname ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> goto phar_spl_fileinfo ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : window functions <NEW_LINE> <START_VULN> last mod : $ Id : window . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_WINDOW_ <NEW_LINE> #define _V_WINDOW_ <NEW_LINE> extern float * _vorbis_window_get ( int n ) ; <NEW_LINE> extern void _vorbis_apply_window ( float * d , int * winno , long * blocksizes ,
protected : <NEW_LINE> nsresult MakeFileInputStream ( nsIFile * file , nsCOMPtr < nsIInputStream > & stream , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsCString & contentType ) ; <NEW_LINE> <START_VULN> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result ) ; <NEW_LINE> <END_VULN> private : <NEW_LINE> nsCOMPtr < nsIInputStream > mUploadStream ; <NEW_LINE> PRInt64 mUploadLength ; <NEW_LINE> } ; <NEW_LINE> #endif
<TAB> return static_cast < nsPluginArray * > ( aSupports ) ; <NEW_LINE> } <NEW_LINE> private : <NEW_LINE> nsresult GetPlugins ( ) ; <NEW_LINE> PRBool AllowPlugins ( ) ; <NEW_LINE> public : <NEW_LINE> <START_VULN> void SetDocShell ( nsIDocShell * aDocShell ) ; <NEW_LINE> <END_VULN> protected : <NEW_LINE> nsNavigator * mNavigator ; <NEW_LINE> nsCOMPtr < nsIPluginHost > mPluginHost ; <NEW_LINE> PRUint32 mPluginCount ; <NEW_LINE> nsIDOMPlugin ** mPluginArray ; <NEW_LINE> nsIDocShell * mDocShell ; <NEW_LINE> } ;
<TAB> <TAB> <TAB> inflateEnd ( strm ) ; <NEW_LINE> <TAB> <TAB> <TAB> g_free ( strm ) ; <NEW_LINE> <TAB> <TAB> <TAB> g_free ( strmbuf ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> g_free ( compr ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( uncompr == NULL ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> <TAB> if ( ! op -> b_o_s ) stream -> delivered_non_b_o_s = 1 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> else <NEW_LINE> <TAB> <TAB> break ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( cb_ret == OGGZ_STOP_OK || <NEW_LINE><TAB> cb_ret == OGGZ_STOP_ERR || <NEW_LINE><TAB> cb_ret == OGGZ_ERR_HOLE_IN_DATA ) <NEW_LINE> <END_VULN> <TAB> return cb_ret ; <NEW_LINE> <TAB> if ( oggz_read_get_next_page ( oggz , & og ) < 0 ) <NEW_LINE> <TAB> return OGGZ_READ_EMPTY ; <NEW_LINE> <TAB> serialno = ogg_page_serialno ( & og ) ; <NEW_LINE> <TAB> reader -> current_serialno = serialno ;
<TAB> crypto_unregister_algs ( tea_algs , ARRAY_SIZE ( tea_algs ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> MODULE_ALIAS ( "xtea" ) ; <NEW_LINE>MODULE_ALIAS ( "xeta" ) ; <NEW_LINE> <END_VULN> module_init ( tea_mod_init ) ; <NEW_LINE> module_exit ( tea_mod_fini ) ;
<TAB> <TAB> zip_error_set ( error , ZIP_ER_SEEK , EFBIG ) ; <NEW_LINE> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ( flags & ZIP_CHECKCONS ) && offset + size != eocd_offset ) { <NEW_LINE> <END_VULN> <TAB> zip_error_set ( error , ZIP_ER_INCONS , 0 ) ; <NEW_LINE> <TAB> return NULL ; <NEW_LINE> <TAB> }
# define SGROUP_FILE <TAB> " / tmp / gshadow" <NEW_LINE> #endif <NEW_LINE> <START_VULN> extern int setpwnam ( struct passwd * pwd ) ; <NEW_LINE> <END_VULN>
<TAB> sdb_num_set ( sdb , "link" , shdr -> sh_link , 0 ) ; <NEW_LINE> <TAB> sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; <NEW_LINE> <START_VULN> <TAB> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; + + cnt ) { <NEW_LINE> <END_VULN> <TAB> <TAB> Sdb * sdb_verdef = sdb_new0 ( ) ; <NEW_LINE> <TAB> <TAB> char * vstart = ( ( char * ) defs ) + i ; <NEW_LINE> <TAB> <TAB> char key [ 32 ] = { 0 } ;
} <NEW_LINE> for ( j = first ; j < last ; j + + ) { <NEW_LINE> <TAB> int ret = 0 ; <NEW_LINE> <TAB> ve -> stretch + + ; <NEW_LINE> <TAB> if ( ve -> stretch > VE_MAXSTRETCH * 2 ) <NEW_LINE> <TAB> ve -> stretch = VE_MAXSTRETCH * 2 ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> for ( i = 0 ; i < ve -> ch ; i + + ) { <NEW_LINE> <TAB> float * pcm = v -> pcm [ i ] + ve -> searchstep * ( j ) ; <NEW_LINE> <TAB> ret |= _ve_amp ( ve , gi , pcm , ve -> band , ve -> filter + i * VE_BANDS ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> ve -> mark [ j + VE_POST ] = 0 ; <NEW_LINE> <TAB> if ( ret & 1 ) { <NEW_LINE> <TAB> ve -> mark [ j ] = 1 ;
<TAB> u_int8_t type , old_state , new_state ; <NEW_LINE> <TAB> enum ct_dccp_roles role ; <NEW_LINE> <START_VULN> <TAB> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <NEW_LINE> <END_VULN> <TAB> BUG_ON ( dh == NULL ) ; <NEW_LINE> <TAB> type = dh -> dccph_type ;
<TAB> <TAB> <TAB> casspecial = ( u8 ) act_code ; <TAB> <NEW_LINE> <TAB> <TAB> <TAB> * ( -- stackp ) = casspecial ; <TAB> <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> WritePixels ( i , & context , stackp , stack_top - stackp ) ; <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> npix -= ( stack_top - stackp ) ; <NEW_LINE> <TAB> <TAB> <TAB> stackp = stack_top ;
DeletionConfirmationDlg ( QWidget * parent , const int & size , const QString & name , bool defaultDeleteFiles ) : QDialog ( parent ) { <NEW_LINE> <TAB> setupUi ( this ) ; <NEW_LINE> <TAB> if ( size == 1 ) <NEW_LINE> <START_VULN> <TAB> label -> setText ( tr ( "Are you sure you want to delete ' % 1' from the transfer list ? " , "Are you sure you want to delete 'ubuntu - linux - iso' from the transfer list ? " ) . arg ( name ) ) ; <NEW_LINE> <END_VULN> <TAB> else <NEW_LINE> <TAB> label -> setText ( tr ( "Are you sure you want to delete these % 1 torrents from the transfer list ? " , "Are you sure you want to delete these 5 torrents from the transfer list ? " ) . arg ( QString : : number ( size ) ) ) ;
static void add_bytes_c ( uint8_t * dst , uint8_t * src , int w ) { <NEW_LINE> <TAB> long i ; <NEW_LINE> <START_VULN> <TAB> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> long a = * ( long * ) ( src + i ) ; <NEW_LINE> <TAB> <TAB> long b = * ( long * ) ( dst + i ) ; <NEW_LINE> <TAB> <TAB> * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ;
<TAB> sp = regs -> gpr [ 1 ] ; <NEW_LINE> <TAB> perf_callchain_store ( entry , next_ip ) ; <NEW_LINE> <START_VULN> <TAB> for ( ; ; ) { <NEW_LINE> <END_VULN> <TAB> <TAB> fp = ( unsigned long __user * ) sp ; <NEW_LINE> <TAB> <TAB> if ( ! valid_user_sp ( sp , 1 ) || read_user_stack_64 ( fp , & next_sp ) ) <NEW_LINE> <TAB> <TAB> <TAB> return ;
<TAB> ( int ) qcd -> compparms . qntsty , qcd -> compparms . numguard , qcd -> compparms . numstepsizes ) ; <NEW_LINE> <TAB> for ( i = 0 ; i < qcd -> compparms . numstepsizes ; + + i ) { <NEW_LINE> <TAB> <TAB> fprintf ( out , "expn [ % d ] = 0x % 04x ; mant [ % d ] = 0x % 04x ; \n" , <NEW_LINE> <START_VULN> <TAB> <TAB> i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) , <NEW_LINE><TAB> <TAB> i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return 0 ; <NEW_LINE> }
<TAB> do { <NEW_LINE> <TAB> <TAB> if ( unlikely ( work_to_do -- <= 0 ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> netdev_dbg ( vif -> dev , "Missing extra info\n" ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return - EBADR ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> return NULL ; <NEW_LINE> <TAB> str -> init ( chars , length ) ; <NEW_LINE> <TAB> return str ; <NEW_LINE> } <NEW_LINE> JS_ALWAYS_INLINE JSAtom * <NEW_LINE> JSFixedString : : morphAtomizedStringIntoAtom ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> JS_ASSERT ( ( d . lengthAndFlags & FLAGS_MASK ) == JS_BIT ( 2 ) ) ; <NEW_LINE><TAB> JS_STATIC_ASSERT ( NON_STATIC_ATOM == JS_BIT ( 3 ) ) ; <NEW_LINE><TAB> d . lengthAndFlags ^ = ( JS_BIT ( 2 ) | JS_BIT ( 3 ) ) ; <NEW_LINE> <END_VULN> <TAB> return & asAtom ( ) ; <NEW_LINE> } <NEW_LINE> JS_ALWAYS_INLINE JSInlineString * <NEW_LINE> JSInlineString : : new_ ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> <TAB> return ( JSInlineString * ) js_NewGCString ( cx ) ; <NEW_LINE> }
<START_VULN> <TAB> <TAB> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( is_error_noslot_pfn ( pfn ) ) { <NEW_LINE> <TAB> <TAB> <TAB> gfn += 1 ; <NEW_LINE> <TAB> <TAB> <TAB> continue ;
<TAB> <TAB> <TAB> buf [ 1 ] = oid [ 3 ] ; <NEW_LINE> <TAB> <TAB> <TAB> if ( buf [ 0 ] == 0x00 && buf [ 1 ] == 0x00 ) continue ; <NEW_LINE> <TAB> <TAB> <TAB> buf += 2 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> count += 2 ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return count ;
<TAB> <TAB> <TAB> proto_tree * padding_tree = proto_item_add_subtree ( ti , ett_csn1 ) ; <NEW_LINE> <TAB> <TAB> <TAB> while ( remaining_bits_len > 0 ) <NEW_LINE> <TAB> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> guint8 bits_to_handle = remaining_bits_len + ( bit_offset % 8 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( bits_to_handle > 32 ) <NEW_LINE> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> bits_to_handle = 32 - ( bit_offset % 8 ) ;
<TAB> <TAB> <TAB> <TAB> zrtpPacket -> messageData = ( void * ) messageData ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> memcpy ( zrtpPacket -> packetString , input , inputLength ) ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> <TAB> ASSERT ( ( entry1 -> flags & XFS_ATTR_LOCAL ) == 0 ) ; <NEW_LINE> <TAB> <TAB> name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args -> index ) ; <NEW_LINE> <TAB> <TAB> name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> xfs_trans_log_buf ( args -> trans , bp1 , <NEW_LINE> <TAB> <TAB> <TAB> XFS_DA_LOGRANGE ( leaf1 , name_rmt , sizeof ( * name_rmt ) ) ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> <TAB> skip_bits_long ( & s -> gb , offset ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! nblocks || nblocks > INT_MAX ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> av_log ( avctx , AV_LOG_ERROR , "Invalid sample count : % "PRIu32" . \n" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> nblocks ) ; <NEW_LINE> <TAB> <TAB> <TAB> return AVERROR_INVALIDDATA ;
<TAB> <TAB> <TAB> g_file_equal ( copy_job -> desktop_location , dest_dir ) && <NEW_LINE> <TAB> <TAB> <TAB> is_trusted_desktop_file ( src , job -> cancellable ) ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> mark_desktop_file_trusted ( job , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> job -> cancellable , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> dest , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> FALSE ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> if ( job -> undo_info != NULL )
struct TypedArrayObjectStorage : AllTypedArraysBase { <NEW_LINE> protected : <NEW_LINE> JSObject * mObj ; <NEW_LINE> <START_VULN> TypedArrayObjectStorage ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> explicit TypedArrayObjectStorage ( TypedArrayObjectStorage && aOther ) <NEW_LINE> <TAB> : mObj ( aOther . mObj ) <NEW_LINE> { <NEW_LINE> <TAB> aOther . mObj = nullptr ; <NEW_LINE> }
<TAB> } <NEW_LINE> <TAB> len += 128 ; <NEW_LINE> <TAB> buf = ( char * ) PORT_Alloc ( len ) ; <NEW_LINE> <TAB> if ( ! buf ) { <NEW_LINE> <START_VULN> <TAB> return ( 0 ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> tmpbuf = buf ; <NEW_LINE> <TAB> if ( cn ) { <NEW_LINE> <TAB> PORT_Memcpy ( tmpbuf , cn -> data , cn -> len ) ; <NEW_LINE> <TAB> tmpbuf += cn -> len ; <NEW_LINE> <TAB> PORT_Memcpy ( tmpbuf , BREAK , BREAKLEN ) ;
<START_VULN> static int ocfs2_dio_get_block ( struct inode * inode , sector_t iblock , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> struct buffer_head * bh_result , int create ) <NEW_LINE> { <NEW_LINE> <TAB> struct ocfs2_super * osb = OCFS2_SB ( inode -> i_sb ) ;
<TAB> <TAB> <TAB> if ( haveQuote ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> cmd + + ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> p = find_eoq ( cmd + 1 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> if ( ! p || ! * p ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> eprintf ( "Missing \" in ( % s ) . " , cmd ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> return false ;
<TAB> } <NEW_LINE> <TAB> ret = PTR_ERR ( filp ) ; <NEW_LINE> out_close : <NEW_LINE> <START_VULN> <TAB> nfs4_close_sync ( path , state , nd -> intent . open . flags ) ; <NEW_LINE> <END_VULN> <TAB> return ret ; <NEW_LINE> }
{ <NEW_LINE> <TAB> struct __net_random_once_work * work = <NEW_LINE> <TAB> <TAB> container_of ( w , struct __net_random_once_work , work ) ; <NEW_LINE> <START_VULN> <TAB> if ( ! static_key_enabled ( work -> key ) ) <NEW_LINE><TAB> <TAB> static_key_slow_inc ( work -> key ) ; <NEW_LINE> <END_VULN> <TAB> kfree ( work ) ; <NEW_LINE> }
<TAB> <TAB> <TAB> <TAB> inode -> i_ino , ( unsigned long ) ce -> e_block ) ; <NEW_LINE> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> lock_buffer ( bh ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( le32_to_cpu ( HDR ( bh ) -> h_refcount ) > <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> EXT2_XATTR_REFCOUNT_MAX ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ea_idebug ( inode , "block % ld refcount % d > % d" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> ( unsigned long ) ce -> e_block ,
<TAB> a -> y2a = y2a * weight + y2b ; <NEW_LINE> <TAB> a -> xya = xya * weight + xyb ; <NEW_LINE> <TAB> a -> an = na * weight + nb ; <NEW_LINE> } <NEW_LINE> return ( na ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void fit_line ( lsfit_acc * a , int fits , int * y0 , int * y1 ) { <NEW_LINE> <END_VULN> long x = 0 , y = 0 , x2 = 0 , y2 = 0 , xy = 0 , an = 0 , i ; <NEW_LINE> long x0 = a [ 0 ] . x0 ; <NEW_LINE> long x1 = a [ fits - 1 ] . x1 ; <NEW_LINE> for ( i = 0 ; i < fits ; i + + ) { <NEW_LINE> <TAB> x += a [ i ] . xa ; <NEW_LINE> <TAB> y += a [ i ] . ya ; <NEW_LINE> <TAB> x2 += a [ i ] . x2a ;
<TAB> if ( ! is_irq_none ( vdev ) ) <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <START_VULN> <TAB> vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! vdev -> ctx ) <NEW_LINE> <TAB> <TAB> return - ENOMEM ; <NEW_LINE> commit 05692d7005a364add85c6e25a6c4447ce08f913a <NEW_LINE> Author : Vlad Tsyrklevich < vlad@tsyrklevich . net > <NEW_LINE> Date : Wed Oct 12 18 : 51 : 24 2016 + 0200 <NEW_LINE> <TAB> vfio / pci : Fix integer overflows , bitmask check <NEW_LINE> <TAB> The VFIO_DEVICE_SET_IRQS ioctl did not sufficiently sanitize <NEW_LINE> <TAB> user - supplied integers , potentially allowing memory corruption . This <NEW_LINE> <TAB> patch adds appropriate integer overflow checks , checks the range bounds <NEW_LINE> <TAB> for VFIO_IRQ_SET_DATA_NONE , and also verifies that only single element <NEW_LINE> <TAB> in the VFIO_IRQ_SET_DATA_TYPE_MASK bitmask is set . <NEW_LINE> <TAB> VFIO_IRQ_SET_ACTION_TYPE_MASK is already correctly checked later in <NEW_LINE> <TAB> vfio_pci_set_irqs_ioctl ( ) . <NEW_LINE> <TAB> Furthermore , a kzalloc is changed to a kcalloc because the use of a <NEW_LINE> <TAB> kzalloc with an integer multiplication allowed an integer overflow <NEW_LINE> <TAB> condition to be reached without this patch . kcalloc checks for overflow <NEW_LINE> <TAB> and should prevent a similar occurrence . <NEW_LINE> <TAB> Signed - off - by : Vlad Tsyrklevich < vlad@tsyrklevich . net > <NEW_LINE> <TAB> Signed - off - by : Alex Williamson < alex . williamson@redhat . com >
<TAB> w = image -> comps [ 0 ] . w ; <NEW_LINE> <TAB> h = image -> comps [ 0 ] . h ; <NEW_LINE> <START_VULN> <TAB> if ( image -> numcomps < 4 ) return ; <NEW_LINE> <END_VULN> <TAB> max = w * h ;
<TAB> cl_allowDownload = Cvar_Get ( "cl_allowDownload" , "0" , CVAR_ARCHIVE ) ; <NEW_LINE> #ifdef USE_CURL_DLOPEN <NEW_LINE> <START_VULN> <TAB> cl_cURLLib = Cvar_Get ( "cl_cURLLib" , DEFAULT_CURL_LIB , CVAR_ARCHIVE ) ; <NEW_LINE> <END_VULN> #endif
<TAB> { <NEW_LINE> <TAB> stream -> msg = "abnormal command termination" ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> return XD3_INTERNAL ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> return 0 ; <NEW_LINE> }
<TAB> this -> sd = - 1 ; <NEW_LINE> <TAB> this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ; <NEW_LINE> <TAB> if ( this -> sd < 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> ERR ( "sockect open failed" ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> goto error ; <NEW_LINE> <TAB> }
namespace js { <NEW_LINE> <START_VULN> typedef js : : HashMap < JSObject * , Value > ObjectValueMap ; <NEW_LINE> <END_VULN> class WeakMap { <NEW_LINE> <TAB> ObjectValueMap map ;
<TAB> curr_offset = offset ; <NEW_LINE> <START_VULN> <TAB> memset ( str , 0 , MAX_APN_LENGTH ) ; <NEW_LINE> <END_VULN> <TAB> tvb_memcpy ( tvb , str , offset , len < MAX_APN_LENGTH ? len : MAX_APN_LENGTH ) ; <NEW_LINE> <TAB> curr_len = 0 ;
public : <NEW_LINE> <TAB> bool init ( uint32_t id , uint32_t offset , uint32_t numSuccessors ) { <NEW_LINE> <TAB> <TAB> id_ = id ; <NEW_LINE> <TAB> <TAB> offset_ = offset ; <NEW_LINE> <TAB> <TAB> numSuccessors_ = numSuccessors ; <NEW_LINE> <TAB> <TAB> if ( numSuccessors ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> successors_ = ( uint32_t * ) js_calloc ( numSuccessors * sizeof ( uint32_t ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( ! successors_ ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> return true ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void destroy ( ) { <NEW_LINE> <TAB> <TAB> js_free ( successors_ ) ;
<TAB> sbinfo -> max_inodes = config . max_inodes ; <NEW_LINE> <TAB> sbinfo -> free_inodes = config . max_inodes - inodes ; <NEW_LINE> <START_VULN> <TAB> mpol_put ( sbinfo -> mpol ) ; <NEW_LINE><TAB> sbinfo -> mpol = config . mpol ; <TAB> <NEW_LINE> <END_VULN> out : <NEW_LINE> <TAB> spin_unlock ( & sbinfo -> stat_lock ) ; <NEW_LINE> <TAB> return error ;
<TAB> <TAB> del_timer ( & p -> timer ) ; <NEW_LINE> <TAB> <TAB> call_rcu_bh ( & p -> rcu , br_multicast_free_pg ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! mp -> ports && ! mp -> mglist && <NEW_LINE> <END_VULN> <TAB> <TAB> netif_running ( br -> dev ) ) <NEW_LINE> <TAB> <TAB> <TAB> mod_timer ( & mp -> timer , jiffies ) ;
<TAB> long i ; <NEW_LINE> <TAB> int ret ; <NEW_LINE> <START_VULN> <TAB> if ( rs -> rs_bound_addr == 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> ret = - ENOTCONN ; <NEW_LINE> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> }
<TAB> struct ext4_iloc iloc ; <NEW_LINE> <TAB> int err = 0 , rc ; <NEW_LINE> <START_VULN> <TAB> if ( ! ext4_handle_valid ( handle ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> mutex_lock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ;
<TAB> data [ 1 ] = new >> 4 ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> FAT_ENTRY subseqEntry ; <NEW_LINE> <START_VULN> <TAB> if ( cluster != fs -> clusters - 1 ) <NEW_LINE> <END_VULN> <TAB> <TAB> get_fat ( & subseqEntry , fs -> fat , cluster + 1 , fs ) ; <NEW_LINE> <TAB> else <NEW_LINE> <TAB> <TAB> subseqEntry . value = 0 ;
<TAB> <TAB> <TAB> phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> <TAB> <TAB> BIO_free ( f ) ; <NEW_LINE> <TAB> <TAB> <TAB> f = tbio ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> while ( f != upto ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> else <NEW_LINE> <TAB> <TAB> BIO_free_all ( f ) ;
<TAB> u32 eb ; <NEW_LINE> <TAB> eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) | <NEW_LINE> <START_VULN> <TAB> ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ; <NEW_LINE> <END_VULN> <TAB> if ( ( vcpu -> guest_debug & <NEW_LINE> <TAB> ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == <NEW_LINE> <TAB> ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) )
<TAB> <TAB> <TAB> goto err ; <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE><TAB> <TAB> goto decryption_failed_or_bad_record_mac ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> #ifdef TLS_DEBUG
* <NEW_LINE> int <NEW_LINE> mar_read_product_info_block ( MarFile * mar , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> struct ProductInformationBlock * infoBlock ) <NEW_LINE> { <NEW_LINE> <START_VULN> int i , hasAdditionalBlocks , offset , <NEW_LINE> <END_VULN> <TAB> offsetAdditionalBlocks , numAdditionalBlocks , <NEW_LINE> <TAB> additionalBlockSize , additionalBlockID ; <NEW_LINE> char buf [ 97 ] = { '\0' } ; <NEW_LINE> int ret = get_mar_file_info_fp ( mar -> fp , NULL , NULL , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & hasAdditionalBlocks , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & offsetAdditionalBlocks ,
<TAB> . preparse <TAB> = dns_resolver_preparse , <NEW_LINE> <TAB> . free_preparse <TAB> = dns_resolver_free_preparse , <NEW_LINE> <TAB> . instantiate <TAB> = generic_key_instantiate , <NEW_LINE> <START_VULN> <TAB> . match <TAB> <TAB> = dns_resolver_match , <NEW_LINE> <END_VULN> <TAB> . revoke <TAB> <TAB> = user_revoke , <NEW_LINE> <TAB> . destroy <TAB> = user_destroy , <NEW_LINE> <TAB> . describe <TAB> = dns_resolver_describe ,
<TAB> } <NEW_LINE> <TAB> if ( dataflag ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> goto error ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> jas_stream_close ( tmpstream ) ;
<TAB> <TAB> PUNFETCH ; <NEW_LINE> <TAB> <TAB> prev = p ; <NEW_LINE> <TAB> <TAB> num = scan_unsigned_octal_number ( & p , end , 3 , enc ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( p == prev ) { <NEW_LINE> <TAB> <TAB> num = 0 ; <NEW_LINE> <TAB> <TAB> }
<START_VULN> <TAB> <TAB> uint <TAB> dblocks = XFS_B_TO_FSB ( mp , valuelen ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> nblks += dblocks ; <NEW_LINE> <TAB> <TAB> nblks += XFS_NEXTENTADD_SPACE_RES ( mp , dblocks , XFS_ATTR_FORK ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> if ( ! buffer_uptodate ( * wait_bh ) ) <NEW_LINE> <TAB> <TAB> <TAB> err = - EIO ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ! err ) <NEW_LINE><TAB> <TAB> return err ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> bh = head ;
<TAB> else <NEW_LINE> <TAB> <TAB> regs . flags &= ~ PERF_EFLAGS_EXACT ; <NEW_LINE> <START_VULN> <TAB> if ( perf_event_overflow ( event , 1 , & data , & regs ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> x86_pmu_stop ( event , 0 ) ; <NEW_LINE> }
SH_TIMING_RESTRICTIONS = 0x0200 , <NEW_LINE> <START_VULN> SH_DEPENDENCY_GRAPH = 0x0400 <NEW_LINE> <END_VULN> } ShCompileOptions ; <NEW_LINE> COMPILER_EXPORT int ShInitialize ( ) ;
void usb_serial_console_disconnect ( struct usb_serial * serial ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( serial -> port [ 0 ] == usbcons_info . port ) { <NEW_LINE> <END_VULN> <TAB> <TAB> usb_serial_console_exit ( ) ; <NEW_LINE> <TAB> <TAB> usb_serial_put ( serial ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> op -> cycles = 2 ; <NEW_LINE> <TAB> <TAB> op -> failcycles = 3 ; <NEW_LINE> <TAB> <TAB> op -> type = R_ANAL_OP_TYPE_CJMP ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( data [ 1 ] <= 127 ) <NEW_LINE><TAB> <TAB> <TAB> op -> jump = addr + data [ 1 ] + op -> size ; <NEW_LINE><TAB> <TAB> else <TAB> op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <NEW_LINE> <END_VULN> <TAB> <TAB> op -> fail = addr + op -> size ;
static void mpeg4_encode_gop_header ( MpegEncContext * s ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> int hours , minutes , seconds ; <NEW_LINE> <END_VULN> <TAB> int64_t time ; <NEW_LINE> <TAB> put_bits ( & s -> pb , 16 , 0 ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> less strict that the <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> _ve_envelope_search , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> the search is not run <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> if we only use one <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> block size * / <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> _vorbis_block_ripcord ( vb ) ; <NEW_LINE> vb -> lW = v -> lW ; <NEW_LINE> vb -> W = v -> W ; <NEW_LINE> vb -> nW = v -> nW ;
<TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> case 'r' : RBININFO ( "relocs" , R_CORE_BIN_ACC_RELOCS , NULL , 0 ) ; break ; <NEW_LINE> <TAB> <TAB> case 'd' : RBININFO ( "dwarf" , R_CORE_BIN_ACC_DWARF , NULL , - 1 ) ; break ; <NEW_LINE> <START_VULN> <TAB> <TAB> case 'i' : RBININFO ( "imports" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ; break ; <NEW_LINE> <END_VULN> <TAB> <TAB> case 'I' : RBININFO ( "info" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ; break ; <NEW_LINE> <TAB> <TAB> case 'e' : RBININFO ( "entries" , R_CORE_BIN_ACC_ENTRIES , NULL , 0 ) ; break ; <NEW_LINE> <TAB> <TAB> case 'M' : RBININFO ( "main" , R_CORE_BIN_ACC_MAIN , NULL , 0 ) ; break ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : normalized modified discrete cosine transform <NEW_LINE> <TAB> <TAB> <TAB> power of two length transform only [ 64 <= n ] <NEW_LINE> <START_VULN> last mod : $ Id : mdct . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> Original algorithm adapted long ago from _The use of multirate filter <NEW_LINE> banks for coding of high quality digital audio_ , by T . Sporer , <NEW_LINE> K . Brandenburg and B . Edler , collection of the European Signal <NEW_LINE> Processing Conference ( EUSIPCO ) , Amsterdam , June 1992 , Vol . 1 , pp <NEW_LINE> 211 - 214 <NEW_LINE> The below code implements an algorithm that no longer looks much like
<TAB> <TAB> key_aliases = calloc ( num_key_aliases , sizeof ( * key_aliases ) ) ; <NEW_LINE> <TAB> <TAB> if ( ! key_aliases ) <NEW_LINE> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <START_VULN> <TAB> } <NEW_LINE><TAB> i = 0 ; <NEW_LINE><TAB> darray_foreach ( alias , info -> aliases ) { <NEW_LINE><TAB> <TAB> if ( alias -> real != XKB_ATOM_NONE ) { <NEW_LINE><TAB> <TAB> <TAB> key_aliases [ i ] . alias = alias -> alias ; <NEW_LINE><TAB> <TAB> <TAB> key_aliases [ i ] . real = alias -> real ; <NEW_LINE><TAB> <TAB> <TAB> i + + ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> }
<TAB> struct net_device * netdev ; <NEW_LINE> <TAB> struct catc * catc ; <NEW_LINE> <TAB> u8 broadcast [ ETH_ALEN ] ; <NEW_LINE> <START_VULN> <TAB> int i , pktsz , ret ; <NEW_LINE> <END_VULN> <TAB> if ( usb_set_interface ( usbdev , <NEW_LINE> <TAB> <TAB> <TAB> intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) {
<TAB> size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ; <NEW_LINE> <START_VULN> <TAB> dl = kmalloc ( size , GFP_KERNEL ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! dl ) <NEW_LINE> <TAB> <TAB> return - ENOMEM ;
{ <NEW_LINE> <TAB> MOZ_COUNT_DTOR ( nsXBLProtoImpl ) ; <NEW_LINE> <TAB> delete mMembers ; <NEW_LINE> <TAB> delete mFields ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsresult InstallImplementation ( nsXBLPrototypeBinding * aBinding , nsIContent * aBoundElement ) ; <NEW_LINE> <END_VULN> nsresult InitTargetObjects ( nsXBLPrototypeBinding * aBinding , nsIScriptContext * aContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIContent * aBoundElement , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIXPConnectJSObjectHolder ** aScriptObjectHolder , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject ** aTargetClassObject ) ; <NEW_LINE> nsresult CompilePrototypeMembers ( nsXBLPrototypeBinding * aBinding ) ; <NEW_LINE> void SetMemberList ( nsXBLProtoImplMember * aMemberList ) <NEW_LINE> {
virtual void OnCallbacksChanged ( ) { <NEW_LINE> } <NEW_LINE> public : <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> <NEW_LINE><TAB> <NEW_LINE><TAB> <NEW_LINE><TAB> <NEW_LINE>nsresult Redirect ( nsIChannel * newChannel , PRUint32 redirectFlags ) ; <NEW_LINE> <END_VULN> PRBool HasContentTypeHint ( ) const ;
<TAB> sent = ( * ss -> sec . send ) ( ss , msg , sendLen , 0 ) ; <NEW_LINE> <TAB> if ( sent < 0 ) { <NEW_LINE> <TAB> if ( ss -> sec . uncache ) <NEW_LINE> <TAB> <TAB> ( * ss -> sec . uncache ) ( sid ) ; <NEW_LINE> <TAB> rv = ( SECStatus ) sent ; <NEW_LINE> <TAB> } else if ( ! ss -> opt . noCache ) { <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> ( * ss -> sec . cache ) ( sid ) ; <NEW_LINE> <END_VULN> <TAB> rv = SECSuccess ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> ssl_FreeSID ( sid ) ; <NEW_LINE> <TAB> ss -> sec . ci . sid = 0 ; <NEW_LINE> <TAB> } <NEW_LINE> done : <NEW_LINE> <TAB> ssl_ReleaseXmitBufLock ( ss ) ; <NEW_LINE> <TAB> return rv ;
if ( opt_count ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> sprintf ( query , "select count ( * ) from ` % s`" , table ) ; <NEW_LINE> <END_VULN> <TAB> if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> fprintf ( stderr , " % s : Cannot get record count for db : % s , table : % s : % s\n" ,
<TAB> nsCOMPtr < nsIPrincipal > mSystemPrincipal ; <NEW_LINE> <TAB> nsCOMPtr < nsIXPConnectJSObjectHolder > mLoaderGlobal ; <NEW_LINE> <TAB> JSRuntime * mRuntime ; <NEW_LINE> <TAB> JSContext * mContext ; <NEW_LINE> <TAB> class ModuleEntry : public mozilla : : Module <NEW_LINE> <TAB> { <NEW_LINE> <TAB> public : <NEW_LINE> <START_VULN> <TAB> <TAB> ModuleEntry ( ) : mozilla : : Module ( ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> mVersion = mozilla : : Module : : kVersion ; <NEW_LINE> <TAB> <TAB> <TAB> mCIDs = nullptr ; <NEW_LINE> <TAB> <TAB> <TAB> mContractIDs = nullptr ; <NEW_LINE> <TAB> <TAB> <TAB> mCategoryEntries = nullptr ; <NEW_LINE> <TAB> <TAB> <TAB> getFactoryProc = GetFactory ; <NEW_LINE> <TAB> <TAB> <TAB> loadProc = nullptr ; <NEW_LINE> <TAB> <TAB> <TAB> unloadProc = nullptr ;
<TAB> char * rundir ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> len = strlen ( " / lock / lxc / " ) + strlen ( n ) + strlen ( p ) + 3 ; <NEW_LINE> <END_VULN> <TAB> rundir = get_rundir ( ) ; <NEW_LINE> <TAB> if ( ! rundir ) <NEW_LINE> <TAB> <TAB> return NULL ;
PRBool <NEW_LINE> CVE_2011_2980_ThinkPadSensor : : Startup ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> mLibrary = LoadLibraryW ( L"sensor . dll" ) ; <NEW_LINE> <END_VULN> if ( ! mLibrary ) <NEW_LINE> <TAB> return PR_FALSE ;
merge : <NEW_LINE> <START_VULN> <TAB> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <NEW_LINE> <END_VULN> <TAB> <TAB> ext4_ext_try_to_merge ( inode , path , nearex ) ;
<TAB> <TAB> <TAB> sub_str_end_pos = ustr_len ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> if ( sub_str_start_pos > sub_str_end_pos ) { <NEW_LINE> <TAB> <TAB> intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "grapheme_substr : length is beyond start" , 1 TSRMLS_CC ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> byte_run = - byte_run ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> palette_idx1 = buf [ stream_ptr + + ] ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> palette_idx2 = buf [ stream_ptr + + ] ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> CHECK_PIXEL_PTR ( byte_run ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> for ( j = 0 ; j < byte_run ; j + + , pixel_countdown -= 2 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> pixels [ pixel_ptr + + ] = palette_idx1 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> pixels [ pixel_ptr + + ] = palette_idx2 ;
<TAB> _preextrapolate_helper ( v ) ; <NEW_LINE> <TAB> <TAB> [ at least ] a few full blocks of zeroes at the end . * / <NEW_LINE> <START_VULN> <TAB> vorbis_analysis_buffer ( v , ci -> blocksizes [ 1 ] * 3 ) ; <NEW_LINE> <END_VULN> <TAB> v -> eofflag = v -> pcm_current ; <NEW_LINE> <TAB> v -> pcm_current += ci -> blocksizes [ 1 ] * 3 ; <NEW_LINE> <TAB> for ( i = 0 ; i < vi -> channels ; i + + ) { <NEW_LINE> <TAB> if ( v -> eofflag > order * 2 ) { <NEW_LINE> <TAB> <TAB> long n ;
<START_VULN> <TAB> if ( op_reply == NULL ) { <NEW_LINE> <END_VULN> <TAB> <TAB> crm_err ( "No reply message - empty" ) ; <NEW_LINE> <TAB> <TAB> return - ENOMSG ; <NEW_LINE> <TAB> }
nsIFrame * mButtonFrame ; <NEW_LINE> nsIFrame * mDropdownFrame ; <NEW_LINE> nsIListControlFrame * mListControlFrame ; <NEW_LINE> nscoord mDisplayWidth ; <NEW_LINE> <START_VULN> bool mDroppedDown ; <NEW_LINE>bool mInRedisplayText ; <NEW_LINE><NEW_LINE> <END_VULN> nsRevocableEventPtr < RedisplayTextEvent > mRedisplayTextEvent ; <NEW_LINE> PRInt32 mRecentSelectedIndex ; <NEW_LINE> PRInt32 mDisplayedIndex ; <NEW_LINE> nsString mDisplayedOptionText ; <NEW_LINE> nsCOMPtr < nsIDOMEventListener > mButtonListener ; <NEW_LINE> static nsComboboxControlFrame * mFocused ; <NEW_LINE> #ifdef DO_REFLOW_COUNTER <NEW_LINE> PRInt32 mReflowId ; <NEW_LINE> #endif <NEW_LINE> } ;
#include < QPushButton > <NEW_LINE> #include "ui_confirmdeletiondlg . h" <NEW_LINE> #include "base / preferences . h" <NEW_LINE> <START_VULN> #include "guiiconprovider . h" <NEW_LINE> <END_VULN> #include "base / utils / misc . h" <NEW_LINE> class DeletionConfirmationDlg : public QDialog , private Ui : : confirmDeletionDlg { <NEW_LINE> Q_OBJECT
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "GHASH Message Digest Algorithm" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "ghash" ) ; <NEW_LINE> <END_VULN>
#ifndef WOFF_H_ <NEW_LINE> #define WOFF_H_ <NEW_LINE> #ifdef _MSC_VER <NEW_LINE> <START_VULN> typedef char int8_t ; <NEW_LINE> <END_VULN> typedef short int16_t ; <NEW_LINE> typedef int int32_t ; <NEW_LINE> typedef unsigned char uint8_t ; <NEW_LINE> typedef unsigned short uint16_t ; <NEW_LINE> typedef unsigned int uint32_t ; <NEW_LINE> typedef unsigned __int64 uint64_t ; <NEW_LINE> #else <NEW_LINE> #include < inttypes . h >
<TAB> <TAB> if ( plugin_data ) { <NEW_LINE> <TAB> <TAB> <TAB> mnd_efree ( plugin_data ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ret == PASS ) { <NEW_LINE> <TAB> <TAB> <TAB> DBG_INF_FMT ( "saving requested_protocol = % s" , requested_protocol ) ; <NEW_LINE> <TAB> <TAB> <TAB> conn -> m -> set_client_option ( conn , MYSQLND_OPT_AUTH_PROTOCOL , requested_protocol TSRMLS_CC ) ;
<TAB> * <NEW_LINE> <START_VULN> <TAB> if ( ssl3_ExtensionNegotiated ( ss , ssl_session_ticket_xtn ) && sid == NULL ) { <NEW_LINE> <END_VULN> <TAB> ssl3_RegisterServerHelloExtensionSender ( ss , <NEW_LINE> <TAB> ssl_session_ticket_xtn , ssl3_SendSessionTicketXtn ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( sid != NULL ) { <NEW_LINE> <TAB> rv = ssl3_InitPendingCipherSpec ( ss , NULL ) ; <NEW_LINE> <TAB> if ( rv != SECSuccess ) {
test_cmp_parameters inParam ; <NEW_LINE> FILE * fbase = NULL , * ftest = NULL ; <NEW_LINE> int same = 0 ; <NEW_LINE> <START_VULN> char lbase [ 256 ] ; <NEW_LINE>char strbase [ 256 ] ; <NEW_LINE>char ltest [ 256 ] ; <NEW_LINE>char strtest [ 256 ] ; <NEW_LINE> <END_VULN> if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) <NEW_LINE> <TAB> {
<TAB> <TAB> const PRUint16 platformID = ReadShortAt ( table , TableOffsetPlatformID ) ; <NEW_LINE> <TAB> <TAB> if ( ! acceptablePlatform ( platformID ) ) <NEW_LINE> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> const PRUint16 encodingID = ReadShortAt ( table , TableOffsetEncodingID ) ; <NEW_LINE> <TAB> <TAB> const PRUint32 offset = ReadLongAt ( table , TableOffsetOffset ) ; <NEW_LINE> <TAB> <TAB> NS_ASSERTION ( offset < aBufLength , "cmap table offset is longer than table size" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> NS_ENSURE_TRUE ( offset < aBufLength , NS_ERROR_FAILURE ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> const PRUint8 * subtable = aBuf + offset ; <NEW_LINE> <TAB> <TAB> const PRUint16 format = ReadShortAt ( subtable , SubtableOffsetFormat ) ; <NEW_LINE> <TAB> <TAB> if ( isSymbol ( platformID , encodingID ) ) { <NEW_LINE> <TAB> <TAB> <TAB> aUnicodeFont = PR_FALSE ; <NEW_LINE> <TAB> <TAB> <TAB> aSymbolFont = PR_TRUE ; <NEW_LINE> <TAB> <TAB> <TAB> keepFormat = format ;
<TAB> if ( data -> state != NULL ) { <NEW_LINE> <TAB> <TAB> struct nfs_delegation * delegation ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( can_open_cached ( data -> state , data -> o_arg . open_flags & ( FMODE_READ|FMODE_WRITE|O_EXCL ) ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> goto out_no_action ; <NEW_LINE> <TAB> <TAB> rcu_read_lock ( ) ; <NEW_LINE> <TAB> <TAB> delegation = rcu_dereference ( NFS_I ( data -> state -> inode ) -> delegation ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> rqstp -> rq_cred . oa_flavor ) ; <NEW_LINE> <TAB> if ( errmsg != NULL ) <NEW_LINE> <TAB> <TAB> krb5_free_error_message ( NULL , errmsg ) ; <NEW_LINE> <START_VULN> <TAB> gss_release_buffer ( & minor_stat , & client_name ) ; <NEW_LINE><TAB> gss_release_buffer ( & minor_stat , & service_name ) ; <NEW_LINE> <END_VULN> exit_func : <NEW_LINE> <TAB> return ( & ret ) ; <NEW_LINE> }
<TAB> <TAB> <TAB> JSObject * obj ; <NEW_LINE> <TAB> <TAB> <TAB> void * ptr ; <NEW_LINE> <TAB> <TAB> <TAB> JSWhyMagic why ; <NEW_LINE> <TAB> <TAB> <TAB> size_t word ; <NEW_LINE> <TAB> <TAB> } payload ; <NEW_LINE> <TAB> } s ; <NEW_LINE> <TAB> double asDouble ; <NEW_LINE> <TAB> void * asPtr ; <NEW_LINE> <START_VULN> } jsval_layout ; <NEW_LINE> <END_VULN> # elif JS_BITS_PER_WORD == 64 <NEW_LINE> typedef union jsval_layout <NEW_LINE> { <NEW_LINE> <TAB> uint64_t asBits ; <NEW_LINE> <TAB> struct { <NEW_LINE> <TAB> <TAB> JSValueTag tag : 17 ; <NEW_LINE> <TAB> <TAB> uint64_t payload47 : 47 ; <NEW_LINE> <TAB> } debugView ;
<TAB> } <NEW_LINE> <TAB> if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> ret = ext4_convert_unwritten_extents_endio ( handle , inode , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> path ) ; <NEW_LINE> <TAB> <TAB> if ( ret >= 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> ext4_update_inode_fsync_trans ( handle , inode , 1 ) ;
<TAB> <TAB> <TAB> <TAB> ret = FAIL ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> new_charset_name = mnd_pestrdup ( value , conn -> persistent ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ! new_charset_name ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto oom ;
<TAB> vcpu -> arch . cr2 = sregs -> cr2 ; <NEW_LINE> <TAB> mmu_reset_needed |= vcpu -> arch . cr3 != sregs -> cr3 ; <NEW_LINE> <START_VULN> <TAB> vcpu -> arch . cr3 = sregs -> cr3 ; <NEW_LINE> <END_VULN> <TAB> kvm_set_cr8 ( vcpu , sregs -> cr8 ) ;
<TAB> <TAB> <TAB> <TAB> cname = ( unsigned char * ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> & nbuf [ doff + prpsoffsets ( i ) ] ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> for ( cp = cname ; * cp && isprint ( * cp ) ; cp + + ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> continue ;
<TAB> } <NEW_LINE> <TAB> if ( tp -> tm_yday < 0 ) { <NEW_LINE> <TAB> <TAB> if ( tp -> tm_mon <= 11 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> tp -> tm_yday = ( leapYear ( tp -> tm_year + 1900 ) ? <NEW_LINE><TAB> <TAB> <TAB> leapMonthStart [ tp -> tm_mon ] : normalMonthStart [ tp -> tm_mon ] ) + tp -> tm_mday - 1 ; <NEW_LINE> <END_VULN> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> tp -> tm_yday = defaults -> tm_yday ; <NEW_LINE> <TAB> <TAB> }
{ <NEW_LINE> <TAB> load_abrt_conf ( ) ; <NEW_LINE> <START_VULN> <TAB> struct dump_dir * dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ; <NEW_LINE> <END_VULN> <TAB> char * problem_id = NULL ; <NEW_LINE> <TAB> if ( dd )
<TAB> case ACL_TYPE_ACCESS : <NEW_LINE> <TAB> <TAB> name = XATTR_NAME_POSIX_ACL_ACCESS ; <NEW_LINE> <TAB> <TAB> if ( acl ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> umode_t mode = inode -> i_mode ; <NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> error = posix_acl_equiv_mode ( acl , & mode ) ; <NEW_LINE><TAB> <TAB> <TAB> if ( error < 0 ) { <NEW_LINE><TAB> <TAB> <TAB> <TAB> gossip_err ( " % s : posix_acl_equiv_mode err : % d\n" , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> __func__ , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> error ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return error ;
<TAB> <TAB> Token currentToken ; <NEW_LINE> <TAB> <TAB> unsigned lookahead ; <NEW_LINE> <TAB> <TAB> Token lookaheadTokens [ maxLookahead ] ; <NEW_LINE> <TAB> } ; <NEW_LINE> <TAB> void advance ( size_t position ) ; <NEW_LINE> <TAB> void tell ( Position * ) ; <NEW_LINE> <TAB> void seek ( const Position & pos ) ; <NEW_LINE> <START_VULN> <TAB> void seek ( const Position & pos , const TokenStream & other ) ; <NEW_LINE> <END_VULN> <TAB> size_t positionToOffset ( const Position & pos ) const { <NEW_LINE> <TAB> <TAB> return pos . buf - userbuf . base ( ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> const jschar * rawBase ( ) const { <NEW_LINE> <TAB> <TAB> return userbuf . base ( ) ; <NEW_LINE> <TAB> }
int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> const char * name , int rep_quick ) <NEW_LINE> <END_VULN> { <NEW_LINE> int got_error ; <NEW_LINE> uint i , key , total_key_length , istep ;
<TAB> goto bail ; <NEW_LINE> } <NEW_LINE> <START_VULN> len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ; <NEW_LINE> <END_VULN> if ( len == - 1 ) <NEW_LINE> { <NEW_LINE> <TAB> mutt_debug ( 1 , "Error decoding base64 response . \n" ) ;
<TAB> <TAB> mm -> context . execute_only_pkey = - 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> #endif <NEW_LINE> <START_VULN> <TAB> init_new_context_ldt ( tsk , mm ) ; <NEW_LINE><NEW_LINE><TAB> return 0 ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline void destroy_context ( struct mm_struct * mm ) <NEW_LINE> {
<TAB> <TAB> errx ( EXIT_FAILURE , _ ( "Shell * NOT * changed . Try again later . " ) ) ; <NEW_LINE> #else <NEW_LINE> <TAB> pw -> pw_shell = info . shell ; <NEW_LINE> <START_VULN> <TAB> if ( setpwnam ( pw ) < 0 ) <NEW_LINE> <END_VULN> <TAB> <TAB> err ( EXIT_FAILURE , _ ( "setpwnam failed\n" <NEW_LINE> <TAB> <TAB> <TAB> "Shell * NOT * changed . Try again later . " ) ) ; <NEW_LINE> #endif
<TAB> struct ip_options <TAB> opt ; <TAB> <TAB> <NEW_LINE> <TAB> unsigned char <TAB> <TAB> flags ; <NEW_LINE> <START_VULN> #define IPSKB_FORWARDED <TAB> <TAB> 1 <NEW_LINE>#define IPSKB_XFRM_TUNNEL_SIZE <TAB> 2 <NEW_LINE>#define IPSKB_XFRM_TRANSFORMED <TAB> 4 <NEW_LINE>#define IPSKB_FRAG_COMPLETE <TAB> 8 <NEW_LINE>#define IPSKB_REROUTED <TAB> <TAB> 16 <NEW_LINE> <END_VULN> <TAB> u16 <TAB> <TAB> <TAB> frag_max_size ; <NEW_LINE> } ;
<TAB> <TAB> <TAB> char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ; <NEW_LINE> <TAB> <TAB> <TAB> * new_path = '\0' ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( strlen ( location ) < 8 || ( strncasecmp ( location , "http : <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> strncasecmp ( location , "https : <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> strncasecmp ( location , "ftp : <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> strncasecmp ( location , "ftps : <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( * location != ' / ' ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> if ( * ( location + 1 ) != '\0' && resource -> path ) {
<TAB> uint32_t str_key_len , base_len = p_obj -> l ; <NEW_LINE> <TAB> phar_entry_data * data ; <NEW_LINE> <TAB> php_stream * fp ; <NEW_LINE> <START_VULN> <TAB> php_stat_len fname_len ; <NEW_LINE> <END_VULN> <TAB> size_t contents_len ; <NEW_LINE> <TAB> char * fname , * error = NULL , * base = p_obj -> b , * save = NULL , * temp = NULL ; <NEW_LINE> <TAB> zend_string * opened ;
<TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> efree ( offsets ) ; <NEW_LINE> }
** h / H - signed / unsigned short <NEW_LINE> ** l / L - signed / unsigned long <NEW_LINE> ** T - size_t <NEW_LINE> <START_VULN> ** i / In - signed / unsigned integer with size `n' ( default is size of int ) <NEW_LINE> ** cn - sequence of `n' chars ( from / to a string ) ; when packing , n == 0 means <NEW_LINE> <END_VULN> <TAB> <TAB> the whole string ; when unpacking , n == 0 means use the previous <NEW_LINE> <TAB> <TAB> read number as the string length <NEW_LINE> ** s - zero - terminated string
nsRefPtr < nsRange > mMaintainRange ; <NEW_LINE> nsSelectionAmount mMaintainedAmount ; <NEW_LINE> PRInt32 mBatching ; <NEW_LINE> <START_VULN> nsIContent * mLimiter ; <NEW_LINE>nsIContent * mAncestorLimiter ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> nsIPresShell * mShell ; <NEW_LINE> PRInt16 mSelectionChangeReason ; <NEW_LINE> PRInt16 mDisplaySelection ; <NEW_LINE> HINT mHint ; <NEW_LINE> #ifdef IBMBIDI <NEW_LINE> PRUint8 mCaretBidiLevel ;
<TAB> uint16_t desired_port = g_options . desired_port ; <NEW_LINE> <START_VULN> <TAB> struct tcp_sock_t * tcp_socket ; <NEW_LINE><TAB> while ( ( tcp_socket = tcp_open ( desired_port ) ) == NULL && <NEW_LINE><TAB> g_options . only_desired_port == 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> desired_port + + ;
<START_VULN> { <NEW_LINE> <END_VULN> <TAB> long bp = _ve_envelope_search ( v ) ; <NEW_LINE> <TAB> if ( bp == - 1 ) { <NEW_LINE> <TAB> if ( v -> eofflag == 0 ) return ( 0 ) ; <NEW_LINE> <TAB> v -> nW = 0 ; <NEW_LINE> <TAB> } else {
<TAB> <TAB> <TAB> return HB_WORK_DONE ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> pv -> context = avcodec_alloc_context3 ( codec ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> pv -> context -> workaround_bugs = FF_BUG_AUTODETECT ; <NEW_LINE> <TAB> <TAB> pv -> context -> err_recognition = AV_EF_CRCCHECK ; <NEW_LINE> <TAB> <TAB> pv -> context -> error_concealment = FF_EC_GUESS_MVS|FF_EC_DEBLOCK ;
<TAB> | Sara Golemon < pollita@php . net > | <NEW_LINE> <TAB> + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- + <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "php . h" <NEW_LINE> #include "php_globals . h"
<TAB> if ( i == ch ) return ( 0 ) ; <NEW_LINE> <TAB> for ( s = 0 ; s < look -> stages ; s + + ) { <NEW_LINE> <TAB> for ( i = 0 , l = 0 ; i < partvals ; l + + ) { <NEW_LINE> <TAB> <TAB> if ( s == 0 ) { <NEW_LINE> <TAB> <TAB> int temp = vorbis_book_decode ( look -> phrasebook , & vb -> opb ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( temp == - 1 ) goto eopbreak ; <NEW_LINE> <END_VULN> <TAB> <TAB> partword [ l ] = look -> decodemap [ temp ] ; <NEW_LINE> <TAB> <TAB> if ( partword [ l ] == NULL ) goto errout ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> for ( k = 0 ; k < partitions_per_word && i < partvals ; k + + , i + + ) <NEW_LINE> <TAB> <TAB> if ( info -> secondstages [ partword [ l ] [ k ] ] & ( 1 << s ) ) { <NEW_LINE> <TAB> <TAB> <TAB> codebook * stagebook = look -> partbooks [ partword [ l ] [ k ] ] [ s ] ;
<TAB> return emulate_exception ( ctxt , NM_VECTOR , 0 , false ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> switch ( ctxt -> op_bytes ) { <NEW_LINE> <TAB> case 2 :
<TAB> __u8 <TAB> <TAB> conf_req [ 64 ] ; <NEW_LINE> <TAB> __u8 <TAB> <TAB> conf_len ; <NEW_LINE> <TAB> __u8 <TAB> <TAB> conf_state ; <NEW_LINE> <START_VULN> <TAB> __u8 <TAB> <TAB> conf_retry ; <NEW_LINE> <END_VULN> <TAB> __u8 <TAB> <TAB> ident ; <NEW_LINE> <TAB> __le16 <TAB> <TAB> sport ; <NEW_LINE> <TAB> struct l2cap_conn <TAB> * conn ;
NS_COM const nsAFlatCString & EmptyCString ( ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> - <NEW_LINE> <END_VULN> 1 . 4 . 1
bool verify_authorizer ( CephContext * cct , KeyStore * keys , <NEW_LINE> <TAB> <TAB> <TAB> bufferlist & authorizer_data , bufferlist & authorizer_reply , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> EntityName & entity_name , uint64_t & global_id , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> AuthCapsInfo & caps_info , CryptoKey & session_key , uint64_t * auid = NULL ) override ; <NEW_LINE> <END_VULN> int authorizer_session_crypto ( ) override ; <NEW_LINE> } ;
<TAB> darray_append ( expr -> keysym_list . symsNumEntries , numEntries ) ; <NEW_LINE> <TAB> darray_concat ( expr -> keysym_list . syms , append -> keysym_list . syms ) ; <NEW_LINE> <START_VULN> <TAB> FreeStmt ( ( ParseCommon * ) & append ) ; <NEW_LINE> <END_VULN> <TAB> return expr ; <NEW_LINE> }
#include < stdlib . h > <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < ctype . h > <NEW_LINE> <START_VULN> #include "compiler / debug . h" <NEW_LINE> <END_VULN> #include "compiler / preprocessor / slglobals . h" <NEW_LINE> #include "compiler / util . h"
<TAB> <TAB> dev_dbg ( & urb -> dev -> dev , " % s - event received\n" , __func__ ) ; <NEW_LINE> <START_VULN> <TAB> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <NEW_LINE> <END_VULN> <TAB> <TAB> memcpy ( command_info -> result_buffer , & data [ 1 ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> urb -> actual_length - 1 ) ; <NEW_LINE> <TAB> <TAB> command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;
<TAB> rsrc . str_index = - 1 ; <NEW_LINE> <TAB> for ( k = 0 ; k < rsrc . type_count ; k + + ) <NEW_LINE> <START_VULN> <TAB> { <TAB> marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( marker == STR_MARKER ) <NEW_LINE> <TAB> <TAB> { <TAB> rsrc . str_index = k ;
<TAB> <TAB> rcu_read_lock ( ) ; <NEW_LINE> <TAB> <TAB> indev = __in_dev_get_rcu ( skb -> dev ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( indev != NULL ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ifa = indev -> ifa_list ; <NEW_LINE> <TAB> <TAB> <TAB> newdst = ifa -> ifa_local ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> <TAB> <TAB> while ( ns -- > 0 && cp && cp < end ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> zval * retval = NULL ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> cp = php_parserr ( cp , & answer , DNS_T_ANY , authns != NULL , raw , & retval ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> if ( retval != NULL ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> add_next_index_zval ( authns , retval ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> }
#define free ( ptr ) hunspell_free ( ptr ) <NEW_LINE> inline void * hunspell_realloc ( void * ptr , size_t size ) <NEW_LINE> { <NEW_LINE> HunspellReportMemoryDeallocation ( ptr ) ; <NEW_LINE> void * result = moz_realloc ( ptr , size ) ; <NEW_LINE> if ( result ) { <NEW_LINE> <TAB> HunspellReportMemoryAllocation ( result ) ; <NEW_LINE> <START_VULN> } else { <NEW_LINE> <END_VULN> <TAB> HunspellReportMemoryAllocation ( ptr ) ; <NEW_LINE> } <NEW_LINE> return result ; <NEW_LINE> } <NEW_LINE> #define realloc ( ptr , size ) hunspell_realloc ( ptr , size ) <NEW_LINE> inline char * hunspell_strdup ( const char * str )
<TAB> flags |= IS_RDONLY ( d_inode ( lower_dentry ) ) ? O_RDONLY : O_RDWR ; <NEW_LINE> <TAB> ( * lower_file ) = dentry_open ( & req . path , flags , cred ) ; <NEW_LINE> <TAB> if ( ! IS_ERR ( * lower_file ) ) <NEW_LINE> <START_VULN> <TAB> <TAB> goto out ; <NEW_LINE> <END_VULN> <TAB> if ( ( flags & O_ACCMODE ) == O_RDONLY ) { <NEW_LINE> <TAB> <TAB> rc = PTR_ERR ( ( * lower_file ) ) ; <NEW_LINE> <TAB> <TAB> goto out ;
module_init ( sit_init ) ; <NEW_LINE> module_exit ( sit_cleanup ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sit0" ) ; <NEW_LINE> <END_VULN>
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Deflate Compression Algorithm for IPCOMP" ) ; <NEW_LINE> MODULE_AUTHOR ( "James Morris < jmorris@intercode . com . au > " ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
module_init ( ghash_mod_init ) ; <NEW_LINE> module_exit ( ghash_mod_exit ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "ghash" ) ; <NEW_LINE> <END_VULN> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "GHASH Message Digest Algorithm , s390 implementation" ) ;
<TAB> <TAB> <TAB> memcpy ( new_bh -> b_data , header , new_bh -> b_size ) ; <NEW_LINE> <TAB> <TAB> <TAB> set_buffer_uptodate ( new_bh ) ; <NEW_LINE> <TAB> <TAB> <TAB> unlock_buffer ( new_bh ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> ext2_xattr_cache_insert ( new_bh ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ext2_xattr_update_super_block ( sb ) ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> return counts ; <NEW_LINE> <TAB> } <NEW_LINE> private : <NEW_LINE> <TAB> bool addGetPropertyCache ( LInstruction * ins , RegisterSet liveRegs , Register objReg , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PropertyName * name , TypedOrValueRegister output , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool allowGetters ) ; <NEW_LINE> <TAB> bool addGetElementCache ( LInstruction * ins , Register obj , ConstantOrRegister index , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> TypedOrValueRegister output , bool monitoredResult ) ; <NEW_LINE> <END_VULN> <TAB> bool checkForAbortPar ( LInstruction * lir ) ; <NEW_LINE> <TAB> bool generateBranchV ( const ValueOperand & value , Label * ifTrue , Label * ifFalse , FloatRegister fr ) ; <NEW_LINE> <TAB> bool emitAllocateGCThingPar ( LInstruction * lir , const Register & objReg , const Register & sliceReg , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const Register & tempReg1 , const Register & tempReg2 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * templateObj ) ;
<TAB> if ( err > 0 ) { <NEW_LINE> <TAB> <TAB> signo = SIGCHLD ; <NEW_LINE> <TAB> <TAB> err = 0 ; <NEW_LINE> <START_VULN> <TAB> } <NEW_LINE><NEW_LINE><TAB> if ( ! err && uru ) { <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> if ( COMPAT_USE_64BIT_TIME ) <NEW_LINE><TAB> <TAB> <TAB> err = copy_to_user ( uru , & ru , sizeof ( ru ) ) ; <NEW_LINE><TAB> <TAB> else <NEW_LINE><TAB> <TAB> <TAB> err = put_compat_rusage ( & ru , uru ) ; <NEW_LINE><TAB> <TAB> if ( err ) <NEW_LINE><TAB> <TAB> <TAB> return - EFAULT ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( ! infop )
<START_VULN> <TAB> if ( tsk != current ) <NEW_LINE> <END_VULN> <TAB> <TAB> return ; <NEW_LINE> <TAB> if ( MSR_TM_SUSPENDED ( mfmsr ( ) ) ) {
<TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) > 0 ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> p_buff + 8 + sizeof ( BITMAPINFOHEADER ) ,
<TAB> if ( IsAnimValList ( ) ) { <NEW_LINE> <TAB> Element ( ) -> FlushAnimations ( ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return LengthNoFlush ( ) ; <NEW_LINE> } <NEW_LINE> void Clear ( ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGLength > Initialize ( nsIDOMSVGLength * newItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> <START_VULN> nsIDOMSVGLength * GetItem ( uint32_t index , ErrorResult & error ) <NEW_LINE> { <NEW_LINE><TAB> bool found ; <NEW_LINE><TAB> nsIDOMSVGLength * item = IndexedGetter ( index , found , error ) ; <NEW_LINE><TAB> if ( ! found ) { <NEW_LINE><TAB> error . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; <NEW_LINE><TAB> } <NEW_LINE><TAB> return item ; <NEW_LINE> } <NEW_LINE>nsIDOMSVGLength * IndexedGetter ( uint32_t index , bool & found , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> <END_VULN> already_AddRefed < nsIDOMSVGLength > InsertItemBefore ( nsIDOMSVGLength * newItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t index , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGLength > ReplaceItem ( nsIDOMSVGLength * newItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t index , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGLength > RemoveItem ( uint32_t index , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ;
<TAB> perf_unpin_context ( ctx ) ; <NEW_LINE> <TAB> if ( move_group ) <NEW_LINE> <START_VULN> <TAB> <TAB> mutex_unlock ( & gctx -> mutex ) ; <NEW_LINE> <END_VULN> <TAB> mutex_unlock ( & ctx -> mutex ) ; <NEW_LINE> <TAB> if ( task ) {
<TAB> <TAB> list_add ( & match -> list , & fanout_list ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> err = - EINVAL ; <NEW_LINE> <START_VULN> <TAB> if ( match -> type == type && <NEW_LINE> <END_VULN> <TAB> match -> prot_hook . type == po -> prot_hook . type && <NEW_LINE> <TAB> match -> prot_hook . dev == po -> prot_hook . dev ) { <NEW_LINE> <TAB> <TAB> err = - ENOSPC ;
<TAB> <TAB> return error ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN> <TAB> destreg = ( opcode >> 4 ) & 0x3f ; <NEW_LINE> <TAB> if ( user_mode ( regs ) ) {
<TAB> add_next_index_stringl ( match_pair , str , len , 1 ) ; <NEW_LINE> <TAB> add_next_index_long ( match_pair , offset ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> if ( name ) { <NEW_LINE> <TAB> <TAB> zval_add_ref ( & match_pair ) ; <NEW_LINE> <TAB> <TAB> zend_hash_update ( Z_ARRVAL_P ( result ) , name , strlen ( name ) + 1 , & match_pair , sizeof ( zval * ) , NULL ) ;
<TAB> } <NEW_LINE> <TAB> nsems = sma -> sem_nsems ; <NEW_LINE> <START_VULN> <TAB> ipc_rcu_getref ( sma ) ; <NEW_LINE> <END_VULN> <TAB> rcu_read_unlock ( ) ;
<TAB> phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> }
virtual already_AddRefed < mozilla : : dom : : UndoManager > GetUndoManager ( ) ; <NEW_LINE> virtual bool UndoScope ( ) MOZ_OVERRIDE ; <NEW_LINE> virtual void SetUndoScope ( bool aUndoScope , mozilla : : ErrorResult & aError ) MOZ_OVERRIDE ; <NEW_LINE> nsresult ClearDataset ( ) ; <NEW_LINE> <START_VULN> nsSize GetWidthHeightForImage ( imgIRequest * aImageRequest ) ; <NEW_LINE> <END_VULN> NS_FORWARD_NSIDOMNODE_TO_NSINODE <NEW_LINE> NS_FORWARD_NSIDOMELEMENT_TO_GENERIC <NEW_LINE> NS_IMETHOD GetId ( nsAString & aId ) MOZ_FINAL { <NEW_LINE> <TAB> mozilla : : dom : : Element : : GetId ( aId ) ;
<TAB> <TAB> for ( conn_opt = conn_opts ; conn_opt -> keyword != NULL ; conn_opt + + ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> keywords [ i ] = conn_opt -> keyword ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> values [ i ] = conn_opt -> val ;
inp = buf -> base ; <NEW_LINE> max = buf -> base + buf -> next - trunto ; <NEW_LINE> <START_VULN> if ( ( ret = xd3_read_uint32_t ( stream , & inp , max , & rval ) ) != <NEW_LINE> <END_VULN> <TAB> XD3_INVALID_INPUT || <NEW_LINE> <TAB> ! MSG_IS ( msg ) ) <NEW_LINE> <TAB> {
<TAB> int haystack_len , needle_len ; <NEW_LINE> <TAB> unsigned char * found ; <NEW_LINE> <TAB> long loffset = 0 ; <NEW_LINE> <START_VULN> <TAB> int32_t offset = 0 ; <NEW_LINE> <END_VULN> <TAB> int ret_pos ; <NEW_LINE> <TAB> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "ss|l" , ( char ** ) & haystack , & haystack_len , ( char ** ) & needle , & needle_len , & loffset ) == FAILURE ) {
void InsertTimeoutIntoList ( nsTimeout * aTimeout ) ; <NEW_LINE> static void TimerCallback ( nsITimer * aTimer , void * aClosure ) ; <NEW_LINE> nsresult GetTreeOwner ( nsIDocShellTreeOwner ** aTreeOwner ) ; <NEW_LINE> nsresult GetTreeOwner ( nsIBaseWindow ** aTreeOwner ) ; <NEW_LINE> nsresult GetWebBrowserChrome ( nsIWebBrowserChrome ** aBrowserChrome ) ; <NEW_LINE> nsresult SecurityCheckURL ( const char * aURL ) ; <NEW_LINE> <START_VULN> nsresult BuildURIfromBase ( const char * aURL , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIURI ** aBuiltURI , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool * aFreeSecurityPass , JSContext ** aCXused ) ; <NEW_LINE> <END_VULN> bool PopupWhitelisted ( ) ; <NEW_LINE> PopupControlState RevisePopupAbuseLevel ( PopupControlState ) ; <NEW_LINE> void FireAbuseEvents ( bool aBlocked , bool aWindow , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsAString & aPopupURL , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsAString & aPopupWindowName , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsAString & aPopupWindowFeatures ) ; <NEW_LINE> void FireOfflineStatusEvent ( ) ;
<TAB> down_read ( & uts_sem ) ; <NEW_LINE> <TAB> res = sysinfo_table [ offset ] ; <NEW_LINE> <TAB> len = strlen ( res ) + 1 ; <NEW_LINE> <START_VULN> <TAB> if ( len > count ) <NEW_LINE> <END_VULN> <TAB> <TAB> len = count ; <NEW_LINE> <TAB> if ( copy_to_user ( buf , res , len ) ) <NEW_LINE> <TAB> <TAB> err = - EFAULT ;
<TAB> if ( NULL == siocb -> scm ) <NEW_LINE> <TAB> <TAB> siocb -> scm = & scm ; <NEW_LINE> <START_VULN> <TAB> err = scm_send ( sock , msg , siocb -> scm ) ; <NEW_LINE> <END_VULN> <TAB> if ( err < 0 ) <NEW_LINE> <TAB> <TAB> return err ;
<TAB> atomic_t xfer_avail ; <NEW_LINE> <TAB> struct gpio_chip gc ; <NEW_LINE> <TAB> u8 * in_out_buffer ; <NEW_LINE> <START_VULN> <TAB> spinlock_t lock ; <NEW_LINE> <END_VULN> <TAB> struct gpio_desc * desc [ 8 ] ; <NEW_LINE> <TAB> bool gpio_poll ;
uint32_t mBufferingWait ; <NEW_LINE> int64_t mLowDataThresholdUsecs ; <NEW_LINE> uint32_t mAmpleVideoFrames ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> bool mAudioCaptured ; <NEW_LINE> bool mTransportSeekable ;
<TAB> int ret ; <NEW_LINE> <TAB> while ( ptr ) { <NEW_LINE> <START_VULN> <TAB> <TAB> ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ret ) <NEW_LINE> <TAB> <TAB> <TAB> return - EFAULT ; <NEW_LINE> <TAB> <TAB> param += sizeof ( struct floppy_raw_cmd ) ;
<TAB> fclose ( orig ) ; <NEW_LINE> <TAB> fclose ( recons ) ; <NEW_LINE> <START_VULN> <TAB> if ( diffs != 0 ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> return XD3_INTERNAL ; <NEW_LINE> <TAB> }
<TAB> <TAB> oggpack_write ( opb , 0 , 32 ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> } <NEW_LINE> oggpack_write ( opb , 1 , 1 ) ; <NEW_LINE> return ( 0 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> static int _vorbis_pack_books ( oggpack_buffer * opb , vorbis_info * vi ) { <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> int i ; <NEW_LINE> if ( ! ci ) return ( OV_EFAULT ) ; <NEW_LINE> oggpack_write ( opb , 0x05 , 8 ) ; <NEW_LINE> _v_writestring ( opb , "vorbis" , 6 ) ;
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> if ( type == R_STRING_TYPE_DETECT ) { <NEW_LINE> <TAB> <TAB> <TAB> char * w = ( char * ) buf + needle + rc - from ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( ( to - needle ) > 5 ) { <NEW_LINE><TAB> <TAB> <TAB> <TAB> bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> if ( is_wide32 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> str_type = R_STRING_TYPE_WIDE32 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } else {
<TAB> if ( ! arp_checkentry ( & e -> arp ) ) <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <START_VULN> <TAB> ret = xt_compat_check_entry_offsets ( e , e -> target_offset , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> e -> next_offset ) ; <NEW_LINE> <TAB> if ( ret ) <NEW_LINE> <TAB> <TAB> return ret ;
<TAB> void ImplSetSize ( sal_uInt16 nSize , bool bResize = true ) ; <NEW_LINE> <TAB> void ImplCreateFlagArray ( ) ; <NEW_LINE> <START_VULN> <TAB> void ImplSplit ( sal_uInt16 nPos , sal_uInt16 nSpace , ImplPolygon const * pInitPoly = nullptr ) ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> #define MAX_POLYGONS ( ( sal_uInt16 ) 0x3FF0 )
<TAB> next_image -> depth = 16 ; <NEW_LINE> monochrome = IsImageMonochrome ( image ) && ( image -> depth == 1 ) ? <NEW_LINE> <TAB> MagickTrue : MagickFalse ; <NEW_LINE> <START_VULN> quantum_info = AcquireQuantumInfo ( image_info , image ) ; <NEW_LINE> <END_VULN> if ( quantum_info == ( QuantumInfo * ) NULL ) <NEW_LINE> <TAB> return ( 0 ) ; <NEW_LINE> pixels = ( unsigned char * ) GetQuantumPixels ( quantum_info ) ;
<TAB> <TAB> <TAB> . tcpv_rttcnt = ca -> cnt_rtt , <NEW_LINE> <TAB> <TAB> <TAB> . tcpv_minrtt = ca -> base_rtt , <NEW_LINE> <TAB> <TAB> } ; <NEW_LINE> <START_VULN> <TAB> <TAB> u64 t = ca -> sum_rtt ; <NEW_LINE><TAB> <TAB> do_div ( t , ca -> cnt_rtt ) ; <NEW_LINE><TAB> <TAB> info . tcpv_rtt = t ; <NEW_LINE> <END_VULN> <TAB> <TAB> nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info ) , & info ) ; <NEW_LINE> <TAB> } <NEW_LINE> }
<START_VULN> <TAB> blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; <NEW_LINE> <END_VULN> <TAB> error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> XFS_ATTR_FORK ) ; <NEW_LINE> <TAB> if ( error )
<TAB> <TAB> x86_pmu . event_constraints = intel_ivb_event_constraints ; <NEW_LINE> <TAB> <TAB> x86_pmu . pebs_constraints = intel_ivb_pebs_event_constraints ; <NEW_LINE> <TAB> <TAB> x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <NEW_LINE> <START_VULN> <TAB> <TAB> x86_pmu . extra_regs = intel_snb_extra_regs ; <NEW_LINE> <END_VULN> <TAB> <TAB> x86_pmu . er_flags |= ERF_HAS_RSP_1 ; <NEW_LINE> <TAB> <TAB> x86_pmu . er_flags |= ERF_NO_HT_SHARING ;
<TAB> <TAB> kdebug ( " - % u" , key -> serial ) ; <NEW_LINE> <TAB> <TAB> key_check ( key ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE><TAB> <TAB> if ( key -> type -> destroy ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> key -> type -> destroy ( key ) ; <NEW_LINE> <TAB> <TAB> security_key_free ( key ) ;
<TAB> } <NEW_LINE> <TAB> ~ nsTextShadowArray ( ) { <NEW_LINE> <TAB> MOZ_COUNT_DTOR ( nsTextShadowArray ) ; <NEW_LINE> <TAB> for ( PRUint32 i = 1 ; i < mLength ; + + i ) { <NEW_LINE> <TAB> <TAB> mArray [ i ] . ~ nsTextShadowItem ( ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> nsrefcnt AddRef ( ) { return + + mRefCnt ; } <NEW_LINE> <END_VULN> <TAB> nsrefcnt Release ( ) ; <NEW_LINE> <TAB> PRUint32 Length ( ) const { return mLength ; } <NEW_LINE> <TAB> nsTextShadowItem * ShadowAt ( PRUint32 i ) { <NEW_LINE> <TAB> NS_ABORT_IF_FALSE ( i < mLength , "Accessing too high an index in the text shadow array ! " ) ; <NEW_LINE> <TAB> return & mArray [ i ] ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> const nsTextShadowItem * ShadowAt ( PRUint32 i ) const {
<TAB> } <NEW_LINE> # else <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) , <NEW_LINE><TAB> <TAB> <TAB> top = p -> top ; <NEW_LINE> <END_VULN> <TAB> <TAB> BN_ULONG * udp , * bdp , * vdp , * cdp ; <NEW_LINE> <TAB> <TAB> bn_wexpand ( u , top ) ;
<TAB> rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ; <NEW_LINE> <START_VULN> <TAB> if ( ctxt -> rip_relative ) <NEW_LINE> <END_VULN> <TAB> <TAB> ctxt -> memopp -> addr . mem . ea = address_mask ( ctxt , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ;
<START_VULN> <TAB> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <NEW_LINE><TAB> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> EXPORT_SYMBOL ( jiffies_to_timespec ) ;
struct ipc_rcu_hdr <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> int refcount ; <NEW_LINE> <END_VULN> <TAB> int is_vmalloc ; <NEW_LINE> <TAB> void * data [ 0 ] ; <NEW_LINE> } ;
<TAB> size_t result_len = 0 ; <NEW_LINE> <TAB> const char * data = _data , * end , * opt ; <NEW_LINE> <START_VULN> <TAB> kenter ( " % % % d , % s , ' % s' , % zu" , <NEW_LINE><TAB> key -> serial , key -> description , data , datalen ) ; <NEW_LINE> <END_VULN> <TAB> if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' ) <NEW_LINE> <TAB> <TAB> return - EINVAL ;
<TAB> [ BPF_EXIT >> 4 ] = "exit" , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static void print_bpf_insn ( struct bpf_insn * insn ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> u8 class = BPF_CLASS ( insn -> code ) ;
<TAB> if ( ! UNIXCB ( skb ) . fp ) <NEW_LINE> <TAB> <TAB> return - ENOMEM ; <NEW_LINE> <START_VULN> <TAB> if ( unix_sock_count ) { <NEW_LINE><TAB> <TAB> for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <NEW_LINE><TAB> <TAB> <TAB> unix_inflight ( scm -> fp -> fp [ i ] ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> return max_level ; <NEW_LINE> }
<TAB> } <NEW_LINE> <TAB> if ( src != tmp_im ) { <NEW_LINE> <START_VULN> <TAB> <TAB> gdFree ( tmp_im ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return dst ;
<TAB> if ( ret < 0 ) { <NEW_LINE> <TAB> <TAB> dev_warn ( dev , "Failed to get K90 initial mode ( error % d ) . \n" , <NEW_LINE> <TAB> <TAB> <TAB> ret ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> return - EIO ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> switch ( data [ 0 ] ) {
kSqrt = ( 12 << 8 ) + 26 , <NEW_LINE> kDup = ( 12 << 8 ) + 27 , <NEW_LINE> kExch = ( 12 << 8 ) + 28 , <NEW_LINE> kIndex = ( 12 << 8 ) + 29 , <NEW_LINE> kRoll = ( 12 << 8 ) + 30 , <NEW_LINE> kHFlex = ( 12 << 8 ) + 34 , <NEW_LINE> kFlex = ( 12 << 8 ) + 35 , <NEW_LINE> kHFlex1 = ( 12 << 8 ) + 36 , <NEW_LINE> <START_VULN> kFlex1 = ( 12 << 8 ) + 37 , <NEW_LINE> <END_VULN> } ; <NEW_LINE> } <NEW_LINE> #endif
<TAB> if ( res ) <NEW_LINE> <TAB> <TAB> goto out ; <NEW_LINE> <START_VULN> <TAB> kzfree ( raw_key ) ; <NEW_LINE><TAB> raw_key = NULL ; <NEW_LINE><TAB> if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) != NULL ) { <NEW_LINE><TAB> <TAB> put_crypt_info ( crypt_info ) ; <NEW_LINE><TAB> <TAB> goto retry ; <NEW_LINE><TAB> } <NEW_LINE><TAB> return 0 ; <NEW_LINE><NEW_LINE> <END_VULN> out : <NEW_LINE> <TAB> if ( res == - ENOKEY ) <NEW_LINE> <TAB> <TAB> res = 0 ;
<TAB> <TAB> <TAB> <TAB> <TAB> GtkWindow * parent_window , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> NautilusCopyCallback done_callback , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> gpointer done_callback_data ) ; <NEW_LINE> <START_VULN> void nautilus_file_mark_desktop_file_trusted ( GFile * file , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> GtkWindow * parent_window , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> gboolean interactive , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> NautilusOpCallback done_callback , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> gpointer done_callback_data ) ; <NEW_LINE> <END_VULN> void nautilus_file_operations_extract_files ( GList * files , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> GFile * destination_directory , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> GtkWindow * parent_window ,
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm , Supplemental SSE3 accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha1" ) ; <NEW_LINE> <END_VULN>
<TAB> struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; <NEW_LINE> <TAB> struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; <NEW_LINE> <TAB> int brightness ; <NEW_LINE> <START_VULN> <TAB> char data [ 8 ] ; <NEW_LINE> <END_VULN> <TAB> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , <NEW_LINE> <TAB> <TAB> <TAB> K90_REQUEST_STATUS ,
<TAB> <TAB> <TAB> Sdb * sdb_parent = sdb_new0 ( ) ; <NEW_LINE> <TAB> <TAB> <TAB> isum += aux . vda_next ; <NEW_LINE> <TAB> <TAB> <TAB> vstart += aux . vda_next ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> sdb_free ( sdb_verdef ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> sdb_free ( sdb_parent ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto out_error ;
<TAB> if ( ! s -> initialized ) { <NEW_LINE> <TAB> <TAB> ff_vp8_decode_init ( avctx ) ; <NEW_LINE> <TAB> <TAB> s -> initialized = 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( s -> has_alpha ) <NEW_LINE><TAB> <TAB> <TAB> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> s -> lossless = 0 ; <NEW_LINE> <TAB> if ( data_size > INT_MAX ) {
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> else { <NEW_LINE> <TAB> <TAB> <TAB> int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> char * buff = malloc ( bytes_to_copy ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( debug_logging_mode ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> error_line ( "extra unknown chunk \" % c % c % c % c\" of % d bytes" ,
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : PCM data vector blocking , windowing and dis / reassembly <NEW_LINE> <START_VULN> last mod : $ Id : block . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> Handle windowing , overlap - add , etc of the PCM vectors . This is made <NEW_LINE> more amusing by Vorbis' current two allowed block sizes . <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < stdlib . h >
<START_VULN> <TAB> <NEW_LINE>nsDOMDataTransfer ( uint32_t aEventType , bool aIsExternal ) ; <NEW_LINE> <END_VULN> void GetDragTarget ( nsIDOMElement ** aDragTarget ) <NEW_LINE> { <NEW_LINE> <TAB> * aDragTarget = mDragTarget ; <NEW_LINE> <TAB> NS_IF_ADDREF ( * aDragTarget ) ; <NEW_LINE> }
<TAB> int fr , j , n , ch , ret ; <NEW_LINE> <START_VULN> <TAB> s -> frame -> nb_samples = MPA_FRAME_SIZE ; <NEW_LINE> <END_VULN> <TAB> if ( ( ret = avctx -> get_buffer ( avctx , s -> frame ) ) < 0 ) { <NEW_LINE> <TAB> <TAB> av_log ( avctx , AV_LOG_ERROR , "get_buffer ( ) failed\n" ) ; <NEW_LINE> <TAB> <TAB> return ret ;
<TAB> <TAB> <TAB> <TAB> LOG ( ( "userfonts ( % p ) [ src % d ] failed uri : ( % s ) for ( % s ) error making platform font\n" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> this , pe -> mSrcIndex , fontURI . get ( ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> NS_ConvertUTF16toUTF8 ( pe -> mFamily -> Name ( ) ) . get ( ) ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> #endif <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( aFontData ) { <NEW_LINE><TAB> <TAB> <TAB> NS_Free ( ( void * ) aFontData ) ; <NEW_LINE><TAB> <TAB> } <NEW_LINE> <END_VULN> #ifdef PR_LOGGING <NEW_LINE> <TAB> <TAB> if ( LOG_ENABLED ( ) ) { <NEW_LINE> <TAB> <TAB> <TAB> nsCAutoString fontURI ; <NEW_LINE> <TAB> <TAB> <TAB> pe -> mSrcList [ pe -> mSrcIndex ] . mURI -> GetSpec ( fontURI ) ; <NEW_LINE> <TAB> <TAB> <TAB> LOG ( ( "userfonts ( % p ) [ src % d ] failed uri : ( % s ) for ( % s ) error % 8 . 8x downloading font data\n" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> this , pe -> mSrcIndex , fontURI . get ( ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> NS_ConvertUTF16toUTF8 ( pe -> mFamily -> Name ( ) ) . get ( ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> aDownloadStatus ) ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> #endif <NEW_LINE> <TAB> } <NEW_LINE> <TAB> LoadStatus status ; <NEW_LINE> <TAB> status = LoadNext ( pe ) ; <NEW_LINE> <TAB> if ( status == STATUS_LOADED ) { <NEW_LINE> <TAB> <TAB> IncrementGeneration ( ) ;
static __u8 * ch_report_fixup ( struct hid_device * hdev , __u8 * rdesc , <NEW_LINE> <TAB> <TAB> unsigned int * rsize ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> hid_info ( hdev , "fixing up Cherry Cymotion report descriptor\n" ) ; <NEW_LINE> <TAB> <TAB> rdesc [ 11 ] = rdesc [ 16 ] = 0xff ; <NEW_LINE> <TAB> <TAB> rdesc [ 12 ] = rdesc [ 17 ] = 0x03 ;
<TAB> unsigned char <TAB> __data [ 0 ] ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> #define optlength ( opt ) ( sizeof ( struct ip_options ) + opt -> optlen ) <NEW_LINE> <END_VULN> struct inet_request_sock { <NEW_LINE> <TAB> struct request_sock <TAB> req ;
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> ret = 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! SSL_USE_ETM ( s ) && EVP_MD_CTX_md ( s -> read_hash ) != NULL ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; <NEW_LINE> <TAB> <TAB> if ( ( bs != 1 ) && ! send ) { <NEW_LINE> <TAB> <TAB> <TAB> int tmpret ;
<TAB> init_rock_state ( & rs , inode ) ; <NEW_LINE> <TAB> setup_rock_ridge ( de , inode , & rs ) ; <NEW_LINE> <START_VULN> <TAB> if ( regard_xa ) { <NEW_LINE> <END_VULN> <TAB> <TAB> rs . chr += 14 ; <NEW_LINE> <TAB> <TAB> rs . len -= 14 ; <NEW_LINE> <TAB> <TAB> if ( rs . len < 0 )
<TAB> const char * msg ; <NEW_LINE> <TAB> u_int8_t state ; <NEW_LINE> <START_VULN> <TAB> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <NEW_LINE> <END_VULN> <TAB> BUG_ON ( dh == NULL ) ; <NEW_LINE> <TAB> state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ;
<TAB> struct rpc_cred * cred ; <NEW_LINE> <TAB> struct nfs4_state * state ; <NEW_LINE> <TAB> fl_owner_t lockowner ; <NEW_LINE> <START_VULN> <TAB> int mode ; <NEW_LINE> <END_VULN> <TAB> unsigned long flags ; <NEW_LINE> #define NFS_CONTEXT_ERROR_WRITE <TAB> <TAB> ( 0 )
MODULE_DESCRIPTION ( "Camellia Cipher Algorithm" ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "camellia" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> return GSS_S_DEFECTIVE_TOKEN ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( header -> buffer . length < token_wrapper_len + 14 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> * minor_status = 0 ; <NEW_LINE> <TAB> <TAB> return GSS_S_DEFECTIVE_TOKEN ; <NEW_LINE> <TAB> } <NEW_LINE> commit e6ae703ae597d798e310368d52b8f38ee11c6a73 <NEW_LINE> Author : Greg Hudson < ghudson@mit . edu > <NEW_LINE> Date : Thu Jun 19 13 : 49 : 16 2014 - 0400 <NEW_LINE> <TAB> Handle invalid RFC 1964 tokens [ CVE - 2014 - 4341 . . . ] <NEW_LINE> <TAB> Detect the following cases which would otherwise cause invalid memory <NEW_LINE> <TAB> accesses and / or integer underflow : <NEW_LINE> <TAB> [ CVE - 2014 - 4342 ] <NEW_LINE> <TAB> incomplete checksum [ CVE - 2014 - 4341 CVE - 2014 - 4342 ] <NEW_LINE> <TAB> If we detect a bad pad byte , continue on to compute the checksum to <NEW_LINE> <TAB> avoid creating a padding oracle , but treat the checksum as invalid <NEW_LINE> <TAB> even if it compares equal . <NEW_LINE> <TAB> CVE - 2014 - 4341 : <NEW_LINE> <TAB> In MIT krb5 , an unauthenticated remote attacker with the ability to <NEW_LINE> <TAB> inject packets into a legitimately established GSSAPI application <NEW_LINE> <TAB> session can cause a program crash due to invalid memory references <NEW_LINE> <TAB> when attempting to read beyond the end of a buffer . <NEW_LINE> <TAB> <TAB> CVSSv2 Vector : AV : N / AC : M / Au : N / C : N / I : N / A : P / E : POC / RL : OF / RC : C <NEW_LINE> <TAB> CVE - 2014 - 4342 : <NEW_LINE> <TAB> In MIT krb5 releases krb5 - 1 . 7 and later , an unauthenticated remote <NEW_LINE> <TAB> attacker with the ability to inject packets into a legitimately <NEW_LINE> <TAB> established GSSAPI application session can cause a program crash due <NEW_LINE> <TAB> to invalid memory references when reading beyond the end of a buffer <NEW_LINE> <TAB> or by causing a null pointer dereference . <NEW_LINE> <TAB> <TAB> CVSSv2 Vector : AV : N / AC : M / Au : N / C : N / I : N / A : P / E : POC / RL : OF / RC : C <NEW_LINE> <TAB> [ tlyu@mit . edu : CVE summaries , CVSS ] <NEW_LINE> <TAB> ( cherry picked from commit fb99962cbd063ac04c9a9d2cc7c75eab73f3533d ) <NEW_LINE> <TAB> ticket : 7949 <NEW_LINE> <TAB> version_fixed : 1 . 12 . 2 <NEW_LINE> <TAB> status : resolved
<TAB> int err ; <NEW_LINE> <TAB> if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || <NEW_LINE> <START_VULN> <TAB> ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) { <NEW_LINE> <END_VULN> <TAB> <TAB> duprintf ( "Bad offset % p\n" , e ) ; <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> }
#include < windows . h > <NEW_LINE> #elif defined ( ANGLE_OS_POSIX ) <NEW_LINE> #include < pthread . h > <NEW_LINE> #include < semaphore . h > <NEW_LINE> #include < errno . h > <NEW_LINE> #endif <NEW_LINE> <START_VULN> #include "compiler / debug . h" <NEW_LINE> <END_VULN> #if defined ( ANGLE_USE_NSPR ) <NEW_LINE> typedef PRUintn OS_TLSIndex ; <NEW_LINE> #define OS_INVALID_TLS_INDEX 0xFFFFFFFF <NEW_LINE> #elif defined ( ANGLE_OS_WIN )
{ <NEW_LINE> <TAB> static char * message = NULL ; <NEW_LINE> <START_VULN> <TAB> static unsigned short len = 0 ; <NEW_LINE> <END_VULN> <TAB> char buff [ 13 ] , * ret_msg = NULL ; <NEW_LINE> <TAB> register unsigned char i ; <NEW_LINE> <TAB> unsigned char blen ;
<TAB> <TAB> if ( nd -> flags & LOOKUP_RCU ) { <NEW_LINE> <TAB> <TAB> <TAB> return follow_dotdot_rcu ( nd ) ; <NEW_LINE> <TAB> <TAB> } else <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> follow_dotdot ( nd ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return 0 ; <NEW_LINE> }
<TAB> vcpu -> arch . regs [ VCPU_REGS_RSP ] = svm -> vmcb -> save . rsp ; <NEW_LINE> <TAB> vcpu -> arch . regs [ VCPU_REGS_RIP ] = svm -> vmcb -> save . rip ; <NEW_LINE> <START_VULN> <TAB> kvm_load_fs ( fs_selector ) ; <NEW_LINE><TAB> kvm_load_gs ( gs_selector ) ; <NEW_LINE><TAB> kvm_load_ldt ( ldt_selector ) ; <NEW_LINE> <END_VULN> <TAB> load_host_msrs ( vcpu ) ; <NEW_LINE> <TAB> reload_tss ( vcpu ) ;
<TAB> <TAB> return error ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN> <TAB> srcreg = ( opcode >> 4 ) & 0x3f ; <NEW_LINE> <TAB> if ( user_mode ( regs ) ) {
<TAB> } <NEW_LINE> <TAB> ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <NEW_LINE> <START_VULN> <TAB> if ( ! ctx -> established ) { <NEW_LINE> <END_VULN> <TAB> <TAB> * minor_status = KG_CTX_INCOMPLETE ; <NEW_LINE> <TAB> <TAB> return GSS_S_NO_CONTEXT ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> * tail = vp ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> while ( * tail ) tail = & vp -> next ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> p += alen ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> }
<TAB> if ( ! port ) <NEW_LINE> <TAB> <TAB> return - EPIPE ; <NEW_LINE> <START_VULN> <TAB> sg_init_one ( sg , buf , count ) ; <NEW_LINE><TAB> return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ; <NEW_LINE> <END_VULN> }
<TAB> <TAB> cluster -> cl_local_node = node -> nd_num ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> return count ; <NEW_LINE> <END_VULN> } <NEW_LINE> CONFIGFS_ATTR ( o2nm_node_ , num ) ;
<TAB> } else { <NEW_LINE> <TAB> for ( i = 0 ; i < s -> entries ; i + + ) { <NEW_LINE> <TAB> <TAB> long num = oggpack_read ( opb , 5 ) ; <NEW_LINE> <TAB> <TAB> if ( num == - 1 ) goto _eofout ; <NEW_LINE> <TAB> <TAB> s -> lengthlist [ i ] = num + 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> break ; <NEW_LINE> case 1 : <NEW_LINE> <TAB> { <NEW_LINE> <TAB> long length = oggpack_read ( opb , 5 ) + 1 ; <NEW_LINE> <TAB> s -> lengthlist = _ogg_malloc ( sizeof ( * s -> lengthlist ) * s -> entries ) ; <NEW_LINE> <TAB> for ( i = 0 ; i < s -> entries ; ) {
<START_VULN> void ip_options_build ( struct sk_buff * skb , struct ip_options * opt , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> __be32 daddr , struct rtable * rt , int is_frag ) <NEW_LINE> { <NEW_LINE> <TAB> unsigned char * iph = skb_network_header ( skb ) ;
<TAB> case ' > ' : h -> endian = BIG ; return ; <NEW_LINE> <TAB> case ' < ' : h -> endian = LITTLE ; return ; <NEW_LINE> <TAB> case ' ! ' : { <NEW_LINE> <START_VULN> <TAB> int a = getnum ( L , fmt , MAXALIGN ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! isp2 ( a ) ) <NEW_LINE> <TAB> <TAB> luaL_error ( L , "alignment % d is not a power of 2" , a ) ; <NEW_LINE> <TAB> h -> align = a ;
<TAB> for ( i = 0 ; i < 3 ; i + + ) { <NEW_LINE> <TAB> <TAB> ff_free_vlc ( & s -> vlc [ i ] ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , <NEW_LINE><TAB> <TAB> <TAB> <TAB> s -> bits [ i ] , 4 , 4 , 0 ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> generate_joint_tables ( s ) ;
} ; <NEW_LINE> extern nsresult <NEW_LINE> <START_VULN> NS_CreateJSTimeoutHandler ( nsIScriptContext * aContext , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRBool * aIsInterval , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRInt32 * aInterval , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIScriptTimeoutHandler ** aRet ) ;
<TAB> l_current_nb_bytes_written = 0 ; <NEW_LINE> <TAB> l_begin_data = p_data ; <NEW_LINE> <START_VULN> <TAB> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> p_manager ) ) { <NEW_LINE> <TAB> <TAB> return OPJ_FALSE ; <NEW_LINE> <TAB> }
MODULE_PARM_DESC ( ksym , "Kernel symbol to monitor ; this module will report any" <NEW_LINE> <TAB> <TAB> <TAB> " write operations on the kernel symbol" ) ; <NEW_LINE> <START_VULN> static void sample_hbp_handler ( struct perf_event * bp , int nmi , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> struct perf_sample_data * data , <NEW_LINE> <TAB> <TAB> <TAB> struct pt_regs * regs ) <NEW_LINE> {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : bitrate tracking and management <NEW_LINE> <START_VULN> last mod : $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_BITRATE_H_ <NEW_LINE> #define _V_BITRATE_H_ <NEW_LINE> #include "vorbis / codec . h" <NEW_LINE> #include "codec_internal . h"
FlatpakProxy * proxy ; <NEW_LINE> gboolean authenticated ; <NEW_LINE> <START_VULN> int auth_end_offset ; <NEW_LINE> <END_VULN> ProxySide client_side ; <NEW_LINE> ProxySide bus_side ;
JS_BEGIN_EXTERN_C <NEW_LINE> extern JSClass js_MathClass ; <NEW_LINE> extern JSObject * <NEW_LINE> js_InitMathClass ( JSContext * cx , JSObject * obj ) ; <NEW_LINE> extern void <NEW_LINE> <START_VULN> js_InitRandom ( JSThreadData * data ) ; <NEW_LINE> <END_VULN> extern JSBool <NEW_LINE> js_math_ceil ( JSContext * cx , uintN argc , jsval * vp ) ; <NEW_LINE> extern JSBool <NEW_LINE> js_math_floor ( JSContext * cx , uintN argc , jsval * vp ) ; <NEW_LINE> extern JSBool
<TAB> <TAB> avpriv_request_sample ( pb , "Primer pack item length % d" , item_len ) ; <NEW_LINE> <TAB> <TAB> return AVERROR_PATCHWELCOME ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( item_num > 65536 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> av_log ( mxf -> fc , AV_LOG_ERROR , "item_num % d is too large\n" , item_num ) ; <NEW_LINE> <TAB> <TAB> return AVERROR_INVALIDDATA ; <NEW_LINE> <TAB> }
<TAB> <TAB> const char * s ; <NEW_LINE> <TAB> <TAB> int len ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! NOTMIME ( ms ) ) <NEW_LINE><TAB> <TAB> str = cdf_clsid_to_mime ( clsid , clsid2mime ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> for ( i = 0 ; i < count ; i + + ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> cdf_print_property_name ( buf , sizeof ( buf ) , info [ i ] . pi_id ) ;
<TAB> NS_DECL_ISUPPORTS <NEW_LINE> <TAB> NS_DECL_MOZIJSSUBSCRIPTLOADER <NEW_LINE> private : <NEW_LINE> <TAB> nsresult ReadScript ( nsIURI * uri , JSContext * cx , JSObject * target_obj , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> jschar * charset , const char * uriStr , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIIOService * serv , JSObject ** scriptObjp ) ; <NEW_LINE> <END_VULN> <TAB> nsCOMPtr < nsIPrincipal > mSystemPrincipal ; <NEW_LINE> } ;
<TAB> <TAB> walk + + ; <NEW_LINE> <TAB> } else <NEW_LINE> <TAB> <TAB> return 0 ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> if ( * walk && * walk >= '0' && * walk <= '9' ) { <NEW_LINE> <TAB> <TAB> * backref = * backref * 10 + * walk - '0' ; <NEW_LINE> <TAB> <TAB> walk + + ;
{ <NEW_LINE> <TAB> struct keyring_search_context * ctx = iterator_data ; <NEW_LINE> <TAB> const struct key * key = keyring_ptr_to_key ( object ) ; <NEW_LINE> <START_VULN> <TAB> unsigned long kflags = key -> flags ; <NEW_LINE> <END_VULN> <TAB> kenter ( " { % d } " , key -> serial ) ;
<TAB> if ( options & STREAM_WILL_CAST ) <NEW_LINE> <TAB> <TAB> chunk_size = php_stream_set_chunk_size ( stream , 1 ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;
<TAB> osa_princ_ent_rec adb ; <NEW_LINE> <TAB> krb5_int32 now ; <NEW_LINE> <TAB> kadm5_policy_ent_rec pol ; <NEW_LINE> <START_VULN> <TAB> int ret , last_pwd ; <NEW_LINE> <END_VULN> <TAB> krb5_boolean have_pol = FALSE ; <NEW_LINE> <TAB> kadm5_server_handle_t handle = server_handle ; <NEW_LINE> <TAB> krb5_keyblock * act_mkey ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 59 2014 / 05 / 14 23 : 22 : 48 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include < assert . h >
#ifdef FLOAT_LOOKUP <NEW_LINE> #include "vorbis_lookup . c" <NEW_LINE> void vorbis_lsp_to_curve ( float * curve , int * map , int n , int ln , float * lsp , int m , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> float amp , float ampoffset ) { <NEW_LINE> <END_VULN> int i ; <NEW_LINE> float wdel = M_PI / ln ; <NEW_LINE> vorbis_fpu_control fpu ; <NEW_LINE> vorbis_fpu_setround ( & fpu ) ; <NEW_LINE> for ( i = 0 ; i < m ; i + + ) lsp [ i ] = vorbis_coslook ( lsp [ i ] ) ; <NEW_LINE> i = 0 ;
<TAB> } <NEW_LINE> <TAB> if ( ! dump ) <NEW_LINE> <TAB> return CL_CLEAN ; <NEW_LINE> <START_VULN> <TAB> cli_dbgmsg ( "cli_pdf : dumping obj % u % u\n" , obj -> id >> 8 , obj -> id ) ; <NEW_LINE> <END_VULN> <TAB> snprintf ( fullname , sizeof ( fullname ) , " % s"PATHSEP"pdf % 02u" , pdf -> dir , pdf -> files + + ) ; <NEW_LINE> <TAB> fout = open ( fullname , O_RDWR|O_CREAT|O_EXCL|O_TRUNC|O_BINARY , 0600 ) ; <NEW_LINE> <TAB> if ( fout < 0 ) {
<TAB> WRITE32 ( OP_OPEN_DOWNGRADE ) ; <NEW_LINE> <TAB> WRITEMEM ( arg -> stateid -> data , NFS4_STATEID_SIZE ) ; <NEW_LINE> <TAB> WRITE32 ( arg -> seqid -> sequence -> counter ) ; <NEW_LINE> <START_VULN> <TAB> encode_share_access ( xdr , arg -> open_flags ) ; <NEW_LINE> <END_VULN> <TAB> return 0 ; <NEW_LINE> }
<TAB> <TAB> return FISH_SOUND_ERR_OUT_OF_MEMORY ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> } else if ( fsv -> packetno == 2 ) { <NEW_LINE> <START_VULN> <TAB> vorbis_synthesis_init ( & fsv -> vd , & fsv -> vi ) ; <NEW_LINE><TAB> vorbis_block_init ( & fsv -> vd , & fsv -> vb ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> } else { <NEW_LINE> <TAB> FishSoundDecoded_FloatIlv df ;
<TAB> else <NEW_LINE> <TAB> <TAB> skb -> tstamp = ktime_get_real ( ) ; <NEW_LINE> <START_VULN> <TAB> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> EXPORT_SYMBOL_GPL ( __skb_tstamp_tx ) ;
<TAB> const uint8_t * data ; <NEW_LINE> <TAB> int ifp_len ; <NEW_LINE> <TAB> int repaired [ 16 ] ; <NEW_LINE> <START_VULN> <TAB> const uint8_t * bufs [ 16 ] ; <NEW_LINE><TAB> int lengths [ 16 ] ; <NEW_LINE> <END_VULN> <TAB> int span ; <NEW_LINE> <TAB> int entries ; <NEW_LINE> <TAB> int ifp_no ;
inline void <NEW_LINE> JSObject : : initCall ( JSContext * cx , const js : : Bindings & bindings , JSObject * parent ) <NEW_LINE> { <NEW_LINE> <TAB> init ( cx , & js : : CallClass , & js : : types : : emptyTypeObject , parent , NULL , false ) ; <NEW_LINE> <START_VULN> <TAB> lastProp = bindings . lastShape ( ) ; <NEW_LINE> <END_VULN> <TAB> if ( bindings . extensibleParents ( ) ) <NEW_LINE> <TAB> <TAB> setOwnShape ( js_GenerateShape ( cx ) ) ; <NEW_LINE> <TAB> else
<TAB> JSObject * PrepareObjectForLocation ( JSCLContextHelper & aCx , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIFile * aComponentFile , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIURI * aComponent , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool aReuseLoaderGlobal , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool * aRealFile ) ; <NEW_LINE> <TAB> nsresult ObjectForLocation ( nsIFile * aComponentFile , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIURI * aComponent , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject ** aObject , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSScript ** aTableScript , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> char ** location , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool aCatchException , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JS : : MutableHandleValue aException ) ; <NEW_LINE> <TAB> nsresult ImportInto ( const nsACString & aLocation , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JS : : HandleObject targetObj , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSContext * callercx , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JS : : MutableHandleObject vp ) ;
<TAB> while ( strncmp ( file , " . / " , 2 ) == 0 ) <NEW_LINE> <TAB> ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ; <NEW_LINE> <TAB> while ( ( cp = strstr ( file , " / . / " ) ) != ( char * ) 0 ) <NEW_LINE> <START_VULN> <TAB> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <NEW_LINE> <END_VULN> <TAB> for ( ; ; )
float CVE_2012_1960_clamp_float ( float a ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( a > 1 . ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> return 1 . ; <NEW_LINE><TAB> <TAB> else if ( a < 0 ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> return 0 ; <NEW_LINE><TAB> <TAB> else <NEW_LINE><TAB> <TAB> <TAB> <TAB> return a ; <NEW_LINE> <END_VULN> }
<TAB> } <NEW_LINE> if ( image -> gamma != 0 . 0 ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> count = FormatLocaleString ( header , MagickPathExtent , "GAMMA = % g\n" , image -> gamma ) ; <NEW_LINE> <END_VULN> <TAB> ( void ) WriteBlob ( image , ( size_t ) count , ( unsigned char * ) header ) ; <NEW_LINE> <TAB> } <NEW_LINE> count = FormatLocaleString ( header , MagickPathExtent ,
{ <NEW_LINE> <TAB> struct sock * s = unix_get_socket ( fp ) ; <NEW_LINE> <TAB> if ( s ) { <NEW_LINE> <TAB> <TAB> struct unix_sock * u = unix_sk ( s ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> spin_lock ( & unix_gc_lock ) ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> <TAB> if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { <NEW_LINE> <TAB> <TAB> <TAB> BUG_ON ( ! list_empty ( & u -> link ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> list_add_tail ( & u -> link , & gc_inflight_list ) ;
<TAB> if ( iris_info . pixel_format != 0 ) <NEW_LINE> <TAB> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE> <TAB> count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; <NEW_LINE> <START_VULN> <TAB> ( void ) count ; <NEW_LINE> <END_VULN> <TAB> image -> columns = iris_info . columns ; <NEW_LINE> <TAB> image -> rows = iris_info . rows ; <NEW_LINE> <TAB> image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ;
<TAB> header [ 11 ] = ( rec -> length ) >> 8 ; <NEW_LINE> <TAB> header [ 12 ] = ( rec -> length ) & 0xff ; <NEW_LINE> <START_VULN> <TAB> if ( ! send && ! SSL_USE_ETM ( ssl ) && <NEW_LINE> <END_VULN> <TAB> <TAB> EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && <NEW_LINE> <TAB> <TAB> ssl3_cbc_record_digest_supported ( mac_ctx ) ) { <NEW_LINE> # define SSL_PKEY_RSA_ENC 0
out_cleanup : <NEW_LINE> <TAB> ovl_cleanup ( wdir , newdentry ) ; <NEW_LINE> <START_VULN> <TAB> goto out ; <NEW_LINE> <END_VULN> }
<START_VULN> <TAB> found = ( unsigned char * ) php_memnstr ( ( char * ) haystack + offset , ( char * ) needle , needle_len , ( char * ) haystack + haystack_len ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! found ) {
#if defined ( PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED ) || \ <NEW_LINE> <TAB> defined ( PNG_USER_CHUNK_MALLOC_MAX ) <NEW_LINE> <TAB> else <NEW_LINE> #endif <NEW_LINE> <TAB> if ( expanded_size > 0 ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> png_size_t new_size = 0 ; <NEW_LINE> <START_VULN> <TAB> <TAB> png_charp text = png_malloc_warn ( png_ptr , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> prefix_size + expanded_size + 1 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( text != NULL ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> png_memcpy ( text , png_ptr -> chunkdata , prefix_size ) ; <NEW_LINE> <TAB> <TAB> <TAB> new_size = png_inflate ( png_ptr , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ( png_bytep ) ( png_ptr -> chunkdata + prefix_size ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> chunklength - prefix_size , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ( png_bytep ) ( text + prefix_size ) , expanded_size ) ;
<TAB> { <NEW_LINE> <TAB> <TAB> MsgToEventLog ( M_ERR , TEXT ( "Startup data ends at working directory" ) ) ; <NEW_LINE> <TAB> <TAB> ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> goto out ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> sud -> options = sud -> directory + len ;
<TAB> nsPIDOMWindow * aWindow , <NEW_LINE> <TAB> const dom : : MediaStreamConstraints & aRawConstraints , <NEW_LINE> <TAB> nsIDOMGetUserMediaSuccessCallback * onSuccess , <NEW_LINE> <TAB> nsIDOMGetUserMediaErrorCallback * onError ) ; <NEW_LINE> nsresult GetUserMediaDevices ( nsPIDOMWindow * aWindow , <NEW_LINE> <TAB> const dom : : MediaStreamConstraintsInternal & aConstraints , <NEW_LINE> <TAB> nsIGetUserMediaDevicesSuccessCallback * onSuccess , <NEW_LINE> <START_VULN> <TAB> nsIDOMGetUserMediaErrorCallback * onError ) ; <NEW_LINE> <END_VULN> void OnNavigation ( uint64_t aWindowID ) ; <NEW_LINE> MediaEnginePrefs mPrefs ; <NEW_LINE> private : <NEW_LINE> WindowTable * GetActiveWindows ( ) { <NEW_LINE> <TAB> NS_ASSERTION ( NS_IsMainThread ( ) , "Only access windowlist on main thread" ) ; <NEW_LINE> <TAB> return & mActiveWindows ;
} <NEW_LINE> <START_VULN> #define DOBIG4 c ^ = * + + buf4 ; \ <NEW_LINE> <END_VULN> <TAB> <TAB> c = crc_table [ 4 ] [ c & 0xff ] ^ crc_table [ 5 ] [ ( c >> 8 ) & 0xff ] ^ \ <NEW_LINE> <TAB> <TAB> <TAB> crc_table [ 6 ] [ ( c >> 16 ) & 0xff ] ^ crc_table [ 7 ] [ c >> 24 ] <NEW_LINE> #define DOBIG32 DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4
void mk_request_free ( struct session_request * sr ) <NEW_LINE> { <NEW_LINE> <TAB> if ( sr -> fd_file > 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> mk_vhost_close ( sr ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( sr -> headers . location ) {
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Blowfish Cipher Algorithm" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "blowfish" ) ; <NEW_LINE> <END_VULN>
<TAB> NS_DECLARE_STATIC_IID_ACCESSOR ( XPCVARIANT_IID ) <NEW_LINE> <TAB> static XPCVariant * newVariant ( XPCCallContext & ccx , jsval aJSVal ) ; <NEW_LINE> <TAB> jsval GetJSVal ( ) const { return mJSVal ; } <NEW_LINE> <START_VULN> <TAB> XPCVariant ( jsval aJSVal ) ; <NEW_LINE> <END_VULN>
void IGDstartelt ( void * d , const char * name , int l ) <NEW_LINE> { <NEW_LINE> <TAB> struct IGDdatas * datas = ( struct IGDdatas * ) d ; <NEW_LINE> <START_VULN> <TAB> memcpy ( datas -> cureltname , name , l ) ; <NEW_LINE> <END_VULN> <TAB> datas -> cureltname [ l ] = '\0' ; <NEW_LINE> <TAB> datas -> level + + ; <NEW_LINE> <TAB> if ( ( l == 7 ) && ! memcmp ( name , "service" , l ) ) {
<TAB> if ( cipher_def -> type == type_block ) { <NEW_LINE> <START_VULN> <TAB> const unsigned int blockSize = cipher_def -> iv_size ; <NEW_LINE> <END_VULN> <TAB> const unsigned int macSize = crSpec -> mac_size ; <NEW_LINE> <TAB> if ( crSpec -> version <= SSL_LIBRARY_VERSION_3_0 ) {
<TAB> status = decode_putfh ( xdr ) ; <NEW_LINE> <TAB> if ( status ) <NEW_LINE> <TAB> <TAB> goto out ; <NEW_LINE> <START_VULN> <TAB> status = decode_getacl ( xdr , rqstp , & res -> acl_len ) ; <NEW_LINE> <END_VULN> out : <NEW_LINE> <TAB> return status ;
<TAB> if ( tstate & TSTATE_PRIV ) <NEW_LINE> <TAB> <TAB> die_if_kernel ( "unfinished / unimplemented FPop from kernel" , regs ) ; <NEW_LINE> <START_VULN> <TAB> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <NEW_LINE> <END_VULN> <TAB> if ( test_thread_flag ( TIF_32BIT ) ) <NEW_LINE> <TAB> <TAB> pc = ( u32 ) pc ; <NEW_LINE> <TAB> if ( get_user ( insn , ( u32 __user * ) pc ) != - EFAULT ) {
<TAB> <TAB> return rv ; <TAB> <NEW_LINE> <TAB> } <NEW_LINE> <TAB> } else { <NEW_LINE> #ifndef HACKED_EXPORT_SERVER <NEW_LINE> <TAB> PORT_SetError ( SSL_ERROR_PUB_KEY_SIZE_LIMIT_EXCEEDED ) ; <NEW_LINE> <TAB> return rv ; <NEW_LINE> #endif <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> #ifndef NSS_DISABLE_ECC <NEW_LINE><TAB> } else if ( ( kea_def -> kea == kea_ecdhe_rsa ) || <NEW_LINE><TAB> ( kea_def -> kea == kea_ecdhe_ecdsa ) ) { <NEW_LINE><TAB> rv = ssl3_SendServerKeyExchange ( ss ) ; <NEW_LINE><TAB> if ( rv != SECSuccess ) { <NEW_LINE><TAB> return rv ; <TAB> <NEW_LINE><TAB> } <NEW_LINE>#endif <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( ss -> opt . requestCertificate ) { <NEW_LINE> <TAB> rv = ssl3_SendCertificateRequest ( ss ) ; <NEW_LINE> <TAB> if ( rv != SECSuccess ) { <NEW_LINE> <TAB> return rv ; <TAB> <TAB> <NEW_LINE> <TAB> } <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> gss_ctx_id_t * context_handle , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> gss_buffer_t output_token ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> OM_uint32 major_status = GSS_S_COMPLETE ; <NEW_LINE> <END_VULN> <TAB> if ( output_token != GSS_C_NO_BUFFER ) { <NEW_LINE> <TAB> <TAB> output_token -> length = 0 ;
<TAB> get_trust_val ( trust , valstr , sizeof valstr ) ; <NEW_LINE> <TAB> PR_LOG ( modlog , 4 , ( fmt_s_s_d , <NEW_LINE> <TAB> atype , valstr , attr -> ulValueLen ) ) ; <NEW_LINE> <TAB> break ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> case CKA_KEY_TYPE : <NEW_LINE> <TAB> if ( attr -> ulValueLen > 0 && attr -> pValue ) { <NEW_LINE> <TAB> CK_KEY_TYPE keyType = * ( ( CK_KEY_TYPE * ) attr -> pValue ) ; <NEW_LINE> <START_VULN> <TAB> get_obj_class ( keyType , valstr , sizeof valstr ) ; <NEW_LINE> <END_VULN> <TAB> PR_LOG ( modlog , 4 , ( fmt_s_s_d , <NEW_LINE> <TAB> atype , valstr , attr -> ulValueLen ) ) ; <NEW_LINE> <TAB> break ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> case CKA_LABEL : <NEW_LINE> <TAB> case CKA_NETSCAPE_EMAIL : <NEW_LINE> <TAB> case CKA_NETSCAPE_URL : <NEW_LINE> <TAB> if ( attr -> ulValueLen > 0 && attr -> pValue ) {
static void cheby ( float * g , int ord ) { <NEW_LINE> int i , j ; <NEW_LINE> g [ 0 ] *= . 5f ; <NEW_LINE> for ( i = 2 ; i <= ord ; i + + ) { <NEW_LINE> <TAB> for ( j = ord ; j >= i ; j -- ) { <NEW_LINE> <TAB> g [ j - 2 ] -= g [ j ] ; <NEW_LINE> <START_VULN> <TAB> g [ j ] += g [ j ] ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> static int comp ( const void * a , const void * b ) { <NEW_LINE> return ( * ( float * ) a < * ( float * ) b ) - ( * ( float * ) a > * ( float * ) b ) ; <NEW_LINE> }
<TAB> <TAB> <TAB> strcmp ( f -> file , " / cgroup . procs" ) == 0 || <NEW_LINE> <TAB> <TAB> <TAB> strcmp ( f -> file , "cgroup . procs" ) == 0 ) <NEW_LINE> <START_VULN> <TAB> <TAB> r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ; <NEW_LINE> <END_VULN> <TAB> else <NEW_LINE> <TAB> <TAB> r = cgfs_set_value ( f -> controller , f -> cgroup , f -> file , localbuf ) ;
<TAB> <TAB> break ; <NEW_LINE> <TAB> case 0x80 . . . 0x8f : <NEW_LINE> <TAB> <TAB> if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> jmp_rel ( ctxt , ctxt -> src . val ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> case 0x90 . . . 0x9f : <NEW_LINE> <TAB> <TAB> ctxt -> dst . val = test_cc ( ctxt -> b , ctxt -> eflags ) ;
<TAB> <TAB> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <NEW_LINE> <TAB> <TAB> <TAB> atomic_dec ( & key -> user -> nikeys ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> key_user_put ( key -> user ) ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> <TAB> if ( key -> type -> destroy ) <NEW_LINE> <TAB> <TAB> <TAB> key -> type -> destroy ( key ) ; <NEW_LINE> <TAB> <TAB> kfree ( key -> description ) ; <NEW_LINE> #ifdef KEY_DEBUGGING
<TAB> <TAB> vlan = __skb_header_pointer ( skb , nhoff , sizeof ( _vlan ) , data , hlen , & _vlan ) ; <NEW_LINE> <TAB> <TAB> if ( ! vlan ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( skb_flow_dissector_uses_key ( flow_dissector , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> FLOW_DISSECTOR_KEY_VLANID ) ) {
<TAB> <TAB> ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; <NEW_LINE> <TAB> <TAB> if ( ret == 0 ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <NEW_LINE> <END_VULN> #ifdef USE_HCACHE <NEW_LINE> <TAB> <TAB> mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; <NEW_LINE> #endif
<TAB> if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || <NEW_LINE> <TAB> <TAB> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || <NEW_LINE> <START_VULN> <TAB> <TAB> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <NEW_LINE><TAB> <TAB> ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || <NEW_LINE> <END_VULN> <TAB> <TAB> ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || <NEW_LINE> <TAB> <TAB> ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || <NEW_LINE> <TAB> <TAB> ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) {
} <NEW_LINE> } <NEW_LINE> <START_VULN> static MagickBooleanType WritePSDImage ( const ImageInfo * image_info , Image * image , <NEW_LINE>ExceptionInfo * exception ) <NEW_LINE> <END_VULN> { <NEW_LINE> const char <NEW_LINE> <TAB> * property ;
<TAB> mark_page_accessed ( page ) ; <NEW_LINE> out : <NEW_LINE> <TAB> page_cache_release ( page ) ; <NEW_LINE> <START_VULN> <TAB> unlock_page ( page ) ; <NEW_LINE> <END_VULN> out_ret : <NEW_LINE> <TAB> return ret ; <NEW_LINE> }
<TAB> av_assert1 ( s -> bitstream_buffer_size == 0 ) ; <NEW_LINE> frame_end : <NEW_LINE> <START_VULN> <TAB> ff_er_frame_end ( & s -> er ) ; <NEW_LINE> <END_VULN> <TAB> if ( avctx -> hwaccel ) { <NEW_LINE> <TAB> <TAB> ret = avctx -> hwaccel -> end_frame ( avctx ) ;
int hns_ppe_get_sset_count ( int stringset ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( stringset == ETH_SS_STATS ) <NEW_LINE> <END_VULN> <TAB> <TAB> return ETH_PPE_STATIC_NUM ; <NEW_LINE> <TAB> return 0 ; <NEW_LINE> }
<TAB> default : CHECK ( 0 ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> snprintf_func ( rptr , rbuf + TESTBUFSIZE - rptr , " % d / % d" , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> inst -> pos , inst -> size ) ; <NEW_LINE> <TAB> rptr += strlen ( rptr ) ;
MODULE_DESCRIPTION ( "Cast5 Cipher Algorithm , AVX optimized" ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "cast5" ) ; <NEW_LINE> <END_VULN>
<TAB> cupsdSetString ( & job -> username , con -> username ) ; <NEW_LINE> <TAB> if ( attr ) <NEW_LINE> <START_VULN> <TAB> cupsdSetString ( & attr -> values [ 0 ] . string . text , con -> username ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else if ( attr ) <NEW_LINE> {
#else <NEW_LINE> <TAB> <TAB> crm_notice ( "Starting a tls listener on port % d . " , port ) ; <NEW_LINE> <TAB> <TAB> gnutls_global_init ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> <TAB> gnutls_global_set_log_function ( debug_log ) ; <NEW_LINE> <TAB> <TAB> gnutls_dh_params_init ( & dh_params ) ; <NEW_LINE> <TAB> <TAB> gnutls_dh_params_generate2 ( dh_params , DH_BITS ) ;
<TAB> { <NEW_LINE> <TAB> <TAB> MsgToEventLog ( M_SYSERR , TEXT ( "PeekNamedPipeAsync failed" ) ) ; <NEW_LINE> <TAB> <TAB> ReturnLastError ( pipe , L"PeekNamedPipeAsync" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> goto out ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> size = bytes / sizeof ( * data ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Twofish Cipher Algorithm , 3 - way parallel asm optimized" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "twofish" ) ; <NEW_LINE>MODULE_ALIAS ( "twofish - asm" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> <TAB> <TAB> if ( ! result ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> result = x ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> pc += GET_OFFSET ( pc ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> op = ( REOp ) * pc + + ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> continue ;
<TAB> <TAB> snd_timer_interrupt ( substream -> timer , 1 ) ; <NEW_LINE> #endif <NEW_LINE> _end : <NEW_LINE> <START_VULN> <TAB> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; <NEW_LINE> <END_VULN> <TAB> kill_fasync ( & runtime -> fasync , SIGIO , POLL_IN ) ; <NEW_LINE> } <NEW_LINE> EXPORT_SYMBOL ( snd_pcm_period_elapsed ) ;
<TAB> <TAB> <TAB> if ( version != s -> version ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> <TAB> s -> version = version ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> al = SSL_AD_PROTOCOL_VERSION ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto f_err ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
<TAB> goto alert_loser ; <TAB> <NEW_LINE> <TAB> } <NEW_LINE> <TAB> sid -> version = ss -> version ; <NEW_LINE> <TAB> sid -> u . ssl3 . sessionIDLength = sidBytes . len ; <NEW_LINE> <TAB> PORT_Memcpy ( sid -> u . ssl3 . sessionID , sidBytes . data , sidBytes . len ) ; <NEW_LINE> <TAB> ss -> ssl3 . hs . isResuming = PR_FALSE ; <NEW_LINE> <START_VULN> <TAB> ss -> ssl3 . hs . ws = wait_server_cert ; <NEW_LINE> <END_VULN> <TAB> return SECSuccess ; <NEW_LINE> alert_loser : <NEW_LINE> <TAB> ( void ) SSL3_SendAlert ( ss , alert_fatal , desc ) ; <NEW_LINE> loser : <NEW_LINE> <TAB> errCode = ssl_MapLowLevelError ( errCode ) ; <NEW_LINE> <TAB> return SECFailure ;
typedef ogg_int16_t vorbis_fpu_control ; <NEW_LINE> static inline void vorbis_fpu_setround ( vorbis_fpu_control * fpu ) { <NEW_LINE> ogg_int16_t ret ; <NEW_LINE> ogg_int16_t temp ; <NEW_LINE> __asm__ __volatile__ ( "fnstcw % 0\n\t" <NEW_LINE> <TAB> <TAB> "movw % 0 , % % dx\n\t" <NEW_LINE> <START_VULN> <TAB> <TAB> "orw $ 62463 , % % dx\n\t" <NEW_LINE> <END_VULN> <TAB> <TAB> "movw % % dx , % 1\n\t" <NEW_LINE> <TAB> <TAB> "fldcw % 1\n\t" : " = m" ( ret ) : "m" ( temp ) : "dx" ) ; <NEW_LINE> * fpu = ret ; <NEW_LINE> } <NEW_LINE> static inline void vorbis_fpu_restore ( vorbis_fpu_control fpu ) { <NEW_LINE> __asm__ __volatile__ ( "fldcw % 0" : : "m" ( fpu ) ) ; <NEW_LINE> }
nsresult InitClass ( const nsCString & aClassName , JSContext * aContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aGlobal , JSObject * aScriptObject , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject ** aClassObject ) ; <NEW_LINE> nsresult ConstructInterfaceTable ( const nsAString & aImpls ) ; <NEW_LINE> void SetImplementation ( nsXBLProtoImpl * aImpl ) { mImplementation = aImpl ; } <NEW_LINE> <START_VULN> nsresult InstallImplementation ( nsIContent * aBoundElement ) ; <NEW_LINE> <END_VULN> bool HasImplementation ( ) const { return mImplementation != nullptr ; } <NEW_LINE> void AttributeChanged ( nsIAtom * aAttribute , int32_t aNameSpaceID , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool aRemoveFlag , nsIContent * aChangedElement , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIContent * aAnonymousContent , bool aNotify ) ; <NEW_LINE> void SetBasePrototype ( nsXBLPrototypeBinding * aBinding ) ; <NEW_LINE> nsXBLPrototypeBinding * GetBasePrototype ( ) { return mBaseBinding ; }
<TAB> uchar * buf_ ; <NEW_LINE> <START_VULN> <TAB> int bufsize_ ; <NEW_LINE> <END_VULN> <TAB> int_fast32_t len_ ;
<TAB> if ( av_pix_fmt_desc_get ( inlink -> format ) -> flags & AV_PIX_FMT_FLAG_PAL ) <NEW_LINE> <TAB> <TAB> memcpy ( out -> data [ 1 ] , in -> data [ 1 ] , AVPALETTE_SIZE ) ; <NEW_LINE> <START_VULN> <TAB> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ; <NEW_LINE> <TAB> <TAB> const int height = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> h , s -> vsub ) : inlink -> h ; <NEW_LINE> <TAB> <TAB> step = s -> max_step [ plane ] ;
<START_VULN> ** Copyright ( C ) 2002 - 2013 Erik de Castro Lopo < erikd@mega - nerd . com > <NEW_LINE> <END_VULN> ** Copyright ( C ) 2003 Ross Bencina < rbencina@iprimus . com . au > <NEW_LINE> ** <NEW_LINE> ** This program is free software ; you can redistribute it and / or modify
<TAB> if ( devices == NULL ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> hb_log ( "OpenCL : hb_generat_bin_from_kernel_source : no device found" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <END_VULN> <TAB> }
public : <NEW_LINE> <TAB> enum <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> MAX_SIZE = 64 * 1024 <NEW_LINE> <END_VULN> <TAB> } ; <NEW_LINE> <TAB> void Clear ( ) { m_DataSize = 0 ; m_NumItems = 0 ; }
void ipc_rcu_putref ( void * ptr ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( -- container_of ( ptr , struct ipc_rcu_hdr , data ) -> refcount > 0 ) <NEW_LINE> <END_VULN> <TAB> <TAB> return ; <NEW_LINE> <TAB> if ( container_of ( ptr , struct ipc_rcu_hdr , data ) -> is_vmalloc ) {
eLinkState_Unknown = 0 , <NEW_LINE> eLinkState_Unvisited = 1 , <NEW_LINE> eLinkState_Visited = 2 , <NEW_LINE> eLinkState_NotLink = 3 <NEW_LINE> } ; <NEW_LINE> #define NS_ICONTENT_IID \ <NEW_LINE> <START_VULN> { 0x98fb308d , 0xc6dd , 0x4c6d , \ <NEW_LINE> { 0xb7 , 0x7c , 0x91 , 0x18 , 0x0c , 0xf0 , 0x6f , 0x23 } } <NEW_LINE> <END_VULN> class nsIContent : public nsINode { <NEW_LINE> public : <NEW_LINE> typedef mozilla : : widget : : IMEState IMEState ;
<TAB> <TAB> <TAB> <TAB> <TAB> args -> shader_rec_count ) ; <NEW_LINE> <TAB> struct vc4_bo * bo ; <NEW_LINE> <START_VULN> <TAB> if ( uniforms_offset < shader_rec_offset || <NEW_LINE> <END_VULN> <TAB> exec_size < uniforms_offset || <NEW_LINE> <TAB> args -> shader_rec_count >= ( UINT_MAX / <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> sizeof ( struct vc4_shader_state ) ) ||
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : basic shared codebook operations <NEW_LINE> <START_VULN> last mod : $ Id : codebook . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_CODEBOOK_H_ <NEW_LINE> #define _V_CODEBOOK_H_ <NEW_LINE> #include < ogg / ogg . h >
<TAB> . open <TAB> <TAB> = ftrace_pid_open , <NEW_LINE> <TAB> . write <TAB> <TAB> = ftrace_pid_write , <NEW_LINE> <TAB> . read <TAB> <TAB> = seq_read , <NEW_LINE> <START_VULN> <TAB> . llseek <TAB> <TAB> = seq_lseek , <NEW_LINE> <END_VULN> <TAB> . release <TAB> = ftrace_pid_release , <NEW_LINE> } ;
<TAB> <TAB> <TAB> return range_within ( rold , rcur ) && <NEW_LINE> <TAB> <TAB> <TAB> tnum_in ( rold -> var_off , rcur -> var_off ) ; <NEW_LINE> <TAB> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> return rold -> umin_value == 0 && <NEW_LINE><TAB> <TAB> <TAB> rold -> umax_value == U64_MAX && <NEW_LINE><TAB> <TAB> <TAB> rold -> smin_value == S64_MIN && <NEW_LINE><TAB> <TAB> <TAB> rold -> smax_value == S64_MAX && <NEW_LINE><TAB> <TAB> <TAB> tnum_is_unknown ( rold -> var_off ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> case PTR_TO_MAP_VALUE :
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : * unnormalized * fft transform <NEW_LINE> <START_VULN> last mod : $ Id : smallft . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdio . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h" <NEW_LINE> #include "codec_internal . h" <NEW_LINE> #include "registry . h"
<START_VULN> <TAB> <TAB> if ( client -> type == USER_CLIENT ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> snd_seq_fifo_clear ( client -> data . user . fifo ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( filter [ i ] . jt != 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> if ( filter [ i ] . jf ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> t_offset += is_near ( f_offset ) ? 2 : 6 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> EMIT_COND_JMP ( t_op , t_offset ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> if ( filter [ i ] . jf ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> EMIT_JMP ( f_offset ) ;
class nsBindingManager ; <NEW_LINE> class nsIDOMNodeList ; <NEW_LINE> class mozAutoSubtreeModified ; <NEW_LINE> struct JSObject ; <NEW_LINE> class nsFrameLoader ; <NEW_LINE> #define NS_IDOCUMENT_IID \ <NEW_LINE> <START_VULN> <TAB> { 0x5f0203a8 , 0xd926 , 0x4adf , \ <NEW_LINE><TAB> { 0xba , 0x96 , 0xe6 , 0xc3 , 0xe6 , 0xbb , 0x1b , 0xe5 } } <NEW_LINE> <END_VULN> #define NS_STYLESHEET_FROM_CATALOG ( 1 << 0 )
<TAB> if ( error ) <NEW_LINE> <TAB> <TAB> return error ; <NEW_LINE> <START_VULN> <TAB> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <NEW_LINE> <END_VULN> <TAB> dget ( new_dentry ) ; <NEW_LINE> <TAB> if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) <NEW_LINE> <TAB> <TAB> lock_two_nondirectories ( source , target ) ;
<TAB> <TAB> UNROLL3 ( { <NEW_LINE> <TAB> <TAB> pos = pos -> next ; <NEW_LINE> <TAB> <TAB> if ( pos -> x >= edge -> x ) <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> } ) <NEW_LINE> <TAB> } while ( TRUE ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <NEW_LINE><TAB> pos -> prev -> next = edge ; <NEW_LINE><TAB> edge -> prev = pos -> prev ; <NEW_LINE><TAB> edge -> next = pos ; <NEW_LINE><TAB> pos -> prev = edge ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline cairo_bool_t <NEW_LINE> sweep_line_insert ( sweep_line_t <TAB> * sweep , <NEW_LINE> <TAB> <TAB> rectangle_t <TAB> * rectangle ) <NEW_LINE> { <NEW_LINE> <TAB> edge_t * pos ;
<TAB> <TAB> <TAB> free ( s ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> sdb_num_set ( sdb_version , "cnt" , entry -> vn_cnt , 0 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> vstart += entry -> vn_aux ; <NEW_LINE> <END_VULN> <TAB> <TAB> for ( j = 0 , isum = i + entry -> vn_aux ; j < entry -> vn_cnt && vstart + sizeof ( Elf_ ( Vernaux ) ) <= end ; + + j ) { <NEW_LINE> <TAB> <TAB> <TAB> int k ; <NEW_LINE> <TAB> <TAB> <TAB> Elf_ ( Vernaux ) * aux = NULL ;
while ( v ) { <NEW_LINE> <TAB> ret + + ; <NEW_LINE> <TAB> v >> = 1 ; <NEW_LINE> } <NEW_LINE> return ( ret ) ; <NEW_LINE> } <NEW_LINE> static void mapping0_pack ( vorbis_info * vi , vorbis_info_mapping * vm , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> oggpack_buffer * opb ) { <NEW_LINE> <END_VULN> int i ; <NEW_LINE> vorbis_info_mapping0 * info = ( vorbis_info_mapping0 * ) vm ; <NEW_LINE> if ( info -> submaps > 1 ) { <NEW_LINE> <TAB> for ( i = 0 ; i < vi -> channels ; i + + ) {
<START_VULN> <TAB> static bool neuterViews ( JSContext * cx , Handle < ArrayBufferObject * > buffer ) ; <NEW_LINE> <END_VULN> <TAB> uint8_t * dataPointer ( ) const ;
<TAB> if ( ! ip6_checkentry ( & e -> ipv6 ) ) <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <START_VULN> <TAB> ret = xt_compat_check_entry_offsets ( e , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> e -> target_offset , e -> next_offset ) ; <NEW_LINE> <TAB> if ( ret ) <NEW_LINE> <TAB> <TAB> return ret ;
int sized_string_cmp ( <NEW_LINE> <START_VULN> SIZED_STRING * s1 , <NEW_LINE>SIZED_STRING * s2 ) ; <NEW_LINE> <END_VULN> #endif
<TAB> mutt_buffer_init ( & err ) ; <NEW_LINE> <TAB> err . data = errstr ; <NEW_LINE> <TAB> err . dsize = sizeof ( errstr ) ; <NEW_LINE> <START_VULN> <TAB> snprintf ( mbox , sizeof ( mbox ) , " % smailboxes \" % s\"" , subscribe ? "" : "un" , path ) ; <NEW_LINE> <END_VULN> <TAB> if ( mutt_parse_rc_line ( mbox , & token , & err ) ) <NEW_LINE> <TAB> mutt_debug ( 1 , "Error adding subscribed mailbox : % s\n" , errstr ) ; <NEW_LINE> <TAB> FREE ( & token . data ) ;
MODULE_DESCRIPTION ( "Twofish Cipher Algorithm , AVX optimized" ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "twofish" ) ; <NEW_LINE> <END_VULN>
<TAB> unsigned int computed_mac_length ; <NEW_LINE> <TAB> unsigned char iv [ AES_BLOCK_SIZE ] ; <NEW_LINE> <TAB> SECItem ivItem ; <NEW_LINE> <TAB> SECItem * srvName = NULL ; <NEW_LINE> <TAB> PRUint32 srvNameLen = 0 ; <NEW_LINE> <TAB> CK_MECHANISM_TYPE msWrapMech = 0 ; <NEW_LINE> <START_VULN> <TAB> SSL_TRC ( 3 , ( " % d : SSL3 [ % d ] : send session_ticket handshake" , <NEW_LINE><TAB> <TAB> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> <END_VULN> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveXmitBufLock ( ss ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> <TAB> ticket . ticket_lifetime_hint = TLS_EX_SESS_TICKET_LIFETIME_HINT ; <NEW_LINE> <TAB> cert_length = ( ss -> opt . requestCertificate && ss -> sec . ci . sid -> peerCert ) ? <NEW_LINE> <TAB> 3 + ss -> sec . ci . sid -> peerCert -> derCert . len : 0 ;
<TAB> for ( i = 0 ; i < PACKETBLOBS ; i + + ) { <NEW_LINE> <TAB> if ( i == PACKETBLOBS / 2 ) { <NEW_LINE> <TAB> <TAB> vbi -> packetblob [ i ] = & vb -> opb ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> vbi -> packetblob [ i ] = <NEW_LINE> <TAB> <TAB> _ogg_calloc ( 1 , sizeof ( oggpack_buffer ) ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> oggpack_writeinit ( vbi -> packetblob [ i ] ) ; <NEW_LINE> <START_VULN> <TAB> } <NEW_LINE> <END_VULN> } <NEW_LINE> return ( 0 ) ; <NEW_LINE> } <NEW_LINE> void * _vorbis_block_alloc ( vorbis_block * vb , long bytes ) { <NEW_LINE> bytes = ( bytes + ( WORD_ALIGN - 1 ) ) & ~ ( WORD_ALIGN - 1 ) ; <NEW_LINE> if ( bytes + vb -> localtop > vb -> localalloc ) {
friend class CanvasRenderingContext2DUserData ; <NEW_LINE> protected : <NEW_LINE> nsresult GetImageDataArray ( JSContext * aCx , int32_t aX , int32_t aY , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t aWidth , uint32_t aHeight , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject ** aRetval ) ; <NEW_LINE> nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> unsigned char * aData , uint32_t aDataLen , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> int32_t dirtyWidth , int32_t dirtyHeight ) ; <NEW_LINE> nsresult Initialize ( int32_t width , int32_t height ) ;
{ <NEW_LINE> <TAB> FILE * f ; <NEW_LINE> <TAB> char * tmpname ; <NEW_LINE> <START_VULN> <TAB> f = xfmkstemp ( & tmpname , NULL ) ; <NEW_LINE> <END_VULN> <TAB> unlink ( tmpname ) ; <NEW_LINE> <TAB> free ( tmpname ) ; <NEW_LINE> <TAB> fclose ( f ) ;
<TAB> <TAB> we're * not * floor1 . This won't happen unless someone has <NEW_LINE> <TAB> <TAB> broken the encode setup lib . Guard it anyway . * / <NEW_LINE> <TAB> if ( ci -> floor_type [ info -> floorsubmap [ submap ] ] != 1 ) return ( - 1 ) ; <NEW_LINE> <TAB> floor_posts [ i ] [ PACKETBLOBS / 2 ] = <NEW_LINE> <TAB> <TAB> floor1_fit ( vb , b -> flr [ info -> floorsubmap [ submap ] ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> logmdct , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> logmask ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> if ( vorbis_bitrate_managed ( vb ) && floor_posts [ i ] [ PACKETBLOBS / 2 ] ) { <NEW_LINE> <TAB> <TAB> _vp_offset_and_mix ( psy_look , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> noise , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> tone ,
<TAB> <TAB> if ( stat ( fname , & s ) == 0 ) <NEW_LINE> <TAB> <TAB> <TAB> return ; <NEW_LINE> <TAB> <TAB> if ( stat ( " / etc / skel / . bashrc" , & s ) == 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( copy_file ( " / etc / skel / . bashrc" , fname , u , g , 0644 ) == 0 ) { <NEW_LINE><TAB> <TAB> <TAB> <TAB> fs_logger ( "clone / etc / skel / . bashrc" ) ; <NEW_LINE><TAB> <TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> free ( fname ) ; <NEW_LINE> <TAB> }
<TAB> if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) <NEW_LINE> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> for ( i = 0 ; i < sh . sh_properties ; i + + ) { <NEW_LINE> <START_VULN> <TAB> <TAB> size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> q = ( const uint8_t * ) ( const void * ) <NEW_LINE> <TAB> <TAB> ( ( const char * ) ( const void * ) p + ofs <NEW_LINE> <TAB> <TAB> - 2 * sizeof ( uint32_t ) ) ;
<TAB> <TAB> <TAB> for ( i = 1 ; i <= length ; i + + ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( ! IndexToId ( cx , i , & id ) ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> return JS_FALSE ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> if ( ! IndexToId ( cx , i - 1 , & id2 ) ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> return JS_FALSE ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> if ( ! OBJ_GET_PROPERTY ( cx , obj , id , & argv [ 0 ] ) ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> return JS_FALSE ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( ! OBJ_SET_PROPERTY ( cx , obj , id2 , & argv [ 0 ] ) ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> return JS_FALSE ; <NEW_LINE> <TAB> <TAB> <TAB> }
bool IsPaused ( ) ; <NEW_LINE> int GetRate ( ) { return mOutRate ; } <NEW_LINE> int GetChannels ( ) { return mChannels ; } <NEW_LINE> int GetOutChannels ( ) { return mOutChannels ; } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE>nsresult EnsureTimeStretcherInitialized ( ) ; <NEW_LINE> <END_VULN> nsresult SetPlaybackRate ( double aPlaybackRate ) ; <NEW_LINE> nsresult SetPreservesPitch ( bool aPreservesPitch ) ; <NEW_LINE> size_t SizeOfIncludingThis ( MallocSizeOf aMallocSizeOf ) const ; <NEW_LINE> private : <NEW_LINE> friend class AudioInitTask ; <NEW_LINE> nsresult OpenCubeb ( cubeb_stream_params & aParams , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> LatencyRequest aLatencyRequest ) ; <NEW_LINE> void CheckForStart ( ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha1" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> <TAB> BCC ( smb_buffer_response ) ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> kfree ( tcon -> nativeFileSystem ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> tcon -> nativeFileSystem = <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> kzalloc ( length + 2 , GFP_KERNEL ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> if ( tcon -> nativeFileSystem ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> cifs_strfromUCS_le ( <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> tcon -> nativeFileSystem ,
<TAB> lblkno = args -> rmtblkno ; <NEW_LINE> <TAB> blkcnt = args -> rmtblkcnt ; <NEW_LINE> <START_VULN> <TAB> valuelen = args -> valuelen ; <NEW_LINE> <END_VULN> <TAB> while ( valuelen > 0 ) { <NEW_LINE> <TAB> <TAB> struct xfs_buf <TAB> * bp ; <NEW_LINE> <TAB> <TAB> xfs_daddr_t <TAB> dblkno ;
#define aes_xts_encrypt <TAB> <TAB> neon_aes_xts_encrypt <NEW_LINE> #define aes_xts_decrypt <TAB> <TAB> neon_aes_xts_decrypt <NEW_LINE> MODULE_DESCRIPTION ( "AES - ECB / CBC / CTR / XTS using ARMv8 NEON" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "ecb ( aes ) " ) ; <NEW_LINE>MODULE_ALIAS ( "cbc ( aes ) " ) ; <NEW_LINE>MODULE_ALIAS ( "ctr ( aes ) " ) ; <NEW_LINE>MODULE_ALIAS ( "xts ( aes ) " ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> MODULE_AUTHOR ( "Ard Biesheuvel < ard . biesheuvel@linaro . org > " ) ;
end : <NEW_LINE> <TAB> if ( TRUE == local_tx_started ) { <NEW_LINE> <START_VULN> <TAB> <TAB> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <TAB> <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> DBG_INF ( ret == PASS ? "PASS" : "FAIL" ) ; <NEW_LINE> <TAB> DBG_RETURN ( ret ) ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 54 2014 / 02 / 25 20 : 52 : 02 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include < assert . h >
{ <NEW_LINE> <TAB> static gstrings_ret ret ; <NEW_LINE> <TAB> char * prime_arg ; <NEW_LINE> <START_VULN> <TAB> gss_buffer_desc client_name , <NEW_LINE><TAB> <TAB> service_name ; <NEW_LINE> <END_VULN> <TAB> OM_uint32 minor_stat ; <NEW_LINE> <TAB> kadm5_server_handle_t handle ; <NEW_LINE> <TAB> const char * errmsg = NULL ;
virtual void ShowDropDown ( bool aDoDropDown ) ; <NEW_LINE> virtual nsIFrame * GetDropDown ( ) ; <NEW_LINE> virtual void SetDropDown ( nsIFrame * aDropDownFrame ) ; <NEW_LINE> virtual void RollupFromList ( ) ; <NEW_LINE> <START_VULN> virtual void AbsolutelyPositionDropDown ( ) ; <NEW_LINE> <END_VULN> virtual PRInt32 GetIndexOfDisplayArea ( ) ; <NEW_LINE> NS_IMETHOD RedisplaySelectedText ( ) ; <NEW_LINE> virtual PRInt32 UpdateRecentIndex ( PRInt32 aIndex ) ; <NEW_LINE> virtual void OnContentReset ( ) ;
<TAB> <TAB> <TAB> add_assoc_long ( * subarray , "weight" , n ) ; <NEW_LINE> <TAB> <TAB> <TAB> GETSHORT ( n , cp ) ; <NEW_LINE> <TAB> <TAB> <TAB> add_assoc_long ( * subarray , "port" , n ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> n = dn_expand ( answer -> qb2 , answer -> qb2 + 65536 , cp , name , ( sizeof name ) - 2 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( n < 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> <TAB> <TAB> }
void SetFlags ( uint32_t aFlagsToSet ) <NEW_LINE> { <NEW_LINE> <TAB> NS_ASSERTION ( ! ( aFlagsToSet & ( NODE_IS_ANONYMOUS | <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> NODE_IS_NATIVE_ANONYMOUS_ROOT | <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> NODE_IS_IN_ANONYMOUS_SUBTREE | <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> NODE_ATTACH_BINDING_ON_POSTCREATE | <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> NODE_DESCENDANTS_NEED_FRAMES | <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> NODE_NEEDS_FRAME ) ) || <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> IsNodeOfType ( eCONTENT ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> "Flag only permitted on nsIContent nodes" ) ; <NEW_LINE> <TAB> mFlags |= aFlagsToSet ; <NEW_LINE> } <NEW_LINE> void UnsetFlags ( uint32_t aFlagsToUnset ) <NEW_LINE> { <NEW_LINE> <TAB> NS_ASSERTION ( ! ( aFlagsToUnset &
<TAB> int pixel_skip ; <NEW_LINE> <TAB> int pixel_countdown ; <NEW_LINE> <TAB> unsigned char * pixels ; <NEW_LINE> <START_VULN> <TAB> int pixel_limit ; <NEW_LINE> <END_VULN> <TAB> s -> frame . reference = 1 ; <NEW_LINE> <TAB> s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;
<TAB> if ( ! ( image = jas_image_create ( numcmpts , cmptparms , <NEW_LINE> <TAB> JAS_CLRSPC_UNKNOWN ) ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> bmp_info_destroy ( info ) ; <NEW_LINE><TAB> <TAB> return 0 ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( numcmpts == 3 ) {
0 . 8928678298F , 0 . 9080153310F , 0 . 9217306608F , 0 . 9340480615F , <NEW_LINE> 0 . 9450138200F , 0 . 9546851041F , 0 . 9631286621F , 0 . 9704194171F , <NEW_LINE> 0 . 9766389810F , 0 . 9818741197F , 0 . 9862151938F , 0 . 9897546035F , <NEW_LINE> 0 . 9925852598F , 0 . 9947991032F , 0 . 9964856900F , 0 . 9977308602F , <NEW_LINE> 0 . 9986155015F , 0 . 9992144193F , 0 . 9995953200F , 0 . 9998179155F , <NEW_LINE> 0 . 9999331503F , 0 . 9999825563F , 0 . 9999977357F , 0 . 9999999720F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin256 [ 128 ] = { <NEW_LINE> <END_VULN> 0 . 0000591390F , 0 . 0005321979F , 0 . 0014780301F , 0 . 0028960636F , <NEW_LINE> 0 . 0047854363F , 0 . 0071449926F , 0 . 0099732775F , 0 . 0132685298F , <NEW_LINE> 0 . 0170286741F , 0 . 0212513119F , 0 . 0259337111F , 0 . 0310727950F , <NEW_LINE> 0 . 0366651302F , 0 . 0427069140F , 0 . 0491939614F , 0 . 0561216907F , <NEW_LINE> 0 . 0634851102F , 0 . 0712788035F , 0 . 0794969160F , 0 . 0881331402F , <NEW_LINE> 0 . 0971807028F , 0 . 1066323515F , 0 . 1164803426F , 0 . 1267164297F , <NEW_LINE> 0 . 1373318534F , 0 . 1483173323F , 0 . 1596630553F , 0 . 1713586755F , <NEW_LINE> 0 . 1833933062F , 0 . 1957555184F , 0 . 2084333404F , 0 . 2214142599F ,
<TAB> return current -> prevType ( ) ; <NEW_LINE> } <NEW_LINE> inline bool <NEW_LINE> IonFrameIterator : : isFakeExitFrame ( ) const <NEW_LINE> { <NEW_LINE> <TAB> bool res = ( prevType ( ) == JitFrame_Unwound_Rectifier || <NEW_LINE> <TAB> <TAB> <TAB> <TAB> prevType ( ) == JitFrame_Unwound_IonJS || <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> prevType ( ) == JitFrame_Unwound_BaselineStub ) ; <NEW_LINE> <END_VULN> <TAB> JS_ASSERT_IF ( res , type ( ) == JitFrame_Exit || type ( ) == JitFrame_BaselineJS ) ; <NEW_LINE> <TAB> return res ; <NEW_LINE> } <NEW_LINE> inline IonExitFrameLayout * <NEW_LINE> IonFrameIterator : : exitFrame ( ) const <NEW_LINE> { <NEW_LINE> <TAB> JS_ASSERT ( type ( ) == JitFrame_Exit ) ;
PRInt16 GetType ( ) { return mType ; } <NEW_LINE> PRInt8 GetCropStyle ( ) { return mCropStyle ; } <NEW_LINE> PRInt32 GetTextAlignment ( ) { return mTextAlignment ; } <NEW_LINE> nsTreeColumn * GetNext ( ) { return mNext ; } <NEW_LINE> nsTreeColumn * GetPrevious ( ) { return mPrevious ; } <NEW_LINE> <START_VULN> void SetNext ( nsTreeColumn * aNext ) { NS_IF_ADDREF ( mNext = aNext ) ; } <NEW_LINE> <END_VULN> void SetPrevious ( nsTreeColumn * aPrevious ) { mPrevious = aPrevious ; } <NEW_LINE> private : <NEW_LINE> nsCOMPtr < nsIContent > mContent ;
{ <NEW_LINE> <TAB> char * s2 = 0 ; <NEW_LINE> <TAB> if ( s1 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> s2 = malloc ( strlen ( s1 ) + 1 ) ; <NEW_LINE><TAB> <TAB> strcpy ( s2 , s1 ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return s2 ; <NEW_LINE> }
<TAB> } <NEW_LINE> <TAB> mBuffer . AdvanceKnownTracksTime ( GraphTimeToStreamTime ( aTo ) ) ; <NEW_LINE> } <NEW_LINE> protected : <NEW_LINE> struct TrackMapEntry { <NEW_LINE> <TAB> MediaInputPort * mInputPort ; <NEW_LINE> <START_VULN> <TAB> StreamBuffer : : Track * mInputTrack ; <NEW_LINE><TAB> StreamBuffer : : Track * mOutputTrack ; <NEW_LINE> <END_VULN> <TAB> nsAutoPtr < MediaSegment > mSegment ; <NEW_LINE> } ; <NEW_LINE> uint32_t AddTrack ( MediaInputPort * aPort , StreamBuffer : : Track * aTrack , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> GraphTime aFrom ) <NEW_LINE> {
<TAB> Vector < CFGState , 8 , IonAllocPolicy > cfgStack_ ; <NEW_LINE> <TAB> Vector < ControlFlowInfo , 4 , IonAllocPolicy > loops_ ; <NEW_LINE> <TAB> Vector < ControlFlowInfo , 0 , IonAllocPolicy > switches_ ; <NEW_LINE> <TAB> Vector < ControlFlowInfo , 2 , IonAllocPolicy > labels_ ; <NEW_LINE> <TAB> Vector < MInstruction * , 2 , IonAllocPolicy > iterators_ ; <NEW_LINE> <TAB> TypeOracle * oracle ; <NEW_LINE> <START_VULN> <TAB> size_t inliningDepth ; <NEW_LINE> <END_VULN> <TAB> Vector < MDefinition * , 0 , IonAllocPolicy > inlinedArguments_ ; <NEW_LINE> <TAB> bool failedBoundsCheck_ ;
<TAB> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> pid_t child = fork ( ) ; <NEW_LINE><TAB> <TAB> if ( child < 0 ) <NEW_LINE><TAB> <TAB> <TAB> errExit ( "fork" ) ; <NEW_LINE><TAB> <TAB> if ( child == 0 ) { <NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> drop_privs ( 0 ) ; <NEW_LINE><TAB> <NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , 0600 ) ; <NEW_LINE><TAB> <TAB> <TAB> if ( rv ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> fprintf ( stderr , "Warning : cannot transfer . Xauthority in private home directory\n" ) ; <NEW_LINE><TAB> <TAB> <TAB> else { <NEW_LINE><TAB> <TAB> <TAB> <TAB> fs_logger2 ( "clone" , dest ) ; <NEW_LINE><TAB> <TAB> <TAB> } <NEW_LINE><TAB> <TAB> <TAB> _exit ( 0 ) ; <NEW_LINE><TAB> <TAB> } <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> waitpid ( child , NULL , 0 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return 1 ; <NEW_LINE> <TAB> }
<TAB> if ( seed [ seedptr ] < lin ) seed [ seedptr ] = lin ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> seedptr += linesper ; <NEW_LINE> <TAB> if ( seedptr >= n ) break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> static void seed_loop ( vorbis_look_psy * p , <NEW_LINE> <START_VULN> <TAB> <TAB> const float ** * curves , <NEW_LINE><TAB> <TAB> const float * f , <NEW_LINE><TAB> <TAB> const float * flr , <NEW_LINE><TAB> <TAB> float * seed , <NEW_LINE><TAB> <TAB> float specmax ) { <NEW_LINE> <END_VULN> vorbis_info_psy * vi = p -> vi ; <NEW_LINE> long n = p -> n , i ; <NEW_LINE> float dBoffset = vi -> max_curve_dB - specmax ; <NEW_LINE> for ( i = 0 ; i < n ; i + + ) { <NEW_LINE> <TAB> float max = f [ i ] ;
<TAB> txStack mResultHandlerStack ; <NEW_LINE> <TAB> txStack mParamStack ; <NEW_LINE> <TAB> txInstruction * mNextInstruction ; <NEW_LINE> <TAB> txVariableMap * mLocalVariables ; <NEW_LINE> <TAB> txVariableMap mGlobalVariableValues ; <NEW_LINE> <TAB> nsRefPtr < txAExprResult > mGlobalVarPlaceholderValue ; <NEW_LINE> <TAB> PRInt32 mRecursionDepth ; <NEW_LINE> <START_VULN> <TAB> TemplateRule * mTemplateRules ; <NEW_LINE><TAB> PRInt32 mTemplateRulesBufferSize ; <NEW_LINE><TAB> PRInt32 mTemplateRuleCount ; <NEW_LINE> <END_VULN> <TAB> txIEvalContext * mEvalContext ; <NEW_LINE> <TAB> txIEvalContext * mInitialEvalContext ; <NEW_LINE> <TAB> txOwningExpandedNameMap < txIGlobalParameter > * mGlobalParams ; <NEW_LINE> <TAB> txLoadedDocumentsHash mLoadedDocuments ; <NEW_LINE> <TAB> txKeyHash mKeyHash ;
<TAB> <TAB> unsigned char tmp ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ( op & ASN1_OP_MATCH__COND && <NEW_LINE><TAB> <TAB> flags & FLAG_MATCHED ) || <NEW_LINE><TAB> <TAB> dp == datalen ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> flags &= ~ FLAG_LAST_MATCHED ; <NEW_LINE> <TAB> <TAB> <TAB> pc += asn1_op_lengths [ op ] ; <NEW_LINE> <TAB> <TAB> <TAB> goto next_op ;
<TAB> <TAB> if ( ! ( mGeneration + 1 ) . valid ( ) ) <NEW_LINE> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <TAB> <TAB> + + mGeneration ; <NEW_LINE> <TAB> <TAB> mMapUniformLocations . Clear ( ) ; <NEW_LINE> <TAB> <TAB> return true ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> already_AddRefed < WebGLUniformLocation > GetUniformLocationObject ( GLint glLocation ) ; <NEW_LINE> <END_VULN> <TAB> bool UpdateInfo ( gl : : GLContext * gl ) ; <NEW_LINE> <TAB> WebGLint UniformMaxNameLength ( ) const { return mUniformMaxNameLength ; } <NEW_LINE> <TAB> WebGLint AttribMaxNameLength ( ) const { return mAttribMaxNameLength ; } <NEW_LINE> <TAB> WebGLint UniformCount ( ) const { return mUniformCount ; }
nsresult Init ( ) ; <NEW_LINE> void LoadDictionaryList ( ) ; <NEW_LINE> nsresult ConvertCharset ( const PRUnichar * aStr , char ** aDst ) ; <NEW_LINE> <START_VULN> static void OnAlloc ( void * ptr ) { sAmount += MallocSizeOfOnAlloc ( ptr ) ; } <NEW_LINE>static void OnFree ( void * ptr ) { sAmount -= MallocSizeOfOnFree ( ptr ) ; } <NEW_LINE><NEW_LINE>int64_t Amount ( ) MOZ_OVERRIDE { return sAmount ; } <NEW_LINE> <END_VULN> protected : <NEW_LINE> nsCOMPtr < mozIPersonalDictionary > mPersonalDictionary ; <NEW_LINE> nsCOMPtr < nsIUnicodeEncoder > mEncoder ; <NEW_LINE> nsCOMPtr < nsIUnicodeDecoder > mDecoder ;
{ <NEW_LINE> <TAB> AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; <NEW_LINE> <TAB> unsigned char * buf = NULL ; <NEW_LINE> <START_VULN> <TAB> int ret = 0 , probe_size ; <NEW_LINE> <END_VULN> <TAB> if ( ! max_probe_size ) { <NEW_LINE> <TAB> <TAB> max_probe_size = PROBE_BUF_MAX ;
<TAB> ! jbd2_journal_set_features ( EXT4_SB ( sb ) -> s_journal , 0 , 0 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> JBD2_FEATURE_INCOMPAT_64BIT ) ) { <NEW_LINE> <TAB> <TAB> ext4_msg ( sb , KERN_ERR , "Failed to set 64 - bit journal feature" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> goto failed_mount4 ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) {
<TAB> <TAB> sas_port_delete_phy ( phy -> port , phy -> phy ) ; <NEW_LINE> <TAB> <TAB> sas_device_set_phy ( found , phy -> port ) ; <NEW_LINE> <TAB> <TAB> if ( phy -> port -> num_phys == 0 ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> sas_port_delete ( phy -> port ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> phy -> port = NULL ; <NEW_LINE> <TAB> } <NEW_LINE> }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : libvorbis backend and mapping structures ; needed for <NEW_LINE> <TAB> <TAB> <TAB> static mode headers <NEW_LINE> <START_VULN> last mod : $ Id : backends . h 16326 2009 - 07 - 24 00 : 06 : 53Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _vorbis_backend_h_
<TAB> <TAB> <TAB> while ( nz >= 8 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> c = ( z >> ( nz - 8 ) ) & 0xff ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( jas_stream_putc ( out , c ) == EOF ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> return - 1 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> nz -= 8 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> z &= RAS_ONES ( nz ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIPrincipal * originPrincipal , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsISupports * context , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsACString & mimeType , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsISupports * extra , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> int16_t * decision , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIContentPolicy * policyService = nullptr , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIScriptSecurityManager * aSecMan = nullptr ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> CHECK_PRINCIPAL ; <NEW_LINE> <END_VULN> <TAB> if ( policyService ) { <NEW_LINE> <TAB> <TAB> CHECK_CONTENT_POLICY_WITH_SERVICE ( ShouldLoad , policyService ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> CHECK_CONTENT_POLICY ( ShouldLoad ) ; <NEW_LINE> }
<TAB> } <NEW_LINE> <START_VULN> <TAB> err = __video_do_ioctl ( file , cmd , parg ) ; <NEW_LINE> <END_VULN> <TAB> if ( err == - ENOIOCTLCMD ) <NEW_LINE> <TAB> <TAB> err = - EINVAL ;
<TAB> <TAB> <TAB> for ( conn_opt = conn_opts ; conn_opt -> keyword != NULL ; conn_opt + + ) <NEW_LINE> <TAB> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> argcount + + ; <NEW_LINE> <TAB> <TAB> <TAB> }
<START_VULN> <TAB> <TAB> if ( * vm_flags & ( VM_NOHUGEPAGE | <NEW_LINE><TAB> <TAB> <TAB> <TAB> VM_SHARED | VM_MAYSHARE | <NEW_LINE><TAB> <TAB> <TAB> <TAB> VM_PFNMAP | VM_IO | VM_DONTEXPAND | <NEW_LINE><TAB> <TAB> <TAB> <TAB> VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | <NEW_LINE><TAB> <TAB> <TAB> <TAB> VM_MIXEDMAP | VM_SAO ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> <TAB> * vm_flags &= ~ VM_HUGEPAGE ; <NEW_LINE> <TAB> <TAB> * vm_flags |= VM_NOHUGEPAGE ;
<TAB> rcu_read_unlock ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void timerfd_remove_cancel ( struct timerfd_ctx * ctx ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> if ( ctx -> might_cancel ) { <NEW_LINE> <TAB> <TAB> ctx -> might_cancel = false ;
<TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } while ( base_was_tested ) ; <NEW_LINE> <TAB> <TAB> mpz_init_set ( tested [ i ] , a ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> mpz_powm ( z , a , m , n ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ( mpz_cmp_ui ( z , 1 ) == 0 ) || ( mpz_cmp ( z , n_1 ) == 0 ) ) <NEW_LINE> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> composite = 1 ;
<TAB> <TAB> case IS_UNDEF : <NEW_LINE> <TAB> <TAB> <TAB> if ( swoole_seria_check_eof ( buffer , len ) < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> php_error_docref ( NULL TSRMLS_CC , E_NOTICE , "detect the error eof" ) ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> return SW_FALSE ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> unser_start = buffer - sizeof ( SBucketType ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ! swoole_unserialize_object ( buffer , return_value , type . data_len , object_args , flag ) )
typedef double iw_tmpsample ; <NEW_LINE> #ifdef IW_64BIT <NEW_LINE> <START_VULN> #define IW_DEFAULT_MAX_DIMENSION 1000000 <NEW_LINE>#define IW_DEFAULT_MAX_MALLOC 2000000000000 <NEW_LINE> <END_VULN> #else <NEW_LINE> #define IW_DEFAULT_MAX_DIMENSION 40000 <NEW_LINE> #define IW_DEFAULT_MAX_MALLOC 2000000000
<TAB> fn = fib6_add_1 ( root , & rt -> rt6i_dst . addr , rt -> rt6i_dst . plen , <NEW_LINE> <TAB> <TAB> <TAB> offsetof ( struct rt6_info , rt6i_dst ) , allow_create , <NEW_LINE> <TAB> <TAB> <TAB> replace_required ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> if ( IS_ERR ( fn ) ) { <NEW_LINE> <TAB> <TAB> err = PTR_ERR ( fn ) ; <NEW_LINE> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> }
<TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( context && <NEW_LINE> <END_VULN> <TAB> php_stream_context_get_option ( context , "http" , "user_agent" , & ua_zval ) == SUCCESS && <NEW_LINE> <TAB> <TAB> Z_TYPE_PP ( ua_zval ) == IS_STRING ) { <NEW_LINE> <TAB> <TAB> ua_str = Z_STRVAL_PP ( ua_zval ) ;
static __u8 * sp_report_fixup ( struct hid_device * hdev , __u8 * rdesc , <NEW_LINE> <TAB> <TAB> unsigned int * rsize ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> rdesc [ 106 ] == 0x03 ) { <NEW_LINE> <TAB> <TAB> hid_info ( hdev , "fixing up Sunplus Wireless Desktop report descriptor\n" ) ; <NEW_LINE> <TAB> <TAB> rdesc [ 105 ] = rdesc [ 110 ] = 0x03 ;
<TAB> if ( ! ( plen <= * len ) ) <NEW_LINE> <TAB> <TAB> printf ( "PLEN % d type % d len % d\n" , <NEW_LINE> <TAB> <TAB> <TAB> plen , nh . nh_type , * len ) ; <NEW_LINE> <START_VULN> <TAB> assert ( plen <= * len ) ; <NEW_LINE> <END_VULN> <TAB> * len = plen ; <NEW_LINE> <TAB> if ( ( * len ) && ( net_read_exact ( s , arg , * len ) == - 1 ) )
{ <NEW_LINE> <TAB> struct sock * sk = skb -> sk ; <NEW_LINE> <TAB> struct inet_sock * inet = inet_sk ( sk ) ; <NEW_LINE> <START_VULN> <TAB> struct ip_options * opt = inet -> opt ; <NEW_LINE> <END_VULN> <TAB> struct rtable * rt ; <NEW_LINE> <TAB> struct iphdr * iph ; <NEW_LINE> <TAB> int res ;
<TAB> state -> empty = 1 ; <NEW_LINE> <TAB> alloc = sizeof ( struct posix_ace_state_array ) <NEW_LINE> <START_VULN> <TAB> <TAB> + cnt * sizeof ( struct posix_ace_state ) ; <NEW_LINE> <END_VULN> <TAB> state -> users = kzalloc ( alloc , GFP_KERNEL ) ; <NEW_LINE> <TAB> if ( ! state -> users ) <NEW_LINE> <TAB> <TAB> return - ENOMEM ;
<START_VULN> <TAB> <TAB> <TAB> if ( rt -> rt6i_flags & RTF_GATEWAY && <NEW_LINE><TAB> <TAB> <TAB> ! ( rt -> rt6i_flags & RTF_EXPIRES ) && <NEW_LINE><TAB> <TAB> <TAB> ! ( iter -> rt6i_flags & RTF_EXPIRES ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> rt -> rt6i_nsiblings + + ; <NEW_LINE> <TAB> <TAB> }
<TAB> ret = 0 ; <NEW_LINE> exit : <NEW_LINE> <START_VULN> <TAB> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <NEW_LINE> <END_VULN> <TAB> return ret <= 0 ? ret : - EIO ; <NEW_LINE> }
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 61 2014 / 06 / 04 17 : 23 : 19 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include < assert . h >
<TAB> <TAB> fprintf ( trace , "\" KID = \"" ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> dump_data_hex ( trace , ( char * ) ptr -> KID , 16 ) ; <NEW_LINE> <START_VULN> <TAB> if ( ptr -> version ) <NEW_LINE> <END_VULN> <TAB> <TAB> fprintf ( trace , "\" crypt_byte_block = \" % d\" skip_byte_block = \" % d" , ptr -> crypt_byte_block , ptr -> skip_byte_block ) ; <NEW_LINE> <TAB> fprintf ( trace , "\" > \n" ) ; <NEW_LINE> <TAB> gf_isom_box_dump_done ( "TrackEncryptionBox" , a , trace ) ;
<TAB> if ( ( jformat = ippFindAttribute ( job -> attrs , "document - format" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> IPP_TAG_MIMETYPE ) ) != NULL ) <NEW_LINE> <START_VULN> <TAB> { <NEW_LINE><TAB> _cupsStrFree ( jformat -> values [ 0 ] . string . text ) ; <NEW_LINE><NEW_LINE><TAB> jformat -> values [ 0 ] . string . text = _cupsStrAlloc ( mimetype ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> else <NEW_LINE> <TAB> ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_MIMETYPE , <NEW_LINE> <TAB> "document - format" , NULL , mimetype ) ;
<TAB> <TAB> <TAB> opt = NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( opt == NULL ) <NEW_LINE><TAB> <TAB> opt = np -> opt ; <NEW_LINE> <END_VULN> <TAB> if ( flowlabel ) <NEW_LINE> <TAB> <TAB> opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; <NEW_LINE> <TAB> opt = ipv6_fixup_options ( & opt_space , opt ) ;
<TAB> Mpi2DiagBufferPostReply_t * mpi_reply ; <NEW_LINE> <TAB> int rc , i ; <NEW_LINE> <TAB> u8 buffer_type ; <NEW_LINE> <START_VULN> <TAB> unsigned long timeleft ; <NEW_LINE> <END_VULN> <TAB> u16 smid ; <NEW_LINE> <TAB> u16 ioc_status ; <NEW_LINE> <TAB> u8 issue_reset = 0 ;
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "cert . h" <NEW_LINE> #include "secitem . h" <NEW_LINE> #include "keyhi . h" <NEW_LINE> #include "ssl . h" <NEW_LINE> #include "sslimpl . h" <NEW_LINE> #include "sslproto . h" <NEW_LINE> #include "secoid . h" <TAB> <NEW_LINE> #include "pk11func . h" <TAB>
<TAB> if ( ! sar . num ) <NEW_LINE> <TAB> <TAB> sar . num = sar . den = 1 ; <NEW_LINE> <START_VULN> <TAB> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ; <NEW_LINE> <TAB> <TAB> int vsub = plane == 1 || plane == 2 ? vsub0 : 0 ;
<TAB> gpa_t time ; <NEW_LINE> <TAB> struct pvclock_vcpu_time_info hv_clock ; <NEW_LINE> <TAB> unsigned int hw_tsc_khz ; <NEW_LINE> <START_VULN> <TAB> unsigned int time_offset ; <NEW_LINE><TAB> struct page * time_page ; <NEW_LINE> <END_VULN> <TAB> bool pvclock_set_guest_stopped_request ;
<TAB> ( v -> sequence + 1 != vb -> sequence ) ) { <NEW_LINE> <TAB> v -> granulepos = - 1 ; <NEW_LINE> <TAB> b -> sample_count = - 1 ; <NEW_LINE> } <NEW_LINE> v -> sequence = vb -> sequence ; <NEW_LINE> if ( vb -> pcm ) { <NEW_LINE> <TAB> int n = ci -> blocksizes [ v -> W ] >> ( hs + 1 ) ; <NEW_LINE> <TAB> int n0 = ci -> blocksizes [ 0 ] >> ( hs + 1 ) ; <NEW_LINE> <TAB> int n1 = ci -> blocksizes [ 1 ] >> ( hs + 1 ) ; <NEW_LINE> <TAB> int thisCenter ; <NEW_LINE> <TAB> int prevCenter ; <NEW_LINE> <TAB> v -> glue_bits += vb -> glue_bits ;
<TAB> uint8_t * dataPointer ( ) const ; <NEW_LINE> <START_VULN> <TAB> void neuter ( JSContext * cx ) ; <NEW_LINE> <END_VULN>
<TAB> error = cxgb3_ofld_send ( tdev , skb ) ; <NEW_LINE> <TAB> if ( error < 0 ) <NEW_LINE> <TAB> <TAB> kfree_skb ( skb ) ; <NEW_LINE> <START_VULN> <TAB> return error ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void release_tid ( struct t3cdev * tdev , u32 hwtid , struct sk_buff * skb )
<START_VULN> <TAB> if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA ) <NEW_LINE> <END_VULN> <TAB> && ! vendor_intel ( ctxt ) ) <NEW_LINE> <TAB> <TAB> return emulate_ud ( ctxt ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> parenSoFar - curState -> parenSoFar ) ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> goto bad ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> pc = pc + GET_OFFSET ( pc ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> op = ( REOp ) * pc + + ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> JS_ASSERT ( op < REOP_LIMIT ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> now = ktime_add ( now , kj ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> timr -> it_overrun += ( unsigned int ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> hrtimer_forward ( timer , now , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> timr -> it_interval ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ret = HRTIMER_RESTART ; <NEW_LINE> <TAB> <TAB> <TAB> + + timr -> it_requeue_pending ; <NEW_LINE> <TAB> <TAB> <TAB> timr -> it_active = 1 ;
#include < ngx_http . h > <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> static ngx_int_t ngx_http_not_modified_filter_init ( ngx_conf_t * cf ) ;
<TAB> <TAB> retv = 0 ; <NEW_LINE> <TAB> <TAB> opt = ipv6_update_options ( sk , opt ) ; <NEW_LINE> sticky_done : <NEW_LINE> <START_VULN> <TAB> <TAB> if ( opt ) <NEW_LINE><TAB> <TAB> <TAB> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> last_pic_structure == PICT_TOP_FIELD ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : basic shared codebook operations <NEW_LINE> <START_VULN> last mod : $ Id : sharedbook . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "os . h"
#ifndef imgStatusTracker_h__ <NEW_LINE> #define imgStatusTracker_h__ <NEW_LINE> class imgDecoderObserver ; <NEW_LINE> class imgIContainer ; <NEW_LINE> <START_VULN> class imgRequestProxy ; <NEW_LINE> <END_VULN> class imgStatusNotifyRunnable ; <NEW_LINE> class imgRequestNotifyRunnable ; <NEW_LINE> class imgStatusTrackerObserver ; <NEW_LINE> class imgStatusTrackerNotifyingObserver ; <NEW_LINE> class nsIRunnable ; <NEW_LINE> #include "mozilla / RefPtr . h" <NEW_LINE> #include "mozilla / WeakPtr . h" <NEW_LINE> #include "nsCOMPtr . h" <NEW_LINE> #include "nsTObserverArray . h" <NEW_LINE> #include "nsThreadUtils . h" <NEW_LINE> #include "nsRect . h" <NEW_LINE> namespace mozilla { <NEW_LINE> namespace image { <NEW_LINE> class Image ; <NEW_LINE> struct ImageStatusDiff <NEW_LINE> {
<TAB> <TAB> } <NEW_LINE> <TAB> if ( ! dcont && ! check_content ( cms ) ) <NEW_LINE> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> if ( pk && ! CMS_decrypt_set1_pkey ( cms , pk , cert ) ) <NEW_LINE> <TAB> <TAB> return 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> cont = CMS_dataInit ( cms , dcont ) ; <NEW_LINE> <TAB> if ( ! cont ) <NEW_LINE> <TAB> <TAB> return 0 ;
bool mListenerEnabled ; <NEW_LINE> bool mReturnInEmptyLIKillsList ; <NEW_LINE> bool mDidDeleteSelection ; <NEW_LINE> bool mDidRangedDelete ; <NEW_LINE> bool mRestoreContentEditableCount ; <NEW_LINE> nsCOMPtr < nsIDOMRange > mUtilRange ; <NEW_LINE> PRUint32 mJoinOffset ; <NEW_LINE> nsCOMPtr < nsIDOMNode > mNewBlock ; <NEW_LINE> <START_VULN> nsRangeStore mRangeItem ; <NEW_LINE> <END_VULN> StyleCache mCachedStyles [ SIZE_STYLE_TABLE ] ; <NEW_LINE> } ; <NEW_LINE> #endif
<TAB> <TAB> if ( value_expected == MagickFalse ) <NEW_LINE> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> p = value ; <NEW_LINE> <START_VULN> <TAB> <TAB> while ( ( c != '\n' ) && ( c != '\0' ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) <NEW_LINE> <TAB> <TAB> <TAB> * p + += c ;
<TAB> void ( * reset ) ( int dev ) ; <NEW_LINE> <TAB> void ( * hw_control ) ( int dev , unsigned char * event ) ; <NEW_LINE> <TAB> int ( * load_patch ) ( int dev , int format , const char __user * addr , <NEW_LINE> <START_VULN> <TAB> int offs , int count , int pmgr_flag ) ; <NEW_LINE> <END_VULN> <TAB> void ( * aftertouch ) ( int dev , int voice , int pressure ) ; <NEW_LINE> <TAB> void ( * controller ) ( int dev , int voice , int ctrl_num , int value ) ; <NEW_LINE> <TAB> void ( * panning ) ( int dev , int voice , int value ) ;
<TAB> new_timer -> it_id = ( timer_t ) new_timer_id ; <NEW_LINE> <TAB> new_timer -> it_clock = which_clock ; <NEW_LINE> <TAB> new_timer -> kclock = kc ; <NEW_LINE> <START_VULN> <TAB> new_timer -> it_overrun = - 1 ; <NEW_LINE> <END_VULN> <TAB> if ( event ) { <NEW_LINE> <TAB> <TAB> rcu_read_lock ( ) ;
static int do_tkill ( pid_t tgid , pid_t pid , int sig ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> struct siginfo info ; <NEW_LINE> <END_VULN> <TAB> info . si_signo = sig ; <NEW_LINE> <TAB> info . si_errno = 0 ;
} <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> struct snd_seq_client_port * snd_seq_create_port ( struct snd_seq_client * client , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> int port ) <NEW_LINE> {
SECURITY_STATUS SEC_ENTRY DeleteSecurityContext ( PCtxtHandle phContext ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> char * Name ; <NEW_LINE> <END_VULN> <TAB> SECURITY_STATUS status ; <NEW_LINE> <TAB> SecurityFunctionTableA * table ;
<TAB> unsigned int cscov ; <NEW_LINE> <TAB> const char * msg ; <NEW_LINE> <START_VULN> <TAB> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <NEW_LINE> <END_VULN> <TAB> if ( dh == NULL ) { <NEW_LINE> <TAB> <TAB> msg = "nf_ct_dccp : short packet " ; <NEW_LINE> <TAB> <TAB> goto out_invalid ;
<TAB> if ( c -> argc >= 4 ) { <NEW_LINE> <TAB> <TAB> robj * o = lookupKeyWriteOrReply ( c , c -> argv [ 2 ] , shared . nokeyerr ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( o == NULL ) return ; <NEW_LINE> <END_VULN> <TAB> <TAB> s = o -> ptr ; <NEW_LINE> <TAB> <TAB> grpname = c -> argv [ 3 ] -> ptr ;
<TAB> <TAB> <TAB> <TAB> " for note" ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( pread ( fd , nbuf , xsh_size , xsh_offset ) == - 1 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> file_badread ( ms ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> free ( nbuf ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return - 1 ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> mozilla : : MallocSizeOf aMallocSizeOf , void * arg ) ; <NEW_LINE> <TAB> static PLDHashOperator ClearModules ( const nsACString & key , ModuleEntry * & entry , void * cx ) ; <NEW_LINE> <TAB> nsDataHashtable < nsCStringHashKey , ModuleEntry * > mModules ; <NEW_LINE> <TAB> nsClassHashtable < nsCStringHashKey , ModuleEntry > mImports ; <NEW_LINE> <TAB> nsDataHashtable < nsCStringHashKey , ModuleEntry * > mInProgressImports ; <NEW_LINE> <START_VULN> <TAB> nsDataHashtable < nsPtrHashKey < JSScript > , JSObject * > mThisObjects ; <NEW_LINE> <END_VULN> <TAB> bool mInitialized ; <NEW_LINE> <TAB> bool mReuseLoaderGlobal ; <NEW_LINE> } ; <NEW_LINE> #endif
<TAB> int i , max_part_read = 0 ; <NEW_LINE> <TAB> for ( i = 0 ; i < f -> residue_count ; + + i ) { <NEW_LINE> <TAB> <TAB> Residue * r = f -> residue_config + i ; <NEW_LINE> <START_VULN> <TAB> <TAB> int n_read = r -> end - r -> begin ; <NEW_LINE> <END_VULN> <TAB> <TAB> int part_read = n_read / r -> part_size ; <NEW_LINE> <TAB> <TAB> if ( part_read > max_part_read ) <NEW_LINE> <TAB> <TAB> <TAB> max_part_read = part_read ;
<TAB> <TAB> <TAB> gso = & extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] ; <NEW_LINE> <TAB> <TAB> <TAB> if ( netbk_set_skb_gso ( vif , skb , gso ) ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> kfree_skb ( skb ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> netbk_tx_err ( vif , & txreq , idx ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> }
MODULE_DESCRIPTION ( "Adjunct Processor Bus driver , " \ <NEW_LINE> <TAB> <TAB> "Copyright IBM Corp . 2006 , 2012" ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "z90crypt" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> <TAB> phar_obj -> arc . archive -> alias = oldalias ; <NEW_LINE> <TAB> <TAB> <TAB> phar_obj -> arc . archive -> alias_len = oldalias_len ; <NEW_LINE> <TAB> <TAB> <TAB> phar_obj -> arc . archive -> is_temporary_alias = old_temp ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( readd ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> zend_hash_add ( & ( PHAR_GLOBALS -> phar_alias_map ) , oldalias , oldalias_len , ( void * ) & ( phar_obj -> arc . archive ) , sizeof ( phar_archive_data * ) , NULL ) ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ret_flags , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> time_rec , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & exts ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( major_status == GSS_S_COMPLETE ) { <NEW_LINE><TAB> <TAB> <TAB> * context_handle = ctx -> gssc ; <NEW_LINE><TAB> <TAB> <TAB> ctx -> gssc = GSS_C_NO_CONTEXT ; <NEW_LINE><TAB> <TAB> <TAB> iakerb_release_context ( ctx ) ; <NEW_LINE><TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> <TAB> if ( actual_mech_type != NULL ) <NEW_LINE> <TAB> <TAB> <TAB> * actual_mech_type = ( gss_OID ) gss_mech_krb5 ; <NEW_LINE> <TAB> } else {
<TAB> vif = pending_tx_info -> vif ; <NEW_LINE> <START_VULN> <TAB> make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ; <NEW_LINE> <END_VULN>
<TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> if ( must_advance_counter ) { <NEW_LINE> <END_VULN> <TAB> char counter_str [ 40 ] ; <NEW_LINE> <TAB> sprintf ( counter_str , " % ld" , hotp_counter + 1 ) ; <NEW_LINE> <TAB> if ( set_cfg_value ( pamh , "HOTP_COUNTER" , counter_str , & buf ) < 0 ) {
base : : ProcessId parentPID = strtol ( parentPIDString , & end , 10 ) ; <NEW_LINE> NS_ABORT_IF_FALSE ( ! * end , "invalid parent PID" ) ; <NEW_LINE> <START_VULN> base : : ProcessHandle parentHandle ; <NEW_LINE>mozilla : : DebugOnly < bool > ok = base : : OpenProcessHandle ( parentPID , & parentHandle ) ; <NEW_LINE>NS_ABORT_IF_FALSE ( ok , "can't open handle to parent" ) ; <NEW_LINE> <END_VULN> #if defined ( XP_WIN )
<TAB> if ( R - offset < noise [ i ] ) noise [ i ] = R - offset ; <NEW_LINE> } <NEW_LINE> for ( ; i < n ; i + + , x += 1 . f ) { <NEW_LINE> <TAB> R = ( A + x * B ) / D ; <NEW_LINE> <TAB> if ( R - offset < noise [ i ] ) noise [ i ] = R - offset ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> static float FLOOR1_fromdB_INV_LOOKUP [ 256 ] = { <NEW_LINE> <END_VULN> 0 . F , 8 . 81683e + 06F , 8 . 27882e + 06F , 7 . 77365e + 06F , <NEW_LINE> 7 . 29930e + 06F , 6 . 85389e + 06F , 6 . 43567e + 06F , 6 . 04296e + 06F , <NEW_LINE> 5 . 67422e + 06F , 5 . 32798e + 06F , 5 . 00286e + 06F , 4 . 69759e + 06F , <NEW_LINE> 4 . 41094e + 06F , 4 . 14178e + 06F , 3 . 88905e + 06F , 3 . 65174e + 06F , <NEW_LINE> 3 . 42891e + 06F , 3 . 21968e + 06F , 3 . 02321e + 06F , 2 . 83873e + 06F , <NEW_LINE> 2 . 66551e + 06F , 2 . 50286e + 06F , 2 . 35014e + 06F , 2 . 20673e + 06F , <NEW_LINE> 2 . 07208e + 06F , 1 . 94564e + 06F , 1 . 82692e + 06F , 1 . 71544e + 06F , <NEW_LINE> 1 . 61076e + 06F , 1 . 51247e + 06F , 1 . 42018e + 06F , 1 . 33352e + 06F ,
<TAB> return bio ; <NEW_LINE> out_unmap : <NEW_LINE> <START_VULN> <TAB> for ( j = 0 ; j < nr_pages ; j + + ) { <NEW_LINE><TAB> <TAB> if ( ! pages [ j ] ) <NEW_LINE><TAB> <TAB> <TAB> break ; <NEW_LINE><TAB> <TAB> put_page ( pages [ j ] ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> out : <NEW_LINE> <TAB> kfree ( pages ) ;
<TAB> <TAB> <TAB> file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> case 0x84 : <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> memcpy ( file -> name , d , len ) ; <NEW_LINE><TAB> <TAB> <TAB> file -> namelen = len ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> case 0x86 : <NEW_LINE> <TAB> <TAB> <TAB> sc_file_set_sec_attr ( file , d , len ) ;
<TAB> <TAB> <TAB> "picture will move % s one line\n" , <NEW_LINE> <TAB> <TAB> <TAB> s -> dst_tff ? "up" : "down" ) ; <NEW_LINE> <TAB> h = frame -> height ; <NEW_LINE> <START_VULN> <TAB> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> line_step = frame -> linesize [ plane ] ; <NEW_LINE> <TAB> <TAB> line_size = s -> line_size [ plane ] ; <NEW_LINE> <TAB> <TAB> data = frame -> data [ plane ] ;
<TAB> if ( ! ip6_checkentry ( & e -> ipv6 ) ) <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <START_VULN> <TAB> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <NEW_LINE> <END_VULN> <TAB> if ( err ) <NEW_LINE> <TAB> <TAB> return err ;
<TAB> <TAB> <TAB> <TAB> <TAB> u32 __user * optval , int __user * optlen ) <NEW_LINE> { <NEW_LINE> <TAB> int rc = - ENOPROTOOPT ; <NEW_LINE> <START_VULN> <TAB> if ( ccid -> ccid_ops -> ccid_hc_tx_getsockopt != NULL ) <NEW_LINE> <END_VULN> <TAB> <TAB> rc = ccid -> ccid_ops -> ccid_hc_tx_getsockopt ( sk , optname , len , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> optval , optlen ) ; <NEW_LINE> <TAB> return rc ;
int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , <NEW_LINE> <START_VULN> <TAB> <TAB> const char * name , int rep_quick ) <NEW_LINE> <END_VULN> { <NEW_LINE> int got_error ; <NEW_LINE> uint i ;
<TAB> <TAB> * elem_rtrn = NULL ; <NEW_LINE> <TAB> <TAB> * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; <NEW_LINE> <TAB> <TAB> * index_rtrn = NULL ; <NEW_LINE> <START_VULN> <TAB> <TAB> return true ; <NEW_LINE> <END_VULN> <TAB> case EXPR_FIELD_REF : <NEW_LINE> <TAB> <TAB> * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; <NEW_LINE> <TAB> <TAB> * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ;
<TAB> <TAB> if ( avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> c -> idct_put = ff_simple_idct_put_int32_10bit ; <NEW_LINE> <TAB> <TAB> <TAB> else { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> c -> idct_put = ff_simple_idct_put_int16_10bit ;
<TAB> if ( IS_SYNC ( inode ) ) <NEW_LINE> <TAB> <TAB> ext4_handle_sync ( handle ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> if ( last_block_offset > first_block_offset ) <NEW_LINE><TAB> <TAB> truncate_pagecache_range ( inode , first_block_offset , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> last_block_offset ) ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; <NEW_LINE> <TAB> ext4_mark_inode_dirty ( handle , inode ) ; <NEW_LINE> out_stop : <NEW_LINE> <TAB> ext4_journal_stop ( handle ) ; <NEW_LINE> out_dio : <NEW_LINE> <TAB> ext4_inode_resume_unlocked_dio ( inode ) ; <NEW_LINE> out_mutex : <NEW_LINE> <TAB> mutex_unlock ( & inode -> i_mutex ) ;
nsresult <NEW_LINE> CVE_2011_3000_nsHttpHeaderArray : : SetHeader ( nsHttpAtom header , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsACString & value , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRBool merge ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> nsEntry * entry = nsnull ; <NEW_LINE> <TAB> PRInt32 index ;
<TAB> <TAB> _vp_offset_and_mix ( psy_look , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> noise , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> tone , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> 1 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> logmask , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> mdct , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> logmdct ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> #if 0 <NEW_LINE> <TAB> <TAB> if ( vi -> channels == 2 ) { <NEW_LINE> <TAB> <TAB> if ( i == 0 ) <NEW_LINE> <TAB> <TAB> <TAB> _analysis_output ( "aotuvM1_L" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ; <NEW_LINE> <TAB> <TAB> else <NEW_LINE> <TAB> <TAB> <TAB> _analysis_output ( "aotuvM1_R" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ; <NEW_LINE> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> _analysis_output ( "aotuvM1" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ;
<TAB> <TAB> dst_pid = addr -> nl_pid ; <NEW_LINE> <TAB> <TAB> dst_group = ffs ( addr -> nl_groups ) ; <NEW_LINE> <TAB> <TAB> err = - EPERM ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> dst_pid = nlk -> dst_pid ;
<TAB> lnet_notify_locked ( lp , ! ni , alive , when ) ; <NEW_LINE> <START_VULN> <TAB> lnet_ni_notify_locked ( ni , lp ) ; <NEW_LINE> <END_VULN> <TAB> lnet_peer_decref_locked ( lp ) ;
<TAB> <TAB> attr -> size = usize ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> ret = copy_to_user ( uattr , attr , usize ) ; <NEW_LINE> <END_VULN> <TAB> if ( ret ) <NEW_LINE> <TAB> <TAB> return - EFAULT ;
<TAB> <TAB> skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> sizeof ( struct frag_hdr ) ) & ~ 7 ; <NEW_LINE> <TAB> <TAB> skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; <NEW_LINE> <START_VULN> <TAB> <TAB> ipv6_select_ident ( & fhdr ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; <NEW_LINE> <TAB> <TAB> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ;
{ <NEW_LINE> <TAB> struct nfs4_opendata * opendata ; <NEW_LINE> <START_VULN> <TAB> opendata = nfs4_opendata_alloc ( & ctx -> path , state -> owner , 0 , NULL ) ; <NEW_LINE> <END_VULN> <TAB> if ( opendata == NULL ) <NEW_LINE> <TAB> <TAB> return ERR_PTR ( - ENOMEM ) ; <NEW_LINE> <TAB> opendata -> state = state ;
<TAB> <TAB> usb_ms_conv_info -> itl = wmem_tree_new ( wmem_file_scope ( ) ) ; <NEW_LINE> <TAB> <TAB> usb_ms_conv_info -> itlq = wmem_tree_new ( wmem_file_scope ( ) ) ; <NEW_LINE> <TAB> <TAB> usb_conv_info -> class_data = usb_ms_conv_info ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> is_request = ( pinfo -> srcport == NO_ENDPOINT ) ; <NEW_LINE> <TAB> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , "USBMS" ) ;
<TAB> static const struct dentry_operations ops = { <NEW_LINE> <TAB> <TAB> . d_dname <TAB> = simple_dname , <NEW_LINE> <TAB> } ; <NEW_LINE> <START_VULN> <TAB> return mount_pseudo ( fs_type , "aio : " , NULL , & ops , AIO_RING_MAGIC ) ; <NEW_LINE> <END_VULN> }
<TAB> if ( ! md -> chain [ ISAKMP_NEXT_v2E ] ) { <NEW_LINE> <TAB> <TAB> libreswan_log ( "R2 state should receive an encrypted payload" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> reset_globals ( ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return STF_FATAL ; <NEW_LINE> <TAB> }
static void * arm_coherent_dma_alloc ( struct device * dev , size_t size , <NEW_LINE> <TAB> dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <NEW_LINE> <END_VULN> <TAB> void * memory ; <NEW_LINE> <TAB> if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) )
<TAB> if ( pid != & init_struct_pid ) <NEW_LINE> <TAB> <TAB> free_pid ( pid ) ; <NEW_LINE> bad_fork_cleanup_io : <NEW_LINE> <START_VULN> <TAB> put_io_context ( p -> io_context ) ; <NEW_LINE> <END_VULN> bad_fork_cleanup_namespaces : <NEW_LINE> <TAB> exit_task_namespaces ( p ) ; <NEW_LINE> bad_fork_cleanup_mm :
<TAB> timr -> it_interval = timespec64_to_ktime ( new_setting -> it_interval ) ; <NEW_LINE> <TAB> expires = timespec64_to_ktime ( new_setting -> it_value ) ; <NEW_LINE> <START_VULN> <TAB> sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <NEW_LINE> <END_VULN> <TAB> kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ; <NEW_LINE> <TAB> timr -> it_active = ! sigev_none ;
<TAB> SECItem algorithms = { siBuffer , NULL , 0 } ; <NEW_LINE> <TAB> CERTDistNames ca_list ; <NEW_LINE> <TAB> SSL_TRC ( 3 , ( " % d : SSL3 [ % d ] : handle certificate_request handshake" , <NEW_LINE> <TAB> <TAB> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> <START_VULN> <TAB> if ( ss -> ssl3 . hs . ws != wait_cert_request && <NEW_LINE><TAB> <TAB> ss -> ssl3 . hs . ws != wait_server_key ) { <NEW_LINE><TAB> desc = unexpected_message ; <NEW_LINE><TAB> errCode = SSL_ERROR_RX_UNEXPECTED_CERT_REQUEST ; <NEW_LINE><TAB> goto alert_loser ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> PORT_Assert ( ss -> ssl3 . clientCertChain == NULL ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> ssl3 . clientCertificate == NULL ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> ssl3 . clientPrivateKey == NULL ) ; <NEW_LINE> <TAB> isTLS = ( PRBool ) ( ss -> ssl3 . prSpec -> version > SSL_LIBRARY_VERSION_3_0 ) ; <NEW_LINE> <TAB> isTLS12 = ( PRBool ) ( ss -> ssl3 . prSpec -> version >= SSL_LIBRARY_VERSION_TLS_1_2 ) ;
#include "file . h" <NEW_LINE> #ifndef <TAB> lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : funcs . c , v 1 . 80 2015 / 01 / 02 21 : 29 : 39 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <TAB> <NEW_LINE> #include "magic . h"
#define __S001 PAGE_READONLY <NEW_LINE> #define __S010 PAGE_SHARED <NEW_LINE> #define __S011 PAGE_SHARED <NEW_LINE> <START_VULN> #define __S100 PAGE_EXECONLY <NEW_LINE> <END_VULN> #define __S101 PAGE_READONLY_EXEC <NEW_LINE> #define __S110 PAGE_SHARED_EXEC <NEW_LINE> #define __S111 PAGE_SHARED_EXEC
<TAB> error = 0 ; <NEW_LINE> <TAB> for ( i = 0 ; i < ord ; i + + ) { <NEW_LINE> <TAB> double pp = 0 . , delta ; <NEW_LINE> <TAB> double rooti = root [ i ] ; <NEW_LINE> <TAB> double p = a [ ord ] ; <NEW_LINE> <TAB> for ( k = ord - 1 ; k >= 0 ; k -- ) { <NEW_LINE> <START_VULN> <TAB> pp = pp * rooti + p ; <NEW_LINE><TAB> p = p * rooti + a [ k ] ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> delta = p / pp ; <NEW_LINE> <TAB> root [ i ] -= delta ; <NEW_LINE> <TAB> error += delta * delta ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( count > 40 ) return ( - 1 ) ;
<TAB> <TAB> } <NEW_LINE> <TAB> if ( priv -> cac_id_len ) { <NEW_LINE> <TAB> <TAB> serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_AUTHOR ( "Michal Ludvig" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "aes" ) ; <NEW_LINE> <END_VULN>
<TAB> } <NEW_LINE> <START_VULN> <TAB> f2fs_wait_discard_bios ( sbi ) ; <NEW_LINE> <END_VULN> <TAB> if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { <NEW_LINE> <TAB> <TAB> struct cp_control cpc = {
<TAB> <TAB> iocb -> private = NULL ; <NEW_LINE> <TAB> <TAB> EXT4_I ( inode ) -> cur_aio_dio = NULL ; <NEW_LINE> <TAB> <TAB> if ( ! is_sync_kiocb ( iocb ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> iocb -> private = ext4_init_io_end ( inode ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( ! iocb -> private ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return - ENOMEM ;
<TAB> return __ipv6_addr_diff ( a1 , a2 , sizeof ( struct in6_addr ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static __inline__ void ipv6_select_ident ( struct frag_hdr * fhdr ) <NEW_LINE> { <NEW_LINE><TAB> static u32 ipv6_fragmentation_id = 1 ; <NEW_LINE><TAB> static DEFINE_SPINLOCK ( ip6_id_lock ) ; <NEW_LINE><NEW_LINE><TAB> spin_lock_bh ( & ip6_id_lock ) ; <NEW_LINE><TAB> fhdr -> identification = htonl ( ipv6_fragmentation_id ) ; <NEW_LINE><TAB> if ( + + ipv6_fragmentation_id == 0 ) <NEW_LINE><TAB> <TAB> ipv6_fragmentation_id = 1 ; <NEW_LINE><TAB> spin_unlock_bh ( & ip6_id_lock ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> * <TAB> Prototypes exported by ipv6
* <NEW_LINE> #define NSS_BUILTINS_LIBRARY_VERSION_MAJOR 1 <NEW_LINE> <START_VULN> #define NSS_BUILTINS_LIBRARY_VERSION_MINOR 79 <NEW_LINE>#define NSS_BUILTINS_LIBRARY_VERSION "1 . 79" <NEW_LINE> <END_VULN> #define NSS_BUILTINS_HARDWARE_VERSION_MAJOR 1 <NEW_LINE> #define NSS_BUILTINS_HARDWARE_VERSION_MINOR 0 <NEW_LINE> #define NSS_BUILTINS_FIRMWARE_VERSION_MAJOR 1
<TAB> <TAB> log_unauth ( funcname , prime_arg , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> & client_name , & service_name , rqstp ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> gss_release_buffer ( & minor_stat , & client_name ) ; <NEW_LINE> <TAB> gss_release_buffer ( & minor_stat , & service_name ) ; <NEW_LINE> <START_VULN> exit_func : <NEW_LINE> <END_VULN> <TAB> free_server_handle ( handle ) ; <NEW_LINE> <TAB> return & ret ;
<TAB> } <NEW_LINE> <START_VULN> <TAB> map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ; <NEW_LINE> <END_VULN> <TAB> if ( NULL == map ) <NEW_LINE> <TAB> <TAB> return - ENOMEM ;
<TAB> <TAB> struct nfsd4_layoutget * lgp ) <NEW_LINE> { <NEW_LINE> <TAB> struct xdr_stream * xdr = & resp -> xdr ; <NEW_LINE> <START_VULN> <TAB> const struct nfsd4_layout_ops * ops = <NEW_LINE><TAB> <TAB> nfsd4_layout_ops [ lgp -> lg_layout_type ] ; <NEW_LINE> <END_VULN> <TAB> __be32 * p ; <NEW_LINE> <TAB> dprintk ( " % s : err % d\n" , __func__ , nfserr ) ;
<TAB> struct domain_device * dev = NULL ; <NEW_LINE> <TAB> res = sas_find_bcast_dev ( port_dev , & dev ) ; <NEW_LINE> <START_VULN> <TAB> while ( res == 0 && dev ) { <NEW_LINE> <END_VULN> <TAB> <TAB> struct expander_device * ex = & dev -> ex_dev ; <NEW_LINE> <TAB> <TAB> int i = 0 , phy_id ;
<TAB> <TAB> || s -> width != s1 -> width <NEW_LINE> <TAB> <TAB> || s -> height != s1 -> height ) { <NEW_LINE> <TAB> <TAB> if ( s != s1 ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> copy_fields ( s , s1 , golden_frame , current_frame ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> }
} <NEW_LINE> long vorbis_coslook_i ( long a ) { <NEW_LINE> int i = a >> COS_LOOKUP_I_SHIFT ; <NEW_LINE> int d = a & COS_LOOKUP_I_MASK ; <NEW_LINE> return COS_LOOKUP_I [ i ] - ( ( d * ( COS_LOOKUP_I [ i ] - COS_LOOKUP_I [ i + 1 ] ) ) >> <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> COS_LOOKUP_I_SHIFT ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif
int rc ; <NEW_LINE> int param_num = SvIV ( param ) ; <NEW_LINE> int idx = param_num - 1 ; <NEW_LINE> <START_VULN> char err_msg [ 64 ] ; <NEW_LINE> <END_VULN> D_imp_xxh ( sth ) ; <NEW_LINE> #if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
<TAB> if ( IS_ERR ( map ) ) <NEW_LINE> <TAB> <TAB> return map ; <NEW_LINE> <START_VULN> <TAB> bpf_map_inc ( map , true ) ; <NEW_LINE> <END_VULN> <TAB> fdput ( f ) ; <NEW_LINE> <TAB> return map ;
<TAB> horizontal_factor , ( image -> rows + vertical_factor - 1 ) / vertical_factor , <NEW_LINE> <TAB> MagickTrue , exception ) ; <NEW_LINE> <TAB> if ( chroma_image == ( Image * ) NULL ) <NEW_LINE> <START_VULN> <TAB> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> sock -> _wreq . bufs = sock -> _wreq . smallbufs ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> sock -> _wreq . bufs = h2o_mem_alloc ( sizeof ( h2o_iovec_t ) * bufcnt ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> sock -> _wreq . alloced_ptr = sock -> _wreq . bufs = sock -> _wreq . bufs ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> memcpy ( sock -> _wreq . bufs , bufs , sizeof ( h2o_iovec_t ) * bufcnt ) ; <NEW_LINE> <TAB> sock -> _wreq . cnt = bufcnt ;
js_AtomizeString ( JSContext * cx , JSString * str , uintN flags ) ; <NEW_LINE> extern JSAtom * <NEW_LINE> <START_VULN> js_Atomize ( JSContext * cx , const char * bytes , size_t length , uintN flags , bool useCESU8 = false ) ; <NEW_LINE> <END_VULN> extern JSAtom * <NEW_LINE> js_AtomizeChars ( JSContext * cx , const jschar * chars , size_t length , uintN flags ) ;
<TAB> } <NEW_LINE> <TAB> * pagep = page ; <NEW_LINE> <START_VULN> <TAB> ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata , <NEW_LINE><TAB> <TAB> <TAB> <TAB> ext4_get_block ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! ret && ext4_should_journal_data ( inode ) ) { <NEW_LINE> <TAB> <TAB> ret = walk_page_buffers ( handle , page_buffers ( page ) ,
<TAB> gint64 * data_offset ) ; <NEW_LINE> static gboolean cosine_seek_read ( wtap * wth , gint64 seek_off , <NEW_LINE> <TAB> struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar ** err_info ) ; <NEW_LINE> <START_VULN> static int parse_cosine_rec_hdr ( struct wtap_pkthdr * phdr , const char * line , <NEW_LINE><TAB> int * err , gchar ** err_info ) ; <NEW_LINE>static gboolean parse_cosine_hex_dump ( FILE_T fh , struct wtap_pkthdr * phdr , <NEW_LINE><TAB> int pkt_len , Buffer * buf , int * err , gchar ** err_info ) ; <NEW_LINE> <END_VULN> static int parse_single_hex_dump_line ( char * rec , guint8 * buf , <NEW_LINE> <TAB> guint byte_offset ) ;
<TAB> <TAB> <TAB> walkbuf = result + * result_len ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( eval || is_callable_replace ) {
<TAB> nsresult Init ( nsIStreamListener * aListener ) ; <NEW_LINE> <TAB> static nsresult <NEW_LINE> <TAB> Create ( nsISupports * aOuter , REFNSIID aIID , void ** aResult ) ; <NEW_LINE> protected : <NEW_LINE> <TAB> void FormatSizeString ( PRInt64 inSize , nsString & outSizeString ) ; <NEW_LINE> <START_VULN> <TAB> nsresult FormatInputStream ( nsIRequest * aRequest , nsISupports * aContext , const nsAString & aBuffer ) ; <NEW_LINE> <END_VULN> protected : <NEW_LINE> <TAB> nsCOMPtr < nsIDirIndexParser > mParser ; <NEW_LINE> <TAB> nsCOMPtr < nsIStreamListener > mListener ; <NEW_LINE> <TAB> nsCOMPtr < nsIDateTimeFormat > mDateTime ; <NEW_LINE> <TAB> nsCOMPtr < nsIStringBundle > mBundle ;
static int sock_close ( struct inode * inode , struct file * filp ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> sock_release ( SOCKET_I ( inode ) ) ; <NEW_LINE> <END_VULN> <TAB> return 0 ; <NEW_LINE> }
<TAB> assert ( boxinfo ) ; <NEW_LINE> <TAB> fprintf ( out , "JP2 box : " ) ; <NEW_LINE> <START_VULN> <TAB> fprintf ( out , "type = % c % s % c ( 0x % 08"PRIxFAST32" ) ; length = % "PRIuFAST32"\n" , '"' , boxinfo -> name , <NEW_LINE><TAB> '"' , box -> type , box -> len ) ; <NEW_LINE> <END_VULN> <TAB> if ( box -> ops -> dumpdata ) { <NEW_LINE> <TAB> <TAB> ( * box -> ops -> dumpdata ) ( box , out ) ; <NEW_LINE> <TAB> }
<TAB> static u32 challenge_timestamp ; <NEW_LINE> <TAB> static unsigned int challenge_count ; <NEW_LINE> <TAB> struct tcp_sock * tp = tcp_sk ( sk ) ; <NEW_LINE> <START_VULN> <TAB> u32 now ; <NEW_LINE> <END_VULN> <TAB> if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb ,
SVGPathData & InternalList ( ) const ; <NEW_LINE> SVGAnimatedPathSegList & InternalAList ( ) const ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE>void EnsureItemAt ( uint32_t aIndex ) ; <NEW_LINE> <END_VULN> void MaybeInsertNullInAnimValListAt ( uint32_t aIndex , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t aInternalIndex , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t aArgCountForItem ) ; <NEW_LINE> void MaybeRemoveItemFromAnimValListAt ( uint32_t aIndex , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> int32_t aArgCountForItem ) ;
namespace xpc { <NEW_LINE> class WrapperFactory { <NEW_LINE> public : <NEW_LINE> <TAB> enum { WAIVE_XRAY_WRAPPER_FLAG = js : : Wrapper : : LAST_USED_FLAG << 1 , <NEW_LINE> <TAB> <TAB> <TAB> IS_XRAY_WRAPPER_FLAG = WAIVE_XRAY_WRAPPER_FLAG << 1 , <NEW_LINE> <TAB> <TAB> <TAB> SCRIPT_ACCESS_ONLY_FLAG = IS_XRAY_WRAPPER_FLAG << 1 , <NEW_LINE> <TAB> <TAB> <TAB> PARTIALLY_TRANSPARENT = SCRIPT_ACCESS_ONLY_FLAG << 1 , <NEW_LINE> <START_VULN> <TAB> <TAB> SOW_FLAG = PARTIALLY_TRANSPARENT << 1 } ; <NEW_LINE> <END_VULN> <TAB> static bool HasWrapperFlag ( JSObject * wrapper , unsigned flag ) { <NEW_LINE> <TAB> <TAB> unsigned flags = 0 ; <NEW_LINE> <TAB> <TAB> js : : UnwrapObject ( wrapper , true , & flags ) ; <NEW_LINE> <TAB> <TAB> return ! ! ( flags & flag ) ; <NEW_LINE> <TAB> }
typedef struct _dumpOptions <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> const char * dbname ; <NEW_LINE> <END_VULN> <TAB> const char * pghost ; <NEW_LINE> <TAB> const char * pgport ; <NEW_LINE> <TAB> const char * username ;
<TAB> <TAB> printf ( " ] ( % llu ) \n" , ddword_tmp ) ; <NEW_LINE> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> case PT_LONG : <NEW_LINE> <START_VULN> <TAB> <TAB> printf ( " Value : % li\n" , * ( ( long * ) mapidata -> data ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> case PT_I2 : <NEW_LINE> <TAB> <TAB> printf ( " Value : % hi\n" , * ( ( short int * ) mapidata -> data ) ) ;
* <NEW_LINE> #include "nsIEnumerator . h" <NEW_LINE> #include "nsCOMPtr . h" <NEW_LINE> <START_VULN> #include "nsVoidArray . h" <NEW_LINE> <END_VULN> class nsIDocShellTreeItem ; <NEW_LINE> #define NS_DOCSHELL_FORWARDS_ENUMERATOR_CID \ <NEW_LINE> { 0x13cbc281 , 0x35ae , 0x11d5 , { 0xbe , 0x5b , 0xbd , 0xe0 , 0xed , 0xec , 0xe4 , 0x3c } }
<TAB> return FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> WCHAR installDir [ MAX_PATH ] = { L'\0' } ; <NEW_LINE> <END_VULN> if ( ! GetInstallationDir ( argc , argv , installDir ) ) { <NEW_LINE> <TAB> LOG_WARN ( ( "Could not get the installation directory" ) ) ; <NEW_LINE> <TAB> if ( ! WriteStatusFailure ( argv [ 1 ] ,
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> atomic_dec ( & key -> user -> nkeys ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> atomic_dec ( & key -> user -> nikeys ) ; <NEW_LINE> <TAB> <TAB> key_user_put ( key -> user ) ;
<TAB> if ( ! timr -> it_interval ) <NEW_LINE> <TAB> <TAB> return ; <NEW_LINE> <START_VULN> <TAB> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> timer -> base -> get_time ( ) , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> timr -> it_interval ) ; <NEW_LINE> <END_VULN> <TAB> hrtimer_restart ( timer ) ; <NEW_LINE> }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : libvorbis codec headers <NEW_LINE> <START_VULN> last mod : $ Id : codec . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _vorbis_codec_h_ <NEW_LINE> #define _vorbis_codec_h_ <NEW_LINE> #ifdef __cplusplus <NEW_LINE> extern "C"
<TAB> <TAB> switch ( elem -> id ) { <NEW_LINE> <TAB> <TAB> case MFIE_TYPE_SSID : <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> bss -> ssid_len = elem -> len ; <NEW_LINE><TAB> <TAB> <TAB> memcpy ( bss -> ssid , elem -> data , elem -> len ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> lbs_deb_scan ( "got SSID IE : ' % s' , len % u\n" , <NEW_LINE> <TAB> <TAB> <TAB> escape_essid ( bss -> ssid , bss -> ssid_len ) , <NEW_LINE> <TAB> <TAB> <TAB> bss -> ssid_len ) ;
<TAB> attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job - sheets" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> 2 , NULL , NULL ) ; <NEW_LINE> <START_VULN> <TAB> attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ) ; <NEW_LINE><TAB> attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> job -> job_sheets = attr ;
<TAB> if ( verbose ) <NEW_LINE> <TAB> <TAB> appendPQExpBuffer ( & sql , " ( VERBOSE ) " ) ; <NEW_LINE> <START_VULN> <TAB> appendPQExpBuffer ( & sql , " SYSTEM % s ; " , PQdb ( conn ) ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! executeMaintenanceCommand ( conn , sql . data , echo ) ) <NEW_LINE> <TAB> {
<TAB> if ( ! ie1 && ! ie2 ) <NEW_LINE> <TAB> <TAB> return 0 ; <NEW_LINE> <START_VULN> <TAB> if ( ! ie1 ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> r = memcmp ( ie1 + 2 , ie2 + 2 , min ( ie1 [ 1 ] , ie2 [ 1 ] ) ) ;
<TAB> <TAB> <TAB> if ( PASS == ( ret = PACKET_READ ( stats_header , conn ) ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> * message = estrndup ( stats_header -> message , stats_header -> message_len ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> * message_len = stats_header -> message_len ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> DBG_INF ( * message ) ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> return user_core_fd ; <NEW_LINE> } <NEW_LINE> <START_VULN> static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> FILE * fp = fopen ( dest_filename , "w" ) ; <NEW_LINE> <TAB> if ( ! fp )
void WalkRules ( nsIStyleRuleProcessor : : EnumFunc aFunc , void * aData ) ; <NEW_LINE> nsINodeList * GetAnonymousNodes ( ) ; <NEW_LINE> static nsresult DoInitJSClass ( JSContext * cx , JSObject * global , JSObject * obj , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsAFlatCString & aClassName , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsXBLPrototypeBinding * aProtoBinding , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject ** aClassObject ) ; <NEW_LINE> <END_VULN> bool AllowScripts ( ) ; <NEW_LINE> void RemoveInsertionParent ( nsIContent * aParent ) ; <NEW_LINE> bool HasInsertionParent ( nsIContent * aParent ) ; <NEW_LINE> protected :
<TAB> <TAB> } <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> if ( state -> indent ) ruby_xfree ( state -> indent ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> state -> indent = strdup ( RSTRING_PTR ( indent ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> state -> indent_len = len ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return Qnil ;
<TAB> <TAB> return 1 ; <NEW_LINE> #endif <NEW_LINE> <TAB> tm_recheckpoint ( & current -> thread , msr ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> if ( __get_user ( msr_hi , & tm_sr -> mc_gregs [ PT_MSR ] ) ) <NEW_LINE><TAB> <TAB> return 1 ; <NEW_LINE><TAB> <NEW_LINE><TAB> regs -> msr = ( regs -> msr & ~ MSR_TS_MASK ) | ( ( msr_hi << 32 ) & MSR_TS_MASK ) ; <NEW_LINE> <END_VULN> <TAB> if ( msr & MSR_FP ) {
void <TAB> Huff_Init ( huffman_t * huff ) ; <NEW_LINE> void <TAB> Huff_addRef ( huff_t * huff , byte ch ) ; <NEW_LINE> int <TAB> <TAB> Huff_Receive ( node_t * node , int * ch , byte * fin ) ; <NEW_LINE> <START_VULN> void <TAB> Huff_transmit ( huff_t * huff , int ch , byte * fout ) ; <NEW_LINE>void <TAB> Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) ; <NEW_LINE>void <TAB> Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) ; <NEW_LINE> <END_VULN> void <TAB> Huff_putBit ( int bit , byte * fout , int * offset ) ; <NEW_LINE> int <TAB> <TAB> Huff_getBit ( byte * fout , int * offset ) ;
<TAB> JSIdArray * ida ; <NEW_LINE> <TAB> jschar * chars , * ochars , * vsharp ; <NEW_LINE> <TAB> const jschar * idstrchars , * vchars ; <NEW_LINE> <START_VULN> <TAB> size_t nchars , idstrlength , gsoplength , vlength , vsharplength ; <NEW_LINE> <END_VULN> <TAB> char * comma ; <NEW_LINE> <TAB> jsint i , j , length , valcnt ; <NEW_LINE> <TAB> jsid id ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : residue backend 0 , 1 and 2 implementation <NEW_LINE> <START_VULN> last mod : $ Id : res0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN>
<TAB> <TAB> socklen = NGX_SOCKADDRLEN ; <NEW_LINE> #if ( NGX_HAVE_ACCEPT4 ) <NEW_LINE> <START_VULN> <TAB> <TAB> s = accept4 ( lc -> fd , ( struct sockaddr * ) sa , & socklen , SOCK_NONBLOCK ) ; <NEW_LINE> <END_VULN> #else <NEW_LINE> <TAB> <TAB> s = accept ( lc -> fd , ( struct sockaddr * ) sa , & socklen ) ; <NEW_LINE> #endif
<TAB> struct filter_op * array = NULL ; <NEW_LINE> <TAB> struct unfold_elm * ue ; <NEW_LINE> <START_VULN> BUG_IF ( tree_root == NULL ) ; <NEW_LINE> <END_VULN> <TAB> fprintf ( stdout , " Unfolding the meta - tree " ) ; <NEW_LINE> <TAB> fflush ( stdout ) ;
<TAB> list_add_tail ( & new_port -> list , & p -> list ) ; <NEW_LINE> <TAB> client -> num_ports + + ; <NEW_LINE> <TAB> new_port -> addr . port = num ; <TAB> <NEW_LINE> <TAB> write_unlock_irqrestore ( & client -> ports_lock , flags ) ; <NEW_LINE> <TAB> mutex_unlock ( & client -> ports_mutex ) ; <NEW_LINE> <START_VULN> <TAB> sprintf ( new_port -> name , "port - % d" , num ) ; <NEW_LINE> <END_VULN> <TAB> return new_port ; <NEW_LINE> }
<TAB> <TAB> ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { <NEW_LINE> <TAB> <TAB> <TAB> ext4_msg ( sb , KERN_ERR , "Journal does not support " <NEW_LINE> <TAB> <TAB> <TAB> "requested data journaling mode" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> goto failed_mount4 ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> default : <NEW_LINE> <TAB> <TAB> break ;
<TAB> if ( ret != GSS_S_COMPLETE ) <NEW_LINE> <TAB> <TAB> goto cleanup ; <NEW_LINE> <START_VULN> <TAB> sc = create_spnego_ctx ( ) ; <NEW_LINE> <END_VULN> <TAB> if ( sc == NULL ) { <NEW_LINE> <TAB> <TAB> ret = GSS_S_FAILURE ; <NEW_LINE> <TAB> <TAB> goto cleanup ;
if ( posts == 0 ) { <NEW_LINE> <TAB> nonzero += accumulate_fit ( logmask , logmdct , 0 , n , fits , n , info ) ; <NEW_LINE> } else { <NEW_LINE> <TAB> for ( i = 0 ; i < posts - 1 ; i + + ) <NEW_LINE> <TAB> nonzero += accumulate_fit ( logmask , logmdct , look -> sorted_index [ i ] , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> look -> sorted_index [ i + 1 ] , fits + i , <NEW_LINE><TAB> <TAB> <TAB> n , info ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( nonzero ) { <NEW_LINE> <TAB> int y0 = - 200 ; <NEW_LINE> <TAB> int y1 = - 200 ; <NEW_LINE> <TAB> fit_line ( fits , posts - 1 , & y0 , & y1 ) ;
MODULE_DESCRIPTION ( "Serpent Cipher Algorithm , AVX optimized" ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "serpent" ) ; <NEW_LINE> <END_VULN>
<TAB> const struct xt_entry_target * t ; <NEW_LINE> <TAB> unsigned int verdict ; <NEW_LINE> <START_VULN> <TAB> if ( ! unconditional ( & e -> ipv6 ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return false ; <NEW_LINE> <TAB> t = ip6t_get_target_c ( e ) ; <NEW_LINE> <TAB> if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 )
<TAB> if ( type == SSL3_RT_APPLICATION_DATA && <NEW_LINE> <TAB> <TAB> u_len >= 4 * ( max_send_fragment = s -> max_send_fragment ) && <NEW_LINE> <TAB> <TAB> s -> compress == NULL && s -> msg_callback == NULL && <NEW_LINE> <START_VULN> <TAB> <TAB> ! SSL_USE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) && <NEW_LINE> <END_VULN> <TAB> <TAB> EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & <NEW_LINE> <TAB> <TAB> EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) { <NEW_LINE> <TAB> <TAB> unsigned char aad [ 13 ] ;
<TAB> <TAB> asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; <NEW_LINE> out_unlock : <NEW_LINE> <START_VULN> <TAB> bh_unlock_sock ( asoc -> base . sk ) ; <NEW_LINE> <END_VULN> <TAB> sctp_association_put ( asoc ) ; <NEW_LINE> }
static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> FILE * fp = fopen ( dest_filename , "w" ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! fp ) <NEW_LINE> <TAB> <TAB> return false ;
compact_pixels = ( unsigned char * ) NULL ; <NEW_LINE> if ( next_image -> compression == RLECompression ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> compact_pixels = AcquireCompactPixels ( image , exception ) ; <NEW_LINE> <END_VULN> <TAB> if ( compact_pixels == ( unsigned char * ) NULL ) <NEW_LINE> <TAB> <TAB> return ( 0 ) ; <NEW_LINE> <TAB> }
<TAB> __be32 spi ; <NEW_LINE> <TAB> spi = xfrm6_tunnel_spi_lookup ( ( xfrm_address_t * ) & iph -> saddr ) ; <NEW_LINE> <START_VULN> <TAB> return xfrm6_rcv_spi ( skb , spi ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int xfrm6_tunnel_err ( struct sk_buff * skb , struct inet6_skb_parm * opt ,
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA - 384 and SHA - 512 Secure Hash Algorithm , sparc64 sha512 opcode accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha384" ) ; <NEW_LINE>MODULE_ALIAS ( "sha512" ) ; <NEW_LINE> <END_VULN> #include "crop_devid . c"
<TAB> <TAB> for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno + + ) { <NEW_LINE> <TAB> <TAB> <TAB> Jpeg2000Band * band = reslevel -> band + bandno ; <NEW_LINE> <TAB> <TAB> <TAB> for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno + + ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> Jpeg2000Prec * prec = band -> prec + precno ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> av_freep ( & prec -> zerobits ) ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> av_freep ( & prec -> cblkincl ) ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> av_freep ( & prec -> cblk ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> av_freep ( & band -> prec ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "AES Secure Hash Algorithm , sparc64 aes opcode accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "aes" ) ; <NEW_LINE> <END_VULN> #include "crop_devid . c"
<TAB> int i , n ; <NEW_LINE> <TAB> for ( i = 0 ; i < num_mixer_volumes ; i + + ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( strcmp ( name , mixer_vols [ i ] . name ) == 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( present ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> mixer_vols [ i ] . num = i ; <NEW_LINE> <TAB> <TAB> <TAB> return mixer_vols [ i ] . levels ;
<TAB> <TAB> * dma_handle = phys_to_dma ( dev , page_to_phys ( page ) ) ; <NEW_LINE> <TAB> <TAB> addr = page_address ( page ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( flags & __GFP_ZERO ) <NEW_LINE><TAB> <TAB> <TAB> memset ( addr , 0 , size ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return addr ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> return swiotlb_alloc_coherent ( dev , size , dma_handle , flags ) ;
<TAB> <TAB> return ERR_PTR ( - ENOBUFS ) ; <NEW_LINE> <TAB> memset ( opt2 , 0 , tot_len ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> opt2 -> tot_len = tot_len ; <NEW_LINE> <TAB> p = ( char * ) ( opt2 + 1 ) ;
int input_incr ; <NEW_LINE> int sp = 0 ; <NEW_LINE> int bytes_matched ; <NEW_LINE> <START_VULN> int max_bytes_matched = input_size ; <NEW_LINE> <END_VULN> input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ;
<TAB> <TAB> <TAB> conn -> current_result = NULL ; <NEW_LINE> <TAB> <TAB> } while ( 0 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> conn -> m -> local_tx_end ( conn , this_func , result == NULL ? FAIL : PASS TSRMLS_CC ) ; <TAB> <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> DBG_RETURN ( result ) ;
<TAB> <TAB> length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; <NEW_LINE> <TAB> <TAB> if ( length > ( size_t ) GetBlobSize ( image ) ) <NEW_LINE> <TAB> <TAB> ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( info . scale != ( Quantum * ) NULL ) <NEW_LINE> <END_VULN> <TAB> <TAB> info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; <NEW_LINE> <TAB> <TAB> info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , <NEW_LINE> <TAB> <TAB> sizeof ( * info . scale ) ) ;
<TAB> <TAB> p_chk -> common . i_chunk_fourcc == AVIFOURCC_ON2 || <NEW_LINE> <TAB> <TAB> p_chk -> common . i_chunk_fourcc == AVIFOURCC_LIST ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> sprintf ( str + i_level * 5 , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> " % c % 4 . 4s - % 4 . 4s size : % "PRIu64" pos : % "PRIu64 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> i_level ? ' + ' : ' * ' , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ( char * ) & p_chk -> common . i_chunk_fourcc ,
<TAB> <TAB> <TAB> <TAB> <TAB> height , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> width ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> ( void ) sscanf ( value , " % d + X % d" , & height , & width ) ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> image -> columns = ( size_t ) width ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> image -> rows = ( size_t ) height ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> ( void ) FormatLocaleString ( tag , MaxTextExtent , "hdr : % s" , keyword ) ;
<TAB> nsXBLProtoImplMethod ( EmptyString ( ) . get ( ) ) <NEW_LINE> { } <NEW_LINE> nsresult Execute ( nsIContent * aBoundElement ) ; <NEW_LINE> <START_VULN> virtual nsresult InstallMember ( nsIScriptContext * aContext , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIContent * aBoundElement , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aScriptObject , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aTargetClassObject , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsCString & aClassStr ) { <NEW_LINE> <END_VULN> <TAB> return NS_OK ; <NEW_LINE> } <NEW_LINE> using nsXBLProtoImplMethod : : Write ; <NEW_LINE> nsresult Write ( nsIScriptContext * aContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> nsIObjectOutputStream * aStream , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> XBLBindingSerializeDetails aType ) ; <NEW_LINE> } ;
<TAB> . release <TAB> = ext3_release_file , <NEW_LINE> <TAB> . fsync <TAB> <TAB> = ext3_sync_file , <NEW_LINE> <TAB> . splice_read <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> } ; <NEW_LINE> const struct inode_operations ext3_file_inode_operations = {
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> data , hlen ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> return true ; <NEW_LINE> <END_VULN> } <NEW_LINE> EXPORT_SYMBOL ( __skb_flow_dissect ) ;
static PHP_MINIT_FUNCTION ( pcre ) <NEW_LINE> { <NEW_LINE> <TAB> REGISTER_INI_ENTRIES ( ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> REGISTER_LONG_CONSTANT ( "PREG_PATTERN_ORDER" , PREG_PATTERN_ORDER , CONST_CS | CONST_PERSISTENT ) ; <NEW_LINE> <TAB> REGISTER_LONG_CONSTANT ( "PREG_SET_ORDER" , PREG_SET_ORDER , CONST_CS | CONST_PERSISTENT ) ; <NEW_LINE> <TAB> REGISTER_LONG_CONSTANT ( "PREG_OFFSET_CAPTURE" , PREG_OFFSET_CAPTURE , CONST_CS | CONST_PERSISTENT ) ;
<TAB> if ( compile_options ) { <NEW_LINE> <TAB> <TAB> * compile_options = pce ? pce -> compile_options : 0 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> return pce ? pce -> re : NULL ; <NEW_LINE> }
<TAB> l_current_pi = l_pi ; <NEW_LINE> <START_VULN> <TAB> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <NEW_LINE> <END_VULN> <TAB> if <NEW_LINE> <TAB> <TAB> ( ! l_current_pi -> include ) <NEW_LINE> <TAB> {
<TAB> xid = GetXid ( ) ; <NEW_LINE> <START_VULN> <TAB> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <NEW_LINE> <END_VULN> <TAB> if ( ses ) { <NEW_LINE> <TAB> <TAB> cFYI ( 1 , "Existing smb sess found ( status = % d ) " , ses -> status ) ;
<TAB> <TAB> gss_qop_t qop_req , gss_iov_buffer_desc * iov , <NEW_LINE> <TAB> <TAB> int iov_count ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return gss_get_mic_iov ( minor_status , context_handle , qop_req , iov , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> iov_count ) ; <NEW_LINE> }
<TAB> <TAB> guint8 * codepage_stag , guint8 * codepage_attr ) <NEW_LINE> { <NEW_LINE> <TAB> guint32 tvb_len = tvb_reported_length ( tvb ) ; <NEW_LINE> <START_VULN> <TAB> guint32 off = offset ; <NEW_LINE> <END_VULN> <TAB> guint32 len ; <NEW_LINE> <TAB> guint str_len ; <NEW_LINE> <TAB> guint32 ent ;
<TAB> if ( status != CL_SUCCESS ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> hb_log ( "OpenCL : hb_generat_bin_from_kernel_source : clGetProgramInfo for CL_PROGRAM_DEVICES failed" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <END_VULN> <TAB> }
success : <NEW_LINE> <TAB> spin_unlock ( & ulp -> lock ) ; <NEW_LINE> <TAB> rcu_read_lock ( ) ; <NEW_LINE> <START_VULN> <TAB> sem_unlock ( sma ) ; <NEW_LINE> <END_VULN> out : <NEW_LINE> <TAB> return un ; <NEW_LINE> }
<TAB> <TAB> const struct iovec * iov = i -> iov ; <NEW_LINE> <TAB> <TAB> size_t base = i -> iov_offset ; <NEW_LINE> <START_VULN> <TAB> <TAB> while ( bytes ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> int copy = min ( bytes , iov -> iov_len - base ) ; <NEW_LINE> <TAB> <TAB> <TAB> bytes -= copy ;
<TAB> while ( 0x80 != plaintext [ cipher_len - 2 ] && ( cipher_len - 2 > 0 ) ) <NEW_LINE> <TAB> <TAB> cipher_len -- ; <NEW_LINE> <START_VULN> <TAB> if ( 2 == cipher_len ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> memcpy ( out , plaintext , cipher_len - 2 ) ;
<TAB> if ( PageMappedToDisk ( page ) ) <NEW_LINE> <TAB> <TAB> SetPageMappedToDisk ( newpage ) ; <NEW_LINE> <START_VULN> <TAB> if ( PageDirty ( page ) ) { <NEW_LINE><TAB> <TAB> clear_page_dirty_for_io ( page ) ; <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> if ( PageSwapBacked ( page ) ) <NEW_LINE><TAB> <TAB> <TAB> SetPageDirty ( newpage ) ; <NEW_LINE><TAB> <TAB> else <NEW_LINE><TAB> <TAB> <TAB> __set_page_dirty_nobuffers ( newpage ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> if ( page_is_young ( page ) ) <NEW_LINE> <TAB> <TAB> set_page_young ( newpage ) ;
<TAB> pseudo_header -> cosine . rm = rm ; <NEW_LINE> <TAB> pseudo_header -> cosine . err = error ; <NEW_LINE> <START_VULN> <TAB> return pkt_len ; <NEW_LINE> } <NEW_LINE><NEW_LINE><NEW_LINE>static gboolean <NEW_LINE>parse_cosine_hex_dump ( FILE_T fh , struct wtap_pkthdr * phdr , int pkt_len , <NEW_LINE><TAB> Buffer * buf , int * err , gchar ** err_info ) <NEW_LINE> { <NEW_LINE><TAB> guint8 * pd ; <NEW_LINE><TAB> gchar <TAB> line [ COSINE_LINE_LENGTH ] ; <NEW_LINE><TAB> int <TAB> i , hex_lines , n , caplen = 0 ; <NEW_LINE><NEW_LINE><TAB> ws_buffer_assure_space ( buf , COSINE_MAX_PACKET_LEN ) ; <NEW_LINE> <END_VULN> <TAB> pd = ws_buffer_start_ptr ( buf ) ;
<TAB> <TAB> <TAB> MYSQL_ROW trow ; <NEW_LINE> <TAB> while ( ( trow = mysql_fetch_row ( tresult ) ) ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> sprintf ( query , "SELECT COUNT ( * ) FROM ` % s`" , trow [ 0 ] ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! ( mysql_query ( mysql , query ) ) ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> MYSQL_RES * rresult ;
protected : <NEW_LINE> nsIntSize mLastSize ; <NEW_LINE> nsIntPoint mLastPoint ; <NEW_LINE> HWND mWnd ; <NEW_LINE> WNDPROC mPrevWndProc ; <NEW_LINE> HBRUSH mBrush ; <NEW_LINE> PRPackedBool mIsTopWidgetWindow ; <NEW_LINE> PRPackedBool mHas3DBorder ; <NEW_LINE> <START_VULN> PRPackedBool mIsDestroying ; <NEW_LINE> <END_VULN> PRPackedBool mIsVisible ; <NEW_LINE> PRPackedBool mIsInMouseCapture ; <NEW_LINE> PRPackedBool mInWheelProcessing ; <NEW_LINE> PRPackedBool mUnicodeWidget ; <NEW_LINE> PRPackedBool mIsPluginWindow ; <NEW_LINE> PRPackedBool mPainting ; <NEW_LINE> char mLeadByte ; <NEW_LINE> PRUint32 mBlurSuppressLevel ;
void mdct_init ( mdct_lookup * lookup , int n ) { <NEW_LINE> int * bitrev = _ogg_malloc ( sizeof ( * bitrev ) * ( n / 4 ) ) ; <NEW_LINE> DATA_TYPE * T = _ogg_malloc ( sizeof ( * T ) * ( n + n / 4 ) ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> int i ; <NEW_LINE> int n2 = n >> 1 ; <NEW_LINE> int log2n = lookup -> log2n = rint ( log ( ( float ) n ) / log ( 2 . f ) ) ; <NEW_LINE> lookup -> n = n ; <NEW_LINE> lookup -> trig = T ; <NEW_LINE> lookup -> bitrev = bitrev ;
void * ipc_rcu_alloc ( int size ) ; <NEW_LINE> <START_VULN> void ipc_rcu_getref ( void * ptr ) ; <NEW_LINE> <END_VULN> void ipc_rcu_putref ( void * ptr ) ; <NEW_LINE> struct kern_ipc_perm * ipc_lock ( struct ipc_ids * , int ) ;
{ <NEW_LINE> <TAB> if ( ftrace_event_is_function ( tp_event ) && <NEW_LINE> <START_VULN> <TAB> perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - EPERM ;
#ifdef DEBUG <NEW_LINE> inline void CHECK_STATE ( int s ) const { NS_ASSERTION ( mState >= s , "bad state" ) ; } <NEW_LINE> #else <NEW_LINE> #define CHECK_STATE ( s ) ( ( void ) 0 ) <NEW_LINE> #endif <NEW_LINE> private : <NEW_LINE> <TAB> State mState ; <NEW_LINE> <TAB> nsXPConnect * mXPC ; <NEW_LINE> <TAB> XPCContext * mXPCContext ; <NEW_LINE> <TAB> JSContext * mJSContext ; <NEW_LINE> <TAB> JSBool mContextPopRequired ; <NEW_LINE> <START_VULN> <TAB> JSBool mDestroyJSContextInDestructor ; <NEW_LINE> <END_VULN> <TAB> XPCContext : : LangType mCallerLanguage ; <NEW_LINE> <TAB> XPCContext : : LangType mPrevCallerLanguage ; <NEW_LINE> <TAB> XPCCallContext * mPrevCallContext ;
<TAB> <TAB> return - ENOMEM ; <NEW_LINE> <TAB> * rcmd = ptr ; <NEW_LINE> <TAB> ret = copy_from_user ( ptr , param , sizeof ( * ptr ) ) ; <NEW_LINE> <START_VULN> <TAB> if ( ret ) <NEW_LINE><TAB> <TAB> return - EFAULT ; <NEW_LINE> <END_VULN> <TAB> ptr -> next = NULL ; <NEW_LINE> <TAB> ptr -> buffer_length = 0 ; <NEW_LINE> <TAB> param += sizeof ( struct floppy_raw_cmd ) ; <NEW_LINE> <TAB> if ( ptr -> cmd_count > 33 )
<TAB> <TAB> tnl_hlen = skb_tnl_header_len ( skb ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> <TAB> }
<TAB> if ( is_amsdu && tvb_reported_length_remaining ( next_tvb , 0 ) > 4 ) { <NEW_LINE> <TAB> <TAB> tvbuff_t * volatile msdu_tvb = NULL ; <NEW_LINE> <TAB> <TAB> guint32 msdu_offset = 0 ; <NEW_LINE> <START_VULN> <TAB> <TAB> guint16 i = 1 ; <NEW_LINE> <END_VULN> <TAB> <TAB> const guint8 * lcl_src = NULL ; <NEW_LINE> <TAB> <TAB> const guint8 * lcl_dst = NULL ; <NEW_LINE> <TAB> <TAB> guint16 msdu_length ;
<TAB> <TAB> if ( unlikely ( ! access_ok ( VERIFY_READ , kiocb -> ki_buf , <NEW_LINE> <TAB> <TAB> <TAB> kiocb -> ki_left ) ) ) <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <START_VULN> <TAB> <TAB> ret = security_file_permission ( file , MAY_WRITE ) ; <NEW_LINE><TAB> <TAB> if ( unlikely ( ret ) ) <NEW_LINE><TAB> <TAB> <TAB> break ; <NEW_LINE><TAB> <TAB> ret = aio_setup_single_vector ( kiocb ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ret ) <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> ret = - EINVAL ;
mrb_field_write_barrier ( mrb , ( struct RBasic * ) p , ( struct RBasic * ) p -> c ) ; <NEW_LINE> clone = mrb_obj_value ( p ) ; <NEW_LINE> init_copy ( mrb , clone , self ) ; <NEW_LINE> <START_VULN> p -> flags = mrb_obj_ptr ( self ) -> flags ; <NEW_LINE> <END_VULN> return clone ; <NEW_LINE> }
<TAB> <TAB> bdrv_delete ( bs1 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> get_tmp_filename ( tmp_filename , sizeof ( tmp_filename ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( is_protocol )
<TAB> t = plaintext -> len ; <NEW_LINE> <TAB> t -= paddingLength + overhead ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> good = DUPLICATE_MSB_TO_ALL ( ~ t ) ; <NEW_LINE> <TAB> t = blockSize - ( paddingLength + 1 ) ;
struct blkif_common_request { <NEW_LINE> <TAB> char dummy ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> struct blkif_common_response { <NEW_LINE><TAB> char dummy ; <NEW_LINE> } ; <NEW_LINE> <END_VULN> struct blkif_x86_32_request_rw { <NEW_LINE> <TAB> uint8_t nr_segments ;
#ifdef CONFIG_HUGETLBFS <NEW_LINE> struct hugetlbfs_sb_info { <NEW_LINE> <START_VULN> <TAB> long <TAB> max_blocks ; <NEW_LINE><TAB> long <TAB> free_blocks ; <NEW_LINE> <END_VULN> <TAB> long <TAB> max_inodes ; <NEW_LINE> <TAB> long <TAB> free_inodes ; <NEW_LINE> <TAB> spinlock_t <TAB> stat_lock ; <NEW_LINE> <TAB> struct hstate * hstate ; <NEW_LINE> } ; <NEW_LINE> static inline struct hugetlbfs_sb_info * HUGETLBFS_SB ( struct super_block * sb )
<TAB> <TAB> goto _error ; <NEW_LINE> <TAB> bprm -> argc + + ; <NEW_LINE> <START_VULN> <TAB> bprm -> interp = iname ; <TAB> <NEW_LINE> <END_VULN> <TAB> interp_file = open_exec ( iname ) ; <NEW_LINE> <TAB> retval = PTR_ERR ( interp_file ) ;
char * <NEW_LINE> guestfs___first_line_of_file ( guestfs_h * g , const char * filename ) <NEW_LINE> { <NEW_LINE> <START_VULN> CLEANUP_FREE char ** lines = NULL ; <NEW_LINE> <END_VULN> int64_t size ; <NEW_LINE> char * ret ;
<TAB> err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; <NEW_LINE> <TAB> if ( err == - ENOSPC && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( err ) <NEW_LINE> <TAB> <TAB> <TAB> goto fix_extent_len ;
<TAB> <TAB> <TAB> don't need to change the reference count . * / <NEW_LINE> <TAB> <TAB> <TAB> new_bh = old_bh ; <NEW_LINE> <TAB> <TAB> <TAB> get_bh ( new_bh ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> ext2_xattr_cache_insert ( new_bh ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> ext2_fsblk_t goal = ext2_group_first_block_no ( sb ,
<TAB> if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) { <NEW_LINE> <TAB> <TAB> <TAB> if ( snprintf ( scratch , scratch_len , "Host : % s : % i\r\n" , resource -> host , resource -> port ) > 0 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> php_stream_write ( stream , scratch , strlen ( scratch ) ) ;
<TAB> err = - EIO ; <NEW_LINE> <START_VULN> <TAB> netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; <NEW_LINE> <END_VULN> <TAB> netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ;
<TAB> uint_fast32_t tmpxend ; <NEW_LINE> <TAB> uint_fast32_t tmpyend ; <NEW_LINE> <TAB> jpc_dec_cp_t * cp ; <NEW_LINE> <START_VULN> <TAB> jpc_tsfb_band_t bnds [ 64 ] ; <NEW_LINE> <END_VULN> <TAB> jpc_pchg_t * pchg ; <NEW_LINE> <TAB> int pchgno ; <NEW_LINE> <TAB> jpc_dec_cmpt_t * cmpt ;
private : <NEW_LINE> already_AddRefed < nsIAtom > GetNameAtom ( nsIContent * aContent ) ; <NEW_LINE> void EnsureChildState ( ) ; <NEW_LINE> <START_VULN> void doRemoveChild ( ) ; <NEW_LINE> <END_VULN> nsString mValue ; <NEW_LINE> nsIContent * mChild ; <NEW_LINE> mozilla : : dom : : Element * GetContentInternal ( ) const
<TAB> <TAB> . index_key . type <TAB> <TAB> = type , <NEW_LINE> <TAB> <TAB> . index_key . description <TAB> = description , <NEW_LINE> <TAB> <TAB> . cred <TAB> <TAB> <TAB> = current_cred ( ) , <NEW_LINE> <START_VULN> <TAB> <TAB> . match_data . cmp <TAB> <TAB> = type -> match , <NEW_LINE> <END_VULN> <TAB> <TAB> . match_data . raw_data <TAB> = description , <NEW_LINE> <TAB> <TAB> . match_data . lookup_type <TAB> = KEYRING_SEARCH_LOOKUP_DIRECT , <NEW_LINE> <TAB> <TAB> . flags <TAB> <TAB> <TAB> = KEYRING_SEARCH_DO_STATE_CHECK ,
<TAB> list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { <NEW_LINE> <TAB> <TAB> if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && <NEW_LINE> <TAB> <TAB> cmd -> device -> lun == my_cmd -> device -> lun ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> sas_eh_defer_cmd ( cmd ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> }
<TAB> s -> buf_ptr = s -> buffer ; <NEW_LINE> <TAB> s -> buf_end = s -> buffer ; <NEW_LINE> <TAB> s -> line_count = 0 ; <NEW_LINE> <START_VULN> <TAB> s -> filesize = - 1 ; <NEW_LINE> <END_VULN> <TAB> cur_auth_type = s -> proxy_auth_state . auth_type ;
<TAB> <TAB> if ( ( int ) val < 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> found = 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> record_and_restart ( event , val , regs , nmi ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> }
char * vorbis_comment_query ( vorbis_comment * vc , const char * tag , int count ) { <NEW_LINE> long i ; <NEW_LINE> int found = 0 ; <NEW_LINE> int taglen = strlen ( tag ) + 1 ; <NEW_LINE> char * fulltag = alloca ( taglen + 1 ) ; <NEW_LINE> strcpy ( fulltag , tag ) ; <NEW_LINE> strcat ( fulltag , " = " ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( i = 0 ; i < vc -> comments ; i + + ) { <NEW_LINE> <TAB> if ( ! tagcompare ( vc -> user_comments [ i ] , fulltag , taglen ) ) { <NEW_LINE> <TAB> if ( count == found ) <NEW_LINE> <TAB> <TAB> <TAB> return vc -> user_comments [ i ] + taglen ; <NEW_LINE> <TAB> else <NEW_LINE> <TAB> <TAB> found + + ; <NEW_LINE> <TAB> }
<TAB> } <NEW_LINE> <TAB> uint32_t numInstructions ( ) const { <NEW_LINE> <TAB> <TAB> return numInstructions_ ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void setLocalSlotCount ( uint32_t localSlotCount ) { <NEW_LINE> <TAB> <TAB> localSlotCount_ = localSlotCount ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> uint32_t localSlotCount ( ) const { <NEW_LINE> <START_VULN> <TAB> <TAB> return localSlotCount_ ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> void setArgumentSlotCount ( uint32_t argumentSlotCount ) { <NEW_LINE> <TAB> <TAB> argumentSlotCount_ = argumentSlotCount ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> uint32_t argumentSlotCount ( ) const { <NEW_LINE> <TAB> <TAB> return argumentSlotCount_ ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> uint32_t totalSlotCount ( ) const {
<TAB> enum { ALLOW_MEMMOVE = PR_TRUE } ; <NEW_LINE> <TAB> ChangeCallback mKey ; <NEW_LINE> } ; <NEW_LINE> private : <NEW_LINE> void FireChangeCallbacks ( nsIContent * aOldContent , nsIContent * aNewContent ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> nsSmallVoidArray mIdContentList ; <NEW_LINE> nsBaseContentList * mNameContentList ; <NEW_LINE> nsRefPtr < nsContentList > mDocAllList ; <NEW_LINE> nsAutoPtr < nsTHashtable < ChangeCallbackEntry > > mChangeCallbacks ; <NEW_LINE> } ; <NEW_LINE> class nsDocHeaderData
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & ireq -> ir_v6_loc_addr , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & ireq -> ir_v6_rmt_addr ) ; <NEW_LINE> <TAB> <TAB> fl6 . daddr = ireq -> ir_v6_rmt_addr ; <NEW_LINE> <START_VULN> <TAB> <TAB> err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> err = net_xmit_eval ( err ) ; <NEW_LINE> <TAB> }
static inline size_t GetPSDRowSize ( Image * image ) <NEW_LINE> { <NEW_LINE> if ( image -> depth == 1 ) <NEW_LINE> <START_VULN> <TAB> return ( ( image -> columns + 7 ) / 8 ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> <TAB> return ( image -> columns * GetPSDPacketSize ( image ) ) ; <NEW_LINE> }
<TAB> if ( oldcode == - 1 ) { <NEW_LINE> <TAB> <TAB> if ( code >= MAX_BITS ) <NEW_LINE> <TAB> <TAB> return false ; <NEW_LINE> <START_VULN> <TAB> <TAB> * rowp + + = suffix [ code ] ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( rowp == rowend ) <NEW_LINE> <TAB> <TAB> OUTPUT_ROW ( ) ;
<TAB> <TAB> case LC_LOAD_WEAK_DYLIB : <NEW_LINE> <TAB> <TAB> <TAB> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_ % d . cmd" , i ) , "load_dylib" , 0 ) ; <NEW_LINE> <TAB> <TAB> <TAB> bin -> nlibs + + ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( ! parse_dylib ( bin , off ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> bprintf ( "Cannot parse dylib\n" ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> bin -> nlibs -- ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return false ;
<TAB> with static tables , but Vorbis allows a number of possible <NEW_LINE> <TAB> combinations , so it's best to do it computationally . <NEW_LINE> <TAB> The below is authoritative in terms of defining scale mapping . <NEW_LINE> <TAB> Note that the scale depends on the sampling rate as well as the <NEW_LINE> <TAB> linear block and mapping sizes * / <NEW_LINE> static void floor0_map_lazy_init ( vorbis_block * vb , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> vorbis_info_floor * infoX , <NEW_LINE><TAB> <TAB> <TAB> <TAB> vorbis_look_floor0 * look ) { <NEW_LINE> <END_VULN> if ( ! look -> linearmap [ vb -> W ] ) { <NEW_LINE> <TAB> vorbis_dsp_state * vd = vb -> vd ; <NEW_LINE> <TAB> vorbis_info * vi = vd -> vi ; <NEW_LINE> <TAB> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> <TAB> vorbis_info_floor0 * info = ( vorbis_info_floor0 * ) infoX ; <NEW_LINE> <TAB> int W = vb -> W ; <NEW_LINE> <TAB> int n = ci -> blocksizes [ W ] / 2 , j ;
<TAB> const ut8 * buf_end = obuf + obuf_len ; <NEW_LINE> <TAB> size_t j ; <NEW_LINE> <START_VULN> <TAB> if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> }
<TAB> if ( ! timr ) <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <START_VULN> <TAB> overrun = timr -> it_overrun_last ; <NEW_LINE> <END_VULN> <TAB> unlock_timer ( timr , flags ) ; <NEW_LINE> <TAB> return overrun ;
<TAB> <TAB> <TAB> tp [ 0 ] = '\0' ; <NEW_LINE> <TAB> <TAB> <TAB> add_assoc_string ( * subarray , "ipv6" , name , 1 ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( cp < p + dlen ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> n = dn_expand ( answer -> qb2 , answer -> qb2 + 65536 , cp , name , ( sizeof name ) - 2 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> if ( n < 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
<TAB> did_log = 1 ; <NEW_LINE> egress : <NEW_LINE> <START_VULN> <TAB> if ( errcode != 0 ) <NEW_LINE><TAB> <TAB> assert ( state -> status != 0 ) ; <NEW_LINE> <END_VULN> <TAB> au_state -> status = state -> status ; <NEW_LINE> <TAB> au_state -> reply = & state -> reply ;
<TAB> } <NEW_LINE> <TAB> case ARCMSR_MESSAGE_WRITE_WQBUFFER : { <NEW_LINE> <TAB> <TAB> unsigned char * ver_addr ; <NEW_LINE> <START_VULN> <TAB> <TAB> int32_t user_len , cnt2end ; <NEW_LINE> <END_VULN> <TAB> <TAB> uint8_t * pQbuffer , * ptmpuserbuffer ; <NEW_LINE> <TAB> <TAB> ver_addr = kmalloc ( ARCMSR_API_DATA_BUFLEN , GFP_ATOMIC ) ; <NEW_LINE> <TAB> <TAB> if ( ! ver_addr ) {
<TAB> . vcpu_load = svm_vcpu_load , <NEW_LINE> <TAB> . vcpu_put = svm_vcpu_put , <NEW_LINE> <START_VULN> <TAB> . update_db_bp_intercept = update_db_bp_intercept , <NEW_LINE> <END_VULN> <TAB> . get_msr = svm_get_msr , <NEW_LINE> <TAB> . set_msr = svm_set_msr , <NEW_LINE> <TAB> . get_segment_base = svm_get_segment_base ,
<TAB> Image ( nsIURI * aURI , nsStringBuffer * aString , nsIURI * aReferrer , <NEW_LINE> <TAB> <TAB> nsIPrincipal * aOriginPrincipal , nsIDocument * aDocument ) NS_HIDDEN ; <NEW_LINE> <TAB> ~ Image ( ) NS_HIDDEN ; <NEW_LINE> <TAB> nsCOMPtr < imgIRequest > mRequest ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> void AddRef ( ) { + + mRefCnt ; } <NEW_LINE><TAB> void Release ( ) { if ( -- mRefCnt == 0 ) delete this ; } <NEW_LINE> <END_VULN> } ; <NEW_LINE> private : <NEW_LINE> static const PRUnichar * GetBufferValue ( nsStringBuffer * aBuffer ) { <NEW_LINE> <TAB> return static_cast < PRUnichar * > ( aBuffer -> Data ( ) ) ; <NEW_LINE> } <NEW_LINE> protected :
{ <NEW_LINE> <TAB> void * pointer ; <NEW_LINE> <START_VULN> <TAB> if ( ! handle ) <NEW_LINE> <END_VULN> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ;
NSS_CMSSignerInfo_Sign ( NSSCMSSignerInfo * signerinfo , SECItem * digest , SECItem * contentType ) <NEW_LINE> { <NEW_LINE> <TAB> CERTCertificate * cert ; <NEW_LINE> <TAB> SECKEYPrivateKey * privkey = NULL ; <NEW_LINE> <TAB> SECOidTag digestalgtag ; <NEW_LINE> <TAB> SECOidTag pubkAlgTag ; <NEW_LINE> <TAB> SECItem signature = { 0 } ; <NEW_LINE> <TAB> SECStatus rv ; <NEW_LINE> <START_VULN> <TAB> PLArenaPool * poolp , * tmppoolp ; <NEW_LINE> <END_VULN> <TAB> SECAlgorithmID * algID , freeAlgID ; <NEW_LINE> <TAB> CERTSubjectPublicKeyInfo * spki ; <NEW_LINE> <TAB> PORT_Assert ( digest != NULL ) ; <NEW_LINE> <TAB> poolp = signerinfo -> cmsg -> poolp ; <NEW_LINE> <TAB> switch ( signerinfo -> signerIdentifier . identifierType ) {
#if USE_MAGIC_HEADERS <NEW_LINE> <TAB> size_t _alignment = alignment ; <NEW_LINE> <TAB> size_t * _ret = 0 ; <NEW_LINE> <START_VULN> <TAB> size += alignment + 3 * sizeof ( size_t ) ; <NEW_LINE> <END_VULN> <TAB> _alignment = 0 ; <NEW_LINE> #endif <NEW_LINE> #if USE_ALLOCATOR == 0
<TAB> assert ( sizeof ( sf_count_t ) == 8 ) ; <NEW_LINE> <START_VULN> <TAB> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <NEW_LINE> <END_VULN> <TAB> { <TAB> sf_errno = SFE_MALLOC_FAILED ; <NEW_LINE> <TAB> <TAB> return <TAB> NULL ; <NEW_LINE> <TAB> <TAB> } ;
oggpack_write ( opb , 1 , 1 ) ; <NEW_LINE> return ( 0 ) ; <NEW_LINE> } <NEW_LINE> static int _vorbis_pack_comment ( oggpack_buffer * opb , vorbis_comment * vc ) { <NEW_LINE> int bytes = strlen ( ENCODE_VENDOR_STRING ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> oggpack_write ( opb , 0x03 , 8 ) ; <NEW_LINE> _v_writestring ( opb , "vorbis" , 6 ) ; <NEW_LINE> oggpack_write ( opb , bytes , 32 ) ; <NEW_LINE> _v_writestring ( opb , ENCODE_VENDOR_STRING , bytes ) ;
void SetBackgroundUnknown ( ) ; <NEW_LINE> already_AddRefed < gfxContext > BeginUpdateBackground ( const nsIntRect & aRect ) ; <NEW_LINE> void EndUpdateBackground ( gfxContext * aContext , const nsIntRect & aRect ) ; <NEW_LINE> bool UseAsyncRendering ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> private : <NEW_LINE> bool IsUpToDate ( ) <NEW_LINE> { <NEW_LINE> <TAB> nsIntSize size ; <NEW_LINE> <TAB> return NS_SUCCEEDED ( mInstance -> GetImageSize ( & size ) ) && <NEW_LINE> <TAB> size == nsIntSize ( mPluginWindow -> width , mPluginWindow -> height ) ;
{ <NEW_LINE> <TAB> static gprinc_ret ret ; <NEW_LINE> <TAB> char * prime_arg , * funcname ; <NEW_LINE> <START_VULN> <TAB> gss_buffer_desc client_name , <NEW_LINE><TAB> <TAB> service_name ; <NEW_LINE> <END_VULN> <TAB> OM_uint32 minor_stat ; <NEW_LINE> <TAB> kadm5_server_handle_t handle ; <NEW_LINE> <TAB> const char * errmsg = NULL ;
#define AUDITSC_SUCCESS 1 <NEW_LINE> #define AUDITSC_FAILURE 2 <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #define MAX_EXECVE_AUDIT_LEN 7500
INST_HANDLER ( cpse ) { <TAB> <NEW_LINE> <TAB> int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; <NEW_LINE> <TAB> int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; <NEW_LINE> <START_VULN> <TAB> RAnalOp next_op ; <NEW_LINE> <END_VULN>
<TAB> return ( DestroyImageList ( image ) ) ; <NEW_LINE> <TAB> if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != <NEW_LINE> <TAB> <TAB> sun_info . length || ! sun_info . length ) <NEW_LINE> <START_VULN> <TAB> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <END_VULN> <TAB> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; <NEW_LINE> <TAB> if ( ( sun_info . type != RT_ENCODED ) && <NEW_LINE> <TAB> <TAB> ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) )
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> * s = ' / ' ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> s [ 1 ] = '\0' ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> if ( resource -> path && * ( resource -> path ) == ' / ' && * ( resource -> path + 1 ) == '\0' ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> snprintf ( loc_path , sizeof ( loc_path ) - 1 , " % s % s" , resource -> path , location ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> } else {
<TAB> uint32_t mOwnOrContainingAppId ; <NEW_LINE> private : <NEW_LINE> <TAB> nsCString mForcedCharset ; <NEW_LINE> <TAB> nsCString mParentCharset ; <NEW_LINE> <TAB> nsTObserverArray < nsWeakPtr > mPrivacyObservers ; <NEW_LINE> <TAB> nsTObserverArray < nsWeakPtr > mReflowObservers ; <NEW_LINE> <START_VULN> <TAB> int32_t mParentCharsetSource ; <NEW_LINE> <END_VULN> <TAB> nsCString mOriginalUriString ; <NEW_LINE> <TAB> nsresult DoFindItemWithName ( const PRUnichar * aName , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsISupports * aRequestor , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIDocShellTreeItem * aOriginalRequestor , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIDocShellTreeItem ** _retval ) ;
<TAB> sb -> s_fs_info = sbinfo ; <NEW_LINE> <TAB> sbinfo -> hstate = config . hstate ; <NEW_LINE> <TAB> spin_lock_init ( & sbinfo -> stat_lock ) ; <NEW_LINE> <START_VULN> <TAB> sbinfo -> max_blocks = config . nr_blocks ; <NEW_LINE><TAB> sbinfo -> free_blocks = config . nr_blocks ; <NEW_LINE> <END_VULN> <TAB> sbinfo -> max_inodes = config . nr_inodes ; <NEW_LINE> <TAB> sbinfo -> free_inodes = config . nr_inodes ; <NEW_LINE> <TAB> sb -> s_maxbytes = MAX_LFS_FILESIZE ; <NEW_LINE> <TAB> sb -> s_blocksize = huge_page_size ( config . hstate ) ; <NEW_LINE> <TAB> sb -> s_blocksize_bits = huge_page_shift ( config . hstate ) ;
<TAB> if ( max + 6 . f > flr [ i ] ) { <NEW_LINE> <TAB> oc = oc >> p -> shiftoc ; <NEW_LINE> <TAB> if ( oc >= P_BANDS ) oc = P_BANDS - 1 ; <NEW_LINE> <TAB> if ( oc < 0 ) oc = 0 ; <NEW_LINE> <TAB> seed_curve ( seed , <NEW_LINE> <START_VULN> <TAB> <TAB> curves [ oc ] , <NEW_LINE><TAB> <TAB> max , <NEW_LINE><TAB> <TAB> p -> octave [ i ] - p -> firstoc , <NEW_LINE><TAB> <TAB> p -> total_octave_lines , <NEW_LINE><TAB> <TAB> p -> eighth_octave_lines , <NEW_LINE><TAB> <TAB> dBoffset ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> static void seed_chase ( float * seeds , int linesper , long n ) { <NEW_LINE> long * posstack = alloca ( n * sizeof ( * posstack ) ) ; <NEW_LINE> float * ampstack = alloca ( n * sizeof ( * ampstack ) ) ; <NEW_LINE> long stack = 0 ;
* <NEW_LINE> <START_VULN> static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> char * p ; <NEW_LINE> <TAB> int rc = 0 ;
<TAB> { <NEW_LINE> <TAB> if ( obuf [ i ] != rbuf [ i ] ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> XPR ( NT "byte % u ( read % u @ % "Q"u ) % d != % d\n" , <NEW_LINE> <END_VULN> <TAB> <TAB> ( int ) i , ( int ) oc , offset , obuf [ i ] , rbuf [ i ] ) ; <NEW_LINE> <TAB> diffs + + ; <NEW_LINE> <TAB> return XD3_INTERNAL ;
<TAB> if ( errmsg != NULL ) <NEW_LINE> <TAB> <TAB> krb5_free_error_message ( handle -> context , errmsg ) ; <NEW_LINE> <TAB> gss_release_buffer ( & minor_stat , & client_name ) ; <NEW_LINE> <TAB> gss_release_buffer ( & minor_stat , & service_name ) ; <NEW_LINE> <START_VULN> exit_func : <NEW_LINE> <END_VULN> <TAB> free_server_handle ( handle ) ; <NEW_LINE> <TAB> return & ret ; <NEW_LINE> }
#endif <NEW_LINE> <TAB> <TAB> <TAB> if ( ! is_anonymous ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> if ( s && s > filename ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> safe_php_register_variable ( lbuf , s + 1 , strlen ( s + 1 ) , NULL , 0 TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> safe_php_register_variable ( lbuf , filename , strlen ( filename ) , NULL , 0 TSRMLS_CC ) ;
<START_VULN> <TAB> <TAB> if ( inet -> hdrincl ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> goto done ; <NEW_LINE> <TAB> <TAB> if ( ipc . opt -> opt . srr ) { <NEW_LINE> <TAB> <TAB> <TAB> if ( ! daddr )
<TAB> <TAB> <TAB> krb5_free_error_message ( handle -> context , errmsg ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> free ( prime_arg1 ) ; <NEW_LINE> <TAB> free ( prime_arg2 ) ; <NEW_LINE> <TAB> gss_release_buffer ( & minor_stat , & client_name ) ; <NEW_LINE> <TAB> gss_release_buffer ( & minor_stat , & service_name ) ; <NEW_LINE> <START_VULN> exit_func : <NEW_LINE> <END_VULN> <TAB> free_server_handle ( handle ) ; <NEW_LINE> <TAB> return & ret ; <NEW_LINE> }
<TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( len + 15 > dev -> mtu ) { <NEW_LINE><TAB> <TAB> mutex_unlock ( & econet_mutex ) ; <NEW_LINE><TAB> <TAB> return - EMSGSIZE ; <NEW_LINE><TAB> } <NEW_LINE><NEW_LINE> <END_VULN> <TAB> if ( dev -> type == ARPHRD_ECONET ) { <NEW_LINE> #ifdef CONFIG_ECONET_NATIVE <NEW_LINE> <TAB> <TAB> unsigned short proto = 0 ; <NEW_LINE> <TAB> <TAB> int res ; <NEW_LINE> <TAB> <TAB> dev_hold ( dev ) ;
<TAB> <TAB> ( ( decoder -> video_info . height - decoder -> video_info . offset_y ) < decoder -> video_info . frame_height ) <NEW_LINE> <TAB> <TAB> || <NEW_LINE> <TAB> <TAB> ( ( decoder -> video_info . width - decoder -> video_info . offset_x ) < decoder -> video_info . frame_width ) <NEW_LINE> <TAB> ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> common -> initialised |= - 1 ; <NEW_LINE> <TAB> <TAB> return OGGZ_CONTINUE ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> if ( theora_decode_init ( & ( decoder -> video_handle ) , & ( decoder -> video_info ) ) ) { <NEW_LINE> <TAB> <TAB> common -> initialised |= - 1 ; <NEW_LINE> <TAB> <TAB> return OGGZ_CONTINUE ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> common -> initialised |= 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return OGGZ_CONTINUE ;
<TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> FT_ASSERT ( cur [ 0 ] -> clazz ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( cur [ 0 ] -> clazz -> get_interface ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> result = cur [ 0 ] -> clazz -> get_interface ( cur [ 0 ] , service_id ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( result != NULL )
<TAB> else <NEW_LINE> <TAB> <TAB> ip4h . ip_off = htons ( off ) ; <NEW_LINE> <TAB> ip4h . ip_ttl = ttl ; <NEW_LINE> <START_VULN> <TAB> ip4h . ip_proto = IPPROTO_ICMP ; <NEW_LINE> <END_VULN> <TAB> ip4h . s_ip_src . s_addr = 0x01010101 ; <NEW_LINE> <TAB> ip4h . s_ip_dst . s_addr = 0x02020202 ;
<START_VULN> static int CVE_2014_5472_isofs_read_inode ( struct inode * inode ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct super_block * sb = inode -> i_sb ; <NEW_LINE> <TAB> struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ;
<TAB> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> ff_free_vlc ( & s -> vlc [ i ] ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , <NEW_LINE><TAB> <TAB> <TAB> <TAB> s -> bits [ i ] , 4 , 4 , 0 ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> generate_joint_tables ( s ) ;
static const struct net_offload sit_offload = { <NEW_LINE> <TAB> . callbacks = { <NEW_LINE> <TAB> <TAB> . gso_segment <TAB> = ipv6_gso_segment , <NEW_LINE> <START_VULN> <TAB> <TAB> . gro_receive = ipv6_gro_receive , <NEW_LINE> <END_VULN> <TAB> <TAB> . gro_complete = sit_gro_complete , <NEW_LINE> <TAB> } , <NEW_LINE> } ;
<TAB> nsLayoutUtils : : SurfaceFromElementResult SurfaceFromElement ( const dom : : NonNull < ElementType > & aElement ) { <NEW_LINE> <TAB> return SurfaceFromElement ( aElement . get ( ) ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> nsresult SurfaceFromElementResultToImageSurface ( nsLayoutUtils : : SurfaceFromElementResult & res , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> gfxImageSurface ** imageOut , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> WebGLTexelFormat * format ) ; <NEW_LINE> <START_VULN> <TAB> void CopyTexSubImage2D_base ( WebGLenum target , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> WebGLint level , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> WebGLenum internalformat , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> WebGLint xoffset , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> WebGLint yoffset , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> WebGLint x , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> WebGLint y , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> WebGLsizei width , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> WebGLsizei height ,
PRInt32 GetContentLengthHint ( ) const { return mContentLengthHint ; } <NEW_LINE> PRInt32 GetInFlowContentLength ( ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> <NEW_LINE>void ClearTextRun ( ) ; <NEW_LINE> <END_VULN> gfxSkipCharsIterator EnsureTextRun ( gfxContext * aReferenceContext = nsnull , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIFrame * aLineContainer = nsnull , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsLineList : : iterator * aLine = nsnull , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRUint32 * aFlowEndInTextRun = nsnull ) ; <NEW_LINE> gfxTextRun * GetTextRun ( ) { return mTextRun ; } <NEW_LINE> void SetTextRun ( gfxTextRun * aTextRun ) { mTextRun = aTextRun ; } <NEW_LINE> struct TrimmedOffsets { <NEW_LINE> <TAB> PRInt32 mStart ; <NEW_LINE> <TAB> PRInt32 mLength ; <NEW_LINE> <TAB> PRInt32 GetEnd ( ) { return mStart + mLength ; }
<TAB> ret = key -> type -> update ( key , & prep ) ; <NEW_LINE> <TAB> if ( ret == 0 ) <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE><TAB> <TAB> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <NEW_LINE> <END_VULN> <TAB> up_write ( & key -> sem ) ;
<TAB> SSL_TRC ( 3 , ( " % d : SSL3 [ % d ] : handle certificate_verify handshake" , <NEW_LINE> <TAB> <TAB> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> <TAB> isTLS = ( PRBool ) ( ss -> ssl3 . prSpec -> version > SSL_LIBRARY_VERSION_3_0 ) ; <NEW_LINE> <TAB> isTLS12 = ( PRBool ) ( ss -> ssl3 . prSpec -> version >= SSL_LIBRARY_VERSION_TLS_1_2 ) ; <NEW_LINE> <START_VULN> <TAB> if ( ss -> ssl3 . hs . ws != wait_cert_verify || ss -> sec . peerCert == NULL ) { <NEW_LINE> <END_VULN> <TAB> desc = unexpected_message ; <NEW_LINE> <TAB> errCode = SSL_ERROR_RX_UNEXPECTED_CERT_VERIFY ; <NEW_LINE> <TAB> goto alert_loser ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( isTLS12 ) { <NEW_LINE> <TAB> rv = ssl3_ConsumeSignatureAndHashAlgorithm ( ss , & b , & length , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & sigAndHash ) ;
<TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> if ( i > ( sizeof ( outbuff ) - 20 ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> outbuff [ i ] = '\0' ; <NEW_LINE> <TAB> <TAB> <TAB> fprintf ( f , " % s" , outbuff ) ; <NEW_LINE> <TAB> <TAB> <TAB> i = 0 ;
int vorbis_synthesis_pcmout ( vorbis_dsp_state * v , float ** * pcm ) { <NEW_LINE> vorbis_info * vi = v -> vi ; <NEW_LINE> if ( v -> pcm_returned > - 1 && v -> pcm_returned < v -> pcm_current ) { <NEW_LINE> <TAB> if ( pcm ) { <NEW_LINE> <TAB> int i ; <NEW_LINE> <TAB> for ( i = 0 ; i < vi -> channels ; i + + ) <NEW_LINE> <START_VULN> <TAB> v -> pcmret [ i ] = v -> pcm [ i ] + v -> pcm_returned ; <NEW_LINE> <END_VULN> <TAB> * pcm = v -> pcmret ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return ( v -> pcm_current - v -> pcm_returned ) ; <NEW_LINE> } <NEW_LINE> return ( 0 ) ; <NEW_LINE> } <NEW_LINE> int vorbis_synthesis_read ( vorbis_dsp_state * v , int n ) {
ipv6 : <NEW_LINE> <TAB> <TAB> iph = __skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , data , hlen , & _iph ) ; <NEW_LINE> <TAB> <TAB> if ( ! iph ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <END_VULN> <TAB> <TAB> ip_proto = iph -> nexthdr ; <NEW_LINE> <TAB> <TAB> nhoff += sizeof ( struct ipv6hdr ) ;
<TAB> st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; <NEW_LINE> <TAB> size_bmp = FFMAX ( size_asf , size_bmp ) ; <NEW_LINE> <START_VULN> <TAB> if ( size_bmp > BMP_HEADER_SIZE ) { <NEW_LINE> <END_VULN> <TAB> <TAB> int ret ; <NEW_LINE> <TAB> <TAB> st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; <NEW_LINE> <TAB> <TAB> if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size +
<TAB> phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> goto error ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> box -> ops = & jp2_boxinfo_unk . ops ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> jas_eprintf ( "cannot copy box data\n" ) ; <NEW_LINE> <TAB> <TAB> <TAB> goto error ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> jas_stream_rewind ( tmpstream ) ; <NEW_LINE> <TAB> <TAB> if ( box -> ops -> getdata ) { <NEW_LINE> <TAB> <TAB> <TAB> if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> jas_eprintf ( "cannot parse box data\n" ) ;
<TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ! ap_strchr_c ( range , ' , ' ) ) { <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> num_ranges = 1 ; <NEW_LINE><TAB> } <NEW_LINE><TAB> else { <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> num_ranges = 2 ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> r -> status = HTTP_PARTIAL_CONTENT ; <NEW_LINE> <TAB> r -> range = range + 6 ;
<TAB> <TAB> for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i + + ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> next_input = input + i * input_incr ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( bytes_matched + i >= max_bytes_matched ) <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> if ( * ( next_opcode ) != RE_OPCODE_LITERAL || <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ( * ( next_opcode ) == RE_OPCODE_LITERAL && <NEW_LINE> <TAB> <TAB> <TAB> <TAB> * ( next_opcode + 1 ) == * next_input ) )
<TAB> fd_install ( fd , filp ) ; <NEW_LINE> <TAB> goto out_upsem ; <NEW_LINE> out_putfd : <NEW_LINE> <START_VULN> <TAB> mntput ( mqueue_mnt ) ; <NEW_LINE> <END_VULN> <TAB> put_unused_fd ( fd ) ; <NEW_LINE> out_err : <NEW_LINE> <TAB> fd = error ;
<TAB> OM_uint32 code ; <NEW_LINE> <TAB> ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <NEW_LINE> <START_VULN> <TAB> if ( ! ctx -> established ) { <NEW_LINE> <END_VULN> <TAB> <TAB> * minor_status = KG_CTX_INCOMPLETE ; <NEW_LINE> <TAB> <TAB> return GSS_S_NO_CONTEXT ; <NEW_LINE> <TAB> }
<TAB> int charlen ; <NEW_LINE> <TAB> if ( utf8 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> * outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( * outlen < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> return * outlen ; <NEW_LINE> <TAB> <TAB> else if ( * outlen > FAT_LFN_LEN )
<TAB> int php_optind = 1 , use_extended_info = 0 ; <NEW_LINE> <TAB> char * ini_path_override = NULL ; <NEW_LINE> <TAB> char * ini_entries = NULL ; <NEW_LINE> <START_VULN> <TAB> int ini_entries_len = 0 ; <NEW_LINE> <END_VULN> <TAB> int ini_ignore = 0 ; <NEW_LINE> <TAB> sapi_module_struct * sapi_module = & cli_sapi_module ;
<TAB> DefragInit ( ) ; <NEW_LINE> <START_VULN> <TAB> Packet * p1 = BuildTestPacket ( ip_id , 2 , 1 , 'C' , 8 ) ; <NEW_LINE><TAB> Packet * p2 = BuildTestPacket ( ip_id , 0 , 1 , 'A' , 8 ) ; <NEW_LINE><TAB> Packet * p3 = BuildTestPacket ( ip_id , 1 , 0 , 'B' , 8 ) ; <NEW_LINE> <END_VULN> <TAB> if ( p1 == NULL || p2 == NULL || p3 == NULL ) { <NEW_LINE> <TAB> <TAB> goto end ; <NEW_LINE> <TAB> }
<TAB> if ( status == MagickFalse ) <NEW_LINE> <TAB> continue ; <NEW_LINE> <START_VULN> <TAB> p = GetCacheViewVirtualPixels ( image_view , 0 , y , image -> columns , 1 , exception ) ; <NEW_LINE> <END_VULN> <TAB> q = QueueCacheViewAuthenticPixels ( splice_view , 0 , y , splice_image -> columns , 1 , <NEW_LINE> <TAB> exception ) ; <NEW_LINE> <TAB> if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) )
GimpImage * image ; <NEW_LINE> GimpImage * loaded_image ; <NEW_LINE> GimpPlugInProcedure * proc ; <NEW_LINE> <START_VULN> gchar * filename ; <NEW_LINE> <END_VULN> GFile * file ;
<TAB> phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> } <NEW_LINE> }
<TAB> <TAB> if ( np -> repflow && ireq -> pktopts ) <NEW_LINE> <TAB> <TAB> <TAB> fl6 -> flowlabel = ip6_flowlabel ( ipv6_hdr ( ireq -> pktopts ) ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> err = ip6_xmit ( sk , skb , fl6 , np -> opt , np -> tclass ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> err = net_xmit_eval ( err ) ; <NEW_LINE> <TAB> }
{ <NEW_LINE> <TAB> struct mount * tree ; <NEW_LINE> <TAB> namespace_lock ( ) ; <NEW_LINE> <START_VULN> <TAB> tree = copy_tree ( real_mount ( path -> mnt ) , path -> dentry , <NEW_LINE><TAB> <TAB> <TAB> CL_COPY_ALL | CL_PRIVATE ) ; <NEW_LINE> <END_VULN> <TAB> namespace_unlock ( ) ; <NEW_LINE> <TAB> if ( IS_ERR ( tree ) ) <NEW_LINE> <TAB> <TAB> return ERR_CAST ( tree ) ;
PRBool HaveForcedBreakPosition ( ) { return mForceBreakContent != nsnull ; } <NEW_LINE> PRInt32 GetForcedBreakPosition ( nsIContent * aContent ) { <NEW_LINE> <TAB> return mForceBreakContent == aContent ? mForceBreakContentOffset : - 1 ; <NEW_LINE> } <NEW_LINE> nsIFrame * GetLineContainerFrame ( ) const { return mBlockReflowState -> frame ; } <NEW_LINE> const nsLineList : : iterator * GetLine ( ) const { <NEW_LINE> <TAB> return GetFlag ( LL_GOTLINEBOX ) ? & mLineBox : nsnull ; <NEW_LINE> } <NEW_LINE> static void <NEW_LINE> BuildTextRuns ( gfxContext * aContext , nsTextFrame * aForFrame , <NEW_LINE> <TAB> <TAB> <TAB> nsIFrame * aLineContainer , const nsLineList : : iterator * aForFrameLine ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( aForFrame || aForFrameLine , <NEW_LINE><TAB> <TAB> <TAB> "One of aForFrame or aForFrameLine must be set ! " ) ; <NEW_LINE><NEW_LINE>if ( ! aLineContainer ) { <NEW_LINE> <END_VULN> <TAB> aLineContainer = FindLineContainer ( aForFrame ) ; <NEW_LINE> } else { <NEW_LINE> <TAB> NS_ASSERTION ( ! aForFrame || aLineContainer == FindLineContainer ( aForFrame ) , "Wrong line container hint" ) ; <NEW_LINE> } <NEW_LINE> nsPresContext * presContext = aLineContainer -> PresContext ( ) ; <NEW_LINE> BuildTextRunsScanner scanner ( presContext , aContext , aLineContainer ) ;
{ <NEW_LINE> } <NEW_LINE> <START_VULN> static inline void <NEW_LINE>ext2_xattr_put_super ( struct super_block * sb ) <NEW_LINE> { <NEW_LINE> } <NEW_LINE><NEW_LINE>static inline int <NEW_LINE>init_ext2_xattr ( void ) <NEW_LINE> { <NEW_LINE><TAB> return 0 ; <NEW_LINE> } <NEW_LINE><NEW_LINE>static inline void <NEW_LINE>exit_ext2_xattr ( void ) <NEW_LINE> <END_VULN> { <NEW_LINE> }
<TAB> <TAB> <TAB> <TAB> EXT4_FREE_BLOCKS_FORGET ) ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> le32_add_cpu ( & BHDR ( bh ) -> h_refcount , - 1 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ce ) <NEW_LINE><TAB> <TAB> <TAB> mb_cache_entry_release ( ce ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ea_bdebug ( bs -> bh , "modifying in - place" ) ; <NEW_LINE> <TAB> <TAB> <TAB> error = ext4_xattr_set_entry ( i , s ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ! error ) {
<TAB> if ( ! CheckGlobalObjectShape ( cx , tm , f -> globalObj ) ) { <NEW_LINE> <TAB> <TAB> Backoff ( cx , ( jsbytecode * ) localRootIP ) ; <NEW_LINE> <TAB> <TAB> return false ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> AUDIT ( recorderStarted ) ; <NEW_LINE> <START_VULN> <TAB> if ( tm -> outOfMemory ( ) || OverfullJITCache ( tm ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> Backoff ( cx , ( jsbytecode * ) f -> root -> ip ) ; <NEW_LINE> <TAB> <TAB> ResetJIT ( cx , FR_OOM ) ; <NEW_LINE> <TAB> <TAB> debug_only_print0 ( LC_TMTracer , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> "Out of memory recording new tree , flushing cache . \n" ) ; <NEW_LINE> <TAB> <TAB> return false ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> JS_ASSERT ( ! f -> code ( ) ) ;
<TAB> <TAB> <TAB> <TAB> if ( DiscardBlobBytes ( image , ( MagickSizeType ) ( length - 18 ) ) == MagickFalse ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> ThrowBinaryException ( CorruptImageError , "UnexpectedEndOfFile" , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> image -> filename ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> length = ReadBlobLong ( image ) ;
<TAB> ** be used as the cert's identity . <NEW_LINE> <TAB> rv = cert_VerifySubjectAltName ( cert , hn ) ; <NEW_LINE> <TAB> if ( rv == SECSuccess || PORT_GetError ( ) != SEC_ERROR_EXTENSION_NOT_FOUND ) <NEW_LINE> <TAB> <TAB> return rv ; <NEW_LINE> <TAB> cn = CERT_GetCommonName ( & cert -> subject ) ; <NEW_LINE> <TAB> if ( cn ) { <NEW_LINE> <START_VULN> <TAB> rv = cert_TestHostName ( cn , hn ) ; <NEW_LINE> <END_VULN> <TAB> PORT_Free ( cn ) ; <NEW_LINE> <TAB> } else <NEW_LINE> <TAB> PORT_SetError ( SSL_ERROR_BAD_CERT_DOMAIN ) ; <NEW_LINE> <TAB> return rv ; <NEW_LINE> } <NEW_LINE> PRBool <NEW_LINE> CERT_CompareCerts ( CERTCertificate * c1 , CERTCertificate * c2 )
<TAB> OM_uint32 ret ; <NEW_LINE> <TAB> spnego_gss_ctx_id_t sc = NULL ; <NEW_LINE> <START_VULN> <TAB> sc = create_spnego_ctx ( ) ; <NEW_LINE> <END_VULN> <TAB> if ( sc == NULL ) <NEW_LINE> <TAB> <TAB> return GSS_S_FAILURE ;
<TAB> <TAB> udpdest . sin_addr . s_addr = htonl ( network | addr . station ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> ah . port = port ; <NEW_LINE> <TAB> ah . cb = cb & 0x7f ; <NEW_LINE> <TAB> ah . code = 2 ; <TAB> <TAB> <NEW_LINE> <START_VULN> <TAB> ah . pad = 0 ; <NEW_LINE> <END_VULN> <TAB> size = sizeof ( struct aunhdr ) ;
static int open_unix_listener ( h2o_configurator_command_t * cmd , yoml_t * node , struct sockaddr_un * sa ) <NEW_LINE> { <NEW_LINE> <TAB> struct stat st ; <NEW_LINE> <START_VULN> <TAB> int fd ; <NEW_LINE> <END_VULN> <TAB> struct passwd * owner = NULL , pwbuf ; <NEW_LINE> <TAB> char pwbuf_buf [ 65536 ] ; <NEW_LINE> <TAB> unsigned mode = UINT_MAX ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ( NC - 1 ) * sizeof ( cat_t ) ) ; <NEW_LINE> <TAB> if ( g == NULL ) <NEW_LINE> <TAB> <TAB> return ( REG_ESPACE ) ; <NEW_LINE> <START_VULN> <TAB> p -> ssize = len / ( size_t ) 2 * ( size_t ) 3 + ( size_t ) 1 ; <TAB> <NEW_LINE> <END_VULN> <TAB> p -> strip = ( sop * ) malloc ( p -> ssize * sizeof ( sop ) ) ; <NEW_LINE> <TAB> p -> slen = 0 ; <NEW_LINE> <TAB> if ( p -> strip == NULL ) {
<TAB> ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; <NEW_LINE> <TAB> ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; <NEW_LINE> <START_VULN> <TAB> ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ; <NEW_LINE><TAB> * reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ; <NEW_LINE> <END_VULN> <TAB> return X86EMUL_CONTINUE ; <NEW_LINE> }
<START_VULN> <TAB> <TAB> if ( n == - 1 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> * err = WTAP_ERR_BAD_FILE ; <NEW_LINE> <TAB> <TAB> <TAB> * err_info = g_strdup ( "netscreen : cannot parse hex - data" ) ; <NEW_LINE> <TAB> <TAB> <TAB> return FALSE ;
<TAB> <TAB> nlh = nlmsg_hdr ( skb ) ; <NEW_LINE> <TAB> <TAB> err = 0 ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) || <NEW_LINE><TAB> <TAB> skb -> len < nlh -> nlmsg_len ) { <NEW_LINE><TAB> <TAB> <TAB> err = - EINVAL ; <NEW_LINE><TAB> <TAB> <TAB> goto ack ; <NEW_LINE> <END_VULN> <TAB> <TAB> }
<TAB> delete mMembers ; <NEW_LINE> <TAB> delete mFields ; <NEW_LINE> } <NEW_LINE> nsresult InstallImplementation ( nsXBLPrototypeBinding * aPrototypeBinding , nsXBLBinding * aBinding ) ; <NEW_LINE> nsresult InitTargetObjects ( nsXBLPrototypeBinding * aBinding , nsIScriptContext * aContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIContent * aBoundElement , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIXPConnectJSObjectHolder ** aScriptObjectHolder , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject ** aTargetClassObject ) ; <NEW_LINE> <END_VULN> nsresult CompilePrototypeMembers ( nsXBLPrototypeBinding * aBinding ) ; <NEW_LINE> void SetMemberList ( nsXBLProtoImplMember * aMemberList ) <NEW_LINE> { <NEW_LINE> <TAB> delete mMembers ; <NEW_LINE> <TAB> mMembers = aMemberList ; <NEW_LINE> }
<TAB> } <NEW_LINE> <TAB> spin_unlock ( & sk -> sk_receive_queue . lock ) ; <NEW_LINE> <START_VULN> <TAB> if ( po -> has_vnet_hdr ) { <NEW_LINE> <END_VULN> <TAB> <TAB> if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> sizeof ( struct virtio_net_hdr ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> vio_le ( ) , true ) ) {
<TAB> if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { <NEW_LINE> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( shdr -> sh_size < 1 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> sdb = sdb_new0 ( ) ;
<TAB> const int dyh = ( dyy - ( 1 << ( 16 + shift ) ) ) * ( h - 1 ) ; <NEW_LINE> <TAB> const int dxh = dxy * ( h - 1 ) ; <NEW_LINE> <TAB> const int dyw = dyx * ( w - 1 ) ; <NEW_LINE> <START_VULN> <TAB> int need_emu = ( unsigned ) ix >= width - w || <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> ( unsigned ) iy >= height - h ; <NEW_LINE> <END_VULN> <TAB> if ( <NEW_LINE> <TAB> <TAB> ( ( ox ^ ( ox + dxw ) ) | ( ox ^ ( ox + dxh ) ) | ( ox ^ ( ox + dxw + dxh ) ) |
static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) <NEW_LINE> { <NEW_LINE> <TAB> long i ; <NEW_LINE> <START_VULN> <TAB> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> long a = * ( long * ) ( src1 + i ) ; <NEW_LINE> <TAB> <TAB> long b = * ( long * ) ( src2 + i ) ; <NEW_LINE> <TAB> <TAB> * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ;
<TAB> <TAB> <TAB> unsigned long arg ) <NEW_LINE> { <NEW_LINE> <TAB> struct linear_c * lc = ( struct linear_c * ) ti -> private ; <NEW_LINE> <START_VULN> <TAB> return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int linear_merge ( struct dm_target * ti , struct bvec_merge_data * bvm ,
<TAB> char * tmp_path = NULL ; <NEW_LINE> <TAB> if ( INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size ) <NEW_LINE> <START_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <END_VULN> <TAB> memcpy ( & source , buffer , sizeof ( struct entry_short ) ) ;
<TAB> <TAB> <TAB> maddr -> sapi = _pms ( sk ) -> ch . addr & 0xFF ; <NEW_LINE> <TAB> <TAB> <TAB> maddr -> tei = ( _pms ( sk ) -> ch . addr >> 8 ) & 0xFF ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> } else { <NEW_LINE><TAB> <TAB> if ( msg -> msg_namelen ) <NEW_LINE><TAB> <TAB> <TAB> printk ( KERN_WARNING " % s : too small namelen % d\n" , <NEW_LINE><TAB> <TAB> <TAB> __func__ , msg -> msg_namelen ) ; <NEW_LINE><TAB> <TAB> msg -> msg_namelen = 0 ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> copied = skb -> len + MISDN_HEADER_LEN ;
<TAB> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> snprintf ( lbuf , llen , " % s [ name ] " , param ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( s && s > filename ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> register_http_post_files_variable ( lbuf , s + 1 , http_post_files , 0 TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> register_http_post_files_variable ( lbuf , filename , http_post_files , 0 TSRMLS_CC ) ;
<TAB> size_t retlen ; <NEW_LINE> <TAB> int truncated ; <NEW_LINE> <START_VULN> <TAB> _dopr ( & buf , NULL , & n , & retlen , & truncated , format , args ) ; <NEW_LINE> <END_VULN> <TAB> if ( truncated )
sleep_again : <NEW_LINE> <TAB> current -> state = TASK_INTERRUPTIBLE ; <NEW_LINE> <START_VULN> <TAB> sem_unlock ( sma ) ; <NEW_LINE> <END_VULN> <TAB> if ( timeout ) <NEW_LINE> <TAB> <TAB> jiffies_left = schedule_timeout ( jiffies_left ) ;
{ <NEW_LINE> <TAB> static gpols_ret ret ; <NEW_LINE> <TAB> char * prime_arg ; <NEW_LINE> <START_VULN> <TAB> gss_buffer_desc client_name , <NEW_LINE><TAB> <TAB> service_name ; <NEW_LINE> <END_VULN> <TAB> OM_uint32 minor_stat ; <NEW_LINE> <TAB> kadm5_server_handle_t handle ; <NEW_LINE> <TAB> const char * errmsg = NULL ;
<TAB> <TAB> <TAB> ( ( whence == SEEK_CUR && off == 0 ) || <NEW_LINE> <TAB> <TAB> <TAB> ( whence == SEEK_SET && off == s -> off ) ) ) <NEW_LINE> <TAB> <TAB> return s -> off ; <NEW_LINE> <START_VULN> <TAB> else if ( ( s -> filesize == - 1 && whence == SEEK_END ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return AVERROR ( ENOSYS ) ; <NEW_LINE> <TAB> if ( whence == SEEK_CUR )
<TAB> } <NEW_LINE> <TAB> if ( XFS_DFORK_Q ( dip ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> switch ( dip -> di_aformat ) { <NEW_LINE><TAB> <TAB> case XFS_DINODE_FMT_LOCAL : <NEW_LINE><TAB> <TAB> <TAB> if ( dip -> di_anextents ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> return __this_address ; <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> case XFS_DINODE_FMT_EXTENTS : <NEW_LINE><TAB> <TAB> case XFS_DINODE_FMT_BTREE : <NEW_LINE><TAB> <TAB> <TAB> break ; <NEW_LINE><TAB> <TAB> default : <NEW_LINE><TAB> <TAB> <TAB> return __this_address ; <NEW_LINE><TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> } else {
<TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> PRInt32 FindMaxUshortElement ( ) { <NEW_LINE> <TAB> if ( mHasCachedMaxUshortElement ) { <NEW_LINE> <TAB> <TAB> return mCachedMaxUshortElement ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> mHasCachedMaxUshortElement = true ; <NEW_LINE> <START_VULN> <TAB> <TAB> mCachedMaxUshortElement = FindMaxElementInSubArray < GLshort > ( mByteLength >> 1 , 0 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return mCachedMaxUshortElement ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> NS_DECL_ISUPPORTS <NEW_LINE> <TAB> NS_DECL_NSIWEBGLBUFFER <NEW_LINE> protected :
<TAB> <TAB> . data <TAB> <TAB> = & kptr_restrict , <NEW_LINE> <TAB> <TAB> . maxlen <TAB> <TAB> = sizeof ( int ) , <NEW_LINE> <TAB> <TAB> . mode <TAB> <TAB> = 0644 , <NEW_LINE> <START_VULN> <TAB> <TAB> . proc_handler <TAB> = proc_dointvec_minmax , <NEW_LINE> <END_VULN> <TAB> <TAB> . extra1 <TAB> <TAB> = & zero , <NEW_LINE> <TAB> <TAB> . extra2 <TAB> <TAB> = & two , <NEW_LINE> <TAB> } ,
<TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; <NEW_LINE> <TAB> }
<TAB> NS_tchar callbackLongPath [ MAXPATHLEN ] ; <NEW_LINE> <TAB> ZeroMemory ( callbackLongPath , sizeof ( callbackLongPath ) ) ; <NEW_LINE> <TAB> NS_tchar * targetPath = argv [ callbackIndex ] ; <NEW_LINE> <START_VULN> <TAB> NS_tchar buffer [ MAXPATHLEN * 2 ] ; <NEW_LINE> <END_VULN> <TAB> if ( sReplaceRequest ) {
<TAB> - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , <NEW_LINE> <TAB> - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , <NEW_LINE> <TAB> - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 62 , - 1 , - 1 , - 1 , 63 , <NEW_LINE> <START_VULN> <TAB> 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , <NEW_LINE> <END_VULN> <TAB> - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , <NEW_LINE> <TAB> 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , - 1 , - 1 , - 1 , - 1 , - 1 , <NEW_LINE> <TAB> - 1 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 ,
MODULE_DESCRIPTION ( "Synchronous AES in CCM mode using ARMv8 Crypto Extensions" ) ; <NEW_LINE> MODULE_AUTHOR ( "Ard Biesheuvel < ard . biesheuvel@linaro . org > " ) ; <NEW_LINE> MODULE_LICENSE ( "GPL v2" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "ccm ( aes ) " ) ; <NEW_LINE> <END_VULN>
<TAB> * <NEW_LINE> SVGNumberList & InternalList ( ) const ; <NEW_LINE> <START_VULN> void EnsureItemAt ( uint32_t aIndex ) ; <NEW_LINE> <END_VULN> void MaybeInsertNullInAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> void MaybeRemoveItemFromAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> FallibleTArray < DOMSVGNumber * > mItems ;
<TAB> <TAB> switch ( verify_error ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> case X509_V_OK : <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> break ; <NEW_LINE> <END_VULN> <TAB> <TAB> case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY : <NEW_LINE> <TAB> <TAB> case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE : <NEW_LINE> <TAB> <TAB> case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT :
<TAB> port_number = edge_port -> port -> port_number ; <NEW_LINE> <START_VULN> <TAB> if ( edge_port -> lsr_event ) { <NEW_LINE> <END_VULN> <TAB> <TAB> edge_port -> lsr_event = 0 ; <NEW_LINE> <TAB> <TAB> dev_dbg ( dev , " % s == == = Port % u LSR Status = % 02x , Data = % 02x == == == \n" , <NEW_LINE> <TAB> <TAB> <TAB> __func__ , port_number , edge_port -> lsr_mask , * data ) ;
<TAB> . llseek <TAB> <TAB> = no_llseek , <NEW_LINE> <TAB> . read <TAB> <TAB> = new_sync_read , <NEW_LINE> <TAB> . read_iter <TAB> = pipe_read , <NEW_LINE> <START_VULN> <TAB> . write <TAB> <TAB> = do_sync_write , <NEW_LINE><TAB> . aio_write <TAB> = pipe_write , <NEW_LINE> <END_VULN> <TAB> . poll <TAB> <TAB> = pipe_poll , <NEW_LINE> <TAB> . unlocked_ioctl <TAB> = pipe_ioctl , <NEW_LINE> <TAB> . release <TAB> = pipe_release ,
<TAB> <TAB> va_start ( ap , files ) ; <NEW_LINE> <TAB> <TAB> while ( files != NULL ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> _cleanup_free_ char * path = strappend ( tmp_dir , files ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> assert_se ( touch_file ( path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) == 0 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> files = va_arg ( ap , const char * ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> va_end ( ap ) ;
<TAB> <TAB> } <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> if ( state -> space ) ruby_xfree ( state -> space ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> state -> space = strdup ( RSTRING_PTR ( space ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> state -> space_len = len ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return Qnil ;
<TAB> cl_allowDownload = Cvar_Get ( "cl_allowDownload" , "1" , CVAR_ARCHIVE ) ; <NEW_LINE> #ifdef USE_CURL_DLOPEN <NEW_LINE> <START_VULN> <TAB> cl_cURLLib = Cvar_Get ( "cl_cURLLib" , DEFAULT_CURL_LIB , CVAR_ARCHIVE ) ; <NEW_LINE> <END_VULN> #endif
<TAB> NULL , <NEW_LINE> #else <NEW_LINE> <TAB> iakerb_gss_export_sec_context , <NEW_LINE> <START_VULN> <TAB> NULL , <NEW_LINE> <END_VULN> #endif <NEW_LINE> <TAB> krb5_gss_inquire_cred_by_mech , <NEW_LINE> <TAB> krb5_gss_inquire_names_for_mech ,
<TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( hdr -> hdr . orig_len > WTAP_MAX_PACKET_SIZE ) { <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> * err = WTAP_ERR_BAD_FILE ; <NEW_LINE><TAB> <TAB> if ( err_info != NULL ) { <NEW_LINE><TAB> <TAB> <TAB> * err_info = g_strdup_printf ( "pcap : File has % u - byte packet , bigger than maximum of % u" , <NEW_LINE><TAB> <TAB> <TAB> hdr -> hdr . orig_len , WTAP_MAX_PACKET_SIZE ) ; <NEW_LINE><TAB> <TAB> } <NEW_LINE><TAB> <TAB> return - 1 ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return bytes_read ;
<TAB> if ( ret < 0 ) <NEW_LINE> <TAB> <TAB> hid_err ( hdev , "error setting GPIO values : % d\n" , ret ) ; <NEW_LINE> <START_VULN> <TAB> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int cp2112_gpio_get_all ( struct gpio_chip * chip )
MODULE_DESCRIPTION ( "Rijndael ( AES ) Cipher Algorithm , asm optimized" ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "aes" ) ; <NEW_LINE>MODULE_ALIAS ( "aes - asm" ) ; <NEW_LINE> <END_VULN>
void kvm_apic_write_nodecode ( struct kvm_vcpu * vcpu , u32 offset ) ; <NEW_LINE> void kvm_apic_set_eoi_accelerated ( struct kvm_vcpu * vcpu , int vector ) ; <NEW_LINE> <START_VULN> void kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr ) ; <NEW_LINE> <END_VULN> void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) ; <NEW_LINE> void kvm_lapic_sync_to_vapic ( struct kvm_vcpu * vcpu ) ;
<TAB> if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) ) <NEW_LINE> <START_VULN> <TAB> <TAB> * flags &= ~ FOLL_WRITE ; <NEW_LINE> <END_VULN> <TAB> return 0 ; <NEW_LINE> }
<TAB> if ( IsAnimValList ( ) ) { <NEW_LINE> <TAB> Element ( ) -> FlushAnimations ( ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return LengthNoFlush ( ) ; <NEW_LINE> } <NEW_LINE> void Clear ( ErrorResult & error ) ; <NEW_LINE> already_AddRefed < dom : : SVGTransform > Initialize ( dom : : SVGTransform & newItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> <START_VULN> dom : : SVGTransform * GetItem ( uint32_t index , ErrorResult & error ) <NEW_LINE> { <NEW_LINE><TAB> bool found ; <NEW_LINE><TAB> dom : : SVGTransform * item = IndexedGetter ( index , found , error ) ; <NEW_LINE><TAB> if ( ! found ) { <NEW_LINE><TAB> error . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; <NEW_LINE><TAB> } <NEW_LINE><TAB> return item ; <NEW_LINE> } <NEW_LINE>dom : : SVGTransform * IndexedGetter ( uint32_t index , bool & found , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> <END_VULN> already_AddRefed < dom : : SVGTransform > InsertItemBefore ( dom : : SVGTransform & newItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t index , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < dom : : SVGTransform > ReplaceItem ( dom : : SVGTransform & newItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t index , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < dom : : SVGTransform > RemoveItem ( uint32_t index , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & error ) ;
<TAB> if ( ! fp ) <NEW_LINE> <TAB> <TAB> return ; <NEW_LINE> <START_VULN> <TAB> fprintf ( certificate_store -> fp , " % s % s\n" , certificate_data -> hostname , certificate_data -> fingerprint ) ; <NEW_LINE> <END_VULN> <TAB> fclose ( fp ) ; <NEW_LINE> }
PRBool HasLoadFlag ( PRUint32 flag ) { <NEW_LINE> <TAB> return ( mLoadFlags & flag ) != 0 ; <NEW_LINE> } <NEW_LINE> PRBool IsPending ( ) const { <NEW_LINE> <START_VULN> <TAB> return ( mPump != nsnull ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void SetContentLength64 ( PRInt64 len ) ; <NEW_LINE> PRInt64 ContentLength64 ( ) ;
<TAB> if ( vsize && st [ NSV_ST_VIDEO ] ) { <NEW_LINE> <TAB> <TAB> nst = st [ NSV_ST_VIDEO ] -> priv_data ; <NEW_LINE> <TAB> <TAB> pkt = & nsv -> ahead [ NSV_ST_VIDEO ] ; <NEW_LINE> <START_VULN> <TAB> <TAB> av_get_packet ( pb , pkt , vsize ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ; <NEW_LINE> <TAB> <TAB> pkt -> dts = nst -> frame_offset ; <NEW_LINE> <TAB> <TAB> pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ;
MODULE_DESCRIPTION ( "CRC32c ( Castagnoli ) optimization using Intel Hardware . " ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "crc32c" ) ; <NEW_LINE>MODULE_ALIAS ( "crc32c - intel" ) ; <NEW_LINE> <END_VULN>
<TAB> for ( i = 0 ; i < 16 ; i + + ) { <NEW_LINE> <START_VULN> <TAB> <TAB> Packet * p = BuildTestPacket ( i , 0 , 1 , 'A' + i , 16 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( p == NULL ) <NEW_LINE> <TAB> <TAB> <TAB> goto end ;
<TAB> return cnt ; <NEW_LINE> } <NEW_LINE> <START_VULN> struct inet_peer * inet_getpeer ( struct inetpeer_addr * daddr , int create ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct inet_peer __rcu ** stack [ PEER_MAXDEPTH ] , ** * stackptr ; <NEW_LINE> <TAB> struct inet_peer_base * base = family_to_base ( daddr -> family ) ;
<TAB> if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) <NEW_LINE> <START_VULN> <TAB> <TAB> timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ; <NEW_LINE> <END_VULN> <TAB> remaining = kc -> timer_remaining ( timr , now ) ;
<TAB> c -> padded_bits = aligned_width - c -> avctx -> width ; <NEW_LINE> <TAB> if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) <NEW_LINE> <TAB> <TAB> return AVERROR_INVALIDDATA ; <NEW_LINE> <START_VULN> <TAB> if ( ! encoding && c -> palette_size && c -> bpp <= 8 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; <NEW_LINE> <TAB> } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { <NEW_LINE> <TAB> <TAB> if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) )
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint16_t prev_hdrextlen ) ; <NEW_LINE> static Packet * <NEW_LINE> <START_VULN> IPV6BuildTestPacket ( uint32_t id , uint16_t off , int mf , const char content , <NEW_LINE><TAB> int content_len ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> Packet * p = NULL ; <NEW_LINE> <TAB> uint8_t * pcontent ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : #ifdef jail to whip a few platforms into the UNIX ideal . <NEW_LINE> <START_VULN> last mod : $ Id : os_types . h 16649 2009 - 10 - 25 00 : 49 : 58Z ds $ <NEW_LINE> <END_VULN> #ifndef _OS_TYPES_H <NEW_LINE> #define _OS_TYPES_H <NEW_LINE> <TAB> different malloc than stdlib * / <NEW_LINE> #define _ogg_malloc malloc
MODULE_DESCRIPTION ( "Rijndael ( AES ) Cipher Algorithm , Intel AES - NI instructions optimized" ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "aes" ) ; <NEW_LINE> <END_VULN>
} <NEW_LINE> NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc ( nedpool * p , size_t no , size_t size ) THROWSPEC <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> unsigned flags = NEDMALLOC_FORCERESERVE ( p , 0 , no * size ) ; <NEW_LINE><TAB> return nedpmalloc2 ( p , size * no , 0 , M2_ZERO_MEMORY|flags ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedprealloc ( nedpool * p , void * mem , size_t size ) THROWSPEC <NEW_LINE> {
<TAB> <TAB> <TAB> if ( hdr -> substreamid == info -> num_ind_sub + 1 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> avpriv_request_sample ( track -> par , "Multiple independent substreams" ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> ret = AVERROR_PATCHWELCOME ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto end ; <NEW_LINE> <TAB> <TAB> <TAB> } else if ( hdr -> substreamid < info -> num_ind_sub ||
{ <NEW_LINE> public : <NEW_LINE> static JSBool GetCallingLocation ( JSContext * aContext , const char * * aFilename , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRUint32 * aLineno ) ; <NEW_LINE> <END_VULN> static jsval ConvertStringToJSVal ( const nsString & aProp , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSContext * aContext ) ;
<TAB> if ( s -> s3 -> tmp . message_type != SSL3_MT_CERTIFICATE_VERIFY ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> s -> s3 -> tmp . reuse_message = 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> al = SSL_AD_UNEXPECTED_MESSAGE ; <NEW_LINE> <TAB> <TAB> <TAB> SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_MISSING_VERIFY_MESSAGE ) ;
<START_VULN> if ( strchr ( page , ' / ' ) ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> http_response_set_status ( res , 404 , "Not Found" ) ; <NEW_LINE> <TAB> http_response_printf ( res , " < html > < body > 404 Not Found < / body > < / html > \n" ) ;
<TAB> <TAB> verdef -> vd_aux = READ32 ( dfs , j ) <NEW_LINE> <TAB> <TAB> verdef -> vd_next = READ32 ( dfs , j ) <NEW_LINE> <TAB> <TAB> int vdaux = verdef -> vd_aux ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> sdb_free ( sdb_verdef ) ; <NEW_LINE> <TAB> <TAB> <TAB> goto out_error ; <NEW_LINE> <TAB> <TAB> }
#define EHMER_OFFSET 16 <NEW_LINE> #define EHMER_MAX 56 <NEW_LINE> <START_VULN> static float tonemasks [ P_BANDS ] [ 6 ] [ EHMER_MAX ] = { <NEW_LINE> <END_VULN> { { - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , <NEW_LINE> <TAB> - 60 , - 60 , - 60 , - 60 , - 62 , - 62 , - 65 , - 73 , <NEW_LINE> <TAB> - 69 , - 68 , - 68 , - 67 , - 70 , - 70 , - 72 , - 74 , <NEW_LINE> <TAB> - 75 , - 79 , - 79 , - 80 , - 83 , - 88 , - 93 , - 100 , <NEW_LINE> <TAB> - 110 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , <NEW_LINE> <TAB> - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , <NEW_LINE> <TAB> - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 } ,
<START_VULN> #define AP4_VERSION 0x01050000 <NEW_LINE>#define AP4_VERSION_STRING "1 . 5 . 0 . 0" <NEW_LINE> <END_VULN> #endif
<TAB> ZEND_ARG_INFO ( 0 , pattern ) <NEW_LINE> <TAB> ZEND_ARG_INFO ( 0 , subject ) <NEW_LINE> <TAB> ZEND_ARG_INFO ( 0 , limit ) <NEW_LINE> <START_VULN> <TAB> ZEND_ARG_INFO ( 0 , flags ) <NEW_LINE> <END_VULN> ZEND_END_ARG_INFO ( ) <NEW_LINE> ZEND_BEGIN_ARG_INFO_EX ( arginfo_preg_quote , 0 , 0 , 1 )
void DestroyRows ( PRInt32 & aRowsToLose ) ; <NEW_LINE> void ReverseDestroyRows ( PRInt32 & aRowsToLose ) ; <NEW_LINE> nsIBox * GetFirstItemBox ( PRInt32 aOffset , PRBool * aCreated ) ; <NEW_LINE> nsIBox * GetNextItemBox ( nsIBox * aBox , PRInt32 aOffset , PRBool * aCreated ) ; <NEW_LINE> PRBool ContinueReflow ( nscoord height ) ; <NEW_LINE> NS_IMETHOD ListBoxAppendFrames ( nsFrameList & aFrameList ) ; <NEW_LINE> NS_IMETHOD ListBoxInsertFrames ( nsIFrame * aPrevFrame , nsFrameList & aFrameList ) ; <NEW_LINE> void OnContentInserted ( nsPresContext * aPresContext , nsIContent * aContent ) ; <NEW_LINE> <START_VULN> void OnContentRemoved ( nsPresContext * aPresContext , nsIFrame * aChildFrame , PRInt32 aIndex ) ; <NEW_LINE> <END_VULN> void GetListItemContentAt ( PRInt32 aIndex , nsIContent ** aContent ) ; <NEW_LINE> void GetListItemNextSibling ( nsIContent * aListItem , nsIContent ** aContent , PRInt32 & aSiblingIndex ) ; <NEW_LINE> void PostReflowCallback ( ) ; <NEW_LINE> PRBool SetBoxObject ( nsPIBoxObject * aBoxObject ) <NEW_LINE> {
<TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> case PHP_MODE_REFLECTION_EXT_INFO : <NEW_LINE> <TAB> <TAB> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> int len = ( int ) strlen ( reflection_what ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> char * lcname = zend_str_tolower_dup ( reflection_what , len ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> zend_module_entry * module ;
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> ptep_user = ( pt_element_t __user * ) ( ( void * ) host_addr + offset ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( unlikely ( copy_from_user ( & pte , ptep_user , sizeof ( pte ) ) ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> present = false ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> }
<TAB> } <NEW_LINE> } <NEW_LINE> <START_VULN> * state = CCS_VALUE ; <NEW_LINE> <END_VULN> * type = CCV_CLASS ; <NEW_LINE> return 0 ; <NEW_LINE> }
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject ** aRetval ) ; <NEW_LINE> nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> unsigned char * aData , uint32_t aDataLen , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> int32_t dirtyWidth , int32_t dirtyHeight ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Counter with CBC MAC" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "ccm_base" ) ; <NEW_LINE>MODULE_ALIAS ( "rfc4309" ) ; <NEW_LINE> <END_VULN>
<TAB> phar_flush ( entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> RETURN_TRUE ;
extern int utf8_to_utf32 ( const u8 * s , int len , unicode_t * pu ) ; <NEW_LINE> extern int utf32_to_utf8 ( unicode_t u , u8 * s , int maxlen ) ; <NEW_LINE> <START_VULN> extern int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) ; <NEW_LINE> <END_VULN> extern int utf16s_to_utf8s ( const wchar_t * pwcs , int len , <NEW_LINE> <TAB> <TAB> enum utf16_endian endian , u8 * s , int maxlen ) ;
<TAB> <TAB> for ( size_t i = 0 ; i < numBlocks_ ; i + + ) <NEW_LINE> <TAB> <TAB> <TAB> blocks_ [ i ] . destroy ( ) ; <NEW_LINE> <TAB> <TAB> js_free ( blocks_ ) ; <NEW_LINE> <TAB> <TAB> js_delete ( previous_ ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> bool init ( size_t numBlocks ) { <NEW_LINE> <TAB> <TAB> numBlocks_ = numBlocks ; <NEW_LINE> <START_VULN> <TAB> <TAB> blocks_ = ( IonBlockCounts * ) js_calloc ( numBlocks * sizeof ( IonBlockCounts ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return blocks_ != NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> size_t numBlocks ( ) const { <NEW_LINE> <TAB> <TAB> return numBlocks_ ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> IonBlockCounts & block ( size_t i ) {
<TAB> for ( i = 0 , l = 0 ; i < partvals ; l + + ) { <NEW_LINE> <TAB> <TAB> if ( s == 0 ) { <NEW_LINE> <TAB> <TAB> for ( j = 0 ; j < ch ; j + + ) { <NEW_LINE> <TAB> <TAB> <TAB> int temp = vorbis_book_decode ( look -> phrasebook , & vb -> opb ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( temp == - 1 ) goto eopbreak ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> partword [ j ] [ l ] = look -> decodemap [ temp ] ; <NEW_LINE> <TAB> <TAB> <TAB> if ( partword [ j ] [ l ] == NULL ) goto errout ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> for ( k = 0 ; k < partitions_per_word && i < partvals ; k + + , i + + ) <NEW_LINE> <TAB> <TAB> for ( j = 0 ; j < ch ; j + + ) {
<TAB> <TAB> <TAB> if ( inet_csk ( sk ) -> icsk_af_ops -> conn_request ( sk , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> skb ) < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> goto discard ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> if ( dh -> dccph_type == DCCP_PKT_RESET ) <NEW_LINE> <TAB> <TAB> <TAB> goto discard ;
<TAB> struct kvm_lapic_irq irq ; <NEW_LINE> <TAB> struct kvm_vcpu * vcpu ; <NEW_LINE> <TAB> struct vcpu_data vcpu_info ; <NEW_LINE> <START_VULN> <TAB> int idx , ret = - EINVAL ; <NEW_LINE> <END_VULN> <TAB> if ( ! kvm_arch_has_assigned_device ( kvm ) || <NEW_LINE> <TAB> <TAB> ! irq_remapping_cap ( IRQ_POSTING_CAP ) ||
<TAB> <TAB> free ( devices ) ; <NEW_LINE> <TAB> <TAB> devices = NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> return 1 ; <NEW_LINE> <END_VULN> }
struct TypedArrayObjectStorage : AllTypedArraysBase { <NEW_LINE> protected : <NEW_LINE> JSObject * mObj ; <NEW_LINE> <START_VULN> TypedArrayObjectStorage ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> TypedArrayObjectStorage ( TypedArrayObjectStorage && aOther ) <NEW_LINE> <TAB> : mObj ( aOther . mObj ) <NEW_LINE> { <NEW_LINE> <TAB> aOther . mObj = nullptr ; <NEW_LINE> }
<TAB> <TAB> keywords [ 3 ] = "password" ; <NEW_LINE> <TAB> <TAB> values [ 3 ] = password ; <NEW_LINE> <TAB> <TAB> keywords [ 4 ] = "dbname" ; <NEW_LINE> <START_VULN> <TAB> <TAB> values [ 4 ] = newdb ; <NEW_LINE> <END_VULN> <TAB> <TAB> keywords [ 5 ] = "fallback_application_name" ; <NEW_LINE> <TAB> <TAB> values [ 5 ] = progname ; <NEW_LINE> <TAB> <TAB> keywords [ 6 ] = NULL ;
<TAB> int bytes_written = 0 ; <NEW_LINE> <TAB> register int i ; <NEW_LINE> <TAB> register guint8 * s_ptr , * m_ptr ; <NEW_LINE> <START_VULN> <TAB> gint16 msdu_length , actual_octets ; <NEW_LINE> <END_VULN> <TAB> guint8 flow_seq ; <NEW_LINE> <TAB> guint64 s_time = LL_ZERO , e_time = LL_ZERO ;
{ <NEW_LINE> <TAB> const struct x86_emulate_ops * ops = ctxt -> ops ; <NEW_LINE> <TAB> struct desc_struct cs , ss ; <NEW_LINE> <START_VULN> <TAB> u64 msr_data ; <NEW_LINE> <END_VULN> <TAB> int usermode ; <NEW_LINE> <TAB> u16 cs_sel = 0 , ss_sel = 0 ;
<TAB> void init ( JSContext * cx ) ; <NEW_LINE> <TAB> ~ TypeCompartment ( ) ; <NEW_LINE> <TAB> inline JSCompartment * compartment ( ) ; <NEW_LINE> <TAB> inline void addPending ( JSContext * cx , TypeConstraint * constraint , TypeSet * source , Type type ) ; <NEW_LINE> <START_VULN> <TAB> void growPendingArray ( JSContext * cx ) ; <NEW_LINE> <END_VULN> <TAB> inline void resolvePending ( JSContext * cx ) ; <NEW_LINE> <TAB> void print ( JSContext * cx , bool force ) ;
<TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> * delim = '\0' ; <NEW_LINE> <START_VULN> <TAB> <TAB> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> mutt_buffer_addstr ( buf , term ) ; <NEW_LINE> <TAB> <TAB> mutt_buffer_addch ( buf , ' ' ) ;
extern void _vp_remove_floor ( vorbis_look_psy * p , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> float * mdct , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> int * icodedflr , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> float * residue , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> int sliding_lowpass ) ; <NEW_LINE> extern void _vp_noisemask ( vorbis_look_psy * p , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> float * logmdct , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> float * logmask ) ; <NEW_LINE> extern void _vp_tonemask ( vorbis_look_psy * p , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> float * logfft , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> float * logmask , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> float global_specmax , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> float local_specmax ) ;
<TAB> unsigned char * p ; <NEW_LINE> <TAB> size_t l ; <NEW_LINE> <TAB> int r ; <NEW_LINE> <START_VULN> <TAB> int ffmax , parent_len ; <NEW_LINE> <END_VULN> <TAB> static const struct archive_rb_tree_ops rb_ops = { <NEW_LINE> <TAB> <TAB> isoent_cmp_node_joliet , isoent_cmp_key_joliet <NEW_LINE> <TAB> } ;
<TAB> count + + ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> loser : <NEW_LINE> <TAB> if ( nickname ) { <NEW_LINE> <TAB> PORT_Free ( nickname ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> nickname = "" ; <NEW_LINE> <END_VULN> done : <NEW_LINE> <TAB> if ( firstname ) { <NEW_LINE> <TAB> PORT_Free ( firstname ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( org ) { <NEW_LINE> <TAB> PORT_Free ( org ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> goto fail ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <NEW_LINE> <END_VULN>
<TAB> sigAndHash . hashAlg = SEC_OID_UNKNOWN ; <NEW_LINE> <TAB> SSL_TRC ( 3 , ( " % d : SSL3 [ % d ] : handle server_key_exchange handshake" , <NEW_LINE> <TAB> <TAB> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> <START_VULN> <TAB> if ( ss -> ssl3 . hs . ws != wait_server_key && <NEW_LINE><TAB> ss -> ssl3 . hs . ws != wait_server_cert ) { <NEW_LINE><TAB> errCode = SSL_ERROR_RX_UNEXPECTED_SERVER_KEY_EXCH ; <NEW_LINE><TAB> desc = unexpected_message ; <NEW_LINE><TAB> goto alert_loser ; <NEW_LINE><TAB> } <NEW_LINE><TAB> if ( ss -> sec . peerCert == NULL ) { <NEW_LINE><TAB> errCode = SSL_ERROR_RX_UNEXPECTED_SERVER_KEY_EXCH ; <NEW_LINE><TAB> desc = unexpected_message ; <NEW_LINE><TAB> goto alert_loser ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> isTLS = ( PRBool ) ( ss -> ssl3 . prSpec -> version > SSL_LIBRARY_VERSION_3_0 ) ; <NEW_LINE> <TAB> isTLS12 = ( PRBool ) ( ss -> ssl3 . prSpec -> version >= SSL_LIBRARY_VERSION_TLS_1_2 ) ; <NEW_LINE> <TAB> switch ( ss -> ssl3 . hs . kea_def -> exchKeyType ) { <NEW_LINE> <TAB> case kt_rsa : {
struct TypedArrayObjectStorage : AllTypedArraysBase { <NEW_LINE> protected : <NEW_LINE> JSObject * mObj ; <NEW_LINE> <START_VULN> TypedArrayObjectStorage ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> public : <NEW_LINE> inline void TraceSelf ( JSTracer * trc ) <NEW_LINE> { <NEW_LINE> <TAB> if ( mObj ) { <NEW_LINE> <TAB> JS_CallObjectTracer ( trc , & mObj , "TypedArray . mObj" ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : PCM data envelope analysis <NEW_LINE> <START_VULN> last mod : $ Id : envelope . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h >
<TAB> if ( halfoc < 0 ) halfoc = 0 ; <NEW_LINE> <TAB> if ( halfoc >= P_BANDS - 1 ) halfoc = P_BANDS - 1 ; <NEW_LINE> <TAB> inthalfoc = ( int ) halfoc ; <NEW_LINE> <TAB> del = halfoc - inthalfoc ; <NEW_LINE> <TAB> for ( j = 0 ; j < P_NOISECURVES ; j + + ) <NEW_LINE> <TAB> p -> noiseoffset [ j ] [ i ] = <NEW_LINE> <START_VULN> <TAB> p -> vi -> noiseoff [ j ] [ inthalfoc ] * ( 1 . - del ) + <NEW_LINE><TAB> p -> vi -> noiseoff [ j ] [ inthalfoc + 1 ] * del ; <NEW_LINE> <END_VULN> } <NEW_LINE> #if 0 <NEW_LINE> { <NEW_LINE> <TAB> static int ls = 0 ; <NEW_LINE> <TAB> _analysis_output_always ( "noiseoff0" , ls , p -> noiseoffset [ 0 ] , n , 1 , 0 , 0 ) ; <NEW_LINE> <TAB> _analysis_output_always ( "noiseoff1" , ls , p -> noiseoffset [ 1 ] , n , 1 , 0 , 0 ) ; <NEW_LINE> <TAB> _analysis_output_always ( "noiseoff2" , ls + + , p -> noiseoffset [ 2 ] , n , 1 , 0 , 0 ) ;
<TAB> <TAB> unsigned char cmd = * delta + + ; <NEW_LINE> <TAB> <TAB> if ( cmd & 0x80 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> size_t off = 0 , len = 0 ; <NEW_LINE> <END_VULN> #define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) * delta + + << shift ) ; else goto fail ; } <NEW_LINE> <TAB> <TAB> <TAB> if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ;
<TAB> rkeylen = strlen ( rkey ) ; <NEW_LINE> <START_VULN> <TAB> if ( nad_find_attr ( nad , 0 , - 1 , "type" , "valid" ) >= 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> log_write ( out -> s2s -> log , LOG_NOTICE , " [ % d ] [ % s , port = % d ] outgoing route ' % s' is now valid % s % s" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? " , TLS negotiated" : "" , out -> s -> compressed ? " , ZLIB compression enabled" : "" ) ; <NEW_LINE> <TAB> <TAB> xhash_put ( out -> states , pstrdup ( xhash_pool ( out -> states ) , rkey ) , ( void * ) conn_VALID ) ;
virtual mozilla : : dom : : EventTarget * GetParentTarget ( ) MOZ_OVERRIDE { return mParent ; } <NEW_LINE> virtual nsIDOMWindow * GetOwnerGlobal ( ) MOZ_OVERRIDE ; <NEW_LINE> NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS ( nsWindowRoot , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIDOMEventTarget ) <NEW_LINE> protected : <NEW_LINE> <START_VULN> nsPIDOMWindow * mWindow ; <NEW_LINE> <END_VULN> nsRefPtr < nsEventListenerManager > mListenerManager ; <NEW_LINE> nsCOMPtr < nsIDOMNode > mPopupNode ; <NEW_LINE> nsCOMPtr < mozilla : : dom : : EventTarget > mParent ; <NEW_LINE> } ;
<TAB> <TAB> io -> flag = 0 ; <NEW_LINE> <TAB> <TAB> io -> offset = 0 ; <NEW_LINE> <TAB> <TAB> io -> size = 0 ; <NEW_LINE> <START_VULN> <TAB> <TAB> io -> error = 0 ; <NEW_LINE> <END_VULN> <TAB> <TAB> INIT_WORK ( & io -> work , ext4_end_io_work ) ; <NEW_LINE> <TAB> <TAB> INIT_LIST_HEAD ( & io -> list ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> if ( tk -> p_subpackets [ j ] ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> block_Release ( tk -> p_subpackets [ j ] ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> if ( tk -> i_subpackets ) <NEW_LINE><TAB> <TAB> { <NEW_LINE><TAB> <TAB> <TAB> free ( tk -> p_subpackets ) ; <NEW_LINE><TAB> <TAB> <TAB> free ( tk -> p_subpackets_timecode ) ; <NEW_LINE><TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> <TAB> if ( tk -> p_sipr_packet ) <NEW_LINE> <TAB> <TAB> <TAB> block_Release ( tk -> p_sipr_packet ) ; <NEW_LINE> <TAB> <TAB> free ( tk ) ;
<TAB> } <NEW_LINE> out_unlock : <NEW_LINE> <START_VULN> <TAB> sem_unlock ( sma ) ; <NEW_LINE> <END_VULN> out_up : <NEW_LINE> <TAB> up_write ( & sem_ids ( ns ) . rw_mutex ) ; <NEW_LINE> <TAB> return err ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Serpent Cipher Algorithm , AVX2 optimized" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "serpent" ) ; <NEW_LINE>MODULE_ALIAS ( "serpent - asm" ) ; <NEW_LINE> <END_VULN>
mutt_message ( _ ( "Logging in . . . " ) ) ; <NEW_LINE> <START_VULN> imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ; <NEW_LINE>imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ; <NEW_LINE> <END_VULN>
<TAB> if ( shlen == 0 ) <NEW_LINE> <TAB> <TAB> shlen = 1 ; <TAB> <NEW_LINE> <TAB> if ( strncmp ( p , at , shlen ) != 0 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> sprintf ( grump , "matched null at ` % . 20s'" , p ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return ( grump ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return ( NULL ) ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 113 2014 / 12 / 11 14 : 10 : 53 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef BUILTIN_ELF
<TAB> union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; <NEW_LINE> <TAB> char <TAB> line [ TOSHIBA_LINE_LENGTH ] ; <NEW_LINE> <TAB> int <TAB> num_items_scanned ; <NEW_LINE> <START_VULN> <TAB> int <TAB> pkt_len , pktnum , hr , min , sec , csec ; <NEW_LINE> <END_VULN> <TAB> char <TAB> channel [ 10 ] , direction [ 10 ] ; <NEW_LINE> <TAB> int <TAB> i , hex_lines ; <NEW_LINE> <TAB> guint8 <TAB> * pd ;
<TAB> size_t estimate = ( 4 * l ) + 3 ; <NEW_LINE> <START_VULN> <TAB> cmd = zend_string_alloc ( 4 * l + 2 , 0 ) ; <NEW_LINE> <END_VULN> #ifdef PHP_WIN32 <NEW_LINE> <TAB> ZSTR_VAL ( cmd ) [ y + + ] = '"' ;
#endif <NEW_LINE> CWD_API void realpath_cache_clean ( void ) ; <NEW_LINE> <START_VULN> CWD_API void realpath_cache_del ( const char * path , int path_len ) ; <NEW_LINE>CWD_API realpath_cache_bucket * realpath_cache_lookup ( const char * path , int path_len , time_t t ) ; <NEW_LINE> <END_VULN> CWD_API zend_long realpath_cache_size ( void ) ; <NEW_LINE> CWD_API zend_long realpath_cache_max_buckets ( void ) ; <NEW_LINE> CWD_API realpath_cache_bucket ** realpath_cache_get_buckets ( void ) ;
<TAB> <TAB> return NULL ; <NEW_LINE> <TAB> mutex_lock ( & mut ) ; <NEW_LINE> <START_VULN> <TAB> mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ; <NEW_LINE> <END_VULN> <TAB> mutex_unlock ( & mut ) ; <NEW_LINE> <TAB> if ( mc -> id < 0 ) <NEW_LINE> <TAB> <TAB> goto error ;
<TAB> oggpack_write ( opb , ci -> mode_param [ i ] -> transformtype , 16 ) ; <NEW_LINE> <TAB> oggpack_write ( opb , ci -> mode_param [ i ] -> mapping , 8 ) ; <NEW_LINE> } <NEW_LINE> oggpack_write ( opb , 1 , 1 ) ; <NEW_LINE> return ( 0 ) ; <NEW_LINE> err_out : <NEW_LINE> return ( - 1 ) ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> int vorbis_commentheader_out ( vorbis_comment * vc , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ogg_packet * op ) { <NEW_LINE> oggpack_buffer opb ; <NEW_LINE> oggpack_writeinit ( & opb ) ; <NEW_LINE> if ( _vorbis_pack_comment ( & opb , vc ) ) return OV_EIMPL ;
<TAB> Com_Printf ( " -- -- - Initializing Renderer -- -- \n" ) ; <NEW_LINE> #ifdef USE_RENDERER_DLOPEN <NEW_LINE> <START_VULN> <TAB> cl_renderer = Cvar_Get ( "cl_renderer" , "opengl1" , CVAR_ARCHIVE | CVAR_LATCH ) ; <NEW_LINE> <END_VULN> <TAB> Com_sprintf ( dllName , sizeof ( dllName ) , "renderer_sp_ % s_" ARCH_STRING DLL_EXT , cl_renderer -> string ) ;
<TAB> <TAB> <TAB> <TAB> int length ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> DEBUG_MSG ( "\tDissector_postgresql RESPONSE type is clear - text ! " ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> GET_ULONG_BE ( length , ptr , 1 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> strncpy ( ( char * ) conn_status -> password , ( char * ) ( ptr + 5 ) , length - 4 ) ; <NEW_LINE><TAB> <TAB> <TAB> conn_status -> password [ length - 4 ] = 0 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> DISSECT_MSG ( "PostgreSQL credentials : % s - % d : % s : % s\n" , ip_addr_ntoa ( & PACKET -> L3 . dst , tmp ) , ntohs ( PACKET -> L4 . dst ) , conn_status -> user , conn_status -> password ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> dissect_wipe_session ( PACKET , DISSECT_CODE ( dissector_postgresql ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> commit e3abe7d7585ecc420a7cab73313216613aadad5a <NEW_LINE> Author : NickSampanis < nicksampanis@gmail . com > <NEW_LINE> Date : Wed Sep 3 13 : 59 : 51 2014 + 0300 <NEW_LINE> <TAB> Fixed heap overflow caused by length
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "MD4 Message Digest Algorithm" ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
<TAB> { STATE_MAIN_R0 , STATE_MAIN_R1 , <NEW_LINE> <TAB> SMF_ALL_AUTH | SMF_REPLY , <NEW_LINE> <TAB> P ( SA ) , P ( VID ) | P ( CR ) , PT ( NONE ) , <NEW_LINE> <START_VULN> <TAB> EVENT_v1_RETRANSMIT , main_inI1_outR1 } , <NEW_LINE> <END_VULN>
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> sizeof ( _eth ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> data , hlen , & _eth ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ! eth ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> proto = eth -> h_proto ; <NEW_LINE> <TAB> <TAB> <TAB> nhoff += sizeof ( * eth ) ; <NEW_LINE> <TAB> <TAB> }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : lookup based functions <NEW_LINE> <START_VULN> last mod : $ Id : lookup . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < math . h > <NEW_LINE> #include "lookup . h" <NEW_LINE> #include "lookup_data . h" <NEW_LINE> #include "os . h" <NEW_LINE> #include "misc . h"
<TAB> <TAB> <TAB> <TAB> u16 selector , int seg ) <NEW_LINE> { <NEW_LINE> <TAB> u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; <NEW_LINE> <START_VULN> <TAB> return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void write_register_operand ( struct operand * op )
<TAB> <TAB> <TAB> <TAB> cli_dbgmsg ( "messageFindArgument : no ' = ' sign found in MIME header ' % s' ( % s ) \n" , variable , messageGetArgument ( m , i ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( ( * + + ptr == '"' ) && ( strchr ( & ptr [ 1 ] , '"' ) != NULL ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> char * ret = cli_strdup ( + + ptr ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> char * p ;
<TAB> <TAB> <TAB> <TAB> unsigned long * nr_segs , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> size_t * len , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> struct iovec ** iovec , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> bool compat ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> ssize_t ret ;
<TAB> if ( ! arp_checkentry ( & e -> arp ) ) <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <START_VULN> <TAB> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <NEW_LINE> <END_VULN> <TAB> if ( err ) <NEW_LINE> <TAB> <TAB> return err ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> xtmp = sk_X509_pop ( ctx -> chain ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> X509_free ( xtmp ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> num -- ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ctx -> last_untrusted -- ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> retry = 1 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
#endif <NEW_LINE> <START_VULN> void <NEW_LINE>mono_reflection_destroy_dynamic_method ( MonoReflectionDynamicMethod * mb ) <NEW_LINE> { <NEW_LINE><TAB> g_assert ( mb ) ; <NEW_LINE><NEW_LINE><TAB> if ( mb -> mhandle ) <NEW_LINE><TAB> <TAB> mono_runtime_free_method ( <NEW_LINE><TAB> <TAB> <TAB> mono_object_get_domain ( ( MonoObject * ) mb ) , mb -> mhandle ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> }
<TAB> return intpart ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void <NEW_LINE> <END_VULN> fmtfp ( char ** sbuffer , <NEW_LINE> <TAB> char ** buffer , <NEW_LINE> <TAB> size_t * currlen ,
<TAB> <TAB> <TAB> <TAB> switch ( intern -> type ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> case SPL_FS_DIR : <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> test = spl_filesystem_object_get_path ( intern , NULL ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> fname_len = ( php_stat_len ) spprintf ( & fname , 0 , " % s % c % s" , test , DEFAULT_SLASH , intern -> u . dir . entry . d_name ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> php_stat ( fname , fname_len , FS_IS_DIR , & dummy ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> if ( Z_TYPE ( dummy ) == IS_TRUE ) {
<TAB> <TAB> <TAB> <TAB> return AVERROR_INVALIDDATA ; <NEW_LINE> <TAB> <TAB> <TAB> frame += v ; <NEW_LINE> <TAB> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( frame_end - frame < width + 3 ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> return AVERROR_INVALIDDATA ; <NEW_LINE> <TAB> <TAB> <TAB> frame [ 0 ] = frame [ 1 ] = <NEW_LINE> <TAB> <TAB> <TAB> frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA - 224 and SHA - 256 Secure Hash Algorithm , sparc64 sha256 opcode accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha224" ) ; <NEW_LINE>MODULE_ALIAS ( "sha256" ) ; <NEW_LINE> <END_VULN> #include "crop_devid . c"
<TAB> <TAB> <TAB> <TAB> <TAB> unsigned long end , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> long adjust_next ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( ! vma -> anon_vma || vma -> vm_ops || vma -> vm_file ) <NEW_LINE> <END_VULN> <TAB> <TAB> return ; <NEW_LINE> <TAB> __vma_adjust_trans_huge ( vma , start , end , adjust_next ) ; <NEW_LINE> }
struct mspack_system * sys ; <NEW_LINE> if ( lzx ) { <NEW_LINE> <TAB> sys = lzx -> sys ; <NEW_LINE> <START_VULN> <TAB> sys -> free ( lzx -> inbuf ) ; <NEW_LINE><TAB> sys -> free ( lzx -> window ) ; <NEW_LINE> <END_VULN> <TAB> sys -> free ( lzx ) ; <NEW_LINE> } <NEW_LINE> }
<TAB> pr_info ( " % s\n" , spectre_v2_strings [ mode ] ) ; <NEW_LINE> <START_VULN> <TAB> if ( ( ! boot_cpu_has ( X86_FEATURE_PTI ) && <NEW_LINE><TAB> ! boot_cpu_has ( X86_FEATURE_SMEP ) ) || is_skylake_era ( ) ) { <NEW_LINE><TAB> <TAB> setup_force_cpu_cap ( X86_FEATURE_RSB_CTXSW ) ; <NEW_LINE><TAB> <TAB> pr_info ( "Spectre v2 mitigation : Filling RSB on context switch\n" ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> if ( boot_cpu_has ( X86_FEATURE_IBPB ) ) {
<TAB> <TAB> char __ptype [ 5 ] ; \ <NEW_LINE> <TAB> <TAB> strcpy ( __ptype , gf_4cc_to_str ( __parent -> type ) ) ; \ <NEW_LINE> <TAB> <TAB> GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( " [ iso file ] extra box % s found in % s , deleting\n" , gf_4cc_to_str ( __abox -> type ) , __ptype ) ) ; \ <NEW_LINE> <START_VULN> <TAB> <TAB> gf_isom_box_del ( a ) ; \ <NEW_LINE> <END_VULN> <TAB> <TAB> return GF_OK ; \ <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> mtu ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> int hns_nic_net_xmit_hw ( struct net_device * ndev , <NEW_LINE><TAB> <TAB> <TAB> struct sk_buff * skb , <NEW_LINE><TAB> <TAB> <TAB> struct hns_nic_ring_data * ring_data ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct hns_nic_priv * priv = netdev_priv ( ndev ) ; <NEW_LINE> <TAB> struct hnae_ring * ring = ring_data -> ring ;
#ifndef imgStatusTracker_h__ <NEW_LINE> #define imgStatusTracker_h__ <NEW_LINE> class imgDecoderObserver ; <NEW_LINE> class imgIContainer ; <NEW_LINE> <START_VULN> class imgRequestProxy ; <NEW_LINE> <END_VULN> class imgStatusNotifyRunnable ; <NEW_LINE> class imgRequestNotifyRunnable ; <NEW_LINE> class imgStatusTrackerObserver ; <NEW_LINE> class imgStatusTrackerNotifyingObserver ; <NEW_LINE> class nsIRunnable ; <NEW_LINE> #include "mozilla / RefPtr . h" <NEW_LINE> #include "nsCOMPtr . h" <NEW_LINE> #include "nsTObserverArray . h" <NEW_LINE> #include "nsRect . h" <NEW_LINE> namespace mozilla { <NEW_LINE> namespace image { <NEW_LINE> class Image ; <NEW_LINE> struct ImageStatusDiff <NEW_LINE> {
namespace XrayUtils { <NEW_LINE> extern JSClass HolderClass ; <NEW_LINE> bool CloneExpandoChain ( JSContext * cx , JSObject * src , JSObject * dst ) ; <NEW_LINE> bool <NEW_LINE> <START_VULN> IsTransparent ( JSContext * cx , JSObject * wrapper ) ; <NEW_LINE> <END_VULN> JSObject * <NEW_LINE> GetNativePropertiesObject ( JSContext * cx , JSObject * wrapper ) ; <NEW_LINE> } <NEW_LINE> class XrayTraits ; <NEW_LINE> class XPCWrappedNativeXrayTraits ;
#ifndef imgStatusTracker_h__ <NEW_LINE> #define imgStatusTracker_h__ <NEW_LINE> class imgDecoderObserver ; <NEW_LINE> class imgIContainer ; <NEW_LINE> <START_VULN> class imgRequestProxy ; <NEW_LINE> <END_VULN> class imgStatusNotifyRunnable ; <NEW_LINE> class imgRequestNotifyRunnable ; <NEW_LINE> class imgStatusTrackerObserver ; <NEW_LINE> class nsIRunnable ; <NEW_LINE> #include "mozilla / RefPtr . h" <NEW_LINE> #include "mozilla / WeakPtr . h" <NEW_LINE> #include "nsCOMPtr . h" <NEW_LINE> #include "nsTObserverArray . h" <NEW_LINE> #include "nsThreadUtils . h" <NEW_LINE> #include "nsRect . h" <NEW_LINE> namespace mozilla { <NEW_LINE> namespace image { <NEW_LINE> class Image ; <NEW_LINE> struct ImageStatusDiff <NEW_LINE> {
<TAB> int err ; <NEW_LINE> <TAB> if ( level != SOL_PPPOL2TP ) <NEW_LINE> <START_VULN> <TAB> <TAB> return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ; <NEW_LINE> <END_VULN> <TAB> if ( optlen < sizeof ( int ) ) <NEW_LINE> <TAB> <TAB> return - EINVAL ;
<TAB> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> for ( i = 0 ; i < sec -> size ; i += 8 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> ut64 addr64 = r_read_le64 ( buf + i ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> if ( addr64 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ;
if ( compact_pixels == ( unsigned char * ) NULL ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , <NEW_LINE> <START_VULN> <TAB> <TAB> ResourceLimitError , "MemoryAllocationFailed" , "` % s'" , <NEW_LINE><TAB> <TAB> image -> filename ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> return ( compact_pixels ) ; <NEW_LINE> }
module_init ( ipip_init ) ; <NEW_LINE> module_exit ( ipip_fini ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "tunl0" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> timer -> it . cpu . expires += incr ; <NEW_LINE> <START_VULN> <TAB> <TAB> timer -> it_overrun += 1 << i ; <NEW_LINE> <END_VULN> <TAB> <TAB> delta -= incr ; <NEW_LINE> <TAB> } <NEW_LINE> }
} <NEW_LINE> static void <NEW_LINE> <START_VULN> build_config ( char * prefix , struct server * server ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> char * path = NULL ; <NEW_LINE> <TAB> int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;
<TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> <TAB> mutt_buffer_addstr ( buf , "X - GM - RAW " ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> mutt_buffer_addstr ( buf , term ) ; <NEW_LINE> <TAB> <TAB> break ; <NEW_LINE> <TAB> }
<TAB> <TAB> ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; <NEW_LINE> <TAB> <TAB> if ( ret == 0 ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <NEW_LINE> <END_VULN> #ifdef USE_HCACHE <NEW_LINE> <TAB> <TAB> mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; <NEW_LINE> #endif <NEW_LINE> commit 9bfab35522301794483f8f9ed60820bdec9be59e <NEW_LINE> Author : Richard Russon < rich@flatcap . org > <NEW_LINE> Date : Thu Jul 5 13 : 32 : 17 2018 + 0100 <NEW_LINE> <TAB> sanitise cache paths <NEW_LINE> <TAB> Co - authored - by : JerikoOne < jeriko . one@gmx . us >
friend class FileManager ; <NEW_LINE> public : <NEW_LINE> FileInfo ( FileManager * aFileManager ) <NEW_LINE> : mFileManager ( aFileManager ) <NEW_LINE> { } <NEW_LINE> virtual ~ FileInfo ( ) <NEW_LINE> <START_VULN> { <NEW_LINE>#ifdef DEBUG <NEW_LINE><TAB> NS_ASSERTION ( NS_IsMainThread ( ) , "File info destroyed on wrong thread ! " ) ; <NEW_LINE>#endif <NEW_LINE> } <NEW_LINE> <END_VULN> static <NEW_LINE> FileInfo * Create ( FileManager * aFileManager , int64_t aId ) ; <NEW_LINE> void AddRef ( ) <NEW_LINE> { <NEW_LINE> <TAB> if ( IndexedDatabaseManager : : IsClosed ( ) ) { <NEW_LINE> <TAB> NS_AtomicIncrementRefcnt ( mRefCnt ) ;
<TAB> if ( page == NULL ) <NEW_LINE> <TAB> page = http_request_get_query_string ( req ) ; <NEW_LINE> <START_VULN> <TAB> if ( page && ( access ( page , R_OK ) == 0 ) ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> http_response_printf ( res , "success" ) ; <NEW_LINE> <TAB> http_response_send ( res ) ;
static int mem_read ( jas_stream_obj_t * obj , char * buf , int cnt ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> int n ; <NEW_LINE> <END_VULN> <TAB> assert ( cnt >= 0 ) ; <NEW_LINE> <TAB> assert ( buf ) ;
snprintf_func ( recmd , TESTBUFSIZE , <NEW_LINE> <TAB> " % s recode % s - f % s % s % s % s % s" , program_name , test_softcfg_str , <NEW_LINE> <TAB> recoded_adler32 ? "" : " - n " , <NEW_LINE> <START_VULN> <TAB> ! change_apphead ? "" : <NEW_LINE> <END_VULN> <TAB> ( recoded_apphead ? " - A = recode_apphead " : " - A = " ) , <NEW_LINE> <TAB> recoded_secondary ? " - S djw " : " - S none " , <NEW_LINE> <TAB> TEST_DELTA_FILE ,
<TAB> <TAB> return script ; <NEW_LINE> <TAB> } <NEW_LINE> #endif <NEW_LINE> <TAB> JSScript * script = fp -> script ( ) ; <NEW_LINE> <TAB> if ( script -> compartment ( ) != cx_ -> compartment ) <NEW_LINE> <TAB> <TAB> return NULL ; <NEW_LINE> <START_VULN> <TAB> if ( ppc ) <NEW_LINE><TAB> <TAB> * ppc = fp -> pcQuadratic ( * this ) ; <NEW_LINE> <END_VULN> <TAB> return script ; <NEW_LINE> } <NEW_LINE> inline JSObject * <NEW_LINE> ContextStack : : currentScriptedScopeChain ( ) const <NEW_LINE> { <NEW_LINE> <TAB> return & fp ( ) -> scopeChain ( ) ; <NEW_LINE> }
<TAB> <TAB> if ( civ -> request && ( civ -> proc == 1 ) ) { <NEW_LINE> <TAB> <TAB> <TAB> const gchar * host ; <NEW_LINE> <TAB> <TAB> <TAB> unsigned char * name ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> int len ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> unsigned char * ptr ; <NEW_LINE> <TAB> <TAB> <TAB> host = ip_to_str ( pinfo -> dst . data ) ;
<TAB> . release <TAB> = ext4_release_file , <NEW_LINE> <TAB> . fsync <TAB> <TAB> = ext4_sync_file , <NEW_LINE> <TAB> . splice_read <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> <TAB> . fallocate <TAB> = ext4_fallocate , <NEW_LINE> } ;
<TAB> next : <NEW_LINE> <TAB> <TAB> if ( p -> key_frame || golden_frame ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ) ; <NEW_LINE> <TAB> <TAB> <TAB> s -> framep [ VP56_FRAME_GOLDEN ] = p ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIAtom * aAttribute , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRInt32 aModType ) ; <NEW_LINE> nsresult GetText ( nsString & aText ) ; <NEW_LINE> NS_DECL_QUERYFRAME <NEW_LINE> public : <NEW_LINE> <START_VULN> void FireOnInput ( ) ; <NEW_LINE> <END_VULN> void SetValueChanged ( PRBool aValueChanged ) ; <NEW_LINE> nsresult InitFocusedValue ( ) ; <NEW_LINE> void SetFireChangeEventState ( PRBool aNewState ) <NEW_LINE> { <NEW_LINE> <TAB> mFireChangeEventState = aNewState ; <NEW_LINE> }
<TAB> SimpleStringList tableNames ; <NEW_LINE> <TAB> int <TAB> <TAB> <TAB> useDB ; <NEW_LINE> <START_VULN> <TAB> char <TAB> * dbname ; <NEW_LINE> <END_VULN> <TAB> char <TAB> * pgport ; <NEW_LINE> <TAB> char <TAB> * pghost ; <NEW_LINE> <TAB> char <TAB> * username ;
<TAB> else <NEW_LINE> <TAB> <TAB> ffmax = 128 ; <NEW_LINE> <START_VULN> <TAB> r = idr_start ( a , idr , isoent -> children . cnt , ffmax , 6 , 2 , & rb_ops ) ; <NEW_LINE> <END_VULN> <TAB> if ( r < 0 ) <NEW_LINE> <TAB> <TAB> return ( r ) ;
nsCOMPtr < nsPIDOMEventTarget > mChromeEventHandler ; <NEW_LINE> nsCOMPtr < nsIDOMDocument > mDocument ; <NEW_LINE> <START_VULN> nsIDOMElement * mFrameElement ; <NEW_LINE> <END_VULN> nsIDocShell * mDocShell ; <NEW_LINE> PRUint32 mModalStateDepth ; <NEW_LINE> nsTimeout * mRunningTimeout ; <NEW_LINE> PRUint32 mMutationBits ;
<TAB> r_buf_write_at ( buf , addr_to_patch , ( void * ) val , sizeof ( val ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int search_old_relocation ( struct reloc_struct_t * reloc_table , ut32 addr_to_patch , int n_reloc ) { <NEW_LINE> <END_VULN> <TAB> int i ; <NEW_LINE> <TAB> for ( i = 0 ; i < n_reloc ; i + + ) { <NEW_LINE> <TAB> <TAB> if ( addr_to_patch == reloc_table [ i ] . data_offset ) {
<START_VULN> <TAB> alternative_input ( <NEW_LINE><TAB> <TAB> ASM_NOP8 ASM_NOP2 , <NEW_LINE><TAB> <TAB> "emms\n\t" <TAB> <TAB> <NEW_LINE><TAB> <TAB> "fildl % P [ addr ] " , <TAB> <NEW_LINE><TAB> <TAB> X86_FEATURE_FXSAVE_LEAK , <NEW_LINE><TAB> <TAB> [ addr ] "m" ( tsk -> thread . fpu . has_fpu ) ) ; <NEW_LINE> <END_VULN> <TAB> return fpu_restore_checking ( & tsk -> thread . fpu ) ; <NEW_LINE> }
module_init ( sha1_s390_init ) ; <NEW_LINE> module_exit ( sha1_s390_fini ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha1" ) ; <NEW_LINE> <END_VULN> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm" ) ;
#include "file . h" <NEW_LINE> #ifndef <TAB> lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : funcs . c , v 1 . 72 2014 / 05 / 14 23 : 15 : 42 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <TAB> <NEW_LINE> #include "magic . h"
<TAB> idx = srcu_read_lock ( & kvm -> irq_srcu ) ; <NEW_LINE> <TAB> irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; <NEW_LINE> <START_VULN> <TAB> BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; <NEW_LINE> <END_VULN> <TAB> hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { <NEW_LINE> <TAB> <TAB> if ( e -> type != KVM_IRQ_ROUTING_MSI )
<TAB> <TAB> <TAB> <TAB> ip = sclone ( ip + 1 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> cp = strchr ( ip , ' ] ' ) ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> * cp = '\0' ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } else {
<TAB> MP_DIGITS ( & t1 ) = 0 ; <NEW_LINE> <TAB> MP_DIGITS ( & M ) = 0 ; <NEW_LINE> <TAB> MP_DIGITS ( & S ) = 0 ; <NEW_LINE> <TAB> MP_CHECKOK ( mp_init ( & t0 ) ) ; <NEW_LINE> <TAB> MP_CHECKOK ( mp_init ( & t1 ) ) ; <NEW_LINE> <TAB> MP_CHECKOK ( mp_init ( & M ) ) ; <NEW_LINE> <TAB> MP_CHECKOK ( mp_init ( & S ) ) ; <NEW_LINE> <START_VULN> <TAB> if ( ec_GFp_pt_is_inf_jac ( px , py , pz ) == MP_YES ) { <NEW_LINE> <END_VULN> <TAB> <TAB> MP_CHECKOK ( ec_GFp_pt_set_inf_jac ( rx , ry , rz ) ) ; <NEW_LINE> <TAB> <TAB> goto CLEANUP ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( mp_cmp_d ( pz , 1 ) == 0 ) { <NEW_LINE> <TAB> <TAB> MP_CHECKOK ( group -> meth -> field_sqr ( px , & t0 , group -> meth ) ) ; <NEW_LINE> <TAB> <TAB> MP_CHECKOK ( group -> meth -> field_add ( & t0 , & t0 , & M , group -> meth ) ) ;
<TAB> This is how the time string is formatted : <NEW_LINE> <TAB> snprintf ( p , sizeof ( p ) , " % 02d % 02d % 02d % 02d % 02d % 02dZ" , ts -> tm_year % 100 , <NEW_LINE> <START_VULN> <TAB> ts -> tm_mon + 1 , ts -> tm_mday , ts -> tm_hour , ts -> tm_min , ts -> tm_sec ) ; <NEW_LINE> <END_VULN> <TAB> time_t ret ;
static int CVE_2013_4516_mp_get_count ( struct sb_uart_state * state , struct serial_icounter_struct * icnt ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> struct serial_icounter_struct icount ; <NEW_LINE> <END_VULN> <TAB> struct sb_uart_icount cnow ; <NEW_LINE> <TAB> struct sb_uart_port * port = state -> port ;
int yr_re_exec ( <NEW_LINE> <TAB> uint8_t * re_code , <NEW_LINE> <TAB> uint8_t * input , <NEW_LINE> <START_VULN> <TAB> size_t input_size , <NEW_LINE> <END_VULN> <TAB> int flags , <NEW_LINE> <TAB> RE_MATCH_CALLBACK_FUNC callback , <NEW_LINE> <TAB> void * callback_args ) ;
<TAB> seq_puts ( m , "key : " ) ; <NEW_LINE> <TAB> seq_puts ( m , key -> description ) ; <NEW_LINE> <START_VULN> <TAB> if ( key_is_instantiated ( key ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> seq_printf ( m , " pid : % d ci : % zu" , rka -> pid , rka -> callout_len ) ; <NEW_LINE> }
* <NEW_LINE> #ifdef DEBUG <NEW_LINE> <START_VULN> static const char CVS_ID [ ] = "@ ( # ) $ RCSfile : certdata . c , v $ $ Revision : 1 . 67 $ $ Date : 2010 / 04 / 08 14 : 28 : 58 $ "" ; @ ( # ) $ RCSfile : certdata . c , v $ $ Revision : 1 . 67 $ $ Date : 2010 / 04 / 08 14 : 28 : 58 $ " ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifndef BUILTINS_H <NEW_LINE> #include "builtins . h" <NEW_LINE> #endif <NEW_LINE> static const CK_BBOOL ck_false = CK_FALSE ; <NEW_LINE> static const CK_BBOOL ck_true = CK_TRUE ;
<TAB> <TAB> if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) <NEW_LINE> <TAB> <TAB> <TAB> perf_get_data_addr ( regs , & data . addr ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> power_pmu_stop ( event , 0 ) ; <NEW_LINE> <TAB> } <NEW_LINE> }
<TAB> crypto_unregister_shashes ( tgr_algs , ARRAY_SIZE ( tgr_algs ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> MODULE_ALIAS ( "tgr160" ) ; <NEW_LINE>MODULE_ALIAS ( "tgr128" ) ; <NEW_LINE> <END_VULN> module_init ( tgr192_mod_init ) ; <NEW_LINE> module_exit ( tgr192_mod_fini ) ;
<TAB> } <NEW_LINE> <TAB> hash_param . type = siBuffer ; <NEW_LINE> <START_VULN> <TAB> hash_param . data = 0 ; <NEW_LINE><TAB> hash_param . len = 0 ; <NEW_LINE> <END_VULN> <TAB> hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance -> crypto_hash_type ] , NULL ) ; <NEW_LINE> <TAB> if ( hash_slot == NULL ) {
<TAB> if ( xmlTextReaderRead ( reader ) == 1 && xmlTextReaderNodeType ( reader ) == XML_READER_TYPE_TEXT ) { <NEW_LINE> <TAB> <TAB> xmlval = xmlTextReaderConstValue ( reader ) ; <NEW_LINE> <TAB> <TAB> if ( xmlval ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> * cksum = xmlStrdup ( xmlval ) ; <NEW_LINE><TAB> <TAB> <TAB> cli_dbgmsg ( "cli_scanxar : checksum value is % s . \n" , * cksum ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> * cksum = NULL ; <NEW_LINE> <TAB> <TAB> <TAB> cli_dbgmsg ( "cli_scanxar : xmlTextReaderConstValue ( ) returns NULL for checksum value . \n" ) ;
virtual size_t SizeOfIncludingThis ( mozilla : : MallocSizeOf mallocSizeOf ) <NEW_LINE> <TAB> const MOZ_MUST_OVERRIDE MOZ_OVERRIDE ; <NEW_LINE> bool AppendFontFaceRules ( nsPresContext * aPresContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsTArray < nsFontFaceRuleContainer > & aArray ) ; <NEW_LINE> <START_VULN> bool AppendKeyframesRules ( nsPresContext * aPresContext , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsTArray < nsCSSKeyframesRule * > & aArray ) ; <NEW_LINE> <END_VULN> bool AppendPageRules ( nsPresContext * aPresContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsTArray < nsCSSPageRule * > & aArray ) ; <NEW_LINE> bool AppendFontFeatureValuesRules ( nsPresContext * aPresContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsTArray < nsCSSFontFeatureValuesRule * > & aArray ) ;
<TAB> <TAB> case GF_ISOM_SAMPLE_GROUP_TRIF : <NEW_LINE> <TAB> <TAB> <TAB> trif_dump ( trace , ( char * ) ( ( GF_DefaultSampleGroupDescriptionEntry * ) entry ) -> data , ( ( GF_DefaultSampleGroupDescriptionEntry * ) entry ) -> length ) ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> case GF_ISOM_SAMPLE_GROUP_NALM : <NEW_LINE> <TAB> <TAB> <TAB> nalm_dump ( trace , ( char * ) ( ( GF_DefaultSampleGroupDescriptionEntry * ) entry ) -> data , ( ( GF_DefaultSampleGroupDescriptionEntry * ) entry ) -> length ) ; <NEW_LINE> <TAB> <TAB> <TAB> break ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : basic codebook pack / unpack / code / decode operations <NEW_LINE> <START_VULN> last mod : $ Id : codebook . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
0 . 9999998698F , 0 . 9999998906F , 0 . 9999999088F , 0 . 9999999246F , <NEW_LINE> 0 . 9999999383F , 0 . 9999999500F , 0 . 9999999600F , 0 . 9999999684F , <NEW_LINE> 0 . 9999999754F , 0 . 9999999811F , 0 . 9999999858F , 0 . 9999999896F , <NEW_LINE> 0 . 9999999925F , 0 . 9999999948F , 0 . 9999999965F , 0 . 9999999978F , <NEW_LINE> 0 . 9999999986F , 0 . 9999999992F , 0 . 9999999996F , 0 . 9999999998F , <NEW_LINE> 0 . 9999999999F , 1 . 0000000000F , 1 . 0000000000F , 1 . 0000000000F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin8192 [ 4096 ] = { <NEW_LINE> <END_VULN> 0 . 0000000578F , 0 . 0000005198F , 0 . 0000014438F , 0 . 0000028299F , <NEW_LINE> 0 . 0000046780F , 0 . 0000069882F , 0 . 0000097604F , 0 . 0000129945F , <NEW_LINE> 0 . 0000166908F , 0 . 0000208490F , 0 . 0000254692F , 0 . 0000305515F , <NEW_LINE> 0 . 0000360958F , 0 . 0000421021F , 0 . 0000485704F , 0 . 0000555006F , <NEW_LINE> 0 . 0000628929F , 0 . 0000707472F , 0 . 0000790635F , 0 . 0000878417F , <NEW_LINE> 0 . 0000970820F , 0 . 0001067842F , 0 . 0001169483F , 0 . 0001275744F , <NEW_LINE> 0 . 0001386625F , 0 . 0001502126F , 0 . 0001622245F , 0 . 0001746984F , <NEW_LINE> 0 . 0001876343F , 0 . 0002010320F , 0 . 0002148917F , 0 . 0002292132F ,
module_param ( cryp_mode , int , 0 ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Driver for ST - Ericsson UX500 CRYP crypto engine . " ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "aes - all" ) ; <NEW_LINE>MODULE_ALIAS ( "des - all" ) ; <NEW_LINE> <END_VULN> MODULE_LICENSE ( "GPL" ) ;
public : <NEW_LINE> <TAB> JSBool IsAvailable ( ) const { return mInterface == nsnull ; } <NEW_LINE> <TAB> JSBool IsReserved ( ) const { return mInterface == ( XPCNativeInterface * ) 1 ; } <NEW_LINE> <TAB> JSBool IsValid ( ) const { return ! IsAvailable ( ) && ! IsReserved ( ) ; } <NEW_LINE> <TAB> void SetReserved ( ) { mInterface = ( XPCNativeInterface * ) 1 ; } <NEW_LINE> <TAB> XPCNativeInterface * GetInterface ( ) const { return mInterface ; } <NEW_LINE> <TAB> nsISupports * GetNative ( ) const { return mNative ; } <NEW_LINE> <START_VULN> <TAB> JSObject * GetJSObject ( ) const ; <NEW_LINE> <END_VULN> <TAB> void SetInterface ( XPCNativeInterface * Interface ) { mInterface = Interface ; } <NEW_LINE> <TAB> void SetNative ( nsISupports * Native ) { mNative = Native ; } <NEW_LINE> <TAB> void SetJSObject ( JSObject * JSObj ) ; <NEW_LINE> <TAB> void JSObjectFinalized ( ) { SetJSObject ( nsnull ) ; } <NEW_LINE> <TAB> XPCWrappedNativeTearOff ( ) <NEW_LINE> <TAB> <TAB> : mInterface ( nsnull ) , mNative ( nsnull ) , mJSObject ( nsnull ) { }
<TAB> <TAB> <TAB> regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> } else if ( opcode > BPF_END ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : LPC low level routines <NEW_LINE> <START_VULN> last mod : $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_LPC_H_ <NEW_LINE> #define _V_LPC_H_ <NEW_LINE> #include "vorbis / codec . h"
<START_VULN> <TAB> void * base = dlmalloc ( bytes + sizeof ( AllocationEntry ) ) ; <NEW_LINE> <END_VULN> <TAB> if ( base != NULL ) { <NEW_LINE> <TAB> <TAB> pthread_mutex_lock ( & gAllocationsMutex ) ;
<TAB> } <NEW_LINE> <START_VULN> <TAB> for ( i = 1 ; i <= lpc_order ; i + + ) <NEW_LINE> <END_VULN> <TAB> <TAB> buffer_out [ i ] = sign_extend ( buffer_out [ i - 1 ] + error_buffer [ i ] , bps ) ;
<TAB> if ( unlikely ( file -> f_flags & __O_TMPFILE ) ) { <NEW_LINE> <TAB> <TAB> error = do_tmpfile ( dfd , pathname , nd , flags , op , file , & opened ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> goto out ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> error = path_init ( dfd , pathname , flags , nd ) ;
<TAB> js : : InitialShapeSet initialShapes ; <NEW_LINE> <TAB> void sweepInitialShapeTable ( ) ; <NEW_LINE> <TAB> js : : types : : TypeObjectSet newTypeObjects ; <NEW_LINE> <TAB> js : : types : : TypeObjectSet lazyTypeObjects ; <NEW_LINE> <TAB> void sweepNewTypeObjectTable ( js : : types : : TypeObjectSet & table ) ; <NEW_LINE> <START_VULN> <TAB> js : : types : : TypeObject * emptyTypeObject ; <NEW_LINE> <END_VULN> <TAB> inline js : : types : : TypeObject * getEmptyType ( JSContext * cx ) ; <NEW_LINE> <TAB> js : : types : : TypeObject * getLazyType ( JSContext * cx , JSObject * proto ) ;
<START_VULN> static int _nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state ** res ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct nfs4_state_owner * sp ; <NEW_LINE> <TAB> struct nfs4_state * state = NULL ;
<TAB> iph -> protocol = sk -> sk_protocol ; <NEW_LINE> <TAB> ip_select_ident ( iph , & rt -> dst , sk ) ; <NEW_LINE> <START_VULN> <TAB> if ( opt && opt -> optlen ) { <NEW_LINE><TAB> <TAB> iph -> ihl += opt -> optlen >> 2 ; <NEW_LINE><TAB> <TAB> ip_options_build ( skb , opt , daddr , rt , 0 ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> skb -> priority = sk -> sk_priority ;
CVE_2014_6427_is_rtsp_request_or_reply ( const guchar * line , size_t linelen , rtsp_type_t * type ) <NEW_LINE> { <NEW_LINE> <TAB> guint ii ; <NEW_LINE> <START_VULN> <TAB> const guchar * next_token ; <NEW_LINE> <END_VULN> <TAB> int tokenlen ; <NEW_LINE> <TAB> gchar response_chars [ 4 ] ;
<TAB> ret = 1 ; <NEW_LINE> <START_VULN> <TAB> cms -> d . envelopedData -> encryptedContentInfo -> key = ek ; <NEW_LINE><TAB> cms -> d . envelopedData -> encryptedContentInfo -> keylen = eklen ; <NEW_LINE> <END_VULN> <TAB> err : <NEW_LINE> <TAB> if ( pctx )
} <NEW_LINE> int touch ( const char * path ) { <NEW_LINE> <START_VULN> <TAB> <TAB> return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> int symlink_idempotent ( const char * from , const char * to ) {
#if 0 <NEW_LINE> <TAB> jp2_pclr_t * pclr = & box -> data . pclr ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE>box = 0 ; <NEW_LINE>out = 0 ; <NEW_LINE> <END_VULN> <TAB> return - 1 ; <NEW_LINE> }
<START_VULN> <TAB> if ( * p + 2 > end ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> <TAB> MBEDTLS_SSL_DEBUG_MSG ( 1 , ( "bad client key exchange message" ) ) ; <NEW_LINE> <TAB> <TAB> return ( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE ) ;
<START_VULN> <TAB> tcred = __task_cred ( task ) ; <NEW_LINE><TAB> if ( ! uid_eq ( cred -> euid , tcred -> suid ) && ! uid_eq ( cred -> euid , tcred -> uid ) && <NEW_LINE><TAB> ! uid_eq ( cred -> uid , tcred -> suid ) && ! uid_eq ( cred -> uid , tcred -> uid ) && <NEW_LINE><TAB> ! capable ( CAP_SYS_NICE ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> rcu_read_unlock ( ) ; <NEW_LINE> <TAB> <TAB> err = - EPERM ; <NEW_LINE> <TAB> <TAB> goto out ;
<TAB> ctl_dir = container_of ( head , struct ctl_dir , header ) ; <NEW_LINE> <TAB> if ( ! dir_emit_dots ( file , ctx ) ) <NEW_LINE> <START_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <END_VULN> <TAB> pos = 2 ;
<TAB> <TAB> <TAB> bytes_per_pixel + + ; <NEW_LINE> <TAB> <TAB> if ( bytes_per_line == 0 ) <NEW_LINE> <TAB> <TAB> <TAB> bytes_per_line = bytes_per_pixel * image -> columns ; <NEW_LINE> <START_VULN> <TAB> <TAB> length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ( ( sun_info . type == RT_ENCODED ) && <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ( length > ( bytes_per_line * image -> rows ) ) ) || <NEW_LINE> <TAB> <TAB> <TAB> ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) )
PHPAPI pcre * pcre_get_compiled_regex_ex ( char * regex , pcre_extra ** extra , int * preg_options , int * compile_options TSRMLS_DC ) <NEW_LINE> { <NEW_LINE> <TAB> pcre_cache_entry * pce = pcre_get_compiled_regex_cache ( regex , strlen ( regex ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> if ( extra ) { <NEW_LINE> <TAB> <TAB> * extra = pce ? pce -> extra : NULL ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> key_addrs -> tipcaddrs . srcnode = hdr -> srcnode ; <NEW_LINE> <TAB> <TAB> <TAB> key_control -> addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> return true ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> case htons ( ETH_P_MPLS_UC ) :
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 55 2014 / 02 / 27 23 : 26 : 17 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include < assert . h >
static inline bool kvm_apic_has_events ( struct kvm_vcpu * vcpu ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return vcpu -> arch . apic -> pending_events ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline bool kvm_lowest_prio_delivery ( struct kvm_lapic_irq * irq )
<TAB> <TAB> NAPI_GRO_CB ( skb ) -> same_flow = 0 ; <NEW_LINE> <TAB> <TAB> NAPI_GRO_CB ( skb ) -> flush = 0 ; <NEW_LINE> <TAB> <TAB> NAPI_GRO_CB ( skb ) -> free = 0 ; <NEW_LINE> <START_VULN> <TAB> <TAB> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <NEW_LINE> <END_VULN> <TAB> <TAB> NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ;
<TAB> <TAB> <TAB> <TAB> xattr_value_len , calc . digest ) ; <NEW_LINE> <TAB> <TAB> if ( rc ) <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <START_VULN> <TAB> <TAB> rc = memcmp ( xattr_data -> digest , calc . digest , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> sizeof ( calc . digest ) ) ; <NEW_LINE> <TAB> <TAB> if ( rc ) <NEW_LINE> <TAB> <TAB> <TAB> rc = - EINVAL ;
MODULE_AUTHOR ( "Alexander Boyko < alexander_boyko@xyratex . com > " ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "crc32" ) ; <NEW_LINE>MODULE_ALIAS ( "crc32 - pclmul" ) ; <NEW_LINE> <END_VULN>
} <NEW_LINE> <START_VULN> static inline realpath_cache_bucket * realpath_cache_find ( const char * path , int path_len , time_t t ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> zend_ulong key = realpath_cache_key ( path , path_len ) ; <NEW_LINE> <TAB> zend_ulong n = key % ( sizeof ( CWDG ( realpath_cache ) ) / sizeof ( CWDG ( realpath_cache ) [ 0 ] ) ) ;
<TAB> } <NEW_LINE> <TAB> <TAB> and 40 , replicate the 100dB curve to 110 * / <NEW_LINE> <TAB> for ( j = 0 ; j < 6 ; j + + ) <NEW_LINE> <TAB> memcpy ( workc [ i ] [ j + 2 ] , tonemasks [ i ] [ j ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ j ] ) ) ; <NEW_LINE> <TAB> memcpy ( workc [ i ] [ 0 ] , tonemasks [ i ] [ 0 ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ 0 ] ) ) ; <NEW_LINE> <TAB> memcpy ( workc [ i ] [ 1 ] , tonemasks [ i ] [ 0 ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ 0 ] ) ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> for ( j = 0 ; j < P_LEVELS ; j + + ) { <NEW_LINE> <TAB> for ( k = 0 ; k < EHMER_MAX ; k + + ) { <NEW_LINE> <TAB> <TAB> float adj = center_boost + abs ( EHMER_OFFSET - k ) * center_decay_rate ; <NEW_LINE> <TAB> <TAB> if ( adj < 0 . && center_boost > 0 ) adj = 0 . ; <NEW_LINE> <TAB> <TAB> if ( adj > 0 . && center_boost < 0 ) adj = 0 . ; <NEW_LINE> <TAB> <TAB> workc [ i ] [ j ] [ k ] += adj ; <NEW_LINE> <TAB> }
<TAB> float <TAB> <TAB> <TAB> * floatptr ; <NEW_LINE> <TAB> double <TAB> <TAB> <TAB> * doubleptr ; <NEW_LINE> <TAB> char <TAB> <TAB> <TAB> c ; <NEW_LINE> <START_VULN> <TAB> int <TAB> <TAB> <TAB> <TAB> byte_count = 0 , count ; <NEW_LINE> <END_VULN> <TAB> if ( ! format ) <NEW_LINE> <TAB> <TAB> return psf_ftell ( psf ) ;
<START_VULN> <TAB> <TAB> sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> case SO_RCVBUFFORCE :
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : lookup data ; generated by lookups . pl ; edit there <NEW_LINE> <START_VULN> last mod : $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_LOOKUP_DATA_H_ <NEW_LINE> #ifdef FLOAT_LOOKUP <NEW_LINE> #define COS_LOOKUP_SZ 128 <NEW_LINE> static const float COS_LOOKUP [ COS_LOOKUP_SZ + 1 ] = {
<TAB> if ( err == - EINPROGRESS ) <NEW_LINE> <TAB> <TAB> return NF_STOLEN ; <NEW_LINE> <START_VULN> <TAB> return NF_ACCEPT ; <NEW_LINE> <END_VULN> } <NEW_LINE> static struct nf_hook_ops ipv6_defrag_ops [ ] = {
<TAB> <TAB> skb_reset_network_header ( skb ) ; <NEW_LINE> <TAB> <TAB> memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> ipv6_select_ident ( fh ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> fh -> nexthdr = nexthdr ; <NEW_LINE> <TAB> <TAB> fh -> reserved = 0 ; <NEW_LINE> <TAB> <TAB> fh -> frag_off = htons ( IP6_MF ) ;
<TAB> ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) { <NEW_LINE> <TAB> <TAB> goto error ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> cmpt -> stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) : <NEW_LINE> <END_VULN> <TAB> jas_stream_tmpfile ( ) ; <NEW_LINE> <TAB> if ( ! cmpt -> stream_ ) { <NEW_LINE> <TAB> <TAB> goto error ;
<TAB> if ( mech != NULL ) { <NEW_LINE> <TAB> <TAB> _sx_debug ( ZONE , "auth request from client ( mechanism = % s ) " , mech ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> _sx_debug ( ZONE , "client requested mechanism ( % s ) that we didn't offer" , mech ) ; <NEW_LINE> <TAB> <TAB> <TAB> _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INVALID_MECHANISM , NULL ) , 0 ) ; <NEW_LINE> <TAB> <TAB> <TAB> return ;
<TAB> <TAB> evt -> event . lun [ 0 ] = 0x01 ; <NEW_LINE> <START_VULN> <TAB> <TAB> evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( lun -> unpacked_lun >= 256 ) <NEW_LINE> <TAB> <TAB> <TAB> evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ; <NEW_LINE> <TAB> <TAB> evt -> event . lun [ 3 ] = lun -> unpacked_lun & 0xFF ;
<TAB> bool <TAB> <TAB> needquotes ; <NEW_LINE> <START_VULN> <TAB> needquotes = false ; <NEW_LINE> <END_VULN> <TAB> for ( s = str ; * s ; s + + ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> if ( ! ( ( * s >= 'a' && * s <= 'z' ) || ( * s >= 'A' && * s <= 'Z' ) ||
<TAB> struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; <NEW_LINE> <TAB> struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; <NEW_LINE> <TAB> const char * macro_mode ; <NEW_LINE> <START_VULN> <TAB> char data [ 8 ] ; <NEW_LINE> <END_VULN> <TAB> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , <NEW_LINE> <TAB> <TAB> <TAB> K90_REQUEST_GET_MODE ,
class AutoCompartment <NEW_LINE> { <NEW_LINE> <TAB> JSContext * const cx_ ; <NEW_LINE> <TAB> JSCompartment * const origin_ ; <NEW_LINE> public : <NEW_LINE> <TAB> inline AutoCompartment ( JSContext * cx , JSObject * target ) ; <NEW_LINE> <START_VULN> <TAB> inline AutoCompartment ( JSContext * cx , JSCompartment * target ) ; <NEW_LINE> <END_VULN> <TAB> inline ~ AutoCompartment ( ) ; <NEW_LINE> <TAB> JSContext * context ( ) const { return cx_ ; } <NEW_LINE> <TAB> JSCompartment * origin ( ) const { return origin_ ; } <NEW_LINE> private : <NEW_LINE> <TAB> AutoCompartment ( const AutoCompartment & ) MOZ_DELETE ; <NEW_LINE> <TAB> AutoCompartment & operator = ( const AutoCompartment & ) MOZ_DELETE ;
<TAB> { <NEW_LINE> <TAB> <TAB> char * rootdir = get_rootdir ( pid ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , " / " ) != 0 ) ? rootdir : NULL ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> char source_filename [ sizeof ( " / proc / % lu / somewhat_long_name" ) + sizeof ( long ) * 3 ] ; <NEW_LINE> <TAB> <TAB> int source_base_ofs = sprintf ( source_filename , " / proc / % lu / smaps" , ( long ) pid ) ;
<TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> req . len = res ; <NEW_LINE> <END_VULN> <TAB> req . socket . fd = sipsock ; <NEW_LINE> <TAB> set_socket_transport ( & req . socket , SIP_TRANSPORT_UDP ) ; <NEW_LINE> <TAB> req . socket . tcptls_session <TAB> = NULL ;
<TAB> int ignored ; <NEW_LINE> <TAB> dynbuf = NULL ; <NEW_LINE> <START_VULN> <TAB> _dopr ( & hugebufp , & dynbuf , & hugebufsize , & retlen , & ignored , format , args ) ; <NEW_LINE> <END_VULN> <TAB> if ( dynbuf ) { <NEW_LINE> <TAB> <TAB> ret = BIO_write ( bio , dynbuf , ( int ) retlen ) ; <NEW_LINE> <TAB> <TAB> OPENSSL_free ( dynbuf ) ;
<START_VULN> void unix_inflight ( struct file * fp ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct sock * s = unix_get_socket ( fp ) ;
exit : <NEW_LINE> <TAB> mutex_unlock ( & dev -> lock ) ; <NEW_LINE> <START_VULN> <TAB> return ret <= 0 ? ret : - EIO ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void cp2112_gpio_set ( struct gpio_chip * chip , unsigned offset , int value )
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> SmsCallbacks * callbacks_ret , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> char ** failure_reason_ret ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> <TAB> IceConn ice_conn ; <NEW_LINE><TAB> <TAB> GsmXSMPClient * client ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( server -> priv -> xsmp_sockets == NULL ) {
<TAB> INIT_LIST_HEAD ( & sm_info -> sit_entry_set ) ; <NEW_LINE> <START_VULN> <TAB> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> err = create_flush_cmd_control ( sbi ) ; <NEW_LINE> <TAB> <TAB> if ( err ) <NEW_LINE> <TAB> <TAB> <TAB> return err ;
static const struct driver_info cdc_ncm_info = { <NEW_LINE> <TAB> . description = "CDC NCM" , <NEW_LINE> <START_VULN> <TAB> . flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET , <NEW_LINE> <END_VULN> <TAB> . bind = cdc_ncm_bind , <NEW_LINE> <TAB> . unbind = cdc_ncm_unbind , <NEW_LINE> <TAB> . manage_power = usbnet_manage_power ,
<TAB> header_len = lha_decode_uint32 ( & RAW_DATA ( header , 24 ) ) ; <NEW_LINE> <START_VULN> <TAB> if ( header_len > LEVEL_3_MAX_HEADER_LEN ) { <NEW_LINE> <END_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> }
<TAB> char * src ; <NEW_LINE> <TAB> char * dest = RUN_ASOUNDRC_FILE ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> FILE * fp = fopen ( dest , "w" ) ; <NEW_LINE> <TAB> if ( fp ) { <NEW_LINE> <TAB> <TAB> fprintf ( fp , "\n" ) ;
<TAB> <TAB> <TAB> j + + ; <NEW_LINE> <TAB> <TAB> <TAB> last = i + 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> currkvno = key_data [ i ] . key_data_kvno ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> ret [ num_versions ] = NULL ;
<TAB> } <NEW_LINE> <TAB> unlock_sock_fast ( sk , slow ) ; <NEW_LINE> <START_VULN> <TAB> if ( noblock ) <NEW_LINE><TAB> <TAB> return - EAGAIN ; <NEW_LINE><NEW_LINE><TAB> <NEW_LINE> <END_VULN> <TAB> msg -> msg_flags &= ~ MSG_TRUNC ; <NEW_LINE> <TAB> goto try_again ; <NEW_LINE> } <NEW_LINE> commit beb39db59d14990e401e235faf66a6b9b31240b0 <NEW_LINE> Author : Eric Dumazet < edumazet@google . com > <NEW_LINE> Date : Sat May 30 09 : 16 : 53 2015 - 0700 <NEW_LINE> <TAB> udp : fix behavior of wrong checksums <NEW_LINE> <TAB> We have two problems in UDP stack related to bogus checksums : <NEW_LINE> <TAB> 1 ) We return - EAGAIN to application even if receive queue is not empty . <NEW_LINE> <TAB> This breaks applications using edge trigger epoll ( ) <NEW_LINE> <TAB> 2 ) Under UDP flood , we can loop forever without yielding to other <NEW_LINE> <TAB> processes , potentially hanging the host , especially on non SMP . <NEW_LINE> <TAB> This patch is an attempt to make things better . <NEW_LINE> <TAB> We might in the future add extra support for rt applications <NEW_LINE> <TAB> wanting to better control time spent doing a recv ( ) in a hostile <NEW_LINE> <TAB> environment . For example we could validate checksums before queuing <NEW_LINE> <TAB> packets in socket receive queue . <NEW_LINE> <TAB> Signed - off - by : Eric Dumazet < edumazet@google . com > <NEW_LINE> <TAB> Cc : Willem de Bruijn < willemb@google . com > <NEW_LINE> <TAB> Signed - off - by : David S . Miller < davem@davemloft . net >
<START_VULN> <NEW_LINE> <END_VULN> #define D0 if ( 1 ) <NEW_LINE> #define D1 if ( 1 )
void midi_synth_close ( int dev ) ; <NEW_LINE> void midi_synth_hw_control ( int dev , unsigned char * event ) ; <NEW_LINE> int midi_synth_load_patch ( int dev , int format , const char __user * addr , <NEW_LINE> <START_VULN> <TAB> <TAB> int offs , int count , int pmgr_flag ) ; <NEW_LINE> <END_VULN> void midi_synth_panning ( int dev , int channel , int pressure ) ; <NEW_LINE> void midi_synth_aftertouch ( int dev , int channel , int pressure ) ; <NEW_LINE> void midi_synth_controller ( int dev , int channel , int ctrl_num , int value ) ;
<TAB> hold &= ( 1U << bits ) - 1 ; <NEW_LINE> <START_VULN> <TAB> strm -> next_in = in + OFF ; <NEW_LINE><TAB> strm -> next_out = out + OFF ; <NEW_LINE> <END_VULN> <TAB> strm -> avail_in = ( unsigned ) ( in < last ? 5 + ( last - in ) : 5 - ( in - last ) ) ; <NEW_LINE> <TAB> strm -> avail_out = ( unsigned ) ( out < end ? <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> 257 + ( end - out ) : 257 - ( out - end ) ) ;
<TAB> <TAB> for ( i = 0 ; i < numcmpts ; + + i ) { <NEW_LINE> <TAB> <TAB> <TAB> if ( jas_image_readcmpt ( image , cmpts [ i ] , 0 , y , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> jas_image_width ( image ) , 1 , data [ i ] ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> return - 1 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> z = 0 ;
CVE_2013_0799_IsStatusApplying ( LPCWSTR updateDirPath , BOOL & isApplying ) <NEW_LINE> { <NEW_LINE> isApplying = FALSE ; <NEW_LINE> <START_VULN> WCHAR updateStatusFilePath [ MAX_PATH + 1 ] ; <NEW_LINE>wcscpy ( updateStatusFilePath , updateDirPath ) ; <NEW_LINE> <END_VULN> if ( ! PathAppendSafe ( updateStatusFilePath , L"update . status" ) ) { <NEW_LINE> <TAB> LOG_WARN ( ( "Could not append path for update . status file" ) ) ; <NEW_LINE> <TAB> return FALSE ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIFile ** aDirectory ) const ; <NEW_LINE> nsresult <NEW_LINE> EnsureOriginIsInitialized ( const nsACString & aOrigin , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool aTrackQuota , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIFile ** aDirectory ) ; <NEW_LINE> void <NEW_LINE> <START_VULN> UninitializeOriginsByPattern ( const nsACString & aPattern ) ; <NEW_LINE> <END_VULN> nsIThread * <NEW_LINE> IOThread ( ) <NEW_LINE> { <NEW_LINE> <TAB> NS_ASSERTION ( mIOThread , "This should never be null ! " ) ; <NEW_LINE> <TAB> return mIOThread ; <NEW_LINE> }
{ <NEW_LINE> <TAB> int i ; <NEW_LINE> <TAB> int nr = pagevec_count ( pvec ) ; <NEW_LINE> <START_VULN> <TAB> int delta_munlocked ; <NEW_LINE> <END_VULN> <TAB> struct pagevec pvec_putback ; <NEW_LINE> <TAB> int pgrescued = 0 ;
<TAB> e = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; <NEW_LINE> <TAB> if ( e == NULL || e -> method == SC_AC_NEVER ) <NEW_LINE> <TAB> <TAB> return 10 ; <NEW_LINE> <START_VULN> <TAB> bufsize = file -> size ; <NEW_LINE> <END_VULN> <TAB> sc_file_free ( file ) ; <NEW_LINE> <TAB> r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; <NEW_LINE> <TAB> if ( r < 0 ) {
<TAB> phar_flush ( phar , 0 , 0 , 1 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> efree ( oldpath ) ; <NEW_LINE> <TAB> <TAB> return NULL ;
<TAB> <TAB> break ; <NEW_LINE> <TAB> case 0x70 . . . 0x7f : <NEW_LINE> <TAB> <TAB> if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> jmp_rel ( ctxt , ctxt -> src . val ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> case 0x8d : <NEW_LINE> <TAB> <TAB> ctxt -> dst . val = ctxt -> src . addr . mem . ea ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIPrincipal * originPrincipal , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsISupports * context , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsACString & mimeType , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsISupports * extra , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> int16_t * decision , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIContentPolicy * policyService = nullptr , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIScriptSecurityManager * aSecMan = nullptr ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> CHECK_PRINCIPAL ; <NEW_LINE> <END_VULN> <TAB> if ( policyService ) { <NEW_LINE> <TAB> <TAB> CHECK_CONTENT_POLICY_WITH_SERVICE ( ShouldProcess , policyService ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> CHECK_CONTENT_POLICY ( ShouldProcess ) ; <NEW_LINE> } <NEW_LINE> #undef CHECK_CONTENT_POLICY <NEW_LINE> #undef CHECK_CONTENT_POLICY_WITH_SERVICE
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : libvorbis codec headers <NEW_LINE> <START_VULN> last mod : $ Id : codec_internal . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_CODECI_H_ <NEW_LINE> #define _V_CODECI_H_ <NEW_LINE> #include "envelope . h" <NEW_LINE> #include "codebook . h"
<TAB> <TAB> ogg_sync_wrote ( & oy , next - buf ) ; <NEW_LINE> <TAB> <TAB> while ( 1 ) { <NEW_LINE> <TAB> <TAB> <TAB> int ret = ogg_sync_pageout ( & oy , & og_de ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ret == 0 ) break ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ret < 0 ) continue ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> fprintf ( stderr , " ( % ld ) , " , pageout ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> check_page ( data + deptr , headers [ pageout ] , & og_de ) ; <NEW_LINE> <TAB> <TAB> <TAB> deptr += og_de . body_len ; <NEW_LINE> <TAB> <TAB> <TAB> pageout + + ; <NEW_LINE> <TAB> <TAB> <TAB> ogg_stream_pagein ( & os_de , & og_de ) ;
<TAB> sem_lock_and_putref ( sma ) ; <NEW_LINE> <TAB> if ( sma -> sem_perm . deleted ) { <NEW_LINE> <START_VULN> <TAB> <TAB> sem_unlock ( sma ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> kfree ( new ) ; <NEW_LINE> <TAB> <TAB> un = ERR_PTR ( - EIDRM ) ; <NEW_LINE> <TAB> <TAB> goto out ;
<TAB> <TAB> for ( x = 0 ; x < 6 ; x + + ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> const int idx = ( p_data [ 4 + y ] >> ( 5 - x ) ) & 0x01 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> uint8_t * p = & p_cdg -> p_screen [ ( sy + y ) * CDG_SCREEN_PITCH + ( sx + x ) ] ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( doXor ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> * p ^ = p_color [ idx ] ; <NEW_LINE> <TAB> <TAB> <TAB> else
<TAB> <TAB> <TAB> if ( type == DNS_T_PTR ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> add_assoc_string ( * subarray , "type" , "PTR" , 1 ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> n = dn_expand ( answer -> qb2 , answer -> qb2 + 65536 , cp , name , ( sizeof name ) - 2 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( n < 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> <TAB> assert ( p_stream != 00 ) ; <NEW_LINE> <TAB> <TAB> l_tcp = & ( p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> <TAB> l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; <NEW_LINE> <TAB> <TAB> if ( l_mco_size > p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size ) {
<TAB> pkiDebug ( "found kdcPkId in AS REQ\n" ) ; <NEW_LINE> <TAB> is = d2i_PKCS7_ISSUER_AND_SERIAL ( NULL , & p , ( int ) pkid_len ) ; <NEW_LINE> <TAB> if ( is == NULL ) <NEW_LINE> <START_VULN> <TAB> <TAB> goto cleanup ; <NEW_LINE> <END_VULN> <TAB> status = X509_NAME_cmp ( X509_get_issuer_name ( kdc_cert ) , is -> issuer ) ; <NEW_LINE> <TAB> if ( ! status ) {
<TAB> struct ext4_iloc iloc ; <NEW_LINE> <TAB> int err = 0 ; <NEW_LINE> <START_VULN> <TAB> if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) <NEW_LINE> <END_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> NEED_OP ( t ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> do { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> * op + + = * m_pos + + ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } while ( op < oe ) ;
int hb_generat_bin_from_kernel_source ( cl_program program , const char * cl_file_name ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> int i = 0 ; <NEW_LINE><TAB> cl_int status ; <NEW_LINE><TAB> cl_uint numDevices ; <NEW_LINE><TAB> size_t * binarySizes ; <NEW_LINE><TAB> cl_device_id * devices ; <NEW_LINE><TAB> char ** binaries ; <NEW_LINE><TAB> char * str = NULL ; <NEW_LINE> <END_VULN> <TAB> if ( hb_ocl == NULL ) <NEW_LINE> <TAB> {
<TAB> int initialContextToken = ( * context_handle == GSS_C_NO_CONTEXT ) ; <NEW_LINE> <TAB> if ( initialContextToken ) { <NEW_LINE> <START_VULN> <TAB> <TAB> code = iakerb_alloc_context ( & ctx ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( code != 0 ) <NEW_LINE> <TAB> <TAB> <TAB> goto cleanup ;
<TAB> for ( i = 0 ; i < size ; i + + ) { <NEW_LINE> <TAB> <TAB> ch = buffer [ i ] ; <NEW_LINE> <START_VULN> <TAB> <TAB> Huff_transmit ( & huff , ch , seq ) ; <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> Huff_addRef ( & huff , ( byte ) ch ) ; <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <NEW_LINE> <TAB> }
<TAB> zval * z_still_running ; <NEW_LINE> <TAB> php_curlm * mh ; <NEW_LINE> <TAB> int still_running ; <NEW_LINE> <START_VULN> <TAB> int result ; <NEW_LINE> <END_VULN> <TAB> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , "rz / " , & z_mh , & z_still_running ) == FAILURE ) { <NEW_LINE> <TAB> <TAB> return ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Twofish Cipher Algorithm" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "twofish" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> return FALSE ; <NEW_LINE> <TAB> * data_offset = offset ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ; <NEW_LINE><TAB> if ( pkt_len == - 1 ) <NEW_LINE><TAB> <TAB> return FALSE ; <NEW_LINE><NEW_LINE><TAB> <NEW_LINE><TAB> return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len , <NEW_LINE><TAB> wth -> frame_buffer , err , err_info ) ; <NEW_LINE> <END_VULN> }
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readcdf . c , v 1 . 39 2014 / 02 / 27 23 : 26 : 18 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include < assert . h >
<TAB> int flags = 0 ; <NEW_LINE> <TAB> Elf32_Ehdr elf32hdr ; <NEW_LINE> <TAB> Elf64_Ehdr elf64hdr ; <NEW_LINE> <START_VULN> <TAB> uint16_t type ; <NEW_LINE> <END_VULN> <TAB> if ( ms -> flags & ( MAGIC_MIME|MAGIC_APPLE ) ) <NEW_LINE> <TAB> <TAB> return 0 ;
<TAB> <TAB> goto err ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> len = file ? file -> size : 4096 ; <NEW_LINE> <END_VULN> <TAB> p = realloc ( * data , len ) ; <NEW_LINE> <TAB> if ( ! p ) { <NEW_LINE> <TAB> <TAB> goto err ;
<TAB> <TAB> <TAB> int32_t i32 ; <NEW_LINE> <TAB> <TAB> <TAB> uint32_t u32 ; <NEW_LINE> <TAB> <TAB> <TAB> JSWhyMagic why ; <NEW_LINE> <TAB> <TAB> } payload ; <NEW_LINE> <TAB> } s ; <NEW_LINE> <TAB> double asDouble ; <NEW_LINE> <TAB> void * asPtr ; <NEW_LINE> <TAB> size_t asWord ; <NEW_LINE> <START_VULN> } jsval_layout ; <NEW_LINE> <END_VULN> # endif <NEW_LINE> #else <NEW_LINE> # if JS_BITS_PER_WORD == 32 <NEW_LINE> typedef union jsval_layout <NEW_LINE> { <NEW_LINE> <TAB> uint64_t asBits ; <NEW_LINE> <TAB> struct { <NEW_LINE> <TAB> <TAB> JSValueTag tag ;
<TAB> mt -> mt_buffer_ [ i ] = <NEW_LINE> <START_VULN> <TAB> ( 1812433253UL * ( mt -> mt_buffer_ [ i - 1 ] ^ <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ( mt -> mt_buffer_ [ i - 1 ] >> 30 ) ) + i ) ; <NEW_LINE> } <NEW_LINE> }
<TAB> mysql_free_result ( result ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> end = strmov ( strmov ( strmov ( query , "show columns from `" ) , table ) , "`" ) ; <NEW_LINE>if ( wild && wild [ 0 ] ) <NEW_LINE><TAB> strxmov ( end , " like '" , wild , "'" , NullS ) ; <NEW_LINE> <END_VULN> if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) <NEW_LINE> { <NEW_LINE> <TAB> fprintf ( stderr , " % s : Cannot list columns in db : % s , table : % s : % s\n" ,
<TAB> while ( count > 0 ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> memcpy ( temp , temp - r -> bpp , r -> bpp ) ; <NEW_LINE><TAB> temp += r -> bpp ; <NEW_LINE><TAB> count -= r -> bpp ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> }
{ <NEW_LINE> <TAB> DATA_TYPE * oX1 = out + n2 + n4 ; <NEW_LINE> <TAB> DATA_TYPE * oX2 = out + n2 + n4 ; <NEW_LINE> <TAB> DATA_TYPE * iX = out ; <NEW_LINE> <TAB> T = init -> trig + n2 ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> do { <NEW_LINE> <TAB> oX1 -= 4 ; <NEW_LINE> <TAB> oX1 [ 3 ] = MULT_NORM ( iX [ 0 ] * T [ 1 ] - iX [ 1 ] * T [ 0 ] ) ; <NEW_LINE> <TAB> oX2 [ 0 ] = - MULT_NORM ( iX [ 0 ] * T [ 0 ] + iX [ 1 ] * T [ 1 ] ) ; <NEW_LINE> <TAB> oX1 [ 2 ] = MULT_NORM ( iX [ 2 ] * T [ 3 ] - iX [ 3 ] * T [ 2 ] ) ; <NEW_LINE> <TAB> oX2 [ 1 ] = - MULT_NORM ( iX [ 2 ] * T [ 2 ] + iX [ 3 ] * T [ 3 ] ) ;
<TAB> <TAB> <TAB> <TAB> MXFEssenceContainerData * essence_data ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> av_log ( mxf , AV_LOG_TRACE , "could not resolve essence container data strong ref\n" ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( ! memcmp ( component -> source_package_ul , essence_data -> package_ul , sizeof ( UID ) ) && ! memcmp ( component -> source_package_uid , essence_data -> package_uid , sizeof ( UID ) ) ) {
<TAB> so = slirp -> udp_last_so ; <NEW_LINE> <START_VULN> <TAB> if ( so -> so_lport != uh -> uh_sport || <NEW_LINE> <END_VULN> <TAB> so -> so_laddr . s_addr != ip -> ip_src . s_addr ) { <NEW_LINE> <TAB> <TAB> struct socket * tmp ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsICSSPseudoComparator * aComparator ) ; <NEW_LINE> #endif <NEW_LINE> bool AppendFontFaceRules ( nsPresContext * aPresContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsTArray < nsFontFaceRuleContainer > & aArray ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> <NEW_LINE>bool AppendKeyframesRules ( nsPresContext * aPresContext , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsTArray < nsCSSKeyframesRule * > & aArray ) ; <NEW_LINE> <END_VULN> already_AddRefed < gfxFontFeatureValueSet > GetFontFeatureValuesLookup ( ) ; <NEW_LINE> bool AppendFontFeatureValuesRules ( nsPresContext * aPresContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsTArray < nsCSSFontFeatureValuesRule * > & aArray ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsCycleCollectionParticipant * helper ) = 0 ; <NEW_LINE> <TAB> NS_IMETHOD_ ( void ) NoteNextEdgeName ( const char * name ) = 0 ; <NEW_LINE> <START_VULN> <TAB> NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * val ) = 0 ; <NEW_LINE> <END_VULN> <TAB> enum { <NEW_LINE> <TAB> <TAB> WANT_DEBUG_INFO = ( 1 << 0 ) ,
<TAB> } <NEW_LINE> <TAB> break ; <NEW_LINE> <TAB> case rsaKey : <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> SECItem digest ; <NEW_LINE> <TAB> <TAB> digest . data = final ; <NEW_LINE> <TAB> <TAB> digest . len = part ; <NEW_LINE> <TAB> if ( sig ) { <NEW_LINE> <TAB> PORT_Assert ( cx -> hashAlg != SEC_OID_UNKNOWN ) ; <NEW_LINE> <START_VULN> <TAB> SECOidTag hashid ; <NEW_LINE> <END_VULN> <TAB> rv = recoverPKCS1DigestInfo ( cx -> hashAlg , & hashid , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> & cx -> pkcs1RSADigestInfo , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> & cx -> pkcs1RSADigestInfoLen , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> cx -> key , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> sig , cx -> wincx ) ; <NEW_LINE> <TAB> PORT_Assert ( cx -> hashAlg == hashid ) ; <NEW_LINE> <TAB> if ( rv != SECSuccess ) { <NEW_LINE> <TAB> <TAB> return SECFailure ;
<TAB> sem_rmid ( ns , sma ) ; <NEW_LINE> <START_VULN> <TAB> sem_unlock ( sma ) ; <NEW_LINE> <END_VULN> <TAB> wake_up_sem_queue_do ( & tasks ) ; <NEW_LINE> <TAB> ns -> used_sems -= sma -> sem_nsems ;
<TAB> save_items_from_notepad ( ) ; <NEW_LINE> <TAB> save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> if ( pages [ PAGENO_SUMMARY ] . page_widget == page ) <NEW_LINE> <TAB> {
<START_VULN> <TAB> if ( SSL_USE_ETM ( s ) && s -> read_hash ) { <NEW_LINE> <END_VULN> <TAB> <TAB> unsigned char * mac ; <NEW_LINE> <TAB> <TAB> mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; <NEW_LINE> <TAB> <TAB> OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ;
<TAB> <TAB> retv = 0 ; <NEW_LINE> <TAB> <TAB> opt = ipv6_update_options ( sk , opt ) ; <NEW_LINE> done : <NEW_LINE> <START_VULN> <TAB> <TAB> if ( opt ) <NEW_LINE><TAB> <TAB> <TAB> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> case IPV6_UNICAST_HOPS :
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Twofish Cipher Algorithm , asm optimized" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "twofish" ) ; <NEW_LINE>MODULE_ALIAS ( "twofish - asm" ) ; <NEW_LINE> <END_VULN>
<TAB> struct nfs_fh * fh ; <NEW_LINE> <TAB> nfs4_stateid * <TAB> <TAB> stateid ; <NEW_LINE> <TAB> struct nfs_seqid * <TAB> seqid ; <NEW_LINE> <START_VULN> <TAB> int <TAB> <TAB> <TAB> open_flags ; <NEW_LINE> <END_VULN> <TAB> const u32 * <TAB> <TAB> bitmask ; <NEW_LINE> } ;
<TAB> logit ( "open \" % s\" flags % s mode 0 % o" , <NEW_LINE> <TAB> name , string_from_portable ( pflags ) , mode ) ; <NEW_LINE> <TAB> if ( readonly && <NEW_LINE> <START_VULN> <TAB> ( ( flags & O_ACCMODE ) == O_WRONLY || <NEW_LINE><TAB> ( flags & O_ACCMODE ) == O_RDWR ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> verbose ( "Refusing open request in read - only mode" ) ; <NEW_LINE> <TAB> <TAB> status = SSH2_FX_PERMISSION_DENIED ; <NEW_LINE> <TAB> } else {
<TAB> ret = key -> type -> update ( key , prep ) ; <NEW_LINE> <TAB> if ( ret == 0 ) <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE><TAB> <TAB> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <NEW_LINE> <END_VULN> <TAB> up_write ( & key -> sem ) ;
<TAB> if ( file_seek ( wth -> fh , frame_table_offset , SEEK_SET , err ) == - 1 ) { <NEW_LINE> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> frame_table = ( guint32 * ) g_malloc ( frame_table_length ) ; <NEW_LINE> <END_VULN> <TAB> errno = WTAP_ERR_CANT_READ ; <NEW_LINE> <TAB> bytes_read = file_read ( frame_table , frame_table_length , wth -> fh ) ; <NEW_LINE> <TAB> if ( ( guint32 ) bytes_read != frame_table_length ) {
<TAB> <TAB> av_frame_copy_props ( out , in ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> for ( p = 0 ; p < 4 && in -> data [ p ] ; p + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> int w = inlink -> w ; <NEW_LINE> <TAB> <TAB> int h = inlink -> h ; <NEW_LINE> <TAB> <TAB> int r = s -> radius ;
<TAB> e_hash - pointer to int for returning extracted checksum algorithm . <NEW_LINE> <TAB> returns - CL_FORMAT , CL_SUCCESS , CL_BREAK . CL_BREAK indicates no more < data > / < ea > element . <NEW_LINE> <START_VULN> static int xar_get_toc_data_values ( xmlTextReaderPtr reader , long * length , long * offset , long * size , int * encoding , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> unsigned char ** a_cksum , int * a_hash , unsigned char ** e_cksum , int * e_hash ) <NEW_LINE> { <NEW_LINE> <TAB> const xmlChar * name ;
<TAB> vma -> vm_mm = mm ; <NEW_LINE> <TAB> down_write ( & mm -> mmap_sem ) ; <NEW_LINE> <START_VULN> <TAB> insert_vm_struct ( mm , vma ) ; <NEW_LINE> <END_VULN> <TAB> mm -> total_vm += npages ; <NEW_LINE> <TAB> up_write ( & mm -> mmap_sem ) ; <NEW_LINE> <TAB> return 0 ;
static void kvmclock_reset ( struct kvm_vcpu * vcpu ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( vcpu -> arch . time_page ) { <NEW_LINE><TAB> <TAB> kvm_release_page_dirty ( vcpu -> arch . time_page ) ; <NEW_LINE><TAB> <TAB> vcpu -> arch . time_page = NULL ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> } <NEW_LINE> static void accumulate_steal_time ( struct kvm_vcpu * vcpu )
<TAB> <TAB> command_success_nodata ( si , _ ( "Cleared flags in \2 % s\2 . " ) , mc -> name ) ; <NEW_LINE> <TAB> <TAB> return ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> else if ( ! strcasecmp ( target , "MODIFY" ) && myentity_find_ext ( target ) == NULL ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> <TAB> free ( target ) ;
<TAB> if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || arg == CDSL_CURRENT ) <NEW_LINE> <TAB> <TAB> return media_changed ( cdi , 1 ) ; <NEW_LINE> <START_VULN> <TAB> if ( ( unsigned int ) arg >= cdi -> capacity ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> info = kmalloc ( sizeof ( * info ) , GFP_KERNEL ) ;
static void l2tp_eth_dev_setup ( struct net_device * dev ) <NEW_LINE> { <NEW_LINE> <TAB> ether_setup ( dev ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> dev -> netdev_ops <TAB> <TAB> = & l2tp_eth_netdev_ops ; <NEW_LINE> <TAB> dev -> destructor <TAB> <TAB> = free_netdev ; <NEW_LINE> }
<TAB> * y0 = rint ( a + b * x0 ) ; <NEW_LINE> <TAB> * y1 = rint ( a + b * x1 ) ; <NEW_LINE> <TAB> if ( * y0 > 1023 ) * y0 = 1023 ; <NEW_LINE> <TAB> if ( * y1 > 1023 ) * y1 = 1023 ; <NEW_LINE> <TAB> if ( * y0 < 0 ) * y0 = 0 ; <NEW_LINE> <TAB> if ( * y1 < 0 ) * y1 = 0 ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> return 0 ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> * y0 = 0 ; <NEW_LINE> <TAB> * y1 = 0 ; <NEW_LINE> <TAB> return 1 ; <NEW_LINE> <TAB> } <NEW_LINE> } <NEW_LINE> }
<TAB> if ( remain >= len ) { <NEW_LINE> <TAB> <TAB> rlen = len ; <NEW_LINE> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( remain == 0 ) { <NEW_LINE> <END_VULN>
<TAB> ASSERT ( apic != NULL ) ; <NEW_LINE> <START_VULN> <TAB> if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 ) <NEW_LINE> <END_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> remaining = hrtimer_get_remaining ( & apic -> lapic_timer . timer ) ;
<START_VULN> void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc , <NEW_LINE><TAB> <TAB> <TAB> int length , int offset , int total_size ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct oz_port * port = hport ; <NEW_LINE> <TAB> struct urb * urb ;
long long crm_int_helper ( const char * text , char ** end_text ) ; <NEW_LINE> char * crm_concat ( const char * prefix , const char * suffix , char join ) ; <NEW_LINE> char * generate_hash_key ( const char * crm_msg_reference , const char * sys ) ; <NEW_LINE> <START_VULN> xmlNode * crm_recv_remote_msg ( void * session , gboolean encrypted ) ; <NEW_LINE>void crm_send_remote_msg ( void * session , xmlNode * msg , gboolean encrypted ) ; <NEW_LINE> <END_VULN> const char * daemon_option ( const char * option ) ; <NEW_LINE> void set_daemon_option ( const char * option , const char * value ) ;
<TAB> <TAB> <TAB> list_del_init ( & u -> link ) ; <NEW_LINE> <TAB> <TAB> unix_tot_inflight -- ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> fp -> f_cred -> user -> unix_inflight -- ; <NEW_LINE> <END_VULN> <TAB> spin_unlock ( & unix_gc_lock ) ; <NEW_LINE> }
<TAB> PRUint32 mPreferredWidth ; <NEW_LINE> <TAB> PRUint32 mPreferredHeight ; <NEW_LINE> private : <NEW_LINE> <TAB> PRBool IsVisible ( ) ; <NEW_LINE> <TAB> void GetToplevelWidget ( GtkWidget ** aWidget ) ; <NEW_LINE> <TAB> GtkWidget * GetMozContainerWidget ( ) ; <NEW_LINE> <START_VULN> <TAB> void GetContainerWindow ( nsWindow ** aWindow ) ; <NEW_LINE> <END_VULN> <TAB> void SetUrgencyHint ( GtkWidget * top_window , PRBool state ) ; <NEW_LINE> <TAB> void * SetupPluginPort ( void ) ; <NEW_LINE> <TAB> nsresult SetWindowIconList ( const nsTArray < nsCString > & aIconList ) ; <NEW_LINE> <TAB> void SetDefaultIcon ( void ) ; <NEW_LINE> <TAB> void InitButtonEvent ( nsMouseEvent & aEvent , GdkEventButton * aGdkEvent ) ; <NEW_LINE> <TAB> PRBool DispatchCommandEvent ( nsIAtom * aCommand ) ; <NEW_LINE> <TAB> GtkWidget * mShell ;
<TAB> const struct xt_entry_target * t ; <NEW_LINE> <TAB> unsigned int verdict ; <NEW_LINE> <START_VULN> <TAB> if ( ! unconditional ( & e -> ip ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return false ; <NEW_LINE> <TAB> t = ipt_get_target_c ( e ) ; <NEW_LINE> <TAB> if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 )
<TAB> <TAB> <TAB> struct rf_tech_specific_params_nfcb_poll * nfcb_poll , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> __u8 * data ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> nfcb_poll -> sensb_res_len = * data + + ; <NEW_LINE> <END_VULN> <TAB> pr_debug ( "sensb_res_len % d\n" , nfcb_poll -> sensb_res_len ) ;
static char * get_pid_environ_val ( pid_t pid , char * val ) { <NEW_LINE> <START_VULN> char temp [ 500 ] ; <NEW_LINE> <END_VULN> int i = 0 ; <NEW_LINE> int foundit = 0 ; <NEW_LINE> FILE * fp ;
<TAB> <TAB> <TAB> <TAB> int length ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> DEBUG_MSG ( "\tDissector_postgresql RESPONSE type is clear - text ! " ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> GET_ULONG_BE ( length , ptr , 1 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> strncpy ( ( char * ) conn_status -> password , ( char * ) ( ptr + 5 ) , length - 4 ) ; <NEW_LINE><TAB> <TAB> <TAB> conn_status -> password [ length - 4 ] = 0 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> DISSECT_MSG ( "PostgreSQL credentials : % s - % d : % s : % s\n" , ip_addr_ntoa ( & PACKET -> L3 . dst , tmp ) , ntohs ( PACKET -> L4 . dst ) , conn_status -> user , conn_status -> password ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> dissect_wipe_session ( PACKET , DISSECT_CODE ( dissector_postgresql ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> public : <NEW_LINE> <TAB> bool Equals ( const nsSMILInstanceTime * aElem1 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> const nsSMILInstanceTime * aElem2 ) const ; <NEW_LINE> <TAB> bool LessThan ( const nsSMILInstanceTime * aElem1 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> const nsSMILInstanceTime * aElem2 ) const ; <NEW_LINE> } ; <NEW_LINE> struct NotifyTimeDependentsParams { <NEW_LINE> <START_VULN> <TAB> nsSMILInterval * mCurrentInterval ; <NEW_LINE> <END_VULN> <TAB> nsSMILTimeContainer * mTimeContainer ; <NEW_LINE> } ; <NEW_LINE> template < class TestFunctor > <NEW_LINE> void RemoveInstanceTimes ( InstanceTimeList & aArray , TestFunctor & aTest ) ;
<TAB> WebGLContext ( ) ; <NEW_LINE> <TAB> virtual ~ WebGLContext ( ) ; <NEW_LINE> <START_VULN> <TAB> NS_DECL_ISUPPORTS <NEW_LINE> <END_VULN> <TAB> NS_DECL_NSICANVASRENDERINGCONTEXTWEBGL
#define INDEX_LEN 2 <NEW_LINE> #define INDEX_HI ( i ) ( ( jsbytecode ) ( ( i ) >> 8 ) ) <NEW_LINE> #define INDEX_LO ( i ) ( ( jsbytecode ) ( i ) ) <NEW_LINE> #define GET_INDEX ( pc ) GET_UINT16 ( pc ) <NEW_LINE> #define SET_INDEX ( pc , i ) ( ( pc ) [ 1 ] = INDEX_HI ( i ) , ( pc ) [ 2 ] = INDEX_LO ( i ) ) <NEW_LINE> <START_VULN> #define GET_INDEXBASE ( pc ) ( JS_ASSERT ( * ( pc ) == JSOP_INDEXBASE ) , \ <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ( ( uintN ) ( ( pc ) [ 1 ] ) ) << 16 ) <NEW_LINE> #define INDEXBASE_LEN 1 <NEW_LINE> #define UINT24_HI ( i ) ( ( jsbytecode ) ( ( i ) >> 16 ) ) <NEW_LINE> #define UINT24_MID ( i ) ( ( jsbytecode ) ( ( i ) >> 8 ) ) <NEW_LINE> #define UINT24_LO ( i ) ( ( jsbytecode ) ( i ) ) <NEW_LINE> #define GET_UINT24 ( pc ) ( ( jsatomid ) ( ( ( pc ) [ 1 ] << 16 ) | \ <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ( ( pc ) [ 2 ] << 8 ) | \
<TAB> duprintf ( "check_compat_entry_size_and_hooks % p\n" , e ) ; <NEW_LINE> <TAB> if ( ( unsigned long ) e % __alignof__ ( struct compat_arpt_entry ) != 0 || <NEW_LINE> <START_VULN> <TAB> ( unsigned char * ) e + sizeof ( struct compat_arpt_entry ) >= limit ) { <NEW_LINE> <END_VULN> <TAB> <TAB> duprintf ( "Bad offset % p , limit = % p\n" , e , limit ) ; <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> }
void user_describe ( const struct key * key , struct seq_file * m ) <NEW_LINE> { <NEW_LINE> <TAB> seq_puts ( m , key -> description ) ; <NEW_LINE> <START_VULN> <TAB> if ( key_is_instantiated ( key ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> seq_printf ( m , " : % u" , key -> datalen ) ; <NEW_LINE> }
<TAB> <TAB> return - EBUSY ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> chip -> data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ; <NEW_LINE> <END_VULN> <TAB> if ( chip -> data_buffer == NULL ) { <NEW_LINE> <TAB> <TAB> clear_bit ( 0 , & chip -> is_open ) ; <NEW_LINE> <TAB> <TAB> put_device ( chip -> dev ) ;
<TAB> <TAB> avcodec_get_frame_defaults ( & pic -> avframe ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> s -> num_refs = parse_code & 0x03 ; <NEW_LINE> <END_VULN> <TAB> <TAB> s -> is_arith = ( parse_code & 0x48 ) == 0x08 ; <NEW_LINE> <TAB> <TAB> s -> low_delay = ( parse_code & 0x88 ) == 0x88 ; <NEW_LINE> <TAB> <TAB> pic -> avframe . reference = ( parse_code & 0x0C ) == 0x0C ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : modified discrete cosine transform prototypes <NEW_LINE> <START_VULN> last mod : $ Id : mdct . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _OGG_mdct_H_ <NEW_LINE> #define _OGG_mdct_H_ <NEW_LINE> #include "vorbis / codec . h"
<TAB> cl_allowDownload = Cvar_Get ( "cl_allowDownload" , "0" , CVAR_ARCHIVE ) ; <NEW_LINE> #ifdef USE_CURL_DLOPEN <NEW_LINE> <START_VULN> <TAB> cl_cURLLib = Cvar_Get ( "cl_cURLLib" , DEFAULT_CURL_LIB , CVAR_ARCHIVE ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> <TAB> cl_conXOffset = Cvar_Get ( "cl_conXOffset" , "0" , 0 ) ;
} <NEW_LINE> <START_VULN> struct inet_peer <TAB> * inet_getpeer ( struct inetpeer_addr * daddr , int create ) ; <NEW_LINE> <END_VULN> static inline struct inet_peer * inet_getpeer_v4 ( __be32 v4daddr , int create ) <NEW_LINE> {
<TAB> <TAB> ma_mov ( c , lr ) ; <NEW_LINE> <TAB> <TAB> ma_str ( lr , dest ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> BufferOffset ma_BoundsCheck ( Register bounded ) { <NEW_LINE> <TAB> <TAB> return as_cmp ( bounded , Imm8 ( 0 ) ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void moveFloat32 ( FloatRegister src , FloatRegister dest ) { <NEW_LINE> <START_VULN> <TAB> <TAB> as_vmov ( VFPRegister ( src ) . singleOverlay ( ) , VFPRegister ( dest ) . singleOverlay ( ) ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> #ifdef JSGC_GENERATIONAL <NEW_LINE> <TAB> void branchPtrInNurseryRange ( Condition cond , Register ptr , Register temp , Label * label ) ; <NEW_LINE> <TAB> void branchValueIsNurseryObject ( Condition cond , ValueOperand value , Register temp , Label * label ) ; <NEW_LINE> #endif <NEW_LINE> } ;
<TAB> if ( ! buf ) <NEW_LINE> <TAB> <TAB> return - ENOMEM ; <NEW_LINE> <START_VULN> <TAB> if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> ret = - EFAULT ; <NEW_LINE> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> }
void hns_nic_net_reset ( struct net_device * ndev ) ; <NEW_LINE> void hns_nic_net_reinit ( struct net_device * netdev ) ; <NEW_LINE> int hns_nic_init_phy ( struct net_device * ndev , struct hnae_handle * h ) ; <NEW_LINE> <START_VULN> int hns_nic_net_xmit_hw ( struct net_device * ndev , <NEW_LINE><TAB> <TAB> <TAB> struct sk_buff * skb , <NEW_LINE><TAB> <TAB> <TAB> struct hns_nic_ring_data * ring_data ) ; <NEW_LINE> <END_VULN> #endif <TAB>
<TAB> if ( preg_options ) { <NEW_LINE> <TAB> <TAB> * preg_options = pce ? pce -> preg_options : 0 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> return pce ? pce -> re : NULL ; <NEW_LINE> }
<TAB> <TAB> return <TAB> NULL ; <NEW_LINE> <TAB> <TAB> } ; <NEW_LINE> <START_VULN> <TAB> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <NEW_LINE> <END_VULN> <TAB> { <TAB> sf_errno = SFE_MALLOC_FAILED ; <NEW_LINE> <TAB> <TAB> return <TAB> NULL ; <NEW_LINE> <TAB> <TAB> } ;
<TAB> <TAB> <TAB> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> i += 2 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> block_length = data [ i ] * 256 + data [ i + 1 ] ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> }
<TAB> <TAB> Token currentToken ; <NEW_LINE> <TAB> <TAB> unsigned lookahead ; <NEW_LINE> <TAB> <TAB> Token lookaheadTokens [ maxLookahead ] ; <NEW_LINE> <TAB> } ; <NEW_LINE> <TAB> void advance ( size_t position ) ; <NEW_LINE> <TAB> void tell ( Position * ) ; <NEW_LINE> <TAB> void seek ( const Position & pos ) ; <NEW_LINE> <START_VULN> <TAB> void seek ( const Position & pos , const TokenStream & other ) ; <NEW_LINE> <END_VULN> <TAB> void positionAfterLastFunctionKeyword ( Position & pos ) ; <NEW_LINE> <TAB> size_t positionToOffset ( const Position & pos ) const { <NEW_LINE> <TAB> <TAB> return pos . buf - userbuf . base ( ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> bool hasSourceMap ( ) const { <NEW_LINE> <TAB> <TAB> return sourceMap != NULL ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 115 2014 / 12 / 16 20 : 53 : 05 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef BUILTIN_ELF
<TAB> if ( skb -> protocol == htons ( ETH_P_IP ) ) <NEW_LINE> <TAB> <TAB> return tcp_v4_do_rcv ( sk , skb ) ; <NEW_LINE> <START_VULN> <TAB> if ( sk_filter ( sk , skb ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> goto discard ;
<TAB> <TAB> <TAB> if ( parse_cookie ( s , p , & s -> cookie_dict ) ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> av_log ( h , AV_LOG_WARNING , "Unable to parse ' % s'\n" , p ) ; <NEW_LINE> <TAB> <TAB> } else if ( ! av_strcasecmp ( tag , "Icy - MetaInt" ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } else if ( ! av_strncasecmp ( tag , "Icy - " , 4 ) ) { <NEW_LINE> <TAB> <TAB> <TAB> if ( ( ret = parse_icy ( s , tag , p ) ) < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return ret ;
<TAB> ( void ) cs ; <NEW_LINE> <TAB> PLUGIN_TRACE ( " [ FD % i ] Mandril validating URL" , cs -> socket ) ; <NEW_LINE> <START_VULN> <TAB> if ( mk_security_check_url ( sr -> uri ) < 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> PLUGIN_TRACE ( " [ FD % i ] Close connection , blocked URL" , cs -> socket ) ; <NEW_LINE> <TAB> <TAB> mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; <NEW_LINE> <TAB> <TAB> return MK_PLUGIN_RET_CLOSE_CONX ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 126 2015 / 11 / 16 16 : 03 : 45 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef BUILTIN_ELF
<TAB> <TAB> <TAB> <TAB> if ( blockp == NULL ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> char errbuff [ 128 ] ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> cli_strerror ( errno , errbuff , sizeof ( errbuff ) ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> cli_dbgmsg ( "cli_scanxar : Can't read % li bytes @ % li , errno : % s . \n" , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> length , at , errbuff ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> rc = CL_EREAD ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> __lzma_wrap_free ( NULL , buff ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> goto exit_tmpfile ;
<TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> size = MIN ( count , self -> buffer_size - self -> buffer_offset ) ; <NEW_LINE><TAB> memcpy ( buf , self -> buffer + self -> buffer_offset , size ) ; <NEW_LINE> <END_VULN> <TAB> if ( size < count && chunk_id + 1 < self -> totalChunks ) { <NEW_LINE> <TAB> <TAB> int tmp_bytes ;
MODULE_PARM_DESC ( dbg , "Boolean to enable debugging ( 0 / 1 == off / on ) " ) ; <NEW_LINE> module_init ( prng_mod_init ) ; <NEW_LINE> module_exit ( prng_mod_fini ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "stdrng" ) ; <NEW_LINE> <END_VULN>
<START_VULN> <TAB> p1 = BuildTestPacket ( id , 0 , 0 , 'A' , 8 ) ; <NEW_LINE> <END_VULN> <TAB> if ( p1 == NULL ) { <NEW_LINE> <TAB> <TAB> goto end ; <NEW_LINE> <TAB> }
<TAB> <TAB> return mask ; <NEW_LINE> <TAB> writable = unix_writable ( sk ) ; <NEW_LINE> <START_VULN> <TAB> other = unix_peer_get ( sk ) ; <NEW_LINE><TAB> if ( other ) { <NEW_LINE><TAB> <TAB> if ( unix_peer ( other ) != sk ) { <NEW_LINE><TAB> <TAB> <TAB> sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ; <NEW_LINE><TAB> <TAB> <TAB> if ( unix_recvq_full ( other ) ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> writable = 0 ; <NEW_LINE><TAB> <TAB> } <NEW_LINE><TAB> <TAB> sock_put ( other ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( writable )
<TAB> <TAB> <TAB> <TAB> <TAB> "recovered\n" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> SAS_ADDR ( task -> dev ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> cmd -> device -> lun ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> sas_eh_defer_cmd ( cmd ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> sas_scsi_clear_queue_lu ( work_q , cmd ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto Again ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> barrier ( ) ; <NEW_LINE> <TAB> if ( ! pte_present ( entry ) ) { <NEW_LINE> <TAB> <TAB> if ( pte_none ( entry ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( vma -> vm_ops ) { <NEW_LINE><TAB> <TAB> <TAB> <TAB> if ( likely ( vma -> vm_ops -> fault ) ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> return do_fault ( mm , vma , address , pte , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> pmd , flags , entry ) ; <NEW_LINE><TAB> <TAB> <TAB> } <NEW_LINE><TAB> <TAB> <TAB> return do_anonymous_page ( mm , vma , address , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> pte , pmd , flags ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> return do_swap_page ( mm , vma , address , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> pte , pmd , flags , entry ) ;
<TAB> int size ; <NEW_LINE> <TAB> syscall_nr = trace_get_syscall_nr ( current , regs ) ; <NEW_LINE> <START_VULN> <TAB> if ( syscall_nr < 0 ) <NEW_LINE> <END_VULN> <TAB> <TAB> return ; <NEW_LINE> <TAB> if ( ! test_bit ( syscall_nr , enabled_perf_exit_syscalls ) ) <NEW_LINE> <TAB> <TAB> return ;
<TAB> <TAB> <TAB> errno = EFTYPE ; <NEW_LINE> <TAB> <TAB> <TAB> return ( size_t ) - 1 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> if ( sid > maxsector ) { <NEW_LINE><TAB> <TAB> <TAB> DPRINTF ( ( "Sector % d > % d\n" , sid , maxsector ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> errno = EFTYPE ; <NEW_LINE> <TAB> <TAB> <TAB> return ( size_t ) - 1 ; <NEW_LINE> <TAB> <TAB> }
<START_VULN> Copyright ( c ) 2000 , 2010 , Oracle and / or its affiliates <NEW_LINE> <END_VULN> <TAB> This program is free software ; you can redistribute it and / or modify <NEW_LINE> <TAB> it under the terms of the GNU General Public License as published by
<TAB> <TAB> <TAB> loff_t * ppos ) <NEW_LINE> { <NEW_LINE> <TAB> struct usb_yurex * dev ; <NEW_LINE> <START_VULN> <TAB> int retval = 0 ; <NEW_LINE><TAB> int bytes_read = 0 ; <NEW_LINE> <END_VULN> <TAB> char in_buffer [ 20 ] ; <NEW_LINE> <TAB> unsigned long flags ;
<TAB> while ( ( item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ) != NULL ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> frag = ( hm_fragment * ) item -> data ; <NEW_LINE><TAB> <TAB> OPENSSL_free ( frag -> fragment ) ; <NEW_LINE><TAB> <TAB> OPENSSL_free ( frag ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> pitem_free ( item ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> }
<TAB> synchronize_rcu ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> mutex_unlock ( & memcg -> thresholds_lock ) ; <NEW_LINE> }
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const struct message_guid * guid ) <NEW_LINE> { <NEW_LINE> <TAB> static char buf [ MAX_MAILBOX_PATH ] ; <NEW_LINE> <START_VULN> <TAB> const char * base ; <NEW_LINE><TAB> <NEW_LINE><TAB> if ( strchr ( part , ' / ' ) ) { <NEW_LINE><TAB> <TAB> base = part ; <NEW_LINE><TAB> } <NEW_LINE><TAB> else { <NEW_LINE><TAB> <TAB> base = isarchive ? config_archivepartitiondir ( part ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> : config_partitiondir ( part ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> assert ( base != NULL ) ;
static __u8 * pl_report_fixup ( struct hid_device * hdev , __u8 * rdesc , <NEW_LINE> <TAB> <TAB> unsigned int * rsize ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && <NEW_LINE> <TAB> <TAB> <TAB> rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) { <NEW_LINE> <TAB> <TAB> hid_info ( hdev , "fixing up Petalynx Maxter Remote report descriptor\n" ) ;
{ <NEW_LINE> <TAB> unsigned int u = 0 ; <NEW_LINE> <TAB> LineContribType * res ; <NEW_LINE> <START_VULN> <TAB> int overflow_error = 0 ; <NEW_LINE> <END_VULN> <TAB> res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; <NEW_LINE> <TAB> if ( ! res ) { <NEW_LINE> <TAB> <TAB> return NULL ;
<TAB> void fStencilOpSeparate ( GLenum face , GLenum sfail , GLenum dpfail , GLenum dppass ) { <NEW_LINE> <TAB> <TAB> BEFORE_GL_CALL ; <NEW_LINE> <TAB> <TAB> mSymbols . fStencilOpSeparate ( face , sfail , dpfail , dppass ) ; <NEW_LINE> <TAB> <TAB> AFTER_GL_CALL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void fTexImage2D ( GLenum target , GLint level , GLint internalformat , GLsizei width , GLsizei height , GLint border , GLenum format , GLenum type , const GLvoid * pixels ) { <NEW_LINE> <TAB> <TAB> BEFORE_GL_CALL ; <NEW_LINE> <START_VULN> <TAB> <TAB> mSymbols . fTexImage2D ( target , level , internalformat , width , height , border , format , type , pixels ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> AFTER_GL_CALL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> void fTexSubImage2D ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLsizei width , GLsizei height , GLenum format , GLenum type , const GLvoid * pixels ) { <NEW_LINE> <TAB> <TAB> BEFORE_GL_CALL ; <NEW_LINE> <TAB> <TAB> mSymbols . fTexSubImage2D ( target , level , xoffset , yoffset , width , height , format , type , pixels ) ; <NEW_LINE> <TAB> <TAB> AFTER_GL_CALL ; <NEW_LINE> <TAB> }
<TAB> hid -> version = req -> version ; <NEW_LINE> <TAB> hid -> country = req -> country ; <NEW_LINE> <START_VULN> <TAB> strncpy ( hid -> name , req -> name , 128 ) ; <NEW_LINE> <END_VULN> <TAB> snprintf ( hid -> phys , sizeof ( hid -> phys ) , " % pMR" , <NEW_LINE> <TAB> <TAB> & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ;
class nsGIFDecoder2 : public Decoder <NEW_LINE> { <NEW_LINE> public : <NEW_LINE> nsGIFDecoder2 ( RasterImage & aImage ) ; <NEW_LINE> ~ nsGIFDecoder2 ( ) ; <NEW_LINE> <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> virtual void FinishInternal ( ) ; <NEW_LINE> virtual Telemetry : : ID SpeedHistogram ( ) ; <NEW_LINE> private : <NEW_LINE> void BeginGIF ( ) ;
<TAB> if ( pv -> context -> extradata == NULL ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( pv -> parser == NULL || pv -> parser == NULL || <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> pv -> parser -> parser -> split == NULL ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> return 0 ;
<TAB> <TAB> <TAB> if ( ch == ' % ' ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> state = DP_S_FLAGS ; <NEW_LINE> <TAB> <TAB> <TAB> else <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> doapr_outch ( sbuffer , buffer , & currlen , maxlen , ch ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ch = * format + + ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> case DP_S_FLAGS :
<TAB> ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <NEW_LINE> <START_VULN> <TAB> if ( ! ctx -> established ) <NEW_LINE> <END_VULN> <TAB> <TAB> return GSS_S_NO_CONTEXT ; <NEW_LINE> <TAB> for ( i = 0 ; i < sizeof ( krb5_gss_inquire_sec_context_by_oid_ops ) /
<TAB> default : <NEW_LINE> <TAB> <TAB> break ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> if ( TIFFGetField ( tiff , 37706 , & length , & tietz ) == 1 ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> ( void ) FormatLocaleString ( message , MagickPathExtent , " % lu" , tietz [ 0 ] ) ; <NEW_LINE> <TAB> ( void ) SetImageProperty ( image , "tiff : tietz_offset" , message , exception ) ;
<TAB> __be16 <TAB> <TAB> <TAB> inet_sport ; <NEW_LINE> <TAB> __u16 <TAB> <TAB> <TAB> inet_id ; <NEW_LINE> <START_VULN> <TAB> struct ip_options <TAB> * opt ; <NEW_LINE> <END_VULN> <TAB> __u8 <TAB> <TAB> <TAB> tos ; <NEW_LINE> <TAB> __u8 <TAB> <TAB> <TAB> min_ttl ; <NEW_LINE> <TAB> __u8 <TAB> <TAB> <TAB> mc_ttl ;
<TAB> } <NEW_LINE> <TAB> fname = Z_STRVAL_P ( value ) ; <NEW_LINE> <START_VULN> <TAB> fname_len = ( php_stat_len ) Z_STRLEN_P ( value ) ; <NEW_LINE> <END_VULN> phar_spl_fileinfo : <NEW_LINE> <TAB> if ( base_len ) {
<START_VULN> enum { FIXNUM_WIDTH = ( 8 * sizeof ( native_int ) ) - TAG_SHIFT - 1 } ; <NEW_LINE> <END_VULN> typedef enum
namespace dom { <NEW_LINE> class DOMCursor : public DOMRequest <NEW_LINE> <TAB> <TAB> <TAB> <TAB> , public nsIDOMDOMCursor <NEW_LINE> { <NEW_LINE> public : <NEW_LINE> NS_DECL_ISUPPORTS_INHERITED <NEW_LINE> NS_DECL_NSIDOMDOMCURSOR <NEW_LINE> <START_VULN> NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED ( DOMCursor , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> DOMRequest ) <NEW_LINE> <END_VULN> DOMCursor ( nsIDOMWindow * aWindow , nsICursorContinueCallback * aCallback ) ; <NEW_LINE> virtual JSObject * WrapObject ( JSContext * aCx , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JS : : Handle < JSObject * > aScope ) MOZ_OVERRIDE ; <NEW_LINE> bool Done ( ) const <NEW_LINE> {
#endif <NEW_LINE> #ifdef HAVE_GNUTLS_GNUTLS_H <NEW_LINE> <START_VULN> const int tls_kx_order [ ] = { <NEW_LINE> <END_VULN> <TAB> GNUTLS_KX_ANON_DH , <NEW_LINE> <TAB> GNUTLS_KX_DHE_RSA , <NEW_LINE> <TAB> GNUTLS_KX_DHE_DSS ,
<TAB> OPT_HELP , <NEW_LINE> <TAB> OPT_VERSION , <NEW_LINE> <TAB> OPT_VERBOSE , <NEW_LINE> <START_VULN> <TAB> OPT_INFILE <NEW_LINE> <END_VULN> } optid_t ; <NEW_LINE> <TAB> while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {
#define base64val ( c ) Index64 [ ( unsigned int ) ( c ) ] <NEW_LINE> size_t mutt_b64_encode ( char * out , const char * cin , size_t len , size_t olen ) ; <NEW_LINE> <START_VULN> int mutt_b64_decode ( char * out , const char * in ) ; <NEW_LINE> <END_VULN> #endif
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : psychoacoustics not including preecho <NEW_LINE> <START_VULN> last mod : $ Id : psy . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include "vorbis / codec . h" <NEW_LINE> #include "codec_internal . h"
<TAB> Com_Printf ( " -- -- - Initializing Renderer -- -- \n" ) ; <NEW_LINE> #ifdef USE_RENDERER_DLOPEN <NEW_LINE> <START_VULN> <TAB> cl_renderer = Cvar_Get ( "cl_renderer" , "opengl1" , CVAR_ARCHIVE | CVAR_LATCH ) ; <NEW_LINE> <END_VULN> <TAB> Com_sprintf ( dllName , sizeof ( dllName ) , "renderer_mp_ % s_" ARCH_STRING DLL_EXT , cl_renderer -> string ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "MD5 Secure Hash Algorithm , sparc64 md5 opcode accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "md5" ) ; <NEW_LINE> <END_VULN> #include "crop_devid . c"
<TAB> <TAB> <TAB> session_keyring = <NEW_LINE> <TAB> <TAB> <TAB> <TAB> keyring_alloc ( buf , user -> uid , INVALID_GID , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> cred , user_keyring_perm , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> KEY_ALLOC_IN_QUOTA , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> NULL , NULL ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( IS_ERR ( session_keyring ) ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ret = PTR_ERR ( session_keyring ) ;
<TAB> dvb_usbv2_exit ( d ) ; <NEW_LINE> <START_VULN> <TAB> dev_info ( & dev , " % s : ' % s' successfully deinitialized and disconnected\n" , <NEW_LINE><TAB> <TAB> <TAB> KBUILD_MODNAME , name ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> EXPORT_SYMBOL ( dvb_usbv2_disconnect ) ;
<TAB> <TAB> if ( snprintf ( path , sizeof ( path ) , " % s / % s - coredump" , g_settings_dump_location , last_slash ) >= sizeof ( path ) ) <NEW_LINE> <TAB> <TAB> <TAB> error_msg_and_die ( "Error saving ' % s' : truncated long file path" , path ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; <NEW_LINE> <TAB> <TAB> if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) <NEW_LINE> <TAB> <TAB> {
<TAB> <TAB> <TAB> cwd [ 2 ] = '\0' ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> <TAB> <TAB> cwd_skip = ( int ) strlen ( cwd ) + 1 ; <NEW_LINE> <END_VULN> <TAB> <TAB> snprintf ( work_pattern , MAXPATHLEN , " % s % c % s" , cwd , DEFAULT_SLASH , pattern ) ; <NEW_LINE> <TAB> <TAB> pattern = work_pattern ;
{ <NEW_LINE> <TAB> void ** ptrptr = ptr ; <NEW_LINE> <TAB> * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; <NEW_LINE> <START_VULN> <TAB> if ( ! * ptrptr && ! ( nmemb && size ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return AVERROR ( ENOMEM ) ; <NEW_LINE> <TAB> return 0 ; <NEW_LINE> }
#include < linux / init . h > <NEW_LINE> #include < linux / fs . h > <NEW_LINE> #include < linux / slab . h > <NEW_LINE> <START_VULN> #include < linux / mbcache . h > <NEW_LINE> <END_VULN> #include < linux / quotaops . h > <NEW_LINE> #include "ext4_jbd2 . h" <NEW_LINE> #include "ext4 . h"
<TAB> struct mm_struct * mm = file -> private_data ; <NEW_LINE> <TAB> unsigned long env_start , env_end ; <NEW_LINE> <START_VULN> <TAB> if ( ! mm ) <NEW_LINE> <END_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> page = ( char * ) __get_free_page ( GFP_TEMPORARY ) ;
<TAB> struct timespec tstamp ; <TAB> <TAB> <NEW_LINE> <TAB> wait_queue_head_t qchange_sleep ; <NEW_LINE> <TAB> struct fasync_struct * fasync ; <NEW_LINE> <START_VULN> <TAB> struct mutex tread_sem ; <NEW_LINE> <END_VULN> } ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : floor backend 0 implementation <NEW_LINE> <START_VULN> last mod : $ Id : floor0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
<TAB> <TAB> break ; <NEW_LINE> <TAB> case SO_PASSCRED : <NEW_LINE> <START_VULN> <TAB> <TAB> v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> case SO_PEERCRED :
j = m + 1 ; <NEW_LINE> while ( j -- ) { <NEW_LINE> <TAB> double d = 0 ; <NEW_LINE> <TAB> for ( i = j ; i < n ; i + + ) d += ( double ) data [ i ] * data [ i - j ] ; <NEW_LINE> <TAB> aut [ j ] = d ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> error = aut [ 0 ] * ( 1 . + 1e - 10 ) ; <NEW_LINE> epsilon = 1e - 9 * aut [ 0 ] + 1e - 10 ; <NEW_LINE> for ( i = 0 ; i < m ; i + + ) { <NEW_LINE> <TAB> double r = - aut [ i + 1 ] ;
<TAB> <TAB> dual_timestamp_get ( & t -> last_trigger ) ; <NEW_LINE> <TAB> <TAB> if ( t -> stamp_path ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> timer_set_state ( t , TIMER_RUNNING ) ; <NEW_LINE> <TAB> <TAB> return ;
<TAB> <TAB> call_rcu_bh ( & p -> rcu , br_multicast_free_pg ) ; <NEW_LINE> <TAB> <TAB> err = 0 ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! mp -> ports && ! mp -> mglist && <NEW_LINE> <END_VULN> <TAB> <TAB> netif_running ( br -> dev ) ) <NEW_LINE> <TAB> <TAB> <TAB> mod_timer ( & mp -> timer , jiffies ) ; <NEW_LINE> <TAB> <TAB> break ;
<TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> case LOCAL_GL_DEPTH_STENCIL_ATTACHMENT : <NEW_LINE> <TAB> <TAB> <TAB> mDepthStencilAttachment . SetRenderbuffer ( wrb ) ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> default : <NEW_LINE> <TAB> <TAB> <TAB> if ( attachment != LOCAL_GL_COLOR_ATTACHMENT0 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return mContext -> ErrorInvalidEnumInfo ( "framebufferRenderbuffer : attachment" , attachment ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( ! isNull ) { <NEW_LINE><TAB> <TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> <TAB> setDimensions ( wrb ) ; <NEW_LINE><TAB> <TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> mColorAttachment . SetRenderbuffer ( wrb ) ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> mContext -> MakeContextCurrent ( ) ; <NEW_LINE> <TAB> <TAB> if ( attachment == LOCAL_GL_DEPTH_STENCIL_ATTACHMENT ) { <NEW_LINE> <TAB> <TAB> <TAB> mContext -> gl -> fFramebufferRenderbuffer ( target , LOCAL_GL_DEPTH_ATTACHMENT , rbtarget , renderbuffername ) ; <NEW_LINE> <TAB> <TAB> <TAB> mContext -> gl -> fFramebufferRenderbuffer ( target , LOCAL_GL_STENCIL_ATTACHMENT , rbtarget , renderbuffername ) ;
<TAB> no_empty = flags & PREG_SPLIT_NO_EMPTY ; <NEW_LINE> <TAB> delim_capture = flags & PREG_SPLIT_DELIM_CAPTURE ; <NEW_LINE> <TAB> offset_capture = flags & PREG_SPLIT_OFFSET_CAPTURE ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> if ( limit_val == 0 ) { <NEW_LINE> <TAB> <TAB> limit_val = - 1 ; <NEW_LINE> <TAB> }
<TAB> { STATE_AGGR_R0 , STATE_AGGR_R1 , <NEW_LINE> <TAB> SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY , <NEW_LINE> <TAB> P ( SA ) | P ( KE ) | P ( NONCE ) | P ( ID ) , P ( VID ) | P ( NATD_RFC ) , PT ( NONE ) , <NEW_LINE> <START_VULN> <TAB> EVENT_v1_RETRANSMIT , aggr_inI1_outR1 } , <NEW_LINE> <END_VULN>
uint8_t zrtpkeyi [ 16 ] = { 0x22 , 0xf6 , 0xea , 0xaa , 0xa4 , 0xad , 0x53 , 0x30 , 0x71 , 0x97 , 0xcc , 0x68 , 0x6b , 0xb0 , 0xcb , 0x55 } ; <NEW_LINE> uint8_t zrtpkeyr [ 16 ] = { 0x09 , 0x50 , 0xcd , 0x9e , 0xc2 , 0x78 , 0x54 , 0x31 , 0x93 , 0x2e , 0x99 , 0x31 , 0x15 , 0x58 , 0xd0 , 0x2a } ; <NEW_LINE> <START_VULN> void test_parser ( void ) { <NEW_LINE> <END_VULN> <TAB> int i , retval ; <NEW_LINE> <TAB> bzrtpPacket_t * zrtpPacket ;
int CVE_2014_8541_ff_mjpeg_decode_sof ( MJpegDecodeContext * s ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> int len , nb_components , i , width , height , pix_fmt_id , ret ; <NEW_LINE> <END_VULN> <TAB> int h_count [ MAX_COMPONENTS ] ; <NEW_LINE> <TAB> int v_count [ MAX_COMPONENTS ] ;
static const struct driver_info wwan_info = { <NEW_LINE> <TAB> . description = "Mobile Broadband Network Device" , <NEW_LINE> <TAB> . flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> | FLAG_WWAN , <NEW_LINE> <END_VULN> <TAB> . bind = cdc_ncm_bind , <NEW_LINE> <TAB> . unbind = cdc_ncm_unbind , <NEW_LINE> <TAB> . manage_power = usbnet_manage_power ,
static void gdCtxPrintf ( gdIOCtx * out , const char * format , . . . ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> char buf [ 4096 ] ; <NEW_LINE> <END_VULN> <TAB> int len ; <NEW_LINE> <TAB> va_list args ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA512 Secure Hash Algorithm , Supplemental SSE3 accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha512" ) ; <NEW_LINE>MODULE_ALIAS ( "sha384" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> return KADM5_BAD_MASK ; <NEW_LINE> <TAB> if ( ( mask & ~ ALL_PRINC_MASK ) ) <NEW_LINE> <TAB> <TAB> return KADM5_BAD_MASK ; <NEW_LINE> <TAB> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <NEW_LINE> <TAB> <TAB> return KADM5_BAD_MASK ; <NEW_LINE> <START_VULN> <TAB> if ( entry == ( kadm5_principal_ent_t ) NULL ) <NEW_LINE><TAB> <TAB> return EINVAL ; <NEW_LINE> <END_VULN> <TAB> if ( mask & KADM5_TL_DATA ) { <NEW_LINE> <TAB> <TAB> tl_data_orig = entry -> tl_data ; <NEW_LINE> <TAB> <TAB> while ( tl_data_orig ) {
<TAB> break ; <NEW_LINE> <TAB> case 'w' : <NEW_LINE> <START_VULN> <TAB> <TAB> fd = open ( filename , O_WRONLY | O_TRUNC | O_CREAT | O_LARGEFILE | O_BINARY , 0666 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> case 's' :
<TAB> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> mag <<= bgshift ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> mask = ( 1 << numbps ) - 1 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> most - significant bit planes introduced by ROI shifting .
<TAB> <TAB> } <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> state -> object_nl_len = len ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return Qnil ;
<TAB> <TAB> return 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> mpz_init ( temp ) ; <NEW_LINE> <START_VULN> <TAB> mpz_powm ( r , key -> g , k , key -> p ) ; <NEW_LINE> <END_VULN> <TAB> mpz_mod ( r , r , key -> q ) ; <NEW_LINE> <TAB> mpz_invert ( s , k , key -> q ) ; <NEW_LINE> <TAB> mpz_mul ( temp , key -> x , r ) ;
<TAB> <TAB> return rv ; <NEW_LINE> <TAB> case FILE_USE : <NEW_LINE> <START_VULN> <TAB> <TAB> if ( nbytes < offset ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> <TAB> sbuf = m -> value . s ; <NEW_LINE> <TAB> <TAB> if ( * sbuf == ' ^ ' ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : lookup based functions <NEW_LINE> <START_VULN> last mod : $ Id : lookup . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_LOOKUP_H_ <NEW_LINE> #ifdef FLOAT_LOOKUP <NEW_LINE> extern float vorbis_coslook ( float a ) ; <NEW_LINE> extern float vorbis_invsqlook ( float a ) ;
<TAB> <TAB> eindex = handle ; <NEW_LINE> <TAB> estr -> event_source = 0 ; <NEW_LINE> <START_VULN> <TAB> if ( eindex >= MAX_EVENTS ) { <NEW_LINE> <END_VULN> <TAB> <TAB> spin_unlock_irqrestore ( & ha -> smp_lock , flags ) ; <NEW_LINE> <TAB> <TAB> return eindex ; <NEW_LINE> <TAB> }
bool WantNativeAddressInfo ( JSContext * ) ; <NEW_LINE> bool EnterScript ( JSContext * , JSScript * , JSFunction * , StackFrame * ) ; <NEW_LINE> <START_VULN> bool ExitScript ( JSContext * , JSScript * , JSFunction * , AbstractFramePtr ) ; <NEW_LINE>bool ExitScript ( JSContext * , JSScript * , JSFunction * , StackFrame * ) ; <NEW_LINE> <END_VULN> bool StartExecution ( JSScript * script ) ; <NEW_LINE> bool StopExecution ( JSScript * script ) ;
<TAB> REG ( "coredump_filter" , S_IRUGO|S_IWUSR , proc_coredump_filter_operations ) , <NEW_LINE> #endif <NEW_LINE> #ifdef CONFIG_TASK_IO_ACCOUNTING <NEW_LINE> <START_VULN> <TAB> INF ( "io" , <TAB> S_IRUGO , proc_tgid_io_accounting ) , <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef CONFIG_HARDWALL <NEW_LINE> <TAB> INF ( "hardwall" , S_IRUGO , proc_pid_hardwall ) ,
<TAB> <TAB> ast_mutex_unlock ( & iaxsl [ callno ] ) ; <NEW_LINE> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> default : <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> <TAB> unsigned short callno = PTR_TO_CALLNO ( c -> tech_pvt ) ; <NEW_LINE> <TAB> <TAB> struct chan_iax2_pvt * pvt ;
<TAB> <TAB> <TAB> <TAB> <TAB> u32 __user * optval , int __user * optlen ) <NEW_LINE> { <NEW_LINE> <TAB> int rc = - ENOPROTOOPT ; <NEW_LINE> <START_VULN> <TAB> if ( ccid -> ccid_ops -> ccid_hc_rx_getsockopt != NULL ) <NEW_LINE> <END_VULN> <TAB> <TAB> rc = ccid -> ccid_ops -> ccid_hc_rx_getsockopt ( sk , optname , len , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> optval , optlen ) ; <NEW_LINE> <TAB> return rc ;
<TAB> <TAB> stub = phar_create_default_stub ( index , webindex , & stub_len , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( stub ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> efree ( stub ) ;
run_test ( & test2 , test2_result ) ; <NEW_LINE> fprintf ( stderr , "OK\nDequant test 3 . . . " ) ; <NEW_LINE> run_test ( & test3 , test3_result ) ; <NEW_LINE> fprintf ( stderr , "OK\nDequant test 4 . . . " ) ; <NEW_LINE> run_test ( & test4 , test4_result ) ; <NEW_LINE> fprintf ( stderr , "OK\nDequant test 5 . . . " ) ; <NEW_LINE> run_test ( & test5 , test5_result ) ; <NEW_LINE> fprintf ( stderr , "OK\n\n" ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return ( 0 ) ; <NEW_LINE> } <NEW_LINE> #endif
<TAB> <TAB> } <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> if ( state -> space_before ) ruby_xfree ( state -> space_before ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> state -> space_before = strdup ( RSTRING_PTR ( space_before ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> state -> space_before_len = len ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return Qnil ;
#if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) <NEW_LINE> <TAB> <TAB> if ( op - m_pos >= 8 ) { <NEW_LINE> <TAB> <TAB> <TAB> unsigned char * oe = op + t ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( likely ( HAVE_OP ( t + 15 ) ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> do { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> COPY8 ( op , m_pos ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> op += 8 ;
{ <NEW_LINE> <TAB> OPJ_UINT32 l_data_size ; <NEW_LINE> <START_VULN> <TAB> l_data_size = ( OPJ_UINT32 ) ( ( p_code_block -> x1 - p_code_block -> x0 ) * <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ( p_code_block -> y1 - p_code_block -> y0 ) * ( OPJ_INT32 ) sizeof ( OPJ_UINT32 ) ) ; <NEW_LINE> <END_VULN> <TAB> if ( l_data_size > p_code_block -> data_size ) { <NEW_LINE> <TAB> <TAB> if ( p_code_block -> data ) {
<TAB> CHECK ( receiver_ != NULL ) <NEW_LINE> <TAB> <TAB> << "create receiver socket failed : " << zmq_strerror ( errno ) ; <NEW_LINE> <TAB> int local = GetEnv ( "DMLC_LOCAL" , 0 ) ; <NEW_LINE> <START_VULN> <TAB> std : : string addr = local ? "ipc : <NEW_LINE> <END_VULN> <TAB> int port = node . port ; <NEW_LINE> <TAB> unsigned seed = static_cast < unsigned > ( time ( NULL ) + port ) ; <NEW_LINE> <TAB> for ( int i = 0 ; i < max_retry + 1 ; + + i ) {
<TAB> <TAB> if ( len ) len -- ; <NEW_LINE> <TAB> <TAB> if ( ! strncmp ( rock -> namespace -> prefix [ NAMESPACE_USER ] , commonpat , MIN ( len , prefixlen ) ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( prefixlen < len ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> strlcpy ( domainpat + domainlen , "user . " , sizeof ( domainpat ) - domainlen ) ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> int size ; <NEW_LINE> <TAB> syscall_nr = trace_get_syscall_nr ( current , regs ) ; <NEW_LINE> <START_VULN> <TAB> if ( syscall_nr < 0 ) <NEW_LINE> <END_VULN> <TAB> <TAB> return ; <NEW_LINE> <TAB> if ( ! test_bit ( syscall_nr , enabled_perf_exit_syscalls ) ) <NEW_LINE> <TAB> <TAB> return ; <NEW_LINE> commit 086ba77a6db00ed858ff07451bedee197df868c9 <NEW_LINE> Author : Rabin Vincent < rabin@rab . in > <NEW_LINE> Date : Wed Oct 29 23 : 06 : 58 2014 + 0100 <NEW_LINE> <TAB> tracing / syscalls : Ignore numbers outside NR_syscalls' range <NEW_LINE> <TAB> ARM has some private syscalls ( for example , set_tls ( 2 ) ) which lie <NEW_LINE> <TAB> outside the range of NR_syscalls . If any of these are called while <NEW_LINE> <TAB> syscall tracing is being performed , out - of - bounds array access will <NEW_LINE> <TAB> occur in the ftrace and perf sys_ { enter , exit } handlers . <NEW_LINE> <TAB> # trace - cmd record - e raw_syscalls : * true && trace - cmd report <NEW_LINE> <TAB> . . . <NEW_LINE> <TAB> true - 653 [ 000 ] 384 . 675777 : sys_enter : NR 192 ( 0 , 1000 , 3 , 4000022 , ffffffff , 0 ) <NEW_LINE> <TAB> true - 653 [ 000 ] 384 . 675812 : sys_exit : NR 192 = 1995915264 <NEW_LINE> <TAB> true - 653 [ 000 ] 384 . 675971 : sys_enter : NR 983045 ( 76f74480 , 76f74000 , 76f74b28 , 76f74480 , 76f76f74 , 1 ) <NEW_LINE> <TAB> true - 653 [ 000 ] 384 . 675988 : sys_exit : NR 983045 = 0 <NEW_LINE> <TAB> . . . <NEW_LINE> <TAB> # trace - cmd record - e syscalls : * true <NEW_LINE> <TAB> [ 17 . 289329 ] Unable to handle kernel paging request at virtual address aaaaaace <NEW_LINE> <TAB> [ 17 . 289590 ] pgd = 9e71c000 <NEW_LINE> <TAB> [ 17 . 289696 ] [ aaaaaace ] * pgd = 00000000 <NEW_LINE> <TAB> [ 17 . 289985 ] Internal error : Oops : 5 [ #1 ] PREEMPT SMP ARM <NEW_LINE> <TAB> [ 17 . 290169 ] Modules linked in : <NEW_LINE> <TAB> [ 17 . 290391 ] CPU : 0 PID : 704 Comm : true Not tainted 3 . 18 . 0 - rc2 + #21 <NEW_LINE> <TAB> [ 17 . 290585 ] task : 9f4dab00 ti : 9e710000 task . ti : 9e710000 <NEW_LINE> <TAB> [ 17 . 290747 ] PC is at ftrace_syscall_enter + 0x48 / 0x1f8 <NEW_LINE> <TAB> [ 17 . 290866 ] LR is at syscall_trace_enter + 0x124 / 0x184 <NEW_LINE> <TAB> Fix this by ignoring out - of - NR_syscalls - bounds syscall numbers . <NEW_LINE> <TAB> Commit cd0980fc8add "tracing : Check invalid syscall nr while tracing syscalls" <NEW_LINE> <TAB> added the check for less than zero , but it should have also checked <NEW_LINE> <TAB> for greater than NR_syscalls . <NEW_LINE> <TAB> Link : http : <NEW_LINE> <TAB> Fixes : cd0980fc8add "tracing : Check invalid syscall nr while tracing syscalls" <NEW_LINE> <TAB> Cc : stable@vger . kernel . org # 2 . 6 . 33 + <NEW_LINE> <TAB> Signed - off - by : Rabin Vincent < rabin@rab . in > <NEW_LINE> <TAB> Signed - off - by : Steven Rostedt < rostedt@goodmis . org >
<TAB> if ( page == NULL ) <NEW_LINE> <TAB> page = http_request_get_query_string ( req ) ; <NEW_LINE> <START_VULN> <TAB> if ( page && ( access ( page , R_OK ) == 0 ) ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> http_response_printf ( res , " % s" , file_read ( page ) ) ; <NEW_LINE> <TAB> http_response_send ( res ) ;
class nsHttpRequestHead <NEW_LINE> { <NEW_LINE> public : <NEW_LINE> <START_VULN> <TAB> nsHttpRequestHead ( ) : mHeaders ( nsHttpHeaderArray : : HTTP_REQUEST_HEADERS ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> , mMethod ( nsHttp : : Get ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> , mVersion ( NS_HTTP_VERSION_1_1 ) { } <NEW_LINE> <END_VULN> <TAB> ~ nsHttpRequestHead ( ) { } <NEW_LINE> <TAB> void SetMethod ( nsHttpAtom method ) { mMethod = method ; } <NEW_LINE> <TAB> void SetVersion ( nsHttpVersion version ) { mVersion = version ; } <NEW_LINE> <TAB> void SetRequestURI ( const nsCSubstring & s ) { mRequestURI = s ; } <NEW_LINE> <TAB> nsHttpHeaderArray & Headers ( ) { return mHeaders ; } <NEW_LINE> <TAB> nsHttpAtom Method ( ) { return mMethod ; }
<TAB> if ( type != M_FS_TYPE_DIR ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( M_fs_perms_can_access ( p2 , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) <NEW_LINE><TAB> <TAB> { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ret = M_FALSE ; <NEW_LINE> <TAB> <TAB> <TAB> goto done ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> pixGetDimensions ( pix , & w , NULL , & d ) ; <NEW_LINE> <TAB> <TAB> factor = ( l_float32 ) thumbwidth / ( l_float32 ) w ; <NEW_LINE> <TAB> <TAB> pixthumb = pixScale ( pix , factor , factor ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> sprintf ( charbuf , " % s_thumb_ % 03d" , rootname , index ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> sarrayAddString ( sathumbs , charbuf , L_COPY ) ; <NEW_LINE> <TAB> <TAB> outname = genPathname ( dirout , charbuf ) ; <NEW_LINE> <TAB> <TAB> WriteFormattedPix ( outname , pixthumb ) ;
#define INIT_STRUCT_PID { <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <TAB> . count <TAB> <TAB> = ATOMIC_INIT ( 1 ) , <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <TAB> . tasks <TAB> <TAB> = { <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <START_VULN> <TAB> <TAB> { . first = & init_task . pids [ PIDTYPE_PID ] . node } , <TAB> <TAB> \ <NEW_LINE><TAB> <TAB> { . first = & init_task . pids [ PIDTYPE_PGID ] . node } , <TAB> \ <NEW_LINE><TAB> <TAB> { . first = & init_task . pids [ PIDTYPE_SID ] . node } , <TAB> <TAB> \ <NEW_LINE> <END_VULN> <TAB> } , <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <TAB> . level <TAB> <TAB> = 0 , <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <TAB> . numbers <TAB> = { { <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> \
static inline int pmd_present ( pmd_t pmd ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return pmd_flags ( pmd ) & _PAGE_PRESENT ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline int pmd_none ( pmd_t pmd )
extern int <TAB> <TAB> ip_build_and_send_pkt ( struct sk_buff * skb , struct sock * sk , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> __be32 saddr , __be32 daddr , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> struct ip_options * opt ) ; <NEW_LINE> <END_VULN> extern int <TAB> <TAB> ip_rcv ( struct sk_buff * skb , struct net_device * dev , <NEW_LINE> <TAB> <TAB> <TAB> struct packet_type * pt , struct net_device * orig_dev ) ; <NEW_LINE> extern int <TAB> <TAB> ip_local_deliver ( struct sk_buff * skb ) ;
void * jas_malloc ( size_t size ) <NEW_LINE> { <NEW_LINE> <TAB> void * result ; <NEW_LINE> <START_VULN> <TAB> JAS_DBGLOG ( 101 , ( "jas_malloc called with % zu\n" , size ) ) ; <NEW_LINE> <END_VULN> <TAB> result = malloc ( size ) ; <NEW_LINE> <TAB> JAS_DBGLOG ( 100 , ( "jas_malloc ( % zu ) -> % p\n" , size , result ) ) ; <NEW_LINE> <TAB> return result ;
<TAB> if ( ! p -> leave_spinning ) <NEW_LINE> <TAB> <TAB> btrfs_set_path_blocking ( p ) ; <NEW_LINE> <START_VULN> <TAB> if ( ret < 0 ) <NEW_LINE> <END_VULN> <TAB> <TAB> btrfs_release_path ( p ) ; <NEW_LINE> <TAB> return ret ; <NEW_LINE> }
<TAB> bool mSuppressEOF ; <NEW_LINE> <TAB> bool mReadingFromStage ; <NEW_LINE> <TAB> nsTArray < nsHtml5TreeOperation > mOpQueue ; <NEW_LINE> <TAB> nsTArray < nsIContentPtr > mElementsSeenInThisAppendBatch ; <NEW_LINE> <TAB> nsTArray < nsHtml5PendingNotification > mPendingNotifications ; <NEW_LINE> <TAB> nsHtml5StreamParser * mStreamParser ; <NEW_LINE> <START_VULN> <TAB> nsCOMArray < nsIContent > mOwnedElements ; <NEW_LINE> <END_VULN> <TAB> nsTHashtable < nsCStringHashKey > mPreloadedURLs ; <NEW_LINE> <TAB> nsCOMPtr < nsIURI > mSpeculationBaseURI ;
<TAB> void Revoke ( ) { <NEW_LINE> <TAB> if ( mPresShell ) { <NEW_LINE> <TAB> <TAB> mPresShell -> GetPresContext ( ) -> RefreshDriver ( ) -> <NEW_LINE> <TAB> <TAB> RemoveRefreshObserver ( this , Flush_Display ) ; <NEW_LINE> <TAB> <TAB> mPresShell = nullptr ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> virtual void WillRefresh ( mozilla : : TimeStamp aTime ) MOZ_OVERRIDE { <NEW_LINE> <START_VULN> <TAB> if ( mPresShell ) <NEW_LINE><TAB> <TAB> mPresShell -> ProcessSynthMouseMoveEvent ( mFromScroll ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> private : <NEW_LINE> <TAB> PresShell * mPresShell ; <NEW_LINE> <TAB> bool mFromScroll ; <NEW_LINE> } ; <NEW_LINE> void ProcessSynthMouseMoveEvent ( bool aFromScroll ) ; <NEW_LINE> void QueryIsActive ( ) ;
<TAB> jsbytecode * nextpc , * testpc ; <NEW_LINE> <TAB> REOp nextop ; <NEW_LINE> <TAB> RECapture * cap ; <NEW_LINE> <START_VULN> <TAB> REProgState * curState ; <NEW_LINE> <END_VULN> <TAB> const jschar * startcp ; <NEW_LINE> <TAB> size_t parenIndex , k ; <NEW_LINE> <TAB> size_t parenSoFar = 0 ;
<TAB> . open <TAB> <TAB> = ftrace_graph_open , <NEW_LINE> <TAB> . read <TAB> <TAB> = seq_read , <NEW_LINE> <TAB> . write <TAB> <TAB> = ftrace_graph_write , <NEW_LINE> <TAB> . release <TAB> = ftrace_graph_release , <NEW_LINE> <START_VULN> <TAB> . llseek <TAB> <TAB> = seq_lseek , <NEW_LINE> <END_VULN> } ; <NEW_LINE> #endif
<TAB> u32 mask = 0 ; <NEW_LINE> <TAB> int err ; <NEW_LINE> <START_VULN> <TAB> mcryptd_check_internal ( tb , & type , & mask ) ; <NEW_LINE> <END_VULN> <TAB> halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ; <NEW_LINE> <TAB> if ( IS_ERR ( halg ) )
static RList * r_bin_wasm_get_global_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { <NEW_LINE> <TAB> RList * ret = NULL ; <NEW_LINE> <TAB> RBinWasmGlobalEntry * ptr = NULL ; <NEW_LINE> <START_VULN> <TAB> int buflen = bin -> buf -> length ; <NEW_LINE><TAB> if ( sec -> payload_data + 32 > buflen ) { <NEW_LINE><TAB> <TAB> return NULL ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { <NEW_LINE> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <NEW_LINE> <TAB> ut32 len = sec -> payload_len ; <NEW_LINE> <TAB> ut32 count = sec -> count ; <NEW_LINE> <TAB> ut32 i = 0 , r = 0 ;
<TAB> if ( sx25 ) { <NEW_LINE> <TAB> <TAB> sx25 -> sx25_family = AF_X25 ; <NEW_LINE> <TAB> <TAB> sx25 -> sx25_addr = x25 -> dest_addr ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> msg -> msg_namelen = sizeof ( struct sockaddr_x25 ) ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> x25_check_rbuf ( sk ) ; <NEW_LINE> <TAB> rc = copied ; <NEW_LINE> out_free_dgram :
<TAB> <TAB> sibling = fn -> leaf ; <NEW_LINE> <TAB> <TAB> while ( sibling ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( sibling -> rt6i_metric == rt -> rt6i_metric ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> list_add_tail ( & rt -> rt6i_siblings , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> & sibling -> rt6i_siblings ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> break ;
<TAB> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> fit_valueB [ ln ] = ly0 ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ln == 0 ) fit_valueA [ ln ] = ly0 ; <NEW_LINE> <TAB> <TAB> <TAB> fit_valueA [ i ] = ly1 ; <NEW_LINE> <TAB> <TAB> <TAB> fit_valueB [ i ] = hy0 ; <NEW_LINE> <TAB> <TAB> <TAB> fit_valueA [ hn ] = hy1 ; <NEW_LINE> <TAB> <TAB> <TAB> if ( hn == 1 ) fit_valueB [ hn ] = hy1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( ly1 >= 0 || hy0 >= 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> for ( j = sortpos - 1 ; j >= 0 ; j -- ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( hineighbor [ j ] == hn ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> hineighbor [ j ] = i ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> else <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> for ( j = sortpos + 1 ; j < posts ; j + + )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : PCM data envelope analysis and manipulation <NEW_LINE> <START_VULN> last mod : $ Id : envelope . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_ENVELOPE_ <NEW_LINE> #define _V_ENVELOPE_ <NEW_LINE> #include "mdct . h"
<TAB> sk2 = newsock -> sk ; <NEW_LINE> <TAB> ask2 = alg_sk ( sk2 ) ; <NEW_LINE> <TAB> ctx2 = ask2 -> private ; <NEW_LINE> <START_VULN> <TAB> ctx2 -> more = 1 ; <NEW_LINE> <END_VULN> <TAB> err = crypto_ahash_import ( & ctx2 -> req , state ) ; <NEW_LINE> <TAB> if ( err ) {
<TAB> SECItem dsasig ; <NEW_LINE> <TAB> rv = SECFailure ; <NEW_LINE> <TAB> cx = vfy_CreateContext ( key , sig , encAlg , hashAlg , NULL , wincx ) ; <NEW_LINE> <TAB> if ( cx != NULL ) { <NEW_LINE> <TAB> switch ( key -> keyType ) { <NEW_LINE> <TAB> case rsaKey : <NEW_LINE> <START_VULN> <TAB> if ( ( digest -> len != cx -> rsadigestlen ) || <NEW_LINE><TAB> <TAB> PORT_Memcmp ( digest -> data , cx -> u . buffer , digest -> len ) ) { <NEW_LINE><TAB> <TAB> PORT_SetError ( SEC_ERROR_BAD_SIGNATURE ) ; <NEW_LINE><TAB> } else { <NEW_LINE><TAB> <TAB> rv = SECSuccess ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> break ; <NEW_LINE> <TAB> case dsaKey : <NEW_LINE> <TAB> case ecKey : <NEW_LINE> <TAB> dsasig . data = cx -> u . buffer ; <NEW_LINE> <TAB> dsasig . len = SECKEY_SignatureLen ( cx -> key ) ; <NEW_LINE> <TAB> if ( dsasig . len == 0 ) { <NEW_LINE> <TAB> <TAB> break ; <NEW_LINE> <TAB> }
#ifndef _V_LSP_H_ <NEW_LINE> #define _V_LSP_H_ <NEW_LINE> extern int vorbis_lpc_to_lsp ( float * lpc , float * lsp , int m ) ; <NEW_LINE> extern void vorbis_lsp_to_curve ( float * curve , int * map , int n , int ln , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> float * lsp , int m , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> float amp , float ampoffset ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #endif
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> sem_lock_and_putref ( sma ) ; <NEW_LINE> <TAB> <TAB> if ( sma -> sem_perm . deleted ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> sem_unlock ( sma ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> err = - EIDRM ; <NEW_LINE> <TAB> <TAB> <TAB> goto out_free ; <NEW_LINE> <TAB> <TAB> }
<TAB> if ( ! uid_valid ( uid ) || ! gid_valid ( gid ) ) <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <START_VULN> <TAB> if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) && <NEW_LINE> <END_VULN> <TAB> ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || <NEW_LINE> <TAB> uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && <NEW_LINE> <TAB> ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) ||
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 137 2017 / 08 / 13 00 : 21 : 47 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef BUILTIN_ELF
<TAB> <TAB> size2 = avio_rb32 ( pb ) ; <NEW_LINE> <TAB> <TAB> ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> size2 , mime ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ret < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> return ret ; <NEW_LINE> <TAB> }
private int <NEW_LINE> cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info , <NEW_LINE> <START_VULN> <TAB> size_t count , const uint64_t clsid [ 2 ] ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> <TAB> size_t i ; <NEW_LINE> <TAB> <TAB> cdf_timestamp_t tp ;
protected : <NEW_LINE> nsPresContext * mPresContext ; <NEW_LINE> nsCOMPtr < nsIPresShell > mPresShell ; <NEW_LINE> nsCOMPtr < nsISelection > mSelection ; <NEW_LINE> nsRefPtr < nsRange > mFirstSelectedRange ; <NEW_LINE> nsCOMPtr < nsIContent > mRootContent ; <NEW_LINE> nsresult Init ( WidgetQueryContentEvent * aEvent ) ; <NEW_LINE> nsresult Init ( WidgetSelectionEvent * aEvent ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> nsresult InitCommon ( ) ; <NEW_LINE> public : <NEW_LINE> static nsresult GetFlatTextOffsetOfRange ( nsIContent * aRootContent , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsINode * aNode , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> int32_t aNodeOffset ,
#endif <NEW_LINE> extern SECStatus ssl3_HandleHelloExtensions ( sslSocket * ss , <NEW_LINE> <TAB> <TAB> <TAB> SSL3Opaque ** b , PRUint32 * length ) ; <NEW_LINE> extern PRBool ssl3_ExtensionNegotiated ( sslSocket * ss , PRUint16 ex_type ) ; <NEW_LINE> <START_VULN> extern SECStatus ssl3_SetSIDSessionTicket ( sslSessionID * sid , <NEW_LINE><TAB> <TAB> <TAB> NewSessionTicket * session_ticket ) ; <NEW_LINE> <END_VULN> extern SECStatus ssl3_SendNewSessionTicket ( sslSocket * ss ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeys ( unsigned char * keyName , <NEW_LINE> <TAB> <TAB> <TAB> unsigned char * encKey , unsigned char * macKey ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeysPKCS11 ( SECKEYPrivateKey * svrPrivKey , <NEW_LINE> <TAB> <TAB> <TAB> SECKEYPublicKey * svrPubKey , void * pwArg , <NEW_LINE> <TAB> <TAB> <TAB> unsigned char * keyName , PK11SymKey ** aesKey , <NEW_LINE> <TAB> <TAB> <TAB> PK11SymKey ** macKey ) ;
<TAB> <TAB> . index_key . type <TAB> <TAB> = type , <NEW_LINE> <TAB> <TAB> . index_key . description <TAB> = description , <NEW_LINE> <TAB> <TAB> . cred <TAB> <TAB> <TAB> = current_cred ( ) , <NEW_LINE> <START_VULN> <TAB> <TAB> . match_data . cmp <TAB> <TAB> = type -> match , <NEW_LINE> <END_VULN> <TAB> <TAB> . match_data . raw_data <TAB> = description , <NEW_LINE> <TAB> <TAB> . match_data . lookup_type <TAB> = KEYRING_SEARCH_LOOKUP_DIRECT , <NEW_LINE> <TAB> } ;
<TAB> if ( GSSINT_CHK_LOOP ( ctx ) ) <NEW_LINE> <TAB> return ( GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT ) ; <NEW_LINE> <START_VULN> <TAB> status = gssint_delete_internal_sec_context ( minor_status , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ctx -> mech_type , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & ctx -> internal_ctx_id , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> output_token ) ; <NEW_LINE><TAB> if ( status ) <NEW_LINE><TAB> return status ; <NEW_LINE> <END_VULN> <TAB> free ( ctx -> mech_type -> elements ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Serpent and tnepres ( kerneli compatible serpent reversed ) Cipher Algorithm" ) ; <NEW_LINE> MODULE_AUTHOR ( "Dag Arne Osvik < osvik@ii . uib . no > " ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "tnepres" ) ; <NEW_LINE>MODULE_ALIAS ( "serpent" ) ; <NEW_LINE> <END_VULN>
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Galois / Counter Mode" ) ; <NEW_LINE> MODULE_AUTHOR ( "Mikko Herranen < mh1@iki . fi > " ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "gcm_base" ) ; <NEW_LINE>MODULE_ALIAS ( "rfc4106" ) ; <NEW_LINE>MODULE_ALIAS ( "rfc4543" ) ; <NEW_LINE> <END_VULN>
<TAB> if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || <NEW_LINE> <TAB> ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) <NEW_LINE> <TAB> <TAB> return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ; <NEW_LINE> <START_VULN> <TAB> if ( ( ( int ) arg >= cdi -> capacity ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> return cdrom_slot_status ( cdi , arg ) ; <NEW_LINE> }
_ogg_free ( e -> mark ) ; <NEW_LINE> memset ( e , 0 , sizeof ( * e ) ) ; <NEW_LINE> } <NEW_LINE> static int _ve_amp ( envelope_lookup * ve , <NEW_LINE> <START_VULN> <TAB> <TAB> vorbis_info_psy_global * gi , <NEW_LINE><TAB> <TAB> float * data , <NEW_LINE><TAB> <TAB> envelope_band * bands , <NEW_LINE><TAB> <TAB> envelope_filter_state * filters , <NEW_LINE><TAB> <TAB> long pos ) { <NEW_LINE> <END_VULN> long n = ve -> winlength ; <NEW_LINE> int ret = 0 ; <NEW_LINE> long i , j ; <NEW_LINE> float decay ;
MODULE_DESCRIPTION ( "Serpent Cipher Algorithm , SSE2 optimized" ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "serpent" ) ; <NEW_LINE> <END_VULN>
<TAB> if ( ctx -> flags & KEYRING_SEARCH_DO_STATE_CHECK ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) { <NEW_LINE><TAB> <TAB> <TAB> smp_rmb ( ) ; <NEW_LINE><TAB> <TAB> <TAB> ctx -> result = ERR_PTR ( key -> reject_error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> kleave ( " = % d [ neg ] " , ctx -> skipped_ret ) ; <NEW_LINE> <TAB> <TAB> <TAB> goto skipped ; <NEW_LINE> <TAB> <TAB> }
<TAB> fprintf ( f , " { \n" ) ; <NEW_LINE> <TAB> fprintf ( f , "\"server_port\" : % d , \n" , atoi ( server -> port ) ) ; <NEW_LINE> <TAB> fprintf ( f , "\"password\" : \" % s\"" , server -> password ) ; <NEW_LINE> <START_VULN> <TAB> if ( server -> fast_open [ 0 ] ) fprintf ( f , " , \n\"fast_open\" : % s" , server -> fast_open ) ; <NEW_LINE><TAB> if ( server -> mode ) fprintf ( f , " , \n\"mode\" : \" % s\"" , server -> mode ) ; <NEW_LINE><TAB> if ( server -> method ) fprintf ( f , " , \n\"method\" : \" % s\"" , server -> method ) ; <NEW_LINE><TAB> if ( server -> plugin ) fprintf ( f , " , \n\"plugin\" : \" % s\"" , server -> plugin ) ; <NEW_LINE><TAB> if ( server -> plugin_opts ) fprintf ( f , " , \n\"plugin_opts\" : \" % s\"" , server -> plugin_opts ) ; <NEW_LINE> <END_VULN> <TAB> fprintf ( f , "\n } \n" ) ; <NEW_LINE> <TAB> fclose ( f ) ; <NEW_LINE> <TAB> ss_free ( path ) ;
<TAB> <TAB> else <NEW_LINE> <TAB> <TAB> <TAB> print_str_opt ( "color_transfer" , av_color_transfer_name ( par -> color_trc ) ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <NEW_LINE><TAB> <TAB> <TAB> print_str ( "color_primaries" , av_color_primaries_name ( par -> color_primaries ) ) ; <NEW_LINE><TAB> <TAB> else <NEW_LINE><TAB> <TAB> <TAB> print_str_opt ( "color_primaries" , av_color_primaries_name ( par -> color_primaries ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( par -> chroma_location != AVCHROMA_LOC_UNSPECIFIED ) <NEW_LINE> <TAB> <TAB> <TAB> print_str ( "chroma_location" , av_chroma_location_name ( par -> chroma_location ) ) ;
<TAB> phar_flush ( entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> value -> encoding . address = READ ( buf , ut64 ) ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> default : <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> eprintf ( "DWARF : Unexpected pointer size : % u\n" , ( unsigned ) hdr -> pointer_size ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> break ;
class nsDataChannel : public nsBaseChannel { <NEW_LINE> public : <NEW_LINE> <TAB> nsDataChannel ( nsIURI * uri ) { <NEW_LINE> <TAB> <TAB> SetURI ( uri ) ; <NEW_LINE> <TAB> } <NEW_LINE> protected : <NEW_LINE> <START_VULN> <TAB> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result ) ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> #endif
<TAB> tag = data [ dp + + ] ; <NEW_LINE> <START_VULN> <TAB> if ( tag == 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> if ( data [ dp + + ] != 0 ) <NEW_LINE> <TAB> <TAB> <TAB> goto invalid_eoc ;
PRInt32 GetContentLengthHint ( ) const { return mContentLengthHint ; } <NEW_LINE> PRInt32 GetInFlowContentLength ( ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> <NEW_LINE>void ClearTextRun ( ) ; <NEW_LINE> <END_VULN> gfxSkipCharsIterator EnsureTextRun ( gfxContext * aReferenceContext = nsnull , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIFrame * aLineContainer = nsnull , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsLineList : : iterator * aLine = nsnull , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRUint32 * aFlowEndInTextRun = nsnull ) ; <NEW_LINE> gfxTextRun * GetTextRun ( ) { return mTextRun ; } <NEW_LINE> void SetTextRun ( gfxTextRun * aTextRun ) { mTextRun = aTextRun ; } <NEW_LINE> struct TrimmedOffsets { <NEW_LINE> <TAB> PRInt32 mStart ; <NEW_LINE> <TAB> PRInt32 mLength ; <NEW_LINE> <TAB> PRInt32 GetEnd ( ) { return mStart + mLength ; }
<START_VULN> <TAB> if ( used_address && used_address -> name_len == msg_sys -> msg_namelen && <NEW_LINE><TAB> ! memcmp ( & used_address -> name , msg -> msg_name , <NEW_LINE> <END_VULN> <TAB> <TAB> used_address -> name_len ) ) { <NEW_LINE> <TAB> <TAB> err = sock_sendmsg_nosec ( sock , msg_sys , total_len ) ; <NEW_LINE> <TAB> <TAB> goto out_freectl ;
<TAB> int err ; <NEW_LINE> <TAB> struct virtio_net_hdr vnet_hdr = { 0 } ; <NEW_LINE> <TAB> int vnet_hdr_len = 0 ; <NEW_LINE> <START_VULN> <TAB> int copylen ; <NEW_LINE> <END_VULN> <TAB> bool zerocopy = false ; <NEW_LINE> <TAB> if ( q -> flags & IFF_VNET_HDR ) {
<TAB> if ( bmp_gethdr ( in , & hdr ) ) { <NEW_LINE> <TAB> <TAB> jas_eprintf ( "cannot get header\n" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> JAS_DBGLOG ( 1 , ( <NEW_LINE> <TAB> "BMP header : magic 0x % x ; siz % d ; res1 % d ; res2 % d ; off % d\n" ,
<TAB> <TAB> SECStatus newrv = PK11_Authenticate ( slot , PR_TRUE , pwarg ) ; <NEW_LINE> <TAB> <TAB> if ( newrv != SECSuccess ) { <NEW_LINE> <TAB> <TAB> <TAB> SECU_PrintError ( progName , "could not authenticate to token % s . " , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PK11_GetTokenName ( slot ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> return SECFailure ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( name ) { <NEW_LINE> <START_VULN> <TAB> CERTCertificate * the_cert ; <NEW_LINE><TAB> the_cert = CERT_FindCertByNicknameOrEmailAddr ( handle , name ) ; <NEW_LINE><TAB> if ( ! the_cert ) { <NEW_LINE><TAB> the_cert = PK11_FindCertFromNickname ( name , NULL ) ; <NEW_LINE><TAB> if ( ! the_cert ) { <NEW_LINE><TAB> <TAB> SECU_PrintError ( progName , "Could not find : % s\n" , name ) ; <NEW_LINE><TAB> <TAB> return SECFailure ; <NEW_LINE><TAB> } <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> certs = CERT_CreateSubjectCertList ( NULL , handle , & the_cert -> derSubject , <NEW_LINE> <TAB> <TAB> PR_Now ( ) , PR_FALSE ) ;
<TAB> <TAB> phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> <TAB> RETURN_FALSE ; <NEW_LINE> <TAB> <TAB> } else {
<TAB> long count = 0 ; <NEW_LINE> <TAB> oggpack_write ( opb , 1 , 1 ) ; <NEW_LINE> <TAB> oggpack_write ( opb , c -> lengthlist [ 0 ] - 1 , 5 ) ; <NEW_LINE> <TAB> for ( i = 1 ; i < c -> entries ; i + + ) { <NEW_LINE> <TAB> long this = c -> lengthlist [ i ] ; <NEW_LINE> <TAB> long last = c -> lengthlist [ i - 1 ] ; <NEW_LINE> <TAB> if ( this > last ) { <NEW_LINE> <START_VULN> <TAB> for ( j = last ; j < this ; j + + ) { <NEW_LINE><TAB> oggpack_write ( opb , i - count , _ilog ( c -> entries - count ) ) ; <NEW_LINE><TAB> count = i ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> oggpack_write ( opb , i - count , _ilog ( c -> entries - count ) ) ; <NEW_LINE> } else { <NEW_LINE> <TAB> oggpack_write ( opb , 0 , 1 ) ;
int * sortpointer [ VIF_POSIT + 2 ] ; <NEW_LINE> vorbis_info_floor1 * info = ( vorbis_info_floor1 * ) in ; <NEW_LINE> vorbis_look_floor1 * look = _ogg_calloc ( 1 , sizeof ( * look ) ) ; <NEW_LINE> int i , j , n = 0 ; <NEW_LINE> look -> vi = info ; <NEW_LINE> look -> n = info -> postlist [ 1 ] ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( i = 0 ; i < info -> partitions ; i + + ) n += info -> class_dim [ info -> partitionclass [ i ] ] ;
<TAB> if ( p -> vrtp ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( vportno > 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ast_sockaddr_set_port ( vsa , vportno ) ; <NEW_LINE> <TAB> <TAB> <TAB> ast_rtp_instance_set_remote_address ( p -> vrtp , vsa ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( debug ) {
<TAB> clockid_t <TAB> <TAB> it_clock ; <NEW_LINE> <TAB> timer_t <TAB> <TAB> <TAB> it_id ; <NEW_LINE> <TAB> int <TAB> <TAB> <TAB> it_active ; <NEW_LINE> <START_VULN> <TAB> int <TAB> <TAB> <TAB> it_overrun ; <NEW_LINE><TAB> int <TAB> <TAB> <TAB> it_overrun_last ; <NEW_LINE> <END_VULN> <TAB> int <TAB> <TAB> <TAB> it_requeue_pending ; <NEW_LINE> <TAB> int <TAB> <TAB> <TAB> it_sigev_notify ; <NEW_LINE> <TAB> ktime_t <TAB> <TAB> <TAB> it_interval ;
<TAB> if ( ! tcptls_session -> parent -> tls_cfg ) { <NEW_LINE> <START_VULN> <TAB> <TAB> tcptls_session -> f = fdopen ( tcptls_session -> fd , "w + " ) ; <NEW_LINE><TAB> <TAB> setvbuf ( tcptls_session -> f , NULL , _IONBF , 0 ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> #ifdef DO_SSL <NEW_LINE> <TAB> else if ( ( tcptls_session -> ssl = SSL_new ( tcptls_session -> parent -> tls_cfg -> ssl_ctx ) ) ) {
<TAB> dec -> numhtiles = JPC_CEILDIV ( dec -> xend - dec -> tilexoff , dec -> tilewidth ) ; <NEW_LINE> <TAB> dec -> numvtiles = JPC_CEILDIV ( dec -> yend - dec -> tileyoff , dec -> tileheight ) ; <NEW_LINE> <START_VULN> <TAB> dec -> numtiles = dec -> numhtiles * dec -> numvtiles ; <NEW_LINE> <END_VULN> <TAB> JAS_DBGLOG ( 10 , ( "numtiles = % d ; numhtiles = % d ; numvtiles = % d ; \n" , <NEW_LINE> <TAB> dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; <NEW_LINE> <TAB> if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) {
<TAB> } <NEW_LINE> <START_VULN> <TAB> mpz_powm ( v , v , key -> d , key -> n ) ; <NEW_LINE> <END_VULN> <TAB> return 0 ; <NEW_LINE> }
<TAB> Foundation , Inc . , 675 Mass Ave , Cambridge , MA 02139 , USA . <NEW_LINE> <START_VULN> #include < crypto / skcipher . h > <NEW_LINE> <END_VULN> #include < linux / module . h > <NEW_LINE> #include < linux / slab . h > <NEW_LINE> #include < linux / fs . h >
<START_VULN> <TAB> if ( ! asoc -> temp ) { <NEW_LINE> <END_VULN> <TAB> <TAB> list_del ( & asoc -> asocs ) ;
{ <NEW_LINE> <TAB> if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || <NEW_LINE> <TAB> <TAB> ! s -> cur_pic . f || <NEW_LINE> <START_VULN> <TAB> s -> cur_pic . field_picture || <NEW_LINE><TAB> s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO <NEW_LINE> <END_VULN> <TAB> ) <NEW_LINE> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> return 1 ;
<START_VULN> return mutt_bcache_del ( bcache , id ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef USE_HCACHE
<TAB> <TAB> for ( conn_opt = conn_opts ; conn_opt -> keyword != NULL ; conn_opt + + ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> argcount + + ; <NEW_LINE> <TAB> <TAB> }
<TAB> if ( val ) * val = p ; <NEW_LINE> <START_VULN> <TAB> SetHeader ( atom , nsDependentCString ( p , p2 - p ) , PR_TRUE ) ; <NEW_LINE> <END_VULN> }
{ <NEW_LINE> <TAB> int i ; <NEW_LINE> <TAB> for ( i = 31 ; i >= 0 ; i -- ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( x & ( 1 << i ) ) return i ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return 0 ; <NEW_LINE> }
struct nf_ct_ext { <NEW_LINE> <TAB> struct rcu_head rcu ; <NEW_LINE> <START_VULN> <TAB> u8 offset [ NF_CT_EXT_NUM ] ; <NEW_LINE><TAB> u8 len ; <NEW_LINE> <END_VULN> <TAB> char data [ 0 ] ; <NEW_LINE> } ;
<TAB> struct task_struct * tsk ; <NEW_LINE> <TAB> struct mm_struct * mm ; <NEW_LINE> <TAB> int fault , sig , code ; <NEW_LINE> <START_VULN> <TAB> unsigned long vm_flags = VM_READ | VM_WRITE ; <NEW_LINE> <END_VULN> <TAB> unsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE ; <NEW_LINE> <TAB> tsk = current ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Salsa20 stream cipher algorithm" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "salsa20" ) ; <NEW_LINE> <END_VULN>
<TAB> rec_hdr . hdr . incl_len = phdr -> caplen + phdrsize ; <NEW_LINE> <TAB> rec_hdr . hdr . orig_len = phdr -> len + phdrsize ; <NEW_LINE> <START_VULN> <TAB> if ( rec_hdr . hdr . incl_len > WTAP_MAX_PACKET_SIZE || rec_hdr . hdr . orig_len > WTAP_MAX_PACKET_SIZE ) { <NEW_LINE> <END_VULN> <TAB> <TAB> * err = WTAP_ERR_BAD_FILE ; <NEW_LINE> <TAB> <TAB> return FALSE ; <NEW_LINE> <TAB> }
<TAB> if ( ( pce = pcre_get_compiled_regex_cache ( regex , regex_len TSRMLS_CC ) ) == NULL ) { <NEW_LINE> <TAB> <TAB> RETURN_FALSE ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> php_pcre_match_impl ( pce , subject , subject_len , return_value , subpats , <NEW_LINE> <END_VULN> <TAB> <TAB> global , ZEND_NUM_ARGS ( ) >= 4 , flags , start_offset TSRMLS_CC ) ; <NEW_LINE> }
<TAB> <TAB> <TAB> <TAB> line_iterator aLine , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> PRBool * aKeepReflowGoing ) ; <NEW_LINE> <START_VULN> nsresult MarkLineDirty ( line_iterator aLine ) ; <NEW_LINE> <END_VULN> PRBool ShouldJustifyLine ( nsBlockReflowState & aState , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> line_iterator aLine ) ; <NEW_LINE> void DeleteLine ( nsBlockReflowState & aState , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> nsLineList : : iterator aLine , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> nsLineList : : iterator aLineEnd ) ;
<TAB> <TAB> break ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> SSL_AtomicIncrementLong ( & ssl3stats . hsh_sid_cache_hits ) ; <NEW_LINE> <START_VULN> <TAB> if ( sid -> version > SSL_LIBRARY_VERSION_3_0 && <NEW_LINE><TAB> sid -> u . ssl3 . sessionTicket . ticket . data != NULL ) <NEW_LINE> <END_VULN> <TAB> SSL_AtomicIncrementLong ( & ssl3stats . hsh_sid_stateless_resumes ) ; <NEW_LINE> <TAB> if ( ssl3_ExtensionNegotiated ( ss , ssl_session_ticket_xtn ) ) <NEW_LINE> <TAB> ss -> ssl3 . hs . ws = wait_new_session_ticket ; <NEW_LINE> <TAB> else <NEW_LINE> <TAB> ss -> ssl3 . hs . ws = wait_change_cipher ; <NEW_LINE> <TAB> ss -> ssl3 . hs . isResuming = PR_TRUE ;
<TAB> <TAB> if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : <NEW_LINE> <TAB> <TAB> <TAB> <TAB> inode -> i_gid ) && <NEW_LINE> <START_VULN> <TAB> <TAB> ! inode_capable ( inode , CAP_FSETID ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> attr -> ia_mode &= ~ S_ISGID ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> free_slot = i ; <NEW_LINE> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> pr_devel ( "replace in slot % d\n" , i ) ; <NEW_LINE> <TAB> <TAB> <TAB> edit -> leaf_p = & node -> slots [ i ] ; <NEW_LINE> <TAB> <TAB> <TAB> edit -> dead_leaf = node -> slots [ i ] ;
<TAB> if ( flags ) { <NEW_LINE> <TAB> <TAB> * p = '\0' ; <NEW_LINE> <TAB> <TAB> * nargv + + = flagsp ; <NEW_LINE> <START_VULN> <TAB> } <NEW_LINE> <END_VULN> <TAB> while ( ( * nargv + + = * argv + + ) ) ;
<TAB> fl6 . fl6_sport = inet -> inet_sport ; <NEW_LINE> <TAB> security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <NEW_LINE> <START_VULN> <TAB> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <NEW_LINE> <END_VULN> <TAB> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; <NEW_LINE> <TAB> if ( IS_ERR ( dst ) ) {
} <NEW_LINE> <START_VULN> CWD_API realpath_cache_bucket * realpath_cache_lookup ( const char * path , int path_len , time_t t ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> return realpath_cache_find ( path , path_len , t ) ; <NEW_LINE> }
<TAB> matched = 0 ; <NEW_LINE> <TAB> PCRE_G ( error_code ) = PHP_PCRE_NO_ERROR ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> do { <NEW_LINE> <TAB> <TAB> count = pcre_exec ( pce -> re , extra , subject , subject_len , start_offset ,
<TAB> . release <TAB> = gfs2_release , <NEW_LINE> <TAB> . fsync <TAB> <TAB> = gfs2_fsync , <NEW_LINE> <TAB> . splice_read <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> <TAB> . setlease <TAB> = generic_setlease , <NEW_LINE> <TAB> . fallocate <TAB> = gfs2_fallocate , <NEW_LINE> } ;
{ <NEW_LINE> <START_VULN> <TAB> HKEY hkApp ; <NEW_LINE> <END_VULN> <TAB> RegCreateKeyExW ( HKEY_CURRENT_USER , L"Software\\Classes\\Applications" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> 0 , nullptr , REG_OPTION_NON_VOLATILE , KEY_SET_VALUE , nullptr , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> & hkApp , nullptr ) ;
virtual bool IsTransportSeekable ( ) = 0 ; <NEW_LINE> <START_VULN> static MediaResource * Create ( MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <NEW_LINE> <END_VULN> virtual nsresult Open ( nsIStreamListener ** aStreamListener ) = 0 ;
switch ( * mode ) <NEW_LINE> { <NEW_LINE> <TAB> case 'a' : <NEW_LINE> <START_VULN> <TAB> <TAB> fd = open ( filename , O_RDWR | O_CREAT | O_APPEND | O_LARGEFILE | O_BINARY , 0666 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> case 'r' :
<TAB> <TAB> } <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> if ( state -> array_nl ) ruby_xfree ( state -> array_nl ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> state -> array_nl_len = len ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return Qnil ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> we can write * / <NEW_LINE> <TAB> vorbis_staticbook_pack ( testlist [ ptr ] , & write ) ; <NEW_LINE> <TAB> fprintf ( stderr , "Codebook size % ld bytes . . . " , oggpack_bytes ( & write ) ) ; <NEW_LINE> <TAB> for ( i = 0 ; i < TESTSIZE ; i += c . dim ) { <NEW_LINE> <TAB> int best = _best ( & c , qv + i , 1 ) ; <NEW_LINE> <TAB> vorbis_book_encodev ( & c , best , qv + i , & write ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> vorbis_book_clear ( & c ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> fprintf ( stderr , "OK . \n" ) ; <NEW_LINE> <TAB> fprintf ( stderr , "\tunpacking / decoding % ld . . . " , ptr ) ; <NEW_LINE> <TAB> oggpack_readinit ( & read , oggpack_get_buffer ( & write ) , oggpack_bytes ( & write ) ) ; <NEW_LINE> <TAB> if ( vorbis_staticbook_unpack ( & read , & s ) ) { <NEW_LINE> <TAB> fprintf ( stderr , "Error unpacking codebook . \n" ) ; <NEW_LINE> <TAB> exit ( 1 ) ;
<TAB> <TAB> RETURN_FALSE ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> RETVAL_LONG ( ( zend_long ) curl_multi_remove_handle ( mh -> multi , ch -> cp ) ) ; <NEW_LINE> <END_VULN> <TAB> zend_llist_del_element ( & mh -> easyh , z_ch , ( int ( * ) ( void * , void * ) ) curl_compare_resources ) ; <NEW_LINE> }
<TAB> <TAB> int max ; <NEW_LINE> <TAB> <TAB> X509_OBJECT ret ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> <TAB> <TAB> unsigned char * ek = NULL ; <NEW_LINE><TAB> <TAB> int eklen ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ( etmp = BIO_new ( BIO_f_cipher ( ) ) ) == NULL ) <NEW_LINE> <TAB> <TAB> <TAB> {
size_t <NEW_LINE> <TAB> bytes_per_line , <NEW_LINE> <TAB> extent , <NEW_LINE> <START_VULN> <TAB> height , <NEW_LINE><TAB> length ; <NEW_LINE> <END_VULN> ssize_t <NEW_LINE> <TAB> count ,
int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { <NEW_LINE> <TAB> op -> len = 1 ; <NEW_LINE> <TAB> op -> op = buf [ 0 ] ; <NEW_LINE> <START_VULN> <TAB> if ( op -> op > 0xbf ) return 1 ; <NEW_LINE> <END_VULN> <TAB> WasmOpDef * opdef = & opcodes [ op -> op ] ; <NEW_LINE> <TAB> switch ( op -> op ) {
<TAB> sync_lapic_to_cr8 ( vcpu ) ; <NEW_LINE> <TAB> save_host_msrs ( vcpu ) ; <NEW_LINE> <START_VULN> <TAB> fs_selector = kvm_read_fs ( ) ; <NEW_LINE><TAB> gs_selector = kvm_read_gs ( ) ; <NEW_LINE> <END_VULN> <TAB> ldt_selector = kvm_read_ldt ( ) ; <NEW_LINE> <TAB> svm -> vmcb -> save . cr2 = vcpu -> arch . cr2 ;
<TAB> inline void setNextView ( ArrayBufferViewObject * view ) ; <NEW_LINE> <START_VULN> <TAB> void neuter ( JSContext * cx ) ; <NEW_LINE> <END_VULN> <TAB> static void trace ( JSTracer * trc , JSObject * obj ) ;
#ifdef CDF_DEBUG <NEW_LINE> <TAB> <TAB> cdf_dump_summary_info ( & h , & scn ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ( i = cdf_file_summary_info ( ms , & h , & scn , <NEW_LINE><TAB> root_storage -> d_storage_uuid ) ) < 0 ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> expn = "Can't expand summary_info" ; <NEW_LINE> <END_VULN> <TAB> if ( i == 0 ) { <NEW_LINE> <TAB> <TAB> const char * str = NULL ;
#ifdef ZEND_WIN32 <NEW_LINE> <START_VULN> static inline zend_ulong realpath_cache_key ( const char * path , int path_len ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> register zend_ulong h ; <NEW_LINE> <TAB> char * bucket_key_start = tsrm_win32_get_path_sid_key ( path ) ;
<TAB> <TAB> goto out_wakeup ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> spin_lock ( & sma -> sem_perm . lock ) ; <NEW_LINE> <END_VULN> <TAB> curr = & sma -> sem_base [ semnum ] ; <NEW_LINE> <TAB> switch ( cmd ) {
<TAB> <TAB> <TAB> case 18 : <NEW_LINE> <TAB> <TAB> <TAB> case 19 : <NEW_LINE> <TAB> <TAB> <TAB> case 20 : <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> <TAB> uni_to_string ( get_finfo_value_string ( PTREE_FINFO ( tree_pointer ) ) , get_finfo_length ( PTREE_FINFO ( tree_pointer ) ) , buffer ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> if ( repeat_lookup > 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> if ( strlen ( temp_buffer ) + strlen ( buffer ) < 250 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> g_strlcat ( temp_buffer , buffer , 256 ) ;
<TAB> First : no IPv4 options . <NEW_LINE> <START_VULN> <TAB> newinet -> opt = NULL ; <NEW_LINE> <END_VULN> <TAB> newnp -> ipv6_fl_list = NULL ;
MODULE_LICENSE ( "Dual BSD / GPL" ) ; <NEW_LINE> MODULE_AUTHOR ( "Intel" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Intel ( R ) QuickAssist Technology" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "intel_qat" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> object = r_asn1_create_object ( buffer , length ) ; <NEW_LINE> <START_VULN> <TAB> if ( ! object || object -> list . length != 2 || ! object -> list . objects [ 0 ] || object -> list . objects [ 1 ] -> list . length != 1 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> r_asn1_free_object ( object ) ; <NEW_LINE> <TAB> <TAB> free ( container ) ; <NEW_LINE> <TAB> <TAB> return NULL ;
#include "hash . h" <NEW_LINE> #include "transaction . h" <NEW_LINE> <START_VULN> static struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root , <NEW_LINE><TAB> <TAB> <TAB> struct btrfs_path * path , <NEW_LINE><TAB> <TAB> <TAB> const char * name , int name_len ) ; <NEW_LINE><NEW_LINE>static struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root , <NEW_LINE><TAB> <TAB> <TAB> struct btrfs_path * path , <NEW_LINE><TAB> <TAB> <TAB> const char * name , int name_len ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct btrfs_dir_item * dir_item ; <NEW_LINE> <TAB> unsigned long name_ptr ;
<TAB> bool src_known , dst_known ; <NEW_LINE> <TAB> s64 smin_val , smax_val ; <NEW_LINE> <TAB> u64 umin_val , umax_val ; <NEW_LINE> <START_VULN> <TAB> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> coerce_reg_to_size ( dst_reg , 4 ) ; <NEW_LINE><TAB> <TAB> coerce_reg_to_size ( & src_reg , 4 ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> smin_val = src_reg . smin_value ; <NEW_LINE> <TAB> smax_val = src_reg . smax_value ; <NEW_LINE> <TAB> umin_val = src_reg . umin_value ;
<TAB> <TAB> info -> cmap . len || cmap -> start < info -> cmap . start ) <NEW_LINE> <TAB> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <START_VULN> <TAB> <TAB> entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ! entries ) <NEW_LINE> <TAB> <TAB> <TAB> return - ENOMEM ;
<TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( i > ( int ) rec -> length ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> {
<TAB> nsCOMPtr < nsIScriptContext > mCtx ; <NEW_LINE> <TAB> nsAutoMicroTask mMt ; <NEW_LINE> <TAB> Maybe < JS : : Rooted < JSObject * > > mRootedCallable ; <NEW_LINE> <START_VULN> <TAB> nsCxPusher mCxPusher ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> Maybe < JSAutoCompartment > mAc ;
<TAB> int chunk_type ; <NEW_LINE> <TAB> int inter ; <NEW_LINE> <START_VULN> <TAB> if ( buf_size < 17 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> av_log ( avctx , AV_LOG_ERROR , "Input buffer too small\n" ) ; <NEW_LINE> <TAB> <TAB> * data_size = 0 ; <NEW_LINE> <TAB> <TAB> return - 1 ;
public : <NEW_LINE> <TAB> ObjectElements ( uint32_t capacity , uint32_t length ) <NEW_LINE> <START_VULN> <TAB> : capacity ( capacity ) , initializedLength ( 0 ) , length ( length ) <NEW_LINE> <END_VULN> <TAB> { } <NEW_LINE> <TAB> HeapSlot * elements ( ) { return ( HeapSlot * ) ( uintptr_t ( this ) + sizeof ( ObjectElements ) ) ; }
<START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> t -> result = TIMER_SUCCESS ;
<START_VULN> <TAB> remaining = tvb_captured_length_remaining ( tvb , offset ) ; <NEW_LINE> <END_VULN> <TAB> if ( remaining <= 0 ) { <NEW_LINE> <TAB> <TAB> if ( data ) <NEW_LINE> <TAB> <TAB> <TAB> * data = g_strdup ( "" ) ;
<TAB> struct videobuf_queue * q = map -> q ; <NEW_LINE> <TAB> int i ; <NEW_LINE> <START_VULN> <TAB> dprintk ( 2 , "vm_close % p [ count = % d , vma = % 08lx - % 08lx ] \n" , map , <NEW_LINE> <END_VULN> <TAB> <TAB> map -> count , vma -> vm_start , vma -> vm_end ) ; <NEW_LINE> <TAB> map -> count -- ;
<TAB> <TAB> return FALSE ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <NEW_LINE><TAB> if ( pkt_len == - 1 ) <NEW_LINE><TAB> <TAB> return FALSE ; <NEW_LINE><NEW_LINE><TAB> <NEW_LINE><TAB> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <NEW_LINE> <END_VULN> <TAB> err_info ) ; <NEW_LINE> }
<TAB> <TAB> precache = true ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) ) { <NEW_LINE> <END_VULN>
{ <NEW_LINE> <TAB> JS_ASSERT ( this == & cx -> compartment -> types ) ; <NEW_LINE> <TAB> JS_ASSERT ( ! cx -> runtime -> gcRunning ) ; <NEW_LINE> <TAB> InferSpew ( ISpewOps , "pending : % sC % p % s % s" , <NEW_LINE> <TAB> <TAB> <TAB> InferSpewColor ( constraint ) , constraint , InferSpewColorReset ( ) , <NEW_LINE> <TAB> <TAB> <TAB> TypeString ( type ) ) ; <NEW_LINE> <START_VULN> <TAB> if ( pendingCount == pendingCapacity ) <NEW_LINE><TAB> <TAB> growPendingArray ( cx ) ; <NEW_LINE> <END_VULN> <TAB> PendingWork & pending = pendingArray [ pendingCount + + ] ; <NEW_LINE> <TAB> pending . constraint = constraint ; <NEW_LINE> <TAB> pending . source = source ; <NEW_LINE> <TAB> pending . type = type ; <NEW_LINE> } <NEW_LINE> inline void
<TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> int first_key = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> sprintf ( op -> buf_asm , "packed - switch - payload % d , % d" , array_size , first_key ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> size = 8 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> payload = 2 * ( array_size * 2 ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> len = 0 ;
MODULE_DESCRIPTION ( "Rijndael ( AES ) Cipher Algorithm ( ASM ) " ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "aes" ) ; <NEW_LINE>MODULE_ALIAS ( "aes - asm" ) ; <NEW_LINE> <END_VULN> MODULE_AUTHOR ( "David McCullough < ucdevel@gmail . com > " ) ;
<TAB> NS_IMETHOD ResetInputState ( ) ; <NEW_LINE> <TAB> NS_IMETHOD_ ( void ) SetInputContext ( const InputContext & aContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const InputContextAction & aAction ) ; <NEW_LINE> <TAB> NS_IMETHOD_ ( InputContext ) GetInputContext ( ) ; <NEW_LINE> <TAB> NS_IMETHOD CancelIMEComposition ( ) ; <NEW_LINE> <TAB> NS_IMETHOD OnIMEFocusChange ( bool aFocus ) ; <NEW_LINE> <TAB> NS_IMETHOD GetToggledKeyState ( uint32_t aKeyCode , bool * aLEDState ) ; <NEW_LINE> <START_VULN> void ResizeTransparencyBitmap ( int32_t aNewWidth , int32_t aNewHeight ) ; <NEW_LINE> <END_VULN> <TAB> void ApplyTransparencyBitmap ( ) ; <NEW_LINE> <TAB> virtual void SetTransparencyMode ( nsTransparencyMode aMode ) ; <NEW_LINE> <TAB> virtual nsTransparencyMode GetTransparencyMode ( ) ; <NEW_LINE> <TAB> virtual nsresult ConfigureChildren ( const nsTArray < Configuration > & aConfigurations ) ; <NEW_LINE> <TAB> nsresult UpdateTranslucentWindowAlphaInternal ( const nsIntRect & aRect , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint8_t * aAlphas , int32_t aStride ) ; <NEW_LINE> #if defined ( MOZ_WIDGET_GTK2 )
<TAB> ' < session - name >= < session - id > ' to allow URLs of the form <NEW_LINE> <TAB> <TAB> http : <NEW_LINE> <START_VULN> <TAB> if ( ! PS ( id ) && <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> zend_hash_find ( & EG ( symbol_table ) , "REQUEST_URI" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> sizeof ( "REQUEST_URI" ) , ( void ** ) & data ) == SUCCESS && <NEW_LINE> <TAB> <TAB> <TAB> Z_TYPE_PP ( data ) == IS_STRING &&
<TAB> copy_flags = CL_COPY_ALL | CL_EXPIRE ; <NEW_LINE> <TAB> if ( user_ns != mnt_ns -> user_ns ) <NEW_LINE> <START_VULN> <TAB> <TAB> copy_flags |= CL_SHARED_TO_SLAVE ; <NEW_LINE> <END_VULN> <TAB> new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; <NEW_LINE> <TAB> if ( IS_ERR ( new ) ) { <NEW_LINE> <TAB> <TAB> up_write ( & namespace_sem ) ;
#define MNT_SHARED_MASK <TAB> ( MNT_UNBINDABLE ) <NEW_LINE> <START_VULN> #define MNT_PROPAGATION_MASK <TAB> ( MNT_SHARED | MNT_UNBINDABLE ) <NEW_LINE> <END_VULN> #define MNT_INTERNAL_FLAGS ( MNT_SHARED | MNT_WRITE_HOLD | MNT_INTERNAL | \ <NEW_LINE> <TAB> <TAB> <TAB> MNT_DOOMED | MNT_SYNC_UMOUNT | MNT_MARKED )
<TAB> fp = skb_shinfo ( head ) -> frag_list ; <NEW_LINE> <START_VULN> <TAB> if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) <NEW_LINE> <END_VULN> <TAB> <TAB> fp = fp -> next ;
} else { <NEW_LINE> <TAB> unsigned char * out ; <NEW_LINE> <START_VULN> <TAB> unsigned long outlen , loid [ 16 ] ; <NEW_LINE> <END_VULN> <TAB> int decoded ; <NEW_LINE> <TAB> ltc_asn1_list digestinfo [ 2 ] , siginfo [ 2 ] ;
<TAB> struct snd_hrtimer * stime = t -> private_data ; <NEW_LINE> <TAB> atomic_set ( & stime -> running , 0 ) ; <NEW_LINE> <START_VULN> <TAB> hrtimer_cancel ( & stime -> hrt ) ; <NEW_LINE> <END_VULN> <TAB> hrtimer_start ( & stime -> hrt , ns_to_ktime ( t -> sticks * resolution ) , <NEW_LINE> <TAB> <TAB> HRTIMER_MODE_REL ) ; <NEW_LINE> <TAB> atomic_set ( & stime -> running , 1 ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ALLOC_ZVAL ( result_set ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> array_init ( result_set ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> INIT_PZVAL ( result_set ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> for ( i = 0 ; i < count ; i + + ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> if ( offset_capture ) {
<TAB> <TAB> next ( NULL ) , <NEW_LINE> <TAB> <TAB> peer ( NULL ) , <NEW_LINE> <TAB> <TAB> globalObj ( _globalObj ) , <NEW_LINE> <TAB> <TAB> globalShape ( _globalShape ) , <NEW_LINE> <TAB> <TAB> argc ( _argc ) , <NEW_LINE> <TAB> <TAB> dependentTrees ( alloc ) , <NEW_LINE> <TAB> <TAB> linkedTrees ( alloc ) , <NEW_LINE> <TAB> <TAB> sideExits ( alloc ) , <NEW_LINE> <TAB> <TAB> gcthings ( alloc ) , <NEW_LINE> <START_VULN> <TAB> <TAB> shapes ( alloc ) <NEW_LINE> <END_VULN> <TAB> { } <NEW_LINE> <TAB> TreeFragment * first ; <NEW_LINE> <TAB> TreeFragment * next ; <NEW_LINE> <TAB> TreeFragment * peer ; <NEW_LINE> <TAB> JSObject * globalObj ; <NEW_LINE> <TAB> uint32 globalShape ; <NEW_LINE> <TAB> uint32 argc ;
<TAB> static PRInt32 getNamespaceID ( const txXPathNode & aNode ) ; <NEW_LINE> <TAB> static void getNamespaceURI ( const txXPathNode & aNode , nsAString & aURI ) ; <NEW_LINE> <TAB> static PRUint16 getNodeType ( const txXPathNode & aNode ) ; <NEW_LINE> <TAB> static void appendNodeValue ( const txXPathNode & aNode , nsAString & aResult ) ; <NEW_LINE> <TAB> static PRBool isWhitespace ( const txXPathNode & aNode ) ; <NEW_LINE> <TAB> static txXPathNode * getDocument ( const txXPathNode & aNode ) ; <NEW_LINE> <TAB> static txXPathNode * getOwnerDocument ( const txXPathNode & aNode ) ; <NEW_LINE> <TAB> static PRInt32 getUniqueIdentifier ( const txXPathNode & aNode ) ; <NEW_LINE> <START_VULN> <TAB> static nsresult getXSLTId ( const txXPathNode & aNode , nsAString & aResult ) ; <NEW_LINE> <END_VULN> <TAB> static void release ( txXPathNode * aNode ) ; <NEW_LINE> <TAB> static void getBaseURI ( const txXPathNode & aNode , nsAString & aURI ) ; <NEW_LINE> <TAB> static PRIntn comparePosition ( const txXPathNode & aNode , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const txXPathNode & aOtherNode ) ; <NEW_LINE> <TAB> static PRBool localNameEquals ( const txXPathNode & aNode , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIAtom * aLocalName ) ; <NEW_LINE> <TAB> static PRBool isRoot ( const txXPathNode & aNode ) ; <NEW_LINE> <TAB> static PRBool isElement ( const txXPathNode & aNode ) ;
<TAB> <TAB> return false ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> link_shdr = & bin -> shdr [ shdr -> sh_link ] ; <NEW_LINE> <START_VULN> <TAB> if ( shdr -> sh_size < 1 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> return false ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ;
#include < linux / sched . h > <NEW_LINE> #include < linux / posix - timers . h > <NEW_LINE> <START_VULN> #include < asm / uaccess . h > <NEW_LINE> <END_VULN> #include < linux / errno . h > <NEW_LINE> static int check_clock ( const clockid_t which_clock ) <NEW_LINE> {
<TAB> int initialContextToken = ( * context_handle == GSS_C_NO_CONTEXT ) ; <NEW_LINE> <TAB> if ( initialContextToken ) { <NEW_LINE> <START_VULN> <TAB> <TAB> code = iakerb_alloc_context ( & ctx ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( code != 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> * minor_status = code ; <NEW_LINE> <TAB> <TAB> <TAB> goto cleanup ;
<TAB> <TAB> <TAB> <TAB> size_t count ) <NEW_LINE> { <NEW_LINE> <TAB> struct o2nm_node * node = to_o2nm_node ( item ) ; <NEW_LINE> <START_VULN> <TAB> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <NEW_LINE> <END_VULN> <TAB> unsigned long tmp ; <NEW_LINE> <TAB> char * p = ( char * ) page ; <NEW_LINE> <TAB> ssize_t ret ;
queue_unlock ( struct futex_q * q , struct futex_hash_bucket * hb ) <NEW_LINE> { <NEW_LINE> <TAB> spin_unlock ( & hb -> lock ) ; <NEW_LINE> <START_VULN> <TAB> drop_futex_key_refs ( & q -> key ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> <TAB> ret = futex_wait_setup ( uaddr , val , fshared , & q , & hb ) ; <NEW_LINE> <TAB> if ( ret ) <NEW_LINE> <TAB> <TAB> goto out ;
bool mDroppedDown ; <NEW_LINE> bool mInRedisplayText ; <NEW_LINE> bool mDelayedShowDropDown ; <NEW_LINE> <START_VULN> static nsComboboxControlFrame * mFocused ; <NEW_LINE> <END_VULN> #ifdef DO_REFLOW_COUNTER <NEW_LINE> PRInt32 mReflowId ; <NEW_LINE> #endif <NEW_LINE> } ; <NEW_LINE> #endif
<TAB> AHASH_REQUEST_ON_STACK ( ahreq , ctx -> mac ) ; <NEW_LINE> <TAB> unsigned int assoclen = req -> assoclen ; <NEW_LINE> <TAB> struct scatterlist sg [ 3 ] ; <NEW_LINE> <START_VULN> <TAB> u8 odata [ 16 ] ; <NEW_LINE><TAB> u8 idata [ 16 ] ; <NEW_LINE> <END_VULN> <TAB> int ilen , err ;
JSObject * <NEW_LINE> js : : CloneRegExpObject ( JSContext * cx , JSObject * obj_ , JSObject * proto_ ) <NEW_LINE> { <NEW_LINE> <TAB> RegExpObjectBuilder builder ( cx ) ; <NEW_LINE> <TAB> Rooted < RegExpObject * > regex ( cx , & obj_ -> as < RegExpObject > ( ) ) ; <NEW_LINE> <TAB> Rooted < RegExpObject * > proto ( cx , & proto_ -> as < RegExpObject > ( ) ) ; <NEW_LINE> <START_VULN> <TAB> return builder . clone ( regex , proto ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> js : : ParseRegExpFlags ( JSContext * cx , JSString * flagStr , RegExpFlag * flagsOut ) <NEW_LINE> { <NEW_LINE> <TAB> size_t n = flagStr -> length ( ) ; <NEW_LINE> <TAB> const jschar * s = flagStr -> getChars ( cx ) ; <NEW_LINE> <TAB> if ( ! s )
<START_VULN> <TAB> if ( startedFromUnelevatedUpdater ) { <NEW_LINE> <END_VULN> <TAB> UACHelper : : DisablePrivileges ( nullptr ) ;
MarFile * CVE_2013_1726_mar_wopen ( const wchar_t * path ) { <NEW_LINE> FILE * fp ; <NEW_LINE> <START_VULN> fp = _wfopen ( path , L"rb" ) ; <NEW_LINE> <END_VULN> if ( ! fp ) <NEW_LINE> <TAB> return NULL ;
<TAB> mutex_unlock ( & vq -> mutex ) ; <NEW_LINE> <TAB> if ( oldubufs ) { <NEW_LINE> <START_VULN> <TAB> <TAB> vhost_net_ubuf_put_and_wait ( oldubufs ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> mutex_lock ( & vq -> mutex ) ; <NEW_LINE> <TAB> <TAB> vhost_zerocopy_signal_used ( n , vq ) ; <NEW_LINE> <TAB> <TAB> mutex_unlock ( & vq -> mutex ) ;
<TAB> virtual gfxFontEntry * MakePlatformFont ( const gfxProxyFontEntry * aProxyEntry , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const PRUint8 * aFontData , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRUint32 aLength ) ; <NEW_LINE> <START_VULN> <TAB> virtual PRBool DownloadableFontsEnabled ( ) ; <NEW_LINE> <END_VULN> #define LOG ( args ) PR_LOG ( gUserFontsLog , PR_LOG_DEBUG , args ) <NEW_LINE> #define LOG_ENABLED ( ) PR_LOG_TEST ( gUserFontsLog , PR_LOG_DEBUG ) <NEW_LINE> static PRUint64 sFontSetGeneration = LL_INIT ( 0 , 0 ) ;
<START_VULN> <TAB> <TAB> if ( offset > pkt_len ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> * err = WTAP_ERR_BAD_FILE ; <NEW_LINE> <TAB> <TAB> <TAB> * err_info = g_strdup ( "netscreen : too much hex - data" ) ; <NEW_LINE> <TAB> <TAB> <TAB> return FALSE ;
CVE_2013_1726_mar_read_product_info_block ( MarFile * mar , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> struct ProductInformationBlock * infoBlock ) <NEW_LINE> { <NEW_LINE> <START_VULN> int i , hasAdditionalBlocks , offset , <NEW_LINE> <END_VULN> <TAB> offsetAdditionalBlocks , numAdditionalBlocks , <NEW_LINE> <TAB> additionalBlockSize , additionalBlockID ;
<TAB> if ( ! unifilename ) <NEW_LINE> <TAB> <TAB> goto out1 ; <NEW_LINE> <START_VULN> <TAB> if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> goto out2 ; <NEW_LINE> <TAB> if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_UTF8 ) ) {
bool IsIMEDoingKakuteiUndo ( ) const ; <NEW_LINE> <START_VULN> void RemoveMessageAndDispatchPluginEvent ( UINT aFirstMsg , UINT aLastMsg ) const ; <NEW_LINE> <END_VULN> bool IsKeyDownMessage ( ) const <NEW_LINE> { <NEW_LINE> <TAB> return ( mMsg . message == WM_KEYDOWN || mMsg . message == WM_SYSKEYDOWN ) ; <NEW_LINE> } <NEW_LINE> bool IsFollowedByCharMessage ( ) const <NEW_LINE> { <NEW_LINE> <TAB> MOZ_ASSERT ( mMsg . message == WM_KEYDOWN || mMsg . message == WM_SYSKEYDOWN ) ;
<TAB> <TAB> for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; <NEW_LINE> <TAB> <TAB> bit < bm -> depth ; <NEW_LINE> <TAB> <TAB> bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> fn ( rq , data , reserved ) ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> <TAB> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> p = ( char __user * ) iocts . arg ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> for ( i = 0 ; i < 10 ; i + + ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> sprintf ( bname , " % s % s" , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ( i < 9 ) ? " , " : "\0" ) ;
while ( -- alloc > 0 ) { <NEW_LINE> <TAB> in = * string ; <NEW_LINE> <START_VULN> <TAB> if ( ( ' % ' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { <NEW_LINE> <END_VULN> <TAB> char hexstr [ 3 ] ; <NEW_LINE> <TAB> char * ptr ;
<TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> return 2 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> mpz_powm ( b , b , key -> e , key -> n ) ; <NEW_LINE> <END_VULN> <TAB> mpz_mul ( v , v , b ) ; <NEW_LINE> <TAB> mpz_mod ( v , v , key -> n ) ; <NEW_LINE> <TAB> return 0 ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "GHASH Message Digest Algorithm , " <NEW_LINE> <TAB> <TAB> "acclerated by PCLMULQDQ - NI" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "ghash" ) ; <NEW_LINE> <END_VULN>
<TAB> const gss_buffer_t <TAB> interprocess_token , <NEW_LINE> <TAB> gss_ctx_id_t <TAB> <TAB> * context_handle ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> OM_uint32 ret ; <NEW_LINE><TAB> ret = gss_import_sec_context ( minor_status , <NEW_LINE><TAB> <TAB> <TAB> <TAB> interprocess_token , <NEW_LINE><TAB> <TAB> <TAB> <TAB> context_handle ) ; <NEW_LINE><TAB> return ( ret ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif
<TAB> <TAB> ret = add_to_page_cache_lru ( page , mapping , index , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> GFP_KERNEL ) ; <NEW_LINE> <TAB> <TAB> if ( unlikely ( ret ) ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> goto out ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> ret = mapping -> a_ops -> prepare_write ( file , page , offset , offset + this_len ) ;
<TAB> data . period = event -> hw . last_period ; <NEW_LINE> <TAB> if ( alpha_perf_event_set_period ( event , hwc , idx ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <NEW_LINE> <END_VULN>
<TAB> <TAB> if ( ( c = jas_stream_getc ( in ) ) == EOF ) { <NEW_LINE> <TAB> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> v |= ( c << 24 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( -- n <= 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> }
#include "file . h" <NEW_LINE> #ifndef <TAB> lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : softmagic . c , v 1 . 189 2014 / 05 / 30 16 : 47 : 44 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <TAB> <NEW_LINE> #include "magic . h"
<TAB> EXT4_HAS_INCOMPAT_FEATURE ( sb , EXT4_FEATURE_INCOMPAT_RECOVER ) ) { <NEW_LINE> <TAB> <TAB> ext4_msg ( sb , KERN_ERR , "required journal recovery " <NEW_LINE> <TAB> <TAB> "suppressed and not mounted read - only" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> goto failed_mount4 ; <NEW_LINE> <END_VULN> <TAB> } else { <NEW_LINE> <TAB> <TAB> clear_opt ( sbi -> s_mount_opt , DATA_FLAGS ) ; <NEW_LINE> <TAB> <TAB> set_opt ( sbi -> s_mount_opt , WRITEBACK_DATA ) ;
<TAB> case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : <NEW_LINE> <TAB> case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : <NEW_LINE> <TAB> case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <NEW_LINE> <START_VULN> <TAB> case EXIT_REASON_INVEPT : <NEW_LINE> <END_VULN>
<START_VULN> <TAB> image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : <NEW_LINE> <END_VULN> <TAB> UndefinedPixelTrait ; <NEW_LINE> <TAB> image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : <NEW_LINE> <TAB> DirectClass ) ;
int jpc_tsfb_synthesize ( jpc_tsfb_t * tsfb , jas_seq2d_t * a ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb , <NEW_LINE> <END_VULN> <TAB> jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , <NEW_LINE> <TAB> jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , <NEW_LINE> <TAB> jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ;
<TAB> if ( p -> rtp ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( portno > 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ast_sockaddr_set_port ( sa , portno ) ; <NEW_LINE> <TAB> <TAB> <TAB> ast_rtp_instance_set_remote_address ( p -> rtp , sa ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( debug ) {
class nsHttpResponseHead <NEW_LINE> { <NEW_LINE> public : <NEW_LINE> <START_VULN> <TAB> nsHttpResponseHead ( ) : mHeaders ( nsHttpHeaderArray : : HTTP_RESPONSE_HEADERS ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> , mVersion ( NS_HTTP_VERSION_1_1 ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> , mStatus ( 200 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> , mContentLength ( LL_MAXUINT ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> , mCacheControlNoStore ( PR_FALSE ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> , mCacheControlNoCache ( PR_FALSE ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> , mPragmaNoCache ( PR_FALSE ) { } <NEW_LINE> <TAB> ~ nsHttpResponseHead ( ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> Reset ( ) ;
} cib_remote_opaque_t ; <NEW_LINE> void cib_remote_connection_destroy ( gpointer user_data ) ; <NEW_LINE> <START_VULN> int cib_remote_dispatch ( gpointer user_data ) ; <NEW_LINE> <END_VULN> int cib_remote_signon ( cib_t * cib , const char * name , enum cib_conn_type type ) ; <NEW_LINE> int cib_remote_signoff ( cib_t * cib ) ; <NEW_LINE> int cib_remote_free ( cib_t * cib ) ;
if ( quantum_info -> pixels != ( unsigned char ** ) NULL ) <NEW_LINE> <TAB> DestroyQuantumPixels ( quantum_info ) ; <NEW_LINE> quantum = ( quantum_info -> pad + 6 ) * ( quantum_info -> depth + 7 ) / 8 ; <NEW_LINE> <START_VULN> extent = image -> columns * quantum ; <NEW_LINE>if ( ( image -> columns != 0 ) && ( quantum != ( extent / image -> columns ) ) ) <NEW_LINE> <END_VULN> <TAB> return ( MagickFalse ) ; <NEW_LINE> return ( AcquireQuantumPixels ( quantum_info , extent ) ) ; <NEW_LINE> }
<TAB> <TAB> <TAB> <TAB> <TAB> return - EACCES ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> mark_reg_unknown ( env , regs , insn -> dst_reg ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> <TAB> regs [ insn -> dst_reg ] . var_off = tnum_cast ( <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> regs [ insn -> dst_reg ] . var_off , 4 ) ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } else {
<TAB> <TAB> <TAB> <TAB> <TAB> if ( byte_run > 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> pixel = AV_RL16 ( & buf [ stream_ptr ] ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> stream_ptr += 2 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> CHECK_PIXEL_PTR ( byte_run ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> for ( j = 0 ; j < byte_run ; j + + ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> * ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> pixel_ptr += 2 ;
<TAB> <TAB> <TAB> <TAB> <TAB> public nsSupportsWeakReference , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIDOMEventTarget , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIDOM3EventTarget , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIDOMNSEventTarget , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIScriptObjectPrincipal , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIRadioGroupContainer , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIDOMNodeSelector , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIApplicationCacheContainer , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> public nsStubMutationObserver <NEW_LINE> <END_VULN> { <NEW_LINE> public : <NEW_LINE> NS_DECL_CYCLE_COLLECTING_ISUPPORTS <NEW_LINE> virtual void Reset ( nsIChannel * aChannel , nsILoadGroup * aLoadGroup ) ; <NEW_LINE> virtual void ResetToURI ( nsIURI * aURI , nsILoadGroup * aLoadGroup , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIPrincipal * aPrincipal ) ;
<TAB> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> coerce_reg_to_32 ( dst_reg ) ; <NEW_LINE><TAB> <TAB> coerce_reg_to_32 ( & src_reg ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> smin_val = src_reg . smin_value ; <NEW_LINE> <TAB> smax_val = src_reg . smax_value ;
virtual bool IsRoot ( ) { return true ; } <NEW_LINE> <START_VULN> void RequestUpdatePluginGeometry ( nsIFrame * aFrame ) ; <NEW_LINE><NEW_LINE><TAB> <NEW_LINE>void RootForgetUpdatePluginGeometryFrame ( nsIFrame * aFrame ) ; <NEW_LINE><NEW_LINE><TAB> <NEW_LINE>void RootForgetUpdatePluginGeometryFrameForPresContext ( nsPresContext * aPresContext ) ; <NEW_LINE> <END_VULN> void IncrementDOMGeneration ( ) { mDOMGeneration + + ; }
bool GetHitRegionRect ( Element * aElement , nsRect & aRect ) ; <NEW_LINE> protected : <NEW_LINE> nsresult GetImageDataArray ( JSContext * aCx , int32_t aX , int32_t aY , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t aWidth , uint32_t aHeight , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject ** aRetval ) ; <NEW_LINE> nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> unsigned char * aData , uint32_t aDataLen , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> int32_t dirtyWidth , int32_t dirtyHeight ) ; <NEW_LINE> nsresult Initialize ( int32_t width , int32_t height ) ;
<TAB> if ( sock -> file -> f_flags & O_NONBLOCK ) <NEW_LINE> <TAB> <TAB> msg_sys -> msg_flags |= MSG_DONTWAIT ; <NEW_LINE> <START_VULN> <TAB> if ( used_address && used_address -> name_len == msg_sys -> msg_namelen && <NEW_LINE><TAB> ! memcmp ( & used_address -> name , msg -> msg_name , <NEW_LINE> <END_VULN> <TAB> <TAB> used_address -> name_len ) ) { <NEW_LINE> <TAB> <TAB> err = sock_sendmsg_nosec ( sock , msg_sys , total_len ) ; <NEW_LINE> <TAB> <TAB> goto out_freectl ;
void vorbis_dsp_clear ( vorbis_dsp_state * v ) { <NEW_LINE> int i ; <NEW_LINE> if ( v ) { <NEW_LINE> <TAB> vorbis_info * vi = v -> vi ; <NEW_LINE> <TAB> codec_setup_info * ci = ( vi ? vi -> codec_setup : NULL ) ; <NEW_LINE> <TAB> private_state * b = v -> backend_state ; <NEW_LINE> <TAB> if ( b ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> if ( b -> ve ) { <NEW_LINE> <TAB> <TAB> _ve_envelope_clear ( b -> ve ) ; <NEW_LINE> <TAB> <TAB> _ogg_free ( b -> ve ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( b -> transform [ 0 ] ) { <NEW_LINE> <TAB> <TAB> mdct_clear ( b -> transform [ 0 ] [ 0 ] ) ; <NEW_LINE> <TAB> <TAB> _ogg_free ( b -> transform [ 0 ] [ 0 ] ) ;
<START_VULN> <NEW_LINE> <END_VULN> #define MY_HOLD_ORIGINAL_MODES 128 <NEW_LINE> #define MY_REDEL_MAKE_BACKUP 256 <NEW_LINE> #define MY_SEEK_NOT_DONE 32 <TAB> <NEW_LINE> #define MY_DONT_WAIT <TAB> 64 <TAB> <NEW_LINE> #define MY_ZEROFILL <TAB> 32 <TAB>
<TAB> if ( ! port ) <NEW_LINE> <TAB> <TAB> port = pool -> stratum_port ; <NEW_LINE> <START_VULN> <TAB> sprintf ( address , " % s : % s" , url , port ) ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) <NEW_LINE> <TAB> <TAB> return false ;
<TAB> <TAB> sgi_timer_get ( timr , old_setting ) ; <NEW_LINE> <TAB> sgi_timer_del ( timr ) ; <NEW_LINE> <START_VULN> <TAB> when = timespec_to_ns ( new_setting -> it_value ) ; <NEW_LINE><TAB> period = timespec_to_ns ( new_setting -> it_interval ) ; <NEW_LINE> <END_VULN> <TAB> if ( when == 0 )
static struct user_namespace * user_ns ; <NEW_LINE> <START_VULN> static struct mount * last_dest , * last_source , * dest_master ; <NEW_LINE> <END_VULN> static struct mountpoint * mp ; <NEW_LINE> static struct hlist_head * list ;
nsresult <NEW_LINE> xpc_EvalInSandbox ( JSContext * cx , JSObject * sandbox , const nsAString & source , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> const char * filename , PRInt32 lineNo , jsval * rval ) ; <NEW_LINE> <END_VULN> #endif
<START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 85 ) <NEW_LINE> <END_VULN>
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : LPC low level routines <NEW_LINE> <START_VULN> last mod : $ Id : lpc . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN>
<TAB> <TAB> return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> ptr = strchr ( ptr + 1 , ' / ' ) + 1 ; <NEW_LINE> <END_VULN> <TAB> rw_exit ( & sdvp -> sdev_contents ) ; <NEW_LINE> <TAB> sdev_iter_datasets ( dvp , ZFS_IOC_DATASET_LIST_NEXT , ptr ) ; <NEW_LINE> <TAB> rw_enter ( & sdvp -> sdev_contents , RW_READER ) ;
virtual void ProcessTextData ( ) ; <NEW_LINE> PRBool SetTextStyle ( ) ; <NEW_LINE> <START_VULN> void SetQuotes ( ) ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> #endif
<TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> ti -> flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; <NEW_LINE> <TAB> <TAB> <TAB> if ( -- timer -> running ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> list_del ( & ti -> active_list ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> if ( ( timer -> hw . flags & SNDRV_TIMER_HW_TASKLET ) || <NEW_LINE> <TAB> <TAB> ( ti -> flags & SNDRV_TIMER_IFLG_FAST ) )
<TAB> <TAB> <TAB> <TAB> zend_unmangle_property_name_ex ( key , & tmp , & prop_name , & prop_len ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> zend_update_property ( ce , return_value , prop_name , prop_len , data ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> else <NEW_LINE> <TAB> <TAB> {
<START_VULN> <NEW_LINE> <END_VULN> <TAB> for ( ; ; ) { <NEW_LINE> <TAB> <TAB> if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> if ( errno == EPIPE )
static void tokenadd ( struct jv_parser * p , char c ) { <NEW_LINE> assert ( p -> tokenpos <= p -> tokenlen ) ; <NEW_LINE> <START_VULN> if ( p -> tokenpos == p -> tokenlen ) { <NEW_LINE> <END_VULN> <TAB> p -> tokenlen = p -> tokenlen * 2 + 256 ; <NEW_LINE> <TAB> p -> tokenbuf = jv_mem_realloc ( p -> tokenbuf , p -> tokenlen ) ; <NEW_LINE> }
<TAB> } <NEW_LINE> <START_VULN> if ( ( ret = test_streaming ( stream , <NEW_LINE><TAB> <TAB> <TAB> buf , <NEW_LINE><TAB> <TAB> <TAB> buf + ( 1 << 20 ) , <NEW_LINE><TAB> <TAB> <TAB> buf + ( 2 << 20 ) , <NEW_LINE><TAB> <TAB> <TAB> 1 << 12 ) ) ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> goto fail ; <NEW_LINE> <TAB> }
0 . 9919389832F , 0 . 9931929973F , 0 . 9942985174F , 0 . 9952667537F , <NEW_LINE> 0 . 9961087037F , 0 . 9968351119F , 0 . 9974564312F , 0 . 9979827858F , <NEW_LINE> 0 . 9984239359F , 0 . 9987892441F , 0 . 9990876435F , 0 . 9993276081F , <NEW_LINE> 0 . 9995171241F , 0 . 9996636648F , 0 . 9997741654F , 0 . 9998550016F , <NEW_LINE> 0 . 9999119692F , 0 . 9999502656F , 0 . 9999744742F , 0 . 9999885497F , <NEW_LINE> 0 . 9999958064F , 0 . 9999989077F , 0 . 9999998584F , 0 . 9999999983F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin512 [ 256 ] = { <NEW_LINE> <END_VULN> 0 . 0000147849F , 0 . 0001330607F , 0 . 0003695946F , 0 . 0007243509F , <NEW_LINE> 0 . 0011972759F , 0 . 0017882983F , 0 . 0024973285F , 0 . 0033242588F , <NEW_LINE> 0 . 0042689632F , 0 . 0053312973F , 0 . 0065110982F , 0 . 0078081841F , <NEW_LINE> 0 . 0092223540F , 0 . 0107533880F , 0 . 0124010466F , 0 . 0141650703F , <NEW_LINE> 0 . 0160451800F , 0 . 0180410758F , 0 . 0201524373F , 0 . 0223789233F , <NEW_LINE> 0 . 0247201710F , 0 . 0271757958F , 0 . 0297453914F , 0 . 0324285286F , <NEW_LINE> 0 . 0352247556F , 0 . 0381335972F , 0 . 0411545545F , 0 . 0442871045F , <NEW_LINE> 0 . 0475306997F , 0 . 0508847676F , 0 . 0543487103F , 0 . 0579219038F ,
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : basic codebook pack / unpack / code / decode operations <NEW_LINE> <START_VULN> last mod : $ Id : codebook . c 16227 2009 - 07 - 08 06 : 58 : 46Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
extern void <NEW_LINE> js_LeaveSharpObject ( JSContext * cx , JSIdArray ** idap ) ; <NEW_LINE> extern JSBool <NEW_LINE> js_obj_toSource ( JSContext * cx , JSObject * obj , uintN argc , jsval * argv , <NEW_LINE> <TAB> <TAB> jsval * rval ) ; <NEW_LINE> <START_VULN> - <NEW_LINE> <END_VULN> 1 . 4 . 1
virtual bool ms_verify_authorizer ( Connection * con , int peer_type , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> int protocol , bufferlist & authorizer , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> bufferlist & authorizer_reply , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> bool & isvalid , CryptoKey & session_key ) { <NEW_LINE> <END_VULN> <TAB> isvalid = true ; <NEW_LINE> <TAB> return true ;
<TAB> <TAB> int i ; <NEW_LINE> <TAB> <TAB> struct sem_undo * un ; <NEW_LINE> <START_VULN> <TAB> <TAB> ipc_rcu_getref ( sma ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> rcu_read_unlock ( ) ; <NEW_LINE> <TAB> <TAB> if ( nsems > SEMMSL_FAST ) {
<TAB> case 'J' : <NEW_LINE> <TAB> usage = certificateUsageObjectSigner ; <NEW_LINE> <TAB> break ; <NEW_LINE> <TAB> default : <NEW_LINE> <TAB> PORT_SetError ( SEC_ERROR_INVALID_ARGS ) ; <NEW_LINE> <TAB> return ( SECFailure ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> do { <NEW_LINE> <START_VULN> <TAB> cert = CERT_FindCertByNicknameOrEmailAddr ( handle , name ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! cert ) { <NEW_LINE> <TAB> SECU_PrintError ( progName , "could not find certificate named \" % s\"" , <NEW_LINE> <TAB> <TAB> <TAB> name ) ; <NEW_LINE> <TAB> GEN_BREAK ( SECFailure ) <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( date != NULL ) { <NEW_LINE> <TAB> rv = DER_AsciiToTime ( & timeBoundary , date ) ;
qsort ( sortpointer , n , sizeof ( * sortpointer ) , icomp ) ; <NEW_LINE> for ( i = 0 ; i < n ; i + + ) look -> forward_index [ i ] = sortpointer [ i ] - info -> postlist ; <NEW_LINE> for ( i = 0 ; i < n ; i + + ) look -> reverse_index [ look -> forward_index [ i ] ] = i ; <NEW_LINE> for ( i = 0 ; i < n ; i + + ) look -> sorted_index [ i ] = info -> postlist [ look -> forward_index [ i ] ] ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> switch ( info -> mult ) { <NEW_LINE> case 1 : <NEW_LINE> <TAB> look -> quant_q = 256 ; <NEW_LINE> <TAB> break ; <NEW_LINE> case 2 : <NEW_LINE> <TAB> look -> quant_q = 128 ; <NEW_LINE> <TAB> break ;
<TAB> <TAB> <TAB> WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; <NEW_LINE> <TAB> <TAB> <TAB> WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> ( Rec2 . RecordLength - 2 - 2 ) / 3 ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; <NEW_LINE> <TAB> <TAB> <TAB> image -> colors = WPG_Palette . NumOfEntries ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ! AcquireImageColormap ( image , image -> colors , exception ) )
<TAB> <TAB> } else if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || <NEW_LINE> <TAB> <TAB> ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> guint offset = 0 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> proto_item * ti = NULL ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> proto_tree * hsrp_tree = NULL ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> guint8 type , len ;
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> case ASF_DEMUX_DATA_TYPE_BOOL : { <NEW_LINE> <START_VULN> <TAB> <TAB> gboolean bool_val = GST_READ_UINT32_LE ( value ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( strncmp ( "Stereoscopic" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> if ( bool_val ) {
#include < ft2build . h > <NEW_LINE> #include FT_CONFIG_CONFIG_H <NEW_LINE> #include FT_INTERNAL_OBJECTS_H <NEW_LINE> #include FT_INTERNAL_DEBUG_H <NEW_LINE> #include FT_MODULE_H <NEW_LINE> #include "basepic . h" <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #undef FT_COMPONENT <NEW_LINE> #define FT_COMPONENT trace_init
ip : <NEW_LINE> <TAB> <TAB> iph = __skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , data , hlen , & _iph ) ; <NEW_LINE> <TAB> <TAB> if ( ! iph || iph -> ihl < 5 ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <END_VULN> <TAB> <TAB> nhoff += iph -> ihl * 4 ; <NEW_LINE> <TAB> <TAB> ip_proto = iph -> protocol ;
MODULE_AUTHOR ( "Tim Chen < tim . c . chen@linux . intel . com > " ) ; <NEW_LINE> MODULE_DESCRIPTION ( "T10 DIF CRC calculation . " ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "crct10dif" ) ; <NEW_LINE> <END_VULN>
<TAB> return 0 ; <NEW_LINE> unmap_pages : <NEW_LINE> <START_VULN> <TAB> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ; <NEW_LINE> <END_VULN> <TAB> return r ; <NEW_LINE> }
<TAB> <TAB> <TAB> goto out_qunlock ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> max_bytes = bytes ; <NEW_LINE> <START_VULN> <TAB> <TAB> calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> al -> al_requested = data_blocks + ind_blocks ; <NEW_LINE> <TAB> <TAB> rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +
<TAB> <TAB> if ( IS_ERR ( uid_keyring ) ) { <NEW_LINE> <TAB> <TAB> <TAB> uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> cred , user_keyring_perm , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> KEY_ALLOC_IN_QUOTA , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> NULL , NULL ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( IS_ERR ( uid_keyring ) ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ret = PTR_ERR ( uid_keyring ) ;
<TAB> err = blkdev_issue_discard ( bdev , req -> u . discard . sector_number , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> req -> u . discard . nr_sectors , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> GFP_KERNEL , secure ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> if ( err == - EOPNOTSUPP ) { <NEW_LINE> <TAB> <TAB> pr_debug ( DRV_PFX "discard op failed , not supported\n" ) ; <NEW_LINE> <TAB> <TAB> status = BLKIF_RSP_EOPNOTSUPP ;
<TAB> int rtype = f -> residue_types [ rn ] ; <NEW_LINE> <TAB> int c = r -> classbook ; <NEW_LINE> <TAB> int classwords = f -> codebooks [ c ] . dimensions ; <NEW_LINE> <START_VULN> int n_read = r -> end - r -> begin ; <NEW_LINE> <END_VULN> <TAB> int part_read = n_read / r -> part_size ; <NEW_LINE> <TAB> int temp_alloc_point = temp_alloc_save ( f ) ; <NEW_LINE> <TAB> #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha1 - powerpc" ) ; <NEW_LINE> <END_VULN>
<TAB> link_info . dest = nla_get_flag ( link [ TIPC_NLA_LINK_DEST ] ) ; <NEW_LINE> <TAB> link_info . up = htonl ( nla_get_flag ( link [ TIPC_NLA_LINK_UP ] ) ) ; <NEW_LINE> <START_VULN> <TAB> strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ; <NEW_LINE> <END_VULN> <TAB> return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , <NEW_LINE> <TAB> <TAB> <TAB> & link_info , sizeof ( link_info ) ) ;
{ <NEW_LINE> <TAB> if ( ( opcode & OPCODE ) == SPEC0 && ( opcode & FUNC ) == SYNC ) { <NEW_LINE> <TAB> <TAB> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> 1 , 0 , regs , 0 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> }
<TAB> nsresult SaveSelection ( nsISelection * aSel ) ; <NEW_LINE> <TAB> nsresult RestoreSelection ( nsISelection * aSel ) ; <NEW_LINE> <TAB> bool IsCollapsed ( ) ; <NEW_LINE> <TAB> bool IsEqual ( nsSelectionState * aSelState ) ; <NEW_LINE> <TAB> void MakeEmpty ( ) ; <NEW_LINE> <TAB> bool IsEmpty ( ) ; <NEW_LINE> protected : <NEW_LINE> <START_VULN> <TAB> nsTArray < nsRangeStore > mArray ; <NEW_LINE> <END_VULN> <TAB> friend class nsRangeUpdater ; <NEW_LINE> } ; <NEW_LINE> class nsRangeUpdater <NEW_LINE> { <NEW_LINE> public :
<TAB> <TAB> return AVERROR_INVALIDDATA ; <NEW_LINE> <TAB> if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) { <NEW_LINE> <TAB> <TAB> avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; <NEW_LINE> <START_VULN> <TAB> } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) <NEW_LINE> <TAB> <TAB> <TAB> return AVERROR_INVALIDDATA ; <NEW_LINE> <TAB> <TAB> avctx -> pix_fmt = AV_PIX_FMT_BGR24 ;
<TAB> if ( ( layer_info -> channel_info [ channel ] . type != - 2 ) || <NEW_LINE> <TAB> <TAB> ( layer_info -> mask . flags > 2 ) || ( ( layer_info -> mask . flags & 0x02 ) && <NEW_LINE> <TAB> <TAB> <TAB> ( IsStringTrue ( option ) == MagickFalse ) ) ) <NEW_LINE> <START_VULN> <TAB> { <NEW_LINE><TAB> <TAB> SeekBlob ( image , layer_info -> channel_info [ channel ] . size - 2 , SEEK_CUR ) ; <NEW_LINE><TAB> <TAB> return ( MagickTrue ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> mask = CloneImage ( image , layer_info -> mask . page . width , <NEW_LINE> <TAB> <TAB> layer_info -> mask . page . height , MagickFalse , exception ) ; <NEW_LINE> <TAB> if ( mask != ( Image * ) NULL )
<TAB> <TAB> <TAB> <TAB> bytecnt = m -> str_range ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( bytecnt == 0 || bytecnt > nbytes - offset ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> bytecnt = nbytes - offset ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> buf = RCAST ( const char * , s ) + offset ; <NEW_LINE> <TAB> <TAB> <TAB> end = last = RCAST ( const char * , s ) + bytecnt ;
<TAB> gpio_dev -> ngroups = ARRAY_SIZE ( kerncz_groups ) ; <NEW_LINE> <TAB> amd_pinctrl_desc . name = dev_name ( & pdev -> dev ) ; <NEW_LINE> <START_VULN> <TAB> gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> & pdev -> dev , gpio_dev ) ; <NEW_LINE> <END_VULN> <TAB> if ( IS_ERR ( gpio_dev -> pctrl ) ) { <NEW_LINE> <TAB> <TAB> dev_err ( & pdev -> dev , "Couldn't register pinctrl driver\n" ) ; <NEW_LINE> <TAB> <TAB> return PTR_ERR ( gpio_dev -> pctrl ) ;
<TAB> <TAB> vd = & ( iso9660 -> joliet ) ; <NEW_LINE> <START_VULN> <TAB> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <NEW_LINE> <END_VULN> <TAB> skipsize = __archive_read_consume ( a , skipsize ) ; <NEW_LINE> <TAB> if ( skipsize < 0 ) <NEW_LINE> <TAB> <TAB> return ( ( int ) skipsize ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Salsa20 stream cipher algorithm ( optimized assembly version ) " ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "salsa20" ) ; <NEW_LINE>MODULE_ALIAS ( "salsa20 - asm" ) ; <NEW_LINE> <END_VULN>
<TAB> } else <NEW_LINE> <TAB> <TAB> goto out2 ; <NEW_LINE> <START_VULN> <TAB> len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> unifilename -> u_name , unifilename -> u_len ) ; <NEW_LINE> out2 : <NEW_LINE> <TAB> kfree ( unifilename ) ;
<TAB> spin_lock_init ( & group -> inotify_data . idr_lock ) ; <NEW_LINE> <TAB> idr_init ( & group -> inotify_data . idr ) ; <NEW_LINE> <TAB> group -> inotify_data . last_wd = 0 ; <NEW_LINE> <START_VULN> <TAB> group -> inotify_data . user = user ; <NEW_LINE> <END_VULN> <TAB> group -> inotify_data . fa = NULL ; <NEW_LINE> <TAB> return group ; <NEW_LINE> }
{ <NEW_LINE> <TAB> zval <TAB> <TAB> * retval_ptr ; <TAB> <TAB> <NEW_LINE> <TAB> zval <TAB> ** args [ 1 ] ; <TAB> <TAB> <TAB> <NEW_LINE> <START_VULN> <TAB> zval <TAB> <TAB> * subpats ; <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> int <TAB> <TAB> <TAB> result_len ; <TAB> <TAB> <NEW_LINE> <TAB> int <TAB> <TAB> <TAB> i ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : code raw packets into framed OggSquish stream and <NEW_LINE> <TAB> <TAB> <TAB> decode Ogg streams back into raw packets <NEW_LINE> <START_VULN> last mod : $ Id : framing . c 16051 2009 - 05 - 27 05 : 00 : 06Z xiphmont $ <NEW_LINE> <END_VULN> note : The CRC code is directly derived from public domain code by <NEW_LINE> Ross Williams ( ross@guest . adelaide . edu . au ) . See docs / framing . html <NEW_LINE> for details . <NEW_LINE> #include < stdlib . h >
<TAB> if ( ! c -> synth_tile || ! c -> jpeg_tile || <NEW_LINE> <TAB> <TAB> c -> old_tile_w < c -> tile_width || <NEW_LINE> <TAB> <TAB> c -> old_tile_h < c -> tile_height ) { <NEW_LINE> <START_VULN> <TAB> <TAB> c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> aligned_height = FFALIGN ( c -> tile_height , 16 ) ; <NEW_LINE> <TAB> <TAB> av_free ( c -> synth_tile ) ; <NEW_LINE> <TAB> <TAB> av_free ( c -> jpeg_tile ) ;
<START_VULN> void CVE_2015_4001_oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc , <NEW_LINE><TAB> <TAB> <TAB> int length , int offset , int total_size ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct oz_port * port = hport ; <NEW_LINE> <TAB> struct urb * urb ;
<TAB> <TAB> <TAB> return AVERROR_INVALIDDATA ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> avpriv_report_missing_feature ( s -> avctx , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> "JPEG - LS that is not <= 8 " <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> "bits / component or 16 - bit gray" ) ;
<TAB> <TAB> * <NEW_LINE> <TAB> bool NS_FASTCALL SetCapacity ( size_type newCapacity ) ; <NEW_LINE> <START_VULN> <TAB> void NS_FASTCALL SetLength ( size_type newLength ) ; <NEW_LINE> <END_VULN> <TAB> void Truncate ( size_type newLength = 0 ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> NS_ASSERTION ( newLength <= mLength , "Truncate cannot make string longer" ) ; <NEW_LINE> <TAB> <TAB> SetLength ( newLength ) ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> <TAB> <TAB> size_t count ) <NEW_LINE> { <NEW_LINE> <TAB> struct o2nm_node * node = to_o2nm_node ( item ) ; <NEW_LINE> <START_VULN> <TAB> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <NEW_LINE> <END_VULN> <TAB> unsigned long tmp ; <NEW_LINE> <TAB> char * p = ( char * ) page ; <NEW_LINE> <TAB> int ret = 0 ;
<TAB> TOREAD_HTTP_HEADER <TAB> <TAB> = - 2 , <NEW_LINE> <TAB> TOREAD_HTTP_CHUNK_LENGTH <TAB> = - 3 , <NEW_LINE> <TAB> TOREAD_HTTP_CHUNK_TRAILER <TAB> = - 4 , <NEW_LINE> <START_VULN> <TAB> TOREAD_HTTP_NONE <TAB> <TAB> = - 5 <NEW_LINE> <END_VULN> } ; <NEW_LINE> #if DEBUG
module_init ( des_s390_init ) ; <NEW_LINE> module_exit ( des_s390_exit ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "des" ) ; <NEW_LINE>MODULE_ALIAS ( "des3_ede" ) ; <NEW_LINE> <END_VULN> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "DES & Triple DES EDE Cipher Algorithms" ) ;
<TAB> struct waitid_info info = { . status = 0 } ; <NEW_LINE> <TAB> long err = kernel_waitid ( which , upid , & info , options , ru ? & r : NULL ) ; <NEW_LINE> <TAB> int signo = 0 ; <NEW_LINE> <TAB> if ( err > 0 ) { <NEW_LINE> <TAB> <TAB> signo = SIGCHLD ; <NEW_LINE> <TAB> <TAB> err = 0 ; <NEW_LINE> <START_VULN> <TAB> } <NEW_LINE><NEW_LINE><TAB> if ( ! err ) { <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ru && copy_to_user ( ru , & r , sizeof ( struct rusage ) ) ) <NEW_LINE> <TAB> <TAB> <TAB> return - EFAULT ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> <TAB> umount_mnt ( p ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> else umount_tree ( mnt , 0 ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> unlock_mount_hash ( ) ; <NEW_LINE> <TAB> put_mountpoint ( mp ) ;
<TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> good = ( unsigned ) - 1 ; <NEW_LINE> <END_VULN> <TAB> minLength = crSpec -> mac_size ; <NEW_LINE> <TAB> if ( cipher_def -> type == type_block ) {
float * ath ; <NEW_LINE> long * octave ; <NEW_LINE> long * bark ; <NEW_LINE> long firstoc ; <NEW_LINE> long shiftoc ; <NEW_LINE> int eighth_octave_lines ; <NEW_LINE> <START_VULN> int total_octave_lines ; <NEW_LINE> <END_VULN> long rate ; <NEW_LINE> float m_val ; <NEW_LINE> } vorbis_look_psy ; <NEW_LINE> extern void _vp_psy_init ( vorbis_look_psy * p , vorbis_info_psy * vi , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> vorbis_info_psy_global * gi , int n , long rate ) ;
<TAB> guint <TAB> curr_len ; <NEW_LINE> <START_VULN> <TAB> memset ( str , 0 , MAX_APN_LENGTH ) ; <NEW_LINE> <END_VULN> <TAB> tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ) ; <NEW_LINE> <TAB> curr_len = 0 ;
<TAB> RETVAL_BOOL ( phar_open_from_filename ( fname , fname_len , alias , alias_len , REPORT_ERRORS , NULL , & error TSRMLS_CC ) == SUCCESS ) ; <NEW_LINE> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> } <NEW_LINE> }
<TAB> <TAB> <TAB> <TAB> if ( ! result ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> result = x ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> op = ( REOp ) * pc + + ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> continue ;
<TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ! flen ) <NEW_LINE> <TAB> <TAB> <TAB> continue ;
<TAB> password_empty = 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> } else { <NEW_LINE> <END_VULN> <TAB> cli_md5_init ( & md5 ) ;
long n = look -> n ; <NEW_LINE> long posts = look -> posts ; <NEW_LINE> long nonzero = 0 ; <NEW_LINE> lsfit_acc fits [ VIF_POSIT + 1 ] ; <NEW_LINE> int fit_valueA [ VIF_POSIT + 2 ] ; <NEW_LINE> int fit_valueB [ VIF_POSIT + 2 ] ; <NEW_LINE> int loneighbor [ VIF_POSIT + 2 ] ; <NEW_LINE> <START_VULN> int hineighbor [ VIF_POSIT + 2 ] ; <NEW_LINE> <END_VULN> int * output = NULL ; <NEW_LINE> int memo [ VIF_POSIT + 2 ] ; <NEW_LINE> for ( i = 0 ; i < posts ; i + + ) fit_valueA [ i ] = - 200 ; <NEW_LINE> for ( i = 0 ; i < posts ; i + + ) fit_valueB [ i ] = - 200 ; <NEW_LINE> for ( i = 0 ; i < posts ; i + + ) loneighbor [ i ] = 0 ; <NEW_LINE> for ( i = 0 ; i < posts ; i + + ) hineighbor [ i ] = 1 ; <NEW_LINE> for ( i = 0 ; i < posts ; i + + ) memo [ i ] = - 1 ;
<TAB> parent = dentry -> d_parent ; <NEW_LINE> <TAB> nfs_block_sillyrename ( parent ) ; <NEW_LINE> <START_VULN> <TAB> state = nfs4_do_open ( dir , & path , nd -> intent . open . flags , & attr , cred ) ; <NEW_LINE> <END_VULN> <TAB> put_rpccred ( cred ) ; <NEW_LINE> <TAB> if ( IS_ERR ( state ) ) { <NEW_LINE> <TAB> <TAB> if ( PTR_ERR ( state ) == - ENOENT ) {
static PRUint32 GetWorkerCloseHandlerTimeoutMS ( ) ; <NEW_LINE> PRBool QueueSuspendedWorker ( nsDOMWorkerRunnable * aRunnable ) ; <NEW_LINE> nsCOMPtr < nsIThreadPool > mThreadPool ; <NEW_LINE> <START_VULN> nsRefPtrHashtable < nsISupportsHashKey , nsDOMWorkerPool > mPools ; <NEW_LINE> <END_VULN> PRMonitor * mMonitor ; <NEW_LINE> nsRefPtrHashtable < nsVoidPtrHashKey , nsDOMWorkerRunnable > mWorkersInProgress ;
<TAB> rkey = s2s_route_key ( NULL , to -> domain , from -> domain ) ; <NEW_LINE> <TAB> attr = nad_find_attr ( nad , 0 , - 1 , "type" , "valid" ) ; <NEW_LINE> <START_VULN> <TAB> if ( attr >= 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ; <NEW_LINE> <TAB> <TAB> log_write ( in -> s2s -> log , LOG_NOTICE , " [ % d ] [ % s , port = % d ] incoming route ' % s' is now valid % s % s" , in -> fd -> fd , in -> ip , in -> port , rkey , ( in -> s -> flags & SX_SSL_WRAPPER ) ? " , TLS negotiated" : "" , in -> s -> compressed ? " , ZLIB compression enabled" : "" ) ; <NEW_LINE> <TAB> <TAB> valid = 1 ;
<TAB> SECStatus rv ; <NEW_LINE> <TAB> SSL3WaitState ws = ss -> ssl3 . hs . ws ; <NEW_LINE> <TAB> SSL_TRC ( 3 , ( " % d : SSL3 [ % d ] : handle server_hello_done handshake" , <NEW_LINE> <TAB> <TAB> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> <TAB> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> <TAB> if ( ws != wait_hello_done && <NEW_LINE> <START_VULN> <TAB> <TAB> ws != wait_server_cert && <NEW_LINE><TAB> ws != wait_server_key && <NEW_LINE> <END_VULN> <TAB> ws != wait_cert_request ) { <NEW_LINE> <TAB> SSL3_SendAlert ( ss , alert_fatal , unexpected_message ) ; <NEW_LINE> <TAB> PORT_SetError ( SSL_ERROR_RX_UNEXPECTED_HELLO_DONE ) ; <NEW_LINE> <TAB> return SECFailure ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> rv = ssl3_SendClientSecondRound ( ss ) ;
<TAB> struct posix_acl_entry * acl_e ; <NEW_LINE> <TAB> struct posix_acl * acl ; <NEW_LINE> <TAB> struct xfs_acl_entry * ace ; <NEW_LINE> <START_VULN> <TAB> int count , i ; <NEW_LINE> <END_VULN> <TAB> count = be32_to_cpu ( aclp -> acl_cnt ) ; <NEW_LINE> <TAB> if ( count > XFS_ACL_MAX_ENTRIES )
void ClearTextRun ( nsTextFrame * aStartContinuation , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> TextRunType aWhichTextRun ) ; <NEW_LINE> void ClearTextRuns ( ) { <NEW_LINE> <TAB> ClearTextRun ( nsnull , nsTextFrame : : eInflated ) ; <NEW_LINE> <START_VULN> <TAB> ClearTextRun ( nsnull , nsTextFrame : : eNotInflated ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> struct TrimmedOffsets { <NEW_LINE> <TAB> PRInt32 mStart ; <NEW_LINE> <TAB> PRInt32 mLength ;
<TAB> unregister_inetaddr_notifier ( & sctp_inetaddr_notifier ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int __net_init sctp_net_init ( struct net * net ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> int status ;
<TAB> <TAB> <TAB> <TAB> return ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> it = item_get ( key , nkey , c , DO_UPDATE ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( settings . detail_enabled ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> stats_prefix_record_get ( key , nkey , NULL != it ) ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> <TAB> frag -> len -= len ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { <NEW_LINE> <END_VULN> <TAB> <TAB> vcpu -> mmio_needed = 0 ;
* <NEW_LINE> #ifndef _nsCrypto_h_ <NEW_LINE> #define _nsCrypto_h_ <NEW_LINE> #include "nsCOMPtr . h" <NEW_LINE> #include "nsIDOMCRMFObject . h" <NEW_LINE> #include "nsIDOMCrypto . h" <NEW_LINE> <START_VULN> #include "nsIDOMPkcs11 . h" <NEW_LINE> <END_VULN> #include "nsIRunnable . h" <NEW_LINE> #include "nsString . h" <NEW_LINE> #include "jsapi . h" <NEW_LINE> #include "nsIPrincipal . h" <NEW_LINE> #define NS_CRYPTO_CLASSNAME "Crypto JavaScript Class" <NEW_LINE> #define NS_CRYPTO_CID \ <NEW_LINE> { 0x929d9320 , 0x251e , 0x11d4 , { 0x8a , 0x7c , 0x00 , 0x60 , 0x08 , 0xc8 , 0x44 , 0xc3 } }
<TAB> nsCOMPtr < nsILoadGroup > mLoadGroup ; <NEW_LINE> <TAB> nsCOMPtr < nsIStreamListener > mListener ; <NEW_LINE> <TAB> nsCOMPtr < nsISupports > mListenerContext ; <NEW_LINE> <TAB> nsCString mContentType ; <NEW_LINE> <TAB> nsCString mContentCharset ; <NEW_LINE> <TAB> PRInt32 mContentLength ; <NEW_LINE> <TAB> PRUint32 mLoadFlags ; <NEW_LINE> <TAB> nsresult mStatus ; <NEW_LINE> <START_VULN> <TAB> PRBool mIsPending ; <NEW_LINE> <END_VULN> <TAB> nsJARInputThunk * mJarInput ; <NEW_LINE> <TAB> nsCOMPtr < nsIStreamListener > mDownloader ; <NEW_LINE> <TAB> nsCOMPtr < nsIInputStreamPump > mPump ; <NEW_LINE> <TAB> nsCOMPtr < nsIFile > mJarFile ; <NEW_LINE> <TAB> nsCOMPtr < nsIURI > mJarBaseURI ; <NEW_LINE> <TAB> nsCString mJarEntry ; <NEW_LINE> } ;
<TAB> udpmsg . msg_name = ( void * ) & udpdest ; <NEW_LINE> <TAB> udpmsg . msg_namelen = sizeof ( udpdest ) ; <NEW_LINE> <TAB> udpmsg . msg_iov = & iov [ 0 ] ; <NEW_LINE> <START_VULN> <TAB> udpmsg . msg_iovlen = msg -> msg_iovlen + 1 ; <NEW_LINE> <END_VULN> <TAB> udpmsg . msg_control = NULL ; <NEW_LINE> <TAB> udpmsg . msg_controllen = 0 ; <NEW_LINE> <TAB> udpmsg . msg_flags = 0 ;
<TAB> perf_prepare_sample ( & header , & data , event , & regs ) ; <NEW_LINE> <START_VULN> <TAB> if ( perf_output_begin ( & handle , event , header . size * ( top - at ) , 1 , 1 ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return 1 ; <NEW_LINE> <TAB> for ( ; at < top ; at + + ) {
if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) <NEW_LINE> <TAB> ThrowImageException ( FileOpenError , "UnableToCreateTemporaryFile" ) ; <NEW_LINE> while ( ( c = ReadBlobByte ( image ) ) != EOF ) <NEW_LINE> <START_VULN> <TAB> ( void ) fputc ( c , file ) ; <NEW_LINE> <END_VULN> ( void ) fclose ( file ) ; <NEW_LINE> ( void ) CloseBlob ( image ) ; <NEW_LINE> image = DestroyImage ( image ) ;
<TAB> payload = NULL ; <NEW_LINE> <START_VULN> <TAB> if ( _payload ) { <NEW_LINE> <END_VULN> <TAB> <TAB> ret = - ENOMEM ; <NEW_LINE> <TAB> <TAB> payload = kvmalloc ( plen , GFP_KERNEL ) ; <NEW_LINE> <TAB> <TAB> if ( ! payload )
<TAB> <TAB> if ( acl_len > buflen ) <NEW_LINE> <TAB> <TAB> <TAB> goto out_free ; <NEW_LINE> <TAB> <TAB> _copy_from_pages ( buf , pages , res . acl_data_offset , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> res . acl_len ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> ret = acl_len ; <NEW_LINE> out_free :
<START_VULN> void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , <NEW_LINE><TAB> const u8 * desc , int length , int offset , int total_size ) ; <NEW_LINE> <END_VULN> void oz_hcd_control_cnf ( void * hport , u8 req_id , u8 rcode , <NEW_LINE> <TAB> const u8 * data , int data_len ) ;
<TAB> <TAB> <TAB> <TAB> "UnexpectedEndOfFile" , image -> filename ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> ( void ) fputc ( c , file ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> ( void ) fclose ( file ) ; <NEW_LINE> <TAB> <TAB> if ( c == EOF )
<TAB> struct fake_dirent * fde ; <NEW_LINE> <TAB> blocksize = dir -> i_sb -> s_blocksize ; <NEW_LINE> <START_VULN> <TAB> dxtrace ( printk ( KERN_DEBUG "Creating index\n" ) ) ; <NEW_LINE> <END_VULN> <TAB> retval = ext4_journal_get_write_access ( handle , bh ) ; <NEW_LINE> <TAB> if ( retval ) { <NEW_LINE> <TAB> <TAB> ext4_std_error ( dir -> i_sb , retval ) ;
<TAB> security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; <NEW_LINE> <START_VULN> <TAB> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <NEW_LINE> <END_VULN> <TAB> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; <NEW_LINE> <TAB> if ( IS_ERR ( dst ) ) {
<TAB> fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; <NEW_LINE> <TAB> fptr -> nexthdr = nexthdr ; <NEW_LINE> <TAB> fptr -> reserved = 0 ; <NEW_LINE> <START_VULN> <TAB> ipv6_select_ident ( fptr ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> if ( get_vmx_mem_address ( vcpu , exit_qualification , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> vmx_instruction_info , true , & gva ) ) <NEW_LINE> <TAB> <TAB> <TAB> return 1 ; <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> kvm_write_guest_virt_system ( & vcpu -> arch . emulate_ctxt , gva , <NEW_LINE> <TAB> <TAB> <TAB> & field_value , ( is_long_mode ( vcpu ) ? 8 : 4 ) , NULL ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> if ( parents ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> mkdir_parents ( path , 0755 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> fd = open ( path , O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY , mode > 0 ? mode : 0644 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( fd < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return - errno ;
<TAB> if ( avctx -> height * istride == avpkt -> size ) { <NEW_LINE> <START_VULN> <TAB> <TAB> int linesize = ( avctx -> width * avctx -> bits_per_coded_sample + 7 ) / 8 ; <NEW_LINE> <END_VULN> <TAB> <TAB> uint8_t * ptr = s -> frame -> data [ 0 ] ; <NEW_LINE> <TAB> <TAB> uint8_t * buf = avpkt -> data + ( avctx -> height - 1 ) * istride ; <NEW_LINE> <TAB> <TAB> int i , j ;
<TAB> <TAB> uint32_t lineIndexToNum ( uint32_t lineIndex ) const { return lineIndex + initialLineNum_ ; } <NEW_LINE> <TAB> <TAB> uint32_t lineNumToIndex ( uint32_t lineNum ) const { return lineNum - initialLineNum_ ; } <NEW_LINE> <TAB> public : <NEW_LINE> <TAB> <TAB> SourceCoords ( JSContext * cx , uint32_t ln ) ; <NEW_LINE> <TAB> <TAB> void add ( uint32_t lineNum , uint32_t lineStartOffset ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> void fill ( const SourceCoords & other ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> bool isOnThisLine ( uint32_t offset , uint32_t lineNum ) const { <NEW_LINE> <TAB> <TAB> <TAB> uint32_t lineIndex = lineNumToIndex ( lineNum ) ; <NEW_LINE> <TAB> <TAB> <TAB> JS_ASSERT ( lineIndex + 1 < lineStartOffsets_ . length ( ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> return lineStartOffsets_ [ lineIndex ] <= offset && <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> offset < lineStartOffsets_ [ lineIndex + 1 ] ; <NEW_LINE> <TAB> <TAB> }
<TAB> ask -> private = ctx ; <NEW_LINE> <START_VULN> <TAB> skcipher_request_set_tfm ( & ctx -> req , private ) ; <NEW_LINE> <END_VULN> <TAB> skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> af_alg_complete , & ctx -> completion ) ;
tap_ops_failed : <NEW_LINE> <TAB> rtnl_link_unregister ( & ipgre_link_ops ) ; <NEW_LINE> rtnl_link_failed : <NEW_LINE> <START_VULN> <TAB> unregister_pernet_device ( & ipgre_net_ops ) ; <NEW_LINE>gen_device_failed : <NEW_LINE> <END_VULN> <TAB> inet_del_protocol ( & ipgre_protocol , IPPROTO_GRE ) ; <NEW_LINE> <TAB> goto out ; <NEW_LINE> }
<TAB> spin_lock_bh ( & net -> nsid_lock ) ; <NEW_LINE> <TAB> peer = idr_find ( & net -> netns_ids , id ) ; <NEW_LINE> <TAB> if ( peer ) <NEW_LINE> <START_VULN> <TAB> <TAB> get_net ( peer ) ; <NEW_LINE> <END_VULN> <TAB> spin_unlock_bh ( & net -> nsid_lock ) ; <NEW_LINE> <TAB> rcu_read_unlock ( ) ;
<START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> last_pic_structure == PICT_TOP_FIELD ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> }
<TAB> char * datablob ; <NEW_LINE> <TAB> int ret = 0 ; <NEW_LINE> <START_VULN> <TAB> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - ENOKEY ; <NEW_LINE> <TAB> p = key -> payload . data [ 0 ] ; <NEW_LINE> <TAB> if ( ! p -> migratable )
<TAB> } <NEW_LINE> <TAB> crm_trace ( "Sending % s message to CIB service" , op ) ; <NEW_LINE> <START_VULN> <TAB> crm_send_remote_msg ( private -> command . session , op_msg , private -> command . encrypted ) ; <NEW_LINE> <END_VULN> <TAB> free_xml ( op_msg ) ; <NEW_LINE> <TAB> if ( ( call_options & cib_discard_reply ) ) {
EXPORT_SYMBOL ( sysctl_tcp_adv_win_scale ) ; <NEW_LINE> <START_VULN> int sysctl_tcp_challenge_ack_limit = 100 ; <NEW_LINE> <END_VULN> int sysctl_tcp_stdurg __read_mostly ; <NEW_LINE> int sysctl_tcp_rfc1337 __read_mostly ;
<TAB> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ! ( exp -> ex_layout_types & ( 1 << layout_type ) ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> dprintk ( " % s : layout type % d not supported\n" , <NEW_LINE> <TAB> <TAB> <TAB> __func__ , layout_type ) ; <NEW_LINE> <TAB> <TAB> return NULL ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : registry for time , floor , res backends and channel mappings <NEW_LINE> <START_VULN> last mod : $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_REG_H_ <NEW_LINE> #define _V_REG_H_ <NEW_LINE> #define VI_TRANSFORMB 1 <NEW_LINE> #define VI_WINDOWB 1
<TAB> { <NEW_LINE> <TAB> <TAB> MsgToEventLog ( M_SYSERR , TEXT ( "malformed startup data : 1 byte received" ) ) ; <NEW_LINE> <TAB> <TAB> ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> goto out ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> data = malloc ( bytes ) ;
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "cert . h" <NEW_LINE> #include "ssl . h" <NEW_LINE> #include "cryptohi . h" <TAB> <NEW_LINE> #include "keyhi . h" <NEW_LINE> #include "secder . h" <NEW_LINE> #include "secitem . h"
<TAB> for ( i = 0 ; i < B43_NR_FWTYPES ; i + + ) { <NEW_LINE> <TAB> <TAB> errmsg = ctx -> errors [ i ] ; <NEW_LINE> <TAB> <TAB> if ( strlen ( errmsg ) ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> b43err ( dev -> wl , errmsg ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> b43_print_fw_helptext ( dev -> wl , 1 ) ; <NEW_LINE> <TAB> goto out ;
CVE_2012_3979_nsFrameMessageManager : : Dump ( const nsAString & aStr ) <NEW_LINE> { <NEW_LINE> #ifdef ANDROID <NEW_LINE> <START_VULN> __android_log_print ( ANDROID_LOG_INFO , "Gecko" , NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> fputs ( NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) , stdout ) ; <NEW_LINE> fflush ( stdout ) ;
<TAB> <TAB> return AVERROR ( ENOMEM ) ; <NEW_LINE> <TAB> hdr = * phdr ; <NEW_LINE> <START_VULN> <TAB> init_get_bits8 ( & gb , buf , size ) ; <NEW_LINE> <END_VULN> <TAB> err = ff_ac3_parse_header ( & gb , hdr ) ; <NEW_LINE> <TAB> if ( err < 0 ) <NEW_LINE> <TAB> <TAB> return AVERROR_INVALIDDATA ;
<TAB> } <NEW_LINE> <TAB> size_offsets = ( size_offsets + 1 ) * 3 ; <NEW_LINE> <TAB> offsets = ( int * ) safe_emalloc ( size_offsets , sizeof ( int ) , 0 ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> array_init ( return_value ) ;
<TAB> XPCWrappedNativeScope * <NEW_LINE> <TAB> GetScope ( ) const { return mScope ; } <NEW_LINE> <TAB> XPCJSRuntime * <NEW_LINE> <TAB> GetRuntime ( ) const { return mScope -> GetRuntime ( ) ; } <NEW_LINE> <TAB> JSObject * <NEW_LINE> <START_VULN> <TAB> GetJSProtoObject ( ) const { return mJSProtoObject ; } <NEW_LINE> <END_VULN> <TAB> nsIClassInfo * <NEW_LINE> <TAB> GetClassInfo ( ) const { return mClassInfo ; } <NEW_LINE> <TAB> XPCNativeSet * <NEW_LINE> <TAB> GetSet ( ) const { return mSet ; } <NEW_LINE> <TAB> XPCNativeScriptableInfo *
<START_VULN> <TAB> if ( dest == a -> name ) { <NEW_LINE> <END_VULN>
<START_VULN> PHPAPI void php_stat ( const char * filename , php_stat_len filename_length , int type , zval * return_value ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> zval stat_dev , stat_ino , stat_mode , stat_nlink , stat_uid , stat_gid , stat_rdev , <NEW_LINE> <TAB> <TAB> stat_size , stat_atime , stat_mtime , stat_ctime , stat_blksize , stat_blocks ;
<TAB> oldsize += bits ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> if ( msg -> maxsize - msg -> cursize < 4 ) { <NEW_LINE><TAB> <TAB> msg -> overflowed = qtrue ; <NEW_LINE> <END_VULN> <TAB> <TAB> return ; <NEW_LINE> <TAB> }
<TAB> <TAB> l_part_tile_size = 0 ; <NEW_LINE> <TAB> <TAB> l_begin_data = p_data ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> p_manager ) ) { <NEW_LINE> <TAB> <TAB> <TAB> return OPJ_FALSE ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> <TAB> <TAB> <TAB> replace_value = & empty_replace ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( ( result = php_pcre_replace ( Z_STRVAL_PP ( regex_entry ) ,
<TAB> } <NEW_LINE> <TAB> * rval = STRING_TO_JSVAL ( str ) ; <NEW_LINE> <TAB> return JS_TRUE ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> - <NEW_LINE> <END_VULN> 1 . 4 . 1
{ <NEW_LINE> <TAB> struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <NEW_LINE> <START_VULN> <TAB> return alg -> cra_rng . rng_make_random ? <NEW_LINE><TAB> alg -> cra_rng . seedsize : ralg -> seedsize ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef CONFIG_NET
static int kvm_set_guest_paused ( struct kvm_vcpu * vcpu ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( ! vcpu -> arch . time_page ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> vcpu -> arch . pvclock_set_guest_stopped_request = true ; <NEW_LINE> <TAB> kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ;
no_journal : <NEW_LINE> <TAB> if ( ext4_mballoc_ready ) { <NEW_LINE> <START_VULN> <TAB> <TAB> sbi -> s_mb_cache = ext4_xattr_create_cache ( sb -> s_id ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ! sbi -> s_mb_cache ) { <NEW_LINE> <TAB> <TAB> <TAB> ext4_msg ( sb , KERN_ERR , "Failed to create an mb_cache" ) ; <NEW_LINE> <TAB> <TAB> <TAB> goto failed_mount_wq ;
<TAB> { <NEW_LINE> <TAB> <TAB> return 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> mpz_powm ( v , v , key -> e , key -> n ) ; <NEW_LINE> <END_VULN> <TAB> return 0 ; <NEW_LINE> }
<TAB> static void TraceBlackJS ( JSTracer * trc , void * data ) ; <NEW_LINE> <TAB> static void TraceGrayJS ( JSTracer * trc , void * data ) ; <NEW_LINE> <TAB> void TraceXPConnectRoots ( JSTracer * trc ) ; <NEW_LINE> <TAB> void AddXPConnectRoots ( nsCycleCollectionTraversalCallback & cb ) ; <NEW_LINE> <TAB> void UnmarkSkippableJSHolders ( ) ; <NEW_LINE> <TAB> static void GCCallback ( JSRuntime * rt , JSGCStatus status ) ; <NEW_LINE> <START_VULN> <TAB> static void FinalizeCallback ( JSFreeOp * fop , JSFinalizeStatus status ) ; <NEW_LINE> <END_VULN> <TAB> inline void AddVariantRoot ( XPCTraceableVariant * variant ) ; <NEW_LINE> <TAB> inline void AddWrappedJSRoot ( nsXPCWrappedJS * wrappedJS ) ; <NEW_LINE> <TAB> inline void AddObjectHolderRoot ( XPCJSObjectHolder * holder ) ; <NEW_LINE> <TAB> nsresult AddJSHolder ( void * aHolder , nsScriptObjectTracer * aTracer ) ; <NEW_LINE> <TAB> nsresult RemoveJSHolder ( void * aHolder ) ;
} <NEW_LINE> LOCAL ( boolean ) <NEW_LINE> get_sos ( j_decompress_ptr cinfo ) <NEW_LINE> { <NEW_LINE> INT32 length ; <NEW_LINE> <START_VULN> int i , ci , n , c , cc ; <NEW_LINE> <END_VULN> jpeg_component_info * compptr ; <NEW_LINE> INPUT_VARS ( cinfo ) ; <NEW_LINE> if ( ! cinfo -> marker -> saw_SOF ) <NEW_LINE> <TAB> ERREXIT ( cinfo , JERR_SOS_NO_SOF ) ; <NEW_LINE> INPUT_2BYTES ( cinfo , length , return FALSE ) ;
0 . 9994740570F , 0 . 9995575079F , 0 . 9996306699F , 0 . 9996944099F , <NEW_LINE> 0 . 9997495605F , 0 . 9997969190F , 0 . 9998372465F , 0 . 9998712678F , <NEW_LINE> 0 . 9998996704F , 0 . 9999231041F , 0 . 9999421807F , 0 . 9999574732F , <NEW_LINE> 0 . 9999695157F , 0 . 9999788026F , 0 . 9999857885F , 0 . 9999908879F , <NEW_LINE> 0 . 9999944746F , 0 . 9999968817F , 0 . 9999984010F , 0 . 9999992833F , <NEW_LINE> 0 . 9999997377F , 0 . 9999999317F , 0 . 9999999911F , 0 . 9999999999F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin1024 [ 512 ] = { <NEW_LINE> <END_VULN> 0 . 0000036962F , 0 . 0000332659F , 0 . 0000924041F , 0 . 0001811086F , <NEW_LINE> 0 . 0002993761F , 0 . 0004472021F , 0 . 0006245811F , 0 . 0008315063F , <NEW_LINE> 0 . 0010679699F , 0 . 0013339631F , 0 . 0016294757F , 0 . 0019544965F , <NEW_LINE> 0 . 0023090133F , 0 . 0026930125F , 0 . 0031064797F , 0 . 0035493989F , <NEW_LINE> 0 . 0040217533F , 0 . 0045235250F , 0 . 0050546946F , 0 . 0056152418F , <NEW_LINE> 0 . 0062051451F , 0 . 0068243817F , 0 . 0074729278F , 0 . 0081507582F , <NEW_LINE> 0 . 0088578466F , 0 . 0095941655F , 0 . 0103596863F , 0 . 0111543789F , <NEW_LINE> 0 . 0119782122F , 0 . 0128311538F , 0 . 0137131701F , 0 . 0146242260F ,
<TAB> if ( status != CL_SUCCESS ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> hb_log ( "OpenCL : hb_generat_bin_from_kernel_source : clGetProgramInfo for CL_PROGRAM_BINARIES failed" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <END_VULN> <TAB> }
<START_VULN> <TAB> <TAB> if ( * vm_flags & ( VM_HUGEPAGE | <NEW_LINE><TAB> <TAB> <TAB> <TAB> VM_SHARED | VM_MAYSHARE | <NEW_LINE><TAB> <TAB> <TAB> <TAB> VM_PFNMAP | VM_IO | VM_DONTEXPAND | <NEW_LINE><TAB> <TAB> <TAB> <TAB> VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | <NEW_LINE><TAB> <TAB> <TAB> <TAB> VM_MIXEDMAP | VM_SAO ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> <TAB> * vm_flags &= ~ VM_NOHUGEPAGE ; <NEW_LINE> <TAB> <TAB> * vm_flags |= VM_HUGEPAGE ;
<TAB> error = - EIDRM ; <NEW_LINE> <START_VULN> <TAB> ipc_lock_object ( & sma -> sem_perm ) ; <NEW_LINE><TAB> if ( un ) { <NEW_LINE><TAB> <TAB> if ( un -> semid == - 1 ) { <NEW_LINE><TAB> <TAB> <TAB> rcu_read_unlock ( ) ; <NEW_LINE><TAB> <TAB> <TAB> goto out_unlock_free ; <NEW_LINE><TAB> <TAB> } else { <NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE><NEW_LINE><TAB> <TAB> <TAB> rcu_read_unlock ( ) ; <NEW_LINE><TAB> <TAB> } <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> error = try_atomic_semop ( sma , sops , nsops , un , task_tgid_vnr ( current ) ) ; <NEW_LINE> <TAB> if ( error <= 0 ) {
<TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> ch = ( sctp_chunkhdr_t * ) chunk -> chunk_end ; <NEW_LINE> <START_VULN> <NEW_LINE><TAB> <TAB> <TAB> skb_pull ( chunk -> skb , <NEW_LINE><TAB> <TAB> <TAB> <TAB> chunk -> chunk_end - chunk -> skb -> data ) ; <NEW_LINE><NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <NEW_LINE><TAB> <TAB> <TAB> <TAB> sctp_chunk_free ( chunk ) ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> chunk = queue -> in_progress = NULL ; <NEW_LINE><TAB> <TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> }
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm ( ARM ) " ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha1" ) ; <NEW_LINE> <END_VULN> MODULE_AUTHOR ( "David McCullough < ucdevel@gmail . com > " ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Kernel Random Number Generator" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "stdrng" ) ; <NEW_LINE> <END_VULN>
<TAB> error = l2t_send ( tdev , skb , l2e ) ; <NEW_LINE> <TAB> if ( error < 0 ) <NEW_LINE> <TAB> <TAB> kfree_skb ( skb ) ; <NEW_LINE> <START_VULN> <TAB> return error ; <NEW_LINE> <END_VULN> } <NEW_LINE> int iwch_cxgb3_ofld_send ( struct t3cdev * tdev , struct sk_buff * skb )
} <NEW_LINE> const nsCString & ClassName ( ) const { <NEW_LINE> <TAB> return mImplementation ? mImplementation -> mClassName : EmptyCString ( ) ; <NEW_LINE> } <NEW_LINE> nsresult InitClass ( const nsCString & aClassName , JSContext * aContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aGlobal , JSObject * aScriptObject , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject ** aClassObject ) ; <NEW_LINE> <END_VULN> nsresult ConstructInterfaceTable ( const nsAString & aImpls ) ; <NEW_LINE> void SetImplementation ( nsXBLProtoImpl * aImpl ) { mImplementation = aImpl ; } <NEW_LINE> nsresult InstallImplementation ( nsXBLBinding * aBinding ) ; <NEW_LINE> bool HasImplementation ( ) const { return mImplementation != nullptr ; } <NEW_LINE> void AttributeChanged ( nsIAtom * aAttribute , int32_t aNameSpaceID ,
<TAB> <TAB> return - ENETUNREACH ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ! inet -> opt || ! inet -> opt -> srr ) <NEW_LINE> <END_VULN> <TAB> <TAB> daddr = rt -> rt_dst ; <NEW_LINE> <TAB> if ( ! inet -> inet_saddr )
<TAB> if ( rc != X86EMUL_CONTINUE ) <NEW_LINE> <TAB> <TAB> return rc ; <NEW_LINE> <START_VULN> <TAB> rc = segmented_read ( ctxt , ctxt -> memop . addr . mem , & fx_state , 512 ) ; <NEW_LINE> <END_VULN> <TAB> if ( rc != X86EMUL_CONTINUE ) <NEW_LINE> <TAB> <TAB> return rc ;
<TAB> <TAB> <TAB> <TAB> <TAB> size_t count ) <NEW_LINE> { <NEW_LINE> <TAB> struct o2nm_node * node = to_o2nm_node ( item ) ; <NEW_LINE> <START_VULN> <TAB> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <NEW_LINE> <END_VULN> <TAB> int ret , i ; <NEW_LINE> <TAB> struct rb_node ** p , * parent ; <NEW_LINE> <TAB> unsigned int octets [ 4 ] ;
<TAB> c = ReadBlobByte ( pwp_image ) ; <NEW_LINE> <TAB> if ( c == EOF ) <NEW_LINE> <TAB> <TAB> break ; <NEW_LINE> <START_VULN> <TAB> ( void ) fputc ( c , file ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> ( void ) fclose ( file ) ; <NEW_LINE> <TAB> if ( c == EOF )
<TAB> <TAB> <TAB> err = ip6_ufo_append_data ( sk , getfrag , from , length , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> hh_len , fragheaderlen , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> transhdrlen , mtu , flags ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( err ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto error ; <NEW_LINE> <TAB> <TAB> <TAB> return 0 ;
<TAB> UNIXCB ( skb ) . fp = NULL ; <NEW_LINE> <TAB> for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <NEW_LINE> <START_VULN> <TAB> <TAB> unix_notinflight ( scm -> fp -> fp [ i ] ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void unix_destruct_scm ( struct sk_buff * skb )
struct inode ; <TAB> <TAB> <NEW_LINE> <START_VULN> extern int parse_rock_ridge_inode ( struct iso_directory_record * , struct inode * ) ; <NEW_LINE> <END_VULN> extern int get_rock_ridge_filename ( struct iso_directory_record * , char * , struct inode * ) ; <NEW_LINE> extern int isofs_name_translate ( struct iso_directory_record * , char * , struct inode * ) ;
<TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> if ( context && php_stream_context_get_option ( context , "http" , "protocol_version" , & tmpzval ) == SUCCESS ) { <NEW_LINE> <TAB> <TAB> SEPARATE_ZVAL ( tmpzval ) ; <NEW_LINE> <TAB> <TAB> convert_to_double_ex ( tmpzval ) ;
<TAB> SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO ( 'T' , 0x23 ) , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static long snd_timer_user_ioctl ( struct file * file , unsigned int cmd , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> unsigned long arg ) <NEW_LINE> { <NEW_LINE> <TAB> struct snd_timer_user * tu ;
<TAB> <TAB> for ( int i = 0 ; i < tk -> i_subpacket_h / 2 ; i + + ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> block_t * p_block = block_New ( p_demux , tk -> i_coded_frame_size ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ! p_block ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return ; <NEW_LINE> <TAB> <TAB> <TAB> if ( & p_buf [ tk -> i_coded_frame_size ] > & p_sys -> buffer [ p_sys -> i_buffer ] ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return ; <NEW_LINE> <START_VULN> <NEW_LINE><TAB> <TAB> <TAB> int i_index = ( i * 2 * tk -> i_frame_size / tk -> i_coded_frame_size ) + y ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> memcpy ( p_block -> p_buffer , p_buf , tk -> i_coded_frame_size ) ; <NEW_LINE> <TAB> <TAB> <TAB> p_block -> i_dts =
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA - 224 and SHA - 256 Secure Hash Algorithm" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha224" ) ; <NEW_LINE>MODULE_ALIAS ( "sha256" ) ; <NEW_LINE> <END_VULN>
<TAB> * <NEW_LINE> SVGTransformList & InternalList ( ) const ; <NEW_LINE> <START_VULN> void EnsureItemAt ( uint32_t aIndex ) ; <NEW_LINE> <END_VULN> void MaybeInsertNullInAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> void MaybeRemoveItemFromAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> FallibleTArray < dom : : SVGTransform * > mItems ;
<TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> phar_flush ( phar_obj -> arc . archive , ( char * ) & zstub , len , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> RETURN_TRUE ;
} <NEW_LINE> <START_VULN> const PRUint8 * <NEW_LINE> <END_VULN> PrepareOpenTypeData ( const PRUint8 * aData , PRUint32 * aLength ) <NEW_LINE> { <NEW_LINE> <TAB> switch ( gfxFontUtils : : DetermineFontDataType ( aData , * aLength ) ) { <NEW_LINE> <TAB> case GFX_USERFONT_OPENTYPE : <NEW_LINE> <TAB> <TAB> return aData ;
<TAB> <TAB> <TAB> <TAB> <TAB> newExtIndex = newIndex ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( newIndex < 256 ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> newName [ newIndex + + ] = curr ; <NEW_LINE> <TAB> <TAB> <TAB> else <NEW_LINE> <TAB> <TAB> <TAB> <TAB> needsCRC = 1 ;
<TAB> uint8_t * from = rowp + mGIFStruct . width ; <NEW_LINE> <TAB> uint32_t * to = ( ( uint32_t * ) rowp ) + mGIFStruct . width ; <NEW_LINE> <TAB> uint32_t * cmap = mColormap ; <NEW_LINE> <START_VULN> <TAB> if ( mColorMask == 0xFF ) { <NEW_LINE><TAB> for ( uint32_t c = mGIFStruct . width ; c > 0 ; c -- ) { <NEW_LINE><TAB> <TAB> * -- to = cmap [ * -- from ] ; <NEW_LINE><TAB> } <NEW_LINE><TAB> } else { <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> uint8_t mask = mColorMask ; <NEW_LINE><TAB> for ( uint32_t c = mGIFStruct . width ; c > 0 ; c -- ) { <NEW_LINE><TAB> <TAB> * -- to = cmap [ ( * -- from ) & mask ] ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> }
<START_VULN> <NEW_LINE> <END_VULN> #ifndef COMPILER_DEBUG_H_ <NEW_LINE> #define COMPILER_DEBUG_H_ <NEW_LINE> #include < assert . h > <NEW_LINE> #ifdef _DEBUG <NEW_LINE> #define TRACE_ENABLED
<TAB> linenr_T <TAB> line_lnum ; <NEW_LINE> <TAB> colnr_T <TAB> line_colnr ; <NEW_LINE> <TAB> linenr_T <TAB> line_count ; <NEW_LINE> <START_VULN> <TAB> int <TAB> <TAB> num_head = 0 ; <NEW_LINE> <END_VULN> <TAB> long <TAB> old_header_seq , new_header_seq , cur_header_seq ; <NEW_LINE> <TAB> long <TAB> seq_last , seq_cur ; <NEW_LINE> <TAB> long <TAB> last_save_nr = 0 ;
<TAB> <TAB> { <NEW_LINE> <TAB> <TAB> jas_eprintf ( "warning : palettized images not fully supported\n" ) ; <NEW_LINE> <TAB> <TAB> numcolors = 1 << hdr -> depth ; <NEW_LINE> <START_VULN> <TAB> <TAB> assert ( numcolors <= RAS_CMAP_MAXSIZ ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> actualnumcolors = hdr -> maplength / 3 ; <NEW_LINE> <TAB> <TAB> for ( i = 0 ; i < numcolors ; i + + ) { <NEW_LINE> <TAB> <TAB> <TAB> cmap -> data [ i ] = 0 ;
#include < limits . h > <NEW_LINE> <START_VULN> #include < vector > <NEW_LINE><NEW_LINE>#include "sfntly / port / type . h" <NEW_LINE> <END_VULN> #include "sfntly / data / byte_array . h" <NEW_LINE> #include "sfntly / port / refcount . h" <NEW_LINE> namespace sfntly {
<TAB> if ( certutil . commands [ cmd_ListCerts ] . activated ) { <NEW_LINE> <TAB> rv = ListCerts ( certHandle , name , slot , <NEW_LINE> <TAB> certutil . options [ opt_BinaryDER ] . activated , <NEW_LINE> <TAB> certutil . options [ opt_ASCIIForIO ] . activated , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ( outFile ) ? outFile : PR_STDOUT , & pwdata ) ; <NEW_LINE> <TAB> goto shutdown ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( certutil . commands [ cmd_DumpChain ] . activated ) { <NEW_LINE> <START_VULN> <TAB> rv = DumpChain ( certHandle , name ) ; <NEW_LINE> <END_VULN> <TAB> goto shutdown ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( certutil . commands [ cmd_ListKeys ] . activated ) { <NEW_LINE> <TAB> rv = ListKeys ( slot , name , 0 , keytype , PR_FALSE , <NEW_LINE> <TAB> & pwdata ) ; <NEW_LINE> <TAB> goto shutdown ;
static nsresult <NEW_LINE> GetStructuredCloneReadInfoFromStatement ( mozIStorageStatement * aStatement , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t aDataIndex , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t aFileIdsIndex , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> IDBDatabase * aDatabase , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> StructuredCloneReadInfo & aInfo ) ; <NEW_LINE> static void <NEW_LINE> <START_VULN> ClearStructuredCloneBuffer ( JSAutoStructuredCloneBuffer & aBuffer ) ; <NEW_LINE> <END_VULN> static bool <NEW_LINE> DeserializeValue ( JSContext * aCx , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> StructuredCloneReadInfo & aCloneReadInfo , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> jsval * aValue ) ; <NEW_LINE> static bool <NEW_LINE> SerializeValue ( JSContext * aCx ,
<TAB> int fd = - 1 ; <NEW_LINE> <TAB> struct xar_header hdr ; <NEW_LINE> <TAB> fmap_t * map = * ctx -> fmap ; <NEW_LINE> <START_VULN> <TAB> long length , offset , size , at ; <NEW_LINE> <END_VULN> <TAB> int encoding ; <NEW_LINE> <TAB> z_stream strm ; <NEW_LINE> <TAB> char * toc , * tmpname ;
<START_VULN> <NEW_LINE> <END_VULN> % lld" , st -> st_size ) ;
<TAB> ret = install_process_keyring_to_cred ( new ) ; <NEW_LINE> <TAB> if ( ret < 0 ) { <NEW_LINE> <TAB> <TAB> abort_creds ( new ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> return ret != - EEXIST ? ret : 0 ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return commit_creds ( new ) ; <NEW_LINE> } <NEW_LINE> int install_session_keyring_to_cred ( struct cred * cred , struct key * keyring ) <NEW_LINE> {
cdf_unpack_summary_info ( const cdf_stream_t * sst , const cdf_header_t * h , <NEW_LINE> <TAB> cdf_summary_info_header_t * ssi , cdf_property_info_t ** info , size_t * count ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> size_t i , maxcount ; <NEW_LINE> <END_VULN> <TAB> const cdf_summary_info_header_t * si = <NEW_LINE> <TAB> CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ; <NEW_LINE> <TAB> const cdf_section_declaration_t * sd =
<START_VULN> static int CVE_2011_1833_ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> char * p ; <NEW_LINE> <TAB> int rc = 0 ;
<TAB> <TAB> else <NEW_LINE> <TAB> <TAB> <TAB> print_str_opt ( "color_space" , av_color_space_name ( frame -> colorspace ) ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( frame -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <NEW_LINE><TAB> <TAB> <TAB> print_str ( "color_primaries" , av_color_primaries_name ( frame -> color_primaries ) ) ; <NEW_LINE><TAB> <TAB> else <NEW_LINE><TAB> <TAB> <TAB> print_str_opt ( "color_primaries" , av_color_primaries_name ( frame -> color_primaries ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( frame -> color_trc != AVCOL_TRC_UNSPECIFIED ) <NEW_LINE> <TAB> <TAB> <TAB> print_str ( "color_transfer" , av_color_transfer_name ( frame -> color_trc ) ) ;
<START_VULN> struct XPCNativeScriptableSharedJSClass <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> js : : Class base ; <NEW_LINE> <TAB> PRUint32 interfacesBitmap ; <NEW_LINE> } ; <NEW_LINE> class XPCNativeScriptableShared <NEW_LINE> { <NEW_LINE> public :
<TAB> usb_fill_control_urb ( urb , priv -> udev , usb_sndctrlpipe ( priv -> udev , 0 ) , <NEW_LINE> <TAB> <TAB> <TAB> ( unsigned char * ) dr , buf , len , <NEW_LINE> <TAB> <TAB> <TAB> rtl8187_iowrite_async_cb , buf ) ; <NEW_LINE> <START_VULN> <TAB> usb_submit_urb ( urb , GFP_ATOMIC ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline void rtl818x_iowrite32_async ( struct rtl8187_priv * priv ,
<START_VULN> <TAB> <TAB> <TAB> length = ( MagickSizeType ) ReadBlobByte ( image ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> combined_length += length + 1 ; <NEW_LINE> <TAB> <TAB> <TAB> if ( length > 0 ) <NEW_LINE> <TAB> <TAB> <TAB> ( void ) ReadBlob ( image , ( size_t ) length + + , layer_info [ i ] . name ) ;
<TAB> <TAB> } * hdr , _hdr ; <NEW_LINE> <TAB> <TAB> hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; <NEW_LINE> <TAB> <TAB> if ( ! hdr ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <END_VULN> <TAB> <TAB> proto = hdr -> proto ; <NEW_LINE> <TAB> <TAB> nhoff += PPPOE_SES_HLEN ; <NEW_LINE> <TAB> <TAB> switch ( proto ) {
rename_principal_2_svc ( rprinc_arg * arg , struct svc_req * rqstp ) <NEW_LINE> { <NEW_LINE> <TAB> static generic_ret ret ; <NEW_LINE> <START_VULN> <TAB> char * prime_arg1 , <NEW_LINE><TAB> <TAB> * prime_arg2 ; <NEW_LINE><TAB> gss_buffer_desc client_name , <NEW_LINE><TAB> <TAB> service_name ; <NEW_LINE> <END_VULN> <TAB> OM_uint32 minor_stat ; <NEW_LINE> <TAB> kadm5_server_handle_t handle ; <NEW_LINE> <TAB> restriction_t * rp ;
<TAB> NS_ASSERTION ( startTicks == TimeToTicksRoundUp ( rate , outputStart ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> "Samples missing" ) ; <NEW_LINE> <TAB> TrackTicks endTicks = TimeToTicksRoundUp ( rate , outputEnd ) ; <NEW_LINE> <TAB> TrackTicks ticks = endTicks - startTicks ; <NEW_LINE> <TAB> StreamTime inputEnd = source -> GraphTimeToStreamTime ( interval . mEnd ) ; <NEW_LINE> <TAB> TrackTicks inputTrackEndPoint = TRACK_TICKS_MAX ; <NEW_LINE> <START_VULN> <TAB> if ( inputTrack -> IsEnded ( ) ) { <NEW_LINE><TAB> <TAB> TrackTicks inputEndTicks = inputTrack -> TimeToTicksRoundDown ( inputEnd ) ; <NEW_LINE><TAB> <TAB> if ( inputTrack -> GetEnd ( ) <= inputEndTicks ) { <NEW_LINE><TAB> <TAB> inputTrackEndPoint = inputTrack -> GetEnd ( ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> * aOutputTrackFinished = true ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( interval . mInputIsBlocked ) { <NEW_LINE> <TAB> <TAB> segment -> AppendNullData ( ticks ) ; <NEW_LINE> <TAB> <TAB> LOG ( PR_LOG_DEBUG , ( "TrackUnionStream % p appending % lld ticks of null data to track % d" ,
<TAB> <TAB> if ( request . magic != htonl ( NBD_REQUEST_MAGIC ) ) <NEW_LINE> <TAB> <TAB> <TAB> err ( "Not enough magic . " ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> err ( "Request too big ! " ) ; <NEW_LINE> #ifdef DODBG <NEW_LINE> <TAB> <TAB> printf ( " % s from % llu ( % llu ) len % d , " , request . type ? "WRITE" :
<TAB> <TAB> <TAB> <TAB> m_pos -= t >> 2 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> m_pos -= * ip + + << 2 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> TEST_LB ( m_pos ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> NEED_OP ( 2 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> op [ 0 ] = m_pos [ 0 ] ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> op [ 1 ] = m_pos [ 1 ] ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> op += 2 ;
<TAB> <TAB> & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { <NEW_LINE> <TAB> <TAB> num_items_scanned = sscanf ( line , <NEW_LINE> <START_VULN> <TAB> <TAB> " % 4d - % 2d - % 2d , % 2d : % 2d : % 2d . % 9d : % 5s ( % 127 [ A - Za - z0 - 9 / : ] ) , Length : % 9u , Pro : % 9d , Off : % 9d , Pri : % 9d , RM : % 9d , Err : % 9d [ % 8x , % 8x ] " , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> & yy , & mm , & dd , & hr , & min , & sec , & csec , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> direction , if_name , & pkt_len , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> & pro , & off , & pri , & rm , & error ,
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 104 2014 / 10 / 17 15 : 49 : 00 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef BUILTIN_ELF
init_side ( client , & client -> client_side ) ; <NEW_LINE> init_side ( client , & client -> bus_side ) ; <NEW_LINE> <START_VULN> client -> auth_end_offset = AUTH_END_INIT_OFFSET ; <NEW_LINE> <END_VULN> client -> rewrite_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_object_unref ) ; <NEW_LINE> client -> get_owner_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_free ) ; <NEW_LINE> client -> unique_id_policy = g_hash_table_new_full ( g_str_hash , g_str_equal , g_free , NULL ) ;
<TAB> <TAB> <TAB> <TAB> parent_inode , & key , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> BTRFS_FT_DIR , index ) ; <NEW_LINE> <START_VULN> <TAB> BUG_ON ( ret == - EEXIST ) ; <NEW_LINE> <END_VULN> <TAB> if ( ret ) { <NEW_LINE> <TAB> <TAB> btrfs_abort_transaction ( trans , root , ret ) ; <NEW_LINE> <TAB> <TAB> goto fail ;
<TAB> <TAB> return parse_uid_node ( object , size ) ; <NEW_LINE> <TAB> case BPLIST_DICT : <NEW_LINE> <START_VULN> <TAB> <TAB> if ( * object + size > bplist -> offset_table ) { <NEW_LINE><TAB> <TAB> <TAB> PLIST_BIN_ERR ( " % s : BPLIST_REAL data bytes point outside of valid range\n" , __func__ ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> return parse_dict_node ( bplist , object , size ) ; <NEW_LINE> commit 32ee5213fe64f1e10ec76c1ee861ee6f233120dd <NEW_LINE> Author : Nikias Bassen < nikias@gmx . li > <NEW_LINE> Date : Fri Feb 10 13 : 42 : 46 2017 + 0100 <NEW_LINE> <TAB> bplist : Fix data range check for string / data / dict / array nodes <NEW_LINE> <TAB> Passing a size of 0xFFFFFFFFFFFFFFFF to parse_string_node ( ) might result <NEW_LINE> <TAB> in a memcpy with a size of - 1 , leading to undefined behavior . <NEW_LINE> <TAB> This commit makes sure that the actual node data ( which depends on the size ) <NEW_LINE> <TAB> is in the range start_of_object . . start_of_object + size . <NEW_LINE> <TAB> Credit to OSS - Fuzz
#endif <NEW_LINE> virtual nsresult Close ( ) ; <NEW_LINE> virtual void Suspend ( bool aCloseImmediately ) ; <NEW_LINE> virtual void Resume ( ) ; <NEW_LINE> virtual already_AddRefed < nsIPrincipal > GetCurrentPrincipal ( ) ; <NEW_LINE> bool IsClosed ( ) const { return mCacheStream . IsClosed ( ) ; } <NEW_LINE> virtual bool CanClone ( ) ; <NEW_LINE> <START_VULN> virtual MediaResource * CloneData ( MediaDecoder * aDecoder ) ; <NEW_LINE> <END_VULN> void RecordStatisticsTo ( MediaChannelStatistics * aStatistics ) MOZ_OVERRIDE { <NEW_LINE> <TAB> NS_ASSERTION ( aStatistics , "Statistics param cannot be null ! " ) ; <NEW_LINE> <TAB> MutexAutoLock lock ( mLock ) ; <NEW_LINE> <TAB> if ( ! mChannelStatistics ) { <NEW_LINE> <TAB> mChannelStatistics = aStatistics ; <NEW_LINE> <TAB> }
<START_VULN> int mutt_b64_decode ( char * out , const char * in ) <NEW_LINE> <END_VULN> { <NEW_LINE> int len = 0 ; <NEW_LINE> unsigned char digit4 ;
<TAB> . compat_ioctl <TAB> = compat_blkdev_ioctl , <NEW_LINE> #endif <NEW_LINE> <TAB> . splice_read <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> } ; <NEW_LINE> int ioctl_by_bdev ( struct block_device * bdev , unsigned cmd , unsigned long arg )
<TAB> if ( rc != X86EMUL_CONTINUE ) <NEW_LINE> <TAB> <TAB> return rc ; <NEW_LINE> <TAB> rc = assign_eip_far ( ctxt , eip , & new_desc ) ; <NEW_LINE> <START_VULN> <TAB> if ( rc != X86EMUL_CONTINUE ) { <NEW_LINE><TAB> <TAB> WARN_ON ( ctxt -> mode != X86EMUL_MODE_PROT64 ) ; <NEW_LINE><TAB> <TAB> ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> return rc ; <NEW_LINE> }
static int CVE_2012_1183_milliwatt_generate ( struct ast_channel * chan , void * data , int len , int samples ) <NEW_LINE> { <NEW_LINE> <TAB> unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; <NEW_LINE> <START_VULN> <TAB> const int maxsamples = ARRAY_LEN ( buf ) ; <NEW_LINE> <END_VULN> <TAB> int i , * indexp = ( int * ) data ; <NEW_LINE> <TAB> struct ast_frame wf = { <NEW_LINE> <TAB> <TAB> . frametype = AST_FRAME_VOICE ,
{ <NEW_LINE> <TAB> void * pointer ; <NEW_LINE> <START_VULN> <TAB> if ( ! handle ) <NEW_LINE> <END_VULN> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> pointer = ( void * ) ~ ( ( size_t ) handle -> dwLower ) ;
<TAB> . compat_ioctl <TAB> = f2fs_compat_ioctl , <NEW_LINE> #endif <NEW_LINE> <TAB> . splice_read <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> } ;
<TAB> <TAB> val = min_t ( u32 , val , sysctl_wmem_max ) ; <NEW_LINE> set_sndbuf : <NEW_LINE> <TAB> <TAB> sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; <NEW_LINE> <START_VULN> <TAB> <TAB> sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> sk -> sk_write_space ( sk ) ; <NEW_LINE> <TAB> <TAB> break ;
{ <NEW_LINE> const char * header ; <NEW_LINE> uint head_length , counter = 0 ; <NEW_LINE> <START_VULN> char query [ 255 ] , rows [ NAME_LEN ] , fields [ 16 ] ; <NEW_LINE> <END_VULN> MYSQL_FIELD * field ; <NEW_LINE> MYSQL_RES * result ; <NEW_LINE> MYSQL_ROW row , rrow ;
<TAB> <TAB> if ( how & UMOUNT_SYNC ) <NEW_LINE> <TAB> <TAB> <TAB> p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; <NEW_LINE> <START_VULN> <TAB> <TAB> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> disconnect ? & unmounted : NULL ) ;
<TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> if ( swoole_seria_check_eof ( buffer , len ) < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> php_error_docref ( NULL TSRMLS_CC , E_NOTICE , "detect the error eof" ) ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> return SW_FALSE ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> unser_start = buffer - sizeof ( SBucketType ) ; <NEW_LINE> <TAB> <TAB> <TAB> uint32_t num = 0 ;
<TAB> if ( rectype == PKT_REC_PACKET ) { <NEW_LINE> <TAB> <TAB> next_tvb = tvb_new_subset_remaining ( tvb , pkt_len ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> dissector_try_uint ( wtap_encap_dissector_table , <NEW_LINE><TAB> <TAB> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> }
} <NEW_LINE> static struct nfs4_opendata * nfs4_opendata_alloc ( struct path * path , <NEW_LINE> <START_VULN> <TAB> <TAB> struct nfs4_state_owner * sp , int flags , <NEW_LINE> <END_VULN> <TAB> <TAB> const struct iattr * attrs ) <NEW_LINE> { <NEW_LINE> <TAB> struct dentry * parent = dget_parent ( path -> dentry ) ;
<TAB> int SSL_get_fd ( SSL * ) ; <NEW_LINE> void _SSL_close ( SSL * ssl ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> int _SSL_get_cert_info ( struct cert_info * cert_info , SSL * ssl ) ; <NEW_LINE> struct chiper_info * _SSL_get_cipher_info ( SSL * ssl ) ;
<TAB> NS_DECL_ISUPPORTS_INHERITED <NEW_LINE> <TAB> NS_DECL_NSIINPUTSTREAMCHANNEL <NEW_LINE> <TAB> nsInputStreamChannel ( ) { } <NEW_LINE> protected : <NEW_LINE> <TAB> virtual ~ nsInputStreamChannel ( ) { } <NEW_LINE> <START_VULN> <TAB> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result ) ; <NEW_LINE> <END_VULN> private : <NEW_LINE> <TAB> nsCOMPtr < nsIInputStream > mContentStream ; <NEW_LINE> } ; <NEW_LINE> #endif
<TAB> } <NEW_LINE> <TAB> ctx . cleanup_addr = proglen ; <NEW_LINE> <START_VULN> <TAB> for ( pass = 0 ; pass < 10 ; pass + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ; <NEW_LINE> <TAB> <TAB> if ( proglen <= 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> image = NULL ;
<TAB> <TAB> path . dentry = res ; <NEW_LINE> <TAB> nfs_set_verifier ( path . dentry , nfs_save_change_attribute ( dir ) ) ; <NEW_LINE> <TAB> nfs_unblock_sillyrename ( parent ) ; <NEW_LINE> <START_VULN> <TAB> nfs4_intent_set_file ( nd , & path , state ) ; <NEW_LINE> <END_VULN> <TAB> return res ; <NEW_LINE> }
<TAB> } <NEW_LINE> <START_VULN> <TAB> if ( pread ( fd , xsh_addr , xsh_sizeof , off + size * strtab ) == - 1 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> file_badread ( ms ) ; <NEW_LINE> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> }
PHPAPI char * xml_utf8_decode ( const XML_Char * s , int len , int * newlen , const XML_Char * encoding ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> int pos = len ; <NEW_LINE> <END_VULN> <TAB> char * newbuf = emalloc ( len + 1 ) ; <NEW_LINE> <TAB> unsigned int c ; <NEW_LINE> <TAB> char ( * decoder ) ( unsigned short ) = NULL ;
oggpack_write ( opb , 1 , 1 ) ; <NEW_LINE> return ( 0 ) ; <NEW_LINE> err_out : <NEW_LINE> return ( - 1 ) ; <NEW_LINE> } <NEW_LINE> int vorbis_commentheader_out ( vorbis_comment * vc , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> ogg_packet * op ) { <NEW_LINE> <END_VULN> oggpack_buffer opb ; <NEW_LINE> oggpack_writeinit ( & opb ) ; <NEW_LINE> if ( _vorbis_pack_comment ( & opb , vc ) ) return OV_EIMPL ; <NEW_LINE> op -> packet = _ogg_malloc ( oggpack_bytes ( & opb ) ) ; <NEW_LINE> memcpy ( op -> packet , opb . buffer , oggpack_bytes ( & opb ) ) ;
<TAB> . coa_decompress <TAB> <TAB> = <TAB> null_compress } } <NEW_LINE> } } ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "compress_null" ) ; <NEW_LINE>MODULE_ALIAS ( "digest_null" ) ; <NEW_LINE>MODULE_ALIAS ( "cipher_null" ) ; <NEW_LINE> <END_VULN> static int __init crypto_null_mod_init ( void ) <NEW_LINE> {
<TAB> <TAB> <TAB> <TAB> unsigned int * size ) ; <NEW_LINE> int xt_compat_target_to_user ( const struct xt_entry_target * t , <NEW_LINE> <TAB> <TAB> <TAB> void __user ** dstptr , unsigned int * size ) ; <NEW_LINE> <START_VULN> int xt_compat_check_entry_offsets ( const void * base , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> unsigned int target_offset , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> unsigned int next_offset ) ;
<TAB> if ( blocks == ( unsigned char * ) NULL ) <NEW_LINE> <TAB> <TAB> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <TAB> count = ReadBlob ( image , ( size_t ) length , blocks ) ; <NEW_LINE> <START_VULN> <TAB> if ( ( count != ( ssize_t ) length ) || <NEW_LINE> <END_VULN> <TAB> <TAB> ( LocaleNCompare ( ( char * ) blocks , "8BIM" , 4 ) != 0 ) ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> blocks = ( unsigned char * ) RelinquishMagickMemory ( blocks ) ;
<TAB> key = key_ref_to_ptr ( key_ref ) ; <NEW_LINE> <START_VULN> <TAB> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <NEW_LINE><TAB> <TAB> ret = - ENOKEY ; <NEW_LINE><TAB> <TAB> goto error2 ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> ret = key_permission ( key_ref , KEY_NEED_READ ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : fft transform <NEW_LINE> <START_VULN> last mod : $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_SMFT_H_ <NEW_LINE> #define _V_SMFT_H_ <NEW_LINE> #include "vorbis / codec . h"
<TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( cookies ) { <NEW_LINE><TAB> <TAB> ast_variables_destroy ( cookies ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> return mngid ; <NEW_LINE> }
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #ifndef __SSL_ERR_H_ <NEW_LINE> #define __SSL_ERR_H_ <NEW_LINE> #define SSL_ERROR_BASE <TAB> <TAB> <TAB> <TAB> ( - 0x3000 ) <NEW_LINE> #define SSL_ERROR_LIMIT <TAB> <TAB> <TAB> <TAB> ( SSL_ERROR_BASE + 1000 ) <NEW_LINE> #define IS_SSL_ERROR ( code ) \
int mi_repair ( MI_CHECK * param , register MI_INFO * info , <NEW_LINE> <START_VULN> <TAB> char * name , int rep_quick ) <NEW_LINE> <END_VULN> { <NEW_LINE> int error , got_error ; <NEW_LINE> ha_rows start_records , new_header_length ;
<TAB> mutt_debug ( 2 , "Handling untagged NO\n" ) ; <NEW_LINE> <START_VULN> <TAB> mutt_error ( " % s" , s + 3 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return 0 ;
<TAB> struct ext4_xattr_entry * entry ; <NEW_LINE> <TAB> size_t size ; <NEW_LINE> <TAB> int error ; <NEW_LINE> <START_VULN> <TAB> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <NEW_LINE> <END_VULN> <TAB> ea_idebug ( inode , "name = % d . % s , buffer = % p , buffer_size = % ld" , <NEW_LINE> <TAB> <TAB> name_index , name , buffer , ( long ) buffer_size ) ;
class nsHttpHeaderArray <NEW_LINE> { <NEW_LINE> public : <NEW_LINE> <TAB> nsHttpHeaderArray ( ) { } <NEW_LINE> <TAB> ~ nsHttpHeaderArray ( ) { Clear ( ) ; } <NEW_LINE> <TAB> const char * PeekHeader ( nsHttpAtom header ) ; <NEW_LINE> <START_VULN> <TAB> nsresult SetHeader ( nsHttpAtom header , const nsACString & value , PRBool merge = PR_FALSE ) ; <NEW_LINE> <END_VULN> <TAB> nsresult GetHeader ( nsHttpAtom header , nsACString & value ) ; <NEW_LINE> <TAB> void ClearHeader ( nsHttpAtom h ) ; <NEW_LINE> <TAB> const char * FindHeaderValue ( nsHttpAtom header , const char * value ) { <NEW_LINE> <TAB> <TAB> return nsHttp : : FindToken ( PeekHeader ( header ) , value , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> HTTP_HEADER_VALUE_SEPS ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> dopt -> optlen += optlen ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( sopt -> srr ) { <NEW_LINE> <START_VULN> <TAB> <TAB> unsigned char * start = sptr + sopt -> srr ; <NEW_LINE> <END_VULN> <TAB> <TAB> __be32 faddr ; <NEW_LINE> <TAB> <TAB> optlen = start [ 1 ] ;
} ; <NEW_LINE> class nsDocShell final <NEW_LINE> : public nsDocLoader <NEW_LINE> <START_VULN> , public nsIDocShell_ESR38 <NEW_LINE> <END_VULN> , public nsIWebNavigation <NEW_LINE> , public nsIBaseWindow <NEW_LINE> , public nsIScrollable <NEW_LINE> , public nsITextScroll <NEW_LINE> , public nsIDocCharset <NEW_LINE> , public nsIContentViewerContainer <NEW_LINE> , public nsIRefreshURI <NEW_LINE> , public nsIWebProgressListener
<TAB> struct ipv6_ac_socklist <TAB> * ipv6_ac_list ; <NEW_LINE> <TAB> struct ipv6_fl_socklist __rcu * ipv6_fl_list ; <NEW_LINE> <START_VULN> <TAB> struct ipv6_txoptions <TAB> * opt ; <NEW_LINE> <END_VULN> <TAB> struct sk_buff <TAB> <TAB> * pktoptions ; <NEW_LINE> <TAB> struct sk_buff <TAB> <TAB> * rxpmtu ; <NEW_LINE> <TAB> struct inet6_cork <TAB> cork ;
private int <NEW_LINE> cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , <NEW_LINE> <START_VULN> <TAB> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> <TAB> cdf_summary_info_header_t si ; <NEW_LINE> <TAB> <TAB> cdf_property_info_t * info ;
<TAB> <TAB> return ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <NEW_LINE><TAB> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <NEW_LINE><TAB> return ; <NEW_LINE> <END_VULN> }
} <NEW_LINE> loff_t <NEW_LINE> <START_VULN> ftrace_regex_lseek ( struct file * file , loff_t offset , int whence ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> loff_t ret ;
0 . 9999979185F , 0 . 9999982507F , 0 . 9999985414F , 0 . 9999987944F , <NEW_LINE> 0 . 9999990129F , 0 . 9999992003F , 0 . 9999993596F , 0 . 9999994939F , <NEW_LINE> 0 . 9999996059F , 0 . 9999996981F , 0 . 9999997732F , 0 . 9999998333F , <NEW_LINE> 0 . 9999998805F , 0 . 9999999170F , 0 . 9999999444F , 0 . 9999999643F , <NEW_LINE> 0 . 9999999784F , 0 . 9999999878F , 0 . 9999999937F , 0 . 9999999972F , <NEW_LINE> 0 . 9999999990F , 0 . 9999999997F , 1 . 0000000000F , 1 . 0000000000F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin4096 [ 2048 ] = { <NEW_LINE> <END_VULN> 0 . 0000002310F , 0 . 0000020791F , 0 . 0000057754F , 0 . 0000113197F , <NEW_LINE> 0 . 0000187121F , 0 . 0000279526F , 0 . 0000390412F , 0 . 0000519777F , <NEW_LINE> 0 . 0000667623F , 0 . 0000833949F , 0 . 0001018753F , 0 . 0001222036F , <NEW_LINE> 0 . 0001443798F , 0 . 0001684037F , 0 . 0001942754F , 0 . 0002219947F , <NEW_LINE> 0 . 0002515616F , 0 . 0002829761F , 0 . 0003162380F , 0 . 0003513472F , <NEW_LINE> 0 . 0003883038F , 0 . 0004271076F , 0 . 0004677584F , 0 . 0005102563F , <NEW_LINE> 0 . 0005546011F , 0 . 0006007928F , 0 . 0006488311F , 0 . 0006987160F , <NEW_LINE> 0 . 0007504474F , 0 . 0008040251F , 0 . 0008594490F , 0 . 0009167191F ,
<TAB> icmp_param . offset = skb_network_offset ( skb_in ) ; <NEW_LINE> <TAB> inet_sk ( sk ) -> tos = tos ; <NEW_LINE> <TAB> ipc . addr = iph -> saddr ; <NEW_LINE> <START_VULN> <TAB> ipc . opt = & icmp_param . replyopts ; <NEW_LINE> <END_VULN> <TAB> ipc . tx_flags = 0 ; <NEW_LINE> <TAB> rt = icmp_route_lookup ( net , skb_in , iph , saddr , tos ,
<TAB> <TAB> r = - EFAULT ; <NEW_LINE> <TAB> <TAB> if ( copy_from_user ( & va , argp , sizeof va ) ) <NEW_LINE> <TAB> <TAB> <TAB> goto out ; <NEW_LINE> <START_VULN> <TAB> <TAB> r = 0 ; <NEW_LINE><TAB> <TAB> kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> case KVM_X86_SETUP_MCE : {
<TAB> <TAB> get_page ( netbk -> mmap_pages [ pending_idx ] ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> xen_netbk_idx_release ( netbk , pending_idx ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> }
typedef struct { <NEW_LINE> void ( * pack ) ( vorbis_info_floor * , oggpack_buffer * ) ; <NEW_LINE> vorbis_info_floor * ( * unpack ) ( vorbis_info * , oggpack_buffer * ) ; <NEW_LINE> vorbis_look_floor * ( * look ) ( vorbis_dsp_state * , vorbis_info_floor * ) ; <NEW_LINE> void ( * free_info ) ( vorbis_info_floor * ) ; <NEW_LINE> void ( * free_look ) ( vorbis_look_floor * ) ; <NEW_LINE> void * ( * inverse1 ) ( struct vorbis_block * , vorbis_look_floor * ) ; <NEW_LINE> int ( * inverse2 ) ( struct vorbis_block * , vorbis_look_floor * , <NEW_LINE> <START_VULN> <TAB> <TAB> void * buffer , float * ) ; <NEW_LINE> <END_VULN> } vorbis_func_floor ; <NEW_LINE> typedef struct { <NEW_LINE> int order ; <NEW_LINE> long rate ; <NEW_LINE> long barkmap ; <NEW_LINE> int ampbits ;
void mdct_clear ( mdct_lookup * l ) { <NEW_LINE> if ( l ) { <NEW_LINE> <TAB> if ( l -> trig ) _ogg_free ( l -> trig ) ; <NEW_LINE> <TAB> if ( l -> bitrev ) _ogg_free ( l -> bitrev ) ; <NEW_LINE> <TAB> memset ( l , 0 , sizeof ( * l ) ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> STIN void mdct_bitreverse ( mdct_lookup * init , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> DATA_TYPE * x ) { <NEW_LINE> int n = init -> n ; <NEW_LINE> int * bit = init -> bitrev ; <NEW_LINE> DATA_TYPE * w0 = x ; <NEW_LINE> DATA_TYPE * w1 = x = w0 + ( n >> 1 ) ; <NEW_LINE> DATA_TYPE * T = init -> trig + n ; <NEW_LINE> do {
generic_ret * init_2_svc ( krb5_ui_4 * arg , struct svc_req * rqstp ) <NEW_LINE> { <NEW_LINE> <TAB> static generic_ret ret ; <NEW_LINE> <START_VULN> <TAB> gss_buffer_desc client_name , <NEW_LINE><TAB> <TAB> service_name ; <NEW_LINE> <END_VULN> <TAB> kadm5_server_handle_t handle ; <NEW_LINE> <TAB> OM_uint32 minor_stat ; <NEW_LINE> <TAB> const char * errmsg = NULL ;
nsresult SharedOutputString ( uint32_t aFlags , bool * aIsCollapsed , nsAString & aResult ) ; <NEW_LINE> bool IsModifiable ( ) ; <NEW_LINE> bool CanCutOrCopy ( ) ; <NEW_LINE> <START_VULN> bool FireClipboardEvent ( int32_t aType ) ; <NEW_LINE> <END_VULN> bool UpdateMetaCharset ( nsIDOMDocument * aDocument , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsACString & aCharacterSet ) ; <NEW_LINE> protected : <NEW_LINE> nsCOMPtr < nsIEditRules > mRules ;
<TAB> <TAB> <TAB> while ( an -- && cp && cp < end ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> zval * retval ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> cp = php_parserr ( cp , & answer , type_to_fetch , store_results , raw , & retval ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> if ( retval != NULL && store_results ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> add_next_index_zval ( return_value , retval ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
<TAB> <TAB> <TAB> c = ReadBlobByte ( image ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( c == EOF ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> ( void ) fputc ( c , file ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> ( void ) fclose ( file ) ;
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "ssl . h" <NEW_LINE> #include "sslimpl . h" <NEW_LINE> #include "sslproto . h" <NEW_LINE> static const char * <NEW_LINE> ssl_GetCompressionMethodName ( SSLCompressionMethod compression ) <NEW_LINE> { <NEW_LINE> <TAB> switch ( compression ) {
<TAB> <TAB> <TAB> <TAB> <TAB> m_pos += 8 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } while ( op < oe ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> op = oe ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> if ( HAVE_IP ( 6 ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> state = next ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> COPY4 ( op , ip ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> op += next ;
nsresult FindInsertionPoint ( <NEW_LINE> <TAB> nsTArray < RangeData > * aElementArray , <NEW_LINE> <TAB> nsINode * aPointNode , PRInt32 aPointOffset , <NEW_LINE> <TAB> nsresult ( * aComparator ) ( nsINode * , PRInt32 , nsRange * , PRInt32 * ) , <NEW_LINE> <TAB> PRInt32 * aPoint ) ; <NEW_LINE> bool EqualsRangeAtPoint ( nsINode * aBeginNode , PRInt32 aBeginOffset , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsINode * aEndNode , PRInt32 aEndOffset , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRInt32 aRangeIndex ) ; <NEW_LINE> <START_VULN> void GetIndicesForInterval ( nsINode * aBeginNode , PRInt32 aBeginOffset , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsINode * aEndNode , PRInt32 aEndOffset , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool aAllowAdjacent , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRInt32 * aStartIndex , PRInt32 * aEndIndex ) ; <NEW_LINE> <END_VULN> RangeData * FindRangeData ( nsIDOMRange * aRange ) ;
<TAB> inst = bytestream_get_byte ( & buf ) ; <NEW_LINE> <TAB> inst &= CDG_MASK ; <NEW_LINE> <TAB> buf += 2 ; <NEW_LINE> <START_VULN> <TAB> bytestream_get_buffer ( & buf , cdg_data , buf_size - CDG_HEADER_SIZE ) ; <NEW_LINE> <END_VULN> <TAB> if ( ( command & CDG_MASK ) == CDG_COMMAND ) { <NEW_LINE> <TAB> <TAB> switch ( inst ) {
<TAB> mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD|MNT_MARKED ) ; <NEW_LINE> <START_VULN> <TAB> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) <NEW_LINE><TAB> <TAB> mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; <NEW_LINE> <END_VULN> <TAB> if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) )
<TAB> if ( is_guest_mode ( vcpu ) ) <NEW_LINE> <TAB> <TAB> msr_bitmap = vmx_msr_bitmap_nested ; <NEW_LINE> <START_VULN> <TAB> else if ( vcpu -> arch . apic_base & X2APIC_ENABLE ) { <NEW_LINE> <END_VULN> <TAB> <TAB> if ( is_long_mode ( vcpu ) ) <NEW_LINE> <TAB> <TAB> <TAB> msr_bitmap = vmx_msr_bitmap_longmode_x2apic ; <NEW_LINE> <TAB> <TAB> else
<TAB> if ( p -> udptl ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( udptlportno > 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_SYMMETRICRTP ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_UDPTL_DESTINATION ) ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ast_rtp_instance_get_remote_address ( p -> rtp , isa ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( ! ast_sockaddr_isnull ( isa ) && debug ) {
<TAB> if ( chr ( s , ' < ' ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> while ( peek ( s ) != ' > ' && ! eol ( s ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> buf_append ( s , next ( s ) ) ; <NEW_LINE> <TAB> <TAB> if ( ! chr ( s , ' > ' ) ) { <NEW_LINE> <TAB> <TAB> <TAB> scanner_err ( s , "unterminated keysym literal" ) ;
<TAB> <TAB> <TAB> gss_qop_t * qop_state , gss_iov_buffer_desc * iov , <NEW_LINE> <TAB> <TAB> <TAB> int iov_count ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return gss_verify_mic_iov ( minor_status , context_handle , qop_state , iov , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> iov_count ) ; <NEW_LINE> }
nsresult ServeStreamAsFile ( nsIRequest * request , nsISupports * ctxt ) ; <NEW_LINE> nsNPAPIPluginInstance * GetPluginInstance ( ) { return mPluginInstance ; } <NEW_LINE> private : <NEW_LINE> nsresult SetUpStreamListener ( nsIRequest * request , nsIURI * aURL ) ; <NEW_LINE> nsresult SetupPluginCacheFile ( nsIChannel * channel ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> nsCOMPtr < nsIURI > mURL ; <NEW_LINE> nsCString mURLSpec ; <NEW_LINE> nsCOMPtr < nsIPluginInstanceOwner > mOwner ; <NEW_LINE> nsCOMPtr < nsIPluginStreamListener > mPStreamListener ; <NEW_LINE> PRPackedBool mRequestFailed ;
<TAB> . fsync = ubifs_fsync , <NEW_LINE> <TAB> . unlocked_ioctl = ubifs_ioctl , <NEW_LINE> <TAB> . splice_read <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> #ifdef CONFIG_COMPAT <NEW_LINE> <TAB> . compat_ioctl = ubifs_compat_ioctl , <NEW_LINE> #endif
# define SSL_ST_BEFORE 0x4000 <NEW_LINE> # define SSL_ST_OK 0x03 <NEW_LINE> # define SSL_ST_RENEGOTIATE ( 0x04|SSL_ST_INIT ) <NEW_LINE> <START_VULN> # define SSL_ST_ERR 0x05 <NEW_LINE> <END_VULN> # define SSL_CB_LOOP 0x01 <NEW_LINE> # define SSL_CB_EXIT 0x02
<TAB> const struct xt_entry_target * t ; <NEW_LINE> <TAB> unsigned int verdict ; <NEW_LINE> <START_VULN> <TAB> if ( ! unconditional ( & e -> arp ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return false ; <NEW_LINE> <TAB> t = arpt_get_target_c ( e ) ; <NEW_LINE> <TAB> if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 )
<TAB> <TAB> fprintf ( stderr , "Unable to select public key file : % s\n" , sc_strerror ( r ) ) ; <NEW_LINE> <TAB> <TAB> return 2 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> bufsize = file -> size ; <NEW_LINE> <END_VULN> <TAB> sc_file_free ( file ) ; <NEW_LINE> <TAB> r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; <NEW_LINE> <TAB> if ( r < 0 ) {
<TAB> if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> intf -> desc . bInterfaceProtocol == USB_PR_UAS ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int uas_find_uas_alt_setting ( struct usb_interface * intf ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> int i ;
<TAB> ether_setup ( dev ) ; <NEW_LINE> <TAB> dev -> priv_flags <TAB> <TAB> |= IFF_802_1Q_VLAN ; <NEW_LINE> <START_VULN> <TAB> dev -> priv_flags <TAB> <TAB> &= ~ IFF_XMIT_DST_RELEASE ; <NEW_LINE> <END_VULN> <TAB> dev -> tx_queue_len <TAB> = 0 ; <NEW_LINE> <TAB> dev -> netdev_ops <TAB> <TAB> = & vlan_netdev_ops ;
<TAB> ( void ) CopyMagickString ( write_info -> magick , images -> magick , MagickPathExtent ) ; <NEW_LINE> p = images ; <NEW_LINE> for ( ; GetNextImageInList ( p ) != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) <NEW_LINE> <START_VULN> <TAB> if ( p -> scene >= GetNextImageInList ( p ) -> scene ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> <TAB> register ssize_t <NEW_LINE> <TAB> <TAB> i ;
<TAB> if ( value . IsEmpty ( ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! merge && entry ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> mHeaders . RemoveElementAt ( index ) ; <NEW_LINE> <TAB> <TAB> return NS_OK ; <NEW_LINE> <TAB> }
#else <NEW_LINE> <TAB> ctl -> pw -> pw_gecos = gecos ; <NEW_LINE> <START_VULN> <TAB> if ( setpwnam ( ctl -> pw ) < 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> warn ( "setpwnam failed" ) ; <NEW_LINE> #endif <NEW_LINE> <TAB> <TAB> printf ( _
<TAB> bits [ 1 ] = cpu_to_be64 ( sctx -> count [ 0 ] << 3 ) ; <NEW_LINE> <START_VULN> <TAB> bits [ 0 ] = cpu_to_be64 ( sctx -> count [ 1 ] << 3 ) | sctx -> count [ 0 ] >> 61 ; <NEW_LINE> <END_VULN>
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 103 2014 / 05 / 02 02 : 25 : 10 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef BUILTIN_ELF
<TAB> union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; <NEW_LINE> <TAB> char <TAB> line [ TOSHIBA_LINE_LENGTH ] ; <NEW_LINE> <TAB> int <TAB> num_items_scanned ; <NEW_LINE> <START_VULN> <TAB> guint <TAB> pkt_len ; <NEW_LINE><TAB> int <TAB> pktnum , hr , min , sec , csec ; <NEW_LINE> <END_VULN> <TAB> char <TAB> channel [ 10 ] , direction [ 10 ] ; <NEW_LINE> <TAB> int <TAB> i , hex_lines ; <NEW_LINE> <TAB> guint8 <TAB> * pd ;
<TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ! eof ) { <NEW_LINE> <END_VULN> <TAB> <TAB> memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return SUCCESS ;
struct crypto_template * crypto_lookup_template ( const char * name ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return try_then_request_module ( __crypto_lookup_template ( name ) , " % s" , <NEW_LINE><TAB> <TAB> <TAB> <TAB> name ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> EXPORT_SYMBOL_GPL ( crypto_lookup_template ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> s -> mb_width = h -> sps . mb_width ; <NEW_LINE> <TAB> s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ;
{ <NEW_LINE> <TAB> char * universal_ip_address = NULL ; <NEW_LINE> <TAB> char * protocol = NULL ; <NEW_LINE> <START_VULN> <TAB> guint8 b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8 , b9 , b10 ; <NEW_LINE> <END_VULN> <TAB> guint16 port ; <NEW_LINE> <TAB> int addr_offset ;
<TAB> <TAB> <TAB> item = proto_tree_add_text ( sched_tree , tvb , offset , 0 , "Other message slots in this schedule" ) ; <NEW_LINE> <TAB> <TAB> <TAB> sched_subtree = proto_item_add_subtree ( item , ett_schedule_new_msg ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> for ( k = 0 ; offset < len ; j + + ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> while ( ( other_slots [ k ] != 0xFFFF ) && ( k < sched_end ) ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> {
<TAB> if ( cText -> buf -> len < minLength ) { <NEW_LINE> <START_VULN> <TAB> SSL_DBG ( ( " % d : SSL3 [ % d ] : HandleRecord , record too small . " , <NEW_LINE><TAB> <TAB> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE><TAB> <NEW_LINE><TAB> ssl_ReleaseSpecReadLock ( ss ) ; <NEW_LINE><TAB> SSL3_SendAlert ( ss , alert_fatal , bad_record_mac ) ; <NEW_LINE><TAB> <NEW_LINE><TAB> PORT_SetError ( SSL_ERROR_BAD_MAC_READ ) ; <NEW_LINE><TAB> return SECFailure ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( cipher_def -> type == type_block &&
<TAB> seq_printf ( m , "seedsize : % u\n" , seedsize ( alg ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> const struct crypto_type crypto_rng_type = { <NEW_LINE> <END_VULN> <TAB> . extsize = crypto_alg_extsize , <NEW_LINE> <TAB> . init_tfm = crypto_rng_init_tfm , <NEW_LINE> #ifdef CONFIG_PROC_FS
<TAB> struct sembuf fast_sops [ SEMOPM_FAST ] ; <NEW_LINE> <TAB> struct sembuf * sops = fast_sops , * sop ; <NEW_LINE> <TAB> struct sem_undo * un ; <NEW_LINE> <START_VULN> <TAB> int undos = 0 , alter = 0 , max ; <NEW_LINE> <END_VULN> <TAB> struct sem_queue queue ; <NEW_LINE> <TAB> unsigned long jiffies_left = 0 ; <NEW_LINE> <TAB> struct ipc_namespace * ns ;
<TAB> <TAB> <TAB> JSObject * argv5 = JSVAL_TO_OBJECT ( argv [ 5 ] ) ; <NEW_LINE> <TAB> <TAB> <TAB> jsval js_width , js_height , js_data ; <NEW_LINE> <TAB> <TAB> <TAB> JS_GetProperty ( cx , argv5 , "width" , & js_width ) ; <NEW_LINE> <TAB> <TAB> <TAB> JS_GetProperty ( cx , argv5 , "height" , & js_height ) ; <NEW_LINE> <TAB> <TAB> <TAB> JS_GetProperty ( cx , argv5 , "data" , & js_data ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( js_width == JSVAL_VOID || <NEW_LINE> <TAB> <TAB> <TAB> <TAB> js_height == JSVAL_VOID || <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> js_data == JSVAL_VOID ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> xpc_qsThrowBadArg ( cx , NS_ERROR_FAILURE , vp , 5 ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return JS_FALSE ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> int32_t int_width , int_height ; <NEW_LINE> <TAB> <TAB> <TAB> JSObject * obj_data = JSVAL_TO_OBJECT ( js_data ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ! JS_ValueToECMAInt32 ( cx , js_width , & int_width ) || <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ! JS_ValueToECMAInt32 ( cx , js_height , & int_height ) )
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> if ( snprintf ( scratch , scratch_len , "Authorization : Basic % s\r\n" , tmp ) > 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> php_stream_write ( stream , scratch , strlen ( scratch ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> jsval * rval ) ; <NEW_LINE> <TAB> JS_REQUIRES_STACK JSRecordingStatus newString ( JSObject * ctor , uint32 argc , jsval * argv , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> jsval * rval ) ; <NEW_LINE> <TAB> JS_REQUIRES_STACK JSRecordingStatus interpretedFunctionCall ( jsval & fval , JSFunction * fun , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uintN argc , bool constructing ) ; <NEW_LINE> <TAB> JS_REQUIRES_STACK void propagateFailureToBuiltinStatus ( nanojit : : LIns * ok_ins , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nanojit : : LIns * & status_ins ) ; <NEW_LINE> <TAB> JS_REQUIRES_STACK JSRecordingStatus emitNativeCall ( JSSpecializedNative * sn , uintN argc , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nanojit : : LIns * args [ ] ) ; <NEW_LINE> <END_VULN> <TAB> JS_REQUIRES_STACK void emitNativePropertyOp ( JSScope * scope , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSScopeProperty * sprop , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nanojit : : LIns * obj_ins , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool setflag , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nanojit : : LIns * boxed_ins ) ; <NEW_LINE> <TAB> JS_REQUIRES_STACK JSRecordingStatus callSpecializedNative ( JSNativeTraceInfo * trcinfo , uintN argc , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool constructing ) ; <NEW_LINE> <TAB> JS_REQUIRES_STACK JSRecordingStatus callNative ( uintN argc , JSOp mode ) ;
<TAB> <TAB> <TAB> int getfrag ( void * from , char * to , int offset , int len , <NEW_LINE> <TAB> <TAB> <TAB> int odd , struct sk_buff * skb ) , <NEW_LINE> <TAB> <TAB> <TAB> void * from , int length , int hh_len , int fragheaderlen , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> int transhdrlen , int mtu , unsigned int flags ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct sk_buff * skb ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> else <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> break ;
<TAB> char * src ; <NEW_LINE> <TAB> char * dest = RUN_XAUTHORITY_FILE ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> FILE * fp = fopen ( dest , "w" ) ; <NEW_LINE> <TAB> if ( fp ) { <NEW_LINE> <TAB> <TAB> fprintf ( fp , "\n" ) ;
<TAB> <TAB> <TAB> return ; \ <NEW_LINE> <TAB> <TAB> } \ <NEW_LINE> <TAB> <TAB> \ <NEW_LINE> <START_VULN> <TAB> <TAB> phar_file_stat ( filename , ( php_stat_len ) filename_len , funcnum , PHAR_G ( orig ) , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; \ <NEW_LINE> <END_VULN> <TAB> } \ <NEW_LINE> }
<START_VULN> <NEW_LINE> <END_VULN> <TAB> if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || <NEW_LINE> <TAB> ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ||
<TAB> <TAB> mode_t curumsk = umask ( 022 ) ; <NEW_LINE> <TAB> <TAB> umask ( curumsk ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( fchmod ( fileno ( fp ) , 0666 - curumsk ) < 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> err_status = "create_chmod" ; <NEW_LINE> <TAB> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> <TAB> }
<TAB> } <NEW_LINE> <TAB> if ( strncasecmp ( resource -> scheme , "http" , sizeof ( "http" ) ) && strncasecmp ( resource -> scheme , "https" , sizeof ( "https" ) ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! context || <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> php_stream_context_get_option ( context , wrapper -> wops -> label , "proxy" , & tmpzval ) == FAILURE || <NEW_LINE> <TAB> <TAB> <TAB> Z_TYPE_PP ( tmpzval ) != IS_STRING || <NEW_LINE> <TAB> <TAB> <TAB> Z_STRLEN_PP ( tmpzval ) <= 0 ) {
<TAB> if ( task -> tk_status < 0 ) { <NEW_LINE> <TAB> <TAB> dprintk ( "lockd : unlock failed ( err = % d ) \n" , - task -> tk_status ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> goto retry_rebind ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( status == NLM_LCK_DENIED_GRACE_PERIOD ) { <NEW_LINE> <TAB> <TAB> rpc_delay ( task , NLMCLNT_GRACE_WAIT ) ;
<TAB> struct timespec64 ts64 ; <NEW_LINE> <TAB> bool sig_none ; <NEW_LINE> <START_VULN> <TAB> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <NEW_LINE> <END_VULN> <TAB> iv = timr -> it_interval ;
typedef struct { <NEW_LINE> <TAB> int nfats ; <NEW_LINE> <TAB> off_t fat_start ; <NEW_LINE> <START_VULN> <TAB> unsigned int fat_size ; <TAB> <NEW_LINE> <END_VULN> <TAB> unsigned int fat_bits ; <TAB> <NEW_LINE> <TAB> unsigned int eff_fat_bits ; <TAB> <NEW_LINE> <TAB> uint32_t root_cluster ; <TAB>
<TAB> <TAB> <TAB> if ( subpats != NULL ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> if ( pcre_get_substring_list ( subject , offsets , count , & stringlist ) < 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> efree ( subpat_names ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> efree ( offsets ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> if ( match_sets ) efree ( match_sets ) ;
#define pte_write ( pte ) <TAB> <TAB> ( ! ! ( pte_val ( pte ) & PTE_WRITE ) ) <NEW_LINE> #define pte_exec ( pte ) <TAB> <TAB> ( ! ( pte_val ( pte ) & PTE_UXN ) ) <NEW_LINE> <START_VULN> #define pte_valid_ng ( pte ) \ <NEW_LINE><TAB> ( ( pte_val ( pte ) & ( PTE_VALID | PTE_NG ) ) == ( PTE_VALID | PTE_NG ) ) <NEW_LINE> <END_VULN> static inline pte_t pte_wrprotect ( pte_t pte ) <NEW_LINE> {
<TAB> <TAB> <TAB> strlcpy ( psz_share , psz_parser , sizeof ( psz_share ) ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> sprintf ( psz_remote , "\\\\ % s\\ % s" , psz_server , psz_share ) ; <NEW_LINE> <END_VULN> <TAB> net_resource . lpRemoteName = psz_remote ; <NEW_LINE> <TAB> i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ) ;
<TAB> PRUint32 Generation ( ) { return mGeneration ; } <NEW_LINE> protected : <NEW_LINE> <START_VULN> <TAB> nsHTMLCanvasElement * mCanvasElement ; <NEW_LINE> <END_VULN> <TAB> nsRefPtr < gl : : GLContext > gl ;
<TAB> goto bail ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <NEW_LINE> <END_VULN> <TAB> request_buf . value = buf2 ; <NEW_LINE> <TAB> sec_token = & request_buf ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const AVFrame * src , int field ) <NEW_LINE> { <NEW_LINE> <TAB> int plane ; <NEW_LINE> <START_VULN> <TAB> for ( plane = 0 ; plane < 4 && src -> data [ plane ] ; plane + + ) <NEW_LINE> <END_VULN> <TAB> <TAB> av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ;
<START_VULN> <TAB> <NEW_LINE>virtual bool Bound ( int32_t offset , int32_t length ) ; <NEW_LINE><NEW_LINE><TAB> <NEW_LINE><TAB> <NEW_LINE><TAB> <NEW_LINE><TAB> <NEW_LINE><TAB> <NEW_LINE><TAB> <NEW_LINE>virtual bool Bound ( int32_t offset ) ; <NEW_LINE> <END_VULN>
#ifndef MODULE_MAGIC_NUMBER_MAJOR <NEW_LINE> #define MODULE_MAGIC_NUMBER_MAJOR 20150222 <NEW_LINE> #endif <NEW_LINE> <START_VULN> #define MODULE_MAGIC_NUMBER_MINOR 2 <NEW_LINE> <END_VULN> AP_DECLARE ( int ) ap_some_auth_required ( request_rec * r ) ;
uint length , counter = 0 ; <NEW_LINE> ulong rowcount = 0L ; <NEW_LINE> char tables [ NAME_LEN + 1 ] , rows [ NAME_LEN + 1 ] ; <NEW_LINE> <START_VULN> char query [ 255 ] ; <NEW_LINE> <END_VULN> MYSQL_FIELD * field ; <NEW_LINE> MYSQL_RES * result ; <NEW_LINE> MYSQL_ROW row = NULL , rrow ;
<TAB> <TAB> put_cmsg ( msg , SOL_SOCKET , <NEW_LINE> <TAB> <TAB> <TAB> SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> skb -> len , skb -> data ) ; <NEW_LINE> <TAB> }
<TAB> void CVE_2011_3003_CopySubDataIfElementArray ( GLuint byteOffset , GLuint byteLength , const void * data ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> memcpy ( ( void * ) ( size_t ( mData ) + byteOffset ) , data , byteLength ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> }
* <NEW_LINE> <START_VULN> #include < k5 - platform . h > <NEW_LINE> <END_VULN> #include < gssrpc / rpc . h > <NEW_LINE> #include < gssapi / gssapi_krb5 . h > <NEW_LINE> #include < syslog . h >
<TAB> <TAB> <TAB> if ( binaries [ i ] == NULL ) <NEW_LINE> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> hb_log ( "OpenCL : hb_generat_bin_from_kernel_source : malloc for binaries [ % d ] failed" , i ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> return 0 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> else
<TAB> do { <NEW_LINE> <START_VULN> <TAB> <TAB> * rowp + + = * -- stackp ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( rowp == rowend ) <NEW_LINE> <TAB> <TAB> OUTPUT_ROW ( ) ; <NEW_LINE> <TAB> } while ( stackp > stack ) ;
<TAB> <TAB> goto end ; <NEW_LINE> <START_VULN> <TAB> p = BuildTestPacket ( id , 1 , 0 , 'A' , 0 ) ; <NEW_LINE> <END_VULN> <TAB> if ( p == NULL ) <NEW_LINE> <TAB> <TAB> goto end ;
<TAB> stream_read ( s , wmac , sizeof ( wmac ) ) ; <NEW_LINE> <TAB> length -= sizeof ( wmac ) ; <NEW_LINE> <START_VULN> <TAB> security_decrypt ( s -> p , length , rdp ) ; <NEW_LINE> <END_VULN> <TAB> if ( securityFlags & SEC_SECURE_CHECKSUM ) <NEW_LINE> <TAB> <TAB> security_salted_mac_signature ( rdp , s -> p , length , FALSE , cmac ) ;
<TAB> if ( ! err && ( iattr -> ia_valid & ATTR_UID ) ) { <NEW_LINE> <TAB> <TAB> struct socket * sock = SOCKET_I ( d_inode ( dentry ) ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> sock -> sk -> sk_uid = iattr -> ia_uid ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return err ;
<TAB> ext4_ext_show_leaf ( inode , path ) ; <NEW_LINE> <START_VULN> <TAB> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <NEW_LINE> <END_VULN> <TAB> <TAB> ret = ext4_split_unwritten_extents ( handle , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> inode , path , iblock , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> max_blocks , flags ) ;
<TAB> const unsigned char * ps ; <NEW_LINE> <TAB> const unsigned char * ps_end ; <NEW_LINE> <TAB> unsigned char * pd ; <NEW_LINE> <START_VULN> <TAB> int i , l ; <NEW_LINE> <END_VULN> <TAB> unsigned char * dest_end = dest + dest_len ; <NEW_LINE> <TAB> ps = src ;
<TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> #endif <NEW_LINE> <TAB> SECKEY_DestroyPublicKey ( pubKey ) ; <NEW_LINE> <TAB> pubKey = NULL ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> ss -> ssl3 . hs . ws = wait_cert_request ; <NEW_LINE><TAB> if ( ss -> ssl3 . hs . kea_def -> is_limited || <NEW_LINE><TAB> <NEW_LINE>#ifndef NSS_DISABLE_ECC <NEW_LINE><TAB> ss -> ssl3 . hs . kea_def -> kea == kea_ecdhe_ecdsa || <NEW_LINE><TAB> ss -> ssl3 . hs . kea_def -> kea == kea_ecdhe_rsa || <NEW_LINE>#endif <NEW_LINE><TAB> ss -> ssl3 . hs . kea_def -> exchKeyType == kt_dh ) { <NEW_LINE><TAB> ss -> ssl3 . hs . ws = wait_server_key ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> } else { <NEW_LINE> <TAB> ss -> ssl3 . hs . ws = wait_client_key ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> PORT_Assert ( rv == SECSuccess ) ; <NEW_LINE> <TAB> if ( rv != SECSuccess ) { <NEW_LINE> <TAB> errCode = SEC_ERROR_LIBRARY_FAILURE ; <NEW_LINE> <TAB> rv = SECFailure ;
<TAB> <TAB> } * hdr , _hdr ; <NEW_LINE> <TAB> <TAB> hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; <NEW_LINE> <TAB> <TAB> if ( ! hdr ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> return false ; <NEW_LINE><TAB> <TAB> key_basic -> n_proto = proto ; <NEW_LINE><TAB> <TAB> key_control -> thoff = ( u16 ) nhoff ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( skb_flow_dissector_uses_key ( flow_dissector , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> FLOW_DISSECTOR_KEY_TIPC_ADDRS ) ) {
<TAB> <TAB> <TAB> : asRope ( ) . flatten ( cx ) ; <NEW_LINE> } <NEW_LINE> JS_ALWAYS_INLINE JSFixedString * <NEW_LINE> JSString : : ensureFixed ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> <TAB> if ( ! ensureFlat ( cx ) ) <NEW_LINE> <TAB> <TAB> return NULL ; <NEW_LINE> <START_VULN> <TAB> if ( isExtensible ( ) ) { <NEW_LINE><TAB> <TAB> JS_ASSERT ( ( d . lengthAndFlags & FLAT_MASK ) == 0 ) ; <NEW_LINE><TAB> <TAB> JS_STATIC_ASSERT ( EXTENSIBLE_FLAGS == ( JS_BIT ( 2 ) | JS_BIT ( 3 ) ) ) ; <NEW_LINE><TAB> <TAB> JS_STATIC_ASSERT ( FIXED_FLAGS == JS_BIT ( 2 ) ) ; <NEW_LINE><TAB> <TAB> d . lengthAndFlags ^ = JS_BIT ( 3 ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> return & asFixed ( ) ; <NEW_LINE> } <NEW_LINE> inline js : : PropertyName * <NEW_LINE> JSAtom : : asPropertyName ( ) <NEW_LINE> { <NEW_LINE> #ifdef DEBUG <NEW_LINE> <TAB> uint32_t dummy ;
<TAB> struct ttm_object_file * tfile = vmw_fpriv ( file_priv ) -> tfile ; <NEW_LINE> <TAB> int ret ; <NEW_LINE> <TAB> uint32_t size ; <NEW_LINE> <START_VULN> <TAB> uint32_t backup_handle ; <NEW_LINE> <END_VULN> <TAB> if ( req -> multisample_count != 0 ) <NEW_LINE> <TAB> <TAB> return - EINVAL ;
#endif <NEW_LINE> <TAB> if ( * src == ' / ' ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { <NEW_LINE><TAB> <TAB> <TAB> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , <NEW_LINE><TAB> <TAB> <TAB> "Path is absolute" ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return ( ARCHIVE_FAILED ) ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> { <NEW_LINE> <TAB> <TAB> assign ( 0 ) ; <NEW_LINE> <TAB> <TAB> return reinterpret_cast < void ** > ( & mRawPtr ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> void <NEW_LINE> <TAB> assign ( T * newPtr ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> NS_ABORT_IF_FALSE ( mRawPtr != newPtr || ! newPtr , "This makes no sense ! " ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> T * oldPtr = mRawPtr ; <NEW_LINE> <TAB> <TAB> mRawPtr = newPtr ; <NEW_LINE> <TAB> <TAB> delete oldPtr ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> " < a href = \"http : <NEW_LINE> <TAB> <TAB> " < / body > \n" <NEW_LINE> <TAB> <TAB> " < / html > \n" , errname , code , errname , <NEW_LINE> <START_VULN> <TAB> <TAB> ( url ? " ( " : "" ) , ( url ? url : "" ) , ( url ? " ) " : "" ) ) ; <NEW_LINE> <END_VULN> <TAB> if ( res == - 1 ) <NEW_LINE> <TAB> {
<TAB> i = 0 ; <NEW_LINE> <START_VULN> <TAB> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> i + + ; <NEW_LINE> <TAB> }
<TAB> void * reghash ; <NEW_LINE> <TAB> void * userdata ; <NEW_LINE> <TAB> JSScript * script ; <NEW_LINE> <START_VULN> <TAB> const char * filename ; <NEW_LINE><TAB> XDRAtoms * atoms ; <NEW_LINE><TAB> XDRAtomsHashMap * atomsMap ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> extern JS_PUBLIC_API ( void )
<TAB> p = this ; <NEW_LINE> <TAB> p -- ; <NEW_LINE> <TAB> if ( p < 0 ) p += VE_AMP ; <NEW_LINE> <TAB> postmax = max ( acc , filters [ j ] . ampbuf [ p ] ) ; <NEW_LINE> <TAB> postmin = min ( acc , filters [ j ] . ampbuf [ p ] ) ; <NEW_LINE> <TAB> for ( i = 0 ; i < stretch ; i + + ) { <NEW_LINE> <START_VULN> <TAB> p -- ; <NEW_LINE><TAB> if ( p < 0 ) p += VE_AMP ; <NEW_LINE><TAB> premax = max ( premax , filters [ j ] . ampbuf [ p ] ) ; <NEW_LINE><TAB> premin = min ( premin , filters [ j ] . ampbuf [ p ] ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> valmin = postmin - premin ; <NEW_LINE> <TAB> valmax = postmax - premax ; <NEW_LINE> <TAB> filters [ j ] . ampbuf [ this ] = acc ; <NEW_LINE> <TAB> filters [ j ] . ampptr + + ;
virtual bool IsTransportSeekable ( ) = 0 ; <NEW_LINE> <START_VULN> static MediaResource * Create ( MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <NEW_LINE> <END_VULN> virtual nsresult Open ( nsIStreamListener ** aStreamListener ) = 0 ; <NEW_LINE> #ifdef MOZ_DASH
<TAB> <TAB> exit ( 1 ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> pid_t child = fork ( ) ; <NEW_LINE><TAB> if ( child < 0 ) <NEW_LINE><TAB> <TAB> errExit ( "fork" ) ; <NEW_LINE><TAB> if ( child == 0 ) { <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> drop_privs ( 0 ) ; <NEW_LINE><NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; <NEW_LINE><TAB> <TAB> if ( rv ) <NEW_LINE><TAB> <TAB> <TAB> fprintf ( stderr , "Warning : cannot transfer . Xauthority in private home directory\n" ) ; <NEW_LINE><TAB> <TAB> else { <NEW_LINE><TAB> <TAB> <TAB> fs_logger2 ( "clone" , dest ) ; <NEW_LINE><TAB> <TAB> } <NEW_LINE><TAB> <TAB> _exit ( 0 ) ; <NEW_LINE><TAB> } <NEW_LINE><TAB> <NEW_LINE><TAB> waitpid ( child , NULL , 0 ) ; <NEW_LINE> <END_VULN> <TAB> unlink ( src ) ;
const char * s = src ; <NEW_LINE> * pt + + = '"' ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE>dlen -= 2 ; <NEW_LINE> <END_VULN> for ( ; * s && dlen ; s + + ) <NEW_LINE> {
<TAB> } <NEW_LINE> <START_VULN> <TAB> sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; <NEW_LINE> <END_VULN> <TAB> sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : bitrate tracking and management <NEW_LINE> <START_VULN> last mod : $ Id : bitrate . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
<TAB> <TAB> <TAB> efree ( ustr ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> ubrk_close ( bi ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> RETURN_EMPTY_STRING ( ) ; <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> }
<TAB> <TAB> bodyLength = pntoh16 ( data + offset + 2 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ( tot_len - offset - 4 ) < bodyLength ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "EAPOL body too short" , AIRPDCAP_DEBUG_LEVEL_3 ) ; <NEW_LINE> <TAB> <TAB> <TAB> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; <NEW_LINE> <TAB> <TAB> }
class nsIDOMNodeList ; <NEW_LINE> class mozAutoSubtreeModified ; <NEW_LINE> struct JSObject ; <NEW_LINE> class nsFrameLoader ; <NEW_LINE> class nsIBoxObject ; <NEW_LINE> #define NS_IDOCUMENT_IID \ <NEW_LINE> <START_VULN> { 0x2ca82a51 , 0x4a6a , 0x4dfa , \ <NEW_LINE><TAB> { 0xa6 , 0x5f , 0x49 , 0x52 , 0xa3 , 0xaa , 0x02 , 0xef } } <NEW_LINE> <END_VULN> #define NS_STYLESHEET_FROM_CATALOG ( 1 << 0 )
extern key_ref_t search_my_process_keyrings ( struct keyring_search_context * ctx ) ; <NEW_LINE> extern key_ref_t search_process_keyrings ( struct keyring_search_context * ctx ) ; <NEW_LINE> <START_VULN> extern struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) ; <NEW_LINE> <END_VULN> extern int install_user_keyrings ( void ) ; <NEW_LINE> extern int install_thread_keyring_to_cred ( struct cred * ) ;
<TAB> <TAB> } <NEW_LINE> <TAB> <TAB> else { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; <NEW_LINE><TAB> <TAB> <TAB> char * buff = malloc ( bytes_to_copy ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( debug_logging_mode ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> error_line ( "extra unknown chunk \" % c % c % c % c\" of % d bytes" ,
MODULE_DESCRIPTION ( "Driver for ST - Ericsson UX500 HASH engine . " ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha1 - all" ) ; <NEW_LINE>MODULE_ALIAS ( "sha256 - all" ) ; <NEW_LINE>MODULE_ALIAS ( "hmac - sha1 - all" ) ; <NEW_LINE>MODULE_ALIAS ( "hmac - sha256 - all" ) ; <NEW_LINE> <END_VULN>
<TAB> BuiltInFunctionEmulator builtInFunctionEmulator ; <NEW_LINE> <TAB> TInfoSink infoSink ; <NEW_LINE> <TAB> TVariableInfoList attribs ; <NEW_LINE> <TAB> TVariableInfoList uniforms ; <NEW_LINE> <START_VULN> <TAB> TMap < TString , TString > varyingLongNameMap ; <NEW_LINE> <END_VULN> } ;
<TAB> if ( page == NULL ) <NEW_LINE> <TAB> page = http_request_get_query_string ( req ) ; <NEW_LINE> <START_VULN> <TAB> if ( page && ( unlink ( page ) > 0 ) ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> http_response_printf ( res , "success" ) ; <NEW_LINE> <TAB> http_response_send ( res ) ;
<TAB> rcvd_serial = ntohl ( addip_hdr -> serial ) ; <NEW_LINE> <START_VULN> <TAB> if ( ! sctp_verify_asconf ( asoc , <NEW_LINE><TAB> ( sctp_paramhdr_t * ) addip_hdr -> params , <NEW_LINE><TAB> ( void * ) asconf_ack -> chunk_end , <NEW_LINE><TAB> & err_param ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , <NEW_LINE> <TAB> <TAB> <TAB> ( void * ) err_param , commands ) ;
* <TAB> <TAB> this should be changed to take a callback which retrieves <NEW_LINE> * <TAB> <TAB> the password . it may be possible for different safes to <NEW_LINE> * <TAB> <TAB> have different passwords . also , the password is already <NEW_LINE> * <TAB> <TAB> in unicode . it should probably be converted down below via <NEW_LINE> * <TAB> <TAB> a unicode conversion callback . <NEW_LINE> * <TAB> slot - the slot to import the dataa into should multiple slots <NEW_LINE> * <TAB> <TAB> be supported based on key type and cert type ? <NEW_LINE> * <TAB> dOpen , dClose , dRead , dWrite - digest routines for writing data <NEW_LINE> <START_VULN> * <TAB> <TAB> to a file so it could be read back and the hmack recomputed <NEW_LINE> * <TAB> <TAB> and verified . doesn't seem to be away for both encoding <NEW_LINE> <END_VULN> * <TAB> <TAB> and decoding to be single pass , thus the need for these <NEW_LINE> * <TAB> <TAB> routines . <NEW_LINE> * <TAB> dArg - the argument for dOpen , etc . <NEW_LINE> * <NEW_LINE> * <NEW_LINE> * <TAB> This function returns the decoder context , if it was successful .
<TAB> } <NEW_LINE> #endif <NEW_LINE> <TAB> void RunScript ( nsIContent * aScriptElement ) ; <NEW_LINE> <TAB> void Reset ( ) ; <NEW_LINE> <TAB> inline void HoldElement ( nsIContent * aContent ) { <NEW_LINE> <START_VULN> <TAB> mOwnedElements . AppendObject ( aContent ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> void DropHeldElements ( ) ;
<TAB> mutt_debug ( 1 , "#2 Error receiving server response . \n" ) ; <NEW_LINE> <TAB> goto bail ; <NEW_LINE> } <NEW_LINE> <START_VULN> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <NEW_LINE> <END_VULN> request_buf . value = buf2 ; <NEW_LINE> maj_stat = gss_unwrap ( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ;
<TAB> return register_die_notifier ( & kgdb_notifier ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void kgdb_hw_overflow_handler ( struct perf_event * event , int nmi , <NEW_LINE> <END_VULN> <TAB> <TAB> struct perf_sample_data * data , struct pt_regs * regs ) <NEW_LINE> { <NEW_LINE> <TAB> struct task_struct * tsk = current ;
<TAB> . cia_decrypt <TAB> <TAB> = <TAB> des3_ede_decrypt } } <NEW_LINE> } } ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "des3_ede" ) ; <NEW_LINE> <END_VULN> static int __init des_generic_mod_init ( void ) <NEW_LINE> {
<TAB> struct sk_buff * skb , * tmp ; <NEW_LINE> <TAB> struct sctp_ulpevent * event ; <NEW_LINE> <TAB> struct sctp_bind_hashbucket * head ; <NEW_LINE> <START_VULN> <TAB> struct list_head tmplist ; <NEW_LINE><TAB> if ( oldsp -> do_auto_asconf ) { <NEW_LINE><TAB> <TAB> memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ; <NEW_LINE><TAB> <TAB> inet_sk_copy_descendant ( newsk , oldsk ) ; <NEW_LINE><TAB> <TAB> memcpy ( & newsp -> auto_asconf_list , & tmplist , sizeof ( tmplist ) ) ; <NEW_LINE><TAB> } else <NEW_LINE><TAB> <TAB> inet_sk_copy_descendant ( newsk , oldsk ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> <TAB> goto found ; <NEW_LINE> <TAB> <TAB> entry = next ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ext2_xattr_cache_insert ( bh ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> ea_idebug ( inode , "cache insert failed" ) ; <NEW_LINE> <TAB> error = - ENODATA ; <NEW_LINE> <TAB> goto cleanup ;
nsresult SetAttrAndNotify ( PRInt32 aNamespaceID , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIAtom * aName , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIAtom * aPrefix , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsAString & aOldValue , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsAttrValue & aParsedValue , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRBool aModification , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRBool aFireMutation , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRBool aNotify ) ; <NEW_LINE> <END_VULN> <TAB> *
<TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> DPRINTF ( ( "nelements = % " SIZE_T_FORMAT "u\n" , <NEW_LINE> <TAB> <TAB> <TAB> nelements ) ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> for ( j = 0 ; j < nelements ; j + + , i + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> uint32_t l = CDF_GETUINT32 ( q , o ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> inp [ i ] . pi_str . s_len = l ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> inp [ i ] . pi_str . s_buf = ( const char * )
static void rtc_irq_eoi_tracking_reset ( struct kvm_ioapic * ioapic ) <NEW_LINE> { <NEW_LINE> <TAB> ioapic -> rtc_status . pending_eoi = 0 ; <NEW_LINE> <START_VULN> <TAB> bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void kvm_rtc_eoi_tracking_restore_all ( struct kvm_ioapic * ioapic ) ;
class nsJPEGDecoder : public Decoder <NEW_LINE> { <NEW_LINE> public : <NEW_LINE> nsJPEGDecoder ( RasterImage & aImage , Decoder : : DecodeStyle aDecodeStyle ) ; <NEW_LINE> virtual ~ nsJPEGDecoder ( ) ; <NEW_LINE> virtual void InitInternal ( ) ; <NEW_LINE> <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> virtual void FinishInternal ( ) ; <NEW_LINE> virtual Telemetry : : ID SpeedHistogram ( ) ; <NEW_LINE> void NotifyDone ( ) ; <NEW_LINE> protected : <NEW_LINE> Orientation ReadOrientationFromEXIF ( ) ; <NEW_LINE> void OutputScanlines ( bool * suspend ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> fvalue = va_arg ( args , double ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> case 'c' : <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> doapr_outch ( sbuffer , buffer , & currlen , maxlen , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> va_arg ( args , int ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> case 's' : <NEW_LINE> <TAB> <TAB> <TAB> <TAB> strvalue = va_arg ( args , char * ) ;
<TAB> seq_puts ( m , key -> description ) ; <NEW_LINE> <START_VULN> <TAB> if ( key_is_instantiated ( key ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> seq_printf ( m , " : % zu [ % s ] " , <NEW_LINE> <TAB> <TAB> <TAB> datalen , <NEW_LINE> <TAB> <TAB> <TAB> datalen > BIG_KEY_FILE_THRESHOLD ? "file" : "buff" ) ;
<TAB> RESERVE_SPACE ( 8 ) ; <NEW_LINE> <TAB> WRITE32 ( OP_OPEN ) ; <NEW_LINE> <TAB> WRITE32 ( arg -> seqid -> sequence -> counter ) ; <NEW_LINE> <START_VULN> <TAB> encode_share_access ( xdr , arg -> open_flags ) ; <NEW_LINE> <END_VULN> <TAB> RESERVE_SPACE ( 28 ) ; <NEW_LINE> <TAB> WRITE64 ( arg -> clientid ) ; <NEW_LINE> <TAB> WRITE32 ( 16 ) ;
<TAB> tfm -> __crt_alg -> cra_type == & crypto_givcipher_type ) <NEW_LINE> <TAB> <TAB> return crypto_init_skcipher_ops_ablkcipher ( tfm ) ; <NEW_LINE> <START_VULN> <TAB> skcipher -> setkey = alg -> setkey ; <NEW_LINE> <END_VULN> <TAB> skcipher -> encrypt = alg -> encrypt ; <NEW_LINE> <TAB> skcipher -> decrypt = alg -> decrypt ; <NEW_LINE> <TAB> skcipher -> ivsize = alg -> ivsize ;
#include "file . h" <NEW_LINE> #ifndef <TAB> lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : softmagic . c , v 1 . 196 2014 / 11 / 07 15 : 24 : 14 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <TAB> <NEW_LINE> #include "magic . h"
#endif <NEW_LINE> <TAB> unsigned char <TAB> <TAB> tk_priority : 2 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> tk_garb_retry : 2 , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> tk_cred_retry : 2 ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> #define tk_xprt <TAB> <TAB> <TAB> tk_client -> cl_xprt
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : libvorbis codec headers <NEW_LINE> <START_VULN> last mod : $ Id $ <NEW_LINE> <END_VULN> #ifndef _vorbis_codec_h_ <NEW_LINE> #define _vorbis_codec_h_ <NEW_LINE> #ifdef __cplusplus <NEW_LINE> extern "C"
{ <NEW_LINE> <TAB> struct nfs_delegation * delegation ; <NEW_LINE> <TAB> struct nfs4_opendata * opendata ; <NEW_LINE> <START_VULN> <TAB> int delegation_type = 0 ; <NEW_LINE> <END_VULN> <TAB> int status ; <NEW_LINE> <TAB> opendata = nfs4_open_recoverdata_alloc ( ctx , state ) ;
<TAB> msr . data = data ; <NEW_LINE> <TAB> msr . index = ecx ; <NEW_LINE> <TAB> msr . host_initiated = false ; <NEW_LINE> <START_VULN> <TAB> if ( vmx_set_msr ( vcpu , & msr ) != 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> trace_kvm_msr_write_ex ( ecx , data ) ; <NEW_LINE> <TAB> <TAB> kvm_inject_gp ( vcpu , 0 ) ; <NEW_LINE> <TAB> <TAB> return 1 ;
<TAB> <TAB> <TAB> av_get_picture_type_char ( frame -> pict_type ) , <NEW_LINE> <TAB> <TAB> <TAB> checksum , plane_checksum [ 0 ] ) ; <NEW_LINE> <START_VULN> <TAB> for ( plane = 1 ; plane < 4 && frame -> data [ plane ] ; plane + + ) <NEW_LINE> <END_VULN> <TAB> <TAB> av_log ( ctx , AV_LOG_INFO , " % 08X" , plane_checksum [ plane ] ) ; <NEW_LINE> <TAB> av_log ( ctx , AV_LOG_INFO , " ] \n" ) ;
<TAB> l = dh -> length ? dh -> length : BN_num_bits ( dh -> p ) - 1 ; <NEW_LINE> <START_VULN> <TAB> do <NEW_LINE><TAB> <TAB> { <NEW_LINE><TAB> <TAB> if ( ! BN_rand ( priv_key , l , 0 , 0 ) ) goto err ; <NEW_LINE><TAB> <TAB> if ( ! ENGINE_get_DH ( dh -> engine ) -> bn_mod_exp ( dh , pub_key , dh -> g , <NEW_LINE><TAB> <TAB> <TAB> priv_key , dh -> p , ctx , mont ) ) goto err ; <NEW_LINE><TAB> <TAB> } <NEW_LINE><TAB> while ( BN_is_one ( priv_key ) ) ; <NEW_LINE> <END_VULN> <TAB> dh -> pub_key = pub_key ; <NEW_LINE> <TAB> dh -> priv_key = priv_key ;
#define char_to_int ( p ) ( p - '0' ) <NEW_LINE> #define OSSL_MAX ( p , q ) ( ( p >= q ) ? p : q ) <NEW_LINE> <START_VULN> static void <NEW_LINE> <END_VULN> _dopr ( char ** sbuffer , <NEW_LINE> <TAB> char ** buffer , <NEW_LINE> <TAB> size_t * maxlen ,
<TAB> } <NEW_LINE> <TAB> key_ref = ERR_PTR ( - EINVAL ) ; <NEW_LINE> <START_VULN> <TAB> if ( ! index_key . type -> match || ! index_key . type -> instantiate || <NEW_LINE> <END_VULN> <TAB> ( ! index_key . description && ! index_key . type -> preparse ) ) <NEW_LINE> <TAB> <TAB> goto error_put_type ;
decoder_info -> bit_count . super_mode [ decoder_info -> bit_count . stat_frame_type ] += ( stream -> bitcnt - bit_start ) ; <NEW_LINE> <START_VULN> if ( split_flag ) { <NEW_LINE> <END_VULN> <TAB> int new_size = size / 2 ; <NEW_LINE> <TAB> TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 0 * new_size , xposY + 0 * new_size , sub ) ; <NEW_LINE> <TAB> TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 1 * new_size , xposY + 0 * new_size , sub ) ;
<TAB> struct task_struct * tsk = current ; <NEW_LINE> <TAB> struct sh_fpu_soft_struct * fpu = & ( tsk -> thread . xstate -> softfpu ) ; <NEW_LINE> <START_VULN> <TAB> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! ( task_thread_info ( tsk ) -> status & TS_USEDFPU ) ) {
<TAB> <TAB> <TAB> <TAB> * analyze_script_file_name , getErrorText ( ) ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> <TAB> if ( os_info . user_specified ) <NEW_LINE><TAB> <TAB> pg_free ( user_specification ) ; <NEW_LINE> <END_VULN> <TAB> check_ok ( ) ; <NEW_LINE> }
<TAB> qemu_get_be32s ( f , & opp -> spve ) ; <NEW_LINE> <TAB> qemu_get_be32s ( f , & opp -> tfrr ) ; <NEW_LINE> <START_VULN> <TAB> qemu_get_be32s ( f , & opp -> nb_cpus ) ; <NEW_LINE> <END_VULN> <TAB> for ( i = 0 ; i < opp -> nb_cpus ; i + + ) { <NEW_LINE> <TAB> <TAB> qemu_get_sbe32s ( f , & opp -> dst [ i ] . ctpr ) ;
<TAB> } else { <NEW_LINE> <TAB> <TAB> num_items_scanned = sscanf ( line , <NEW_LINE> <START_VULN> <TAB> <TAB> " % 5s ( % 127 [ A - Za - z0 - 9 / : ] ) , Length : % 9u , Pro : % 9d , Off : % 9d , Pri : % 9d , RM : % 9d , Err : % 9d [ % 8x , % 8x ] " , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> direction , if_name , & pkt_len , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> & pro , & off , & pri , & rm , & error , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> & code1 , & code2 ) ;
<TAB> <TAB> <TAB> int newbuf = ( pipe -> curbuf + bufs ) & ( pipe -> buffers - 1 ) ; <NEW_LINE> <TAB> <TAB> <TAB> struct pipe_buffer * buf = pipe -> bufs + newbuf ; <NEW_LINE> <TAB> <TAB> <TAB> struct page * page = pipe -> tmp_page ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> char * src ; <NEW_LINE><TAB> <TAB> <TAB> int error , atomic = 1 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( ! page ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> page = alloc_page ( GFP_HIGHUSER ) ;
<TAB> if ( ! ( current -> personality & ADDR_NO_RANDOMIZE ) && randomize_va_space ) <NEW_LINE> <TAB> <TAB> current -> flags |= PF_RANDOMIZE ; <NEW_LINE> <START_VULN> <TAB> arch_pick_mmap_layout ( current -> mm ) ; <NEW_LINE> <END_VULN> <TAB> current -> mm -> free_area_cache = current -> mm -> mmap_base ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 48 2012 / 02 / 17 05 : 27 : 45 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include < assert . h >
<TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> jas_tvparser_destroy ( tvp ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! cmpt -> sampperx || ! cmpt -> samppery ) { <NEW_LINE> <TAB> <TAB> goto error ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( mif_hdr_addcmpt ( hdr , hdr -> numcmpts , cmpt ) ) { <NEW_LINE> <TAB> <TAB> goto error ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return 0 ; <NEW_LINE> error :
<TAB> Com_Printf ( " -- -- - Initializing Renderer -- -- \n" ) ; <NEW_LINE> #ifdef USE_RENDERER_DLOPEN <NEW_LINE> <START_VULN> <TAB> cl_renderer = Cvar_Get ( "cl_renderer" , "opengl2" , CVAR_ARCHIVE | CVAR_LATCH ) ; <NEW_LINE> <END_VULN> <TAB> Com_sprintf ( dllName , sizeof ( dllName ) , "renderer_ % s_" ARCH_STRING DLL_EXT , cl_renderer -> string ) ;
<TAB> unsigned int n_rdonly ; <TAB> <TAB> <NEW_LINE> <TAB> unsigned int n_wronly ; <TAB> <TAB> <NEW_LINE> <TAB> unsigned int n_rdwr ; <TAB> <TAB> <NEW_LINE> <START_VULN> <TAB> int state ; <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> atomic_t count ; <NEW_LINE> } ;
#ifndef _LINUX_JIFFIES_H <NEW_LINE> #define _LINUX_JIFFIES_H <NEW_LINE> <START_VULN> #include < linux / calc64 . h > <NEW_LINE> <END_VULN> #include < linux / kernel . h > <NEW_LINE> #include < linux / types . h > <NEW_LINE> #include < linux / time . h >
nsTextFrame * nextContinuation = <NEW_LINE> <TAB> static_cast < nsTextFrame * > ( aPrevInFlow -> GetNextContinuation ( ) ) ; <NEW_LINE> #endif <NEW_LINE> SetPrevInFlow ( aPrevInFlow ) ; <NEW_LINE> aPrevInFlow -> SetNextInFlow ( this ) ; <NEW_LINE> nsTextFrame * prev = static_cast < nsTextFrame * > ( aPrevInFlow ) ; <NEW_LINE> mContentOffset = prev -> GetContentOffset ( ) + prev -> GetContentLengthHint ( ) ; <NEW_LINE> <START_VULN> NS_ASSERTION ( mContentOffset < aContent -> GetText ( ) -> GetLength ( ) , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> "Creating ContinuingTextFrame , but there is no more content" ) ; <NEW_LINE> if ( prev -> GetStyleContext ( ) != GetStyleContext ( ) ) { <NEW_LINE> <TAB> prev -> ClearTextRun ( ) ; <NEW_LINE> } else { <NEW_LINE> <TAB> mTextRun = prev -> GetTextRun ( ) ; <NEW_LINE> }
} <NEW_LINE> <START_VULN> static inline void realpath_cache_add ( const char * path , int path_len , const char * realpath , int realpath_len , int is_dir , time_t t ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> zend_long size = sizeof ( realpath_cache_bucket ) + path_len + 1 ; <NEW_LINE> <TAB> int same = 1 ;
<TAB> <TAB> r += 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> return ret ; <NEW_LINE> }
#define COPY_FORCE _ ( "Copy _Anyway" ) <NEW_LINE> static void <NEW_LINE> <START_VULN> mark_desktop_file_trusted ( CommonJob * common , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> GCancellable * cancellable , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> GFile * file , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> gboolean interactive ) ; <NEW_LINE> <END_VULN> static gboolean <NEW_LINE> is_all_button_text ( const char * button_text )
<TAB> register const struct in6_addr * addr ; <NEW_LINE> <TAB> dp = ( const struct ip6_rthdr * ) bp ; <NEW_LINE> <START_VULN> <TAB> len = dp -> ip6r_len ; <NEW_LINE> <END_VULN> <TAB> ep = ndo -> ndo_snapend ; <NEW_LINE> <TAB> ND_TCHECK ( dp -> ip6r_segleft ) ; <NEW_LINE> <TAB> ND_PRINT ( ( ndo , "srcrt ( len = % d" , dp -> ip6r_len ) ) ; <TAB> <NEW_LINE> <TAB> ND_PRINT ( ( ndo , " , type = % d" , dp -> ip6r_type ) ) ; <NEW_LINE> <TAB> ND_PRINT ( ( ndo , " , segleft = % d" , dp -> ip6r_segleft ) ) ;
<TAB> sb_block = simple_strtoul ( options , & options , 0 ) ; <NEW_LINE> <TAB> if ( * options && * options != ' , ' ) { <NEW_LINE> <START_VULN> <TAB> <TAB> ext3_msg ( sb , "error : invalid sb specification : % s" , <NEW_LINE> <END_VULN> <TAB> <TAB> ( char * ) * data ) ; <NEW_LINE> <TAB> <TAB> return 1 ; <NEW_LINE> <TAB> }
<TAB> scm -> pid = get_pid ( pid ) ; <NEW_LINE> <TAB> scm -> cred = cred ? get_cred ( cred ) : NULL ; <NEW_LINE> <TAB> scm -> creds . pid = pid_vnr ( pid ) ; <NEW_LINE> <START_VULN> <TAB> scm -> creds . uid = cred ? cred -> euid : INVALID_UID ; <NEW_LINE><TAB> scm -> creds . gid = cred ? cred -> egid : INVALID_GID ; <NEW_LINE> <END_VULN> } <NEW_LINE> static __inline__ void scm_destroy_cred ( struct scm_cookie * scm )
<TAB> <TAB> case ( AVIFOURCC_vids ) : <NEW_LINE> <TAB> <TAB> <TAB> p_strh -> strh . i_samplesize = 0 ; <NEW_LINE> <TAB> <TAB> <TAB> p_chk -> strf . vids . i_cat = VIDEO_ES ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> p_chk -> strf . vids . p_bih = malloc ( p_chk -> common . i_chunk_size ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSize ) ; <NEW_LINE> <TAB> <TAB> <TAB> AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biWidth ) ; <NEW_LINE> <TAB> <TAB> <TAB> AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biHeight ) ;
<TAB> <TAB> <TAB> <TAB> gss_cred_usage_t , gss_OID_set * ) ; <NEW_LINE> static void release_spnego_ctx ( spnego_gss_ctx_id_t * ) ; <NEW_LINE> static void check_spnego_options ( spnego_gss_ctx_id_t ) ; <NEW_LINE> <START_VULN> static spnego_gss_ctx_id_t create_spnego_ctx ( void ) ; <NEW_LINE> <END_VULN> static int put_mech_set ( gss_OID_set mechSet , gss_buffer_t buf ) ; <NEW_LINE> static int put_input_token ( unsigned char ** , gss_buffer_t , unsigned int ) ; <NEW_LINE> static int put_mech_oid ( unsigned char ** , gss_OID_const , unsigned int ) ;
<TAB> <TAB> <TAB> p -> invitestate = INV_TERMINATED ; <NEW_LINE> <TAB> <TAB> <TAB> p -> pendinginvite = 0 ; <NEW_LINE> <TAB> <TAB> <TAB> acked = __sip_ack ( p , seqno , 1 , 0 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( find_sdp ( req ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> if ( process_sdp ( p , req , SDP_T38_NONE ) ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
<TAB> if ( IsAnimValList ( ) ) { <NEW_LINE> <TAB> Element ( ) -> FlushAnimations ( ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return LengthNoFlush ( ) ; <NEW_LINE> } <NEW_LINE> void Clear ( ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < nsISVGPoint > Initialize ( nsISVGPoint & aNewItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & aError ) ; <NEW_LINE> <START_VULN> nsISVGPoint * GetItem ( uint32_t aIndex , ErrorResult & aError ) <NEW_LINE> { <NEW_LINE><TAB> bool found ; <NEW_LINE><TAB> nsISVGPoint * item = IndexedGetter ( aIndex , found , aError ) ; <NEW_LINE><TAB> if ( ! found ) { <NEW_LINE><TAB> aError . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; <NEW_LINE><TAB> } <NEW_LINE><TAB> return item ; <NEW_LINE> } <NEW_LINE>nsISVGPoint * IndexedGetter ( uint32_t aIndex , bool & aFound , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & aError ) ; <NEW_LINE> <END_VULN> already_AddRefed < nsISVGPoint > InsertItemBefore ( nsISVGPoint & aNewItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t aIndex , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < nsISVGPoint > ReplaceItem ( nsISVGPoint & aNewItem , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> uint32_t aIndex , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < nsISVGPoint > RemoveItem ( uint32_t aIndex , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ErrorResult & aError ) ;
static int hns_gmac_get_sset_count ( int stringset ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( stringset == ETH_SS_STATS ) <NEW_LINE> <END_VULN> <TAB> <TAB> return ARRAY_SIZE ( g_gmac_stats_string ) ; <NEW_LINE> <TAB> return 0 ;
<TAB> } <NEW_LINE> <TAB> mark_discard_range_all ( sbi ) ; <NEW_LINE> <START_VULN> <TAB> f2fs_wait_discard_bios ( sbi ) ; <NEW_LINE> <END_VULN> out : <NEW_LINE> <TAB> range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ; <NEW_LINE> <TAB> return err ;
<TAB> <TAB> <TAB> res_dp += len ; <NEW_LINE> <TAB> <TAB> <TAB> res_sz -= len ; <NEW_LINE> <START_VULN> <TAB> <TAB> } <NEW_LINE><TAB> <TAB> else if ( cmd ) { <NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( delta_end - delta < cmd || res_sz < cmd ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto fail ; <NEW_LINE> <TAB> <TAB> <TAB> memcpy ( res_dp , delta , cmd ) ;
if ( array -> items == NULL ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <NEW_LINE> <END_VULN> <TAB> array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( <NEW_LINE> <TAB> <TAB> sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;
PLArenaPool * <NEW_LINE> PORT_NewArena ( unsigned long chunksize ) <NEW_LINE> { <NEW_LINE> <TAB> PORTArenaPool * pool ; <NEW_LINE> <TAB> pool = PORT_ZNew ( PORTArenaPool ) ; <NEW_LINE> <TAB> if ( ! pool ) { <NEW_LINE> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> pool -> magic = ARENAPOOL_MAGIC ; <NEW_LINE> <TAB> pool -> lock = PZ_NewLock ( nssILockArena ) ; <NEW_LINE> <TAB> if ( ! pool -> lock ) { <NEW_LINE> <TAB> + + port_allocFailures ; <NEW_LINE> <TAB> PORT_Free ( pool ) ; <NEW_LINE> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> PL_InitArenaPool ( & pool -> arena , "security" , chunksize , sizeof ( double ) ) ; <NEW_LINE> <TAB> return ( & pool -> arena ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #define MAX_SIZE 0x7fffffffUL <NEW_LINE><NEW_LINE> <END_VULN> void * <NEW_LINE> PORT_ArenaAlloc ( PLArenaPool * arena , size_t size ) <NEW_LINE> { <NEW_LINE> <TAB> void * p = NULL ; <NEW_LINE> <TAB> PORTArenaPool * pool = ( PORTArenaPool * ) arena ; <NEW_LINE> <TAB> if ( size <= 0 ) {
<TAB> <TAB> INIT_LIST_HEAD ( & tasks ) ; <NEW_LINE> <TAB> <TAB> do_smart_update ( sma , NULL , 0 , 1 , & tasks ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> sem_unlock ( sma ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> wake_up_sem_queue_do ( & tasks ) ; <NEW_LINE> <TAB> <TAB> kfree_rcu ( un , rcu ) ;
<TAB> <TAB> ipaddr_string ( ndo , & ps -> page . p_sid ) , <NEW_LINE> <TAB> <TAB> EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; <NEW_LINE> <TAB> <TAB> io = ( struct id_off * ) ( ps + 1 ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> for ( ie = io + ps -> nid ; io < ie && ! ND_TTEST ( * io ) ; + + io ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ND_PRINT ( ( ndo , " % c % s : % u" , c , ipaddr_string ( ndo , & io -> id ) , <NEW_LINE> <TAB> <TAB> <TAB> EXTRACT_32BITS ( & io -> off ) ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> c = ' , ' ;
<START_VULN> PHPAPI void php_clear_stat_cache ( zend_bool clear_realpath_cache , const char * filename , int filename_len ) <NEW_LINE> <END_VULN> {
inline <NEW_LINE> CompilerOutput : : CompilerOutput ( ) <NEW_LINE> : script ( NULL ) , <NEW_LINE> <START_VULN> <TAB> kindInt ( Ion ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> inline ion : : IonScript * <NEW_LINE> CompilerOutput : : ion ( ) const <NEW_LINE> { <NEW_LINE> #ifdef JS_ION <NEW_LINE> <TAB> JS_ASSERT ( isValid ( ) ) ;
<TAB> fprintf ( stdout , "\n\nThe script contains errors . . . \n\n" ) ; <NEW_LINE> <START_VULN> if ( write_output ( ) != E_SUCCESS ) <NEW_LINE><TAB> FATAL_ERROR ( "Cannot write output file ( % s ) " , EF_GBL_OPTIONS -> output_file ) ; <NEW_LINE> <END_VULN> <TAB> ef_globals_free ( ) ; <NEW_LINE> <TAB> return 0 ; <NEW_LINE> }
<TAB> <TAB> <TAB> <TAB> ubits -- ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( ubits < vbits ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> i = ubits ;
* <NEW_LINE> <START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 89 ) <NEW_LINE> <END_VULN> extern JSBool <NEW_LINE> js_XDRAtom ( JSXDRState * xdr , JSAtom ** atomp ) ; <NEW_LINE> JS_END_EXTERN_C
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #ifndef __nss_h_ <NEW_LINE> #define __nss_h_ <NEW_LINE> #ifdef NSS_ENABLE_ECC <NEW_LINE> #ifdef NSS_ECC_MORE_THAN_SUITE_B <NEW_LINE> #define _NSS_ECC_STRING " Extended ECC"
<TAB> <TAB> <TAB> <TAB> enqueue_goaway ( conn , ( int ) ret , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> err_desc != NULL ? ( h2o_iovec_t ) { ( char * ) err_desc , strlen ( err_desc ) } : ( h2o_iovec_t ) { } ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> close_connection ( conn ) ; <NEW_LINE><TAB> <TAB> <TAB> return ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> h2o_buffer_consume ( & conn -> sock -> input , ret ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : random psychoacoustics ( not including preecho ) <NEW_LINE> <START_VULN> last mod : $ Id : psy . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_PSY_H_ <NEW_LINE> #define _V_PSY_H_ <NEW_LINE> #include "smallft . h" <NEW_LINE> #include "backends . h"
<TAB> set_task_ioprio ( sbi -> s_journal -> j_task , journal_ioprio ) ; <NEW_LINE> no_journal : <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> if ( test_opt ( sb , NOBH ) ) { <NEW_LINE> <TAB> <TAB> if ( ! ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_WRITEBACK_DATA ) ) { <NEW_LINE> <TAB> <TAB> <TAB> ext4_msg ( sb , KERN_WARNING , "Ignoring nobh option - " <NEW_LINE> <TAB> <TAB> <TAB> <TAB> "its supported only with writeback mode" ) ; <NEW_LINE> <TAB> <TAB> <TAB> clear_opt ( sbi -> s_mount_opt , NOBH ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> EXT4_SB ( sb ) -> dio_unwritten_wq = create_workqueue ( "ext4 - dio - unwritten" ) ; <NEW_LINE> <TAB> if ( ! EXT4_SB ( sb ) -> dio_unwritten_wq ) {
<TAB> <TAB> return PTR_ERR ( path ) ; <NEW_LINE> <TAB> if ( map -> m_lblk >= ee_block ) { <NEW_LINE> <START_VULN> <TAB> <TAB> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <NEW_LINE><TAB> <TAB> <TAB> EXT4_EXT_MAY_ZEROOUT : 0 ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( uninitialized ) <NEW_LINE> <TAB> <TAB> <TAB> split_flag1 |= EXT4_EXT_MARK_UNINIT1 ; <NEW_LINE> <TAB> <TAB> if ( split_flag & EXT4_EXT_MARK_UNINIT2 )
<TAB> <TAB> _analysis_output ( "mask0" , seq , logmask , n / 2 , 1 , 0 , 0 ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> #endif <NEW_LINE> <TAB> <TAB> floor_posts [ i ] [ 0 ] = <NEW_LINE> <TAB> <TAB> floor1_fit ( vb , b -> flr [ info -> floorsubmap [ submap ] ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> logmdct , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> logmask ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> for ( k = 1 ; k < PACKETBLOBS / 2 ; k + + ) <NEW_LINE> <TAB> <TAB> floor_posts [ i ] [ k ] = <NEW_LINE> <TAB> <TAB> <TAB> floor1_interpolate_fit ( vb , b -> flr [ info -> floorsubmap [ submap ] ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> floor_posts [ i ] [ 0 ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> floor_posts [ i ] [ PACKETBLOBS / 2 ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> k * 65536 / ( PACKETBLOBS / 2 ) ) ;
<TAB> <TAB> TFunctionSign3 , <NEW_LINE> <TAB> <TAB> TFunctionSign4 , <NEW_LINE> <TAB> <TAB> TFunctionUnknown <NEW_LINE> <TAB> } ; <NEW_LINE> <TAB> TBuiltInFunction IdentifyFunction ( TOperator op , const TType & returnType ) ; <NEW_LINE> <START_VULN> <TAB> TVector < TBuiltInFunction > mFunctions ; <NEW_LINE> <END_VULN> <TAB> unsigned int mFunctionGroupMask ; <NEW_LINE> } ; <NEW_LINE> #endif
<TAB> inline JSBool GetStaticMemberIsLocal ( ) const ; <NEW_LINE> <TAB> inline unsigned GetArgc ( ) const ; <NEW_LINE> <TAB> inline jsval * GetArgv ( ) const ; <NEW_LINE> <TAB> inline jsval * GetRetVal ( ) const ; <NEW_LINE> <TAB> inline uint16_t GetMethodIndex ( ) const ; <NEW_LINE> <TAB> inline void SetMethodIndex ( uint16_t index ) ; <NEW_LINE> <START_VULN> <TAB> inline JSBool GetDestroyJSContextInDestructor ( ) const ; <NEW_LINE><TAB> inline void SetDestroyJSContextInDestructor ( JSBool b ) ; <NEW_LINE> <END_VULN> <TAB> inline jsid GetResolveName ( ) const ; <NEW_LINE> <TAB> inline jsid SetResolveName ( JS : : HandleId name ) ; <NEW_LINE> <TAB> inline XPCWrappedNative * GetResolvingWrapper ( ) const ; <NEW_LINE> <TAB> inline XPCWrappedNative * SetResolvingWrapper ( XPCWrappedNative * w ) ; <NEW_LINE> <TAB> inline void SetRetVal ( jsval val ) ;
<TAB> <TAB> <TAB> <TAB> while ( ar -- > 0 && cp && cp < end ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> zval * retval = NULL ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> cp = php_parserr ( cp , & answer , DNS_T_ANY , 1 , raw , & retval ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> if ( retval != NULL ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> add_next_index_zval ( addtl , retval ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> }
friend struct nsTreeRange ; <NEW_LINE> protected : <NEW_LINE> nsresult FireOnSelectHandler ( ) ; <NEW_LINE> static void SelectCallback ( nsITimer * aTimer , void * aClosure ) ; <NEW_LINE> protected : <NEW_LINE> <START_VULN> nsITreeBoxObject * mTree ; <NEW_LINE> <END_VULN> PRBool mSuppressed ; <NEW_LINE> PRInt32 mCurrentIndex ; <NEW_LINE> nsCOMPtr < nsITreeColumn > mCurrentColumn ; <NEW_LINE> PRInt32 mShiftSelectPivot ; <NEW_LINE> nsTreeRange * mFirstRange ;
<TAB> { <NEW_LINE> <TAB> c = XBMInteger ( image , hex_digits ) ; <NEW_LINE> <TAB> if ( c < 0 ) <NEW_LINE> <START_VULN> <TAB> <TAB> break ; <NEW_LINE> <END_VULN> <TAB> * p + += ( unsigned char ) c ; <NEW_LINE> <TAB> } <NEW_LINE> if ( EOFBlob ( image ) != MagickFalse )
<TAB> <TAB> ASSERT ( ( entry -> flags & XFS_ATTR_LOCAL ) == 0 ) ; <NEW_LINE> <TAB> <TAB> name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; <NEW_LINE> <TAB> <TAB> name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> xfs_trans_log_buf ( args -> trans , bp , <NEW_LINE> <TAB> <TAB> <TAB> XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ; <NEW_LINE> <TAB> }
<TAB> <TAB> call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , tree , & phdr ) ; <NEW_LINE> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> dissector_try_uint ( wtap_encap_dissector_table , <NEW_LINE><TAB> <TAB> <TAB> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> }
<TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( bits == 32 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> for ( i = 0 ; i < sec -> size ; i += 4 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> ut32 addr32 = r_read_le32 ( buf + i ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> if ( addr32 ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ;
<TAB> len -- ; <NEW_LINE> <TAB> int l = 0 ; <NEW_LINE> <START_VULN> <TAB> while ( * s && l < len ) { <NEW_LINE> <END_VULN> <TAB> str [ l ] = s [ l ] ; <NEW_LINE> <TAB> l + + ; <NEW_LINE> <TAB> }
static uint32_t <NEW_LINE> sanityCheck ( const uint8_t * woffData , uint32_t woffLen ) <NEW_LINE> { <NEW_LINE> const woffHeader * header ; <NEW_LINE> uint16_t numTables , i ; <NEW_LINE> const woffDirEntry * dirEntry ; <NEW_LINE> <START_VULN> uint32_t tableTotal = 0 ; <NEW_LINE> <END_VULN> if ( ! woffData || ! woffLen ) { <NEW_LINE> <TAB> return eWOFF_bad_parameter ; <NEW_LINE> } <NEW_LINE> if ( woffLen < sizeof ( woffHeader ) ) { <NEW_LINE> <TAB> return eWOFF_invalid ; <NEW_LINE> }
<TAB> struct ipv6_opt_hdr <TAB> * dst0opt ; <NEW_LINE> <TAB> struct ipv6_rt_hdr <TAB> * srcrt ; <TAB> <NEW_LINE> <TAB> struct ipv6_opt_hdr <TAB> * dst1opt ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> } ;
void * jas_realloc ( void * ptr , size_t size ) <NEW_LINE> { <NEW_LINE> <TAB> void * result ; <NEW_LINE> <START_VULN> <TAB> JAS_DBGLOG ( 101 , ( "jas_realloc called with % x , % zu\n" , ptr , size ) ) ; <NEW_LINE> <END_VULN> <TAB> result = realloc ( ptr , size ) ; <NEW_LINE> <TAB> JAS_DBGLOG ( 100 , ( "jas_realloc ( % p , % zu ) -> % p\n" , ptr , size , result ) ) ; <NEW_LINE> <TAB> return result ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Cast6 Cipher Algorithm" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "cast6" ) ; <NEW_LINE> <END_VULN>
share -> kfile = - 1 ; <NEW_LINE> ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ; <NEW_LINE> if ( change_to_newfile ( share -> index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> MYF ( 0 ) ) || <NEW_LINE> <END_VULN> <TAB> mi_open_keyfile ( share ) ) <NEW_LINE> <TAB> goto err2 ; <NEW_LINE> info -> lock_type = F_UNLCK ; <TAB> <TAB> <TAB>
<TAB> <TAB> . index_key . type <TAB> <TAB> = & key_type_request_key_auth , <NEW_LINE> <TAB> <TAB> . index_key . description <TAB> = description , <NEW_LINE> <TAB> <TAB> . cred <TAB> <TAB> <TAB> = current_cred ( ) , <NEW_LINE> <START_VULN> <TAB> <TAB> . match_data . cmp <TAB> <TAB> = user_match , <NEW_LINE> <END_VULN> <TAB> <TAB> . match_data . raw_data <TAB> = description , <NEW_LINE> <TAB> <TAB> . match_data . lookup_type <TAB> = KEYRING_SEARCH_LOOKUP_DIRECT , <NEW_LINE> <TAB> } ;
<TAB> struct proc_maps_private * priv = m -> private ; <NEW_LINE> <TAB> struct vm_area_struct * vma = v ; <NEW_LINE> <START_VULN> <TAB> vma_stop ( priv , vma ) ; <NEW_LINE> <END_VULN> <TAB> if ( priv -> task ) <NEW_LINE> <TAB> <TAB> put_task_struct ( priv -> task ) ; <NEW_LINE> }
<START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 85 ) <NEW_LINE> <END_VULN>
<TAB> return true ; <NEW_LINE> if ( ( uint64_t ) capacity * elemSize > size_type ( - 1 ) / 2 ) { <NEW_LINE> <START_VULN> <TAB> NS_ERROR ( "Attempting to allocate excessively large array" ) ; <NEW_LINE> <END_VULN> <TAB> return false ; <NEW_LINE> } <NEW_LINE> if ( mHdr == EmptyHdr ( ) ) { <NEW_LINE> <TAB> Header * header = static_cast < Header * > <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> ( Alloc : : Malloc ( sizeof ( Header ) + capacity * elemSize ) ) ; <NEW_LINE> <TAB> if ( ! header )
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Cast5 Cipher Algorithm" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "cast5" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> <TAB> gss_ctx_id_t context_handle , gss_qop_t qop_req , <NEW_LINE> <TAB> <TAB> <TAB> gss_iov_buffer_desc * iov , int iov_count ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return gss_get_mic_iov_length ( minor_status , context_handle , qop_req , iov , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> iov_count ) ; <NEW_LINE> }
<TAB> if ( task -> mm ) <NEW_LINE> <TAB> <TAB> dumpable = get_dumpable ( task -> mm ) ; <NEW_LINE> <TAB> rcu_read_lock ( ) ; <NEW_LINE> <START_VULN> <TAB> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> rcu_read_unlock ( ) ; <NEW_LINE> <TAB> <TAB> return - EPERM ; <NEW_LINE> <TAB> }
<START_VULN> struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct nfs_inode * nfsi = NFS_I ( inode ) ; <NEW_LINE> <TAB> struct nfs_open_context * pos , * ctx = NULL ;
new_tvb = tvb_new_subset ( tvb , offset , caplen , len ) ; <NEW_LINE> if ( decode_content && linktype != WTAP_ENCAP_UNKNOWN ) { <NEW_LINE> <START_VULN> <TAB> dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! info_added ) {
<TAB> int aligned_height ; <NEW_LINE> <TAB> if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { <NEW_LINE> <START_VULN> <TAB> <TAB> c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; <NEW_LINE><TAB> <TAB> aligned_height = FFALIGN ( c -> height , 16 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> av_free ( c -> framebuf ) ; <NEW_LINE> <TAB> <TAB> c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; <NEW_LINE> <TAB> <TAB> if ( ! c -> framebuf )
{ <NEW_LINE> <TAB> nsRefPtr < AccEvent > event = <NEW_LINE> <TAB> new AccTextChangeEvent ( mHyperText , mTextOffset + aAddlOffset , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> aText , PR_FALSE ) ; <NEW_LINE> <TAB> aEvents . AppendElement ( event ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void UpdateTextNFireEvent ( const nsAString & aNewText , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsAString & aChangeText , PRUint32 aAddlOffset , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRBool aIsInserted ) ; <NEW_LINE> <END_VULN> private : <NEW_LINE> nsDocAccessible * mDocument ; <NEW_LINE> nsTextAccessible * mTextLeaf ; <NEW_LINE> nsHyperTextAccessible * mHyperText ; <NEW_LINE> PRInt32 mTextOffset ; <NEW_LINE> } ;
<TAB> char * password = * passptr ; <NEW_LINE> <START_VULN> <TAB> if ( ! ( mask & KADM5_ATTRIBUTES ) || <NEW_LINE> <END_VULN> <TAB> <TAB> ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) <NEW_LINE> <TAB> <TAB> return ;
<TAB> . release <TAB> = ext2_release_file , <NEW_LINE> <TAB> . fsync <TAB> <TAB> = ext2_fsync , <NEW_LINE> <TAB> . splice_read <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> } ; <NEW_LINE> #ifdef CONFIG_EXT2_FS_XIP
<TAB> } <NEW_LINE> <TAB> <TAB> for ( ; num ; num -- ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( pread ( fd , xph_addr , xph_sizeof , off ) == - 1 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> file_badread ( ms ) ; <NEW_LINE> <TAB> <TAB> <TAB> return - 1 ; <NEW_LINE> <TAB> <TAB> }
* <TAB> If the given username exists in the passwd file , the entry is <NEW_LINE> * <TAB> replaced with the given entry . <NEW_LINE> <START_VULN> int setpwnam ( struct passwd * pwd ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> FILE * fp = NULL , * pwf = NULL ; <NEW_LINE> <TAB> int save_errno ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Camellia Cipher Algorithm , AES - NI / AVX2 optimized" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "camellia" ) ; <NEW_LINE>MODULE_ALIAS ( "camellia - asm" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> rep9 -> choice == choice_pa_pk_as_rep_draft9_dhSignedData ) || <NEW_LINE> <TAB> <TAB> ( rep != NULL && rep -> choice == choice_pa_pk_as_rep_dhInfo ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE><TAB> <TAB> if ( rep -> u . dh_Info . kdfID ) { <NEW_LINE><TAB> <TAB> <TAB> secret . data = server_key ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> secret . length = server_key_len ; <NEW_LINE> <TAB> <TAB> <TAB> retval = pkinit_alg_agility_kdf ( context , & secret ,
{ <NEW_LINE> <TAB> int i ; <NEW_LINE> <TAB> for ( i = 0 ; i <= 31 ; i + + ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( x & ( 1 << i ) ) return i ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return 0 ; <NEW_LINE> }
<TAB> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> ret = snprintf ( dest , len , " % s / lock / lxc / % s" , rundir , p ) ; <NEW_LINE> <END_VULN> <TAB> if ( ret < 0 || ret >= len ) { <NEW_LINE> <TAB> <TAB> free ( dest ) ; <NEW_LINE> <TAB> <TAB> free ( rundir ) ;
<TAB> <TAB> if ( match_kern ) <NEW_LINE> <TAB> <TAB> <TAB> match_kern -> match_size = ret ; <NEW_LINE> <START_VULN> <TAB> <TAB> WARN_ON ( type == EBT_COMPAT_TARGET && size_left ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> match32 = ( struct compat_ebt_entry_mwt * ) buf ; <NEW_LINE> <TAB> }
<TAB> int err ; <NEW_LINE> <TAB> if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || <NEW_LINE> <START_VULN> <TAB> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) { <NEW_LINE> <END_VULN> <TAB> <TAB> duprintf ( "Bad offset % p\n" , e ) ; <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> ao2_unlock ( peer ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ! peer && sip_cfg . alwaysauthreject ) { <NEW_LINE> <END_VULN> <TAB> <TAB> transmit_response ( p , "100 Trying" , req ) ;
SVGPointList & InternalList ( ) const ; <NEW_LINE> SVGAnimatedPointList & InternalAList ( ) const ; <NEW_LINE> <START_VULN> void EnsureItemAt ( uint32_t aIndex ) ; <NEW_LINE> <END_VULN> void MaybeInsertNullInAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> void MaybeRemoveItemFromAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> FallibleTArray < nsISVGPoint * > mItems ;
void UpdateCueDisplay ( ) ; <NEW_LINE> void PopulatePendingList ( ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> <NEW_LINE><TAB> <NEW_LINE>HTMLMediaElement * mMediaElement ; <NEW_LINE> <END_VULN> private : <NEW_LINE> nsRefPtr < TextTrackList > mTextTracks ; <NEW_LINE> nsRefPtr < TextTrackList > mPendingTextTracks ; <NEW_LINE> nsRefPtr < TextTrackCueList > mNewCues ;
<TAB> <TAB> fh -> nexthdr = nexthdr ; <NEW_LINE> <TAB> <TAB> fh -> reserved = 0 ; <NEW_LINE> <TAB> <TAB> if ( ! frag_id ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> ipv6_select_ident ( fh ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> frag_id = fh -> identification ; <NEW_LINE> <TAB> <TAB> } else <NEW_LINE> <TAB> <TAB> <TAB> fh -> identification = frag_id ;
<TAB> <TAB> <TAB> h -> is_streamed = 0 ; <NEW_LINE> <TAB> <TAB> } else if ( ! av_strcasecmp ( tag , "Transfer - Encoding" ) && <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> ! av_strncasecmp ( p , "chunked" , 7 ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> s -> filesize = - 1 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> s -> chunksize = 0 ; <NEW_LINE> <TAB> <TAB> } else if ( ! av_strcasecmp ( tag , "WWW - Authenticate" ) ) { <NEW_LINE> <TAB> <TAB> <TAB> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ;
<TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ! npages ) { <NEW_LINE> <END_VULN> <TAB> <TAB> struct kvm_memory_slot * slot ; <NEW_LINE> <TAB> <TAB> r = - ENOMEM ;
MODULE_AUTHOR ( "Clay Haapala < chaapala@cisco . com > " ) ; <NEW_LINE> MODULE_DESCRIPTION ( "CRC32c ( Castagnoli ) calculations wrapper for lib / crc32c" ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "crc32c" ) ; <NEW_LINE> <END_VULN> MODULE_SOFTDEP ( "pre : crc32c" ) ;
<START_VULN> <TAB> Packet * p = BuildTestPacket ( 99 , 0 , 1 , 'A' + i , 16 ) ; <NEW_LINE> <END_VULN> <TAB> if ( p == NULL ) <NEW_LINE> <TAB> <TAB> goto end ;
<TAB> <TAB> case 2 : <NEW_LINE> <TAB> <TAB> <TAB> data16 = get_unaligned_le16 ( & report [ i ] ) ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <START_VULN> <TAB> <TAB> case 3 : <NEW_LINE><TAB> <TAB> <TAB> size = 4 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> data32 = get_unaligned_le32 ( & report [ i ] ) ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const char * aPropertyName , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const char * anInterfaceName , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRBool aForceReport ) ; <NEW_LINE> private : <NEW_LINE> <TAB> nsXPCWrappedJSClass ( ) ; <NEW_LINE> <TAB> nsXPCWrappedJSClass ( XPCCallContext & ccx , REFNSIID aIID , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIInterfaceInfo * aInfo ) ; <NEW_LINE> <START_VULN> <TAB> JSObject * NewOutObject ( JSContext * cx ) ; <NEW_LINE> <END_VULN> <TAB> JSBool IsReflectable ( uint16 i ) const <NEW_LINE> <TAB> <TAB> { return ( JSBool ) ( mDescriptors [ i / 32 ] & ( 1 << ( i % 32 ) ) ) ; } <NEW_LINE> <TAB> void SetReflectable ( uint16 i , JSBool b ) <NEW_LINE> <TAB> <TAB> { if ( b ) mDescriptors [ i / 32 ] |= ( 1 << ( i % 32 ) ) ; <NEW_LINE> <TAB> <TAB> else mDescriptors [ i / 32 ] &= ~ ( 1 << ( i % 32 ) ) ; } <NEW_LINE> <TAB> enum SizeMode { GET_SIZE , GET_LENGTH } ;
<TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> cupsdSetString ( & attr -> values [ 1 ] . string . text , attr -> values [ 0 ] . string . text ) ; <NEW_LINE> <END_VULN> <TAB> cupsdLogJob ( job , CUPSD_LOG_NOTICE , "CLASSIFICATION FORCED " <NEW_LINE> <TAB> <TAB> <TAB> "job - sheets = \" % s , % s\" , "
<TAB> * result_len = 0 ; <NEW_LINE> <TAB> start_offset = 0 ; <NEW_LINE> <TAB> PCRE_G ( error_code ) = PHP_PCRE_NO_ERROR ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> while ( 1 ) { <NEW_LINE> <TAB> <TAB> count = pcre_exec ( pce -> re , extra , subject , subject_len , start_offset ,
static int hns_xgmac_get_sset_count ( int stringset ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( stringset == ETH_SS_STATS ) <NEW_LINE> <END_VULN> <TAB> <TAB> return ARRAY_SIZE ( g_xgmac_stats_string ) ; <NEW_LINE> <TAB> return 0 ;
<TAB> <TAB> enqueue_huge_page ( h , page ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> spin_unlock ( & hugetlb_lock ) ; <NEW_LINE> <START_VULN> <TAB> if ( mapping ) <NEW_LINE><TAB> <TAB> hugetlb_put_quota ( mapping , 1 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void prep_new_huge_page ( struct hstate * h , struct page * page , int nid )
<TAB> <TAB> <TAB> <TAB> <TAB> public nsIDOMEventTarget , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIDOM3EventTarget , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIDOMNSEventTarget , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIScriptObjectPrincipal , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIRadioGroupContainer , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIDOMNodeSelector , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIApplicationCacheContainer , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> public nsIDOMXPathNSResolver , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> public nsStubMutationObserver <NEW_LINE> <END_VULN> { <NEW_LINE> public : <NEW_LINE> NS_DECL_CYCLE_COLLECTING_ISUPPORTS <NEW_LINE> virtual void Reset ( nsIChannel * aChannel , nsILoadGroup * aLoadGroup ) ; <NEW_LINE> virtual void ResetToURI ( nsIURI * aURI , nsILoadGroup * aLoadGroup , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIPrincipal * aPrincipal ) ;
uint32_t GetListBaseExpandoSlot ( ) ; <NEW_LINE> extern JS_FRIEND_API ( bool ) <NEW_LINE> IsReadOnlyDateMethod ( JS : : IsAcceptableThis test , JS : : NativeImpl method ) ; <NEW_LINE> extern JS_FRIEND_API ( bool ) <NEW_LINE> IsTypedArrayThisCheck ( JS : : IsAcceptableThis test ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE>extern JSBool <NEW_LINE>DefaultValue ( JSContext * cx , HandleObject obj , JSType hint , MutableHandleValue vp ) ; <NEW_LINE><NEW_LINE> <END_VULN> extern Class ArrayClass ; <NEW_LINE> extern Class ArrayBufferClass ; <NEW_LINE> extern Class BlockClass ; <NEW_LINE> extern Class BooleanClass ; <NEW_LINE> extern Class CallableObjectClass ; <NEW_LINE> extern Class DataViewClass ; <NEW_LINE> extern Class DateClass ; <NEW_LINE> extern Class ErrorClass ;
<TAB> cli_md5_update ( & md5 , & v , 4 ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> cli_md5_final ( result , & md5 ) ; <NEW_LINE> <TAB> if ( R >= 3 ) { <NEW_LINE> <START_VULN> <TAB> if ( length > 128 ) <NEW_LINE><TAB> <TAB> length = 128 ; <NEW_LINE> <END_VULN> <TAB> for ( i = 0 ; i < 50 ; i + + ) { <NEW_LINE> <TAB> <TAB> cli_md5_init ( & md5 ) ; <NEW_LINE> <TAB> <TAB> cli_md5_update ( & md5 , result , length / 8 ) ;
<START_VULN> <TAB> if ( sbi -> s_journal && ! handle ) <NEW_LINE> <END_VULN> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> err = ext4_reserve_inode_write ( handle , inode , & iloc ) ;
<TAB> <TAB> hwc -> event_base <TAB> = 0 ; <NEW_LINE> <TAB> } else if ( hwc -> idx >= X86_PMC_IDX_FIXED ) { <NEW_LINE> <TAB> <TAB> hwc -> config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL ; <NEW_LINE> <START_VULN> <TAB> <TAB> hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ; <NEW_LINE> <END_VULN> <TAB> } else { <NEW_LINE> <TAB> <TAB> hwc -> config_base = x86_pmu_config_addr ( hwc -> idx ) ; <NEW_LINE> <TAB> <TAB> hwc -> event_base = x86_pmu_event_addr ( hwc -> idx ) ;
{ <NEW_LINE> <TAB> struct sk_buff * skb ; <NEW_LINE> <TAB> int err ; <NEW_LINE> <TAB> if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { <NEW_LINE> <START_VULN> <TAB> <TAB> struct frag_hdr fhdr ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> <TAB> skb = sock_alloc_send_skb ( sk , <NEW_LINE> <TAB> <TAB> <TAB> hh_len + fragheaderlen + transhdrlen + 20 , <NEW_LINE> <TAB> <TAB> <TAB> ( flags & MSG_DONTWAIT ) , & err ) ;
<TAB> if ( ! is_irq_none ( vdev ) ) <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <START_VULN> <TAB> vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! vdev -> ctx ) <NEW_LINE> <TAB> <TAB> return - ENOMEM ;
<TAB> mParent = aTarget ; <NEW_LINE> } <NEW_LINE> virtual nsIDOMEventTarget * GetParentTarget ( ) { return mParent ; } <NEW_LINE> NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS ( nsWindowRoot , nsIDOMEventTarget ) <NEW_LINE> protected : <NEW_LINE> <START_VULN> nsPIDOMWindow * mWindow ; <NEW_LINE> <END_VULN> nsRefPtr < nsEventListenerManager > mListenerManager ; <NEW_LINE> nsCOMPtr < nsIDOMNode > mPopupNode ; <NEW_LINE> nsCOMPtr < nsIDOMEventTarget > mParent ; <NEW_LINE> } ;
<TAB> unsigned int address , destreg , data , type ; <NEW_LINE> <TAB> unsigned int res = 0 ; <NEW_LINE> <START_VULN> <TAB> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <NEW_LINE> <END_VULN> <TAB> if ( current -> pid != previous_pid ) { <NEW_LINE> <TAB> <TAB> pr_debug ( "\" % s\" ( % ld ) uses deprecated SWP { B } instruction\n" ,
<TAB> s -> line_count = 0 ; <NEW_LINE> <TAB> s -> off = 0 ; <NEW_LINE> <TAB> s -> icy_data_read = 0 ; <NEW_LINE> <START_VULN> <TAB> s -> filesize = - 1 ; <NEW_LINE> <END_VULN> <TAB> s -> willclose = 0 ; <NEW_LINE> <TAB> s -> end_chunked_post = 0 ; <NEW_LINE> <TAB> s -> end_header = 0 ;
<TAB> } <NEW_LINE> <TAB> update_idle_timeout ( conn ) ; <NEW_LINE> <START_VULN> <TAB> parse_input ( conn ) ; <NEW_LINE> <END_VULN> <TAB> if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) {
<TAB> <TAB> <TAB> free ( rp ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> pid_t child = fork ( ) ; <NEW_LINE><TAB> <TAB> if ( child < 0 ) <NEW_LINE><TAB> <TAB> <TAB> errExit ( "fork" ) ; <NEW_LINE><TAB> <TAB> if ( child == 0 ) { <NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> drop_privs ( 0 ) ; <NEW_LINE><TAB> <NEW_LINE><TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ; <NEW_LINE><TAB> <TAB> <TAB> if ( rv ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> fprintf ( stderr , "Warning : cannot transfer . asoundrc in private home directory\n" ) ; <NEW_LINE><TAB> <TAB> <TAB> else { <NEW_LINE><TAB> <TAB> <TAB> <TAB> fs_logger2 ( "clone" , dest ) ; <NEW_LINE><TAB> <TAB> <TAB> } <NEW_LINE><TAB> <TAB> <TAB> _exit ( 0 ) ; <NEW_LINE><TAB> <TAB> } <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> waitpid ( child , NULL , 0 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> return 1 ; <NEW_LINE> <TAB> }
<TAB> if ( useService ) { <NEW_LINE> <TAB> <TAB> WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; <NEW_LINE> <TAB> <TAB> if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> HKEY baseKey ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> maintenanceServiceKey , 0 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> KEY_READ | KEY_WOW64_64KEY ,
<TAB> <TAB> if ( int ( mDepthAttachment . IsNull ( ) ) + <NEW_LINE> <TAB> <TAB> <TAB> int ( mStencilAttachment . IsNull ( ) ) + <NEW_LINE> <TAB> <TAB> <TAB> int ( mDepthStencilAttachment . IsNull ( ) ) <= 1 ) <NEW_LINE> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> return PR_TRUE ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> <TAB> else return PR_FALSE ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> const WebGLFramebufferAttachment & ColorAttachment ( ) const { <NEW_LINE> <TAB> <TAB> return mColorAttachment ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> const WebGLFramebufferAttachment & DepthAttachment ( ) const {
<TAB> <TAB> <TAB> return bh ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> brelse ( bh ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> return NULL ; <NEW_LINE> }
<TAB> <TAB> } <NEW_LINE> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ; <NEW_LINE> <TAB> <TAB> <TAB> int hsub = plane == 1 || plane == 2 ? s -> hsub : 0 ; <NEW_LINE> <TAB> <TAB> <TAB> int h = FF_CEIL_RSHIFT ( inlink -> h , vsub ) ;
typedef double iw_tmpsample ; <NEW_LINE> #ifdef IW_64BIT <NEW_LINE> <START_VULN> #define IW_DEFAULT_MAX_DIMENSION 1000000 <NEW_LINE>#define IW_DEFAULT_MAX_MALLOC 2000000000000 <NEW_LINE> <END_VULN> #else <NEW_LINE> #define IW_DEFAULT_MAX_DIMENSION 40000 <NEW_LINE> #define IW_DEFAULT_MAX_MALLOC 2000000000 <NEW_LINE> commit 86564051db45b466e5f667111ce00b5eeedc8fb6 <NEW_LINE> Author : Jason Summers < jason1@pobox . com > <NEW_LINE> Date : Wed Apr 12 10 : 54 : 31 2017 - 0400 <NEW_LINE> <TAB> Reduced the max memory use and image size in 64 - bit builds <NEW_LINE> <TAB> This is a stopgap measure that should prevent some problems with excessive <NEW_LINE> <TAB> resource use , and possibly integer overflow . <NEW_LINE> <TAB> Related : issue #14
} <NEW_LINE> <START_VULN> static void phar_file_stat ( const char * filename , php_stat_len filename_length , int type , void ( * orig_stat_func ) ( INTERNAL_FUNCTION_PARAMETERS ) , INTERNAL_FUNCTION_PARAMETERS ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> if ( ! filename_length ) { <NEW_LINE> <TAB> <TAB> RETURN_FALSE ;
<TAB> FD_ZERO ( & writefds ) ; <NEW_LINE> <TAB> FD_ZERO ( & exceptfds ) ; <NEW_LINE> <START_VULN> <TAB> curl_multi_fdset ( mh -> multi , & readfds , & writefds , & exceptfds , & maxfd ) ; <NEW_LINE> <END_VULN> <TAB> if ( maxfd == - 1 ) { <NEW_LINE> <TAB> <TAB> RETURN_LONG ( - 1 ) ; <NEW_LINE> <TAB> }
#define SMKTREE_BITS 9 <NEW_LINE> #define SMK_NODE 0x80000000 <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> typedef struct SmackVContext { <NEW_LINE> <TAB> AVCodecContext * avctx ;
<TAB> <TAB> <TAB> <TAB> } else <NEW_LINE> #endif <NEW_LINE> <TAB> <TAB> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> NEED_OP ( t ) ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> NEED_IP ( t + 3 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> do { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> * op + + = * ip + + ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> } while ( -- t > 0 ) ;
<TAB> <TAB> <TAB> path_end = memchr ( path_ptr , '\0' , buffer_size ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( path_end == NULL ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> return 0 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> path_length = path_end - path_ptr ; <NEW_LINE> <TAB> <TAB> }
char * path_name ( struct strbuf * path , const char * name ) ; <NEW_LINE> <START_VULN> extern void show_object_with_name ( FILE * , struct object * , <NEW_LINE><TAB> <TAB> <TAB> <TAB> struct strbuf * , const char * ) ; <NEW_LINE> <END_VULN> extern void add_pending_object ( struct rev_info * revs , <NEW_LINE> <TAB> <TAB> <TAB> struct object * obj , const char * name ) ;
<START_VULN> <TAB> <TAB> if ( parent_len + np -> mb_len > 240 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , <NEW_LINE> <TAB> <TAB> <TAB> "The regulation of Joliet extensions ; " <NEW_LINE> <TAB> <TAB> <TAB> " A length of a full - pathname of ` % s' is "
vorbis_info * vi = v -> vi ; <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> int hs = ci -> halfrate_flag ; <NEW_LINE> private_state * b = v -> backend_state ; <NEW_LINE> if ( b -> window [ W ] - 1 < 0 ) return NULL ; <NEW_LINE> return _vorbis_window_get ( b -> window [ W ] - hs ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN>
CVE_2013_0797_AutoLoadSystemDependencies ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> static LPCWSTR delayDLLs [ ] = { L"wsock32 . dll" , L"crypt32 . dll" } ; <NEW_LINE> <END_VULN> <TAB> WCHAR systemDirectory [ MAX_PATH + 1 ] = { L'\0' } ;
static nsresult Startup ( ) ; <NEW_LINE> static void Shutdown ( ) ; <NEW_LINE> friend class TimerThread ; <NEW_LINE> friend struct TimerAdditionComparator ; <NEW_LINE> void Fire ( ) ; <NEW_LINE> <START_VULN> nsresult PostTimerEvent ( ) ; <NEW_LINE> <END_VULN> void SetDelayInternal ( uint32_t aDelay ) ; <NEW_LINE> NS_DECL_THREADSAFE_ISUPPORTS <NEW_LINE> NS_DECL_NSITIMER <NEW_LINE> int32_t GetGeneration ( ) <NEW_LINE> { <NEW_LINE> <TAB> return mGeneration ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> byte_run = - byte_run ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> CHECK_PIXEL_PTR ( byte_run ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> for ( j = 0 ; j < byte_run ; j + + ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> * ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> stream_ptr += 2 ;
<TAB> { <NEW_LINE> <TAB> <TAB> ca_slot_info_t * info = ( ca_slot_info_t * ) parg ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( info -> num > 1 ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> <TAB> av7110 -> ci_slot [ info -> num ] . num = info -> num ; <NEW_LINE> <TAB> <TAB> av7110 -> ci_slot [ info -> num ] . type = FW_CI_LL_SUPPORT ( av7110 -> arm_app ) ?
<TAB> <TAB> umode_t mode = attr -> ia_mode ; <NEW_LINE> <TAB> <TAB> if ( ! in_group_p ( inode -> i_gid ) && <NEW_LINE> <START_VULN> <TAB> <TAB> ! inode_capable ( inode , CAP_FSETID ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> mode &= ~ S_ISGID ; <NEW_LINE> <TAB> <TAB> inode -> i_mode = mode ; <NEW_LINE> <TAB> }
<TAB> STACK_OF ( X509_CRL ) * crls = NULL ; <NEW_LINE> <TAB> X509 * signer ; <NEW_LINE> <TAB> int i , scount = 0 , ret = 0 ; <NEW_LINE> <START_VULN> <TAB> BIO * cmsbio = NULL , * tmpin = NULL ; <NEW_LINE> <END_VULN> <TAB> if ( ! dcont && ! check_content ( cms ) ) <NEW_LINE> <TAB> <TAB> return 0 ;
<TAB> <TAB> perf_sample_data_init ( & data , 0 ) ; <NEW_LINE> <TAB> <TAB> data . period = event -> hw . last_period ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> fsl_emb_pmu_stop ( event , 0 ) ; <NEW_LINE> <TAB> } <NEW_LINE> }
<TAB> <TAB> 0 , NULL , sizeof ( LGEncryptedDataInfo ) } , <NEW_LINE> <TAB> { SEC_ASN1_INLINE | SEC_ASN1_XTRN , <NEW_LINE> <TAB> <TAB> offsetof ( LGEncryptedDataInfo , algorithm ) , <NEW_LINE> <TAB> <TAB> SEC_ASN1_SUB ( SECOID_AlgorithmIDTemplate ) } , <NEW_LINE> <TAB> { SEC_ASN1_OCTET_STRING , <NEW_LINE> <TAB> <TAB> offsetof ( LGEncryptedDataInfo , encryptedData ) } , <NEW_LINE> <TAB> { 0 } <NEW_LINE> } ; <NEW_LINE> <START_VULN> static const unsigned char def_iter_data [ ] = { SEC_ASN1_INTEGER , 0x01 , 0x01 } ; <NEW_LINE>static const SECItem def_iter = { siBuffer , <NEW_LINE><TAB> <TAB> <TAB> <TAB> ( unsigned char * ) def_iter_data , <NEW_LINE><TAB> <TAB> <TAB> <TAB> sizeof ( def_iter_data ) } ; <NEW_LINE> <END_VULN> static SECItem * <NEW_LINE> nsslowkey_EncodePW ( SECOidTag alg , const SECItem * salt , SECItem * data ) <NEW_LINE> { <NEW_LINE> <TAB> NSSLowPasswordDataParam param ; <NEW_LINE> <TAB> LGEncryptedDataInfo edi ; <NEW_LINE> <TAB> PLArenaPool * arena ; <NEW_LINE> <TAB> unsigned char one = 1 ; <NEW_LINE> <TAB> SECItem * epw = NULL ; <NEW_LINE> <TAB> SECItem * encParam ; <NEW_LINE> <TAB> SECStatus rv ; <NEW_LINE> <TAB> param . salt = * salt ; <NEW_LINE> <TAB> param . iter . data = & one ; <NEW_LINE> <TAB> param . iter . len = 1 ; <NEW_LINE> <TAB> edi . encryptedData = * data ; <NEW_LINE> <TAB> arena = PORT_NewArena ( DER_DEFAULT_CHUNKSIZE ) ; <NEW_LINE> <TAB> if ( arena == NULL ) { <NEW_LINE> <TAB> return NULL ; <NEW_LINE> <TAB> }
#define CAFChannelDescriptionFormat "LLLLL" <NEW_LINE> <START_VULN> static const char TMH_full [ ] = { 1 , 2 , 3 , 13 , 9 , 10 , 5 , 6 , 12 , 14 , 15 , 16 , 17 , 9 , 4 , 18 , 7 , 8 , 19 , 20 , 21 } ; <NEW_LINE>static const char TMH_std [ ] = { 1 , 2 , 3 , 11 , 8 , 9 , 5 , 6 , 10 , 12 , 13 , 14 , 15 , 7 , 4 , 16 } ; <NEW_LINE> <END_VULN> static struct { <NEW_LINE> <TAB> uint32_t mChannelLayoutTag ;
int yr_re_fast_exec ( <NEW_LINE> <TAB> uint8_t * re_code , <NEW_LINE> <TAB> uint8_t * input , <NEW_LINE> <START_VULN> <TAB> size_t input_size , <NEW_LINE> <END_VULN> <TAB> int flags , <NEW_LINE> <TAB> RE_MATCH_CALLBACK_FUNC callback , <NEW_LINE> <TAB> void * callback_args ) ;
} ; <NEW_LINE> static struct extra_reg intel_snb_extra_regs [ ] __read_mostly = { <NEW_LINE> <START_VULN> <TAB> INTEL_EVENT_EXTRA_REG ( 0xb7 , MSR_OFFCORE_RSP_0 , 0x3fffffffffull , RSP_0 ) , <NEW_LINE><TAB> INTEL_EVENT_EXTRA_REG ( 0xbb , MSR_OFFCORE_RSP_1 , 0x3fffffffffull , RSP_1 ) , <NEW_LINE> <END_VULN> <TAB> EVENT_EXTRA_END <NEW_LINE> } ;
virtual bool verify_authorizer ( CephContext * cct , KeyStore * keys , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> bufferlist & authorizer_data , bufferlist & authorizer_reply , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> EntityName & entity_name , uint64_t & global_id , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> AuthCapsInfo & caps_info , CryptoKey & session_key , uint64_t * auid = NULL ) = 0 ; <NEW_LINE> <END_VULN> virtual int authorizer_session_crypto ( ) = 0 ; <NEW_LINE> } ;
<TAB> <TAB> <TAB> vA = buf [ 1 ] & 0x0f ; <NEW_LINE> <TAB> <TAB> <TAB> vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; <NEW_LINE> <TAB> <TAB> <TAB> vC = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> snprintf ( str , sizeof ( str ) , " v % i , v % i , 0x % 08"PFMT64x , vA , vB , a -> pc + ( vC * 2 ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> strasm = r_str_concat ( strasm , str ) ; <NEW_LINE> <TAB> <TAB> <TAB> break ;
<TAB> if ( av_image_check_size ( s -> width , s -> height , 0 , avctx ) < 0 ) <NEW_LINE> <TAB> <TAB> return - 1 ; <NEW_LINE> <START_VULN> <TAB> if ( s -> width != avctx -> width && s -> height != avctx -> height ) { <NEW_LINE> <END_VULN> <TAB> <TAB> ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ; <NEW_LINE> <TAB> <TAB> if ( ret < 0 ) <NEW_LINE> <TAB> <TAB> <TAB> return ret ;
NULL , <NEW_LINE> 0 , <NEW_LINE> 0 , 0 , 0 , 0 , <NEW_LINE> NULL , <NEW_LINE> NULL , NULL , NULL , <NEW_LINE> 0 <NEW_LINE> } ; <NEW_LINE> static float * test1_result = NULL ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> static_codebook test2 = { <NEW_LINE> 4 , 3 , <NEW_LINE> NULL , <NEW_LINE> 2 , <NEW_LINE> - 533200896 , 1611661312 , 4 , 0 , <NEW_LINE> full_quantlist1 , <NEW_LINE> NULL , NULL , NULL ,
int imap_mxcmp ( const char * mx1 , const char * mx2 ) ; <NEW_LINE> char * imap_next_word ( char * s ) ; <NEW_LINE> void imap_qualify_path ( char * dest , size_t len , struct ImapMbox * mx , char * path ) ; <NEW_LINE> <START_VULN> void imap_quote_string ( char * dest , size_t dlen , const char * src ) ; <NEW_LINE> <END_VULN> void imap_unquote_string ( char * s ) ; <NEW_LINE> void imap_munge_mbox_name ( struct ImapData * idata , char * dest , size_t dlen , const char * src ) ; <NEW_LINE> void imap_unmunge_mbox_name ( struct ImapData * idata , char * s ) ;
<TAB> <TAB> <TAB> goto exit_reader ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> cli_dbgmsg ( "cli_scanxar : decompress into temp file : \n % s , size % li , \n" <NEW_LINE><TAB> <TAB> <TAB> <TAB> "from xar heap offset % li length % li\n" , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> tmpname , size , offset , length ) ;
<TAB> + + vcpu -> stat . insn_emulation_fail ; <NEW_LINE> <TAB> trace_kvm_emulate_insn_failed ( vcpu ) ; <NEW_LINE> <START_VULN> <TAB> if ( ! is_guest_mode ( vcpu ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; <NEW_LINE> <TAB> <TAB> vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_EMULATION ; <NEW_LINE> <TAB> <TAB> vcpu -> run -> internal . ndata = 0 ;
{ <NEW_LINE> <TAB> int frameSize = afGetVirtualFrameSize ( infile , trackid , 1 ) ; <NEW_LINE> <START_VULN> <TAB> const int kBufferFrameCount = 65536 ; <NEW_LINE><TAB> void * buffer = malloc ( kBufferFrameCount * frameSize ) ; <NEW_LINE> <END_VULN> <TAB> AFframecount totalFrames = afGetFrameCount ( infile , AF_DEFAULT_TRACK ) ; <NEW_LINE> <TAB> AFframecount totalFramesWritten = 0 ;
<TAB> ind = 2 ; <NEW_LINE> <START_VULN> <TAB> while ( ibuf [ ind ] == 0x01 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ibuf [ ind + 1 ] == 0xFE ) { <NEW_LINE> <TAB> <TAB> <TAB> gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; <NEW_LINE> <TAB> <TAB> <TAB> sc_log ( card -> ctx , "Key container % d is allocated and uses key_ref % d" ,
nsresult Read ( nsIScriptContext * aContext , nsIObjectInputStream * aStream ) ; <NEW_LINE> nsresult Write ( nsIScriptContext * aContext , nsIObjectOutputStream * aStream ) ; <NEW_LINE> const PRUnichar * GetName ( ) const { return mName ; } <NEW_LINE> unsigned AccessorAttributes ( ) const { <NEW_LINE> <TAB> return JSPROP_SHARED | JSPROP_GETTER | JSPROP_SETTER | <NEW_LINE> <START_VULN> <TAB> <TAB> ( mJSAttributes & ( JSPROP_ENUMERATE | JSPROP_PERMANENT ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool IsEmpty ( ) const { return mFieldTextLength == 0 ; } <NEW_LINE> protected : <NEW_LINE> nsXBLProtoImplField * mNext ; <NEW_LINE> PRUnichar * mName ; <NEW_LINE> PRUnichar * mFieldText ;
<TAB> len -= sizeof ( * io ) * nid ; <NEW_LINE> <TAB> io = ( struct id_off * ) ( id + 1 ) ; <NEW_LINE> <TAB> cp = ( char * ) ( io + nid ) ; <NEW_LINE> <START_VULN> <TAB> if ( ! ND_TTEST2 ( cp , len ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> ND_PRINT ( ( ndo , "\"" ) ) ; <NEW_LINE> <TAB> <TAB> fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; <NEW_LINE> <TAB> <TAB> ND_PRINT ( ( ndo , "\"" ) ) ;
<TAB> if ( is_machine_check ( intr_info ) ) <NEW_LINE> <TAB> <TAB> return handle_machine_check ( vcpu ) ; <NEW_LINE> <START_VULN> <TAB> if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) <NEW_LINE> <END_VULN> <TAB> <TAB> return 1 ; <NEW_LINE> <TAB> if ( is_no_device ( intr_info ) ) {
<TAB> <TAB> <TAB> : 0 ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> bool isNative ( ) const { <NEW_LINE> <TAB> <TAB> JS_ASSERT ( ! ( flags & NON_NATIVE ) == getObjectClass ( ) -> isNative ( ) ) ; <NEW_LINE> <TAB> <TAB> return ! ( flags & NON_NATIVE ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> const js : : Shape * previous ( ) const { <NEW_LINE> <END_VULN> <TAB> <TAB> return parent ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> class Range { <NEW_LINE> <TAB> protected : <NEW_LINE> <TAB> <TAB> friend struct Shape ; <NEW_LINE> <TAB> <TAB> const Shape * cursor ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> __u8 * data ) <NEW_LINE> { <NEW_LINE> <TAB> nfcf_poll -> bit_rate = * data + + ; <NEW_LINE> <START_VULN> <TAB> nfcf_poll -> sensf_res_len = * data + + ; <NEW_LINE> <END_VULN> <TAB> pr_debug ( "bit_rate % d , sensf_res_len % d\n" , <NEW_LINE> <TAB> <TAB> nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ;
<TAB> l_current_pi -> include = 00 ; <NEW_LINE> <TAB> if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if
<TAB> WARN_ON ( sk -> sk_wmem_queued ) ; <NEW_LINE> <TAB> WARN_ON ( sk -> sk_forward_alloc ) ; <NEW_LINE> <START_VULN> <TAB> kfree ( inet -> opt ) ; <NEW_LINE> <END_VULN> <TAB> dst_release ( rcu_dereference_check ( sk -> sk_dst_cache , 1 ) ) ; <NEW_LINE> <TAB> sk_refcnt_debug_dec ( sk ) ; <NEW_LINE> }
<TAB> } else { <NEW_LINE> <TAB> <TAB> bh = sb_bread ( inode -> i_sb , pos ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! bh ) <NEW_LINE><TAB> <TAB> <TAB> goto out ; <NEW_LINE> <END_VULN> <TAB> <TAB> symlink = bh -> b_data ; <NEW_LINE> <TAB> }
<TAB> mscfs_check_cache ( priv -> fs ) ; <NEW_LINE> <TAB> for ( x = 0 ; x < fs -> cache . size ; x + + ) { <NEW_LINE> <START_VULN> <TAB> <TAB> u8 * oid = fs -> cache . array [ x ] . objectId . id ; <NEW_LINE> <END_VULN> <TAB> <TAB> sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , <NEW_LINE> <TAB> <TAB> <TAB> "FILE : % 02X % 02X % 02X % 02X\n" , <NEW_LINE> <TAB> <TAB> <TAB> oid [ 0 ] , oid [ 1 ] , oid [ 2 ] , oid [ 3 ] ) ;
<TAB> <TAB> <TAB> mark_reg_unknown ( env , regs , insn -> dst_reg ) ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE><TAB> <TAB> if ( dst_reg -> smin_value < 0 ) { <NEW_LINE><TAB> <TAB> <TAB> if ( umin_val ) { <NEW_LINE><TAB> <TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> <TAB> dst_reg -> smin_value = 0 ; <NEW_LINE><TAB> <TAB> <TAB> } else { <NEW_LINE><TAB> <TAB> <TAB> <TAB> <NEW_LINE><TAB> <TAB> <TAB> <TAB> dst_reg -> smin_value = S64_MIN ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> dst_reg -> smax_value = S64_MAX ; <NEW_LINE><TAB> <TAB> <TAB> } <NEW_LINE><TAB> <TAB> } else { <NEW_LINE><TAB> <TAB> <TAB> dst_reg -> smin_value = <NEW_LINE><TAB> <TAB> <TAB> <TAB> ( u64 ) ( dst_reg -> smin_value ) >> umax_val ; <NEW_LINE><TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> <TAB> if ( src_known ) <NEW_LINE> <TAB> <TAB> <TAB> dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> umin_val ) ;
<TAB> EP_CHECK_CANARY ( ( "before dissecting frame % d" , fd -> num ) ) ; <NEW_LINE> <TAB> TRY { <NEW_LINE> <START_VULN> <TAB> <TAB> edt -> tvb = tvb_new_real_data ( pd , fd -> cap_len , fd -> pkt_len ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> add_new_data_source ( & edt -> pi , edt -> tvb , "Frame" ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : single - block PCM analysis mode dispatch <NEW_LINE> <START_VULN> last mod : $ Id : analysis . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdio . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
<TAB> <TAB> return SC_ERROR_INVALID_ARGUMENTS ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( sec_attr == NULL ) { <NEW_LINE> <END_VULN> <TAB> <TAB> if ( file -> sec_attr != NULL ) <NEW_LINE> <TAB> <TAB> <TAB> free ( file -> sec_attr ) ; <NEW_LINE> <TAB> <TAB> file -> sec_attr = NULL ;
<TAB> unsigned long _flags ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> struct sk_buff_head ps_tx_buf [ IEEE80211_NUM_ACS ] ; <NEW_LINE> <TAB> struct sk_buff_head tx_filtered [ IEEE80211_NUM_ACS ] ; <NEW_LINE> <TAB> unsigned long driver_buffered_tids ;
0 . 9999667820F , 0 . 9999720773F , 0 . 9999767136F , 0 . 9999807479F , <NEW_LINE> 0 . 9999842344F , 0 . 9999872249F , 0 . 9999897688F , 0 . 9999919127F , <NEW_LINE> 0 . 9999937009F , 0 . 9999951749F , 0 . 9999963738F , 0 . 9999973342F , <NEW_LINE> 0 . 9999980900F , 0 . 9999986724F , 0 . 9999991103F , 0 . 9999994297F , <NEW_LINE> 0 . 9999996543F , 0 . 9999998049F , 0 . 9999999000F , 0 . 9999999552F , <NEW_LINE> 0 . 9999999836F , 0 . 9999999957F , 0 . 9999999994F , 1 . 0000000000F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin2048 [ 1024 ] = { <NEW_LINE> <END_VULN> 0 . 0000009241F , 0 . 0000083165F , 0 . 0000231014F , 0 . 0000452785F , <NEW_LINE> 0 . 0000748476F , 0 . 0001118085F , 0 . 0001561608F , 0 . 0002079041F , <NEW_LINE> 0 . 0002670379F , 0 . 0003335617F , 0 . 0004074748F , 0 . 0004887765F , <NEW_LINE> 0 . 0005774661F , 0 . 0006735427F , 0 . 0007770054F , 0 . 0008878533F , <NEW_LINE> 0 . 0010060853F , 0 . 0011317002F , 0 . 0012646969F , 0 . 0014050742F , <NEW_LINE> 0 . 0015528307F , 0 . 0017079650F , 0 . 0018704756F , 0 . 0020403610F , <NEW_LINE> 0 . 0022176196F , 0 . 0024022497F , 0 . 0025942495F , 0 . 0027936173F , <NEW_LINE> 0 . 0030003511F , 0 . 0032144490F , 0 . 0034359088F , 0 . 0036647286F ,
<TAB> <TAB> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> offset ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> offset += ipv6_optlen ( exthdr ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> * nexthdr = & exthdr -> nexthdr ; <NEW_LINE> <TAB> }
<TAB> <TAB> swoole_string_release ( fname ) ; <NEW_LINE> <TAB> <TAB> zval_ptr_dtor ( & ret ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> return buffer ; <NEW_LINE> }
<TAB> <TAB> phar_flush ( phar_obj -> arc . archive , stub , stub_len , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> }
<TAB> parameters -> csty |= 0x01 ; <NEW_LINE> <START_VULN> <TAB> parameters -> res_spec = parameters -> numresolution - 1 ; <NEW_LINE><TAB> for ( i = 0 ; i < parameters -> res_spec ; i + + ) { <NEW_LINE><TAB> <TAB> parameters -> prcw_init [ i ] = 256 ; <NEW_LINE><TAB> <TAB> parameters -> prch_init [ i ] = 256 ; <NEW_LINE> <END_VULN> <TAB> }
<TAB> <TAB> <TAB> goto bad_block ; <NEW_LINE> <TAB> <TAB> entry = next ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ext2_xattr_cache_insert ( bh ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> ea_idebug ( inode , "cache insert failed" ) ;
<TAB> <TAB> hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> hlen , & _hdr ) ; <NEW_LINE> <TAB> <TAB> if ( ! hdr ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ( ntohl ( hdr [ 0 ] . entry ) & MPLS_LS_LABEL_MASK ) >> <NEW_LINE> <TAB> <TAB> MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY ) {
<TAB> <TAB> <TAB> <TAB> inet -> inet_saddr , inet -> inet_dport , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> inet -> inet_sport , sk -> sk_protocol , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; <NEW_LINE> <START_VULN> <TAB> if ( ! IS_ERR ( rt ) ) <NEW_LINE><TAB> <TAB> __sk_dst_set ( sk , & rt -> dst ) ; <NEW_LINE> <END_VULN> <TAB> rcu_read_unlock ( ) ; <NEW_LINE> } <NEW_LINE> EXPORT_SYMBOL_GPL ( ip4_datagram_release_cb ) ;
<TAB> { <NEW_LINE> <START_VULN> <TAB> _cupsStrFree ( username -> values [ 0 ] . string . text ) ; <NEW_LINE><TAB> username -> values [ 0 ] . string . text = _cupsStrAlloc ( RemoteRoot ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> }
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> MediaByteRange const & aByteRange ) ; <NEW_LINE> virtual nsresult Close ( ) ; <NEW_LINE> virtual void Suspend ( bool aCloseImmediately ) ; <NEW_LINE> virtual void Resume ( ) ; <NEW_LINE> virtual already_AddRefed < nsIPrincipal > GetCurrentPrincipal ( ) ; <NEW_LINE> bool IsClosed ( ) const { return mCacheStream . IsClosed ( ) ; } <NEW_LINE> virtual bool CanClone ( ) ; <NEW_LINE> <START_VULN> virtual MediaResource * CloneData ( MediaDecoder * aDecoder ) ; <NEW_LINE> <END_VULN> void RecordStatisticsTo ( MediaChannelStatistics * aStatistics ) MOZ_OVERRIDE { <NEW_LINE> <TAB> NS_ASSERTION ( aStatistics , "Statistics param cannot be null ! " ) ; <NEW_LINE> <TAB> MutexAutoLock lock ( mLock ) ; <NEW_LINE> <TAB> if ( ! mChannelStatistics ) { <NEW_LINE> <TAB> mChannelStatistics = aStatistics ; <NEW_LINE> <TAB> }
<TAB> sslSessionID * sid = ss -> sec . ci . sid ; <NEW_LINE> <TAB> if ( sid -> peerCert == NULL ) { <NEW_LINE> <TAB> PORT_Memcpy ( sid -> u . ssl2 . sessionID , s , sizeof ( sid -> u . ssl2 . sessionID ) ) ; <NEW_LINE> <TAB> sid -> peerCert = CERT_DupCertificate ( ss -> sec . peerCert ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( ! ss -> opt . noCache ) <NEW_LINE> <END_VULN> <TAB> ( * ss -> sec . cache ) ( sid ) ; <NEW_LINE> } <NEW_LINE> static SECStatus <NEW_LINE> ssl2_TriggerNextMessage ( sslSocket * ss ) <NEW_LINE> { <NEW_LINE> <TAB> SECStatus rv ;
static inline int pmd_large ( pmd_t pte ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return ( pmd_flags ( pte ) & ( _PAGE_PSE | _PAGE_PRESENT ) ) == <NEW_LINE><TAB> <TAB> ( _PAGE_PSE | _PAGE_PRESENT ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef CONFIG_TRANSPARENT_HUGEPAGE
extern void nfs4_put_state_owner ( struct nfs4_state_owner * ) ; <NEW_LINE> extern struct nfs4_state * nfs4_get_open_state ( struct inode * , struct nfs4_state_owner * ) ; <NEW_LINE> extern void nfs4_put_open_state ( struct nfs4_state * ) ; <NEW_LINE> <START_VULN> extern void nfs4_close_state ( struct path * , struct nfs4_state * , mode_t ) ; <NEW_LINE>extern void nfs4_close_sync ( struct path * , struct nfs4_state * , mode_t ) ; <NEW_LINE>extern void nfs4_state_set_mode_locked ( struct nfs4_state * , mode_t ) ; <NEW_LINE> <END_VULN> extern void nfs4_schedule_state_recovery ( struct nfs_client * ) ; <NEW_LINE> extern void nfs4_schedule_state_manager ( struct nfs_client * ) ; <NEW_LINE> extern int nfs4_state_mark_reclaim_nograce ( struct nfs_client * clp , struct nfs4_state * state ) ;
<TAB> <TAB> if ( mono_class_is_subclass_of ( src_class , dest_class , FALSE ) ) <NEW_LINE> <TAB> <TAB> <TAB> ; <NEW_LINE> <START_VULN> <TAB> <TAB> else if ( mono_class_is_subclass_of ( dest_class , src_class , FALSE ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return FALSE ; <NEW_LINE> <TAB> }
<TAB> if ( pos + total_len <= i_size_read ( inode ) ) { <NEW_LINE> <START_VULN> <TAB> <TAB> down_read ( & oi -> ip_alloc_sem ) ; <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> ret = ocfs2_get_block ( inode , iblock , bh_result , create ) ; <NEW_LINE><NEW_LINE><TAB> <TAB> up_read ( & oi -> ip_alloc_sem ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( buffer_mapped ( bh_result ) && <NEW_LINE> <TAB> <TAB> ! buffer_new ( bh_result ) && <NEW_LINE> <TAB> <TAB> ret == 0 )
<START_VULN> PHPAPI ulong <NEW_LINE> <END_VULN> mysqlnd_old_escape_string ( char * newstr , const char * escapestr , size_t escapestr_len TSRMLS_DC ) <NEW_LINE> { <NEW_LINE> <TAB> DBG_ENTER ( "mysqlnd_old_escape_string" ) ;
} <NEW_LINE> static void <NEW_LINE> <START_VULN> mark_trusted_task_thread_func ( GTask * task , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> gpointer source_object , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> gpointer task_data , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> GCancellable * cancellable ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> MarkTrustedJob * job = task_data ; <NEW_LINE> <TAB> CommonJob * common ;
<TAB> <TAB> seed = buf ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> err = tfm -> seed ( tfm , seed , slen ) ; <NEW_LINE> <END_VULN> <TAB> kfree ( buf ) ; <NEW_LINE> <TAB> return err ;
<TAB> <TAB> <TAB> <TAB> if ( error ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> goto cleanup_dquot ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> mb_cache_entry_release ( ce ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ce = NULL ; <NEW_LINE> <TAB> <TAB> } else if ( bs -> bh && s -> base == bs -> bh -> b_data ) {
<TAB> <TAB> ret = vmw_user_dmabuf_lookup ( tfile , req -> buffer_handle , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> & res -> backup , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> & user_srf -> backup_base ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ret == 0 && res -> backup -> base . num_pages * PAGE_SIZE < <NEW_LINE><TAB> <TAB> res -> backup_size ) { <NEW_LINE><TAB> <TAB> <TAB> DRM_ERROR ( "Surface backup buffer is too small . \n" ) ; <NEW_LINE><TAB> <TAB> <TAB> vmw_dmabuf_unreference ( & res -> backup ) ; <NEW_LINE><TAB> <TAB> <TAB> ret = - EINVAL ; <NEW_LINE><TAB> <TAB> <TAB> goto out_unlock ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> } else if ( req -> drm_surface_flags & drm_vmw_surface_flag_create_buffer ) <NEW_LINE> <TAB> <TAB> ret = vmw_user_dmabuf_alloc ( dev_priv , tfile ,
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA512 Secure Hash Algorithm , NEON accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha512" ) ; <NEW_LINE>MODULE_ALIAS ( "sha384" ) ; <NEW_LINE> <END_VULN>
<TAB> } <NEW_LINE> <TAB> else <NEW_LINE> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> sprintf ( str + i_level * 5 , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> " + % 4 . 4s size : % "PRIu64" pos : % "PRIu64 , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ( char * ) & p_chk -> common . i_chunk_fourcc , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> p_chk -> common . i_chunk_size ,
<TAB> <TAB> opthdr = __skb_header_pointer ( skb , nhoff , sizeof ( _opthdr ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> data , hlen , & _opthdr ) ; <NEW_LINE> <TAB> <TAB> if ( ! opthdr ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <END_VULN> <TAB> <TAB> ip_proto = opthdr [ 0 ] ; <NEW_LINE> <TAB> <TAB> nhoff += ( opthdr [ 1 ] + 1 ) << 3 ;
<TAB> switch ( exit_reason ) { <NEW_LINE> <TAB> case EXIT_REASON_EXCEPTION_NMI : <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! is_exception ( intr_info ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> return false ; <NEW_LINE> <TAB> <TAB> else if ( is_page_fault ( intr_info ) ) <NEW_LINE> <TAB> <TAB> <TAB> return enable_ept ;
<TAB> } else if ( ret == - EINPROGRESS ) { <NEW_LINE> <TAB> <TAB> ret = 0 ; <NEW_LINE> <TAB> } else { <NEW_LINE> <START_VULN> <TAB> <TAB> goto couldnt_alloc_key ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> key_put ( dest_keyring ) ;
struct rad_handle ; <NEW_LINE> <START_VULN> int <TAB> rad_get_vendor_attr ( u_int32_t * , const void ** , size_t * ) ; <NEW_LINE> <END_VULN> int <TAB> rad_put_vendor_addr ( struct rad_handle * , int , int , struct in_addr ) ; <NEW_LINE> int <TAB> rad_put_vendor_attr ( struct rad_handle * , int , int , const void * , <NEW_LINE> <TAB> size_t ) ;
<TAB> int err ; <NEW_LINE> <TAB> if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <NEW_LINE> <START_VULN> <TAB> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <NEW_LINE> <END_VULN> <TAB> <TAB> duprintf ( "Bad offset % p\n" , e ) ; <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> }
<TAB> <TAB> num = ( rem_sz > scatter_elem_sz_prev ) ? <NEW_LINE> <TAB> <TAB> <TAB> scatter_elem_sz_prev : rem_sz ; <NEW_LINE> <START_VULN> <TAB> <TAB> schp -> pages [ k ] = alloc_pages ( gfp_mask , order ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ! schp -> pages [ k ] ) <NEW_LINE> <TAB> <TAB> <TAB> goto out ;
} <NEW_LINE> static int opl3_load_patch ( int dev , int format , const char __user * addr , <NEW_LINE> <START_VULN> <TAB> <TAB> int offs , int count , int pmgr_flag ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct sbi_instrument ins ;
<TAB> js : : gc : : MarkStringUnbarriered ( trc , & d . u1 . left , "left child" ) ; <NEW_LINE> <TAB> js : : gc : : MarkStringUnbarriered ( trc , & d . s . u2 . right , "right child" ) ; <NEW_LINE> } <NEW_LINE> JS_ALWAYS_INLINE void <NEW_LINE> JSDependentString : : init ( JSLinearString * base , const jschar * chars , size_t length ) <NEW_LINE> { <NEW_LINE> <TAB> JS_ASSERT ( ! js : : IsPoisonedPtr ( base ) ) ; <NEW_LINE> <START_VULN> <TAB> d . lengthAndFlags = buildLengthAndFlags ( length , DEPENDENT_BIT ) ; <NEW_LINE> <END_VULN> <TAB> d . u1 . chars = chars ; <NEW_LINE> <TAB> d . s . u2 . base = base ; <NEW_LINE> <TAB> JSString : : writeBarrierPost ( d . s . u2 . base , & d . s . u2 . base ) ; <NEW_LINE> } <NEW_LINE> JS_ALWAYS_INLINE JSDependentString * <NEW_LINE> JSDependentString : : new_ ( JSContext * cx , JSLinearString * base_ , const jschar * chars , size_t length ) <NEW_LINE> {
extern void nfs_setattr_update_inode ( struct inode * inode , struct iattr * attr ) ; <NEW_LINE> extern struct nfs_open_context * get_nfs_open_context ( struct nfs_open_context * ctx ) ; <NEW_LINE> extern void put_nfs_open_context ( struct nfs_open_context * ctx ) ; <NEW_LINE> <START_VULN> extern struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode ) ; <NEW_LINE> <END_VULN> extern u64 nfs_compat_user_ino64 ( u64 fileid ) ; <NEW_LINE> extern void nfs_fattr_init ( struct nfs_fattr * fattr ) ;
<TAB> i = 0 ; <NEW_LINE> <TAB> if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { <NEW_LINE> <TAB> <TAB> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <NEW_LINE> <TAB> <TAB> <TAB> if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> err = - EINVAL ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto out_free ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> i + + ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> }
<TAB> <TAB> unsigned char __user * ugreen ; <NEW_LINE> <TAB> <TAB> unsigned char __user * ublue ; <NEW_LINE> <TAB> <TAB> struct fb_cmap * cmap = & info -> cmap ; <NEW_LINE> <START_VULN> <TAB> <TAB> int index , count , i ; <NEW_LINE> <END_VULN> <TAB> <TAB> u8 red , green , blue ; <NEW_LINE> <TAB> <TAB> if ( get_user ( index , & c -> index ) ||
protected : <NEW_LINE> nsPresContext * mPresContext ; <NEW_LINE> nsCOMPtr < nsIPresShell > mPresShell ; <NEW_LINE> nsCOMPtr < nsISelection > mSelection ; <NEW_LINE> nsRefPtr < nsRange > mFirstSelectedRange ; <NEW_LINE> nsCOMPtr < nsIContent > mRootContent ; <NEW_LINE> nsresult Init ( nsQueryContentEvent * aEvent ) ; <NEW_LINE> nsresult Init ( nsSelectionEvent * aEvent ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> nsresult InitCommon ( ) ; <NEW_LINE> public : <NEW_LINE> static nsresult GetFlatTextOffsetOfRange ( nsIContent * aRootContent , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsINode * aNode , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> int32_t aNodeOffset ,
<TAB> . write_iter <TAB> = generic_file_write_iter , <NEW_LINE> <TAB> . mmap <TAB> <TAB> = generic_file_mmap , <NEW_LINE> <TAB> . splice_read <TAB> = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write <TAB> = generic_file_splice_write , <NEW_LINE> <END_VULN> <TAB> . fsync <TAB> <TAB> = jfs_fsync , <NEW_LINE> <TAB> . release <TAB> = jfs_release , <NEW_LINE> <TAB> . unlocked_ioctl = jfs_ioctl ,
<TAB> crypto_unregister_shashes ( wp_algs , ARRAY_SIZE ( wp_algs ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> MODULE_ALIAS ( "wp384" ) ; <NEW_LINE>MODULE_ALIAS ( "wp256" ) ; <NEW_LINE> <END_VULN> module_init ( wp512_mod_init ) ; <NEW_LINE> module_exit ( wp512_mod_fini ) ;
else <NEW_LINE> <TAB> status = 1 ; <NEW_LINE> <START_VULN> if ( caught_signal ) <NEW_LINE> <END_VULN> <TAB> { <NEW_LINE> <TAB> fprintf ( stderr , _ ( "\nSession terminated , killing shell . . . " ) ) ; <NEW_LINE> <TAB> kill ( child , SIGTERM ) ;
extern int rose_validate_nr ( struct sock * , unsigned short ) ; <NEW_LINE> extern void rose_write_internal ( struct sock * , int ) ; <NEW_LINE> extern int rose_decode ( struct sk_buff * , int * , int * , int * , int * , int * ) ; <NEW_LINE> <START_VULN> extern int rose_parse_facilities ( unsigned char * , struct rose_facilities_struct * ) ; <NEW_LINE> <END_VULN> extern void rose_disconnect ( struct sock * , int , int , int ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> use_gimp_2_8_features ) ; <NEW_LINE> <START_VULN> filename = g_build_filename ( g_get_tmp_dir ( ) , "gimp - test . xcf" , NULL ) ; <NEW_LINE> <END_VULN> file = g_file_new_for_path ( filename ) ; <NEW_LINE> g_free ( filename ) ;
<TAB> ut64 source_file_idx = c -> source_file ; <NEW_LINE> <TAB> RList * params , * debug_positions , * emitted_debug_locals = NULL ; <NEW_LINE> <TAB> bool keep = true ; <NEW_LINE> <START_VULN> <TAB> if ( argReg >= regsz ) { <NEW_LINE><TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> p4 = r_uleb128 ( p4 , p4_end - p4 , & line_start ) ; <NEW_LINE> <TAB> p4 = r_uleb128 ( p4 , p4_end - p4 , & parameters_size ) ;
{ <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <TAB> . node = { <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <TAB> <TAB> . next = NULL , <TAB> <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <START_VULN> <TAB> <TAB> . pprev = & init_struct_pid . tasks [ type ] . first , <TAB> \ <NEW_LINE> <END_VULN> <TAB> } , <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <TAB> . pid = & init_struct_pid , <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> }
<TAB> } <NEW_LINE> <TAB> fseek ( f , 0 , SEEK_SET ) ; <NEW_LINE> <START_VULN> <TAB> if ( fscanf ( f , "PG % [ \t ] % c % c % [ \t + - ] % d % [ \t ] % d % [ \t ] % d" , temp , & endian1 , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) { <NEW_LINE> <TAB> <TAB> fclose ( f ) ; <NEW_LINE> <TAB> <TAB> fprintf ( stderr ,
<TAB> return ret ; <NEW_LINE> } <NEW_LINE> <START_VULN> long video_ioctl2 ( struct file * file , <NEW_LINE><TAB> unsigned int cmd , unsigned long arg ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> char <TAB> sbuf [ 128 ] ; <NEW_LINE> <TAB> void * mbuf = NULL ;
<TAB> assert_true ( prof_output_exact ( "unencrypted" ) ) ; <NEW_LINE> <TAB> stbbr_send ( <NEW_LINE> <START_VULN> <TAB> <TAB> " < message type = 'chat' to = 'stabber@localhost / profanity' from = 'buddy1@localhost' > " <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> " < received xmlns = 'urn : xmpp : carbons : 2' > " <NEW_LINE> <TAB> <TAB> <TAB> <TAB> " < forwarded xmlns = 'urn : xmpp : forward : 0' > " <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> " < message id = 'prof_msg_7' xmlns = 'jabber : client' type = 'chat' lang = 'en' to = 'stabber@localhost / profanity' from = 'buddy1@localhost / mobile' > "
<TAB> <TAB> return GSS_S_DEFECTIVE_TOKEN ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( header -> buffer . length < token_wrapper_len + 14 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> * minor_status = 0 ; <NEW_LINE> <TAB> <TAB> return GSS_S_DEFECTIVE_TOKEN ; <NEW_LINE> <TAB> }
<TAB> . read_iter = generic_file_read_iter , <NEW_LINE> <TAB> . write_iter = generic_file_write_iter , <NEW_LINE> <TAB> . splice_read = generic_file_splice_read , <NEW_LINE> <START_VULN> <TAB> . splice_write = generic_file_splice_write , <NEW_LINE> <END_VULN> <TAB> . llseek = generic_file_llseek , <NEW_LINE> } ;
<TAB> * <TAB> We now generate an ICMP HOST REDIRECT giving the route <NEW_LINE> <TAB> * <TAB> we calculated . <NEW_LINE> <START_VULN> <TAB> if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> ip_rt_send_redirect ( skb ) ; <NEW_LINE> <TAB> skb -> priority = rt_tos2priority ( iph -> tos ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> if ( test ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> fname = test ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> fname_len = ( php_stat_len ) strlen ( fname ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 , "Could not resolve file path" ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> return ZEND_HASH_APPLY_STOP ;
<TAB> <TAB> x86_pmu . event_constraints = intel_snb_event_constraints ; <NEW_LINE> <TAB> <TAB> x86_pmu . pebs_constraints = intel_snb_pebs_event_constraints ; <NEW_LINE> <TAB> <TAB> x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <NEW_LINE> <START_VULN> <TAB> <TAB> x86_pmu . extra_regs = intel_snb_extra_regs ; <NEW_LINE> <END_VULN> <TAB> <TAB> x86_pmu . er_flags |= ERF_HAS_RSP_1 ; <NEW_LINE> <TAB> <TAB> x86_pmu . er_flags |= ERF_NO_HT_SHARING ;
<TAB> <TAB> <TAB> JSObject * argv6 = JSVAL_TO_OBJECT ( argv [ 6 ] ) ; <NEW_LINE> <TAB> <TAB> <TAB> jsval js_width , js_height , js_data ; <NEW_LINE> <TAB> <TAB> <TAB> JS_GetProperty ( cx , argv6 , "width" , & js_width ) ; <NEW_LINE> <TAB> <TAB> <TAB> JS_GetProperty ( cx , argv6 , "height" , & js_height ) ; <NEW_LINE> <TAB> <TAB> <TAB> JS_GetProperty ( cx , argv6 , "data" , & js_data ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( js_width == JSVAL_VOID || <NEW_LINE> <TAB> <TAB> <TAB> <TAB> js_height == JSVAL_VOID || <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> js_data == JSVAL_VOID ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> xpc_qsThrowBadArg ( cx , NS_ERROR_FAILURE , vp , 6 ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return JS_FALSE ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> int32_t int_width , int_height ; <NEW_LINE> <TAB> <TAB> <TAB> JSObject * obj_data = JSVAL_TO_OBJECT ( js_data ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( ! JS_ValueToECMAInt32 ( cx , js_width , & int_width ) || <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ! JS_ValueToECMAInt32 ( cx , js_height , & int_height ) )
struct ipcm_cookie { <NEW_LINE> <TAB> __be32 <TAB> <TAB> <TAB> addr ; <NEW_LINE> <TAB> int <TAB> <TAB> <TAB> oif ; <NEW_LINE> <START_VULN> <TAB> struct ip_options <TAB> * opt ; <NEW_LINE> <END_VULN> <TAB> __u8 <TAB> <TAB> <TAB> tx_flags ; <NEW_LINE> } ;
<TAB> <TAB> return - ENOMEM ; <NEW_LINE> <TAB> spin_lock_init ( & tu -> qlock ) ; <NEW_LINE> <TAB> init_waitqueue_head ( & tu -> qchange_sleep ) ; <NEW_LINE> <START_VULN> <TAB> mutex_init ( & tu -> tread_sem ) ; <NEW_LINE> <END_VULN> <TAB> tu -> ticks = 1 ; <NEW_LINE> <TAB> tu -> queue_size = 128 ; <NEW_LINE> <TAB> tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) ,
<TAB> <TAB> <TAB> if ( ( unsigned long ) iterator -> _arg - <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> ( unsigned long ) iterator -> _rtheader > <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ( unsigned long ) iterator -> _max_length ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> struct inode * inode , const char * name , <NEW_LINE> <TAB> <TAB> const void * value , size_t size , int flags ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> struct btrfs_dir_item * di ; <NEW_LINE> <END_VULN> <TAB> struct btrfs_root * root = BTRFS_I ( inode ) -> root ; <NEW_LINE> <TAB> struct btrfs_path * path ; <NEW_LINE> <TAB> size_t name_len = strlen ( name ) ;
<TAB> struct inet_sock * inet ; <NEW_LINE> <TAB> __be32 daddr ; <NEW_LINE> <START_VULN> <TAB> if ( ip_options_echo ( & icmp_param -> replyopts , skb ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return ; <NEW_LINE> <TAB> sk = icmp_xmit_lock ( net ) ;
<TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> case REOP_ASSERTNOTTEST : <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> -- curState ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> x -> cp = gData -> cpbegin + curState -> index ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> gData -> backTrackSP =
<TAB> } <NEW_LINE> } ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha384" ) ; <NEW_LINE> <END_VULN> static int __init init ( void ) <NEW_LINE> {
<TAB> <TAB> <TAB> icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; <NEW_LINE> <END_VULN> <TAB> sk_dst_reset ( sk ) ; <NEW_LINE> <TAB> return opt ;
<TAB> struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; <NEW_LINE> <TAB> struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; <NEW_LINE> <TAB> int current_profile ; <NEW_LINE> <START_VULN> <TAB> char data [ 8 ] ; <NEW_LINE> <END_VULN> <TAB> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , <NEW_LINE> <TAB> <TAB> <TAB> K90_REQUEST_STATUS ,
static Packet * <NEW_LINE> <START_VULN> BuildTestPacket ( uint16_t id , uint16_t off , int mf , const char content , <NEW_LINE><TAB> int content_len ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> Packet * p = NULL ; <NEW_LINE> <TAB> int hlen = 20 ;
bool mListenerEnabled ; <NEW_LINE> bool mReturnInEmptyLIKillsList ; <NEW_LINE> bool mDidDeleteSelection ; <NEW_LINE> bool mDidRangedDelete ; <NEW_LINE> bool mRestoreContentEditableCount ; <NEW_LINE> nsRefPtr < nsRange > mUtilRange ; <NEW_LINE> PRUint32 mJoinOffset ; <NEW_LINE> nsCOMPtr < nsIDOMNode > mNewBlock ; <NEW_LINE> <START_VULN> nsRangeStore mRangeItem ; <NEW_LINE> <END_VULN> StyleCache mCachedStyles [ SIZE_STYLE_TABLE ] ; <NEW_LINE> } ; <NEW_LINE> #endif
<TAB> dev -> udev = interface_to_usbdev ( intf ) ; <NEW_LINE> <TAB> for ( i = 0 ; i < icount ; i + + ) { <NEW_LINE> <START_VULN> <TAB> <TAB> dev -> canch [ i ] = gs_make_candev ( i , intf , & dconf ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( IS_ERR_OR_NULL ( dev -> canch [ i ] ) ) { <NEW_LINE> <TAB> <TAB> <TAB> rc = PTR_ERR ( dev -> canch [ i ] ) ;
static inline unsigned int __xfrm4_daddr_saddr_hash ( xfrm_address_t * daddr , xfrm_address_t * saddr ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> return ntohl ( daddr -> a4 ^ saddr -> a4 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline unsigned int __xfrm6_daddr_saddr_hash ( xfrm_address_t * daddr , xfrm_address_t * saddr )
<START_VULN> <TAB> <TAB> if ( * rsize >= 74 && <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && <NEW_LINE> <TAB> <TAB> <TAB> rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && <NEW_LINE> <TAB> <TAB> <TAB> rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f &&
<TAB> struct ext4_iloc iloc ; <NEW_LINE> <TAB> int err = 0 ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> if ( handle && ! ext4_handle_valid ( handle ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ;
<TAB> <TAB> err = do_remount_sb ( sb , flags , data , 0 ) ; <NEW_LINE> <TAB> if ( ! err ) { <NEW_LINE> <TAB> <TAB> lock_mount_hash ( ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <NEW_LINE> <END_VULN> <TAB> <TAB> mnt -> mnt . mnt_flags = mnt_flags ; <NEW_LINE> <TAB> <TAB> touch_mnt_namespace ( mnt -> mnt_ns ) ; <NEW_LINE> <TAB> <TAB> unlock_mount_hash ( ) ;
<TAB> <TAB> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; <NEW_LINE> <TAB> <TAB> if ( ret <= 0 ) { <NEW_LINE> <TAB> <TAB> <TAB> if ( ret != 0 ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> ERROR ( "error using IPC to receive notification from attached process ( 1 ) " ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> goto cleanup_error ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> skb_queue_walk ( queue , skb ) { <NEW_LINE> <TAB> <TAB> <TAB> * peeked = skb -> peeked ; <NEW_LINE> <TAB> <TAB> <TAB> if ( flags & MSG_PEEK ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> if ( * off >= skb -> len ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> * off -= skb -> len ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> }
<TAB> } <NEW_LINE> out_unlock : <NEW_LINE> <START_VULN> <TAB> sem_unlock ( sma ) ; <NEW_LINE> <END_VULN> out_wakeup : <NEW_LINE> <TAB> wake_up_sem_queue_do ( & tasks ) ; <NEW_LINE> out_free :
<TAB> <TAB> for ( int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK ; i > 0 ; i -- , to + + ) { <NEW_LINE> <TAB> <TAB> <TAB> JSBool marked = to -> IsMarked ( ) ; <NEW_LINE> <TAB> <TAB> <TAB> to -> Unmark ( ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( marked ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> if ( ! to -> GetJSObject ( ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> nsISupports * obj = to -> GetNative ( ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( obj ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> obj -> Release ( ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> to -> SetNative ( nsnull ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> to -> SetInterface ( nsnull ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> }
<TAB> IPV6_SET_RAW_VER ( p -> ip6h , 6 ) ; <NEW_LINE> <TAB> IPV6FragHdr * fh = ( IPV6FragHdr * ) ( GET_PKT_DATA ( p ) + sizeof ( IPV6Hdr ) ) ; <NEW_LINE> <START_VULN> <TAB> fh -> ip6fh_nxt = IPPROTO_ICMP ; <NEW_LINE> <END_VULN> <TAB> fh -> ip6fh_ident = htonl ( id ) ; <NEW_LINE> <TAB> fh -> ip6fh_offlg = htons ( ( off << 3 ) | mf ) ;
virtual ~ nsXBLProtoImplProperty ( ) ; <NEW_LINE> void AppendGetterText ( const nsAString & aGetter ) ; <NEW_LINE> void AppendSetterText ( const nsAString & aSetter ) ; <NEW_LINE> void SetGetterLineNumber ( uint32_t aLineNumber ) ; <NEW_LINE> void SetSetterLineNumber ( uint32_t aLineNumber ) ; <NEW_LINE> <START_VULN> virtual nsresult InstallMember ( nsIScriptContext * aContext , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nsIContent * aBoundElement , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aScriptObject , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aTargetClassObject , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsCString & aClassStr ) ; <NEW_LINE> <END_VULN> virtual nsresult CompileMember ( nsIScriptContext * aContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const nsCString & aClassStr , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aClassObject ) ; <NEW_LINE> virtual void Trace ( TraceCallback aCallback , void * aClosure ) const ; <NEW_LINE> nsresult Read ( nsIScriptContext * aContext , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> nsIObjectInputStream * aStream ,
<TAB> if ( * ctx == NULL ) <NEW_LINE> <TAB> <TAB> return ( GSS_S_COMPLETE ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> if ( ( * ctx ) -> magic_num == SPNEGO_MAGIC_ID ) { <NEW_LINE><TAB> <TAB> ( void ) gss_delete_sec_context ( minor_status , <NEW_LINE><TAB> <TAB> <TAB> <TAB> & ( * ctx ) -> ctx_handle , <NEW_LINE><TAB> <TAB> <TAB> <TAB> output_token ) ; <NEW_LINE><TAB> <TAB> ( void ) release_spnego_ctx ( ctx ) ; <NEW_LINE><TAB> } else { <NEW_LINE><TAB> <TAB> ret = gss_delete_sec_context ( minor_status , <NEW_LINE><TAB> <TAB> <TAB> <TAB> context_handle , <NEW_LINE><TAB> <TAB> <TAB> <TAB> output_token ) ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> return ( ret ) ; <NEW_LINE> }
char * result ; <NEW_LINE> if ( len <= 0 ) return NULL ; <NEW_LINE> result = ALLOC_N ( char , len ) ; <NEW_LINE> <START_VULN> memccpy ( result , ptr , 0 , len ) ; <NEW_LINE> <END_VULN> return result ; <NEW_LINE> }
<TAB> <TAB> break ; <NEW_LINE> <TAB> case SO_PASSSEC : <NEW_LINE> <START_VULN> <TAB> <TAB> v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ; <NEW_LINE> <END_VULN> <TAB> <TAB> break ; <NEW_LINE> <TAB> case SO_PEERSEC :
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 63 2014 / 06 / 09 13 : 04 : 37 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include < assert . h >
<TAB> <TAB> <TAB> if ( ua ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> efree ( ua ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> } <TAB> <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> <TAB> if ( user_headers ) {
<TAB> <TAB> int ext_off , noff , weight ; <NEW_LINE> <TAB> <TAB> size_t lt ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ( int ) ( l = np -> file -> basename_utf16 . length ) > ffmax ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> l = ffmax ; <NEW_LINE> <TAB> <TAB> p = malloc ( ( l + 1 ) * 2 ) ;
<TAB> if ( ! dev -> in_out_buffer ) <NEW_LINE> <TAB> <TAB> return - ENOMEM ; <NEW_LINE> <START_VULN> <TAB> spin_lock_init ( & dev -> lock ) ; <NEW_LINE> <END_VULN> <TAB> ret = hid_parse ( hdev ) ; <NEW_LINE> <TAB> if ( ret ) {
<TAB> std : : size_t writeAttributeData ( ArrayVertexBuffer * vertexBuffer , GLint start , GLsizei count , const VertexAttribute & attribute ) ; <NEW_LINE> <TAB> Context * const mContext ; <NEW_LINE> <TAB> IDirect3DDevice9 * const mDevice ; <NEW_LINE> <TAB> StreamingVertexBuffer * mStreamingBuffer ; <NEW_LINE> <TAB> bool mDirtyCurrentValue [ MAX_VERTEX_ATTRIBS ] ; <NEW_LINE> <START_VULN> <TAB> ConstantVertexBuffer * mCurrentValueBuffer [ MAX_VERTEX_ATTRIBS ] ; <NEW_LINE> <END_VULN> <TAB> struct FormatConverter <NEW_LINE> <TAB> { <NEW_LINE> <TAB> <TAB> bool identity ; <NEW_LINE> <TAB> <TAB> std : : size_t outputElementSize ; <NEW_LINE> <TAB> <TAB> void ( * convertArray ) ( const void * in , std : : size_t stride , std : : size_t n , void * out ) ; <NEW_LINE> <TAB> <TAB> D3DDECLTYPE d3dDeclType ;
<TAB> <TAB> } <NEW_LINE> <TAB> } <NEW_LINE> <TAB> * q = '\0' ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> RETVAL_STRINGL ( erealloc ( out_str , q - out_str + 1 ) , q - out_str , 0 ) ; <NEW_LINE> }
<TAB> tnl_hlen = skb_tnl_header_len ( skb ) ; <NEW_LINE> <START_VULN> <TAB> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) <NEW_LINE> <TAB> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> }
<TAB> cx -> hasSignature = ( sig != NULL ) ; <NEW_LINE> <TAB> cx -> encAlg = encAlg ; <NEW_LINE> <TAB> cx -> hashAlg = hashAlg ; <NEW_LINE> <TAB> cx -> key = SECKEY_CopyPublicKey ( key ) ; <NEW_LINE> <TAB> rv = SECSuccess ; <NEW_LINE> <TAB> if ( sig ) { <NEW_LINE> <TAB> switch ( type ) { <NEW_LINE> <TAB> case rsaKey : <NEW_LINE> <START_VULN> <TAB> rv = DecryptSigBlock ( & cx -> hashAlg , cx -> u . buffer , & cx -> rsadigestlen , <NEW_LINE><TAB> <TAB> <TAB> HASH_LENGTH_MAX , cx -> key , sig , ( char * ) wincx ) ; <NEW_LINE><TAB> if ( cx -> hashAlg != hashAlg && hashAlg != SEC_OID_UNKNOWN ) { <NEW_LINE><TAB> <TAB> PORT_SetError ( SEC_ERROR_BAD_SIGNATURE ) ; <NEW_LINE><TAB> <TAB> rv = SECFailure ; <TAB> <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> break ; <NEW_LINE> <TAB> case dsaKey : <NEW_LINE> <TAB> case ecKey : <NEW_LINE> <TAB> sigLen = SECKEY_SignatureLen ( key ) ; <NEW_LINE> <TAB> if ( sigLen == 0 ) { <NEW_LINE> <TAB> <TAB> rv = SECFailure ; <TAB> <NEW_LINE> <TAB> <TAB> break ;
<TAB> room = dst_mtu ( & rt -> dst ) ; <NEW_LINE> <TAB> if ( room > 576 ) <NEW_LINE> <TAB> <TAB> room = 576 ; <NEW_LINE> <START_VULN> <TAB> room -= sizeof ( struct iphdr ) + icmp_param . replyopts . optlen ; <NEW_LINE> <END_VULN> <TAB> room -= sizeof ( struct icmphdr ) ; <NEW_LINE> <TAB> icmp_param . data_len = skb_in -> len - icmp_param . offset ;
XPC_SJOW_Construct ( JSContext * cx , JSObject * obj , uintN , jsval * argv , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> jsval * rval ) ; <NEW_LINE> PRBool <NEW_LINE> XPC_SJOW_AttachNewConstructorObject ( XPCCallContext & ccx , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JSObject * aGlobalObject ) ; <NEW_LINE> JSBool <NEW_LINE> <START_VULN> XPC_XOW_WrapObject ( JSContext * cx , JSObject * parent , jsval * vp ) ; <NEW_LINE> <END_VULN> #ifdef XPC_IDISPATCH_SUPPORT <NEW_LINE> #include "XPCDispPrivate . h" <NEW_LINE> #endif
<TAB> if ( ! ip_checkentry ( & e -> ip ) ) <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <START_VULN> <TAB> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <NEW_LINE> <END_VULN> <TAB> if ( err ) <NEW_LINE> <TAB> <TAB> return err ;
vb -> pcm = _vorbis_block_alloc ( vb , sizeof ( * vb -> pcm ) * vi -> channels ) ; <NEW_LINE> for ( i = 0 ; i < vi -> channels ; i + + ) <NEW_LINE> <TAB> vb -> pcm [ i ] = _vorbis_block_alloc ( vb , vb -> pcmend * sizeof ( * vb -> pcm [ i ] ) ) ; <NEW_LINE> type = ci -> map_type [ ci -> mode_param [ mode ] -> mapping ] ; <NEW_LINE> return ( _mapping_P [ type ] -> inverse ( vb , ci -> map_param [ ci -> mode_param [ mode ] -> <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> mapping ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> int vorbis_synthesis_trackonly ( vorbis_block * vb , ogg_packet * op ) { <NEW_LINE> vorbis_dsp_state * vd = vb -> vd ; <NEW_LINE> private_state * b = vd -> backend_state ; <NEW_LINE> vorbis_info * vi = vd -> vi ;
#include "file . h" <NEW_LINE> #ifndef <TAB> lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : softmagic . c , v 1 . 195 2014 / 09 / 24 19 : 49 : 07 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <TAB> <NEW_LINE> #include "magic . h"
<TAB> proto_item * wpa_sub_ucs_item , * wpa_sub_akms_item ; <NEW_LINE> <TAB> proto_tree * wpa_mcs_tree , * wpa_ucs_tree , * wpa_akms_tree ; <NEW_LINE> <TAB> proto_tree * wpa_sub_ucs_tree , * wpa_sub_akms_tree ; <NEW_LINE> <START_VULN> <TAB> guint16 i , ucs_count , akms_count ; <NEW_LINE> <END_VULN> <TAB> proto_tree_add_item ( tree , hf_ieee80211_wfa_ie_wpa_version , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; <NEW_LINE> <TAB> offset += 2 ;
<TAB> <TAB> <TAB> printk ( XENLOG_G_INFO <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> "Cannot bind IRQ % d to dom % d . Out of memory . \n" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> pirq -> pirq , v -> domain -> domain_id ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> rc = - ENOMEM ; <NEW_LINE><TAB> <TAB> <TAB> goto out ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> action = newaction ;
<TAB> <TAB> return - ENOMEM ; <NEW_LINE> <TAB> for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <NEW_LINE> <START_VULN> <TAB> <TAB> unix_inflight ( scm -> fp -> fp [ i ] ) ; <NEW_LINE> <END_VULN> <TAB> return max_level ; <NEW_LINE> }
{ <NEW_LINE> <TAB> gchar * absolute_filename ; <NEW_LINE> <START_VULN> <TAB> if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> absolute_filename = g_strdup ( filename ) ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> gchar * tmpcdir ;
<TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> if ( ( creds -> pid == task_tgid_vnr ( current ) || <NEW_LINE> <START_VULN> <TAB> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && <NEW_LINE> <END_VULN> <TAB> ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || <NEW_LINE> <TAB> uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && <NEW_LINE> <TAB> ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) ||
<TAB> <TAB> <TAB> <TAB> <TAB> kernel ; it's the pixel to remove from the accumulator . * / <NEW_LINE> <TAB> gint * ac ; <NEW_LINE> <TAB> ac = g_new0 ( gint , bpp ) ; <NEW_LINE> <START_VULN> <TAB> if ( sx < 10 . 0 && sy < 10 . 0 ) <NEW_LINE><TAB> <TAB> use_box_blur = FALSE ; <NEW_LINE><TAB> else <NEW_LINE><TAB> <TAB> use_box_blur = TRUE ; <NEW_LINE><NEW_LINE> <END_VULN> <TAB> if ( ( sx == 0 . 0 && sy == 0 . 0 ) <NEW_LINE> <TAB> <TAB> || sx > 1000 || sy > 1000 ) {
<TAB> <TAB> unsigned long now ; <NEW_LINE> <TAB> <TAB> getnstimeofday ( & n ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> now = timespec_to_ns ( n ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( when > now ) <NEW_LINE> <TAB> <TAB> <TAB> when -= now ; <NEW_LINE> <TAB> <TAB> else
<TAB> long err ; <NEW_LINE> <TAB> int i ; <NEW_LINE> <START_VULN> <TAB> if ( nsops < 1 ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> sops = kmalloc ( sizeof ( * sops ) * nsops , GFP_KERNEL ) ; <NEW_LINE> <TAB> if ( ! sops )
<TAB> <TAB> psf -> fileoffset += offset + 10 ; <NEW_LINE> <START_VULN> <TAB> <TAB> psf_binheader_readf ( psf , "p" , psf -> fileoffset ) ; <NEW_LINE><TAB> <TAB> return 1 ; <NEW_LINE> <END_VULN> <TAB> <TAB> } ; <NEW_LINE> <TAB> return 0 ;
<TAB> <TAB> data . period = event -> hw . last_period ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( perf_event_overflow ( event , 1 , & data , regs ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> x86_pmu_stop ( event , 0 ) ; <NEW_LINE> <TAB> }
<TAB> } <NEW_LINE> <TAB> if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) <NEW_LINE> <TAB> <TAB> goto no_page ; <NEW_LINE> <START_VULN> <TAB> if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> pte_unmap_unlock ( ptep , ptl ) ; <NEW_LINE> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> }
<TAB> } <NEW_LINE> <TAB> else { <NEW_LINE> <TAB> char * newBuf ; <NEW_LINE> <TAB> int bufferSize = ( int ) ( bufferLim - bufferPtr ) ; <NEW_LINE> <TAB> if ( bufferSize == 0 ) <NEW_LINE> <TAB> <TAB> bufferSize = INIT_BUFFER_SIZE ; <NEW_LINE> <TAB> do { <NEW_LINE> <TAB> <TAB> bufferSize *= 2 ; <NEW_LINE> <START_VULN> <TAB> } while ( bufferSize < neededSize ) ; <NEW_LINE> <END_VULN> <TAB> newBuf = ( char * ) MALLOC ( bufferSize ) ; <NEW_LINE> <TAB> if ( newBuf == 0 ) { <NEW_LINE> <TAB> <TAB> errorCode = XML_ERROR_NO_MEMORY ; <NEW_LINE> <TAB> <TAB> return NULL ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> bufferLim = newBuf + bufferSize ; <NEW_LINE> #ifdef XML_CONTEXT_BYTES <NEW_LINE> <TAB> if ( bufferPtr ) {
* <TAB> "id : < id > " <TAB> - request a key matching the ID <NEW_LINE> * <TAB> " < subtype > : < id > " - request a key of a subtype <NEW_LINE> <START_VULN> static int asymmetric_key_match ( const struct key * key , <NEW_LINE><TAB> <TAB> <TAB> <TAB> const struct key_match_data * match_data ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> const struct asymmetric_key_subtype * subtype = asymmetric_key_subtype ( key ) ; <NEW_LINE> <TAB> const char * description = match_data -> raw_data ;
<TAB> <TAB> if ( unlikely ( ! access_ok ( VERIFY_WRITE , kiocb -> ki_buf , <NEW_LINE> <TAB> <TAB> <TAB> kiocb -> ki_left ) ) ) <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <START_VULN> <TAB> <TAB> ret = security_file_permission ( file , MAY_READ ) ; <NEW_LINE><TAB> <TAB> if ( unlikely ( ret ) ) <NEW_LINE><TAB> <TAB> <TAB> break ; <NEW_LINE><TAB> <TAB> ret = aio_setup_single_vector ( kiocb ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ret ) <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> ret = - EINVAL ;
struct SParser * p = cast ( struct SParser * , ud ) ; <NEW_LINE> int c = luaZ_lookahead ( p -> z ) ; <NEW_LINE> luaC_checkGC ( L ) ; <NEW_LINE> <START_VULN> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & p -> buff , p -> name ) ; <NEW_LINE> cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ; <NEW_LINE> cl -> l . p = tf ;
<TAB> <TAB> if ( ! ( type -> fs_flags & FS_USERNS_DEV_MOUNT ) ) { <NEW_LINE> <TAB> <TAB> <TAB> flags |= MS_NODEV ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> mnt_flags |= MNT_NODEV ; <NEW_LINE> <END_VULN> <TAB> <TAB> } <NEW_LINE> <TAB> }
# define LLONG long <NEW_LINE> #endif <NEW_LINE> <START_VULN> static void fmtstr ( char ** , char ** , size_t * , size_t * , <NEW_LINE><TAB> <TAB> <TAB> <TAB> const char * , int , int , int ) ; <NEW_LINE>static void fmtint ( char ** , char ** , size_t * , size_t * , <NEW_LINE><TAB> <TAB> <TAB> <TAB> LLONG , int , int , int , int ) ; <NEW_LINE>static void fmtfp ( char ** , char ** , size_t * , size_t * , <NEW_LINE><TAB> <TAB> <TAB> <TAB> LDOUBLE , int , int , int ) ; <NEW_LINE>static void doapr_outch ( char ** , char ** , size_t * , size_t * , int ) ; <NEW_LINE>static void _dopr ( char ** sbuffer , char ** buffer , <NEW_LINE><TAB> <TAB> <TAB> <TAB> size_t * maxlen , size_t * retlen , int * truncated , <NEW_LINE><TAB> <TAB> <TAB> <TAB> const char * format , va_list args ) ; <NEW_LINE> <END_VULN> #define DP_S_DEFAULT 0
<TAB> switch ( optname ) { <NEW_LINE> <TAB> case TCP_MAXSEG : <NEW_LINE> <START_VULN> <TAB> <TAB> if ( val < 8 || val > MAX_TCP_WINDOW ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> err = - EINVAL ; <NEW_LINE> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> }
int hns_rcb_get_ring_sset_count ( int stringset ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( stringset == ETH_SS_STATS ) <NEW_LINE> <END_VULN> <TAB> <TAB> return HNS_RING_STATIC_REG_NUM ; <NEW_LINE> <TAB> return 0 ;
<TAB> if ( in_atomic ( ) || ! mm ) <NEW_LINE> <TAB> <TAB> goto intr_or_no_mm ; <NEW_LINE> <START_VULN> <TAB> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! down_read_trylock ( & mm -> mmap_sem ) ) { <NEW_LINE> <TAB> <TAB> if ( ( regs -> tstate & TSTATE_PRIV ) &&
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bps , channels , samplerate ) ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> av_get_packet ( pb , pkt , asize ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ; <NEW_LINE> <TAB> <TAB> pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; <NEW_LINE> <TAB> <TAB> if ( nsv -> state == NSV_HAS_READ_NSVS && st [ NSV_ST_VIDEO ] ) {
getprivs_ret * get_privs_2_svc ( krb5_ui_4 * arg , struct svc_req * rqstp ) <NEW_LINE> { <NEW_LINE> <TAB> static getprivs_ret ret ; <NEW_LINE> <START_VULN> <TAB> gss_buffer_desc client_name , service_name ; <NEW_LINE> <END_VULN> <TAB> OM_uint32 minor_stat ; <NEW_LINE> <TAB> kadm5_server_handle_t handle ; <NEW_LINE> <TAB> const char * errmsg = NULL ;
static void mspack_fmap_free ( void * mem ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> free ( mem ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void mspack_fmap_copy ( void * src , void * dst , size_t num )
<TAB> if ( get_vmx_mem_address ( vcpu , exit_qualification , <NEW_LINE> <TAB> <TAB> <TAB> vmx_instruction_info , true , & vmcs_gva ) ) <NEW_LINE> <TAB> <TAB> return 1 ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> if ( kvm_write_guest_virt_system ( & vcpu -> arch . emulate_ctxt , vmcs_gva , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> ( void * ) & to_vmx ( vcpu ) -> nested . current_vmptr , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> sizeof ( u64 ) , & e ) ) {
<TAB> <TAB> reserve = ( end - start ) - <NEW_LINE> <TAB> <TAB> <TAB> region_count ( & reservations -> regions , start , end ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> kref_put ( & reservations -> refs , resv_map_release ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( reserve ) { <NEW_LINE> <TAB> <TAB> <TAB> hugetlb_acct_memory ( h , - reserve ) ;
proto_item * rsn_sub_pcs_item , * rsn_sub_akms_item ; <NEW_LINE> proto_tree * rsn_gcs_tree , * rsn_pcs_tree , * rsn_akms_tree , * rsn_cap_tree , * rsn_pmkid_tree , * rsn_gmcs_tree ; <NEW_LINE> proto_tree * rsn_sub_pcs_tree , * rsn_sub_akms_tree ; <NEW_LINE> <START_VULN> guint16 i , pcs_count , akms_count , pmkid_count ; <NEW_LINE> <END_VULN> int tag_end = offset + tag_len ; <NEW_LINE> proto_tree_add_item ( tree , hf_ieee80211_rsn_version , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;
<TAB> struct gs_usb * dev ; <NEW_LINE> <TAB> int rc = - ENOMEM ; <NEW_LINE> <TAB> unsigned int icount , i ; <NEW_LINE> <START_VULN> <TAB> struct gs_host_config hconf = { <NEW_LINE><TAB> <TAB> . byte_order = 0x0000beef , <NEW_LINE><TAB> } ; <NEW_LINE><TAB> struct gs_device_config dconf ; <NEW_LINE> <END_VULN> <TAB> rc = usb_control_msg ( interface_to_usbdev ( intf ) ,
<TAB> } else { <NEW_LINE> <TAB> <TAB> state -> list = cachep -> random_seq ; <NEW_LINE> <TAB> <TAB> state -> count = count ; <NEW_LINE> <START_VULN> <TAB> <TAB> state -> pos = 0 ; <NEW_LINE><TAB> <TAB> state -> rand = rand ; <NEW_LINE> <END_VULN> <TAB> <TAB> ret = true ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> return ret ;
<TAB> size_t noff , size_t doff , int * flags ) <NEW_LINE> { <NEW_LINE> <TAB> if ( namesz == 4 && strcmp ( ( char * ) & nbuf [ noff ] , "GNU" ) == 0 && <NEW_LINE> <START_VULN> <TAB> type == NT_GNU_BUILD_ID && ( descsz >= 4 || descsz <= 20 ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> uint8_t desc [ 20 ] ; <NEW_LINE> <TAB> <TAB> const char * btype ; <NEW_LINE> <TAB> <TAB> uint32_t i ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> KG_TOK_DEL_CTX ) ) ) <NEW_LINE> <TAB> <TAB> return ( majerr ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><NEW_LINE><TAB> return ( krb5_gss_delete_sec_context ( minor_status , & context_handle , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> GSS_C_NO_BUFFER ) ) ; <NEW_LINE> <END_VULN> }
#include "file . h" <NEW_LINE> #ifndef <TAB> lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File : softmagic . c , v 1 . 170 2014 / 01 / 06 02 : 25 : 32 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <TAB> <NEW_LINE> #include "magic . h"
<TAB> REG ( "make - it - fail" , S_IRUGO|S_IWUSR , proc_fault_inject_operations ) , <NEW_LINE> #endif <NEW_LINE> #ifdef CONFIG_TASK_IO_ACCOUNTING <NEW_LINE> <START_VULN> <TAB> INF ( "io" , <TAB> S_IRUGO , proc_tid_io_accounting ) , <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef CONFIG_HARDWALL <NEW_LINE> <TAB> INF ( "hardwall" , S_IRUGO , proc_pid_hardwall ) ,
void WalkDescendantsClearAncestorDirAuto ( mozilla : : dom : : Element * aElement ) ; <NEW_LINE> <START_VULN> void SetDirectionFromChangedTextNode ( nsIContent * aTextNode , uint32_t aOffset , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const char16_t * aBuffer , uint32_t aLength , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> bool aNotify ) ; <NEW_LINE> <END_VULN> void SetDirectionFromNewTextNode ( nsIContent * aTextNode ) ;
<TAB> OD ( nsExtEntityLogo , SEC_OID_NS_CERT_EXT_ENTITY_LOGO , <NEW_LINE> <TAB> "Certificate Entity Logo" , <NEW_LINE> <TAB> CKM_INVALID_MECHANISM , UNSUPPORTED_CERT_EXTENSION ) , <NEW_LINE> <TAB> OD ( nsExtUserPicture , SEC_OID_NS_CERT_EXT_USER_PICTURE , <NEW_LINE> <TAB> "Certificate User Picture" , <NEW_LINE> <TAB> CKM_INVALID_MECHANISM , UNSUPPORTED_CERT_EXTENSION ) , <NEW_LINE> <TAB> OD ( nsExtSSLServerName , SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME , <NEW_LINE> <TAB> "Certificate SSL Server Name" , <NEW_LINE> <START_VULN> <TAB> CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , <NEW_LINE> <END_VULN> <TAB> OD ( nsExtComment , SEC_OID_NS_CERT_EXT_COMMENT , <NEW_LINE> <TAB> "Certificate Comment" , <NEW_LINE> <TAB> CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , <NEW_LINE> <TAB> OD ( nsExtLostPasswordURL , SEC_OID_NS_CERT_EXT_LOST_PASSWORD_URL , <NEW_LINE> <TAB> <TAB> "Lost Password URL" , <NEW_LINE> <TAB> CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , <NEW_LINE> <TAB> OD ( nsExtCertRenewalTime , SEC_OID_NS_CERT_EXT_CERT_RENEWAL_TIME , <NEW_LINE> <TAB> "Certificate Renewal Time" ,
<TAB> <TAB> TrackTicks inputEndTicks = TimeToTicksRoundUp ( rate , inputEnd ) ; <NEW_LINE> <TAB> <TAB> TrackTicks inputStartTicks = inputEndTicks - ticks ; <NEW_LINE> <START_VULN> <TAB> <TAB> segment -> AppendSlice ( * inputTrack -> GetSegment ( ) , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> NS_MIN ( inputTrackEndPoint , inputStartTicks ) , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> NS_MIN ( inputTrackEndPoint , inputEndTicks ) ) ; <NEW_LINE> <TAB> <TAB> LOG ( PR_LOG_DEBUG , ( "TrackUnionStream % p appending % lld ticks of input data to track % d" , <NEW_LINE> <TAB> <TAB> <TAB> this , ( long long ) ( NS_MIN ( inputTrackEndPoint , inputEndTicks ) - NS_MIN ( inputTrackEndPoint , inputStartTicks ) ) , <NEW_LINE> <TAB> <TAB> <TAB> outputTrack -> GetID ( ) ) ) ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> for ( uint32_t j = 0 ; j < mListeners . Length ( ) ; + + j ) { <NEW_LINE> <TAB> <TAB> MediaStreamListener * l = mListeners [ j ] ;
<TAB> if ( msr -> request_content_length == - 1 ) { <NEW_LINE> <TAB> <TAB> char * transfer_encoding = ( char * ) apr_table_get ( msr -> request_headers , "Transfer - Encoding" ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , "chunked" ) != NULL ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> msr -> reqbody_should_exist = 1 ; <NEW_LINE> <TAB> <TAB> <TAB> msr -> reqbody_chunked = 1 ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> goto valid_alias ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> <TAB> RETURN_FALSE ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> av_log ( avctx , AV_LOG_ERROR , "width must be even for this colorspace\n" ) ; <NEW_LINE> <TAB> <TAB> return AVERROR_INVALIDDATA ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> <TAB> alloc_temp ( s ) ; <NEW_LINE> <TAB> return 0 ;
<TAB> } <NEW_LINE> <TAB> SetQuantumImageType ( image , quantum_type ) ; <NEW_LINE> next_tiff_frame : <NEW_LINE> <START_VULN> <TAB> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <NEW_LINE> <END_VULN> <TAB> if ( photometric == PHOTOMETRIC_CIELAB ) <NEW_LINE> <TAB> DecodeLabImage ( image , exception ) ; <NEW_LINE> <TAB> if ( ( photometric == PHOTOMETRIC_LOGL ) ||
<TAB> struct boot_sector b ; <NEW_LINE> <TAB> unsigned total_sectors ; <NEW_LINE> <TAB> unsigned short logical_sector_size , sectors ; <NEW_LINE> <START_VULN> <TAB> unsigned fat_length ; <NEW_LINE> <END_VULN> <TAB> unsigned total_fat_entries ; <NEW_LINE> <TAB> off_t data_size ;
<TAB> address = address & huge_page_mask ( h ) ; <NEW_LINE> <TAB> pgoff = vma_hugecache_offset ( h , vma , address ) ; <NEW_LINE> <START_VULN> <TAB> mapping = ( struct address_space * ) page_private ( page ) ; <NEW_LINE> <END_VULN> <TAB> if ( vm_flags & VM_NORESERVE ) <NEW_LINE> <TAB> <TAB> return 0 ;
<TAB> <TAB> new -> ns = ns ; <NEW_LINE> <TAB> <TAB> new -> uid = uid ; <NEW_LINE> <START_VULN> <TAB> <TAB> atomic_set ( & new -> count , 0 ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> spin_lock_irq ( & ucounts_lock ) ; <NEW_LINE> <TAB> <TAB> ucounts = find_ucounts ( ns , uid , hashent ) ;
<TAB> bee_t * bee = ic -> bee ; <NEW_LINE> <TAB> bee_user_t * bu = bee_user_by_handle ( bee , ic , handle ) ; <NEW_LINE> <START_VULN> <TAB> if ( bee -> ui -> ft_in_start ) { <NEW_LINE> <END_VULN> <TAB> <TAB> return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ; <NEW_LINE> <TAB> } else { <NEW_LINE> <TAB> <TAB> return NULL ;
<TAB> vcpu -> hv_clock . flags = pvclock_flags ; <NEW_LINE> <START_VULN> <TAB> memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock , <NEW_LINE><TAB> sizeof ( vcpu -> hv_clock ) ) ; <NEW_LINE><NEW_LINE><TAB> kunmap_atomic ( shared_kaddr ) ; <NEW_LINE><NEW_LINE><TAB> mark_page_dirty ( v -> kvm , vcpu -> time >> PAGE_SHIFT ) ; <NEW_LINE> <END_VULN> <TAB> return 0 ; <NEW_LINE> }
<TAB> case RXE_MEM_TYPE_MR : <NEW_LINE> <TAB> case RXE_MEM_TYPE_FMR : <NEW_LINE> <START_VULN> <TAB> <TAB> return ( ( iova < mem -> iova ) || <NEW_LINE><TAB> <TAB> <TAB> ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ? <NEW_LINE><TAB> <TAB> <TAB> - EFAULT : 0 ; <NEW_LINE> <END_VULN> <TAB> default : <NEW_LINE> <TAB> <TAB> return - EFAULT ;
<TAB> <TAB> if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && <NEW_LINE> <START_VULN> <TAB> <TAB> * p == SSL3_MT_CLIENT_HELLO ) && <NEW_LINE> <END_VULN> <TAB> <TAB> ! dtls1_record_replay_check ( s , bitmap ) ) <NEW_LINE> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> rr -> length = 0 ;
list_fields ( MYSQL * mysql , const char * db , const char * table , <NEW_LINE> <TAB> const char * wild ) <NEW_LINE> { <NEW_LINE> <START_VULN> char query [ 1024 ] , * end ; <NEW_LINE> <END_VULN> MYSQL_RES * result ; <NEW_LINE> MYSQL_ROW row ; <NEW_LINE> ulong UNINIT_VAR ( rows ) ;
<START_VULN> <NEW_LINE> <END_VULN> <TAB> <TAB> xasprintf ( & userstyle , " % s % s % s" , authctxt -> user , <NEW_LINE> <TAB> <TAB> authctxt -> style ? " : " : "" ,
<TAB> <TAB> <TAB> if ( p_stream -> p_headers ) <NEW_LINE> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> memcpy ( ( unsigned char * ) p_stream -> p_headers + p_stream -> i_headers - p_oggpacket -> bytes , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> p_oggpacket -> packet , p_stream -> i_headers ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> else <NEW_LINE> <TAB> <TAB> <TAB> {
<TAB> va_start ( argptr , format ) ; <NEW_LINE> <TAB> while ( ( c = * format + + ) ) <NEW_LINE> <START_VULN> <TAB> { <TAB> switch ( c ) <NEW_LINE> <END_VULN> <TAB> <TAB> { <TAB> case 'e' : <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> psf -> rwf_endian = SF_ENDIAN_LITTLE ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> break ;
MODULE_DESCRIPTION ( "T10 DIF CRC calculation accelerated with PCLMULQDQ . " ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "crct10dif" ) ; <NEW_LINE>MODULE_ALIAS ( "crct10dif - pclmul" ) ; <NEW_LINE> <END_VULN>
<TAB> Find pathnames matching a pattern * / <NEW_LINE> PHP_FUNCTION ( glob ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> int cwd_skip = 0 ; <NEW_LINE> <END_VULN> #ifdef ZTS <NEW_LINE> <TAB> char cwd [ MAXPATHLEN ] ; <NEW_LINE> <TAB> char work_pattern [ MAXPATHLEN ] ;
<TAB> if ( ! ip_checkentry ( & e -> ip ) ) <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <START_VULN> <TAB> ret = xt_compat_check_entry_offsets ( e , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> e -> target_offset , e -> next_offset ) ; <NEW_LINE> <TAB> if ( ret ) <NEW_LINE> <TAB> <TAB> return ret ;
<TAB> <TAB> phar_flush ( entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> <TAB> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> efree ( error ) ; <NEW_LINE> <TAB> <TAB> <TAB> RETURN_FALSE ; <NEW_LINE> <TAB> <TAB> } else {
<TAB> c -> interfaces_offset < <NEW_LINE> <TAB> <TAB> bin -> header . data_offset + bin -> header . data_size ) { <NEW_LINE> <TAB> <TAB> p = r_buf_get_at ( binfile -> buf , c -> interfaces_offset , NULL ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> int types_list_size = r_read_le32 ( p ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( types_list_size < 0 || types_list_size >= bin -> header . types_size ) { <NEW_LINE> <TAB> <TAB> <TAB> return ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> spin_lock ( & sbinfo -> stat_lock ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( sbinfo -> max_blocks >= 0 ) { <NEW_LINE><TAB> <TAB> <TAB> buf -> f_blocks = sbinfo -> max_blocks ; <NEW_LINE><TAB> <TAB> <TAB> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> buf -> f_files = sbinfo -> max_inodes ; <NEW_LINE> <TAB> <TAB> <TAB> buf -> f_ffree = sbinfo -> free_inodes ; <NEW_LINE> <TAB> <TAB> }
<TAB> <TAB> return - ENETUNREACH ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> if ( inet -> opt == NULL || ! inet -> opt -> srr ) <NEW_LINE> <END_VULN> <TAB> <TAB> daddr = rt -> rt_dst ; <NEW_LINE> <TAB> if ( inet -> inet_saddr == 0 )
<TAB> <TAB> <TAB> send_cookie = 0 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ! PS ( id ) && <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> zend_hash_find ( & EG ( symbol_table ) , "_POST" , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> sizeof ( "_POST" ) , ( void ** ) & data ) == SUCCESS && <NEW_LINE> <TAB> <TAB> <TAB> <TAB> Z_TYPE_PP ( data ) == IS_ARRAY &&
<TAB> ( unsigned long long ) fs -> fat_start , <NEW_LINE> <TAB> ( unsigned long long ) fs -> fat_start / lss ) ; <NEW_LINE> <TAB> printf ( " % 10d FATs , % d bit entries\n" , b -> fats , fs -> fat_bits ) ; <NEW_LINE> <START_VULN> <TAB> printf ( " % 10d bytes per FAT ( = % u sectors ) \n" , fs -> fat_size , <NEW_LINE><TAB> fs -> fat_size / lss ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! fs -> root_cluster ) { <NEW_LINE> <TAB> printf ( "Root directory starts at byte % llu ( sector % llu ) \n" , <NEW_LINE> <TAB> ( unsigned long long ) fs -> root_start ,
<TAB> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && <NEW_LINE> <TAB> <TAB> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) <NEW_LINE> <TAB> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE> <START_VULN> <TAB> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length , <NEW_LINE><TAB> sizeof ( * sun_data ) ) ; <NEW_LINE> <END_VULN> <TAB> if ( sun_data == ( unsigned char * ) NULL ) <NEW_LINE> <TAB> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <TAB> count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ;
} ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> static OM_uint32 KRB5_CALLCONV <NEW_LINE> <END_VULN> krb5_gss_set_sec_context_option ( OM_uint32 * minor_status , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> gss_ctx_id_t * context_handle , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> const gss_OID desired_object ,
<TAB> } else { <NEW_LINE> <TAB> if ( isDH ) master_derive = CKM_SSL3_MASTER_KEY_DERIVE_DH ; <NEW_LINE> <TAB> else master_derive = CKM_SSL3_MASTER_KEY_DERIVE ; <NEW_LINE> <TAB> key_derive = CKM_SSL3_KEY_AND_MAC_DERIVE ; <NEW_LINE> <TAB> keyFlags = 0 ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( pms || ! pwSpec -> master_secret ) { <NEW_LINE> <START_VULN> <TAB> master_params . pVersion = & pms_version ; <NEW_LINE> <END_VULN> <TAB> master_params . RandomInfo . pClientRandom = cr ; <NEW_LINE> <TAB> master_params . RandomInfo . ulClientRandomLen = SSL3_RANDOM_LENGTH ; <NEW_LINE> <TAB> master_params . RandomInfo . pServerRandom = sr ; <NEW_LINE> <TAB> master_params . RandomInfo . ulServerRandomLen = SSL3_RANDOM_LENGTH ; <NEW_LINE> <TAB> params . data = ( unsigned char * ) & master_params ; <NEW_LINE> <TAB> params . len = sizeof master_params ; <NEW_LINE> <TAB> }
