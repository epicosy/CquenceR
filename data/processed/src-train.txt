} <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> <START_VULN> pCur -> iPtr = 0 ; <NEW_LINE> <END_VULN> pCur -> iCnt = 0 ; <NEW_LINE> } <NEW_LINE> pCur -> iRowid = 1 ;
} ; <NEW_LINE> static const uint32_t ISO2022JPCharLenTable [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; <NEW_LINE> const SMModel ISO2022JPSMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , ISO2022JP_cls } , <NEW_LINE> 10 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , ISO2022JP_st } , <NEW_LINE> <START_VULN> ISO2022JPCharLenTable , <NEW_LINE> <END_VULN> "ISO - 2022 - JP" , <NEW_LINE> } ; <NEW_LINE> static const uint32_t ISO2022KR_cls [ 256 / 8 ] = { <NEW_LINE> PCK4BITS ( 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) , <NEW_LINE> PCK4BITS ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) , <NEW_LINE> PCK4BITS ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) , <NEW_LINE> PCK4BITS ( 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ) ,
} <NEW_LINE> } <NEW_LINE> <START_VULN> SkipDXTMipmaps ( image , dds_info , 8 ) ; <NEW_LINE><NEW_LINE>return MagickTrue ; <NEW_LINE> <END_VULN> } <NEW_LINE> static MagickBooleanType ReadDXT3 ( Image * image , DDSInfo * dds_info ,
int vorbis_synthesis_headerin ( vorbis_info * vi , vorbis_comment * vc , ogg_packet * op ) { <NEW_LINE> oggpack_buffer opb ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( op ) { <NEW_LINE> oggpack_readinit ( & opb , op -> packet , op -> bytes ) ; <NEW_LINE> { <NEW_LINE> char buffer [ 6 ] ; <NEW_LINE> int packtype = oggpack_read ( & opb , 8 ) ;
downscaling using the fixed point implementations are usually much faster <NEW_LINE> than the existing gdImageCopyResampled while having a similar or better <NEW_LINE> quality . <NEW_LINE> <START_VULN> <NEW_LINE>For image rotations , the optimized versions have a lazy antialiasing for <NEW_LINE> <END_VULN> the edges of the images . For a much better antialiased result , the affine <NEW_LINE> function is recommended .
} <NEW_LINE> } <NEW_LINE> return aIterator -> GetSkippedOffset ( ) ; <NEW_LINE> } <NEW_LINE> void nsTextFrame::MarkIntrinsicWidthsDirty ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> ClearTextRun ( ) ; <NEW_LINE> <END_VULN> nsFrame::MarkIntrinsicWidthsDirty ( ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsTextFrame::AddInlineMinWidthForFlow ( nsIRenderingContext * aRenderingContext , <NEW_LINE> nsIFrame::InlineMinWidthData * aData )
cupsdSetString ( & job -> username , con -> username ) ; <NEW_LINE> if ( attr ) <NEW_LINE> <START_VULN> cupsdSetString ( & attr -> values [ 0 ] . string . text , con -> username ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else if ( attr ) <NEW_LINE> {
return JSVAL_NULL ; <NEW_LINE> } <NEW_LINE> nsIScriptContext * scriptContext = sgo -> GetScriptContext ( ) ; <NEW_LINE> if ( ! scriptContext ) { <NEW_LINE> return JSVAL_NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSContext * cx = scriptContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> if ( ! cx ) { <NEW_LINE> return JSVAL_NULL ; <NEW_LINE> } <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> jsval result = JSVAL_NULL ; <NEW_LINE> if ( ! xpc::StringToJsval ( cx , aString , & result ) ) {
nsCOMPtr < nsIConsoleService > consoleService <NEW_LINE> ( do_GetService ( "@mozilla . org / consoleservice ; 1" ) ) ; <NEW_LINE> if ( consoleService ) { <NEW_LINE> consoleService -> LogStringMessage ( NS_LITERAL_STRING ( "Deprecated method document . getSelection ( ) called . Please use window . getSelection ( ) instead . " ) . get ( ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsIDOMWindow * window = GetWindow ( ) ; <NEW_LINE>NS_ENSURE_TRUE ( window , NS_OK ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsISelection > selection ; <NEW_LINE> nsresult rv = window -> GetSelection ( getter_AddRefs ( selection ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( selection && NS_SUCCEEDED ( rv ) , rv ) ; <NEW_LINE> nsXPIDLString str ; <NEW_LINE> rv = selection -> ToString ( getter_Copies ( str ) ) ;
} <NEW_LINE> <START_VULN> CWD_API realpath_cache_bucket * realpath_cache_lookup ( const char * path , int path_len , time_t t ) <NEW_LINE> <END_VULN> { <NEW_LINE> return realpath_cache_find ( path , path_len , t ) ; <NEW_LINE> }
nsresult <NEW_LINE> nsHTMLPluginObjElementSH::SetupProtoChain ( nsIXPConnectWrappedNative * wrapper , <NEW_LINE> JSContext * cx , <NEW_LINE> JSObject * obj ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( nsContentUtils::IsSafeToRunScript ( ) , <NEW_LINE> "Shouldn't have gotten in here" ) ; <NEW_LINE> <START_VULN> <NEW_LINE>nsCxPusher cxPusher ; <NEW_LINE>if ( ! cxPusher . Push ( cx , nsCxPusher::REQUIRE_SCRIPT_CONTEXT ) ) { <NEW_LINE>return NS_OK ; <NEW_LINE> } <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , obj ) ; <NEW_LINE> nsRefPtr < nsNPAPIPluginInstance > pi ; <NEW_LINE> nsresult rv = GetPluginInstanceIfSafe ( wrapper , obj , cx , getter_AddRefs ( pi ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
if ( mod_loc_name == NULL ) { <NEW_LINE> mod_loc_name = estrdup ( loc_name ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ! disp_loc_name ) { <NEW_LINE> disp_loc_name = estrdup ( intl_locale_get_default ( TSRMLS_C ) ) ;
<START_VULN> return mutt_bcache_del ( bcache , id ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef USE_HCACHE
unsigned int count_sat , <NEW_LINE> unsigned int update_factor ) { <NEW_LINE> const FRAME_CONTEXT * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] ; <NEW_LINE> <START_VULN> vp9_coeff_probs_model * const probs = cm -> fc . coef_probs [ tx_size ] ; <NEW_LINE> <END_VULN> const vp9_coeff_probs_model * const pre_probs = pre_fc -> coef_probs [ tx_size ] ; <NEW_LINE> vp9_coeff_count_model * counts = cm -> counts . coef [ tx_size ] ; <NEW_LINE> unsigned int ( * eob_counts ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] =
sk_sp < SkPixelRef > SkMallocPixelRef::MakeZeroed ( const SkImageInfo & info , <NEW_LINE> size_t rowBytes ) { <NEW_LINE> <START_VULN> return MakeUsing ( sk_calloc , info , rowBytes ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void sk_data_releaseproc ( void * , void * dataPtr ) {
if ( ! aNPP ) <NEW_LINE> return NPERR_INVALID_INSTANCE_ERROR ; <NEW_LINE> nsCString url = NullableString ( aRelativeURL ) ; <NEW_LINE> StreamNotifyChild * sn = new StreamNotifyChild ( url ) ; <NEW_LINE> NPError err ; <NEW_LINE> <START_VULN> InstCast ( aNPP ) -> CallPStreamNotifyConstructor ( <NEW_LINE>sn , url , NullableString ( aTarget ) , false , nsCString ( ) , false , & err ) ; <NEW_LINE> <END_VULN> if ( NPERR_NO_ERROR == err ) { <NEW_LINE> sn -> SetValid ( aNotifyData ) ; <NEW_LINE> } <NEW_LINE> return err ;
continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> CHECK ( dstOffset + 4 <= ( * buffer ) -> size ( ) ) ; <NEW_LINE> <END_VULN> dstData [ dstOffset ++ ] = 0 ; <NEW_LINE> dstData [ dstOffset ++ ] = 0 ;
u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , <NEW_LINE> pu4_bitstrm_buf ) ; <NEW_LINE> if ( u4_idr_pic_id > 65535 ) <NEW_LINE> <START_VULN> return ERROR_INV_SPS_PPS_T ; <NEW_LINE> <END_VULN> COPYTHECONTEXT ( "SH: " , u4_idr_pic_id ) ; <NEW_LINE> }
const __m128i zero = _mm_setzero_si128 ( ) ; <NEW_LINE> const __m128i eight = _mm_set1_epi16 ( 8 ) ; <NEW_LINE> <START_VULN> in [ 0 ] = _mm_loadu_si128 ( ( const __m128i * ) ( input ) ) ; <NEW_LINE>in [ 1 ] = _mm_loadu_si128 ( ( const __m128i * ) ( input + 8 ) ) ; <NEW_LINE> <END_VULN> switch ( tx_type ) { <NEW_LINE> case 0:
char ps_name [ MAX_RDS_PS_NAME + 1 ] ; <NEW_LINE> len = control -> size - 1 ; <NEW_LINE> <START_VULN> if ( len > MAX_RDS_PS_NAME ) { <NEW_LINE> <END_VULN> rval = - ERANGE ; <NEW_LINE> goto exit ; <NEW_LINE> }
} <NEW_LINE> bool <NEW_LINE> GetElementIC::attachTypedArrayElement ( JSContext * cx , IonScript * ion , TypedArrayObject * tarr , <NEW_LINE> const Value & idval ) <NEW_LINE> { <NEW_LINE> MacroAssembler masm ( cx , ion ) ; <NEW_LINE> RepatchStubAppender attacher ( * this ) ; <NEW_LINE> <START_VULN> GenerateGetTypedArrayElement ( cx , masm , attacher , tarr , idval , object ( ) , index ( ) , output ( ) ) ; <NEW_LINE> <END_VULN> return linkAndAttachStub ( cx , masm , attacher , ion , "typed array" ) ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> GetElementIC::attachArgumentsElement ( JSContext * cx , IonScript * ion , JSObject * obj ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( obj -> is < ArgumentsObject > ( ) ) ;
<START_VULN> if ( transforms & PNG_TRANSFORM_GRAY_TO_RGB ) <NEW_LINE> <END_VULN> #ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED <NEW_LINE> png_set_gray_to_rgb ( png_ptr ) ; <NEW_LINE> #else
c = * cp ; <NEW_LINE> if ( c == ' / ' || c == '\0' ) { <NEW_LINE> * cp = '\0' ; <NEW_LINE> <START_VULN> key = stok ( term , " = " , & value ) ; <NEW_LINE> <END_VULN> if ( smatch ( key , "emailAddress" ) ) { <NEW_LINE> key = "EMAIL" ; <NEW_LINE> }
} <NEW_LINE> bsi -> rdstat [ i ] [ mode_idx ] . brate = <NEW_LINE> <START_VULN> labels2mode ( cpi , xd , i , this_mode , mode_mv [ this_mode ] , frame_mv , <NEW_LINE>seg_mvs [ i ] , bsi -> ref_mv , x -> nmvjointcost , x -> mvcost ) ; <NEW_LINE> <END_VULN> for ( ref = 0 ; ref < 1 + has_second_rf ; ++ ref ) { <NEW_LINE> bsi -> rdstat [ i ] [ mode_idx ] . mvs [ ref ] . as_int =
return intpart ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void <NEW_LINE> <END_VULN> fmtfp ( char ** sbuffer , <NEW_LINE> char ** buffer , <NEW_LINE> size_t * currlen ,
PRBool forceWriteOnly = res . mIsWriteOnly ; <NEW_LINE> if ( mCanvasElement ) <NEW_LINE> <START_VULN> CanvasUtils::DoDrawImageSecurityCheck ( mCanvasElement , principal , forceWriteOnly ) ; <NEW_LINE> <END_VULN> gfxContextPathAutoSaveRestore pathSR ( mThebes , PR_FALSE ) ;
for ( Node & node : NodeTraversal::inclusiveDescendantsOf ( root ) ) { <NEW_LINE> <START_VULN> <NEW_LINE>if ( ! inDocument ( ) && ! node . isContainerNode ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( Node::InsertionShouldCallDidNotifySubtreeInsertions == node . insertedInto ( this ) ) <NEW_LINE> postInsertionNotificationTargets . append ( & node ) ;
<START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> nsresult <NEW_LINE> nsCookieService::GetBaseDomain ( nsIURI * aHostURI , <NEW_LINE> nsCString & aBaseDomain , <NEW_LINE> PRBool & aRequireHostMatch ) <NEW_LINE> { <NEW_LINE> nsresult rv = mTLDService -> GetBaseDomain ( aHostURI , 0 , aBaseDomain ) ;
#warning No alignment directives known for this compiler . <NEW_LINE> #define DECLARE_ALIGNED ( n , typ , val ) typ val <NEW_LINE> #endif <NEW_LINE> <START_VULN> #endif <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>#define DECLARE_ALIGNED_ARRAY ( a , typ , val , n ) \ <NEW_LINE>typ val##_ [ ( n ) + ( a ) / sizeof ( typ ) + 1 ] ; \ <NEW_LINE>typ * val = ( typ * ) ( ( ( ( intptr_t ) val##_ ) + ( a ) - 1 ) & ( ( intptr_t ) - ( a ) ) ) <NEW_LINE><NEW_LINE> <END_VULN> #endif
} <NEW_LINE> else if ( ( 0 == ps_pps -> i1_entropy_coding_sync_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && ( 0 != ps_codec -> s_parse . i4_ctb_x ) ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <NEW_LINE> & ps_codec -> s_parse . s_bitstrm , <NEW_LINE>slice_qp , <NEW_LINE>cabac_init_idc , <NEW_LINE> & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; <NEW_LINE> <END_VULN> }
void LocalFileSystem::resolveURLInternal ( <NEW_LINE> PassRefPtrWillBeRawPtr < ExecutionContext > context , <NEW_LINE> const KURL & fileSystemURL , <NEW_LINE> <START_VULN> PassRefPtr < CallbackWrapper > callbacks ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ! fileSystem ( ) ) { <NEW_LINE> fileSystemNotAvailable ( context , callbacks ) ;
} <NEW_LINE> void BufferQueueConsumer::dump ( String8 & result , const char * prefix ) const { <NEW_LINE> <START_VULN> mCore -> dump ( result , prefix ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
<START_VULN> if ( ( id == 0x0F43B675 ) || ( id == 0x0C53BB6B ) ) <NEW_LINE> { <NEW_LINE> <END_VULN> element_size = pos - element_start ; <NEW_LINE> assert ( element_size > 0 ) ;
while ( u4_start_code == USER_DATA_START_CODE ) <NEW_LINE> { <NEW_LINE> impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; <NEW_LINE> <START_VULN> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <NEW_LINE> <END_VULN> { <NEW_LINE> impeg2d_bit_stream_flush ( ps_stream , 8 ) ; <NEW_LINE> }
<START_VULN> int test_main ( int argc , char * argv [ ] ) ; <NEW_LINE> <END_VULN> #define main ( ) 		test_main ( int argc , char * argv [ ] ) <NEW_LINE> \ No newline at end of file
* a = tempa ; <NEW_LINE> * l = templ ; <NEW_LINE> copy_predictor ( best_predictor , b -> predictor ) ; <NEW_LINE> <START_VULN> vpx_memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> b -> bmi . as_mode = * best_mode ;
PRUint32 invariant = elementsToAppend + mElements . Count ( ) ; <NEW_LINE> #endif <NEW_LINE> if ( count != 0 ) { <NEW_LINE> <START_VULN> PopulateWithStartingAfter ( NS_STATIC_CAST ( nsIContent * , <NEW_LINE>mElements . ElementAt ( count - 1 ) ) , <NEW_LINE>nsnull , <NEW_LINE>elementsToAppend ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( elementsToAppend + mElements . Count ( ) == invariant , <NEW_LINE> "Something is awry in PopulateWithStartingAfter ! " ) ; <NEW_LINE> } else if ( mRootContent ) {
JS_ASSERT_IF ( callerFrame , tcflags & TCF_COMPILE_N_GO ) ; <NEW_LINE> JS_ASSERT_IF ( staticLevel != 0 , callerFrame ) ; <NEW_LINE> <START_VULN> Parser parser ( cx , principals , callerFrame ) ; <NEW_LINE> <END_VULN> if ( ! parser . init ( chars , length , filename , lineno , version ) ) <NEW_LINE> return NULL ; <NEW_LINE> TokenStream & tokenStream = parser . tokenStream ; <NEW_LINE> BytecodeEmitter bce ( & parser , tokenStream . getLineno ( ) ) ; <NEW_LINE> if ( ! bce . init ( cx , TreeContext::USED_AS_TREE_CONTEXT ) ) <NEW_LINE> return NULL ;
png_ptr -> flags &= ~ ( PNG_FLAG_BENIGN_ERRORS_WARN | <NEW_LINE> PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
SoftAACEncoder2:: ~ SoftAACEncoder2 ( ) { <NEW_LINE> aacEncClose ( & mAACEncoder ) ; <NEW_LINE> <START_VULN> delete [ ] mInputFrame ; <NEW_LINE>mInputFrame = NULL ; <NEW_LINE> <END_VULN> } <NEW_LINE> void SoftAACEncoder2::initPorts ( ) {
} <NEW_LINE> if ( r == 0 ) { <NEW_LINE> printf ( "Empty directory\n" ) ; <NEW_LINE> <START_VULN> } else <NEW_LINE>for ( i = 0 ; i < r / 2 ; i ++ ) { <NEW_LINE>sc_path_t tmppath ; <NEW_LINE><NEW_LINE>memset ( & tmppath , 0 , sizeof ( tmppath ) ) ; <NEW_LINE>memcpy ( & tmppath , & path , sizeof ( path ) ) ; <NEW_LINE>memcpy ( tmppath . value + tmppath . len , files + 2 * i , 2 ) ; <NEW_LINE>tmppath . len += 2 ; <NEW_LINE>enum_dir ( tmppath , depth + 1 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> return 0 ;
INC_STATS ( "DOM . WebGLRenderingContext . getAttachedShaders ( ) " ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> WebGLRenderingContext * context = V8WebGLRenderingContext::toNative ( args . Holder ( ) ) ;
const SVGDocumentExtensions * SvgExtensions ( ) ; <NEW_LINE> SVGDocumentExtensions & AccessSVGExtensions ( ) ; <NEW_LINE> <START_VULN> void InitContentSecurityPolicy ( ContentSecurityPolicy * = nullptr ) ; <NEW_LINE> <END_VULN> bool IsSecureTransitionTo ( const KURL & ) const ;
class SearchProvider : public AutocompleteProvider , <NEW_LINE> public net::URLFetcherDelegate { <NEW_LINE> public: <NEW_LINE> <START_VULN> SearchProvider ( ACProviderListener * listener , Profile * profile ) ; <NEW_LINE> <END_VULN> #if defined ( UNIT_TEST ) <NEW_LINE> static void set_query_suggest_immediately ( bool value ) {
return current -> prevType ( ) ; <NEW_LINE> } <NEW_LINE> inline bool <NEW_LINE> IonFrameIterator::isFakeExitFrame ( ) const <NEW_LINE> { <NEW_LINE> bool res = ( prevType ( ) == JitFrame_Unwound_Rectifier || <NEW_LINE> prevType ( ) == JitFrame_Unwound_IonJS || <NEW_LINE> <START_VULN> prevType ( ) == JitFrame_Unwound_BaselineStub ) ; <NEW_LINE> <END_VULN> JS_ASSERT_IF ( res , type ( ) == JitFrame_Exit || type ( ) == JitFrame_BaselineJS ) ; <NEW_LINE> return res ; <NEW_LINE> } <NEW_LINE> inline IonExitFrameLayout * <NEW_LINE> IonFrameIterator::exitFrame ( ) const <NEW_LINE> { <NEW_LINE> JS_ASSERT ( type ( ) == JitFrame_Exit ) ;
SkColor thumb_inactive_color ; <NEW_LINE> SkColor track_color ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> SkColor active_selection_bg_color ; <NEW_LINE> SkColor active_selection_fg_color ; <NEW_LINE> SkColor inactive_selection_bg_color ;
struct nfsd4_layoutget * lgp ) <NEW_LINE> { <NEW_LINE> struct xdr_stream * xdr = & resp -> xdr ; <NEW_LINE> <START_VULN> const struct nfsd4_layout_ops * ops = <NEW_LINE>nfsd4_layout_ops [ lgp -> lg_layout_type ] ; <NEW_LINE> <END_VULN> __be32 * p ; <NEW_LINE> dprintk ( " % s: err % d\n" , __func__ , nfserr ) ;
{ <NEW_LINE> png_debug ( 1 , "in png_set_strip_16" ) ; <NEW_LINE> <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> png_ptr -> transformations |= PNG_16_TO_8 ;
if ( IsAnimValList ( ) ) { <NEW_LINE> Element ( ) -> FlushAnimations ( ) ; <NEW_LINE> } <NEW_LINE> return LengthNoFlush ( ) ; <NEW_LINE> } <NEW_LINE> void Clear ( ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < nsISVGPoint > Initialize ( nsISVGPoint & aNewItem , <NEW_LINE> ErrorResult & aError ) ; <NEW_LINE> <START_VULN> nsISVGPoint * GetItem ( uint32_t aIndex , ErrorResult & aError ) <NEW_LINE> { <NEW_LINE>bool found ; <NEW_LINE>nsISVGPoint * item = IndexedGetter ( aIndex , found , aError ) ; <NEW_LINE>if ( ! found ) { <NEW_LINE>aError . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; <NEW_LINE> } <NEW_LINE>return item ; <NEW_LINE> } <NEW_LINE>nsISVGPoint * IndexedGetter ( uint32_t aIndex , bool & aFound , <NEW_LINE>ErrorResult & aError ) ; <NEW_LINE> <END_VULN> already_AddRefed < nsISVGPoint > InsertItemBefore ( nsISVGPoint & aNewItem , <NEW_LINE> uint32_t aIndex , <NEW_LINE> ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < nsISVGPoint > ReplaceItem ( nsISVGPoint & aNewItem , <NEW_LINE> uint32_t aIndex , <NEW_LINE> ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < nsISVGPoint > RemoveItem ( uint32_t aIndex , <NEW_LINE> ErrorResult & aError ) ;
<START_VULN> RenderInline * isolatedInline = toRenderInline ( containingIsolate ( startObj , currentRoot ) ) ; <NEW_LINE> <END_VULN> InlineBidiResolver isolatedResolver ; <NEW_LINE> EUnicodeBidi unicodeBidi = isolatedInline -> style ( ) -> unicodeBidi ( ) ;
errorPageUrl . AppendLiteral ( " & d = " ) ; <NEW_LINE> errorPageUrl . AppendASCII ( escapedDescription . get ( ) ) ; <NEW_LINE> nsCOMPtr < nsIURI > errorPageURI ; <NEW_LINE> rv = NS_NewURI ( getter_AddRefs ( errorPageURI ) , errorPageUrl ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> return InternalLoad ( errorPageURI , nullptr , mozilla::net::RP_Default , <NEW_LINE> <END_VULN> nullptr , INTERNAL_LOAD_FLAGS_INHERIT_OWNER , nullptr , <NEW_LINE> nullptr , NullString ( ) , nullptr , nullptr , LOAD_ERROR_PAGE , <NEW_LINE> nullptr , true , NullString ( ) , this , nullptr , nullptr , <NEW_LINE> nullptr ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsDocShell::Reload ( uint32_t aReloadFlags )
PRBool ExpectSymbol ( PRUnichar aSymbol , PRBool aSkipWS ) ; <NEW_LINE> PRBool ExpectEndProperty ( ) ; <NEW_LINE> PRBool CheckEndProperty ( ) ; <NEW_LINE> nsSubstring * NextIdent ( ) ; <NEW_LINE> void SkipUntil ( PRUnichar aStopSymbol ) ; <NEW_LINE> void SkipUntilOneOf ( const PRUnichar * aStopSymbolChars ) ; <NEW_LINE> void SkipRuleSet ( PRBool aInsideBraces ) ; <NEW_LINE> <START_VULN> PRBool SkipAtRule ( ) ; <NEW_LINE> <END_VULN> PRBool SkipDeclaration ( PRBool aCheckForBraces ) ; <NEW_LINE> PRBool GetNonCloseParenToken ( PRBool aSkipWS ) ; <NEW_LINE> PRBool PushGroup ( nsICSSGroupRule * aRule ) ; <NEW_LINE> void PopGroup ( void ) ; <NEW_LINE> PRBool ParseRuleSet ( RuleAppendFunc aAppendFunc , void * aProcessData , <NEW_LINE> PRBool aInsideBraces = PR_FALSE ) ;
nsIURI * uri = doc -> GetDocumentURI ( ) ; <NEW_LINE> if ( uri ) { <NEW_LINE> uri -> GetSpec ( url ) ; <NEW_LINE> lineNo = 1 ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> if ( aNeedsCxPush && ! pusher . Push ( cx , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> uint32_t argCount ; <NEW_LINE> const char ** argNames ;
fseek ( ifp , save , SEEK_SET ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #line 6130 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> int CLASS parse_tiff_ifd ( int base ) <NEW_LINE> { <NEW_LINE> unsigned entries , tag , type , len , plen = 16 , save ;
NS_ASSERTION ( mViewManager , "Must have view manager" ) ; <NEW_LINE> nsCOMPtr < nsIViewManager > viewManagerDeathGrip = mViewManager ; <NEW_LINE> nsIViewManager::UpdateViewBatch batch ( mViewManager ) ; <NEW_LINE> nsCOMPtr < nsIPresShell > kungFuDeathGrip ( this ) ; <NEW_LINE> <START_VULN> mFrameConstructor -> ProcessPendingRestyles ( ) ; <NEW_LINE> <END_VULN> if ( ! mIsDestroying ) { <NEW_LINE> { <NEW_LINE> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE> WillDoReflow ( ) ;
inline <NEW_LINE> InitialShapeEntry::InitialShapeEntry ( const ReadBarriered < Shape > & shape , TaggedProto proto ) <NEW_LINE> : shape ( shape ) , proto ( proto ) <NEW_LINE> { <NEW_LINE> } <NEW_LINE> inline InitialShapeEntry::Lookup <NEW_LINE> <START_VULN> InitialShapeEntry::getLookup ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> return Lookup ( shape -> getObjectClass ( ) , proto , shape -> getObjectParent ( ) , <NEW_LINE> shape -> numFixedSlots ( ) , shape -> getObjectFlags ( ) ) ; <NEW_LINE> } <NEW_LINE> inline HashNumber <NEW_LINE> InitialShapeEntry::hash ( const Lookup & lookup ) <NEW_LINE> {
for ( int i = 0 ; i < tk -> i_subpacket_h / 2 ; i ++ ) <NEW_LINE> { <NEW_LINE> block_t * p_block = block_New ( p_demux , tk -> i_coded_frame_size ) ; <NEW_LINE> if ( ! p_block ) <NEW_LINE> return ; <NEW_LINE> if ( & p_buf [ tk -> i_coded_frame_size ] > & p_sys -> buffer [ p_sys -> i_buffer ] ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> <NEW_LINE>int i_index = ( i * 2 * tk -> i_frame_size / tk -> i_coded_frame_size ) + y ; <NEW_LINE> <END_VULN> memcpy ( p_block -> p_buffer , p_buf , tk -> i_coded_frame_size ) ; <NEW_LINE> p_block -> i_dts =
} <NEW_LINE> } <NEW_LINE> <START_VULN> good = ( unsigned ) - 1 ; <NEW_LINE> <END_VULN> minLength = crSpec -> mac_size ; <NEW_LINE> if ( cipher_def -> type == type_block ) {
{ <NEW_LINE> switch ( pn -> pn_type ) { <NEW_LINE> case TOK_NAME: <NEW_LINE> NoteLValue ( cx , pn , tc ) ; <NEW_LINE> case TOK_DOT: <NEW_LINE> case TOK_LB: <NEW_LINE> <START_VULN> pn -> pn_op = JSOP_SETNAME ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case TOK_LP: <NEW_LINE> if ( ! MakeSetCall ( cx , pn , tc , JSMSG_BAD_LEFTSIDE_OF_ASS ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> break ; <NEW_LINE> #if JS_HAS_XML_SUPPORT
mm_segment_t seg ; <NEW_LINE> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , <NEW_LINE> <START_VULN> 1 , 0 , regs , regs -> cp0_badvaddr ) ; <NEW_LINE> <END_VULN>
m_anSofHorzSampFact_Hi [ nCompIdent ] = ( anSofSampFact [ nCompIdent ] & 0xF0 ) >> 4 ; <NEW_LINE> m_anSofVertSampFact_Vi [ nCompIdent ] = ( anSofSampFact [ nCompIdent ] & 0x0F ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> <NEW_LINE> <NEW_LINE> }
JSJavaThreadState * jsj_env = NULL ; <NEW_LINE> JSObjectHandle * handle = ( JSObjectHandle * ) obj ; <NEW_LINE> JSObject * js_obj = handle -> js_obj ; <NEW_LINE> JSContext * cx = NULL ; <NEW_LINE> jobject member = NULL ; <NEW_LINE> jsval js_val ; <NEW_LINE> int dummy_cost = 0 ; <NEW_LINE> JSBool dummy_bool = PR_FALSE ; <NEW_LINE> JSErrorReporter saved_state = NULL ; <NEW_LINE> jsj_env = jsj_enter_js ( jEnv , mJavaClient , NULL , & cx , NULL , & saved_state , principalsArray , numPrincipals , securitySupports ) ; <NEW_LINE> if ( ! jsj_env ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> <START_VULN> AutoPushJSContext autopush ( securitySupports , cx ) ; <NEW_LINE>if ( NS_FAILED ( autopush . ResultOfPush ( ) ) ) <NEW_LINE>goto done ; <NEW_LINE><NEW_LINE> <END_VULN> if ( ! JS_GetElement ( cx , js_obj , slot , & js_val ) ) <NEW_LINE> goto done ; <NEW_LINE> if ( ! jsj_ConvertJSValueToJavaObject ( cx , jEnv , js_val , jsj_get_jlObject_descriptor ( cx , jEnv ) , <NEW_LINE> & dummy_cost , & member , & dummy_bool ) ) <NEW_LINE> goto done ; <NEW_LINE> done: <NEW_LINE> if ( ! jsj_exit_js ( cx , jsj_env , saved_state ) )
{ <NEW_LINE> char sig_recv = 0 ; <NEW_LINE> <START_VULN> recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
free ( devices ) ; <NEW_LINE> devices = NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> return 1 ; <NEW_LINE> <END_VULN> }
NS_ASSERTION ( valueList != 0 , "ran out of memory" ) ; <NEW_LINE> return valueList ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsComputedDOMStyle::GetOffsetWidthFor ( PRUint8 aSide , nsIDOMCSSValue ** aValue ) <NEW_LINE> { <NEW_LINE> <START_VULN> const nsStyleDisplay * display = GetStyleDisplay ( ) ; <NEW_LINE><NEW_LINE>FlushPendingReflows ( ) ; <NEW_LINE> <END_VULN> nsresult rv = NS_OK ; <NEW_LINE> switch ( display -> mPosition ) { <NEW_LINE> case NS_STYLE_POSITION_STATIC: <NEW_LINE> rv = GetStaticOffset ( aSide , aValue ) ; <NEW_LINE> break ; <NEW_LINE> case NS_STYLE_POSITION_RELATIVE: <NEW_LINE> rv = GetRelativeOffset ( aSide , aValue ) ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( fields ) <NEW_LINE> {
goto error ; <NEW_LINE> rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , <NEW_LINE> <START_VULN> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; <NEW_LINE> <END_VULN> for ( d = alldevs ; d != NULL ; d = d -> next )
} <NEW_LINE> } <NEW_LINE> <START_VULN> static void copyMultiCh8 ( short * dst , const int * const * src , unsigned nSamples , unsigned nChannels ) <NEW_LINE> <END_VULN> { <NEW_LINE> for ( unsigned i = 0 ; i < nSamples ; ++ i ) { <NEW_LINE> for ( unsigned c = 0 ; c < nChannels ; ++ c ) {
{ <NEW_LINE> PRBool inherits ; <NEW_LINE> if ( aLoadType != LOAD_NORMAL_EXTERNAL && ! owner && <NEW_LINE> ( aFlags & INTERNAL_LOAD_FLAGS_INHERIT_OWNER ) && <NEW_LINE> <START_VULN> ( ( NS_SUCCEEDED ( URIInheritsSecurityContext ( aURI , & inherits ) ) && <NEW_LINE>inherits ) || URIIsLocalFile ( aURI ) ) ) { <NEW_LINE> <END_VULN> nsCOMPtr < nsIDocShellTreeItem > treeItem = this ; <NEW_LINE> do { <NEW_LINE> nsCOMPtr < nsIDocShell > itemDocShell = <NEW_LINE> do_QueryInterface ( treeItem ) ; <NEW_LINE> PRBool isUnsafe ;
{ <NEW_LINE> xd -> mb_segement_abs_delta = ( unsigned char ) vp8_read_bit ( bc ) ; <NEW_LINE> <START_VULN> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <NEW_LINE> <END_VULN> for ( i = 0 ; i < MB_LVL_MAX ; i ++ )
png_set_expand ( png_ptr ) ; <NEW_LINE> #ifdef NJET <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( bit_depth == 16 ) <NEW_LINE> png_set_strip_16 ( png_ptr ) ;
fp -> slots = NULL ; <NEW_LINE> fp -> callobj = NULL ; <NEW_LINE> fp -> argsobj = NULL ; <NEW_LINE> fp -> varobj = cx -> fp -> varobj ; <NEW_LINE> fp -> callee = exit -> nativeCallee ( ) ; <NEW_LINE> fp -> script = NULL ; <NEW_LINE> fp -> fun = GET_FUNCTION_PRIVATE ( cx , fp -> callee ) ; <NEW_LINE> <START_VULN> fp -> thisp = ( JSObject * ) cx -> nativeVp [ 1 ] ; <NEW_LINE>fp -> argc = cx -> nativeVpLen - 2 ; <NEW_LINE>fp -> argv = cx -> nativeVp + 2 ; <NEW_LINE> <END_VULN> fp -> rval = JSVAL_VOID ; <NEW_LINE> fp -> down = cx -> fp ; <NEW_LINE> fp -> annotation = NULL ; <NEW_LINE> JS_ASSERT ( cx -> fp -> scopeChain ) ; <NEW_LINE> fp -> scopeChain = cx -> fp -> scopeChain ; <NEW_LINE> fp -> blockChain = NULL ; <NEW_LINE> fp -> sharpDepth = 0 ; <NEW_LINE> fp -> sharpArray = NULL ;
uint16_t numRealAttrs = mNumCachedAttrs ; <NEW_LINE> nsAutoString data ; <NEW_LINE> <START_VULN> if ( mContent -> Tag ( ) == nsGkAtoms::object && <NEW_LINE> ! mContent -> HasAttr ( kNameSpaceID_None , nsGkAtoms::src ) && <NEW_LINE>mContent -> GetAttr ( kNameSpaceID_None , nsGkAtoms::data , data ) && <NEW_LINE> <END_VULN> ! data . IsEmpty ( ) ) { <NEW_LINE> mNumCachedAttrs ++ ; <NEW_LINE> } <NEW_LINE> nsCString wmodeType ;
frames [ i ] = frames_ [ i ] ; <NEW_LINE> } <NEW_LINE> <START_VULN> delete [ ] frames_ ; <NEW_LINE> <END_VULN> frames_ = frames ; <NEW_LINE> frames_capacity_ = new_capacity ; <NEW_LINE> }
return false ; <NEW_LINE> RenderObject * first = parent -> firstChild ( ) ; <NEW_LINE> <START_VULN> while ( first && first -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> first = first -> nextSibling ( ) ; <NEW_LINE> RenderObject * next = context . nextRenderer ( ) ; <NEW_LINE> if ( ! first || next == first )
<START_VULN> PHP_FUNCTION ( locale_get_display_script ) <NEW_LINE> <END_VULN> { <NEW_LINE> get_icu_disp_value_src_php ( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; <NEW_LINE> }
<START_VULN> for_each_leaf_cfs_rq_safe ( rq , cfs_rq , pos ) { <NEW_LINE> <END_VULN> struct sched_entity * se ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: floor backend 1 implementation <NEW_LINE> <START_VULN> last mod: $ Id: floor1 . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
LayoutUnit floatLeftWidth = 0 , floatRightWidth = 0 ; <NEW_LINE> while ( child ) { <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> child = child -> nextSibling ( ) ; <NEW_LINE> continue ; <NEW_LINE> }
if ( tstate & TSTATE_PRIV ) <NEW_LINE> die_if_kernel ( "stdfmna from kernel" , regs ) ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , sfar ) ; <NEW_LINE> <END_VULN> if ( test_thread_flag ( TIF_32BIT ) ) <NEW_LINE> pc = ( u32 ) pc ; <NEW_LINE> if ( get_user ( insn , ( u32 __user * ) pc ) != - EFAULT ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: window functions <NEW_LINE> <START_VULN> last mod: $ Id: window . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_WINDOW_ <NEW_LINE> #define _V_WINDOW_ <NEW_LINE> extern float * _vorbis_window_get ( int n ) ; <NEW_LINE> extern void _vorbis_apply_window ( float * d , int * winno , long * blocksizes ,
const char * aPropertyName , <NEW_LINE> const char * anInterfaceName , <NEW_LINE> PRBool aForceReport ) ; <NEW_LINE> private: <NEW_LINE> nsXPCWrappedJSClass ( ) ; <NEW_LINE> nsXPCWrappedJSClass ( XPCCallContext & ccx , REFNSIID aIID , <NEW_LINE> nsIInterfaceInfo * aInfo ) ; <NEW_LINE> <START_VULN> JSObject * NewOutObject ( JSContext * cx ) ; <NEW_LINE> <END_VULN> JSBool IsReflectable ( uint16 i ) const <NEW_LINE> { return ( JSBool ) ( mDescriptors [ i / 32 ] & ( 1 << ( i % 32 ) ) ) ; } <NEW_LINE> void SetReflectable ( uint16 i , JSBool b ) <NEW_LINE> { if ( b ) mDescriptors [ i / 32 ] |= ( 1 << ( i % 32 ) ) ; <NEW_LINE> else mDescriptors [ i / 32 ] &= ~ ( 1 << ( i % 32 ) ) ; } <NEW_LINE> enum SizeMode { GET_SIZE , GET_LENGTH } ;
ModuleScriptCreationParams params ( <NEW_LINE> script_resource -> GetResponse ( ) . Url ( ) , script_resource -> SourceText ( ) , <NEW_LINE> script_resource -> GetResourceRequest ( ) . GetFetchCredentialsMode ( ) , <NEW_LINE> <START_VULN> script_resource -> CalculateAccessControlStatus ( ) ) ; <NEW_LINE> <END_VULN> Finalize ( params , error_messages ) ; <NEW_LINE> }
IDBKeyRange * aKeyRange , <NEW_LINE> IDBCursor::Direction aDirection ) <NEW_LINE> : ObjectStoreHelper ( aTransaction , aRequest , aObjectStore ) , <NEW_LINE> mKeyRange ( aKeyRange ) , mDirection ( aDirection ) <NEW_LINE> { } <NEW_LINE> ~ OpenCursorHelper ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( mCloneReadInfo . mCloneBuffer ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> virtual nsresult DoDatabaseWork ( mozIStorageConnection * aConnection ) <NEW_LINE> MOZ_OVERRIDE ; <NEW_LINE> virtual nsresult GetSuccessResult ( JSContext * aCx , <NEW_LINE> jsval * aVal ) MOZ_OVERRIDE ;
return object_common2 ( UNSERIALIZE_PASSTHRU , <NEW_LINE> object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 818 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy32: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych == ' + ' ) goto yy33 ;
iterator -> intern . funcs = & spl_filesystem_tree_it_funcs ; <NEW_LINE> } <NEW_LINE> zval_add_ref ( & object ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return ( zend_object_iterator * ) iterator ; <NEW_LINE> }
{ <NEW_LINE> br -> entryfp ( ) -> clearRunningInIon ( ) ; <NEW_LINE> ScriptFrameIter iter ( cx ) ; <NEW_LINE> StackFrame * fp = NULL ; <NEW_LINE> Rooted < JSScript * > script ( cx , NULL ) ; <NEW_LINE> do { <NEW_LINE> <START_VULN> JS_ASSERT ( ! iter . isIon ( ) ) ; <NEW_LINE>fp = iter . fp ( ) ; <NEW_LINE> <END_VULN> script = iter . script ( ) ; <NEW_LINE> if ( script -> needsArgsObj ( ) ) { <NEW_LINE> JS_ASSERT ( ! fp -> hasArgsObj ( ) ) ; <NEW_LINE> ArgumentsObject * argsobj = ArgumentsObject::createExpected ( cx , fp ) ; <NEW_LINE> if ( ! argsobj )
nsCOMPtr < nsIScriptContext > ctxNew = languageRuntime -> CreateContext ( false , nullptr ) ; <NEW_LINE> MOZ_ASSERT ( ctxNew ) ; <NEW_LINE> { <NEW_LINE> <START_VULN> JSContext * cx = ctxNew -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSObject * newGlob = JS_NewGlobalObject ( cx , & gSharedGlobalClass , <NEW_LINE> nsJSPrincipals::get ( GetPrincipal ( ) ) ) ; <NEW_LINE> if ( ! newGlob ) <NEW_LINE> return NS_OK ; <NEW_LINE> ::JS_SetGlobalObject ( cx , newGlob ) ;
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( mount ( console -> name , lxcpath , "none" , MS_BIND , 0 ) ) { <NEW_LINE> <END_VULN> ERROR ( "failed to mount ' % s' on ' % s'" , console -> name , lxcpath ) ; <NEW_LINE> return - 1 ; <NEW_LINE> }
char * start = s ; <NEW_LINE> char * t = s ; <NEW_LINE> for ( ; * s ; s ++ ) { <NEW_LINE> <START_VULN> if ( isspace ( * s ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( c1 ) { <NEW_LINE> * t ++ = ( hexval ( c1 ) << 4 ) + hexval ( * s ) ;
if ( op . m_op == OpBodyAlternativeNext ) { <NEW_LINE> op . m_reentry = label ( ) ; <NEW_LINE> <START_VULN> if ( int delta = alternative -> m_minimumSize - priorAlternative -> m_minimumSize ) { <NEW_LINE>add32 ( Imm32 ( delta ) , index ) ; <NEW_LINE>if ( delta > 0 ) <NEW_LINE>op . m_jumps . append ( jumpIfNoAvailableInput ( ) ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } else if ( op . m_nextOp == notFound ) { <NEW_LINE> op . m_reentry = label ( ) ; <NEW_LINE> sub32 ( Imm32 ( priorAlternative -> m_minimumSize ) , index ) ; <NEW_LINE> } <NEW_LINE> if ( op . m_op == OpBodyAlternativeNext )
JSObject * PrepareObjectForLocation ( JSCLContextHelper & aCx , <NEW_LINE> nsIFile * aComponentFile , <NEW_LINE> nsIURI * aComponent , <NEW_LINE> bool aReuseLoaderGlobal , <NEW_LINE> bool * aRealFile ) ; <NEW_LINE> nsresult ObjectForLocation ( nsIFile * aComponentFile , <NEW_LINE> nsIURI * aComponent , <NEW_LINE> <START_VULN> JSObject ** aObject , <NEW_LINE>JSScript ** aTableScript , <NEW_LINE> <END_VULN> char ** location , <NEW_LINE> bool aCatchException , <NEW_LINE> JS::MutableHandleValue aException ) ; <NEW_LINE> nsresult ImportInto ( const nsACString & aLocation , <NEW_LINE> JS::HandleObject targetObj , <NEW_LINE> JSContext * callercx , <NEW_LINE> JS::MutableHandleObject vp ) ;
virtual void TabInsertedAt ( content::WebContents * contents , <NEW_LINE> int index , <NEW_LINE> bool foreground ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void TabDetachedAt ( TabContents * contents , int index ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual void TabMoved ( TabContents * contents , <NEW_LINE> int from_index , <NEW_LINE> int to_index ) OVERRIDE ;
MB_MODE_INFO saved_mbmi ; <NEW_LINE> MACROBLOCKD * filter_xd = & x -> e_mbd ; <NEW_LINE> MB_MODE_INFO * mbmi = & filter_xd -> mode_info_context -> mbmi ; <NEW_LINE> <START_VULN> int sse_diff = zero_mv_sse - best_sse ; <NEW_LINE> <END_VULN> saved_mbmi = * mbmi ;
float page_scale_factor ( ) const { return page_scale_factor_ ; } <NEW_LINE> <START_VULN> void ScrollTo ( gfx::Vector2d new_value ) ; <NEW_LINE> <END_VULN> bool IsVisible ( ) const ;
return 0 ; <NEW_LINE> if ( uid_eq ( dir -> i_uid , fsuid ) ) <NEW_LINE> return 0 ; <NEW_LINE> <START_VULN> return ! inode_capable ( inode , CAP_FOWNER ) ; <NEW_LINE> <END_VULN> }
} <NEW_LINE> for ( InlineBox * curr = firstChild ( ) ; curr ; curr = curr -> nextOnLine ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> renderer ( ) -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( descendantsHaveSameLineHeightAndBaseline ( ) ) {
#include "vp9 / common / vp9_onyxc_int . h" <NEW_LINE> #include "vp9 / common / vp9_seg_common . h" <NEW_LINE> <START_VULN> const vp9_prob vp9_kf_y_mode_prob [ INTRA_MODES ] [ INTRA_MODES ] [ INTRA_MODES - 1 ] = { <NEW_LINE> <END_VULN> { <NEW_LINE> { 137 , 30 , 42 , 148 , 151 , 207 , 70 , 52 , 91 } , <NEW_LINE> { 92 , 45 , 102 , 136 , 116 , 180 , 74 , 90 , 100 } ,
<START_VULN> PHPAPI void php_clear_stat_cache ( zend_bool clear_realpath_cache , const char * filename , int filename_len ) <NEW_LINE> <END_VULN> {
{ <NEW_LINE> * q ++ = ( unsigned char ) ( GetPixelLuma ( image , p ) >= ( QuantumRange / 2 . 0 ) ? <NEW_LINE> '0' : '1' ) ; <NEW_LINE> <START_VULN> * q ++ = ' ' ; <NEW_LINE> <END_VULN> if ( ( q - pixels + 1 ) >= ( ssize_t ) sizeof ( pixels ) ) <NEW_LINE> { <NEW_LINE> * q ++ = '\n' ; <NEW_LINE> ( void ) WriteBlob ( image , q - pixels , pixels ) ; <NEW_LINE> q = pixels ; <NEW_LINE> } <NEW_LINE> p += GetPixelChannels ( image ) ; <NEW_LINE> } <NEW_LINE> * q ++ = '\n' ;
GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; <NEW_LINE> if ( sess ) { <NEW_LINE> e = gf_dm_sess_process ( sess ) ; <NEW_LINE> <START_VULN> if ( ! e ) strcpy ( the_url , gf_dm_sess_get_cache_name ( sess ) ) ; <NEW_LINE> <END_VULN> gf_dm_sess_del ( sess ) ; <NEW_LINE> } <NEW_LINE> }
int i ; <NEW_LINE> vp9_clearall_segfeatures ( & cm -> seg ) ; <NEW_LINE> cm -> seg . abs_delta = SEGMENT_DELTADATA ; <NEW_LINE> <START_VULN> if ( cm -> last_frame_seg_map ) <NEW_LINE>vpx_memset ( cm -> last_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; <NEW_LINE> <END_VULN> vp9_zero ( lf -> last_ref_deltas ) ;
{ <NEW_LINE> if ( isFloating ( ) ) <NEW_LINE> return "RenderMultiColumnBlock ( floating ) " ; <NEW_LINE> <START_VULN> if ( isPositioned ( ) ) <NEW_LINE> <END_VULN> return "RenderMultiColumnBlock ( positioned ) " ; <NEW_LINE> if ( isAnonymousBlock ( ) ) <NEW_LINE> return "RenderMultiColumnBlock ( anonymous ) " ;
if ( ! ctx || ! iter || ! ctx -> iface || ! ctx -> priv ) <NEW_LINE> img = NULL ; <NEW_LINE> else <NEW_LINE> <START_VULN> img = ctx -> iface -> dec . get_frame ( ctx -> priv -> alg_priv , iter ) ; <NEW_LINE> <END_VULN> return img ; <NEW_LINE> }
return NULL ; <NEW_LINE> str -> init ( chars , length ) ; <NEW_LINE> return str ; <NEW_LINE> } <NEW_LINE> JS_ALWAYS_INLINE JSAtom * <NEW_LINE> JSFixedString::morphAtomizedStringIntoAtom ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> JS_ASSERT ( ( d . lengthAndFlags & FLAGS_MASK ) == JS_BIT ( 2 ) ) ; <NEW_LINE>JS_STATIC_ASSERT ( NON_STATIC_ATOM == JS_BIT ( 3 ) ) ; <NEW_LINE>d . lengthAndFlags ^= ( JS_BIT ( 2 ) | JS_BIT ( 3 ) ) ; <NEW_LINE> <END_VULN> return & asAtom ( ) ; <NEW_LINE> } <NEW_LINE> JS_ALWAYS_INLINE JSInlineString * <NEW_LINE> JSInlineString::new_ ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> return ( JSInlineString * ) js_NewGCString ( cx ) ; <NEW_LINE> }
PassRefPtr < DocumentFragment > createFragmentFromMarkup ( Document * , const String & markup , const String & baseURL , FragmentScriptingPermission = AllowScriptingContent ) ; <NEW_LINE> PassRefPtr < DocumentFragment > createFragmentFromMarkupWithContext ( Document * , const String & markup , unsigned fragmentStart , unsigned fragmentEnd , const String & baseURL , FragmentScriptingPermission ) ; <NEW_LINE> PassRefPtr < DocumentFragment > createFragmentFromNodes ( Document * , const Vector < Node * > & ) ; <NEW_LINE> <START_VULN> PassRefPtr < DocumentFragment > createFragmentFromSource ( const String & , Element * , ExceptionCode & ) ; <NEW_LINE> <END_VULN> bool isPlainTextMarkup ( Node * node ) ;
@param dispatcher Event dispatcher <NEW_LINE> @return Event mark 64 bit integer <NEW_LINE> @ingroup MprDispatcher <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC int64 mprGetEventMark ( MprDispatcher * dispatcher ) ;
const SkImageInfo & info ) { <NEW_LINE> <START_VULN> <NEW_LINE>size_t width = static_cast < size_t > ( input -> width ( ) ) ; <NEW_LINE> <END_VULN> RefPtr < ArrayBuffer > dstBuffer = <NEW_LINE> ArrayBuffer::createOrNull ( width * input -> height ( ) , info . bytesPerPixel ( ) ) ; <NEW_LINE> if ( ! dstBuffer )
{ 0 , 1024 } , { - 1024 , 1024 } , { - 1024 , 0 } } , <NEW_LINE> } ; <NEW_LINE> return vp9_pattern_search ( x , ref_mv , search_param , sad_per_bit , <NEW_LINE> <START_VULN> do_init_search , 0 , vfp , use_mvcost , <NEW_LINE> <END_VULN> center_mv , best_mv , <NEW_LINE> square_num_candidates , square_candidates ) ; <NEW_LINE> }
break ; <NEW_LINE> } <NEW_LINE> <START_VULN> setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , 0 ) ; <NEW_LINE> <END_VULN> if ( setup_ret == 0 ) { <NEW_LINE> goto _mus_end ; <NEW_LINE> }
{ <NEW_LINE> fprintf ( stderr , <NEW_LINE> "usage: ssh - agent [ - c | - s ] [ - Dd ] [ - a bind_address ] [ - E fingerprint_hash ] \n" <NEW_LINE> <START_VULN> " [ - t life ] [ command [ arg . . . ] ] \n" <NEW_LINE> <END_VULN> " ssh - agent [ - c | - s ] - k\n" ) ; <NEW_LINE> exit ( 1 ) ; <NEW_LINE> }
break ; <NEW_LINE> case PT_OSI: <NEW_LINE> <START_VULN> isoclns_print ( ndo , p , length , length ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> default:
NS_IMETHOD ResetInputState ( ) ; <NEW_LINE> NS_IMETHOD_ ( void ) SetInputContext ( const InputContext & aContext , <NEW_LINE> const InputContextAction & aAction ) ; <NEW_LINE> NS_IMETHOD_ ( InputContext ) GetInputContext ( ) ; <NEW_LINE> NS_IMETHOD CancelIMEComposition ( ) ; <NEW_LINE> NS_IMETHOD OnIMEFocusChange ( bool aFocus ) ; <NEW_LINE> NS_IMETHOD GetToggledKeyState ( uint32_t aKeyCode , bool * aLEDState ) ; <NEW_LINE> <START_VULN> void ResizeTransparencyBitmap ( int32_t aNewWidth , int32_t aNewHeight ) ; <NEW_LINE> <END_VULN> void ApplyTransparencyBitmap ( ) ; <NEW_LINE> virtual void SetTransparencyMode ( nsTransparencyMode aMode ) ; <NEW_LINE> virtual nsTransparencyMode GetTransparencyMode ( ) ; <NEW_LINE> virtual nsresult ConfigureChildren ( const nsTArray < Configuration > & aConfigurations ) ; <NEW_LINE> nsresult UpdateTranslucentWindowAlphaInternal ( const nsIntRect & aRect , <NEW_LINE> uint8_t * aAlphas , int32_t aStride ) ; <NEW_LINE> #if defined ( MOZ_WIDGET_GTK2 )
const u_char * bp , u_int length , <NEW_LINE> const u_char * bp2 ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( length == 1 && bp [ 0 ] == 0xff ) { <NEW_LINE> ND_PRINT ( ( ndo , "isakmp - nat - keep - alive" ) ) ; <NEW_LINE> return ;
INC_STATS ( "DOM . WebGLRenderingContext . getUniform ( ) " ) ; <NEW_LINE> if ( args . Length ( ) != 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> WebGLRenderingContext * context = V8WebGLRenderingContext::toNative ( args . Holder ( ) ) ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! ( png_ptr -> color_type & PNG_COLOR_MASK_COLOR ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_warning ( png_ptr , <NEW_LINE> "Ignoring request to write a PLTE chunk in grayscale PNG" ) ;
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> }
if ( i + 1 < P_BANDS ) { <NEW_LINE> int l = 0 ; <NEW_LINE> k = i + 1 ; <NEW_LINE> for ( j = 0 ; j < EHMER_MAX ; j ++ ) { <NEW_LINE> int lo_bin = fromOC ( j * . 125 + i * . 5 - 2 . 0625 ) / binHz ; <NEW_LINE> int hi_bin = fromOC ( j * . 125 + i * . 5 - 1 . 9375 ) / binHz + 1 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( lo_bin < 0 ) lo_bin = 0 ; <NEW_LINE> if ( lo_bin > n ) lo_bin = n ; <NEW_LINE> if ( lo_bin < l ) l = lo_bin ; <NEW_LINE> if ( hi_bin < 0 ) hi_bin = 0 ; <NEW_LINE> if ( hi_bin > n ) hi_bin = n ; <NEW_LINE> for ( ; l < hi_bin && l < n ; l ++ ) <NEW_LINE> if ( brute_buffer [ l ] > workc [ k ] [ m ] [ j ] )
nsresult <NEW_LINE> IDBFactory::LoadDatabaseInformation ( mozIStorageConnection * aConnection , <NEW_LINE> nsIAtom * aDatabaseId , <NEW_LINE> uint64_t * aVersion , <NEW_LINE> ObjectStoreInfoArray & aObjectStores ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( aConnection , "Null pointer ! " ) ; <NEW_LINE> aObjectStores . Clear ( ) ; <NEW_LINE> nsCOMPtr < mozIStorageStatement > stmt ; <NEW_LINE> nsresult rv = aConnection -> CreateStatement ( NS_LITERAL_CSTRING ( <NEW_LINE> "SELECT name , id , key_path , auto_increment "
content_encodings_size += encoding -> Size ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> size += EbmlMasterElementSize ( kMkvContentEncodings , <NEW_LINE>content_encodings_size ) + <NEW_LINE>content_encodings_size ; <NEW_LINE> <END_VULN> } <NEW_LINE> return size ;
<START_VULN> #line 197 "re_grammar . c" <NEW_LINE> <END_VULN> #ifdef short <NEW_LINE> # undef short
int endOverhang ; <NEW_LINE> RenderObject * nextObject = 0 ; <NEW_LINE> for ( BidiRun * runWithNextObject = run -> next ( ) ; runWithNextObject ; runWithNextObject = runWithNextObject -> next ( ) ) { <NEW_LINE> <START_VULN> if ( ! runWithNextObject -> m_object -> isPositioned ( ) && ! runWithNextObject -> m_box -> isLineBreak ( ) ) { <NEW_LINE> <END_VULN> nextObject = runWithNextObject -> m_object ; <NEW_LINE> break ; <NEW_LINE> }
NS_PRECONDITION ( ( ( mNumCachedAttrs + mNumCachedParams ) == 0 ) && <NEW_LINE> ! mCachedAttrParamNames , <NEW_LINE> "re - cache of attrs / params not implemented ! use the DOM " <NEW_LINE> "node directy instead" ) ; <NEW_LINE> <START_VULN> uint32_t cattrs = mContent -> GetAttrCount ( ) ; <NEW_LINE> <END_VULN> if ( cattrs < 0x0000FFFC ) { <NEW_LINE> mNumCachedAttrs = static_cast < uint16_t > ( cattrs ) ; <NEW_LINE> } else { <NEW_LINE> mNumCachedAttrs = 0xFFFC ; <NEW_LINE> } <NEW_LINE> const char * mime = nullptr ;
<START_VULN> if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) || <NEW_LINE> ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) { <NEW_LINE> <END_VULN> goto error ; <NEW_LINE> } <NEW_LINE> cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 ( 0 , size ) :
if ( IsAttrURI ( keyAtom ) ) { <NEW_LINE> if ( ! baseURI ) { <NEW_LINE> baseURI = aContent -> GetBaseURI ( ) ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIURI > attrURI ; <NEW_LINE> rv = NS_NewURI ( getter_AddRefs ( attrURI ) , v , nsnull , baseURI ) ; <NEW_LINE> if ( NS_SUCCEEDED ( rv ) ) { <NEW_LINE> rv = secMan -> <NEW_LINE> <START_VULN> CheckLoadURIWithPrincipal ( mTargetDocument -> NodePrincipal ( ) , <NEW_LINE>attrURI , <NEW_LINE>nsIScriptSecurityManager::DISALLOW_INHERIT_PRINCIPAL ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> continue ; <NEW_LINE> }
NS_ENSURE_TRUE ( owner , true ) ; <NEW_LINE> globalObject = owner -> GetScriptGlobalObject ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( globalObject , true ) ; <NEW_LINE> } <NEW_LINE> nsIScriptContext * scriptContext = globalObject -> GetContext ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( scriptContext , true ) ; <NEW_LINE> <START_VULN> <NEW_LINE>JSContext * cx = scriptContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( cx , true ) ; <NEW_LINE> bool enabled = true ; <NEW_LINE> nsContentUtils::GetSecurityManager ( ) -> <NEW_LINE> CanExecuteScripts ( cx , aDoc -> NodePrincipal ( ) , & enabled ) ; <NEW_LINE> return enabled ; <NEW_LINE> }
ND_PRINT ( ( ndo , " ( length bogus , should be >= 6 ) " ) ) ; <NEW_LINE> return len ; <NEW_LINE> } <NEW_LINE> <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 3 ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , ": Vendor: % s ( % u ) " , <NEW_LINE> tok2str ( oui_values , "Unknown" , EXTRACT_24BITS ( p + 2 ) ) , <NEW_LINE> EXTRACT_24BITS ( p + 2 ) ) ) ;
<START_VULN> if ( ! ext_dp -> icmp_length ) { <NEW_LINE> <END_VULN> vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; <NEW_LINE> vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; <NEW_LINE> if ( in_cksum ( vec , 1 ) ) {
Impl * impl , KeyType * key , v8::PersistentContainerValue value ) <NEW_LINE> { <NEW_LINE> v8::PersistentContainerValue oldValue = Get ( impl , key ) ; <NEW_LINE> <START_VULN> impl -> add ( key , value ) ; <NEW_LINE> <END_VULN> return oldValue ; <NEW_LINE> } <NEW_LINE> static v8::PersistentContainerValue Get ( const Impl * impl , KeyType * key )
return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> rv = strStream -> SetData ( reinterpret_cast < char * > ( aData . Value ( ) . GetAsArrayBufferView ( ) . Data ( ) ) , <NEW_LINE>aData . Value ( ) . GetAsArrayBufferView ( ) . Length ( ) ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) { <NEW_LINE> aRv . Throw ( NS_ERROR_FAILURE ) ;
bool WantNativeAddressInfo ( JSContext * ) ; <NEW_LINE> bool EnterScript ( JSContext * , JSScript * , JSFunction * , StackFrame * ) ; <NEW_LINE> <START_VULN> bool ExitScript ( JSContext * , JSScript * , JSFunction * , AbstractFramePtr ) ; <NEW_LINE>bool ExitScript ( JSContext * , JSScript * , JSFunction * , StackFrame * ) ; <NEW_LINE> <END_VULN> bool StartExecution ( JSScript * script ) ; <NEW_LINE> bool StopExecution ( JSScript * script ) ;
} <NEW_LINE> } <NEW_LINE> jsval v ; <NEW_LINE> if ( ! RewrapObject ( cx , scope , obj , NONE , & v ) ) { <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! JS_CallFunctionValue ( cx , JSVAL_TO_OBJECT ( v ) , OBJECT_TO_JSVAL ( unsafeObj ) , <NEW_LINE>argc , argv , rval ) ) { <NEW_LINE> <END_VULN> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return WrapJSValue ( cx , callee , * rval , rval ) ; <NEW_LINE> } <NEW_LINE> static JSBool
if ( ! lazy -> maybeScript ( ) ) <NEW_LINE> lazy -> initScript ( clonedScript ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> JS_ASSERT ( lazy -> source ( ) -> hasSourceData ( ) ) ; <NEW_LINE> <START_VULN> SourceDataCache::AutoSuppressPurge asp ( cx ) ; <NEW_LINE>const jschar * chars = lazy -> source ( ) -> chars ( cx , asp ) ; <NEW_LINE> <END_VULN> if ( ! chars ) <NEW_LINE> return false ; <NEW_LINE> const jschar * lazyStart = chars + lazy -> begin ( ) ; <NEW_LINE> size_t lazyLength = lazy -> end ( ) - lazy -> begin ( ) ; <NEW_LINE> if ( ! frontend::CompileLazyFunction ( cx , lazy , lazyStart , lazyLength ) ) <NEW_LINE> return false ;
MP_DIGITS ( & t1 ) = 0 ; <NEW_LINE> MP_DIGITS ( & M ) = 0 ; <NEW_LINE> MP_DIGITS ( & S ) = 0 ; <NEW_LINE> MP_CHECKOK ( mp_init ( & t0 ) ) ; <NEW_LINE> MP_CHECKOK ( mp_init ( & t1 ) ) ; <NEW_LINE> MP_CHECKOK ( mp_init ( & M ) ) ; <NEW_LINE> MP_CHECKOK ( mp_init ( & S ) ) ; <NEW_LINE> <START_VULN> if ( ec_GFp_pt_is_inf_jac ( px , py , pz ) == MP_YES ) { <NEW_LINE> <END_VULN> MP_CHECKOK ( ec_GFp_pt_set_inf_jac ( rx , ry , rz ) ) ; <NEW_LINE> goto CLEANUP ; <NEW_LINE> } <NEW_LINE> if ( mp_cmp_d ( pz , 1 ) == 0 ) { <NEW_LINE> MP_CHECKOK ( group -> meth -> field_sqr ( px , & t0 , group -> meth ) ) ; <NEW_LINE> MP_CHECKOK ( group -> meth -> field_add ( & t0 , & t0 , & M , group -> meth ) ) ;
aOffset , <NEW_LINE> endOffset , <NEW_LINE> aLength , <NEW_LINE> aDetails <NEW_LINE> } ; <NEW_LINE> nsNodeUtils::CharacterDataWillChange ( this , & info ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( NodeType ( ) == nsIDOMNode::TEXT_NODE ) { <NEW_LINE>SetDirectionFromChangedTextNode ( this , aOffset , aBuffer , aLength , aNotify ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> if ( aOffset == 0 && endOffset == textLength ) { <NEW_LINE> bool ok = mText . SetTo ( aBuffer , aLength , ! document || ! document -> GetBidiEnabled ( ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( ok , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> } <NEW_LINE> else if ( aOffset == textLength ) {
RefPtr < Image > previous_image_ ; <NEW_LINE> Member < ScriptedAnimationController > scripted_animation_controller_ ; <NEW_LINE> <START_VULN> bool pending_raf_ = false ; <NEW_LINE> <END_VULN> bool pending_vsync_ = false ; <NEW_LINE> bool in_animation_frame_ = false ; <NEW_LINE> bool in_display_activate_ = false ;
else if ( warn < 2 ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( warn ) <NEW_LINE> <END_VULN> png_chunk_warning ( png_ptr , "insufficient memory to read chunk" ) ; <NEW_LINE> else
<START_VULN> GetNextToken ( q , & q , extent , keyword ) ; <NEW_LINE> <END_VULN> if ( * keyword == '\0' ) <NEW_LINE> break ; <NEW_LINE> if ( * keyword == '#' )
#if DCHECK_IS_ON ( ) <NEW_LINE> <START_VULN> scoped_refptr < TransformPaintPropertyNode > Clone ( ) const { <NEW_LINE>return base::AdoptRef ( <NEW_LINE> <END_VULN> new TransformPaintPropertyNode ( Parent ( ) , State ( state_ ) ) ) ; <NEW_LINE> }
threshold_image = CloneImage ( image , 0 , 0 , MagickTrue , exception ) ; <NEW_LINE> if ( threshold_image == ( Image * ) NULL ) <NEW_LINE> return ( ( Image * ) NULL ) ; <NEW_LINE> <START_VULN> if ( width == 0 ) <NEW_LINE> <END_VULN> return ( threshold_image ) ; <NEW_LINE> if ( SetImageStorageClass ( threshold_image , DirectClass ) == MagickFalse ) <NEW_LINE> {
} while ( Op ) ; <NEW_LINE> <START_VULN> return_ACPI_STATUS ( Status ) ; <NEW_LINE> <END_VULN> }
nsresult rv ; <NEW_LINE> <START_VULN> if ( aScriptProto -> mScriptObject . mObject ) { <NEW_LINE> <END_VULN> rv = ExecuteScript ( aScriptProto ) ;
void CLASS foveon_dp_load_raw ( ) <NEW_LINE> { <NEW_LINE> unsigned c , roff [ 4 ] , row , col , diff ; <NEW_LINE> <START_VULN> ushort huff [ 512 ] , vpred [ 2 ] [ 2 ] , hpred [ 2 ] ; <NEW_LINE> <END_VULN> fseek ( ifp , 8 , SEEK_CUR ) ; <NEW_LINE> foveon_huff ( huff ) ;
nsGenericElement::DestroyContent ( ) ; <NEW_LINE> } <NEW_LINE> #ifdef DEBUG <NEW_LINE> void <NEW_LINE> nsXULElement::List ( FILE * out , PRInt32 aIndent ) const <NEW_LINE> { <NEW_LINE> <START_VULN> nsCString prefix ( " < XUL" ) ; <NEW_LINE> <END_VULN> if ( HasSlots ( ) ) { <NEW_LINE> prefix . Append ( ' * ' ) ; <NEW_LINE> } <NEW_LINE> prefix . Append ( ' ' ) ; <NEW_LINE> nsGenericElement::List ( out , aIndent , prefix ) ; <NEW_LINE> } <NEW_LINE> #endif
viz::TextureMailbox * out_mailbox , <NEW_LINE> std::unique_ptr < cc::SingleReleaseCallback > * out_release_callback ) { <NEW_LINE> DCHECK ( state_restorer_ ) ; <NEW_LINE> <START_VULN> if ( web_gl_version_ > kWebGL1 ) { <NEW_LINE> <END_VULN> state_restorer_ -> SetPixelUnpackBufferBindingDirty ( ) ; <NEW_LINE> gl_ -> BindBuffer ( GL_PIXEL_UNPACK_BUFFER , 0 ) ; <NEW_LINE> }
nsICSSPseudoComparator * aComparator ) ; <NEW_LINE> #endif <NEW_LINE> bool AppendFontFaceRules ( nsPresContext * aPresContext , <NEW_LINE> nsTArray < nsFontFaceRuleContainer > & aArray ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>bool AppendKeyframesRules ( nsPresContext * aPresContext , <NEW_LINE>nsTArray < nsCSSKeyframesRule * > & aArray ) ; <NEW_LINE> <END_VULN> already_AddRefed < gfxFontFeatureValueSet > GetFontFeatureValuesLookup ( ) ; <NEW_LINE> bool AppendFontFeatureValuesRules ( nsPresContext * aPresContext , <NEW_LINE> nsTArray < nsCSSFontFeatureValuesRule * > & aArray ) ;
pthread_mutex_unlock ( & info -> cb_lock ) ; <NEW_LINE> cmd -> cancel ( ) ; <NEW_LINE> pthread_mutex_lock ( & info -> cb_lock ) ; <NEW_LINE> <START_VULN> <NEW_LINE>cmd -> releaseRef ( ) ; <NEW_LINE> <END_VULN> if ( num_cmd == info -> num_cmd ) { <NEW_LINE> ALOGI ( "Cancelling command % p: % s did not work" , cmd , ( cmd ? cmd -> getType ( ) : "" ) ) ; <NEW_LINE> bad_commands ++ ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
<START_VULN> <NEW_LINE> <END_VULN> #include < r_io . h > <NEW_LINE> #include < r_fs . h >
bool atBottomOfBlock = true ; <NEW_LINE> for ( RenderBox * curr = child -> nextSiblingBox ( ) ; curr && atBottomOfBlock ; curr = curr -> nextSiblingBox ( ) ) { <NEW_LINE> <START_VULN> if ( ! curr -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> atBottomOfBlock = false ; <NEW_LINE> }
LayoutRect result ( enclosingLayoutRect ( floatResult ) ) ; <NEW_LINE> bool isHorizontal = style ( ) -> isHorizontalWritingMode ( ) ; <NEW_LINE> for ( RenderObject * curr = firstChild ( ) ; curr ; curr = curr -> nextSibling ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> continue ;
nsresult RequestDecodeIfNeeded ( nsresult aStatus , <NEW_LINE> eShutdownIntent aIntent , <NEW_LINE> bool aDone , <NEW_LINE> bool aWasSize ) ; <NEW_LINE> nsresult WantDecodedFrames ( ) ; <NEW_LINE> nsresult SyncDecode ( ) ; <NEW_LINE> nsresult InitDecoder ( bool aDoSizeDecode ) ; <NEW_LINE> <START_VULN> nsresult WriteToDecoder ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE>nsresult DecodeSomeData ( uint32_t aMaxBytes ) ; <NEW_LINE> <END_VULN> bool IsDecodeFinished ( ) ; <NEW_LINE> TimeStamp mDrawStartTime ; <NEW_LINE> inline bool CanQualityScale ( const gfxSize & scale ) ; <NEW_LINE> inline bool CanScale ( GraphicsFilter aFilter , gfxSize aScale , uint32_t aFlags ) ; <NEW_LINE> struct ScaleResult <NEW_LINE> {
buf [ 1 ] = oid [ 3 ] ; <NEW_LINE> if ( buf [ 0 ] == 0x00 && buf [ 1 ] == 0x00 ) continue ; <NEW_LINE> buf += 2 ; <NEW_LINE> <START_VULN> count += 2 ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> return count ;
PNG_UNUSED ( params ) <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE>#endif <NEW_LINE> <END_VULN> #ifdef PNG_SIMPLIFIED_READ_SUPPORTED <NEW_LINE> #define PNG_CMAP_NONE 0 <NEW_LINE> #define PNG_CMAP_GA 1
CHECK_EQ ( reInitDecoder ( ) , ( status_t ) OK ) ; <NEW_LINE> <START_VULN> setDecodeArgs ( & s_dec_ip , & s_dec_op , inHeader , outHeader , timeStampIx ) ; <NEW_LINE><NEW_LINE>ivdec_api_function ( mCodecCtx , ( void * ) & s_dec_ip , ( void * ) & s_dec_op ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
return buffer ; <NEW_LINE> } <NEW_LINE> <START_VULN> OMX_BUFFERHEADERTYPE * OMXNodeInstance::findBufferHeader ( OMX::buffer_id buffer ) { <NEW_LINE> <END_VULN> if ( buffer == 0 ) { <NEW_LINE> return NULL ; <NEW_LINE> }
static void <NEW_LINE> <START_VULN> perform_formatting_test ( png_store * volatile ps ) <NEW_LINE> <END_VULN> { <NEW_LINE> #ifdef PNG_TIME_RFC1123_SUPPORTED <NEW_LINE> png_uint_32 id ; <NEW_LINE> png_uint_32 w ; <NEW_LINE> png_uint_32 h ;
#include < stdlib . h > <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < ctype . h > <NEW_LINE> <START_VULN> #include "compiler / debug . h" <NEW_LINE> <END_VULN> #include "compiler / preprocessor / slglobals . h" <NEW_LINE> #include "compiler / util . h"
{ <NEW_LINE> ctxt = xmlRelaxNGNewParserCtxt ( argv [ i ] ) ; <NEW_LINE> xmlRelaxNGSetParserErrors ( ctxt , <NEW_LINE> <START_VULN> ( xmlRelaxNGValidityErrorFunc ) fprintf , <NEW_LINE> ( xmlRelaxNGValidityWarningFunc ) fprintf , <NEW_LINE>stderr ) ; <NEW_LINE> <END_VULN> schema = xmlRelaxNGParse ( ctxt ) ; <NEW_LINE> xmlRelaxNGFreeParserCtxt ( ctxt ) ; <NEW_LINE> }
# define PNG_ARM_NEON_IMPLEMENTATION 2 <NEW_LINE> # endif <NEW_LINE> <START_VULN> # endif <NEW_LINE> <END_VULN> # ifndef PNG_ARM_NEON_IMPLEMENTATION
setup_ret = 6 ; <NEW_LINE> goto _XMI_Next_Event ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) { <NEW_LINE> <END_VULN> goto _xmi_end ; <NEW_LINE> }
if ( intrinsicSize . isEmpty ( ) && ( m_imageResource -> imageHasRelativeWidth ( ) || m_imageResource -> imageHasRelativeHeight ( ) ) ) { <NEW_LINE> <START_VULN> RenderObject * containingBlock = isPositioned ( ) ? container ( ) : this -> containingBlock ( ) ; <NEW_LINE> <END_VULN> if ( containingBlock -> isBox ( ) ) { <NEW_LINE> RenderBox * box = toRenderBox ( containingBlock ) ; <NEW_LINE> intrinsicSize . setWidth ( box -> availableLogicalWidth ( ) ) ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> MediaDecodeTask::CreateReader ( ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( NS_IsMainThread ( ) ) ; <NEW_LINE> <START_VULN> BufferMediaResource * resource = <NEW_LINE> <END_VULN> new BufferMediaResource ( static_cast < uint8_t * > ( mBuffer ) , <NEW_LINE> mLength , mPrincipal , mContentType ) ; <NEW_LINE> MOZ_ASSERT ( ! mBufferDecoder ) ; <NEW_LINE> mBufferDecoder = new BufferDecoder ( resource ) ;
( defined ( PNG_FIXED_POINT_SUPPORTED ) || defined ( PNG_FLOATING_POINT_SUPPORTED ) ) <NEW_LINE> #if PNG_LIBPNG_VER < 10500 <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> typedef png_byte * png_const_bytep ;
nsresult <NEW_LINE> nsMediaDocument::StartLayout ( ) <NEW_LINE> { <NEW_LINE> mMayStartLayout = PR_TRUE ; <NEW_LINE> nsPresShellIterator iter ( this ) ; <NEW_LINE> nsCOMPtr < nsIPresShell > shell ; <NEW_LINE> while ( ( shell = iter . GetNextShell ( ) ) ) { <NEW_LINE> nsRect visibleArea = shell -> GetPresContext ( ) -> GetVisibleArea ( ) ; <NEW_LINE> <START_VULN> nsCOMPtr < nsIPresShell > shellGrip = shell ; <NEW_LINE> <END_VULN> nsresult rv = shell -> InitialReflow ( visibleArea . width , visibleArea . height ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsIViewManager * vm = shell -> GetViewManager ( ) ; <NEW_LINE> if ( vm ) { <NEW_LINE> vm -> EnableRefresh ( NS_VMREFRESH_IMMEDIATE ) ;
} <NEW_LINE> <START_VULN> else if ( relaxed ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_set_benign_errors ( read_ptr , 1 ) ;
so = slirp -> udp_last_so ; <NEW_LINE> <START_VULN> if ( so -> so_lport != uh -> uh_sport || <NEW_LINE> <END_VULN> so -> so_laddr . s_addr != ip -> ip_src . s_addr ) { <NEW_LINE> struct socket * tmp ;
0 , nullptr , retval . address ( ) ) ; <NEW_LINE> } <NEW_LINE> if ( ! ok ) { <NEW_LINE> <START_VULN> JSBool saved = JS_SaveFrameChain ( cx ) ; <NEW_LINE>JS_ReportPendingException ( cx ) ; <NEW_LINE>if ( saved ) <NEW_LINE>JS_RestoreFrameChain ( cx ) ; <NEW_LINE> <END_VULN> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsXBLProtoImplAnonymousMethod::Write ( nsIScriptContext * aContext ,
NS_COM const nsAFlatCString & EmptyCString ( ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> - <NEW_LINE> <END_VULN> 1 . 4 . 1
return false ; <NEW_LINE> case nsXPTType::T_IID: <NEW_LINE> { <NEW_LINE> nsID * iid2 = * ( ( nsID ** ) s ) ; <NEW_LINE> if ( ! iid2 ) <NEW_LINE> break ; <NEW_LINE> JSObject * obj ; <NEW_LINE> <START_VULN> if ( ! ( obj = xpc_NewIDObject ( cx , lccx . GetScopeForNewJSObjects ( ) , * iid2 ) ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> * d = OBJECT_TO_JSVAL ( obj ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> case nsXPTType::T_ASTRING:
String getSelectedText ( ) ; <NEW_LINE> bool gestureWillBegin ( const WebCore::IntPoint & ) ; <NEW_LINE> <START_VULN> void gestureDidScroll ( const WebCore::IntSize & ) ; <NEW_LINE> <END_VULN> void gestureDidEnd ( ) ; <NEW_LINE> #endif <NEW_LINE> #if ENABLE ( TILED_BACKING_STORE )
{ <NEW_LINE> png_debug ( 1 , "in png_set_strip_alpha" ) ; <NEW_LINE> <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> png_ptr -> transformations |= PNG_STRIP_ALPHA ;
asocket * s ; <NEW_LINE> asocket * result = NULL ; <NEW_LINE> <START_VULN> adb_mutex_lock ( & socket_list_lock ) ; <NEW_LINE> <END_VULN> for ( s = local_socket_list . next ; s != & local_socket_list ; s = s -> next ) { <NEW_LINE> if ( s -> id != local_id ) { <NEW_LINE> continue ;
ND_PRINT ( ( ndo , " + % x" , aflags & 0xf ) ) ; <NEW_LINE> ND_PRINT ( ( ndo , " ] : " ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> tptr += alen ; <NEW_LINE> len - = alen ;
uintN argc , jsval * argv , jsval * rval ) <NEW_LINE> { <NEW_LINE> if ( argc < 3 || argc > 4 ) { <NEW_LINE> ThrowJSException ( cx , NS_ERROR_XPC_NOT_ENOUGH_ARGS ) ; <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> OBJ_TO_INNER_OBJECT ( cx , obj ) ; <NEW_LINE><NEW_LINE> <END_VULN> nsresult rv = sXPConnect -> GetJSObjectOfWrapper ( cx , obj , & obj ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> nsDOMClassInfo::ThrowJSException ( cx , rv ) ; <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> if ( NS_FAILED ( sSecMan -> CheckPropertyAccess ( cx , obj , <NEW_LINE> JS_GET_CLASS ( cx , obj ) -> name , <NEW_LINE> sAddEventListener_id , <NEW_LINE> nsIXPCSecurityManager::ACCESS_GET_PROPERTY ) ) || <NEW_LINE> NS_FAILED ( sSecMan -> CheckPropertyAccess ( cx , obj , <NEW_LINE> JS_GET_CLASS ( cx , obj ) -> name , <NEW_LINE> sAddEventListener_id ,
original_resource_request . GetRequestContext ( ) ) ; <NEW_LINE> Context ( ) . DispatchDidLoadResourceFromMemoryCache ( identifier , resource_request , <NEW_LINE> resource -> GetResponse ( ) ) ; <NEW_LINE> <START_VULN> Context ( ) . DispatchWillSendRequest ( identifier , resource_request , <NEW_LINE>ResourceResponse ( ) , <NEW_LINE>resource -> Options ( ) . initiator_info ) ; <NEW_LINE> <END_VULN> Context ( ) . DispatchDidReceiveResponse ( <NEW_LINE> identifier , resource -> GetResponse ( ) , resource_request . GetFrameType ( ) , <NEW_LINE> resource_request . GetRequestContext ( ) , resource ,
static bool requiresLineBox ( const InlineIterator & it , const LineInfo & lineInfo = LineInfo ( ) , WhitespacePosition whitespacePosition = LeadingWhitespace ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( it . m_obj -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> if ( it . m_obj -> isRenderInline ( ) && ! alwaysRequiresLineBox ( toRenderInline ( it . m_obj ) ) && ! requiresLineBoxForContent ( toRenderInline ( it . m_obj ) , lineInfo ) )
printk ( KERN_WARNING "nfs_callback_create_svc: no kthread , % d users ? ? \n" , <NEW_LINE> cb_info -> users ) ; <NEW_LINE> <START_VULN> serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ; <NEW_LINE> <END_VULN> if ( ! serv ) { <NEW_LINE> printk ( KERN_ERR "nfs_callback_create_svc: create service failed\n" ) ; <NEW_LINE> return ERR_PTR ( - ENOMEM ) ;
bool <NEW_LINE> WebAudioDecodeJob::FinalizeBufferData ( ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( NS_IsMainThread ( ) ) ; <NEW_LINE> MOZ_ASSERT ( mOutput ) ; <NEW_LINE> MOZ_ASSERT ( mChannels == mChannelBuffers . Length ( ) ) ; <NEW_LINE> <START_VULN> JSContext * cx = GetJSContext ( ) ; <NEW_LINE> <END_VULN> if ( ! cx ) { <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> for ( uint32_t i = 0 ; i < mChannels ; ++ i ) { <NEW_LINE> mOutput -> SetChannelDataFromArrayBufferContents ( cx , i , mChannelBuffers [ i ] . first ) ; <NEW_LINE> }
nsXBLProtoImplMethod ( const PRUnichar * aName ) ; <NEW_LINE> virtual ~ nsXBLProtoImplMethod ( ) ; <NEW_LINE> void AppendBodyText ( const nsAString & aBody ) ; <NEW_LINE> void AddParameter ( const nsAString & aName ) ; <NEW_LINE> void SetLineNumber ( uint32_t aLineNumber ) ; <NEW_LINE> <START_VULN> virtual nsresult InstallMember ( nsIScriptContext * aContext , <NEW_LINE>nsIContent * aBoundElement , <NEW_LINE>JSObject * aScriptObject , <NEW_LINE>JSObject * aTargetClassObject , <NEW_LINE>const nsCString & aClassStr ) ; <NEW_LINE> <END_VULN> virtual nsresult CompileMember ( nsIScriptContext * aContext , <NEW_LINE> const nsCString & aClassStr , <NEW_LINE> JSObject * aClassObject ) ; <NEW_LINE> virtual void Trace ( TraceCallback aCallback , void * aClosure ) const ; <NEW_LINE> nsresult Read ( nsIScriptContext * aContext , nsIObjectInputStream * aStream ) ; <NEW_LINE> virtual nsresult Write ( nsIScriptContext * aContext , nsIObjectOutputStream * aStream ) ;
item = proto_tree_add_text ( sched_tree , tvb , offset , 0 , "Other message slots in this schedule" ) ; <NEW_LINE> sched_subtree = proto_item_add_subtree ( item , ett_schedule_new_msg ) ; <NEW_LINE> <START_VULN> for ( k = 0 ; offset < len ; j ++ ) <NEW_LINE> <END_VULN> { <NEW_LINE> while ( ( other_slots [ k ] != 0xFFFF ) && ( k < sched_end ) ) <NEW_LINE> {
if ( ! WriteEbmlMasterElement ( writer , kMkvSeek , entry_size [ i ] ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> if ( ! WriteEbmlElement ( writer , <NEW_LINE>kMkvSeekID , <NEW_LINE> <END_VULN> static_cast < uint64 > ( seek_entry_id_ [ i ] ) ) ) <NEW_LINE> return false ;
class PlatformSensorAndroid : public PlatformSensor { <NEW_LINE> public: <NEW_LINE> PlatformSensorAndroid ( mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> PlatformSensorProvider * provider , <NEW_LINE> const base::android::JavaRef < jobject > & java_sensor ) ;
for ( i = 0 ; i < 16 ; ++ i ) { <NEW_LINE> for ( j = 0 ; j < 16 ; ++ j ) <NEW_LINE> temp_in [ j ] = out [ j * 16 + i ] ; <NEW_LINE> <START_VULN> iadst16 ( temp_in , temp_out ) ; <NEW_LINE> <END_VULN> for ( j = 0 ; j < 16 ; ++ j ) <NEW_LINE> dest [ j * pitch + i ] = <NEW_LINE> clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 )
ma_mov ( c , lr ) ; <NEW_LINE> ma_str ( lr , dest ) ; <NEW_LINE> } <NEW_LINE> BufferOffset ma_BoundsCheck ( Register bounded ) { <NEW_LINE> return as_cmp ( bounded , Imm8 ( 0 ) ) ; <NEW_LINE> } <NEW_LINE> void moveFloat32 ( FloatRegister src , FloatRegister dest ) { <NEW_LINE> <START_VULN> as_vmov ( VFPRegister ( src ) . singleOverlay ( ) , VFPRegister ( dest ) . singleOverlay ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef JSGC_GENERATIONAL <NEW_LINE> void branchPtrInNurseryRange ( Condition cond , Register ptr , Register temp , Label * label ) ; <NEW_LINE> void branchValueIsNurseryObject ( Condition cond , ValueOperand value , Register temp , Label * label ) ; <NEW_LINE> #endif <NEW_LINE> } ;
png_fixed_point result ; <NEW_LINE> if ( ppm <= PNG_UINT_31_MAX && png_muldiv ( & result , ( png_int_32 ) ppm , 127 , <NEW_LINE> <START_VULN> 5000 ) ) <NEW_LINE> <END_VULN> return result ;
cluster_size = size ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>#if 0 <NEW_LINE>len = static_cast < long > ( size_ ) ; <NEW_LINE><NEW_LINE>if ( cluster_stop > avail ) <NEW_LINE>return E_BUFFER_NOT_FULL ; <NEW_LINE>#endif <NEW_LINE><NEW_LINE> <END_VULN> long long timecode = - 1 ; <NEW_LINE> long long new_pos = - 1 ; <NEW_LINE> bool bBlock = false ;
NPObject * NP_CALLBACK <NEW_LINE> _getwindowobject ( NPP npp ) <NEW_LINE> { <NEW_LINE> if ( ! NS_IsMainThread ( ) ) { <NEW_LINE> NPN_PLUGIN_LOG ( PLUGIN_LOG_ALWAYS , ( "NPN_getwindowobject called from the wrong thread\n" ) ) ; <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSContext * cx = GetJSContextFromNPP ( npp ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( cx , nullptr ) ; <NEW_LINE> return nsJSObjWrapper::GetNewOrUsed ( npp , cx , ::JS_GetGlobalObject ( cx ) ) ; <NEW_LINE> }
void Collect ( bool aMergeCompartments , <NEW_LINE> nsCycleCollectorResults * aResults , <NEW_LINE> uint32_t aTryCollections , <NEW_LINE> nsICycleCollectorListener * aListener ) ; <NEW_LINE> bool PrepareForCollection ( nsCycleCollectorResults * aResults , <NEW_LINE> nsTArray < PtrInfo * > * aWhiteNodes ) ; <NEW_LINE> <START_VULN> void GCIfNeeded ( bool aForceGC ) ; <NEW_LINE> <END_VULN> void CleanupAfterCollection ( ) ; <NEW_LINE> bool BeginCollection ( bool aMergeCompartments , nsICycleCollectorListener * aListener ) ; <NEW_LINE> bool FinishCollection ( nsICycleCollectorListener * aListener ) ; <NEW_LINE> uint32_t SuspectedCount ( ) ; <NEW_LINE> void Shutdown ( ) ;
MagickExport int LocaleLowercase ( const int c ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( c < 0 ) <NEW_LINE> <END_VULN> return ( c ) ; <NEW_LINE> #if defined ( MAGICKCORE_LOCALE_SUPPORT ) <NEW_LINE> if ( c_locale != ( locale_t ) NULL )
int64_t seekTimeUs ; <NEW_LINE> ReadOptions::SeekMode mode ; <NEW_LINE> <START_VULN> if ( options && options -> getSeekTo ( & seekTimeUs , & mode ) ) { <NEW_LINE> <END_VULN> size_t size ; <NEW_LINE> int64_t seekFrame = seekTimeUs / 20000ll ; <NEW_LINE> mCurrentTimeUs = seekFrame * 20000ll ;
OMX_U32 yFrameSize = sizeof ( uint8 ) * mHandle -> size ; <NEW_LINE> if ( ( outHeader -> nAllocLen < yFrameSize ) || <NEW_LINE> ( outHeader -> nAllocLen - yFrameSize < yFrameSize / 2 ) ) { <NEW_LINE> <START_VULN> ALOGE ( "Too small output buffer for reference frame: % zu bytes" , <NEW_LINE>outHeader -> nAllocLen ) ; <NEW_LINE> <END_VULN> android_errorWriteLog ( 0x534e4554 , "30033990" ) ; <NEW_LINE> notify ( OMX_EventError , OMX_ErrorUndefined , 0 , NULL ) ; <NEW_LINE> mSignalledError = true ;
static void copyMono16 ( <NEW_LINE> short * dst , <NEW_LINE> <START_VULN> const int * const * src , <NEW_LINE> <END_VULN> unsigned nSamples , <NEW_LINE> unsigned ) { <NEW_LINE> for ( unsigned i = 0 ; i < nSamples ; ++ i ) {
SITE_IDENTITY_STATUS_DEPRECATED_SIGNATURE_ALGORITHM , <NEW_LINE> <START_VULN> } ; <NEW_LINE><NEW_LINE><NEW_LINE>enum SafeBrowsingStatus { <NEW_LINE>SAFE_BROWSING_STATUS_NONE = 0 , <NEW_LINE>SAFE_BROWSING_STATUS_MALWARE , <NEW_LINE>SAFE_BROWSING_STATUS_SOCIAL_ENGINEERING , <NEW_LINE>SAFE_BROWSING_STATUS_UNWANTED_SOFTWARE , <NEW_LINE>SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE , <NEW_LINE>SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE , <NEW_LINE>SAFE_BROWSING_STATUS_BILLING , <NEW_LINE> <END_VULN> } ;
if ( slen + idx > ms -> search . s_len ) <NEW_LINE> break ; <NEW_LINE> <START_VULN> v = file_strncmp ( m -> value . s , ms -> search . s + idx , slen , m -> str_flags ) ; <NEW_LINE> <END_VULN> if ( v == 0 ) { <NEW_LINE> ms -> search . offset += idx ; <NEW_LINE> break ;
MEDIA_EXPORT bool ParseNewStyleVp9CodecID ( const std::string & codec_id , <NEW_LINE> VideoCodecProfile * profile , <NEW_LINE> uint8_t * level_idc , <NEW_LINE> <START_VULN> gfx::ColorSpace::TransferID * eotf ) ; <NEW_LINE> <END_VULN> MEDIA_EXPORT bool ParseLegacyVp9CodecID ( const std::string & codec_id , <NEW_LINE> VideoCodecProfile * profile ,
GetWindowRect ( parentHwnd , & parentRect ) ; <NEW_LINE> BOOL b = SetWindowPos ( hwnd , NULL , <NEW_LINE> parentRect . left , <NEW_LINE> parentRect . top , 0 , 0 , <NEW_LINE> SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> static UINT_PTR CALLBACK FilePickerHook ( HWND hwnd , UINT msg , <NEW_LINE> WPARAM wParam , LPARAM lParam ) <NEW_LINE> { <NEW_LINE> if ( msg == WM_NOTIFY ) { <NEW_LINE> LPOFNOTIFYW lpofn = ( LPOFNOTIFYW ) lParam ; <NEW_LINE> if ( ! lpofn || ! lpofn -> lpOFN ) { <NEW_LINE> return 0 ; <NEW_LINE> }
uint32_t len ; <NEW_LINE> while ( packet_get_head_l ( sock , & buf , & len ) ) { <NEW_LINE> <START_VULN> int sent = send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ; <NEW_LINE> <END_VULN> if ( sent == ( signed ) len ) <NEW_LINE> osi_free ( buf ) ;
bdt_log ( "Bluetooth is already enabled" ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> status = sBtInterface -> enable ( ) ; <NEW_LINE> <END_VULN> check_return_status ( status ) ; <NEW_LINE> }
for ( k = 0 ; k < 4 ; ++ k , up += show -> uv_stride , udp += dest -> uv_stride , <NEW_LINE> vp += show -> uv_stride , vdp += dest -> uv_stride ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memcpy ( udp , up , 4 ) ; <NEW_LINE>vpx_memcpy ( vdp , vp , 4 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
} <NEW_LINE> bool Segment::DoNewClusterProcessing ( uint64 track_number , <NEW_LINE> <START_VULN> uint64 frame_timestamp_ns , <NEW_LINE>bool is_key ) { <NEW_LINE> <END_VULN> for ( ; ; ) {
{ <NEW_LINE> struct crypto_report_blkcipher rblkcipher ; <NEW_LINE> <START_VULN> snprintf ( rblkcipher . type , CRYPTO_MAX_ALG_NAME , " % s" , "blkcipher" ) ; <NEW_LINE>snprintf ( rblkcipher . geniv , CRYPTO_MAX_ALG_NAME , " % s" , <NEW_LINE>alg -> cra_blkcipher . geniv ? : " < default > " ) ; <NEW_LINE> <END_VULN> rblkcipher . blocksize = alg -> cra_blocksize ; <NEW_LINE> rblkcipher . min_keysize = alg -> cra_blkcipher . min_keysize ;
toRenderBlock ( cb ) -> removePositionedObjects ( this ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( containsFloats ( ) && ! isFloating ( ) && ! isPositioned ( ) && ( newStyle -> position ( ) == AbsolutePosition || newStyle -> position ( ) == FixedPosition ) ) <NEW_LINE> <END_VULN> markAllDescendantsWithFloatsForLayout ( ) ; <NEW_LINE> }
<START_VULN> * <NEW_LINE> <END_VULN>
RootInlineBox * box = 0 ; <NEW_LINE> RenderObject * curr = 0 ; <NEW_LINE> for ( curr = child -> previousSibling ( ) ; curr ; curr = curr -> previousSibling ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( curr -> isReplaced ( ) ) {
} <NEW_LINE> int optval ; <NEW_LINE> <START_VULN> socklen_t optlen ; <NEW_LINE> <END_VULN> netdutils::Status status = <NEW_LINE> getSyscallInstance ( ) . getsockopt ( Fd ( socket ) , IPPROTO_UDP , UDP_ENCAP , & optval , & optlen ) ; <NEW_LINE> if ( status != netdutils::status::ok ) {
VP8_BD_VALUE value ; <NEW_LINE> int count ; <NEW_LINE> unsigned int range ; <NEW_LINE> <START_VULN> vp8_decrypt_cb * decrypt_cb ; <NEW_LINE> <END_VULN> void * decrypt_state ; <NEW_LINE> } BOOL_DECODER ;
#endif <NEW_LINE> using namespace js ; <NEW_LINE> #if USE_ZLIB <NEW_LINE> static void * <NEW_LINE> zlib_alloc ( void * cx , uInt items , uInt size ) <NEW_LINE> { <NEW_LINE> <START_VULN> return OffTheBooks::malloc_ ( items * size ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void <NEW_LINE> zlib_free ( void * cx , void * addr ) <NEW_LINE> { <NEW_LINE> Foreground::free_ ( addr ) ; <NEW_LINE> }
sax -> sax25_family = AF_NETROM ; <NEW_LINE> skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , <NEW_LINE> AX25_ADDR_LEN ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> msg -> msg_namelen = sizeof ( * sax ) ; <NEW_LINE><NEW_LINE> <END_VULN> skb_free_datagram ( sk , skb ) ; <NEW_LINE> release_sock ( sk ) ;
result . mRescaling = aKernelUnitLength -> IsExplicitlySet ( ) ; <NEW_LINE> if ( ! result . mRescaling ) { <NEW_LINE> result . mSource = aSource -> mImage ; <NEW_LINE> result . mTarget = aTarget -> mImage ; <NEW_LINE> result . mDataRect = aDataRect ; <NEW_LINE> return result ; <NEW_LINE> } <NEW_LINE> <START_VULN> float kernelX = aInstance -> GetPrimitiveNumber ( nsSVGUtils::X , <NEW_LINE>aKernelUnitLength , <NEW_LINE>nsSVGNumberPair::eFirst ) ; <NEW_LINE>float kernelY = aInstance -> GetPrimitiveNumber ( nsSVGUtils::Y , <NEW_LINE>aKernelUnitLength , <NEW_LINE>nsSVGNumberPair::eSecond ) ; <NEW_LINE> <END_VULN> if ( kernelX <= 0 || kernelY <= 0 ) <NEW_LINE> return result ; <NEW_LINE> bool overflow = false ; <NEW_LINE> gfxIntSize scaledSize = <NEW_LINE> nsSVGUtils::ConvertToSurfaceSize ( gfxSize ( aTarget -> mImage -> Width ( ) / kernelX , <NEW_LINE> aTarget -> mImage -> Height ( ) / kernelY ) , <NEW_LINE> & overflow ) ;
<START_VULN> #ifndef BASE_ALLOCATOR_ALLOCATOR_THUNKS_EXTENSION_H <NEW_LINE>#define BASE_ALLOCATOR_ALLOCATOR_THUNKS_EXTENSION_H <NEW_LINE> <END_VULN> #include < stddef . h >
if ( info -> action == ACTION_CONNECT ) { <NEW_LINE> <START_VULN> rv = zsocket_connect ( * sock , info -> description ) ; <NEW_LINE> <END_VULN> if ( rv == - 1 ) { <NEW_LINE> errmsg . LogError ( 0 , <NEW_LINE> RS_RET_INVALID_PARAMS ,
int independent_partitions ; <NEW_LINE> int frame_corrupt_residual ; <NEW_LINE> <START_VULN> vp8_decrypt_cb * decrypt_cb ; <NEW_LINE> <END_VULN> void * decrypt_state ; <NEW_LINE> } VP8D_COMP ;
AcquireNextImage ( image_info , image , exception ) ; <NEW_LINE> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) <NEW_LINE> { <NEW_LINE> <START_VULN> image = DestroyImageList ( image ) ; <NEW_LINE>return ( ( Image * ) NULL ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> image = SyncNextImageInList ( image ) ; <NEW_LINE> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) ,
if ( ! mWindow || ! mWindow -> GetOuterWindow ( ) || <NEW_LINE> mWindow -> GetOuterWindow ( ) -> GetCurrentInnerWindow ( ) != mWindow ) { <NEW_LINE> aRv . Throw ( NS_ERROR_NOT_AVAILABLE ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> MediaManager * manager = MediaManager::Get ( ) ; <NEW_LINE> <START_VULN> aRv = manager -> GetUserMediaDevices ( mWindow , aConstraints , onsuccess , onerror ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif <NEW_LINE> DesktopNotificationCenter * <NEW_LINE> Navigator::GetMozNotification ( ErrorResult & aRv ) <NEW_LINE> { <NEW_LINE> if ( mNotification ) { <NEW_LINE> return mNotification ;
#include < freerdp / api . h > <NEW_LINE> <START_VULN> FREERDP_LOCAL void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , <NEW_LINE> <END_VULN> UINT32 rowstride ) ; <NEW_LINE> #endif
rv = BuildArrayRecursive ( curChild , inItemArray ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsresult nsDocShellBackwardsEnumerator::BuildArrayRecursive ( nsIDocShellTreeItem * inItem , nsTArray < nsIDocShellTreeItem * > & inItemArray ) <NEW_LINE> <END_VULN> { <NEW_LINE> nsresult rv ; <NEW_LINE> nsCOMPtr < nsIDocShellTreeNode > itemAsNode = do_QueryInterface ( inItem , & rv ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> PRInt32 numChildren ; <NEW_LINE> rv = itemAsNode -> GetChildCount ( & numChildren ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ;
if ( ! lengthlist ) goto _eofout ; <NEW_LINE> for ( i = 0 ; i < s -> entries ; ) { <NEW_LINE> <START_VULN> long num = oggpack_read ( opb , _ilog ( s -> entries - i ) ) ; <NEW_LINE>if ( num < 0 ) goto _eofout ; <NEW_LINE>for ( j = 0 ; j < num && i < s -> entries ; j ++ , i ++ ) <NEW_LINE>lengthlist [ i ] = ( char ) length ; <NEW_LINE>s -> dec_maxlength = length ; <NEW_LINE>length ++ ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> break ;
tap_ops_failed: <NEW_LINE> rtnl_link_unregister ( & ipgre_link_ops ) ; <NEW_LINE> rtnl_link_failed: <NEW_LINE> <START_VULN> unregister_pernet_device ( & ipgre_net_ops ) ; <NEW_LINE>gen_device_failed: <NEW_LINE> <END_VULN> inet_del_protocol ( & ipgre_protocol , IPPROTO_GRE ) ; <NEW_LINE> goto out ; <NEW_LINE> }
virtual void scheduleBeginFrameAndCommit ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> CCMainThread::postTask ( m_proxy -> createBeginFrameAndCommitTaskOnCCThread ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> virtual void scheduleDrawAndPresent ( )
t = plaintext -> len ; <NEW_LINE> t - = paddingLength + overhead ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> good = DUPLICATE_MSB_TO_ALL ( ~ t ) ; <NEW_LINE> t = blockSize - ( paddingLength + 1 ) ;
cp = ( const u_char * ) ( p + 1 ) ; <NEW_LINE> ep2 = ( const u_char * ) p + item_len ; <NEW_LINE> while ( cp < ep && cp < ep2 ) { <NEW_LINE> <START_VULN> if ( map && nmap ) { <NEW_LINE>cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <NEW_LINE>map , nmap ) ; <NEW_LINE> } else <NEW_LINE>cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ep < ep2 ) <NEW_LINE> ND_PRINT ( ( ndo , " . . . " ) ) ;
static nsTHashtable < nsISupportsHashKey > * sAllowedTags ; <NEW_LINE> static nsTHashtable < nsISupportsHashKey > * sAllowedAttributes ; <NEW_LINE> } ; <NEW_LINE> nsTHashtable < nsISupportsHashKey > * nsHTMLParanoidFragmentSink::sAllowedTags ; <NEW_LINE> nsTHashtable < nsISupportsHashKey > * nsHTMLParanoidFragmentSink::sAllowedAttributes ; <NEW_LINE> <START_VULN> nsHTMLParanoidFragmentSink::nsHTMLParanoidFragmentSink ( ) : <NEW_LINE>nsHTMLFragmentContentSink ( PR_FALSE ) , mSkip ( PR_FALSE ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsHTMLParanoidFragmentSink::Init ( ) <NEW_LINE> { <NEW_LINE> nsresult rv = NS_ERROR_FAILURE ;
#include < stdlib . h > <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < string . h > <NEW_LINE> <START_VULN> #include "compiler / debug . h" <NEW_LINE> <END_VULN> #include "compiler / preprocessor / slglobals . h" <NEW_LINE> #undef malloc <NEW_LINE> #undef realloc <NEW_LINE> #undef free
img -> bps = bps ; <NEW_LINE> <START_VULN> img -> stride [ VPX_PLANE_Y ] = img -> stride [ VPX_PLANE_ALPHA ] = s ; <NEW_LINE>img -> stride [ VPX_PLANE_U ] = img -> stride [ VPX_PLANE_V ] = s >> xcs ; <NEW_LINE> <END_VULN> if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) )
grub_ext2_read_inode ( diro -> data , <NEW_LINE> grub_le_to_cpu32 ( dirent . inode ) , <NEW_LINE> & fdiro -> inode ) ; <NEW_LINE> <START_VULN> if ( grub_errno ) <NEW_LINE> { <NEW_LINE> <END_VULN> grub_free ( fdiro ) ; <NEW_LINE> return 0 ; <NEW_LINE> }
{ <NEW_LINE> ASSERT ( m_policyDownloadID ) ; <NEW_LINE> <START_VULN> DownloadManager::shared ( ) . startDownload ( m_policyDownloadID , request ) ; <NEW_LINE> <END_VULN> m_policyDownloadID = 0 ; <NEW_LINE> }
if ( ! name ) { <NEW_LINE> nsresult rv = nsContentUtils::CheckQName ( aName , false ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsCOMPtr < nsIAtom > nameAtom ; <NEW_LINE> if ( IsInHTMLDocument ( ) ) { <NEW_LINE> nsAutoString lower ; <NEW_LINE> <START_VULN> nsContentUtils::ASCIIToLower ( aName , lower ) ; <NEW_LINE>nameAtom = do_GetAtom ( lower ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else { <NEW_LINE> nameAtom = do_GetAtom ( aName ) ; <NEW_LINE> } <NEW_LINE> NS_ENSURE_TRUE ( nameAtom , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> return SetAttr ( kNameSpaceID_None , nameAtom , aValue , true ) ; <NEW_LINE> }
void RemoveAutocompleteSuggestion ( const WebKit::WebString & name , <NEW_LINE> const WebKit::WebString & value ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> void SuggestionsReceived ( int query_id , <NEW_LINE> const std::vector < string16 > & values , <NEW_LINE> const std::vector < string16 > & labels ,
void init ( JSContext * cx ) ; <NEW_LINE> ~ TypeCompartment ( ) ; <NEW_LINE> inline JSCompartment * compartment ( ) ; <NEW_LINE> inline void addPending ( JSContext * cx , TypeConstraint * constraint , TypeSet * source , Type type ) ; <NEW_LINE> <START_VULN> void growPendingArray ( JSContext * cx ) ; <NEW_LINE> <END_VULN> inline void resolvePending ( JSContext * cx ) ; <NEW_LINE> void print ( JSContext * cx , bool force ) ;
user_manager::UserList users_ ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> std::map < AccountId , proximity_auth::mojom::AuthType > user_auth_type_map_ ;
if ( inputBufferHeader -> nTimeStamp > mLastTimestamp ) { <NEW_LINE> frameDuration = ( uint32_t ) ( inputBufferHeader -> nTimeStamp - mLastTimestamp ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> frameDuration = ( uint32_t ) ( ( ( uint64_t ) 1000000 << 16 ) / mFramerate ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> mLastTimestamp = inputBufferHeader -> nTimeStamp ; <NEW_LINE> codec_return = vpx_codec_encode (
#ifdef PNG_READ_GAMMA_SUPPORTED <NEW_LINE> png_color_16 background_1 ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_WRITE_FLUSH_SUPPORTED <NEW_LINE> png_flush_ptr output_flush_fn ;
for ( lvl = 0 ; lvl <= MAX_LOOP_FILTER ; lvl ++ ) { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> int block_inside_limit = lvl >> ( ( sharpness_lvl > 0 ) + ( sharpness_lvl > 4 ) ) ; <NEW_LINE> if ( sharpness_lvl > 0 ) {
case IPPROTO_SHIM6: <NEW_LINE> hdrextlen = 8 + ( * ( pkt + 1 ) * 8 ) ; <NEW_LINE> if ( hdrextlen > plen ) { <NEW_LINE> <START_VULN> ENGINE_SET_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <NEW_LINE> <END_VULN> SCReturn ; <NEW_LINE> } <NEW_LINE> nh = * pkt ;
<START_VULN> return ( png_ptr ? 0L: 0L ) ; <NEW_LINE> <END_VULN> }
#define EHMER_OFFSET 16 <NEW_LINE> #define EHMER_MAX 56 <NEW_LINE> <START_VULN> static float tonemasks [ P_BANDS ] [ 6 ] [ EHMER_MAX ] = { <NEW_LINE> <END_VULN> { { - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , <NEW_LINE> - 60 , - 60 , - 60 , - 60 , - 62 , - 62 , - 65 , - 73 , <NEW_LINE> - 69 , - 68 , - 68 , - 67 , - 70 , - 70 , - 72 , - 74 , <NEW_LINE> - 75 , - 79 , - 79 , - 80 , - 83 , - 88 , - 93 , - 100 , <NEW_LINE> - 110 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , <NEW_LINE> - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , <NEW_LINE> - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999
} <NEW_LINE> len += 128 ; <NEW_LINE> buf = ( char * ) PORT_Alloc ( len ) ; <NEW_LINE> if ( ! buf ) { <NEW_LINE> <START_VULN> return ( 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> tmpbuf = buf ; <NEW_LINE> if ( cn ) { <NEW_LINE> PORT_Memcpy ( tmpbuf , cn -> data , cn -> len ) ; <NEW_LINE> tmpbuf += cn -> len ; <NEW_LINE> PORT_Memcpy ( tmpbuf , BREAK , BREAKLEN ) ;
length = ( size_t ) pcx_info . bytes_per_line ; <NEW_LINE> pixel_info = AcquireVirtualMemory ( length , pcx_info . planes * sizeof ( * pixels ) ) ; <NEW_LINE> if ( pixel_info == ( MemoryInfo * ) NULL ) <NEW_LINE> <START_VULN> ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <END_VULN> pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; <NEW_LINE> q = pixels ; <NEW_LINE> if ( ( image -> storage_class == DirectClass ) || ( image -> colors > 256 ) )
make_four_random_bytes ( store_seed , mark ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #ifdef PNG_READ_SUPPORTED <NEW_LINE> <END_VULN>
UIPC_LOCK ( ) ; <NEW_LINE> <START_VULN> if ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) < 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> BTIF_TRACE_ERROR ( "failed to write ( % s ) " , strerror ( errno ) ) ; <NEW_LINE> }
nbchars = xmlCharEncFirstLineInput ( input -> buf , len ) ; <NEW_LINE> } <NEW_LINE> if ( nbchars < 0 ) { <NEW_LINE> xmlErrInternal ( ctxt , <NEW_LINE> "switching encoding: encoder error\n" , <NEW_LINE> NULL ) ; <NEW_LINE> return ( - 1 ) ; <NEW_LINE> } <NEW_LINE> input -> buf -> rawconsumed += use - xmlBufUse ( input -> buf -> raw ) ; <NEW_LINE> <START_VULN> xmlBufResetInput ( input -> buf -> buffer , input ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return ( 0 ) ; <NEW_LINE> } else if ( input -> length == 0 ) {
break ; <NEW_LINE> if ( currChild -> isListMarker ( ) ) <NEW_LINE> currChild = currChild -> nextSibling ( ) ; <NEW_LINE> <START_VULN> else if ( currChild -> isFloatingOrPositioned ( ) ) { <NEW_LINE> <END_VULN> if ( currChild -> style ( ) -> styleType ( ) == FIRST_LETTER ) { <NEW_LINE> currChild = currChild -> firstChild ( ) ; <NEW_LINE> break ;
"bold command . Then they shouldn't " <NEW_LINE> "be present after it . " ; <NEW_LINE> <START_VULN> Selection ( ) . SetSelection ( SelectionInDOMTree::Builder ( ) <NEW_LINE> . Collapse ( end_of_text ) <NEW_LINE> . SetIsHandleVisible ( true ) <NEW_LINE> . Build ( ) ) ; <NEW_LINE> <END_VULN> EXPECT_TRUE ( Selection ( ) . IsHandleVisible ( ) ) ; <NEW_LINE> Selection ( ) . SelectAll ( ) ; <NEW_LINE> GetDocument ( ) . execCommand ( "bold" , false , "" , ASSERT_NO_EXCEPTION ) ;
mContent -> mPendingInstantiateEvent = nsnull ; <NEW_LINE> nsIObjectFrame * frame = mContent -> <NEW_LINE> GetExistingFrame ( nsObjectLoadingContent::eFlushContent ) ; <NEW_LINE> <START_VULN> if ( frame == mFrame && <NEW_LINE> <END_VULN> mContent -> mURI == mURI && <NEW_LINE> mContent -> mContentType . Equals ( mContentType ) ) { <NEW_LINE> if ( LOG_ENABLED ( ) ) { <NEW_LINE> nsCAutoString spec ; <NEW_LINE> if ( mURI ) { <NEW_LINE> mURI -> GetSpec ( spec ) ; <NEW_LINE> } <NEW_LINE> LOG ( ( "OBJLC [ % p ] : Handling Instantiate event: Type = < % s > URI = % p < % s > \n" ,
} <NEW_LINE> #ifdef ANDROID <NEW_LINE> <START_VULN> __android_log_print ( ANDROID_LOG_INFO , "Gecko" , buffer . ptr ( ) ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> fputs ( buffer . ptr ( ) , stdout ) ; <NEW_LINE> fflush ( stdout ) ;
temp_in [ j ] = input [ j * stride + i ] * 4 ; <NEW_LINE> ht . cols ( temp_in , temp_out ) ; <NEW_LINE> for ( j = 0 ; j < 16 ; ++ j ) <NEW_LINE> <START_VULN> outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ; <NEW_LINE> <END_VULN> }
{ <NEW_LINE> JSScript * oldscript ; <NEW_LINE> JSBool ok ; <NEW_LINE> uint32 length , lineno , nslots ; <NEW_LINE> uint32 natoms , nsrcnotes , ntrynotes , nobjects , nregexps , nconsts , i ; <NEW_LINE> uint32 prologLength , version , encodedClosedCount ; <NEW_LINE> uint16 nClosedArgs = 0 , nClosedVars = 0 ; <NEW_LINE> uint32 nTypeSets = 0 ; <NEW_LINE> <START_VULN> JSPrincipals * principals ; <NEW_LINE>uint32 encodeable ; <NEW_LINE> <END_VULN> JSSecurityCallbacks * callbacks ; <NEW_LINE> uint32 scriptBits = 0 ; <NEW_LINE> JSContext * cx = xdr -> cx ; <NEW_LINE> JSScript * script = * scriptp ; <NEW_LINE> nsrcnotes = ntrynotes = natoms = nobjects = nregexps = nconsts = 0 ; <NEW_LINE> jssrcnote * notes = NULL ; <NEW_LINE> XDRScriptState * state = xdr -> state ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> RasterImage::WriteToDecoder ( const char * aBuffer , uint32_t aCount , DecodeStrategy aStrategy ) <NEW_LINE> { <NEW_LINE> <START_VULN> mDecodingMutex . AssertCurrentThreadOwns ( ) ; <NEW_LINE> <END_VULN> NS_ABORT_IF_FALSE ( mDecoder , "Trying to write to null decoder ! " ) ; <NEW_LINE> nsRefPtr < Decoder > kungFuDeathGrip = mDecoder ; <NEW_LINE> mInDecoder = true ; <NEW_LINE> mDecoder -> Write ( aBuffer , aCount , aStrategy ) ;
size_t mjitDataSize ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> bool inOOMReport ; <NEW_LINE> <END_VULN> #if defined ( MOZ_GCTIMER ) || defined ( JSGC_TESTPILOT ) <NEW_LINE> struct GCData { <NEW_LINE> uint64 firstEnter ; <NEW_LINE> bool firstEnterValid ;
int vp8dx_start_decode ( BOOL_DECODER * br , <NEW_LINE> const unsigned char * source , <NEW_LINE> unsigned int source_sz , <NEW_LINE> <START_VULN> vp8_decrypt_cb * decrypt_cb , <NEW_LINE> <END_VULN> void * decrypt_state ) ; <NEW_LINE> void vp8dx_bool_decoder_fill ( BOOL_DECODER * br ) ;
MIRType propertyType = MIRTypeFromValueType ( aggregateProperty . ref ( ) . knownTypeTag ( constraints ) ) ; <NEW_LINE> switch ( propertyType ) { <NEW_LINE> case MIRType_Boolean: <NEW_LINE> case MIRType_Int32: <NEW_LINE> case MIRType_Double: <NEW_LINE> case MIRType_String: { <NEW_LINE> <START_VULN> if ( ( * pvalue ) -> type ( ) != MIRType_Value ) { <NEW_LINE><NEW_LINE><NEW_LINE>JS_ASSERT ( ( * pvalue ) -> type ( ) != propertyType ) ; <NEW_LINE> <END_VULN> return false ; <NEW_LINE> } <NEW_LINE> MInstruction * ins = MUnbox::New ( alloc , * pvalue , propertyType , MUnbox::Fallible ) ; <NEW_LINE> current -> add ( ins ) ; <NEW_LINE> * pvalue = ins ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> default: ;
{ <NEW_LINE> MOZ_COUNT_DTOR ( nsXBLProtoImpl ) ; <NEW_LINE> delete mMembers ; <NEW_LINE> delete mFields ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsresult InstallImplementation ( nsXBLPrototypeBinding * aBinding , nsIContent * aBoundElement ) ; <NEW_LINE> <END_VULN> nsresult InitTargetObjects ( nsXBLPrototypeBinding * aBinding , nsIScriptContext * aContext , <NEW_LINE> nsIContent * aBoundElement , <NEW_LINE> nsIXPConnectJSObjectHolder ** aScriptObjectHolder , <NEW_LINE> JSObject ** aTargetClassObject ) ; <NEW_LINE> nsresult CompilePrototypeMembers ( nsXBLPrototypeBinding * aBinding ) ; <NEW_LINE> void SetMemberList ( nsXBLProtoImplMember * aMemberList ) <NEW_LINE> {
dst = dst_ybc -> v_buffer ; <NEW_LINE> for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { <NEW_LINE> <START_VULN> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <NEW_LINE> <END_VULN> src += src_ybc -> uv_stride ; <NEW_LINE> dst += dst_ybc -> uv_stride ; <NEW_LINE> }
{ <NEW_LINE> struct crypto_report_cipher rcipher ; <NEW_LINE> <START_VULN> strlcpy ( rcipher . type , "cipher" , sizeof ( rcipher . type ) ) ; <NEW_LINE> <END_VULN> rcipher . blocksize = alg -> cra_blocksize ; <NEW_LINE> rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ;
ns = js_ConstructObject ( cx , & js_NamespaceClass , NULL , obj , <NEW_LINE> argc == 0 ? 0 : 1 , Valueify ( vp + 2 ) ) ; <NEW_LINE> if ( ! ns ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> vp [ 0 ] = OBJECT_TO_JSVAL ( ns ) ; <NEW_LINE> ns -> setNamespaceDeclared ( JSVAL_TRUE ) ; <NEW_LINE> <START_VULN> qnargv [ 0 ] = vp [ 2 ] = OBJECT_TO_JSVAL ( ns ) ; <NEW_LINE> <END_VULN> qnargv [ 1 ] = OBJECT_TO_JSVAL ( xml -> name ) ; <NEW_LINE> qn = js_ConstructObject ( cx , & js_QNameClass , NULL , NULL , 2 , Valueify ( qnargv ) ) ; <NEW_LINE> if ( ! qn ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> xml -> name = qn ;
<START_VULN> <NEW_LINE> <END_VULN> #define LOCK_SIZE	32 <NEW_LINE> #define LOCK_SALT_SIZE	16
#define BT_SHB			0x0A0D0D0A <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> struct section_header_block { <NEW_LINE> bpf_u_int32	byte_order_magic ; <NEW_LINE> u_short		major_version ;
nsIPrincipal * originPrincipal , <NEW_LINE> nsISupports * context , <NEW_LINE> const nsACString & mimeType , <NEW_LINE> nsISupports * extra , <NEW_LINE> int16_t * decision , <NEW_LINE> nsIContentPolicy * policyService = nullptr , <NEW_LINE> nsIScriptSecurityManager * aSecMan = nullptr ) <NEW_LINE> { <NEW_LINE> <START_VULN> CHECK_PRINCIPAL ; <NEW_LINE> <END_VULN> if ( policyService ) { <NEW_LINE> CHECK_CONTENT_POLICY_WITH_SERVICE ( ShouldProcess , policyService ) ; <NEW_LINE> } <NEW_LINE> CHECK_CONTENT_POLICY ( ShouldProcess ) ; <NEW_LINE> } <NEW_LINE> #undef CHECK_CONTENT_POLICY <NEW_LINE> #undef CHECK_CONTENT_POLICY_WITH_SERVICE
const int mi_dc = hbs * ( n & 1 ) ; <NEW_LINE> const int mi_dr = hbs * ( n >> 1 ) ; <NEW_LINE> <START_VULN> count_segs_sb ( cpi , tile , & mi_8x8 [ mi_dr * mis + mi_dc ] , <NEW_LINE> <END_VULN> no_pred_segcounts , temporal_predictor_count , <NEW_LINE> t_unpred_seg_counts , <NEW_LINE> mi_row + mi_dr , mi_col + mi_dc , subsize ) ;
if ( ! parent -> isHTMLElement ( ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> RefPtr < DocumentFragment > fragment = Range::createDocumentFragmentForElement ( markup , toHTMLElement ( parent ) ) ; <NEW_LINE> <END_VULN> if ( ! fragment || ! fragment -> firstChild ( ) ) <NEW_LINE> return ;
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> CreateTables ( mozIStorageConnection * aDBConn ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> NS_ASSERTION ( aDBConn , "Passing a null database connection ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "CreateTables" ) ; <NEW_LINE> nsresult rv = aDBConn -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( <NEW_LINE> "CREATE TABLE database ( "
XPC_SJOW_Construct ( JSContext * cx , JSObject * obj , uintN , jsval * argv , <NEW_LINE> jsval * rval ) ; <NEW_LINE> PRBool <NEW_LINE> XPC_SJOW_AttachNewConstructorObject ( XPCCallContext & ccx , <NEW_LINE> JSObject * aGlobalObject ) ; <NEW_LINE> JSBool <NEW_LINE> <START_VULN> XPC_XOW_WrapObject ( JSContext * cx , JSObject * parent , jsval * vp ) ; <NEW_LINE> <END_VULN> #ifdef XPC_IDISPATCH_SUPPORT <NEW_LINE> #include "XPCDispPrivate . h" <NEW_LINE> #endif
char * tok ; <NEW_LINE> int64 major , minor , patch ; <NEW_LINE> <START_VULN> major = stoi ( stok ( sclone ( version ) , " . " , & tok ) ) ; <NEW_LINE>minor = stoi ( stok ( tok , " . " , & tok ) ) ; <NEW_LINE>patch = stoi ( stok ( tok , " . " , & tok ) ) ; <NEW_LINE> <END_VULN> return ( ( ( major * VER_FACTOR ) + minor ) * VER_FACTOR ) + patch ; <NEW_LINE> }
<START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> #ifndef CHROME_RENDERER_SAFE_BROWSING_PHISHING_CLASSIFIER_H_ <NEW_LINE> #define CHROME_RENDERER_SAFE_BROWSING_PHISHING_CLASSIFIER_H_
if ( in -> proc_buf_frames ) { <NEW_LINE> memcpy ( in -> proc_buf_in , <NEW_LINE> <START_VULN> in -> proc_buf_in + in_buf . frameCount * src_channels * bytes_per_sample , <NEW_LINE>in -> proc_buf_frames * in -> config . channels * audio_bytes_per_sample ( in_get_format ( in ) ) ) ; <NEW_LINE> <END_VULN> }
fdbname , fmtId ( dbtablespace ) ) ; <NEW_LINE> <START_VULN> appendPQExpBuffer ( buf , "\\connect % s\n" , fdbname ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( binary_upgrade )
#ifndef WITH_MODULES <NEW_LINE> #define WITH_MODULES <NEW_LINE> #endif <NEW_LINE> <START_VULN> #define LIBXSLT_DEFAULT_PLUGINS_PATH ( ) " / usr / local / lib / libxslt - plugins" <NEW_LINE> <END_VULN> #endif
nsIFrame * frame = nullptr ; <NEW_LINE> nsCOMPtr < nsIDOMNode > node ; <NEW_LINE> rv = domSelection -> GetFocusNode ( getter_AddRefs ( node ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , false ) ; <NEW_LINE> NS_ENSURE_TRUE ( node , false ) ; <NEW_LINE> nsCOMPtr < nsIContent > content ( do_QueryInterface ( node ) ) ; <NEW_LINE> if ( content ) { <NEW_LINE> <START_VULN> nsIContent * nonNative = content -> FindFirstNonNativeAnonymous ( ) ; <NEW_LINE> <END_VULN> content = nonNative ; <NEW_LINE> } <NEW_LINE> if ( content ) {
q = ( const uint8_t * ) ( const void * ) <NEW_LINE> ( ( const char * ) ( const void * ) p + ofs <NEW_LINE> - 2 * sizeof ( uint32_t ) ) ; <NEW_LINE> <START_VULN> if ( q > e ) { <NEW_LINE> <END_VULN> DPRINTF ( ( "Ran of the end % p > % p\n" , q , e ) ) ; <NEW_LINE> goto out ; <NEW_LINE> }
return enumerate ( cx , wrapper , JSITER_OWNONLY | JSITER_HIDDEN , props ) ; <NEW_LINE> } <NEW_LINE> template < typename Base , typename Traits > <NEW_LINE> bool <NEW_LINE> XrayWrapper < Base , Traits > ::delete_ ( JSContext * cx , JSObject * wrapper , jsid id , bool * bp ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( XrayUtils::IsTransparent ( cx , wrapper ) ) { <NEW_LINE> <END_VULN> JSObject * obj = Traits::getTargetObject ( wrapper ) ; <NEW_LINE> JSAutoCompartment ac ( cx , obj ) ; <NEW_LINE> JSBool b ; <NEW_LINE> jsval v ; <NEW_LINE> if ( ! JS_DeletePropertyById2 ( cx , obj , id , & v ) || ! JS_ValueToBoolean ( cx , v , & b ) ) <NEW_LINE> return false ;
bool mDroppedDown ; <NEW_LINE> bool mInRedisplayText ; <NEW_LINE> bool mDelayedShowDropDown ; <NEW_LINE> <START_VULN> static nsComboboxControlFrame * mFocused ; <NEW_LINE> <END_VULN> #ifdef DO_REFLOW_COUNTER <NEW_LINE> PRInt32 mReflowId ; <NEW_LINE> #endif <NEW_LINE> } ; <NEW_LINE> #endif
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File: readelf . c , v 1 . 102 2014 / 03 / 11 21:00:13 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef BUILTIN_ELF
draw_info -> direction == RightToLeftDirection ? image -> columns - <NEW_LINE> metrics . bounds . x2 : 0 . 0 , draw_info -> gravity == UndefinedGravity ? <NEW_LINE> metrics . ascent : 0 . 0 ) ; <NEW_LINE> <START_VULN> draw_info -> geometry = AcquireString ( geometry ) ; <NEW_LINE> <END_VULN> status = AnnotateImage ( image , draw_info ) ; <NEW_LINE> if ( image_info -> pointsize == 0 . 0 ) <NEW_LINE> {
png_bytep quantize_index ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> #ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED <NEW_LINE>png_byte heuristic_method ; <NEW_LINE>png_byte num_prev_filters ; <NEW_LINE>png_bytep prev_filters ; <NEW_LINE>png_uint_16p filter_weights ; <NEW_LINE>png_uint_16p inv_filter_weights ; <NEW_LINE>png_uint_16p filter_costs ; <NEW_LINE>png_uint_16p inv_filter_costs ; <NEW_LINE>#endif <NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> #ifdef PNG_SET_OPTION_SUPPORTED <NEW_LINE> png_byte options ; <NEW_LINE> #endif
if ( s -> size - stream_ptr < n_blocks * 4 ) <NEW_LINE> return ; <NEW_LINE> while ( n_blocks -- ) { <NEW_LINE> block_ptr = row_ptr + pixel_ptr ; <NEW_LINE> for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { <NEW_LINE> } <NEW_LINE> <START_VULN> ADVANCE_BLOCK ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> break ;
: public base::RefCounted < BluetoothAdapter > { <NEW_LINE> public: <NEW_LINE> <START_VULN> class Observer { <NEW_LINE> <END_VULN> public: <NEW_LINE> virtual ~ Observer ( ) { }
mAnimationElementTable . PutEntry ( aAnimationElement ) ; <NEW_LINE> if ( mDeferredStartSampling ) { <NEW_LINE> mDeferredStartSampling = PR_FALSE ; <NEW_LINE> if ( mChildContainerTable . Count ( ) ) { <NEW_LINE> NS_ABORT_IF_FALSE ( mAnimationElementTable . Count ( ) == 1 , <NEW_LINE> "we shouldn't have deferred sampling if we already had " <NEW_LINE> "animations registered" ) ; <NEW_LINE> <START_VULN> StartSampling ( GetRefreshDriverForDoc ( mDocument ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsSMILAnimationController::UnregisterAnimationElement ( <NEW_LINE> nsISMILAnimationElement * aAnimationElement ) <NEW_LINE> {
xtmp = sk_X509_pop ( ctx -> chain ) ; <NEW_LINE> X509_free ( xtmp ) ; <NEW_LINE> num -- ; <NEW_LINE> <START_VULN> ctx -> last_untrusted -- ; <NEW_LINE> <END_VULN> } <NEW_LINE> retry = 1 ; <NEW_LINE> break ; <NEW_LINE> }
return nullptr ; <NEW_LINE> return newSkImageFromRaster ( <NEW_LINE> info , std::move ( dstPixels ) , <NEW_LINE> <START_VULN> static_cast < size_t > ( input -> width ( ) ) * info . bytesPerPixel ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> sk_sp < SkImage > ImageBitmap::getSkImageFromDecoder (
if ( ch == ' % ' ) <NEW_LINE> state = DP_S_FLAGS ; <NEW_LINE> else <NEW_LINE> <START_VULN> doapr_outch ( sbuffer , buffer , & currlen , maxlen , ch ) ; <NEW_LINE> <END_VULN> ch = * format ++ ; <NEW_LINE> break ; <NEW_LINE> case DP_S_FLAGS:
<START_VULN> for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <NEW_LINE> <END_VULN> jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ; <NEW_LINE> }
fclose ( orig ) ; <NEW_LINE> fclose ( recons ) ; <NEW_LINE> <START_VULN> if ( diffs != 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> return XD3_INTERNAL ; <NEW_LINE> }
} <NEW_LINE> if ( up ) { <NEW_LINE> <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <NEW_LINE> <END_VULN> fprintf ( stdout , "BT adapter is up\n" ) ; <NEW_LINE> fprintf ( stdout , "Waiting for % d seconds\n" , timeout_in_sec ) ;
virtual void OnConfigWatcherError ( ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void OnChannelConnected ( ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual bool OnMessageReceived ( const IPC::Message & message ) OVERRIDE ; <NEW_LINE> virtual void OnPermanentError ( ) OVERRIDE ;
{ <NEW_LINE> if ( ! Base::getPropertyDescriptor ( cx , wrapper , id , set , desc ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> return FilterSetter < Policy > ( cx , wrapper , id , desc ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> template < typename Base , typename Policy >
if ( m_info . output_scanline == 0xffffff ) <NEW_LINE> m_info . output_scanline = 0 ; <NEW_LINE> <START_VULN> if ( ! m_decoder -> outputScanlines ( ) ) { <NEW_LINE> <END_VULN> if ( ! m_info . output_scanline )
make sure there are no rw files opened * / <NEW_LINE> if ( remount_ro ) { <NEW_LINE> if ( force ) { <NEW_LINE> <START_VULN> mark_files_ro ( sb ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> retval = sb_prepare_remount_readonly ( sb ) ; <NEW_LINE> if ( retval )
PHP_FUNCTION ( curl_escape ) <NEW_LINE> { <NEW_LINE> char * str = NULL , * res = NULL ; <NEW_LINE> <START_VULN> size_t str_len = 0 ; <NEW_LINE> <END_VULN> zval * zid ; <NEW_LINE> php_curl * ch ;
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( mount ( "none" , path , "tmpfs" , 0 , "size = 100000 , mode = 755" ) ) { <NEW_LINE> <END_VULN> SYSERROR ( "Failed mounting tmpfs onto % s\n" , path ) ; <NEW_LINE> return false ; <NEW_LINE> }
int hb_generat_bin_from_kernel_source ( cl_program program , const char * cl_file_name ) <NEW_LINE> { <NEW_LINE> <START_VULN> int i = 0 ; <NEW_LINE>cl_int status ; <NEW_LINE>cl_uint numDevices ; <NEW_LINE>size_t * binarySizes ; <NEW_LINE>cl_device_id * devices ; <NEW_LINE>char ** binaries ; <NEW_LINE>char * str = NULL ; <NEW_LINE> <END_VULN> if ( hb_ocl == NULL ) <NEW_LINE> {
{ <NEW_LINE> png_uint_32 ig = ( j << ( 8 - shift ) ) + i ; <NEW_LINE> <START_VULN> if ( shift ) <NEW_LINE> <END_VULN> ig = ( ig * 65535U + max_by_2 ) / max ; <NEW_LINE> sub_table [ j ] = ( png_uint_16 ) ig ;
} <NEW_LINE> else <NEW_LINE> { <NEW_LINE> <START_VULN> memcpy ( cp , qp -> d_memory , memory_length ) ; <NEW_LINE> <END_VULN> qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ; <NEW_LINE> qp -> d_write = cp + ( qp -> d_write - qp -> d_memory ) ; <NEW_LINE> }
t &= - t ; <NEW_LINE> <START_VULN> for ( i = 0 ; i < TTABLE_SIZE ; ++ i ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ( transform_info [ i ] . transform & t ) != 0 ) <NEW_LINE> return transform_info [ i ] . name ;
void H264SwDecTrace ( char * ) ; <NEW_LINE> <START_VULN> void * H264SwDecMalloc ( u32 size ) ; <NEW_LINE> <END_VULN> void H264SwDecFree ( void * ptr ) ;
this -> info ( ) . executionMode ( ) ) ; <NEW_LINE> if ( ! info ) <NEW_LINE> return false ; <NEW_LINE> MIRGraphExits saveExits ; <NEW_LINE> AutoAccumulateExits aae ( graph ( ) , saveExits ) ; <NEW_LINE> IonBuilder inlineBuilder ( cx , & temp ( ) , & graph ( ) , & oracle , <NEW_LINE> <START_VULN> info , inliningDepth + 1 , loopDepth_ ) ; <NEW_LINE> <END_VULN> if ( callInfo . constructing ( ) ) { <NEW_LINE> MDefinition * thisDefn = createThis ( callee , callInfo . fun ( ) ) ; <NEW_LINE> if ( ! thisDefn ) <NEW_LINE> return false ; <NEW_LINE> callInfo . setThis ( thisDefn ) ; <NEW_LINE> }
mysql_init ( & mysql_connection ) ; <NEW_LINE> if ( opt_compress ) <NEW_LINE> mysql_options ( & mysql_connection , MYSQL_OPT_COMPRESS , NullS ) ; <NEW_LINE> <START_VULN> #ifdef HAVE_OPENSSL <NEW_LINE>if ( opt_use_ssl ) <NEW_LINE> { <NEW_LINE>mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , <NEW_LINE>opt_ssl_capath , opt_ssl_cipher ) ; <NEW_LINE>mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; <NEW_LINE>mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; <NEW_LINE> } <NEW_LINE>#endif <NEW_LINE> <END_VULN> if ( opt_protocol ) <NEW_LINE> mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; <NEW_LINE> if ( opt_bind_addr )
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestMediaQueryListListener::s_info ) ; <NEW_LINE> TestMediaQueryListListener * impl = static_cast < TestMediaQueryListListener * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> RefPtr < MediaQueryListListener > listener ( MediaQueryListListener::create ( ScriptValue ( exec -> globalData ( ) , MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
bool snap = false , <NEW_LINE> bool animate_bounds_on_attach = true ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>void ForgetWindow ( aura::Window * window , bool destroyed ) ; <NEW_LINE> <END_VULN> bool ShouldHandleWindow ( aura::Window * window ) ;
else if ( isspace ( UCHAR_MAX & * str ) ) <NEW_LINE> putc ( '_' , out ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> else <NEW_LINE> fprintf ( out , "\\ % . 3o" , * str ) ; <NEW_LINE> }
Address addr = reinterpret_cast < Address > ( const_cast < void * > ( payload ) ) ; <NEW_LINE> HeapObjectHeader * header = <NEW_LINE> reinterpret_cast < HeapObjectHeader * > ( addr - sizeof ( HeapObjectHeader ) ) ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> return header ; <NEW_LINE> }
if ( 0 == PL_strcasecmp ( mCachedAttrParamNames [ i ] , name ) ) { <NEW_LINE> * result = mCachedAttrParamValues [ i ] ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> NS_IMETHODIMP nsPluginInstanceOwner::GetDocumentBase ( const char * * result ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_ARG_POINTER ( result ) ; <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> if ( mDocumentBase . IsEmpty ( ) ) { <NEW_LINE> if ( ! mObjectFrame ) { <NEW_LINE> * result = nsnull ; <NEW_LINE> return NS_ERROR_FAILURE ;
start_pos = cpi -> twopass . stats_in ; <NEW_LINE> <START_VULN> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <NEW_LINE> <END_VULN> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ;
return NULL ; <NEW_LINE> } <NEW_LINE> SkRegion * region = new SkRegion ; <NEW_LINE> <START_VULN> region -> readFromMemory ( regionData , size ) ; <NEW_LINE> <END_VULN> return reinterpret_cast < jlong > ( region ) ; <NEW_LINE> }
using Value = typename Table::ValueType ; <NEW_LINE> ASSERT ( ! WTF::IsTriviallyDestructible < Value > ::value ) ; <NEW_LINE> HeapObjectHeader * header = HeapObjectHeader::fromPayload ( pointer ) ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> size_t length = header -> payloadSize ( ) / sizeof ( Value ) ;
void vp8_default_coef_probs ( VP8_COMMON * pc ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs , <NEW_LINE>sizeof ( default_coef_probs ) ) ; <NEW_LINE> <END_VULN> }
if ( ConstructorMode::current ( ) == ConstructorMode::WrapExistingObject ) <NEW_LINE> return args . Holder ( ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> if ( args . Length ( ) == 1 ) {
} <NEW_LINE> void TextTrackCue::setStartTime ( double value ) { <NEW_LINE> <START_VULN> <NEW_LINE>if ( start_time_ == value || value < 0 ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> CueWillChange ( ) ;
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsTreeSelection::ClearSelection ( ) <NEW_LINE> { <NEW_LINE> if ( mFirstRange ) { <NEW_LINE> <START_VULN> mFirstRange -> Invalidate ( ) ; <NEW_LINE> <END_VULN> delete mFirstRange ; <NEW_LINE> mFirstRange = nsnull ; <NEW_LINE> } <NEW_LINE> mShiftSelectPivot = - 1 ; <NEW_LINE> FireOnSelectHandler ( ) ; <NEW_LINE> return NS_OK ;
m_webPage -> handleMouseEvent ( mouseRelease ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void TouchEventHandler::handleTouchPoint ( Platform::TouchPoint & point , unsigned modifiers ) <NEW_LINE> <END_VULN> { <NEW_LINE> m_webPage -> m_inputHandler -> setInputModeEnabled ( ) ;
#endif <NEW_LINE> #ifdef MOZ_WIDGET_ANDROID <NEW_LINE> { <NEW_LINE> nsIFocusManager * fm = nsFocusManager::GetFocusManager ( ) ; <NEW_LINE> if ( fm ) { <NEW_LINE> <START_VULN> nsCOMPtr < nsIDOMElement > elem = do_QueryInterface ( mContent ) ; <NEW_LINE> <END_VULN> fm -> SetFocus ( elem , 0 ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> switch ( anEvent . mClass ) { <NEW_LINE> case eMouseEventClass: <NEW_LINE> { <NEW_LINE> switch ( anEvent . message ) <NEW_LINE> {
uint_fast32_t len ; <NEW_LINE> <START_VULN> uchar * data ; <NEW_LINE> <END_VULN> } jpc_ppxstabent_t ;
JSContext * cx = mContext ; <NEW_LINE> JSXDRState * xdr = ::JS_XDRNewMem ( cx , JSXDR_DECODE ) ; <NEW_LINE> JSScript * result = nsnull ; <NEW_LINE> if ( ! xdr ) { <NEW_LINE> rv = NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } else { <NEW_LINE> xdr -> userdata = ( void * ) aStream ; <NEW_LINE> <START_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> <END_VULN> ::JS_XDRMemSetData ( xdr , data , size ) ; <NEW_LINE> if ( ! ::JS_XDRScript ( xdr , & result ) ) { <NEW_LINE> rv = NS_ERROR_FAILURE ; <NEW_LINE> }
return mChunkOffsetOffset >= 0 <NEW_LINE> && mSampleToChunkOffset >= 0 <NEW_LINE> && mSampleSizeOffset >= 0 <NEW_LINE> <START_VULN> && mTimeToSample != NULL ; <NEW_LINE> <END_VULN> } <NEW_LINE> status_t SampleTable::setChunkOffsetParams (
#ifdef UNUSED <NEW_LINE> <START_VULN> #elif __GNUC__ <NEW_LINE> <END_VULN> #define UNUSED __attribute__ ( ( unused ) ) <NEW_LINE> #else <NEW_LINE> #define UNUSED
ResourceTimingInfo * info , <NEW_LINE> TimeTicks time_origin , <NEW_LINE> const WebVector < WebServerTimingInfo > & server_timing ) <NEW_LINE> <START_VULN> : PerformanceResourceTiming ( info ? info -> InitialURL ( ) . GetString ( ) : "" , <NEW_LINE>"navigation" , <NEW_LINE>time_origin , <NEW_LINE>server_timing ) , <NEW_LINE> <END_VULN> ContextClient ( frame ) , <NEW_LINE> resource_timing_info_ ( info ) { <NEW_LINE> DCHECK ( frame ) ;
return t1 - t0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #elif defined ( HAVE_GETRUSAGE ) <NEW_LINE> <END_VULN> void jas_tmr_start ( jas_tmr_t * tmr ) <NEW_LINE> {
matched = 0 ; <NEW_LINE> PCRE_G ( error_code ) = PHP_PCRE_NO_ERROR ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> do { <NEW_LINE> count = pcre_exec ( pce -> re , extra , subject , subject_len , start_offset ,
LayoutPoint pagination_offset ; <NEW_LINE> LayoutUnit logical_top_in_flow_thread ; <NEW_LINE> std::unique_ptr < ObjectPaintProperties > paint_properties ; <NEW_LINE> <START_VULN> std::unique_ptr < RefCountedPropertyTreeState > local_border_box_properties ; <NEW_LINE> <END_VULN> bool is_clip_path_cache_valid = false ; <NEW_LINE> base::Optional < IntRect > clip_path_bounding_box ; <NEW_LINE> scoped_refptr < const RefCountedPath > clip_path_path ;
void UpdateCueDisplay ( ) ; <NEW_LINE> void PopulatePendingList ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>HTMLMediaElement * mMediaElement ; <NEW_LINE> <END_VULN> private: <NEW_LINE> nsRefPtr < TextTrackList > mTextTracks ; <NEW_LINE> nsRefPtr < TextTrackList > mPendingTextTracks ; <NEW_LINE> nsRefPtr < TextTrackCueList > mNewCues ;
* <NEW_LINE> SVGTransformList & InternalList ( ) const ; <NEW_LINE> <START_VULN> void EnsureItemAt ( uint32_t aIndex ) ; <NEW_LINE> <END_VULN> void MaybeInsertNullInAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> void MaybeRemoveItemFromAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> FallibleTArray < dom::SVGTransform * > mItems ;
while ( c < col_max ) <NEW_LINE> { <NEW_LINE> <START_VULN> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <NEW_LINE> <END_VULN> if ( thissad < bestsad ) <NEW_LINE> {
if ( ! addrs ) <NEW_LINE> return 0 ; <NEW_LINE> <START_VULN> net_get_random_once ( & ip6_proxy_idents_hashrnd , <NEW_LINE>sizeof ( ip6_proxy_idents_hashrnd ) ) ; <NEW_LINE><NEW_LINE>id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <NEW_LINE> & addrs [ 1 ] , & addrs [ 0 ] ) ; <NEW_LINE> <END_VULN> return htonl ( id ) ; <NEW_LINE> } <NEW_LINE> EXPORT_SYMBOL_GPL ( ipv6_proxy_select_ident ) ;
! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) <NEW_LINE> return TEE_ERROR_ACCESS_DENIED ; <NEW_LINE> <START_VULN> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <NEW_LINE> <END_VULN> uint32_t attr ; <NEW_LINE> TEE_Result res ;
aPrevFrame = kidFrame ; <NEW_LINE> } <NEW_LINE> kidFrame = kidFrame -> GetNextSibling ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == display -> mDisplay ) { <NEW_LINE> <START_VULN> NS_ASSERTION ( aListID == kPrincipalList || aListID == kColGroupList , <NEW_LINE>"unexpected child list" ) ; <NEW_LINE> <END_VULN> const nsFrameList::Slice & newColgroups = <NEW_LINE> mColGroups . InsertFrames ( nsnull , aPrevFrame , aFrameList ) ; <NEW_LINE> PRInt32 startColIndex = 0 ; <NEW_LINE> if ( aPrevFrame ) { <NEW_LINE> nsTableColGroupFrame * prevColGroup = <NEW_LINE> ( nsTableColGroupFrame * ) GetFrameAtOrBefore ( this , aPrevFrame ,
return ; <NEW_LINE> if ( policy == kUse && ! resource -> StillNeedsLoad ( ) && <NEW_LINE> <START_VULN> ! validated_ur_ls_ . Contains ( request . GetResourceRequest ( ) . Url ( ) ) ) { <NEW_LINE> <END_VULN> RefPtr < ResourceTimingInfo > info = ResourceTimingInfo::Create (
return ERROR ; <NEW_LINE> } <NEW_LINE> <START_VULN> const metadata_uptrdiff_t entries_end = <NEW_LINE>metadata -> entries_start + metadata -> entry_capacity ; <NEW_LINE> <END_VULN> if ( entries_end < metadata -> entries_start || <NEW_LINE> entries_end > metadata -> data_start ) {
virtual void TabInsertedAt ( content::WebContents * contents , <NEW_LINE> int index , <NEW_LINE> bool foreground ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void TabDetachedAt ( TabContents * contents , int index ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual void TabStripModelDeleted ( ) OVERRIDE ; <NEW_LINE> private:
void AddTaskObserver ( base::MessageLoop::TaskObserver * task_observer ) ; <NEW_LINE> void RemoveTaskObserver ( base::MessageLoop::TaskObserver * task_observer ) ; <NEW_LINE> <START_VULN> void SetTimeSourceForTesting ( scoped_ptr < TimeSource > time_source ) ; <NEW_LINE> <END_VULN>
} <NEW_LINE> <START_VULN> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ; <NEW_LINE> <END_VULN> source += source_band_height * source_pitch ;
next_image -> depth = 16 ; <NEW_LINE> monochrome = IsMonochromeImage ( image , & image -> exception ) && ( image -> depth == 1 ) <NEW_LINE> ? MagickTrue : MagickFalse ; <NEW_LINE> <START_VULN> quantum_info = AcquireQuantumInfo ( image_info , image ) ; <NEW_LINE> <END_VULN> if ( quantum_info == ( QuantumInfo * ) NULL ) <NEW_LINE> return ( 0 ) ; <NEW_LINE> pixels = GetQuantumPixels ( quantum_info ) ;
IPV6_SET_L4PROTO ( p , nh ) ; <NEW_LINE> hdrextlen = sizeof ( IPV6EspHdr ) ; <NEW_LINE> if ( hdrextlen > plen ) { <NEW_LINE> <START_VULN> ENGINE_SET_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <NEW_LINE> <END_VULN> SCReturn ; <NEW_LINE> }
if ( setjmp ( png_jmpbuf ( png_ptr ) ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> png_destroy_write_struct ( & png_ptr , ( png_infopp ) NULL ) ; <NEW_LINE> <END_VULN> return FALSE ; <NEW_LINE> }
{ "Trapped" , "" } , <NEW_LINE> } ; <NEW_LINE> <START_VULN> daddy = malloc ( sizeof ( creator_template ) ) ; <NEW_LINE> <END_VULN> memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ; <NEW_LINE> if ( n_elements )
private int <NEW_LINE> toomany ( struct magic_set * ms , const char * name , uint16_t num ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( file_printf ( ms , " , too many % s header sections ( % u ) " , name , num <NEW_LINE> <END_VULN> ) == - 1 ) <NEW_LINE> return - 1 ; <NEW_LINE> return 0 ;
return AVERROR_INVALIDDATA ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) ) { <NEW_LINE> <END_VULN> avpriv_report_missing_feature ( s -> avctx , <NEW_LINE> "JPEG - LS that is not <= 8 " <NEW_LINE> "bits / component or 16 - bit gray" ) ;
vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; <NEW_LINE> vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; <NEW_LINE> vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; <NEW_LINE> <START_VULN> vmcs_write16 ( HOST_FS_SELECTOR , kvm_read_fs ( ) ) ; <NEW_LINE>vmcs_write16 ( HOST_GS_SELECTOR , kvm_read_gs ( ) ) ; <NEW_LINE> <END_VULN> vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; <NEW_LINE> #ifdef CONFIG_X86_64 <NEW_LINE> rdmsrl ( MSR_FS_BASE , a ) ;
unsigned char * t = ( unsigned char * ) book -> dec_table ; <NEW_LINE> for ( i = 0 ; i < read ; i ++ ) { <NEW_LINE> <START_VULN> chase = t [ chase * 2 + ( ( lok >> i ) & 1 ) ] ; <NEW_LINE>if ( chase & 0x80UL ) break ; <NEW_LINE> <END_VULN> } <NEW_LINE> chase &= 0x7fUL ; <NEW_LINE> break ;
const FragmentData & fragment_data_ ; <NEW_LINE> const bool & is_actually_needed_ ; <NEW_LINE> LayoutPoint old_paint_offset_ ; <NEW_LINE> <START_VULN> scoped_refptr < const TransformPaintPropertyNode > old_paint_offset_translation_ ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> class FindVisualRectNeedingUpdateScopeBase {
} <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::getOwnPropertyNames ( JSContext * cx , JSObject * wrapper , AutoIdVector & props ) <NEW_LINE> { <NEW_LINE> PIERCE ( cx , wrapper , GET , <NEW_LINE> NOTHING , <NEW_LINE> DirectWrapper::getOwnPropertyNames ( cx , wrapper , props ) , <NEW_LINE> <START_VULN> call . origin -> wrap ( cx , props ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::delete_ ( JSContext * cx , JSObject * wrapper , jsid id , bool * bp ) <NEW_LINE> { <NEW_LINE> PIERCE ( cx , wrapper , SET , <NEW_LINE> call . destination -> wrapId ( cx , & id ) , <NEW_LINE> DirectWrapper::delete_ ( cx , wrapper , id , bp ) ,
INC_STATS ( "DOM . WebGLRenderingContext . getFramebufferAttachmentParameter ( ) " ) ; <NEW_LINE> if ( args . Length ( ) != 3 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> WebGLRenderingContext * context = V8WebGLRenderingContext::toNative ( args . Holder ( ) ) ;
void QQuickWebViewFlickablePrivate::onComponentComplete ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> Q_Q ( QQuickWebView ) ; <NEW_LINE><NEW_LINE>m_viewportHandler . reset ( new QtViewportHandler ( webPageProxy . get ( ) , q , pageView . data ( ) ) ) ; <NEW_LINE>pageView -> eventHandler ( ) -> setViewportHandler ( m_viewportHandler . data ( ) ) ; <NEW_LINE> <END_VULN> _q_onVisibleChanged ( ) ;
@param str String containing white space or comma separated words <NEW_LINE> @return Returns a list of words <NEW_LINE> @ingroup MprList <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC MprList * mprCreateListFromWords ( cchar * str ) ;
nsresult <NEW_LINE> nsComputedDOMStyle::GetBorderWidthFor ( PRUint8 aSide , nsIDOMCSSValue ** aValue ) <NEW_LINE> { <NEW_LINE> nsROCSSPrimitiveValue * val = GetROCSSPrimitiveValue ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( val , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> nscoord width ; <NEW_LINE> if ( mInnerFrame ) { <NEW_LINE> <START_VULN> FlushPendingReflows ( ) ; <NEW_LINE> <END_VULN> width = mInnerFrame -> GetUsedBorder ( ) . side ( aSide ) ; <NEW_LINE> } else { <NEW_LINE> width = GetStyleBorder ( ) -> GetActualBorderWidth ( aSide ) ; <NEW_LINE> } <NEW_LINE> val -> SetAppUnits ( width ) ; <NEW_LINE> return CallQueryInterface ( val , aValue ) ; <NEW_LINE> }
virtual void OnCallbacksChanged ( ) { <NEW_LINE> } <NEW_LINE> public: <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>nsresult Redirect ( nsIChannel * newChannel , PRUint32 redirectFlags ) ; <NEW_LINE> <END_VULN> PRBool HasContentTypeHint ( ) const ;
float CVE_2012_1960_clamp_float ( float a ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( a > 1 . ) <NEW_LINE>return 1 . ; <NEW_LINE>else if ( a < 0 ) <NEW_LINE>return 0 ; <NEW_LINE>else <NEW_LINE>return a ; <NEW_LINE> <END_VULN> }
return NS_OK ; <NEW_LINE> nsCOMPtr < nsIWidget > widget = GetWidget ( sPresContext ) ; <NEW_LINE> if ( widget ) { <NEW_LINE> IMEState newState = GetNewIMEState ( sPresContext , nsnull ) ; <NEW_LINE> InputContextAction action ( InputContextAction::CAUSE_UNKNOWN , <NEW_LINE> InputContextAction::LOST_FOCUS ) ; <NEW_LINE> SetIMEState ( newState , nsnull , widget , action ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> sContent = nsnull ; <NEW_LINE> <END_VULN> sPresContext = nsnull ; <NEW_LINE> OnTextStateBlur ( nsnull , nsnull ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsIMEStateManager::OnRemoveContent ( nsPresContext * aPresContext , <NEW_LINE> nsIContent * aContent )
unsigned rendering_context_id = 0 ; <NEW_LINE> CompositingReasons direct_compositing_reasons = CompositingReason::kNone ; <NEW_LINE> CompositorElementId compositor_element_id ; <NEW_LINE> <START_VULN> scoped_refptr < const ScrollPaintPropertyNode > scroll ; <NEW_LINE> <END_VULN> bool operator == ( const State & o ) const { <NEW_LINE> return matrix == o . matrix && origin == o . origin &&
namespace WebCore { <NEW_LINE> <START_VULN> class MediaStreamSource : public RefCounted < MediaStreamSource > { <NEW_LINE> <END_VULN> public: <NEW_LINE> class Observer { <NEW_LINE> public:
} <NEW_LINE> else <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE>if ( ps_dec -> u4_first_slice_in_pic ) <NEW_LINE> { <NEW_LINE><NEW_LINE>prev_slice_err = 1 ; <NEW_LINE>num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; <NEW_LINE> } <NEW_LINE>else <NEW_LINE> { <NEW_LINE><NEW_LINE>prev_slice_err = 2 ; <NEW_LINE>num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) <NEW_LINE> - ps_dec -> u2_total_mbs_coded ; <NEW_LINE> } <NEW_LINE> <END_VULN> ps_cur_poc = & s_tmp_poc ; <NEW_LINE> } <NEW_LINE> }
gray = r * data . red_coefficient + g * data . green_coefficient + <NEW_LINE> <START_VULN> b * data . blue_coefficient - 1 . / 32768 - out_qe ; <NEW_LINE> <END_VULN> if ( gray <= 0 ) <NEW_LINE> gray = 0 ; <NEW_LINE> else
mode_t curumsk = umask ( 022 ) ; <NEW_LINE> umask ( curumsk ) ; <NEW_LINE> <START_VULN> if ( fchmod ( fileno ( fp ) , 0666 - curumsk ) < 0 ) { <NEW_LINE> <END_VULN> err_status = "create_chmod" ; <NEW_LINE> return - 1 ; <NEW_LINE> }
* ( -- dp ) = * ( -- sp ) ; <NEW_LINE> * ( -- dp ) = * ( -- sp ) ; <NEW_LINE> * ( -- dp ) = * ( -- sp ) ; <NEW_LINE> <START_VULN> * ( -- dp ) = hi_filler ; <NEW_LINE> <END_VULN> * ( -- dp ) = lo_filler ; <NEW_LINE> } <NEW_LINE> row_info -> channels = 4 ;
<START_VULN> void reset ( C p = NULL ) { <NEW_LINE> <END_VULN> if ( obj_ != p ) { <NEW_LINE> FreeProc free_proc ; <NEW_LINE> free_proc ( obj_ ) ;
{ <NEW_LINE> stream_t * ps_stream = ( stream_t * ) pv_ctxt ; <NEW_LINE> <START_VULN> FLUSH_BITS ( ps_stream -> u4_offset , ps_stream -> u4_buf , ps_stream -> u4_buf_nxt , u4_no_of_bits , ps_stream -> pu4_buf_aligned ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
if ( ! obj || ! child ) { <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ( existing = mprLookupJsonObj ( obj , name ) ) != 0 ) { <NEW_LINE> <END_VULN> existing -> value = child -> value ; <NEW_LINE> existing -> children = child -> children ; <NEW_LINE> existing -> type = child -> type ;
NS_IMETHODIMP <NEW_LINE> nsXPConnect::EvalInSandboxObject ( const nsAString & source , JSContext * cx , <NEW_LINE> nsIXPConnectJSObjectHolder * sandbox , <NEW_LINE> <START_VULN> jsval * rval ) <NEW_LINE> <END_VULN> { <NEW_LINE> #ifdef XPCONNECT_STANDALONE <NEW_LINE> return NS_ERROR_NOT_AVAILABLE ;
com = & enc -> mrk -> parms . com ; <NEW_LINE> com -> len = JAS_CAST ( uint_fast16_t , strlen ( buf ) ) ; <NEW_LINE> com -> regid = JPC_COM_LATIN ; <NEW_LINE> <START_VULN> if ( ! ( com -> data = JAS_CAST ( uchar * , jas_strdup ( buf ) ) ) ) { <NEW_LINE> <END_VULN> abort ( ) ; <NEW_LINE> } <NEW_LINE> if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) {
* rp = table [ * rp ] ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #if defined ( PNG_WRITE_FILLER_SUPPORTED ) || \ <NEW_LINE> defined ( PNG_READ_STRIP_ALPHA_SUPPORTED )
if ( ! hash_arr || zend_hash_num_elements ( hash_arr ) == 0 ) { <NEW_LINE> RETURN_EMPTY_STRING ( ) ; <NEW_LINE> <START_VULN> } <NEW_LINE><NEW_LINE> <END_VULN> result = lookup_loc_range ( loc_range , hash_arr , boolCanonical TSRMLS_CC ) ; <NEW_LINE> if ( result == NULL || result [ 0 ] == '\0' ) { <NEW_LINE> if ( fallback_loc ) {
fReserved = false ; <NEW_LINE> } else { <NEW_LINE> fAllocCount = SkTMax ( count , SkTMax ( kMinHeapAllocCount , reserveCount ) ) ; <NEW_LINE> <START_VULN> fMemArray = sk_malloc_throw ( fAllocCount * sizeof ( T ) ) ; <NEW_LINE> <END_VULN> fOwnMemory = true ; <NEW_LINE> fReserved = reserveCount > 0 ; <NEW_LINE> }
state_ . depth_mask = saved_state_ . depth_mask ; <NEW_LINE> state_ . stencil_mask = saved_state_ . stencil_mask ; <NEW_LINE> } <NEW_LINE> <START_VULN> void DrawingBufferClientRestorePixelPackAlignment ( ) override { <NEW_LINE> <END_VULN> state_ . pack_alignment = saved_state_ . pack_alignment ; <NEW_LINE> } <NEW_LINE> void DrawingBufferClientRestoreTexture2DBinding ( ) override {
fi -> spdist = fp -> regs -> sp - fp -> slots ; <NEW_LINE> fi -> set_argc ( argc , constructing ) ; <NEW_LINE> fi -> spoffset = 2 + fp -> argc ; <NEW_LINE> unsigned callDepth = getCallDepth ( ) ; <NEW_LINE> if ( callDepth >= treeInfo -> maxCallDepth ) <NEW_LINE> treeInfo -> maxCallDepth = callDepth + 1 ; <NEW_LINE> if ( callDepth == 0 ) <NEW_LINE> <START_VULN> fi -> spoffset = 2 + argc - fi -> spdist ; <NEW_LINE> <END_VULN> lir -> insStorei ( INS_CONSTPTR ( fi ) , lirbuf -> rp , callDepth * sizeof ( FrameInfo * ) ) ; <NEW_LINE> atoms = fun -> u . i . script -> atomMap . vector ; <NEW_LINE> return JSRS_CONTINUE ; <NEW_LINE> } <NEW_LINE> JS_REQUIRES_STACK JSRecordingStatus
return png_ptr -> pass ; <NEW_LINE> return 8 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE>#endif <NEW_LINE>#endif <NEW_LINE> <END_VULN>
goto trunc ; <NEW_LINE> if ( length < alen ) <NEW_LINE> goto trunc ; <NEW_LINE> <START_VULN> if ( ! bgp_attr_print ( ndo , atype , p , alen ) ) <NEW_LINE> <END_VULN> goto trunc ; <NEW_LINE> p += alen ; <NEW_LINE> len - = alen ;
static v8::Handle < v8::Value > getObjectParameter ( const v8::Arguments & args , ObjectType objectType ) <NEW_LINE> { <NEW_LINE> if ( args . Length ( ) != 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> WebGLRenderingContext * context = V8WebGLRenderingContext::toNative ( args . Holder ( ) ) ;
uint64 ContentEncoding::EncryptionSize ( ) const { <NEW_LINE> const uint64 aes_size = enc_aes_settings_ . Size ( ) ; <NEW_LINE> <START_VULN> uint64 encryption_size = EbmlElementSize ( kMkvContentEncKeyID , <NEW_LINE>enc_key_id_ , <NEW_LINE>enc_key_id_length_ ) ; <NEW_LINE> <END_VULN> encryption_size += EbmlElementSize ( kMkvContentEncAlgo , enc_algo_ ) ; <NEW_LINE> return encryption_size + aes_size ;
else <NEW_LINE> { <NEW_LINE> <START_VULN> data . red_coefficient = 6968 / 32768 . ; <NEW_LINE>data . green_coefficient = 23434 / 32768 . ; <NEW_LINE>data . blue_coefficient = 2366 / 32768 . ; <NEW_LINE> <END_VULN> } <NEW_LINE> data . gamma = pm -> current_gamma ;
status_t OMXNodeInstance::sendCommand ( <NEW_LINE> OMX_COMMANDTYPE cmd , OMX_S32 param ) { <NEW_LINE> if ( cmd == OMX_CommandStateSet ) { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> mSailed = true ; <NEW_LINE> } <NEW_LINE> const sp < GraphicBufferSource > bufferSource ( getGraphicBufferSource ( ) ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: normalized modified discrete cosine transform <NEW_LINE> power of two length transform only [ 64 <= n ] <NEW_LINE> <START_VULN> last mod: $ Id: mdct . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> Original algorithm adapted long ago from _The use of multirate filter <NEW_LINE> banks for coding of high quality digital audio_ , by T . Sporer , <NEW_LINE> K . Brandenburg and B . Edler , collection of the European Signal <NEW_LINE> Processing Conference ( EUSIPCO ) , Amsterdam , June 1992 , Vol . 1 , pp <NEW_LINE> 211 - 214 <NEW_LINE> The below code implements an algorithm that no longer looks much like
} <NEW_LINE> curNode -> GetLastChild ( getter_AddRefs ( child ) ) ; <NEW_LINE> } <NEW_LINE> res = mHTMLEditor -> RemoveBlockContainer ( curNode ) ; <NEW_LINE> if ( NS_FAILED ( res ) ) return res ; <NEW_LINE> } <NEW_LINE> else if ( useCSS ) { <NEW_LINE> <START_VULN> RelativeChangeIndentationOfElementNode ( curNode , - 1 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( curBlockQuote ) <NEW_LINE> { <NEW_LINE> res = OutdentPartOfBlock ( curBlockQuote , firstBQChild , lastBQChild , <NEW_LINE> curBlockQuoteIsIndentedWithCSS ,
TabContents * GetVisibleTab ( ) const { return preview_ ? preview_ : tab_ ; } <NEW_LINE> <START_VULN> void DetachTab ( TabContents * tab ) ; <NEW_LINE> <END_VULN> virtual void Observe ( int type ,
break ; <NEW_LINE> } <NEW_LINE> default: { <NEW_LINE> <START_VULN> break ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
y = 0 ; <NEW_LINE> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> p = GetVirtualPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <NEW_LINE> <END_VULN> if ( p == ( const PixelPacket * ) NULL ) <NEW_LINE> break ; <NEW_LINE> bit = 0 ;
if ( p -> udptl ) { <NEW_LINE> <START_VULN> if ( udptlportno > 0 ) { <NEW_LINE> <END_VULN> if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_SYMMETRICRTP ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_UDPTL_DESTINATION ) ) { <NEW_LINE> ast_rtp_instance_get_remote_address ( p -> rtp , isa ) ; <NEW_LINE> if ( ! ast_sockaddr_isnull ( isa ) && debug ) {
class AutoCompartment <NEW_LINE> { <NEW_LINE> JSContext * const cx_ ; <NEW_LINE> JSCompartment * const origin_ ; <NEW_LINE> public: <NEW_LINE> inline AutoCompartment ( JSContext * cx , JSObject * target ) ; <NEW_LINE> <START_VULN> inline AutoCompartment ( JSContext * cx , JSCompartment * target ) ; <NEW_LINE> <END_VULN> inline ~ AutoCompartment ( ) ; <NEW_LINE> JSContext * context ( ) const { return cx_ ; } <NEW_LINE> JSCompartment * origin ( ) const { return origin_ ; } <NEW_LINE> private: <NEW_LINE> AutoCompartment ( const AutoCompartment & ) MOZ_DELETE ; <NEW_LINE> AutoCompartment & operator = ( const AutoCompartment & ) MOZ_DELETE ;
nsWeakFrame mFrame ; <NEW_LINE> } ; <NEW_LINE> void <NEW_LINE> nsComboboxControlFrame::GetAvailableDropdownSpace ( nscoord * aAbove , <NEW_LINE> nscoord * aBelow , <NEW_LINE> nsPoint * aTranslation ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
} <NEW_LINE> static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , <NEW_LINE> <START_VULN> int ctr_id , va_list args ) { <NEW_LINE> <END_VULN> vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ; <NEW_LINE> if ( frame != NULL ) {
} <NEW_LINE> mCurrentSampleTime = mStartTime ; <NEW_LINE> Begin ( ) ; <NEW_LINE> } <NEW_LINE> nsSMILAnimationController:: ~ nsSMILAnimationController ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> StopSampling ( GetRefreshDriverForDoc ( mDocument ) ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( mAnimationElementTable . Count ( ) == 0 , <NEW_LINE> "Animation controller shouldn't be tracking any animation" <NEW_LINE> " elements when it dies" ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsSMILAnimationController::Pause ( PRUint32 aType ) <NEW_LINE> { <NEW_LINE> nsSMILTimeContainer::Pause ( aType ) ;
<START_VULN> Copyright ( c ) 2010 - 2014 , The Linux Foundation . All rights reserved . <NEW_LINE> <END_VULN> Redistribution and use in source and binary forms , with or without <NEW_LINE> modification , are permitted provided that the following conditions are
} <NEW_LINE> } else { <NEW_LINE> if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ; <NEW_LINE> <START_VULN> state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ; <NEW_LINE> <END_VULN> state -> object_nl_len = len ; <NEW_LINE> } <NEW_LINE> return Qnil ;
mCurrentNode -> mURI -> GetSpec ( spec ) ; <NEW_LINE> LOG ( ( "ProcessNextURI [ % s ] \n" , spec . get ( ) ) ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> rv = mCurrentNode -> OpenChannel ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> while ( NS_FAILED ( rv ) ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsPrefetchService::NotifyLoadRequested ( nsPrefetchNode * node ) <NEW_LINE> { <NEW_LINE> nsCOMPtr < nsIObserverService > observerService =
void prependToViews ( ArrayBufferViewObject * viewsHead ) ; <NEW_LINE> <START_VULN> void neuter ( JSContext * cx ) ; <NEW_LINE> <END_VULN> static void trace ( JSTracer * trc , JSObject * obj ) ; <NEW_LINE> } ;
INC_STATS ( "DOM . WebGLRenderingContext . getParameter ( ) " ) ; <NEW_LINE> if ( args . Length ( ) != 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> WebGLRenderingContext * context = V8WebGLRenderingContext::toNative ( args . Holder ( ) ) ;
{ <NEW_LINE> bool alreadyDirty = preferredLogicalWidthsDirty ( ) ; <NEW_LINE> m_bitfields . setPreferredLogicalWidthsDirty ( shouldBeDirty ) ; <NEW_LINE> <START_VULN> if ( shouldBeDirty && ! alreadyDirty && markParents == MarkContainingBlockChain && ( isText ( ) || ! style ( ) -> isPositioned ( ) ) ) <NEW_LINE> <END_VULN> invalidateContainerPreferredLogicalWidths ( ) ; <NEW_LINE> }
if ( nsLayoutAtoms::tableRowFrame == aHighestType ) return rv ; <NEW_LINE> if ( aPseudoFrames . mRowGroup . mFrame ) { <NEW_LINE> <START_VULN> rv = ProcessPseudoFrame ( aPresContext , aPseudoFrames . mRowGroup , aHighestFrame ) ; <NEW_LINE> <END_VULN> if ( nsLayoutAtoms::tableRowGroupFrame == aHighestType ) return rv ; <NEW_LINE> } <NEW_LINE> if ( aPseudoFrames . mColGroup . mFrame ) {
} <NEW_LINE> } <NEW_LINE> if ( ctxt -> instate == XML_PARSER_EOF ) <NEW_LINE> <START_VULN> return ; <NEW_LINE> <END_VULN> SKIP_BLANKS ; <NEW_LINE> if ( RAW != ' > ' ) { <NEW_LINE> xmlFatalErrMsgStr ( ctxt , XML_ERR_ENTITY_NOT_FINISHED ,
PassRefPtrWillBeRawPtr < File > DOMFileSystemSync::createFile ( const FileEntrySync * fileEntry , ExceptionState & exceptionState ) <NEW_LINE> { <NEW_LINE> KURL fileSystemURL = createFileSystemURL ( fileEntry ) ; <NEW_LINE> <START_VULN> RefPtrWillBeRawPtr < CreateFileHelper::CreateFileResult > result ( CreateFileHelper::CreateFileResult::create ( ) ) ; <NEW_LINE> <END_VULN> fileSystem ( ) -> createSnapshotFileAndReadMetadata ( fileSystemURL , CreateFileHelper::create ( result , fileEntry -> name ( ) , fileSystemURL , type ( ) ) ) ; <NEW_LINE> if ( result -> m_failed ) { <NEW_LINE> exceptionState . throwDOMException ( result -> m_code , "Could not create '" + fileEntry -> name ( ) + "' . " ) ;
#ifndef ChooserOnlyTemporalInputTypeView_h <NEW_LINE> #define ChooserOnlyTemporalInputTypeView_h <NEW_LINE> <START_VULN> #include "core / html / forms / BaseClickableWithKeyInputType . h" <NEW_LINE> <END_VULN> #include "core / html / forms / BaseTemporalInputType . h" <NEW_LINE> #include "core / html / forms / DateTimeChooser . h" <NEW_LINE> #include "core / html / forms / DateTimeChooserClient . h" <NEW_LINE> #include "platform / heap / Handle . h" <NEW_LINE> namespace blink {
return args . Holder ( ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> v8::Local < v8::Value > arg = args [ 0 ] ; <NEW_LINE> if ( ! arg -> IsObject ( ) )
oggpack_write ( opb , ci -> mode_param [ i ] -> transformtype , 16 ) ; <NEW_LINE> oggpack_write ( opb , ci -> mode_param [ i ] -> mapping , 8 ) ; <NEW_LINE> } <NEW_LINE> oggpack_write ( opb , 1 , 1 ) ; <NEW_LINE> return ( 0 ) ; <NEW_LINE> err_out: <NEW_LINE> return ( - 1 ) ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> int vorbis_commentheader_out ( vorbis_comment * vc , <NEW_LINE> ogg_packet * op ) { <NEW_LINE> oggpack_buffer opb ; <NEW_LINE> oggpack_writeinit ( & opb ) ; <NEW_LINE> if ( _vorbis_pack_comment ( & opb , vc ) ) return OV_EIMPL ;
nsIScriptSecurityManager * secMan = nsContentUtils::GetSecurityManager ( ) ; <NEW_LINE> rv = secMan -> <NEW_LINE> CheckLoadURIWithPrincipal ( mDocument -> NodePrincipal ( ) , url , <NEW_LINE> nsIScriptSecurityManager::ALLOW_CHROME ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , NS_OK ) ; <NEW_LINE> int16_t decision = nsIContentPolicy::ACCEPT ; <NEW_LINE> <START_VULN> rv = NS_CheckContentLoadPolicy ( nsIContentPolicy::TYPE_STYLESHEET , <NEW_LINE> <END_VULN> url , <NEW_LINE> mDocument -> NodePrincipal ( ) , <NEW_LINE> aElement , <NEW_LINE> type , <NEW_LINE> nullptr , <NEW_LINE> & decision , <NEW_LINE> nsContentUtils::GetContentPolicy ( ) , <NEW_LINE> nsContentUtils::GetSecurityManager ( ) ) ;
NS_ASSERTION ( processor . mFontgrp , "font group is null" ) ; <NEW_LINE> nscoord totalWidthCoord ; <NEW_LINE> nsBidi bidiEngine ; <NEW_LINE> rv = nsBidiPresUtils::ProcessText ( textToDraw . get ( ) , <NEW_LINE> <START_VULN> textToDraw . Length ( ) , <NEW_LINE>isRTL ? NSBIDI_RTL : NSBIDI_LTR , <NEW_LINE>presShell -> GetPresContext ( ) , <NEW_LINE>processor , <NEW_LINE>nsBidiPresUtils::MODE_MEASURE , <NEW_LINE>nsnull , <NEW_LINE>0 , <NEW_LINE> & totalWidthCoord , <NEW_LINE> & bidiEngine ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) { <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> float totalWidth = float ( totalWidthCoord ) / processor . mAppUnitsPerDevPixel ; <NEW_LINE> if ( aWidth ) { <NEW_LINE> * aWidth = totalWidth ; <NEW_LINE> }
void RenderBlock::styleWillChange ( StyleDifference diff , const RenderStyle * newStyle ) <NEW_LINE> { <NEW_LINE> RenderStyle * oldStyle = style ( ) ; <NEW_LINE> <START_VULN> s_canPropagateFloatIntoSibling = oldStyle ? ! isFloatingOrPositioned ( ) && ! avoidsFloats ( ) : false ; <NEW_LINE> <END_VULN> setReplaced ( newStyle -> isDisplayInlineType ( ) ) ;
<START_VULN> #define UNP_RECIPROCAL ( alpha ) ( ( ( ( 0xffff * 0xff ) << 7 ) + ( alpha >> 1 ) ) / alpha ) <NEW_LINE> <END_VULN> static png_byte <NEW_LINE> png_unpremultiply ( png_uint_32 component , png_uint_32 alpha ,
return NS_OK ; <NEW_LINE> } <NEW_LINE> static nsresult <NEW_LINE> txFnEndTopVariable ( txStylesheetCompilerState & aState ) <NEW_LINE> { <NEW_LINE> txHandlerTable * prev = aState . mHandlerTable ; <NEW_LINE> aState . popHandlerTable ( ) ; <NEW_LINE> <START_VULN> txVariableItem * var = static_cast < txVariableItem * > ( aState . popPtr ( ) ) ; <NEW_LINE> <END_VULN> if ( prev == gTxTopVariableHandler ) { <NEW_LINE> NS_ASSERTION ( ! var -> mValue , <NEW_LINE> "There shouldn't be a select - expression here" ) ; <NEW_LINE> var -> mValue = new txLiteralExpr ( EmptyString ( ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( var -> mValue , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> }
if ( posts == 0 ) { <NEW_LINE> nonzero += accumulate_fit ( logmask , logmdct , 0 , n , fits , n , info ) ; <NEW_LINE> } else { <NEW_LINE> for ( i = 0 ; i < posts - 1 ; i ++ ) <NEW_LINE> nonzero += accumulate_fit ( logmask , logmdct , look -> sorted_index [ i ] , <NEW_LINE> look -> sorted_index [ i + 1 ] , fits + i , <NEW_LINE> n , info ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( nonzero ) { <NEW_LINE> int y0 = - 200 ; <NEW_LINE> int y1 = - 200 ; <NEW_LINE> fit_line ( fits , posts - 1 , & y0 , & y1 ) ; <NEW_LINE> fit_valueA [ 0 ] = y0 ; <NEW_LINE> fit_valueB [ 0 ] = y0 ;
Find pathnames matching a pattern * / <NEW_LINE> PHP_FUNCTION ( glob ) <NEW_LINE> { <NEW_LINE> <START_VULN> int cwd_skip = 0 ; <NEW_LINE> <END_VULN> #ifdef ZTS <NEW_LINE> char cwd [ MAXPATHLEN ] ; <NEW_LINE> char work_pattern [ MAXPATHLEN ] ;
if ( mCubebStream ) { <NEW_LINE> mCubebStream . reset ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> int64_t <NEW_LINE> AudioStream::GetPosition ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> return mAudioClock . GetPosition ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef _MSC_VER <NEW_LINE> #pragma optimize ( "" , off ) <NEW_LINE> #endif <NEW_LINE> int64_t <NEW_LINE> AudioStream::GetPositionInFrames ( )
nsCOMPtr < nsIURI > uri ; <NEW_LINE> nsresult rv = webNav -> GetCurrentURI ( getter_AddRefs ( uri ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsCOMPtr < nsIDocument > doc = do_QueryInterface ( mDocument ) ; <NEW_LINE> nsCOMPtr < nsIURI > manifestURI ; <NEW_LINE> nsContentUtils::GetOfflineAppManifest ( doc , getter_AddRefs ( manifestURI ) ) ; <NEW_LINE> <START_VULN> nsDOMOfflineResourceList * applicationCache = <NEW_LINE>new nsDOMOfflineResourceList ( manifestURI , uri , this ) ; <NEW_LINE><NEW_LINE>if ( ! applicationCache ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> <END_VULN> mApplicationCache = applicationCache ; <NEW_LINE> } <NEW_LINE> NS_IF_ADDREF ( * aApplicationCache = mApplicationCache ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
virtual ~ nsXBLProtoImplProperty ( ) ; <NEW_LINE> void AppendGetterText ( const nsAString & aGetter ) ; <NEW_LINE> void AppendSetterText ( const nsAString & aSetter ) ; <NEW_LINE> void SetGetterLineNumber ( uint32_t aLineNumber ) ; <NEW_LINE> void SetSetterLineNumber ( uint32_t aLineNumber ) ; <NEW_LINE> <START_VULN> virtual nsresult InstallMember ( nsIScriptContext * aContext , <NEW_LINE>nsIContent * aBoundElement , <NEW_LINE>JSObject * aScriptObject , <NEW_LINE>JSObject * aTargetClassObject , <NEW_LINE>const nsCString & aClassStr ) ; <NEW_LINE> <END_VULN> virtual nsresult CompileMember ( nsIScriptContext * aContext , <NEW_LINE> const nsCString & aClassStr , <NEW_LINE> JSObject * aClassObject ) ; <NEW_LINE> virtual void Trace ( TraceCallback aCallback , void * aClosure ) const ; <NEW_LINE> nsresult Read ( nsIScriptContext * aContext , <NEW_LINE> nsIObjectInputStream * aStream ,
json_tokener_error_parse_object_key_sep , <NEW_LINE> json_tokener_error_parse_object_value_sep , <NEW_LINE> json_tokener_error_parse_string , <NEW_LINE> <START_VULN> json_tokener_error_parse_comment <NEW_LINE> <END_VULN> } ; <NEW_LINE> enum json_tokener_state {
if ( mObjectFrame && mPluginWindow && <NEW_LINE> mPluginWindow -> type == NPWindowTypeDrawable ) { <NEW_LINE> nsIFocusManager * fm = nsFocusManager::GetFocusManager ( ) ; <NEW_LINE> if ( fm ) { <NEW_LINE> <START_VULN> nsCOMPtr < nsIDOMElement > elem = do_QueryInterface ( mContent ) ; <NEW_LINE> <END_VULN> fm -> SetFocus ( elem , 0 ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> WidgetMouseEvent * mouseEvent = <NEW_LINE> aMouseEvent -> GetInternalNSEvent ( ) -> AsMouseEvent ( ) ; <NEW_LINE> if ( mouseEvent && mouseEvent -> eventStructType == NS_MOUSE_EVENT ) { <NEW_LINE> mLastMouseDownButtonType = mouseEvent -> button ;
Enable use of SSL if we are using any ssl option <NEW_LINE> One can disable SSL later by using -- skip - ssl or -- ssl = 0 <NEW_LINE> <START_VULN> opt_use_ssl = 1 ; <NEW_LINE> <END_VULN> #ifdef HAVE_YASSL <NEW_LINE> opt_ssl_crl = NULL ;
JSAMPROW pixrow ; <NEW_LINE> size_t buffer_width ; <NEW_LINE> JSAMPLE * rescale ; <NEW_LINE> <START_VULN> int maxval ; <NEW_LINE> <END_VULN> } ppm_source_struct ; <NEW_LINE> typedef ppm_source_struct * ppm_source_ptr ;
e = gf_dm_sess_process ( sess ) ; <NEW_LINE> if ( ! e ) { <NEW_LINE> strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; <NEW_LINE> <START_VULN> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <NEW_LINE> <END_VULN> } <NEW_LINE> gf_dm_sess_del ( sess ) ; <NEW_LINE> }
} <NEW_LINE> line = temp ; <NEW_LINE> } <NEW_LINE> <START_VULN> while ( c != '\n' && JS_ISSPACE ( c ) ) <NEW_LINE> <END_VULN> c = GetChar ( ts ) ; <NEW_LINE> i = 0 ; <NEW_LINE> if ( c == '"' ) {
default: <NEW_LINE> err = 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( err ) <NEW_LINE> <END_VULN> png_error ( png_ptr , "Bad I / O state or buffer size" ) ; <NEW_LINE> } <NEW_LINE> #endif
__u8 conf_req [ 64 ] ; <NEW_LINE> __u8 conf_len ; <NEW_LINE> __u8 conf_state ; <NEW_LINE> <START_VULN> __u8 conf_retry ; <NEW_LINE> <END_VULN> __u8 ident ; <NEW_LINE> __le16 sport ; <NEW_LINE> struct l2cap_conn * conn ;
idx = ( ( r -> CRm & 3 ) << 3 ) | ( r -> Op2 & 7 ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> BUG ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! pmu_counter_idx_valid ( vcpu , idx ) )
public RenderFrameObserverTracker < PepperMediaDeviceManager > , <NEW_LINE> public base::SupportsWeakPtr < PepperMediaDeviceManager > { <NEW_LINE> public: <NEW_LINE> <START_VULN> static PepperMediaDeviceManager * GetForRenderFrame ( RenderFrame * render_frame ) ; <NEW_LINE> <END_VULN> virtual ~ PepperMediaDeviceManager ( ) ;
using HTMLElement::GetExecutionContext ; <NEW_LINE> bool HasSingleSecurityOrigin ( ) const { <NEW_LINE> <START_VULN> return GetWebMediaPlayer ( ) && <NEW_LINE>GetWebMediaPlayer ( ) -> HasSingleSecurityOrigin ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool IsFullscreen ( ) const ;
DEBUG ( "A2DP COMMAND % s" , dump_a2dp_ctrl_event ( cmd ) ) ; <NEW_LINE> <START_VULN> if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 ) <NEW_LINE> <END_VULN> { <NEW_LINE> ERROR ( "cmd failed ( % s ) " , strerror ( errno ) ) ; <NEW_LINE> skt_disconnect ( common -> ctrl_fd ) ;
{ <NEW_LINE> JSTestObjConstructor * castedThis = jsCast < JSTestObjConstructor * > ( exec -> callee ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> if ( exec -> argumentCount ( ) <= 0 || ! exec -> argument ( 0 ) . isFunction ( ) ) { <NEW_LINE> setDOMException ( exec , TYPE_MISMATCH_ERR ) ; <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
if ( parts . mVScrollbar == aScrollbar ) { <NEW_LINE> nscoord rh = nsPresContext::AppUnitsToIntCSSPixels ( mRowHeight ) ; <NEW_LINE> nscoord newrow = aNewIndex / rh ; <NEW_LINE> ScrollInternal ( parts , newrow ) ; <NEW_LINE> } else if ( parts . mHScrollbar == aScrollbar ) { <NEW_LINE> <START_VULN> ScrollHorzInternal ( parts , aNewIndex ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> UpdateScrollbars ( parts ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsStyleContext *
void vpx_img_free ( vpx_image_t * img ) { <NEW_LINE> if ( img ) { <NEW_LINE> if ( img -> img_data && img -> img_data_owner ) <NEW_LINE> <START_VULN> img_buf_free ( img -> img_data ) ; <NEW_LINE> <END_VULN> if ( img -> self_allocd ) <NEW_LINE> free ( img ) ;
break ; <NEW_LINE> case EFFECT_CMD_DISABLE: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> ALOGV ( "PreProcessingFx_Command cmdCode Case: EFFECT_CMD_DISABLE: ERROR" ) ; <NEW_LINE> return - EINVAL ; <NEW_LINE> }
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . convert2" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( b * , , V8b::HasInstance ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ? V8b::toNative ( v8::Handle < v8::Object > ::Cast ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) : 0 ) ; <NEW_LINE> imp -> convert2 ( ) ;
if ( NS_FAILED ( rv ) ) <NEW_LINE> widget -> ResetInputState ( ) ; <NEW_LINE> IMEState newState = GetNewIMEState ( sPresContext , nsnull ) ; <NEW_LINE> InputContextAction action ( InputContextAction::CAUSE_UNKNOWN , <NEW_LINE> InputContextAction::LOST_FOCUS ) ; <NEW_LINE> SetIMEState ( newState , nsnull , widget , action ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> sContent = nsnull ; <NEW_LINE> <END_VULN> sPresContext = nsnull ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsIMEStateManager::OnChangeFocus ( nsPresContext * aPresContext , <NEW_LINE> nsIContent * aContent ,
static void set_roi_map ( const vpx_codec_enc_cfg_t * cfg , <NEW_LINE> vpx_codec_ctx_t * codec ) { <NEW_LINE> unsigned int i ; <NEW_LINE> <START_VULN> vpx_roi_map_t roi = { 0 } ; <NEW_LINE> <END_VULN> roi . rows = ( cfg -> g_h + 15 ) / 16 ; <NEW_LINE> roi . cols = ( cfg -> g_w + 15 ) / 16 ;
struct OldObjectRepresentationHack { <NEW_LINE> <START_VULN> uint32_t capacity ; <NEW_LINE> <END_VULN> uint32_t initializedLength ; <NEW_LINE> JSObject * views ; <NEW_LINE> } ;
ast_atomic_fetchadd_int ( & session_count , - 1 ) ; <NEW_LINE> <START_VULN> if ( headers ) { <NEW_LINE>ast_variables_destroy ( headers ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> if ( ser -> f ) { <NEW_LINE> fclose ( ser -> f ) ;
return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ends_with ( filename , " . pbl" ) ) { <NEW_LINE> <END_VULN> ERR_FS << "Illegal path '" << filename << "' ( . pbl files are not allowed ) . " << std::endl ; <NEW_LINE> return false ; <NEW_LINE> }
for ( size_t i = 0 ; i < test_suite_size ; ++ i ) { <NEW_LINE> if ( ! test_name || ! strcmp ( test_name , test_suite [ i ] . function_name ) ) { <NEW_LINE> callbacks_init ( ) ; <NEW_LINE> <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <NEW_LINE> <END_VULN> if ( test_suite [ i ] . function ( ) ) { <NEW_LINE> printf ( " [ % 4d ] % - 64s [ % sPASS % s ] \n" , ++ case_num , test_suite [ i ] . function_name , GREEN , DEFAULT ) ; <NEW_LINE> ++ pass ;
<START_VULN> #ifndef BASE_SAFE_CONVERSIONS_H_ <NEW_LINE>#define BASE_SAFE_CONVERSIONS_H_ <NEW_LINE> <END_VULN> #include < limits >
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> if ( name == nsGkAtoms::base ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> if ( ! sAllowedTags || ! sAllowedTags -> GetEntry ( name ) ) { <NEW_LINE> <START_VULN> return NS_OK ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> return nsHTMLFragmentContentSink::AddLeaf ( aNode ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsHTMLParanoidFragmentSink::AddComment ( const nsIParserNode & aNode )
} <NEW_LINE> else { <NEW_LINE> char * newBuf ; <NEW_LINE> int bufferSize = ( int ) ( bufferLim - bufferPtr ) ; <NEW_LINE> if ( bufferSize == 0 ) <NEW_LINE> bufferSize = INIT_BUFFER_SIZE ; <NEW_LINE> do { <NEW_LINE> bufferSize *= 2 ; <NEW_LINE> <START_VULN> } while ( bufferSize < neededSize ) ; <NEW_LINE> <END_VULN> newBuf = ( char * ) MALLOC ( bufferSize ) ; <NEW_LINE> if ( newBuf == 0 ) { <NEW_LINE> errorCode = XML_ERROR_NO_MEMORY ; <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> bufferLim = newBuf + bufferSize ; <NEW_LINE> #ifdef XML_CONTEXT_BYTES <NEW_LINE> if ( bufferPtr ) {
<START_VULN> <NEW_LINE> <END_VULN> #include "vpx_scale / vpx_scale . h" <NEW_LINE> #include "vpx_mem / vpx_mem . h"
ReadyState GetReadyState ( ) const override { return kReadyStateHaveNothing ; } <NEW_LINE> WebString GetErrorMessage ( ) const override ; <NEW_LINE> bool DidLoadingProgress ( ) override { return false ; } <NEW_LINE> <START_VULN> bool DidGetOpaqueResponseFromServiceWorker ( ) const override { return false ; } <NEW_LINE>bool HasSingleSecurityOrigin ( ) const override { return true ; } <NEW_LINE>bool DidPassCORSAccessCheck ( ) const override { return true ; } <NEW_LINE> <END_VULN> double MediaTimeForTimeValue ( double time_value ) const override { <NEW_LINE> return time_value ; <NEW_LINE> } ;
if ( nhdr . n_type == NT_GNU_BUILD_ID ) { <NEW_LINE> addr += NOTE_ALIGN ( nhdr . n_namesz ) ; <NEW_LINE> <START_VULN> uint8_t build_id_data [ 128 ] ; <NEW_LINE>if ( nhdr . n_namesz > sizeof ( build_id_data ) ) { <NEW_LINE>ALOGE ( "Possible corrupted note , name size value is too large: % u" , <NEW_LINE>nhdr . n_namesz ) ; <NEW_LINE> <END_VULN> return false ; <NEW_LINE> } <NEW_LINE> if ( backtrace -> Read ( addr , build_id_data , nhdr . n_descsz ) != nhdr . n_descsz ) {
tmsize_t wc = cc / bps ; <NEW_LINE> tmsize_t count = cc ; <NEW_LINE> uint8 * cp = ( uint8 * ) cp0 ; <NEW_LINE> <START_VULN> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <NEW_LINE> <END_VULN> if ( cc % ( bps * stride ) != 0 ) <NEW_LINE> {
JSObject ** aRetval ) ; <NEW_LINE> nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <NEW_LINE> <START_VULN> unsigned char * aData , uint32_t aDataLen , <NEW_LINE> <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , <NEW_LINE> int32_t dirtyWidth , int32_t dirtyHeight ) ;
} <NEW_LINE> void TextTrackCue::setEndTime ( double value ) { <NEW_LINE> <START_VULN> <NEW_LINE>if ( end_time_ == value || value < 0 ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> CueWillChange ( ) ;
return false ; <NEW_LINE> if ( ! js_IsCallable ( vp ) ) { <NEW_LINE> vp . setObject ( * obj ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> return Invoke ( cx , ObjectValue ( * obj ) , vp , 0 , NULL , vp . address ( ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSBool <NEW_LINE>DefaultValue ( JSContext * cx , HandleObject obj , JSType hint , MutableHandleValue vp ) <NEW_LINE> <END_VULN> { <NEW_LINE> JS_ASSERT ( hint == JSTYPE_NUMBER || hint == JSTYPE_STRING || hint == JSTYPE_VOID ) ; <NEW_LINE> #if JS_HAS_XML_SUPPORT <NEW_LINE> JS_ASSERT ( ! obj -> isXML ( ) ) ; <NEW_LINE> #endif <NEW_LINE> Rooted < jsid > id ( cx ) ;
jsval * rval ) ; <NEW_LINE> JS_REQUIRES_STACK JSRecordingStatus newString ( JSObject * ctor , uint32 argc , jsval * argv , <NEW_LINE> jsval * rval ) ; <NEW_LINE> JS_REQUIRES_STACK JSRecordingStatus interpretedFunctionCall ( jsval & fval , JSFunction * fun , <NEW_LINE> uintN argc , bool constructing ) ; <NEW_LINE> JS_REQUIRES_STACK void propagateFailureToBuiltinStatus ( nanojit::LIns * ok_ins , <NEW_LINE> nanojit::LIns * & status_ins ) ; <NEW_LINE> JS_REQUIRES_STACK JSRecordingStatus emitNativeCall ( JSSpecializedNative * sn , uintN argc , <NEW_LINE> <START_VULN> nanojit::LIns * args [ ] ) ; <NEW_LINE> <END_VULN> JS_REQUIRES_STACK void emitNativePropertyOp ( JSScope * scope , <NEW_LINE> JSScopeProperty * sprop , <NEW_LINE> nanojit::LIns * obj_ins , <NEW_LINE> bool setflag , <NEW_LINE> nanojit::LIns * boxed_ins ) ; <NEW_LINE> JS_REQUIRES_STACK JSRecordingStatus callSpecializedNative ( JSNativeTraceInfo * trcinfo , uintN argc , <NEW_LINE> bool constructing ) ; <NEW_LINE> JS_REQUIRES_STACK JSRecordingStatus callNative ( uintN argc , JSOp mode ) ;
if ( owner ) { <NEW_LINE> <START_VULN> switch ( getFileType ( path ) ) { <NEW_LINE> <END_VULN> case FT_NONEXISTANT: <NEW_LINE> createDirectory ( path ) ; <NEW_LINE> break ;
} <NEW_LINE> DidDoReflow ( true ) ; <NEW_LINE> } <NEW_LINE> batch . EndUpdateViewBatch ( NS_VMREFRESH_NO_SYNC ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( aHeight == NS_UNCONSTRAINEDSIZE ) { <NEW_LINE> <END_VULN> mPresContext -> SetVisibleArea ( <NEW_LINE> nsRect ( 0 , 0 , aWidth , rootFrame -> GetRect ( ) . height ) ) ; <NEW_LINE> } <NEW_LINE> if ( ! mIsDestroying && ! mResizeEvent . IsPending ( ) && <NEW_LINE> ! mAsyncResizeTimerIsActive ) { <NEW_LINE> if ( mInResize ) { <NEW_LINE> if ( ! mAsyncResizeEventTimer ) {
unsigned short bcache = 1 ; <NEW_LINE> <START_VULN> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; <NEW_LINE> <END_VULN> if ( msg -> fp ) <NEW_LINE> return 0 ;
} <NEW_LINE> <START_VULN> static void calc_segtree_probs ( int * segcounts , vp9_prob * segment_tree_probs ) { <NEW_LINE> <END_VULN> const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ; <NEW_LINE> const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ;
const BYTE * palette ; <NEW_LINE> <START_VULN> void ( * decode ) ( NSC_CONTEXT * context ) ; <NEW_LINE>void ( * encode ) ( NSC_CONTEXT * context , const BYTE * BitmapData , <NEW_LINE> <END_VULN> UINT32 rowstride ) ; <NEW_LINE> NSC_CONTEXT_PRIV * priv ;
if ( mbmi -> skip && is_inter_block ( mbmi ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; <NEW_LINE> else <NEW_LINE> max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; <NEW_LINE> <START_VULN> pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets , <NEW_LINE>bytes_per_pixel * sizeof ( * pixels ) ) ; <NEW_LINE> <END_VULN> if ( pixels == ( unsigned char * ) NULL ) <NEW_LINE> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> ( void ) ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ;
MAX_SCREEN_COLORS , NULL , 0 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> else if ( png_get_PLTE ( png_ptr , info_ptr , & palette , & num_palette ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_uint_16p histogram = NULL ;
params , portIndex , false , false , data ) ; <NEW_LINE> } else { <NEW_LINE> buffer_meta = new BufferMeta ( <NEW_LINE> <START_VULN> params , portIndex , false , false , NULL ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> OMX_BUFFERHEADERTYPE * header ;
static Elem <NEW_LINE> TypedObjectMemory ( HandleValue v ) <NEW_LINE> { <NEW_LINE> <START_VULN> return reinterpret_cast < Elem > ( v . toObject ( ) . as < TypedObject > ( ) . typedMem ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> template < typename V >
} <NEW_LINE> } else { <NEW_LINE> for ( RenderBox * box = firstChildBox ( ) ; box ; box = box -> nextSiblingBox ( ) ) { <NEW_LINE> <START_VULN> if ( ! box -> isPositioned ( ) ) <NEW_LINE> <END_VULN> box -> layoutIfNeeded ( ) ; <NEW_LINE> } <NEW_LINE> }
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> Vector < unsigned long > unsignedLongArray ( jsUnsignedLongArrayToVector ( exec , MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
mParsingCompoundProperty ( PR_FALSE ) , <NEW_LINE> mUnresolvablePrefixException ( PR_FALSE ) <NEW_LINE> #ifdef DEBUG <NEW_LINE> , mScannerInited ( PR_FALSE ) <NEW_LINE> #endif <NEW_LINE> { <NEW_LINE> } <NEW_LINE> <START_VULN> NS_IMPL_ISUPPORTS1 ( CSSParserImpl , nsICSSParser ) <NEW_LINE> <END_VULN> CSSParserImpl:: ~ CSSParserImpl ( ) <NEW_LINE> { <NEW_LINE> mData . AssertInitialState ( ) ; <NEW_LINE> mTempData . AssertInitialState ( ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP
modifier *= modifier ; <NEW_LINE> modifier *= 3 ; <NEW_LINE> <START_VULN> modifier += 1 << ( strength - 1 ) ; <NEW_LINE> <END_VULN> modifier >> = strength ; <NEW_LINE> if ( modifier > 16 )
const char * kind ( ) { return "freezeStack" ; } <NEW_LINE> void newType ( JSContext * cx , TypeSet * source , Type type ) <NEW_LINE> { <NEW_LINE> <START_VULN> RootedScript script ( cx , script_ ) ; <NEW_LINE>AddPendingRecompile ( cx , script ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } ; <NEW_LINE> TypeCompartment::TypeCompartment ( )
} <NEW_LINE> long long EBMLHeader::Parse ( IMkvReader * pReader , long long & pos ) { <NEW_LINE> <START_VULN> assert ( pReader ) ; <NEW_LINE> <END_VULN> long long total , available ;
#include < vector > <NEW_LINE> #include "base / callback . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "extensions / renderer / api / display_source / wifi_display / wifi_display_transport_stream_packetizer . h" <NEW_LINE> namespace extensions {
} <NEW_LINE> <START_VULN> PUBLIC ssize slen ( char * s ) <NEW_LINE> <END_VULN> { <NEW_LINE> return s ? strlen ( s ) : 0 ; <NEW_LINE> }
if ( ! m_isExternalScript && ( ! shouldBypassMainWorldContentSecurityPolicy && ! elementDocument -> contentSecurityPolicy ( ) -> allowInlineScript ( elementDocument -> url ( ) , m_startLineNumber ) ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( m_isExternalScript && m_resource && ! m_resource -> mimeTypeAllowedByNosniff ( ) ) { <NEW_LINE>contextDocument -> addConsoleMessage ( SecurityMessageSource , ErrorMessageLevel , "Refused to execute script from '" + m_resource -> url ( ) . elidedString ( ) + "' because its MIME type ( '" + m_resource -> mimeType ( ) + "' ) is not executable , and strict MIME type checking is enabled . " ) ; <NEW_LINE>return ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( frame ) {
return JSVAL_NULL ; <NEW_LINE> } <NEW_LINE> nsIScriptContext * scriptContext = sgo -> GetScriptContext ( ) ; <NEW_LINE> if ( ! scriptContext ) { <NEW_LINE> return JSVAL_NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSContext * cx = scriptContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> if ( ! cx ) { <NEW_LINE> return JSVAL_NULL ; <NEW_LINE> } <NEW_LINE> jsval someJsVal ; <NEW_LINE> nsresult rv = nsContentUtils::WrapNative ( cx , <NEW_LINE> JS_GetGlobalObject ( cx ) , <NEW_LINE> aObject ,
FloatingObjectSetIterator end = floatingObjectSet . end ( ) ; <NEW_LINE> for ( RenderObject * next = nextSibling ( ) ; next ; next = next -> nextSibling ( ) ) { <NEW_LINE> <START_VULN> if ( ! next -> isRenderBlock ( ) || next -> isFloatingOrPositioned ( ) || toRenderBlock ( next ) -> avoidsFloats ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> RenderBlock * nextBlock = toRenderBlock ( next ) ;
count = ( ssize_t ) value ; <NEW_LINE> if ( ( count & 0x01 ) != 0 ) <NEW_LINE> count ++ ; <NEW_LINE> <START_VULN> if ( ( p > ( datum + length - count ) ) || ( count > ( ssize_t ) length ) ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> if ( id != profile_id ) <NEW_LINE> p += count ;
static void copyStereo16 ( <NEW_LINE> short * dst , <NEW_LINE> <START_VULN> const int * const * src , <NEW_LINE> <END_VULN> unsigned nSamples , <NEW_LINE> unsigned ) { <NEW_LINE> for ( unsigned i = 0 ; i < nSamples ; ++ i ) {
zend_throw_exception_ex ( spl_ce_LogicException , 0 TSRMLS_CC , "Can't truncate file % s" , intern -> file_name ) ; <NEW_LINE> RETURN_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> RETURN_BOOL ( 0 == php_stream_truncate_set_size ( intern -> u . file . stream , size ) ) ; <NEW_LINE> }
const base::Value * GetBackupForPref ( const std::string & path ) const ; <NEW_LINE> <START_VULN> <NEW_LINE>void UpdateBackupSignature ( ) ; <NEW_LINE> <END_VULN> bool is_backup_valid ( ) { return is_backup_valid_ ; }
{ Z_PACKET_SERVACK , "serv - ack" } , <NEW_LINE> { Z_PACKET_SERVNAK , "serv - nak" } , <NEW_LINE> { Z_PACKET_CLIENTACK , "client - ack" } , <NEW_LINE> <START_VULN> { Z_PACKET_STAT , "stat" } <NEW_LINE> <END_VULN> } ; <NEW_LINE> static char z_buf [ 256 ] ;
<START_VULN> if ( transforms & PNG_TRANSFORM_STRIP_ALPHA ) <NEW_LINE> <END_VULN> #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED <NEW_LINE> png_set_strip_alpha ( png_ptr ) ; <NEW_LINE> #else
memcpy ( prefix , base , len ) ; <NEW_LINE> prefix [ len ] = 0 ; <NEW_LINE> <START_VULN> snprintf ( pattern , 499 , " . / test / relaxng / % s_ ? . xml" , prefix ) ; <NEW_LINE>pattern [ 499 ] = 0 ; <NEW_LINE> <END_VULN> globbuf . gl_offs = 0 ; <NEW_LINE> glob ( pattern , GLOB_DOOFFS , NULL , & globbuf ) ;
#define CHROME_BROWSER_UI_BLOCKED_CONTENT_POPUP_BLOCKER_H_ <NEW_LINE> #include "base / optional . h" <NEW_LINE> <START_VULN> #include "third_party / blink / public / mojom / window_features / window_features . mojom . h" <NEW_LINE> <END_VULN> #include "ui / base / window_open_disposition . h" <NEW_LINE> #include "url / gurl . h"
JS_ASSERT ( ! f . fp ( ) -> finishedInInterpreter ( ) ) ; <NEW_LINE> UnwindScope ( cx , 0 ) ; <NEW_LINE> <START_VULN> f . regs . sp = f . fp ( ) -> base ( ) ; <NEW_LINE> <END_VULN> if ( cx -> compartment -> debugMode ( ) ) { <NEW_LINE> if ( js::ScriptDebugEpilogue ( cx , f . fp ( ) , false ) ) <NEW_LINE> return cx -> jaegerCompartment ( ) -> forceReturnFromExternC ( ) ; <NEW_LINE> }
break ; <NEW_LINE> case NS_ERROR_DOM_SECURITY_ERR: <NEW_LINE> case NS_ERROR_DOM_SYNTAX_ERR: <NEW_LINE> Throw ( aCx , aLoadResult ) ; <NEW_LINE> break ; <NEW_LINE> default: <NEW_LINE> <START_VULN> JS_ReportError ( aCx , "Failed to load script: % s ( nsresult = 0x % x ) " , <NEW_LINE>url . get ( ) , aLoadResult ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> LoadWorkerScript ( JSContext * aCx ) <NEW_LINE> { <NEW_LINE> WorkerPrivate * worker = GetWorkerPrivateFromContext ( aCx ) ; <NEW_LINE> NS_ASSERTION ( worker , "This should never be null ! " ) ;
# define LLONG long <NEW_LINE> #endif <NEW_LINE> <START_VULN> static void fmtstr ( char ** , char ** , size_t * , size_t * , <NEW_LINE>const char * , int , int , int ) ; <NEW_LINE>static void fmtint ( char ** , char ** , size_t * , size_t * , <NEW_LINE>LLONG , int , int , int , int ) ; <NEW_LINE>static void fmtfp ( char ** , char ** , size_t * , size_t * , <NEW_LINE>LDOUBLE , int , int , int ) ; <NEW_LINE>static void doapr_outch ( char ** , char ** , size_t * , size_t * , int ) ; <NEW_LINE>static void _dopr ( char ** sbuffer , char ** buffer , <NEW_LINE>size_t * maxlen , size_t * retlen , int * truncated , <NEW_LINE>const char * format , va_list args ) ; <NEW_LINE> <END_VULN> #define DP_S_DEFAULT 0
scoped_ptr < FormStructure > upload_form_structure_ ; <NEW_LINE> <START_VULN> scoped_ptr < AutoFillCCInfoBarDelegate > cc_infobar_ ; <NEW_LINE> <END_VULN> friend class TestAutoFillManager ; <NEW_LINE> FRIEND_TEST_ALL_PREFIXES ( AutoFillManagerTest , FillCreditCardForm ) ;
#endif <NEW_LINE> error: <NEW_LINE> JS_ASSERT ( cx -> regs == & regs ) ; <NEW_LINE> #ifdef JS_TRACER <NEW_LINE> if ( regs . fp -> hasImacropc ( ) && cx -> throwing ) { <NEW_LINE> regs . pc = regs . fp -> imacropc ( ) ; <NEW_LINE> regs . fp -> clearImacropc ( ) ; <NEW_LINE> <START_VULN> atoms = script -> atomMap . vector ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif <NEW_LINE> JS_ASSERT ( size_t ( ( regs . fp -> hasImacropc ( ) ? regs . fp -> imacropc ( ) : regs . pc ) - script -> code ) < <NEW_LINE> script -> length ) ; <NEW_LINE> #ifdef JS_TRACER <NEW_LINE> interpReturnOK = JS_FALSE ; <NEW_LINE> } else { <NEW_LINE> JSThrowHook handler ; <NEW_LINE> JSTryNote * tn , * tnlimit ; <NEW_LINE> uint32 offset ; <NEW_LINE> handler = cx -> debugHooks -> throwHook ; <NEW_LINE> if ( handler ) { <NEW_LINE> Value rval ; <NEW_LINE> switch ( handler ( cx , script , regs . pc , Jsvalify ( & rval ) , <NEW_LINE> cx -> debugHooks -> throwHookData ) ) { <NEW_LINE> case JSTRAP_ERROR: <NEW_LINE> cx -> throwing = JS_FALSE ; <NEW_LINE> goto error ;
static const PRUint8 * <NEW_LINE> SanitizeOpenTypeData ( const PRUint8 * aData , PRUint32 aLength , <NEW_LINE> PRUint32 & aSaneLength ) <NEW_LINE> { <NEW_LINE> ots::ExpandingMemoryStream output ( aLength , 1024 * 1024 * 256 ) ; <NEW_LINE> <START_VULN> if ( ots::Process ( & output , aData , aLength ) ) { <NEW_LINE> <END_VULN> aSaneLength = output . Tell ( ) ; <NEW_LINE> PRUint8 * result = static_cast < PRUint8 * > ( NS_Alloc ( aSaneLength ) ) ; <NEW_LINE> ::memcpy ( result , output . get ( ) , aSaneLength ) ; <NEW_LINE> return result ; <NEW_LINE> } else { <NEW_LINE> aSaneLength = 0 ; <NEW_LINE> return nsnull ; <NEW_LINE> }
mozilla::MallocSizeOf aMallocSizeOf , void * arg ) ; <NEW_LINE> static PLDHashOperator ClearModules ( const nsACString & key , ModuleEntry * & entry , void * cx ) ; <NEW_LINE> nsDataHashtable < nsCStringHashKey , ModuleEntry * > mModules ; <NEW_LINE> nsClassHashtable < nsCStringHashKey , ModuleEntry > mImports ; <NEW_LINE> nsDataHashtable < nsCStringHashKey , ModuleEntry * > mInProgressImports ; <NEW_LINE> <START_VULN> nsDataHashtable < nsPtrHashKey < JSScript > , JSObject * > mThisObjects ; <NEW_LINE> <END_VULN> bool mInitialized ; <NEW_LINE> bool mReuseLoaderGlobal ; <NEW_LINE> } ; <NEW_LINE> #endif
int64_t pre_store_ [ 8 ] ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> #define REGISTER_STATE_CHECK ( statement ) do { \ <NEW_LINE>libvpx_test::RegisterStateCheck reg_check ; \ <NEW_LINE>statement ; \ <NEW_LINE> <END_VULN> } while ( false ) <NEW_LINE> }
{ <NEW_LINE> png_byte sTER [ 5 ] = { 115 , 84 , 69 , 82 , '\0' } ; <NEW_LINE> <START_VULN> if ( verbose ) <NEW_LINE> <END_VULN> fprintf ( STDERR , "\n stereo mode = % d\n" , user_chunk_data . sTER_mode ) ; <NEW_LINE> png_write_chunk ( write_ptr , sTER , & user_chunk_data . sTER_mode , 1 ) ;
nsIAtom * aAttribute , <NEW_LINE> PRInt32 aModType ) ; <NEW_LINE> nsresult GetText ( nsString & aText ) ; <NEW_LINE> NS_DECL_QUERYFRAME <NEW_LINE> public: <NEW_LINE> <START_VULN> void FireOnInput ( ) ; <NEW_LINE> <END_VULN> void SetValueChanged ( PRBool aValueChanged ) ; <NEW_LINE> nsresult InitFocusedValue ( ) ; <NEW_LINE> void SetFireChangeEventState ( PRBool aNewState ) <NEW_LINE> { <NEW_LINE> mFireChangeEventState = aNewState ; <NEW_LINE> }
if ( * s2 == '\0' ) <NEW_LINE> return s1 ; <NEW_LINE> <START_VULN> for ( p = s1 ; ( p = strchr ( p , * s2 ) ) != NULL ; p = strchr ( p + 1 , * s2 ) ) { <NEW_LINE> <END_VULN> if ( strncmp ( p , s2 , len ) == 0 ) <NEW_LINE> return ( p ) ; <NEW_LINE> }
<START_VULN> bool checkHeader ( ) const ; <NEW_LINE> <END_VULN> #if DCHECK_IS_ON ( ) && CPU ( 64BIT )
CHECK_TYPE0 ( XPATH_LOCATIONSET ) ; <NEW_LINE> obj = valuePop ( ctxt ) ; <NEW_LINE> oldlocset = obj -> user ; <NEW_LINE> <START_VULN> if ( ( oldlocset == NULL ) || ( oldlocset -> locNr == 0 ) ) { <NEW_LINE>ctxt -> context -> node = NULL ; <NEW_LINE>ctxt -> context -> contextSize = 0 ; <NEW_LINE>ctxt -> context -> proximityPosition = 0 ; <NEW_LINE>total += xmlXPathCompOpEval ( ctxt , & comp -> steps [ op -> ch2 ] ) ; <NEW_LINE>res = valuePop ( ctxt ) ; <NEW_LINE>if ( res != NULL ) { <NEW_LINE>xmlXPathReleaseObject ( ctxt -> context , res ) ; <NEW_LINE> } <NEW_LINE>valuePush ( ctxt , obj ) ; <NEW_LINE>CHECK_ERROR0 ; <NEW_LINE>return ( total ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> newlocset = xmlXPtrLocationSetCreate ( NULL ) ; <NEW_LINE> for ( i = 0 ; i < oldlocset -> locNr ; i ++ ) {
BCC ( smb_buffer_response ) ) { <NEW_LINE> kfree ( tcon -> nativeFileSystem ) ; <NEW_LINE> tcon -> nativeFileSystem = <NEW_LINE> <START_VULN> kzalloc ( length + 2 , GFP_KERNEL ) ; <NEW_LINE> <END_VULN> if ( tcon -> nativeFileSystem ) <NEW_LINE> cifs_strfromUCS_le ( <NEW_LINE> tcon -> nativeFileSystem ,
} <NEW_LINE> jschar * <NEW_LINE> <START_VULN> js_InflateString ( JSContext * cx , const char * bytes , size_t * lengthp , bool useCESU8 ) <NEW_LINE> <END_VULN> { <NEW_LINE> size_t nbytes , nchars , i ; <NEW_LINE> jschar * chars ;
ND_PRINT ( ( ndo , " ( length bogus , should be = 4 ) " ) ) ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , ": % u" , EXTRACT_16BITS ( p + 2 ) ) ) ; <NEW_LINE> break ; <NEW_LINE> case LCPOPT_MLED:
RGBA , <NEW_LINE> COLORMODE_COLOR , <NEW_LINE> COLORMODE_MONOCHROME , <NEW_LINE> <START_VULN> HP_COLOR_COLOR , <NEW_LINE>HP_COLOR_BLACK , <NEW_LINE> <END_VULN> PRINTOUTMODE_NORMAL , <NEW_LINE> PRINTOUTMODE_NORMAL_GRAY , <NEW_LINE> PROCESSCOLORMODEL_CMYK ,
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #ifndef __nss_h_ <NEW_LINE> #define __nss_h_ <NEW_LINE> #ifdef NSS_ENABLE_ECC <NEW_LINE> #ifdef NSS_ECC_MORE_THAN_SUITE_B <NEW_LINE> #define _NSS_ECC_STRING " Extended ECC"
nsCOMPtr < nsPIDOMWindow > window = GetWindow ( ) ; <NEW_LINE> if ( window ) { <NEW_LINE> nsCOMPtr < nsPIDOMWindow > focusedWindow ; <NEW_LINE> nsIContent * focusedContent = <NEW_LINE> nsFocusManager::GetFocusedDescendant ( window , false , <NEW_LINE> getter_AddRefs ( focusedWindow ) ) ; <NEW_LINE> if ( focusedContent && focusedContent -> OwnerDoc ( ) == this ) { <NEW_LINE> <START_VULN> if ( focusedContent -> IsInNativeAnonymousSubtree ( ) ) { <NEW_LINE>focusedContent = focusedContent -> FindFirstNonNativeAnonymous ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( focusedContent ) { <NEW_LINE> CallQueryInterface ( focusedContent , aElement ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x18:
if ( ( ctxt == NULL ) || ( ctxt -> context == NULL ) ) return ( NULL ) ; <NEW_LINE> if ( cur == NULL ) { <NEW_LINE> cur = ctxt -> context -> node ; <NEW_LINE> <START_VULN> if ( cur -> type == XML_NAMESPACE_DECL ) <NEW_LINE>return ( NULL ) ; <NEW_LINE>if ( cur -> type == XML_ATTRIBUTE_NODE ) <NEW_LINE>return ( cur -> parent ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ( cur == NULL ) || ( cur -> type == XML_NAMESPACE_DECL ) ) <NEW_LINE> return ( NULL ) ;
int ip6_find_1stfragopt ( struct sk_buff * skb , u8 ** nexthdr ) <NEW_LINE> { <NEW_LINE> <START_VULN> u16 offset = sizeof ( struct ipv6hdr ) ; <NEW_LINE> <END_VULN> unsigned int packet_len = skb_tail_pointer ( skb ) - <NEW_LINE> skb_network_header ( skb ) ; <NEW_LINE> int found_rhdr = 0 ;
ReportPendingException ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( ok ) { <NEW_LINE> <START_VULN> JSAutoRequest ar ( mContext ) ; <NEW_LINE> <END_VULN> JSAutoEnterCompartment ac ; <NEW_LINE> if ( ! ac . enter ( mContext , aScopeObject ) ) { <NEW_LINE> stack -> Pop ( nsnull ) ; <NEW_LINE> } <NEW_LINE> rv = JSValueToAString ( mContext , val , aRetValue , aIsUndefined ) ; <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> if ( aIsUndefined ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: maintain the info structure , info < -> header packets <NEW_LINE> <START_VULN> last mod: $ Id: info . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h >
if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_CSV ) <NEW_LINE> && zend_hash_num_elements ( Z_ARRVAL_P ( intern -> u . file . current_zval ) ) == 1 ) { <NEW_LINE> zval ** first = Z_ARRVAL_P ( intern -> u . file . current_zval ) -> pListHead -> pData ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return Z_TYPE_PP ( first ) == IS_STRING && Z_STRLEN_PP ( first ) == 0 ; <NEW_LINE> } <NEW_LINE> return zend_hash_num_elements ( Z_ARRVAL_P ( intern -> u . file . current_zval ) ) == 0 ;
enum gr_face_options { <NEW_LINE> gr_face_default = 0 , <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> gr_face_dumbRendering = 1 , <NEW_LINE> gr_face_preloadGlyphs = 2 ,
ExtensionPopup * TestGetPopup ( ) { return popup_ ; } <NEW_LINE> private: <NEW_LINE> <START_VULN> <NEW_LINE>virtual void BrowserActionAdded ( Extension * extension , int index ) ; <NEW_LINE>virtual void BrowserActionRemoved ( Extension * extension ) ; <NEW_LINE> <END_VULN>
if ( res ) <NEW_LINE> goto out ; <NEW_LINE> <START_VULN> kzfree ( raw_key ) ; <NEW_LINE>raw_key = NULL ; <NEW_LINE>if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) != NULL ) { <NEW_LINE>put_crypt_info ( crypt_info ) ; <NEW_LINE>goto retry ; <NEW_LINE> } <NEW_LINE>return 0 ; <NEW_LINE><NEW_LINE> <END_VULN> out: <NEW_LINE> if ( res == - ENOKEY ) <NEW_LINE> res = 0 ;
png_warning ( png_ptr , msg ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_READ_SUPPORTED <NEW_LINE> #ifdef PNG_BENIGN_ERRORS_SUPPORTED
if ( is_amsdu && tvb_reported_length_remaining ( next_tvb , 0 ) > 4 ) { <NEW_LINE> tvbuff_t * volatile msdu_tvb = NULL ; <NEW_LINE> guint32 msdu_offset = 0 ; <NEW_LINE> <START_VULN> guint16 i = 1 ; <NEW_LINE> <END_VULN> const guint8 * lcl_src = NULL ; <NEW_LINE> const guint8 * lcl_dst = NULL ; <NEW_LINE> guint16 msdu_length ;
if ( ! strncmp ( prop_chunk , "SND " , 4 ) ) { <NEW_LINE> char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; <NEW_LINE> <START_VULN> uint16_t numChannels , chansSpecified , chanMask = 0 ; <NEW_LINE> <END_VULN> uint32_t sampleRate ; <NEW_LINE> while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) {
int slots = <NEW_LINE> #endif <NEW_LINE> FlushNativeStackFrame ( cx , innermost -> calldepth , <NEW_LINE> getStackTypeMap ( innermost ) , <NEW_LINE> stack , NULL ) ; <NEW_LINE> JS_ASSERT ( unsigned ( slots ) == innermost -> numStackSlots ) ; <NEW_LINE> if ( innermost -> nativeCalleeWord ) <NEW_LINE> <START_VULN> SynthesizeSlowNativeFrame ( cx , innermost ) ; <NEW_LINE> <END_VULN> double * global = ( double * ) ( & state + 1 ) ; <NEW_LINE> FlushNativeGlobalFrame ( cx , ngslots , gslots , globalTypeMap , global ) ; <NEW_LINE> JS_ASSERT ( * ( uint64 * ) & global [ STOBJ_NSLOTS ( JS_GetGlobalForObject ( cx , cx -> fp -> scopeChain ) ) ] == <NEW_LINE> 0xdeadbeefdeadbeefLL ) ; <NEW_LINE> #ifdef DEBUG
frames . * / <NEW_LINE> memset ( & raw , 0 , sizeof ( raw ) ) ; <NEW_LINE> else <NEW_LINE> <START_VULN> vpx_img_alloc ( & raw , <NEW_LINE>input . use_i420 ? VPX_IMG_FMT_I420 <NEW_LINE>: VPX_IMG_FMT_YV12 , <NEW_LINE>input . width , input . height , 32 ) ; <NEW_LINE> <END_VULN> FOREACH_STREAM ( stream -> rate_hist = <NEW_LINE> init_rate_histogram ( & stream -> config . cfg ,
strcpy ( temp , filename ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> delete [ ] chunking_base_name_ ; <NEW_LINE> <END_VULN> chunking_base_name_ = temp ; <NEW_LINE> if ( ! UpdateChunkName ( "chk" , & chunk_name_ ) )
demux_sys_t * p_sys = p_demux -> p_sys ; <NEW_LINE> block_t * p_block = tk -> p_sipr_packet ; <NEW_LINE> <START_VULN> if ( p_sys -> i_buffer < tk -> i_frame_size ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> if ( ! p_block )
static Variant HHVM_FUNCTION ( bcdiv , const String & left , const String & right , <NEW_LINE> int64_t scale ) { <NEW_LINE> <START_VULN> if ( scale < 0 ) scale = BCG ( bc_precision ) ; <NEW_LINE> <END_VULN> bc_num first , second , result ; <NEW_LINE> bc_init_num ( & first ) ; <NEW_LINE> bc_init_num ( & second ) ;
0 , imageData , imageLength , <NEW_LINE> nsnull , <NEW_LINE> nsnull ) ; <NEW_LINE> nsIntRect rect = frame -> GetRect ( ) ; <NEW_LINE> if ( rect . x != aX || rect . y != aY || rect . width != aWidth || rect . height != aHeight || <NEW_LINE> frame -> GetFormat ( ) != aFormat ) { <NEW_LINE> <START_VULN> delete frame ; <NEW_LINE> <END_VULN> return InternalAddFrame ( aFrameNum , aX , aY , aWidth , aHeight , aFormat , <NEW_LINE> 0 , imageData , imageLength , <NEW_LINE> nsnull , <NEW_LINE> nsnull ) ; <NEW_LINE> } <NEW_LINE> frame -> GetImageData ( imageData , imageLength ) ;
} <NEW_LINE> Symbol * VM::symbol ( const char * str ) { <NEW_LINE> <START_VULN> return shared . symbols . lookup ( str , strlen ( str ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> Symbol * VM::symbol ( std::string str ) {
} <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> <START_VULN> for ( j = 0 ; j < x -> searches_per_step ; j ++ ) { <NEW_LINE> <END_VULN> const MV this_mv = { best_mv -> row + ss [ i ] . mv . row , <NEW_LINE> best_mv -> col + ss [ i ] . mv . col } ;
check_location ( png_ptr , location ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE><NEW_LINE> <END_VULN> #ifdef PNG_MNG_FEATURES_SUPPORTED <NEW_LINE> png_uint_32 PNGAPI
TaskRunnerHelper::Get ( TaskType::kMediaElementEvent , <NEW_LINE> Context ( ) -> GetExecutionContext ( ) ) <NEW_LINE> <START_VULN> -> PostTask ( BLINK_FROM_HERE , <NEW_LINE>CrossThreadBind ( <NEW_LINE> & ScriptProcessorHandler:: <NEW_LINE>FireProcessEventForOfflineAudioContext , <NEW_LINE>CrossThreadUnretained ( this ) , double_buffer_index_ , <NEW_LINE>CrossThreadUnretained ( waitable_event . get ( ) ) ) ) ; <NEW_LINE> <END_VULN>
sRetMsg . clear ( ) ; <NEW_LINE> <START_VULN> for ( unsigned int a = 0 ; a < sModule . length ( ) ; a ++ ) { <NEW_LINE>if ( ( ( sModule [ a ] < '0' ) || ( sModule [ a ] > '9' ) ) && <NEW_LINE> ( ( sModule [ a ] < 'a' ) || ( sModule [ a ] > 'z' ) ) && <NEW_LINE> ( ( sModule [ a ] < 'A' ) || ( sModule [ a ] > 'Z' ) ) && ( sModule [ a ] != '_' ) ) { <NEW_LINE>sRetMsg = <NEW_LINE>t_f ( "Module names can only contain letters , numbers and " <NEW_LINE>"underscores , [ { 1 } ] is invalid" ) ( sModule ) ; <NEW_LINE>return nullptr ; <NEW_LINE> } <NEW_LINE> <END_VULN> }
exit ( 1 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( multiple ) <NEW_LINE> <END_VULN> { <NEW_LINE> int i ; <NEW_LINE> #if defined ( PNG_USER_MEM_SUPPORTED ) && PNG_DEBUG
& cipher , & cipher_len , & module , & module_len ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> td = mcrypt_module_open ( cipher , cipher_dir_string , module , module_dir_string ) ; <NEW_LINE> if ( td != MCRYPT_FAILED ) { <NEW_LINE> RETVAL_LONG ( mcrypt_enc_get_key_size ( td ) ) ;
return hdrlen ; <NEW_LINE> } <NEW_LINE> if ( ndo -> ndo_vflag ) <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " % 04x: % 04x " , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; <NEW_LINE> <END_VULN> p += 2 ; <NEW_LINE> caplen - = 2 ; <NEW_LINE> hdrlen += 2 ;
status_t initialize ( camera_module_t * module ) ; <NEW_LINE> <START_VULN> status_t dump ( int fd , const Vector < String16 > & args ) ; <NEW_LINE> <END_VULN> private:
NS_IMPL_EVENT_HANDLER ( nsDOMFileReader , loadstart ) <NEW_LINE> NS_IMPL_FORWARD_EVENT_HANDLER ( nsDOMFileReader , abort , FileIOObject ) <NEW_LINE> NS_IMPL_FORWARD_EVENT_HANDLER ( nsDOMFileReader , progress , FileIOObject ) <NEW_LINE> NS_IMPL_FORWARD_EVENT_HANDLER ( nsDOMFileReader , error , FileIOObject ) <NEW_LINE> void <NEW_LINE> nsDOMFileReader::RootResultArrayBuffer ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsContentUtils::PreserveWrapper ( <NEW_LINE>static_cast < EventTarget * > ( <NEW_LINE>static_cast < nsDOMEventTargetHelper * > ( this ) ) , this ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsDOMFileReader::nsDOMFileReader ( ) <NEW_LINE> : mFileData ( nullptr ) , <NEW_LINE> mDataLen ( 0 ) , mDataFormat ( FILE_AS_BINARY ) , <NEW_LINE> mResultArrayBuffer ( nullptr )
a -> y2a = y2a * weight + y2b ; <NEW_LINE> a -> xya = xya * weight + xyb ; <NEW_LINE> a -> an = na * weight + nb ; <NEW_LINE> } <NEW_LINE> return ( na ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void fit_line ( lsfit_acc * a , int fits , int * y0 , int * y1 ) { <NEW_LINE> <END_VULN> long x = 0 , y = 0 , x2 = 0 , y2 = 0 , xy = 0 , an = 0 , i ; <NEW_LINE> long x0 = a [ 0 ] . x0 ; <NEW_LINE> long x1 = a [ fits - 1 ] . x1 ; <NEW_LINE> for ( i = 0 ; i < fits ; i ++ ) { <NEW_LINE> x += a [ i ] . xa ; <NEW_LINE> y += a [ i ] . ya ; <NEW_LINE> x2 += a [ i ] . x2a ;
ND_PRINT ( ( ndo , " ] " ) ) ; <NEW_LINE> return ; <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " [ | icmp6 ] " ) ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
mFrameIsUpdatingScrollbar = true ; <NEW_LINE> nsCOMPtr < nsIContent > vScroll = <NEW_LINE> mVScrollbarBox ? mVScrollbarBox -> GetContent ( ) : nullptr ; <NEW_LINE> nsCOMPtr < nsIContent > hScroll = <NEW_LINE> mHScrollbarBox ? mHScrollbarBox -> GetContent ( ) : nullptr ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( vScroll || hScroll ) { <NEW_LINE> nsWeakFrame weakFrame ( mOuter ) ; <NEW_LINE> nsPoint scrollPos = GetScrollPosition ( ) ; <NEW_LINE> nsSize lineScrollAmount = GetLineScrollAmount ( ) ; <NEW_LINE> if ( vScroll ) { <NEW_LINE> const double kScrollMultiplier = <NEW_LINE> Preferences::GetInt ( "toolkit . scrollbox . verticalScrollDistance" , <NEW_LINE> NS_DEFAULT_VERTICAL_SCROLL_DISTANCE ) ;
if ( ctxt -> recovery == 0 ) ctxt -> disableSAX = 1 ; <NEW_LINE> ctxt -> instate = XML_PARSER_IGNORE ; <NEW_LINE> <START_VULN> while ( ( depth >= 0 ) && ( RAW != 0 ) ) { <NEW_LINE> <END_VULN> if ( ( RAW == ' < ' ) && ( NXT ( 1 ) == ' ! ' ) && ( NXT ( 2 ) == ' [ ' ) ) { <NEW_LINE> depth ++ ; <NEW_LINE> SKIP ( 3 ) ;
int ret ; <NEW_LINE> ret = png_set_text_2 ( png_ptr , info_ptr , text_ptr , num_text ) ; <NEW_LINE> <START_VULN> if ( ret ) <NEW_LINE> <END_VULN> png_error ( png_ptr , "Insufficient memory to store text" ) ; <NEW_LINE> }
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . serializedValue" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> bool serializedArgDidThrow = false ; <NEW_LINE> RefPtr < SerializedScriptValue > serializedArg = SerializedScriptValue::create ( args [ 0 ] , 0 , 0 , serializedArgDidThrow , args . GetIsolate ( ) ) ;
} <NEW_LINE> return ; <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " [ | truncated ] " ) ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
} <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsLocation::SetHref ( const nsAString & aHref ) <NEW_LINE> { <NEW_LINE> nsAutoString oldHref ; <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> <START_VULN> <NEW_LINE>nsCOMPtr < nsIJSContextStack > <NEW_LINE>stack ( do_GetService ( "@mozilla . org / js / xpc / ContextStack ; 1" , & rv ) ) ; <NEW_LINE><NEW_LINE>if ( NS_FAILED ( rv ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE><NEW_LINE>JSContext * cx ; <NEW_LINE><NEW_LINE>if ( NS_FAILED ( GetContextFromStack ( stack , & cx ) ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> <END_VULN>
bool frozen ; <NEW_LINE> <START_VULN> <NEW_LINE>NGLayoutInputNode ng_input_node ; <NEW_LINE> <END_VULN> scoped_refptr < NGLayoutResult > layout_result ; <NEW_LINE> } ;
#endif <NEW_LINE> } ; <NEW_LINE> <START_VULN> int get_vpx_encoder_count ( ) { <NEW_LINE> <END_VULN> return sizeof ( vpx_encoders ) / sizeof ( vpx_encoders [ 0 ] ) ; <NEW_LINE> }
<START_VULN> #ifndef BASE_TEST_TEST_REG_UTIL_H_ <NEW_LINE>#define BASE_TEST_TEST_REG_UTIL_H_ <NEW_LINE> <END_VULN>
class TextureImageTransportSurface : <NEW_LINE> public ImageTransportSurface , <NEW_LINE> public GpuCommandBufferStub::DestructionObserver , <NEW_LINE> <START_VULN> public gfx::GLSurface , <NEW_LINE>public base::SupportsWeakPtr < TextureImageTransportSurface > { <NEW_LINE> <END_VULN> public: <NEW_LINE> TextureImageTransportSurface ( GpuChannelManager * manager , <NEW_LINE> GpuCommandBufferStub * stub ,
wrapper = & FilteringWrapper < XrayDOM , CrossOriginAccessiblePropertiesOnly > ::singleton ; <NEW_LINE> } else if ( IsComponentsObject ( obj ) ) { <NEW_LINE> wrapper = & FilteringWrapper < CrossCompartmentSecurityWrapper , <NEW_LINE> ComponentsObjectPolicy > ::singleton ; <NEW_LINE> } else { <NEW_LINE> wrapper = & FilteringWrapper < CrossCompartmentSecurityWrapper , <NEW_LINE> ExposedPropertiesOnly > ::singleton ; <NEW_LINE> } <NEW_LINE> <START_VULN> } else if ( AccessCheck::isSameOrigin ( origin , target ) ) { <NEW_LINE> <END_VULN>
if ( mContent ) { <NEW_LINE> mContent -> SetHost ( nullptr ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> NS_IMPL_ADDREF_INHERITED ( HTMLTemplateElement , Element ) <NEW_LINE> NS_IMPL_RELEASE_INHERITED ( HTMLTemplateElement , Element ) <NEW_LINE> <START_VULN> NS_IMPL_CYCLE_COLLECTION_INHERITED_1 ( HTMLTemplateElement , <NEW_LINE>nsGenericHTMLElement , <NEW_LINE>mContent ) <NEW_LINE> <END_VULN> NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED ( HTMLTemplateElement ) <NEW_LINE> NS_INTERFACE_MAP_END_INHERITING ( nsGenericHTMLElement ) <NEW_LINE> NS_IMPL_ELEMENT_CLONE_WITH_INIT ( HTMLTemplateElement ) <NEW_LINE> JSObject *
best_mode . rd = INT_MAX ; <NEW_LINE> best_mode . yrd = INT_MAX ; <NEW_LINE> best_mode . intra_rd = INT_MAX ; <NEW_LINE> <START_VULN> vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; <NEW_LINE>vpx_memset ( & best_mode . mbmode , 0 , sizeof ( best_mode . mbmode ) ) ; <NEW_LINE>vpx_memset ( & best_mode . bmodes , 0 , sizeof ( best_mode . bmodes ) ) ; <NEW_LINE> <END_VULN> get_reference_search_order ( cpi , ref_frame_map ) ;
return nullptr ; <NEW_LINE> return newSkImageFromRaster ( <NEW_LINE> info , std::move ( dstPixels ) , <NEW_LINE> <START_VULN> static_cast < size_t > ( input -> width ( ) ) * info . bytesPerPixel ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static sk_sp < SkImage > unPremulSkImageToPremul ( SkImage * input ) {
} <NEW_LINE> uint32_t afterOffset = nextOffset + GetBytecodeLength ( nextpc ) ; <NEW_LINE> if ( afterOffset < script -> length ) { <NEW_LINE> if ( analysis -> maybeCode ( afterOffset ) && <NEW_LINE> JSOp ( script -> code [ afterOffset ] ) == JSOP_LOOPHEAD && <NEW_LINE> analysis -> getLoop ( afterOffset ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> finishChunk = true ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( finishChunk && ! preserveChunk ) { <NEW_LINE> ChunkDescriptor desc ; <NEW_LINE> desc . begin = chunkStart ; <NEW_LINE> desc . end = nextOffset ;
public: <NEW_LINE> bool init ( uint32_t id , uint32_t offset , uint32_t numSuccessors ) { <NEW_LINE> id_ = id ; <NEW_LINE> offset_ = offset ; <NEW_LINE> numSuccessors_ = numSuccessors ; <NEW_LINE> if ( numSuccessors ) { <NEW_LINE> <START_VULN> successors_ = ( uint32_t * ) js_calloc ( numSuccessors * sizeof ( uint32_t ) ) ; <NEW_LINE> <END_VULN> if ( ! successors_ ) <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> void destroy ( ) { <NEW_LINE> js_free ( successors_ ) ;
WillBeHeapVector < RefPtrWillBeMember < SVGSVGElement > > timeContainers ; <NEW_LINE> timeContainers . appendRange ( m_timeContainers . begin ( ) , m_timeContainers . end ( ) ) ; <NEW_LINE> WillBeHeapVector < RefPtrWillBeMember < SVGSVGElement > > ::iterator end = timeContainers . end ( ) ; <NEW_LINE> <START_VULN> for ( WillBeHeapVector < RefPtrWillBeMember < SVGSVGElement > > ::iterator itr = timeContainers . begin ( ) ; itr != end ; ++ itr ) <NEW_LINE> ( * itr ) -> timeContainer ( ) -> begin ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void SVGDocumentExtensions::pauseAnimations ( )
{ <NEW_LINE> if ( chunk_name == png_IDAT ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ( length > 0 ) || ( png_ptr -> mode & PNG_HAVE_CHUNK_AFTER_IDAT ) ) <NEW_LINE> <END_VULN> png_benign_error ( png_ptr , "Too many IDATs found" ) ; <NEW_LINE> } <NEW_LINE> png_handle_unknown ( png_ptr , info_ptr , length , keep ) ;
NS_INTERFACE_MAP_ENTRY ( nsIDOMMouseMotionListener ) <NEW_LINE> NS_INTERFACE_MAP_ENTRY ( nsIDOMKeyListener ) <NEW_LINE> NS_INTERFACE_MAP_ENTRY ( nsIDOMFocusListener ) <NEW_LINE> NS_INTERFACE_MAP_ENTRY_AMBIGUOUS ( nsIDOMEventListener , nsIDOMMouseListener ) <NEW_LINE> NS_INTERFACE_MAP_ENTRY_AMBIGUOUS ( nsISupports , nsIPluginInstanceOwner ) <NEW_LINE> NS_INTERFACE_MAP_END <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsPluginInstanceOwner::SetInstance ( nsIPluginInstance * aInstance ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! mInstance || ! aInstance , "mInstance should only be set once ! " ) ; <NEW_LINE> <END_VULN> mInstance = aInstance ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsPluginInstanceOwner::GetWindow ( NPWindow * & aWindow ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( mPluginWindow , "the plugin window object being returned is null" ) ; <NEW_LINE> aWindow = mPluginWindow ;
png_get_bKGD ( png_const_structrp png_ptr , png_inforp info_ptr , <NEW_LINE> png_color_16p * background ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr != NULL && info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_bKGD ) <NEW_LINE> && background != NULL ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_debug1 ( 1 , "in % s retrieval function" , "bKGD" ) ;
} <NEW_LINE> } else if ( msg . type == omx_message::EMPTY_BUFFER_DONE ) { <NEW_LINE> OMX_BUFFERHEADERTYPE * buffer = <NEW_LINE> <START_VULN> findBufferHeader ( msg . u . buffer_data . buffer ) ; <NEW_LINE> <END_VULN> { <NEW_LINE> Mutex::Autolock _l ( mDebugLock ) ;
@param count Count of pad characters to put <NEW_LINE> @returns Zero if successful and otherwise a negative error code <NEW_LINE> @ingroup MprBuf <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC ssize mprPutPadToBuf ( MprBuf * buf , int c , ssize count ) ;
private: <NEW_LINE> void doMode ( const BufferInfo & bufferInfo , const QChar & addOrRemove , const QChar & mode , const QString & nickList ) ; <NEW_LINE> void banOrUnban ( const BufferInfo & bufferInfo , const QString & text , bool ban ) ; <NEW_LINE> <START_VULN> void putPrivmsg ( const QByteArray & target , const QByteArray & message , Cipher * cipher = 0 ) ; <NEW_LINE> <END_VULN> #ifdef HAVE_QCA2 <NEW_LINE> QByteArray encrypt ( const QString & target , const QByteArray & message , bool * didEncrypt = 0 ) const ;
#define USB_API_HUB 1 <NEW_LINE> #define USB_API_COMPOSITE 2 <NEW_LINE> #define USB_API_WINUSBX 3 <NEW_LINE> <START_VULN> #define USB_API_HID 4 <NEW_LINE>#define USB_API_MAX 5 <NEW_LINE><NEW_LINE> <END_VULN> #define USB_API_SET ( 1 << USB_API_MAX )
ND_PRINT ( ( ndo , " ( length bogus , should be >= 4 ) " ) ) ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <NEW_LINE> <END_VULN> compproto = EXTRACT_16BITS ( p + 2 ) ; <NEW_LINE> ND_PRINT ( ( ndo , ": % s ( 0x % 02x ) :" ,
{ <NEW_LINE> BYTE c ; <NEW_LINE> BYTE flags ; <NEW_LINE> <START_VULN> int extra ; <NEW_LINE> <END_VULN> int opIndex ; <NEW_LINE> int haveBits ; <NEW_LINE> int inPrefix ;
if ( flags ) { <NEW_LINE> * p = '\0' ; <NEW_LINE> * nargv ++ = flagsp ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> while ( ( * nargv ++ = * argv ++ ) ) ;
interface = get_vpx_decoder_by_index ( 0 ) ; <NEW_LINE> dec_flags = ( postproc ? VPX_CODEC_USE_POSTPROC : 0 ) | <NEW_LINE> <START_VULN> ( ec_enabled ? VPX_CODEC_USE_ERROR_CONCEALMENT : 0 ) ; <NEW_LINE>if ( vpx_codec_dec_init ( & decoder , interface -> interface ( ) , & cfg , dec_flags ) ) { <NEW_LINE> <END_VULN> fprintf ( stderr , "Failed to initialize decoder: % s\n" , <NEW_LINE> vpx_codec_error ( & decoder ) ) ; <NEW_LINE> return EXIT_FAILURE ;
dwc3_ep_inc_trb ( & dep -> trb_dequeue ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>void dwc3_gadget_giveback ( struct dwc3_ep * dep , struct dwc3_request * req , <NEW_LINE>int status ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct dwc3 * dwc = dep -> dwc ;
JS_ASSERT ( pos == wholeChars + wholeLength ) ; <NEW_LINE> * pos = '\0' ; <NEW_LINE> str -> d . lengthAndFlags = buildLengthAndFlags ( wholeLength , EXTENSIBLE_FLAGS ) ; <NEW_LINE> str -> d . u1 . chars = wholeChars ; <NEW_LINE> str -> d . s . u2 . capacity = wholeCapacity ; <NEW_LINE> return & this -> asFlat ( ) ; <NEW_LINE> } <NEW_LINE> size_t progress = str -> d . lengthAndFlags ; <NEW_LINE> <START_VULN> str -> d . lengthAndFlags = buildLengthAndFlags ( pos - str -> d . u1 . chars , DEPENDENT_BIT ) ; <NEW_LINE> <END_VULN> str -> d . s . u2 . base = ( JSLinearString * ) this ; <NEW_LINE> JSString::writeBarrierPost ( str -> d . s . u2 . base , & str -> d . s . u2 . base ) ; <NEW_LINE> str = str -> d . s . u3 . parent ; <NEW_LINE> if ( progress == 0x200 ) <NEW_LINE> goto visit_right_child ; <NEW_LINE> JS_ASSERT ( progress == 0x300 ) ; <NEW_LINE> goto finish_node ; <NEW_LINE> }
jas_matrix_t * jas_matrix_copy ( jas_matrix_t * x ) <NEW_LINE> { <NEW_LINE> jas_matrix_t * y ; <NEW_LINE> <START_VULN> int i ; <NEW_LINE>int j ; <NEW_LINE> <END_VULN> y = jas_matrix_create ( x -> numrows_ , x -> numcols_ ) ; <NEW_LINE> for ( i = 0 ; i < x -> numrows_ ; ++ i ) { <NEW_LINE> for ( j = 0 ; j < x -> numcols_ ; ++ j ) {
case JSOP_NOT: <NEW_LINE> return jsop_not ( ) ; <NEW_LINE> case JSOP_THIS: <NEW_LINE> return jsop_this ( ) ; <NEW_LINE> case JSOP_CALLEE: <NEW_LINE> { <NEW_LINE> <START_VULN> MCallee * callee = MCallee::New ( ) ; <NEW_LINE> <END_VULN> current -> add ( callee ) ; <NEW_LINE> current -> push ( callee ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> case JSOP_GETPROP: <NEW_LINE> case JSOP_CALLPROP: <NEW_LINE> {
PRUint32 index = 0 ; <NEW_LINE> PRUint32 dataLength = aNewValue . mData . Length ( ) ; <NEW_LINE> PRUint32 dataIndex = 0 ; <NEW_LINE> PRUint32 newSegType ; <NEW_LINE> nsRefPtr < DOMSVGPathSegList > kungFuDeathGrip ; <NEW_LINE> <START_VULN> if ( aNewValue . Length ( ) < length ) { <NEW_LINE> <END_VULN> kungFuDeathGrip = this ; <NEW_LINE> } <NEW_LINE> while ( index < length && dataIndex < dataLength ) { <NEW_LINE> newSegType = SVGPathSegUtils::DecodeType ( aNewValue . mData [ dataIndex ] ) ; <NEW_LINE> if ( ItemAt ( index ) && ItemAt ( index ) -> Type ( ) != newSegType ) { <NEW_LINE> ItemAt ( index ) -> RemovingFromList ( ) ; <NEW_LINE> ItemAt ( index ) = nsnull ;
UNROLL3 ( { <NEW_LINE> pos = pos -> next ; <NEW_LINE> if ( pos -> x >= edge -> x ) <NEW_LINE> break ; <NEW_LINE> } ) <NEW_LINE> } while ( TRUE ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>pos -> prev -> next = edge ; <NEW_LINE>edge -> prev = pos -> prev ; <NEW_LINE>edge -> next = pos ; <NEW_LINE>pos -> prev = edge ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline cairo_bool_t <NEW_LINE> sweep_line_insert ( sweep_line_t * sweep , <NEW_LINE> rectangle_t * rectangle ) <NEW_LINE> { <NEW_LINE> edge_t * pos ;
mCloneWriteInfo . mCloneBuffer . clear ( ) ; <NEW_LINE> return mKey . ToJSVal ( aCx , aVal ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> AddHelper::ReleaseMainThreadObjects ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( mCloneWriteInfo . mCloneBuffer ) ; <NEW_LINE> <END_VULN> ObjectStoreHelper::ReleaseMainThreadObjects ( ) ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> AddHelper::PackArgumentsForParentProcess ( ObjectStoreRequestParams & aParams ) <NEW_LINE> { <NEW_LINE> AddPutParams commonParams ; <NEW_LINE> commonParams . cloneInfo ( ) = mCloneWriteInfo ;
res [ 3 ] = _mm_unpackhi_epi64 ( res [ 2 ] , res [ 2 ] ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void fdct4_sse2 ( __m128i * in ) { <NEW_LINE>const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <NEW_LINE> <END_VULN> const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; <NEW_LINE> const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; <NEW_LINE> const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ;
if ( ! m_parent ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( diff == StyleDifferenceLayout || diff == StyleDifferenceSimplifiedLayout ) { <NEW_LINE> <END_VULN> RenderCounter::rendererStyleChanged ( * this , oldStyle , m_style . get ( ) ) ;
if ( len && * ( token - 1 ) == '\n' ) { <NEW_LINE> -- len ; <NEW_LINE> if ( len && * ( token - 2 ) == '\r' ) <NEW_LINE> -- len ; <NEW_LINE> } <NEW_LINE> return len ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsPartChannel::nsPartChannel ( nsIChannel * aMultipartChannel , PRUint32 aPartID ) : <NEW_LINE> <END_VULN> mStatus ( NS_OK ) , <NEW_LINE> mContentLength ( LL_MAXUINT ) , <NEW_LINE> mIsByteRangeRequest ( PR_FALSE ) , <NEW_LINE> mByteRangeStart ( 0 ) , <NEW_LINE> mByteRangeEnd ( 0 ) , <NEW_LINE> mPartID ( aPartID ) , <NEW_LINE> mIsLastPart ( PR_FALSE ) <NEW_LINE> {
let = ( pn -> pn_op == JSOP_NOP ) ; <NEW_LINE> forInVar = ( pn -> pn_xflags & PNX_FORINVAR ) != 0 ; <NEW_LINE> #if JS_HAS_BLOCK_SCOPE <NEW_LINE> <START_VULN> forInLet = let && forInVar ; <NEW_LINE>popScope = ( inLetHead || ( let && ( cg -> flags & TCF_IN_FOR_INIT ) ) ) ; <NEW_LINE>if ( popScope ) { <NEW_LINE>stmt = cg -> topStmt ; <NEW_LINE>scopeStmt = cg -> topScopeStmt ; <NEW_LINE> } <NEW_LINE># ifdef __GNUC__ <NEW_LINE>else stmt = scopeStmt = NULL ; <NEW_LINE># endif <NEW_LINE>JS_ASSERT ( ! popScope || let ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> off = noteIndex = - 1 ; <NEW_LINE> for ( pn2 = pn -> pn_head ; ; pn2 = next ) { <NEW_LINE> first = pn2 == pn -> pn_head ; <NEW_LINE> next = pn2 -> pn_next ; <NEW_LINE> if ( pn2 -> pn_type != TOK_NAME ) {
offset += 3 ; <NEW_LINE> length - = 3 ; <NEW_LINE> <START_VULN> memcpy ( tim . bitmap , p + ( tim . length - 3 ) , <NEW_LINE> ( tim . length - 3 ) ) ; <NEW_LINE> <END_VULN> offset += tim . length - 3 ; <NEW_LINE> length - = tim . length - 3 ;
return ( 0 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! num_in ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> if ( memcmp ( inbuf , outbuf , num_in ) )
efree ( ustr ) ; <NEW_LINE> } <NEW_LINE> ubrk_close ( bi ) ; <NEW_LINE> <START_VULN> RETURN_EMPTY_STRING ( ) ; <NEW_LINE> <END_VULN> }
{ <NEW_LINE> png_debug1 ( 1 , "in % s retrieval function" , "pCAL" ) ; <NEW_LINE> <START_VULN> if ( png_ptr != NULL && info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_pCAL ) <NEW_LINE> && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL && <NEW_LINE> <END_VULN> nparams != NULL && units != NULL && params != NULL ) <NEW_LINE> { <NEW_LINE> * purpose = info_ptr -> pcal_purpose ;
nsIDocument * ownerDoc = aBoundElement -> GetOwnerDoc ( ) ; <NEW_LINE> nsIScriptGlobalObject * sgo ; <NEW_LINE> <START_VULN> if ( ! ownerDoc || ! ( sgo = ownerDoc -> GetScriptGlobalObject ( ) ) ) { <NEW_LINE>NS_ERROR ( "Can't find global object for bound content ! " ) ; <NEW_LINE><NEW_LINE> <END_VULN> return NS_ERROR_UNEXPECTED ; <NEW_LINE> }
static int keepalive_counter = 0 ; <NEW_LINE> <START_VULN> static unsigned char pass_salt [ 17 ] ; <NEW_LINE> <END_VULN> static char username [ MT_MNDP_MAX_STRING_SIZE ] ; <NEW_LINE> static char password [ MT_MNDP_MAX_STRING_SIZE ] ; <NEW_LINE> static char nonpriv_username [ MT_MNDP_MAX_STRING_SIZE ] ;
virtual scoped_refptr < ui::Texture > CreateTransportClient ( <NEW_LINE> const gfx::Size & size , <NEW_LINE> float device_scale_factor , <NEW_LINE> <START_VULN> uint64 transport_handle ) = 0 ; <NEW_LINE> <END_VULN>
nsIntSize size = GetWidthHeight ( ) ; <NEW_LINE> if ( size . height == 0 || size . width == 0 ) { <NEW_LINE> aDataURL = NS_LITERAL_STRING ( "data: , " ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsAutoString type ; <NEW_LINE> <START_VULN> nsContentUtils::ASCIIToLower ( aMimeType , type ) ; <NEW_LINE> <END_VULN> nsAutoString params ; <NEW_LINE> if ( type . EqualsLiteral ( "image / jpeg" ) ) { <NEW_LINE> PRUint16 vartype ; <NEW_LINE> if ( aEncoderOptions &&
} else { <NEW_LINE> const AtomicString & pressedAttr = <NEW_LINE> axObject . getAttribute ( HTMLNames::aria_pressedAttr ) ; <NEW_LINE> <START_VULN> if ( equalIgnoringCase ( pressedAttr , "mixed" ) ) <NEW_LINE> <END_VULN> properties . addItem ( <NEW_LINE> createProperty ( AXWidgetStatesEnum::Pressed , <NEW_LINE> createValue ( "mixed" , AXValueTypeEnum::Tristate ) ) ) ;
#define PPAPI_DISPATCH_HOST_RESOURCE_CALL ( msg_class , member_func ) \ <NEW_LINE> case msg_class::ID: { \ <NEW_LINE> <START_VULN> TRACK_RUN_IN_IPC_HANDLER ( member_func ) ; \ <NEW_LINE> <END_VULN> msg_class::Schema::Param p ; \ <NEW_LINE> if ( msg_class::Read ( & ipc_message__ , & p ) ) { \ <NEW_LINE> return ppapi::host::DispatchResourceCall ( \
if ( ! mClassObject ) { <NEW_LINE> rv = CompilePrototypeMembers ( aBinding ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) <NEW_LINE> return rv ; <NEW_LINE> <START_VULN> if ( ! mClassObject ) <NEW_LINE>return NS_OK ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsIDocument * ownerDoc = aBoundElement -> OwnerDoc ( ) ; <NEW_LINE> nsIScriptGlobalObject * sgo ; <NEW_LINE> if ( ! ( sgo = ownerDoc -> GetScopeObject ( ) ) ) { <NEW_LINE> return NS_ERROR_UNEXPECTED ; <NEW_LINE> }
virtual bool UndoScope ( ) MOZ_OVERRIDE ; <NEW_LINE> virtual void SetUndoScope ( bool aUndoScope , mozilla::ErrorResult & aError ) MOZ_OVERRIDE ; <NEW_LINE> nsresult ClearDataset ( ) ; <NEW_LINE> <START_VULN> nsSize GetWidthHeightForImage ( imgIRequest * aImageRequest ) ; <NEW_LINE> <END_VULN> NS_FORWARD_NSIDOMNODE_TO_NSINODE <NEW_LINE> NS_FORWARD_NSIDOMELEMENT_TO_GENERIC <NEW_LINE> NS_IMETHOD GetId ( nsAString & aId ) MOZ_FINAL { <NEW_LINE> mozilla::dom::Element::GetId ( aId ) ;
void * chk_malloc ( size_t bytes ) <NEW_LINE> { <NEW_LINE> <START_VULN> char * buffer = ( char * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ; <NEW_LINE> <END_VULN> if ( buffer ) { <NEW_LINE> memset ( buffer , CHK_SENTINEL_VALUE , bytes + CHK_OVERHEAD_SIZE ) ; <NEW_LINE> size_t offset = dlmalloc_usable_size ( buffer ) - sizeof ( size_t ) ;
png_debug1 ( 1 , "in % s storage function" , "pCAL" ) ; <NEW_LINE> if ( png_ptr == NULL || info_ptr == NULL || purpose == NULL || units == NULL <NEW_LINE> <START_VULN> || ( nparams > 0 && params == NULL ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> length = strlen ( purpose ) + 1 ;
} <NEW_LINE> break ; <NEW_LINE> case ' % ': <NEW_LINE> <START_VULN> doapr_outch ( sbuffer , buffer , & currlen , maxlen , ch ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 'w':
{ <NEW_LINE> rtnl_link_unregister ( & ipgre_tap_ops ) ; <NEW_LINE> rtnl_link_unregister ( & ipgre_link_ops ) ; <NEW_LINE> <START_VULN> unregister_pernet_device ( & ipgre_net_ops ) ; <NEW_LINE> <END_VULN> if ( inet_del_protocol ( & ipgre_protocol , IPPROTO_GRE ) < 0 ) <NEW_LINE> printk ( KERN_INFO "ipgre close: can't remove protocol\n" ) ; <NEW_LINE> } <NEW_LINE> module_init ( ipgre_init ) ;
MediaByteRange const & aByteRange ) ; <NEW_LINE> virtual nsresult Close ( ) ; <NEW_LINE> virtual void Suspend ( bool aCloseImmediately ) ; <NEW_LINE> virtual void Resume ( ) ; <NEW_LINE> virtual already_AddRefed < nsIPrincipal > GetCurrentPrincipal ( ) ; <NEW_LINE> bool IsClosed ( ) const { return mCacheStream . IsClosed ( ) ; } <NEW_LINE> virtual bool CanClone ( ) ; <NEW_LINE> <START_VULN> virtual MediaResource * CloneData ( MediaDecoder * aDecoder ) ; <NEW_LINE> <END_VULN> void RecordStatisticsTo ( MediaChannelStatistics * aStatistics ) MOZ_OVERRIDE { <NEW_LINE> NS_ASSERTION ( aStatistics , "Statistics param cannot be null ! " ) ; <NEW_LINE> MutexAutoLock lock ( mLock ) ; <NEW_LINE> if ( ! mChannelStatistics ) { <NEW_LINE> mChannelStatistics = aStatistics ; <NEW_LINE> }
return ; <NEW_LINE> #ifdef PNG_READ_INTERLACING_SUPPORTED <NEW_LINE> <START_VULN> if ( png_ptr -> interlaced ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_ptr -> row_number = 0 ; <NEW_LINE> memset ( png_ptr -> prev_row , 0 , png_ptr -> rowbytes + 1 ) ;
nsresult rv = window -> GetLocation ( getter_AddRefs ( location ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> rv = location -> SetHref ( nsDependentJSString ( val ) ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE><NEW_LINE> <END_VULN> nsCOMPtr < nsIXPConnectJSObjectHolder > holder ; <NEW_LINE> rv = WrapNative ( cx , obj , location , NS_GET_IID ( nsIDOMLocation ) , vp , <NEW_LINE> getter_AddRefs ( holder ) ) ; <NEW_LINE> return NS_FAILED ( rv ) ? rv : NS_SUCCESS_I_DID_SOMETHING ; <NEW_LINE> }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: libvorbis backend and mapping structures ; needed for <NEW_LINE> static mode headers <NEW_LINE> <START_VULN> last mod: $ Id: backends . h 16326 2009 - 07 - 24 00:06:53Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _vorbis_backend_h_
void spellCheckingRequestProcessed ( int32_t transactionId , spannable_string_t * ) ; <NEW_LINE> void spellCheckingRequestCancelled ( int32_t transactionId ) ; <NEW_LINE> <START_VULN> bool shouldRequestSpellCheckingOptionsForPoint ( Platform::IntPoint & , const WebCore::Element * , imf_sp_text_t & ) ; <NEW_LINE> <END_VULN> void requestSpellingCheckingOptions ( imf_sp_text_t & , WebCore::IntSize & screenOffset , const bool shouldMoveDialog = false ) ; <NEW_LINE> void clearDidSpellCheckState ( ) { m_didSpellCheckWord = false ; } <NEW_LINE> void redrawSpellCheckDialogIfRequired ( const bool shouldMoveDialog = true ) ;
} <NEW_LINE> } <NEW_LINE> if ( EOFBlob ( image ) != MagickFalse ) <NEW_LINE> <START_VULN> { <NEW_LINE>ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , <NEW_LINE>image -> filename ) ; <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE> <END_VULN> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <NEW_LINE> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) <NEW_LINE> break ;
nsIScriptGlobalObject * sgo ; <NEW_LINE> if ( ! ( sgo = ownerDoc -> GetScopeObject ( ) ) ) { <NEW_LINE> return NS_ERROR_UNEXPECTED ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSContext * jscontext = aContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSObject * global = sgo -> GetGlobalJSObject ( ) ; <NEW_LINE> nsCOMPtr < nsIXPConnectJSObjectHolder > wrapper ; <NEW_LINE> jsval v ; <NEW_LINE> rv = nsContentUtils::WrapNative ( jscontext , global , aBoundElement , & v , <NEW_LINE> getter_AddRefs ( wrapper ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
encryption -> key_id_len = buflen ; <NEW_LINE> } else if ( id == 0x7E3 ) { <NEW_LINE> <START_VULN> delete [ ] encryption -> signature ; <NEW_LINE> <END_VULN> encryption -> signature = NULL ; <NEW_LINE> encryption -> signature_len = 0 ;
} <NEW_LINE> bool NormalPageArena::shrinkObject ( HeapObjectHeader * header , size_t newSize ) { <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> ASSERT ( header -> payloadSize ( ) > newSize ) ; <NEW_LINE> size_t allocationSize = ThreadHeap::allocationSizeFromSize ( newSize ) ; <NEW_LINE> ASSERT ( header -> size ( ) > allocationSize ) ;
for ( conn_opt = conn_opts ; conn_opt -> keyword != NULL ; conn_opt ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' ) <NEW_LINE> <END_VULN> argcount ++ ; <NEW_LINE> }
while ( shape -> previous ( ) && ! shape -> enumerable ( ) ) <NEW_LINE> shape = shape -> previous ( ) ; <NEW_LINE> if ( ! shape -> previous ( ) ) { <NEW_LINE> JS_ASSERT ( shape -> isEmptyShape ( ) ) ; <NEW_LINE> * idp = JSID_VOID ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> iterobj -> setPrivate ( const_cast < Shape * > ( shape -> previous ( ) ) ) ; <NEW_LINE> <END_VULN> * idp = shape -> propid ( ) ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> ida = ( JSIdArray * ) iterobj -> getPrivate ( ) ; <NEW_LINE> JS_ASSERT ( i <= ida -> length ) ; <NEW_LINE> STATIC_ASSUME ( i <= ida -> length ) ; <NEW_LINE> if ( i == 0 ) {
static int _vds_shared_init ( vorbis_dsp_state * v , vorbis_info * vi , int encp ) { <NEW_LINE> int i ; <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> private_state * b = NULL ; <NEW_LINE> int hs ; <NEW_LINE> if ( ci == NULL ) return 1 ; <NEW_LINE> <START_VULN> hs = ci -> halfrate_flag ; <NEW_LINE> <END_VULN> memset ( v , 0 , sizeof ( * v ) ) ; <NEW_LINE> b = v -> backend_state = _ogg_calloc ( 1 , sizeof ( * b ) ) ; <NEW_LINE> v -> vi = vi ; <NEW_LINE> b -> modebits = ilog2 ( ci -> modes ) ; <NEW_LINE> b -> transform [ 0 ] = _ogg_calloc ( VI_TRANSFORMB , sizeof ( * b -> transform [ 0 ] ) ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: fft transform <NEW_LINE> <START_VULN> last mod: $ Id: smallft . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_SMFT_H_ <NEW_LINE> #define _V_SMFT_H_ <NEW_LINE> #include "vorbis / codec . h"
best_sse = best_rd_sse ; <NEW_LINE> } <NEW_LINE> vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , <NEW_LINE> <START_VULN> recon_yoffset , recon_uvoffset ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( best_mode . mbmode . ref_frame == INTRA_FRAME &&
* <NEW_LINE> <START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 89 ) <NEW_LINE> <END_VULN> extern JSBool <NEW_LINE> js_XDRAtom ( JSXDRState * xdr , JSAtom ** atomp ) ; <NEW_LINE> JS_END_EXTERN_C
<START_VULN> <NEW_LINE>virtual void NavigateBackForwardSoon ( int offset ) { } <NEW_LINE> <END_VULN>
return x % max ; <NEW_LINE> } <NEW_LINE> <START_VULN> #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED <NEW_LINE> <END_VULN> static int <NEW_LINE> random_choice ( void ) <NEW_LINE> {
if ( tk -> p_subpackets [ j ] ) <NEW_LINE> block_Release ( tk -> p_subpackets [ j ] ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( tk -> i_subpackets ) <NEW_LINE> { <NEW_LINE>free ( tk -> p_subpackets ) ; <NEW_LINE>free ( tk -> p_subpackets_timecode ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> if ( tk -> p_sipr_packet ) <NEW_LINE> block_Release ( tk -> p_sipr_packet ) ; <NEW_LINE> free ( tk ) ;
#endif <NEW_LINE> PHP_GD_CHECK_OPEN_BASEDIR ( fontname , "Invalid font filename" ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #ifdef HAVE_GD_FREETYPE <NEW_LINE> if ( extended ) { <NEW_LINE> error = gdImageStringFTEx ( im , brect , col , fontname , ptsize , angle , x , y , str , & strex ) ;
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> }
return result ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ends_with ( filename , " . pbl" ) ) { <NEW_LINE> <END_VULN> ERR_FS << "Illegal path '" << filename << "' ( . pbl files are not allowed ) . " << std::endl ; <NEW_LINE> return result ; <NEW_LINE> }
nsIDNSRecord * aRecord , <NEW_LINE> nsresult aStatus ) <NEW_LINE> { <NEW_LINE> NS_ABORT_IF_FALSE ( aRequest == mLookup , "wrong DNS query" ) ; <NEW_LINE> mLookup = nullptr ; <NEW_LINE> mLookupStatus = aStatus ; <NEW_LINE> mDnsRec = aRecord ; <NEW_LINE> mState = SOCKS_DNS_COMPLETE ; <NEW_LINE> <START_VULN> ConnectToProxy ( mFD ) ; <NEW_LINE>mFD = nullptr ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> PRStatus <NEW_LINE> nsSOCKSSocketInfo::ConnectToProxy ( PRFileDesc * fd ) <NEW_LINE> { <NEW_LINE> PRStatus status ; <NEW_LINE> nsresult rv ;
if ( gpu -> caps ( ) -> mustClearUploadedBufferData ( ) ) { <NEW_LINE> cpuData = sk_calloc_throw ( sizeInBytes ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> cpuData = sk_malloc_flags ( sizeInBytes , SK_MALLOC_THROW ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( data ) { <NEW_LINE> memcpy ( cpuData , data , sizeInBytes ) ;
#include < string . h > <NEW_LINE> #include "allheaders . h" <NEW_LINE> <START_VULN> static const l_int32 L_BUF_SIZE = 256 ; <NEW_LINE> <END_VULN> static const l_int32 INITIAL_PTR_ARRAYSIZE = 50 ; <NEW_LINE> static const l_int32 MANY_SELS = 1000 ;
SortedVector < wp < IMediaDeathNotifier > > IMediaDeathNotifier::sObitRecipients ; <NEW_LINE> <START_VULN> const sp < IMediaPlayerService > & <NEW_LINE> <END_VULN> IMediaDeathNotifier::getMediaPlayerService ( ) <NEW_LINE> { <NEW_LINE> ALOGV ( "getMediaPlayerService" ) ;
} ; <NEW_LINE> chunk_list = chunks_to_ignore ; <NEW_LINE> <START_VULN> num_chunks = ( sizeof chunks_to_ignore ) / 5 ; <NEW_LINE> <END_VULN> } <NEW_LINE> else
case 0: op [ 0 ] = ( unsigned char ) ( ( v ) << 6 ) ; break ; \ <NEW_LINE> case 1: op [ 0 ] |= ( v ) << 4 ; break ; \ <NEW_LINE> case 2: op [ 0 ] |= ( v ) << 2 ; break ; \ <NEW_LINE> <START_VULN> case 3: * op ++ |= ( v ) ; break ; \ <NEW_LINE> <END_VULN> } \ <NEW_LINE> }
} <NEW_LINE> <START_VULN> static void phar_file_stat ( const char * filename , php_stat_len filename_length , int type , void ( * orig_stat_func ) ( INTERNAL_FUNCTION_PARAMETERS ) , INTERNAL_FUNCTION_PARAMETERS ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ! filename_length ) { <NEW_LINE> RETURN_FALSE ;
{ <NEW_LINE> MsgToEventLog ( M_SYSERR , TEXT ( "malloc failed" ) ) ; <NEW_LINE> ReturnLastError ( pipe , L"malloc" ) ; <NEW_LINE> <START_VULN> goto out ; <NEW_LINE> <END_VULN> } <NEW_LINE> read = ReadPipeAsync ( pipe , data , bytes , 1 , & exit_event ) ;
const AtomicString & type = event -> type ( ) ; <NEW_LINE> return type == EventTypeNames::mouseover || <NEW_LINE> <START_VULN> type == EventTypeNames::mouseout || type == EventTypeNames::mousemove ; <NEW_LINE> <END_VULN> } <NEW_LINE> Element * elementFromCenter ( Element & element ) {
<START_VULN> <NEW_LINE>void ClearUnloadState ( TabContents * tab ) ; <NEW_LINE> <END_VULN>
clearPositionedState ( ) ; <NEW_LINE> setFloating ( false ) ; <NEW_LINE> setHasOverflowClip ( false ) ; <NEW_LINE> <START_VULN> if ( oldStyle && m_scrollbar && m_part != NoPart && diff >= StyleDifferenceRepaint ) <NEW_LINE> <END_VULN> m_scrollbar -> theme ( ) -> invalidatePart ( m_scrollbar , m_part ) ; <NEW_LINE> }
SetDirectionFromNewTextNode ( this ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void nsTextNode::UnbindFromTree ( bool aDeep , bool aNullParent ) <NEW_LINE> { <NEW_LINE> <START_VULN> ResetDirectionSetByTextNode ( this ) ; <NEW_LINE> <END_VULN> nsGenericDOMDataNode::UnbindFromTree ( aDeep , aNullParent ) ; <NEW_LINE> } <NEW_LINE> #ifdef DEBUG <NEW_LINE> void <NEW_LINE> nsTextNode::List ( FILE * out , int32_t aIndent ) const <NEW_LINE> {
OMX_U32 portIndex , const sp < GraphicBuffer > & graphicBuffer , <NEW_LINE> OMX::buffer_id buffer ) { <NEW_LINE> Mutex::Autolock autoLock ( mLock ) ; <NEW_LINE> <START_VULN> OMX_BUFFERHEADERTYPE * header = findBufferHeader ( buffer ) ; <NEW_LINE> <END_VULN> return updateGraphicBufferInMeta_l ( portIndex , graphicBuffer , buffer , header ) ; <NEW_LINE> }
#include "vm / RegExpObject . h" <NEW_LINE> #include "jsscopeinlines . h" <NEW_LINE> namespace js { <NEW_LINE> inline <NEW_LINE> Bindings::Bindings ( JSContext * cx ) <NEW_LINE> <START_VULN> : lastBinding ( NULL ) , nargs ( 0 ) , nvars ( 0 ) , nupvars ( 0 ) <NEW_LINE> <END_VULN> { } <NEW_LINE> inline void <NEW_LINE> Bindings::transfer ( JSContext * cx , Bindings * bindings ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( ! lastBinding ) ; <NEW_LINE> JS_ASSERT ( ! bindings -> lastBinding || ! bindings -> lastBinding -> inDictionary ( ) ) ;
status_t resetPlugin ( ) ; <NEW_LINE> <START_VULN> void setDecodeArgs ( <NEW_LINE> <END_VULN> ivd_video_decode_ip_t * ps_dec_ip , <NEW_LINE> ivd_video_decode_op_t * ps_dec_op , <NEW_LINE> OMX_BUFFERHEADERTYPE * inHeader ,
virtual void AcceleratedSurfaceNew ( <NEW_LINE> int32 width_in_pixel , <NEW_LINE> int32 height_in_pixel , <NEW_LINE> <START_VULN> uint64 surface_id ) { } <NEW_LINE>virtual void AcceleratedSurfaceRelease ( uint64 surface_id ) { } <NEW_LINE> <END_VULN> #if defined ( TOOLKIT_GTK ) <NEW_LINE> virtual void CreatePluginContainer ( gfx::PluginWindowHandle id ) = 0 ;
#endif <NEW_LINE> entry = SetMagickInfo ( "MNG" ) ; <NEW_LINE> <START_VULN> entry -> seekable_stream = MagickTrue ; <NEW_LINE> <END_VULN> #if defined ( MAGICKCORE_PNG_DELEGATE ) <NEW_LINE> entry -> decoder = ( DecodeImageHandler * ) ReadMNGImage ;
<START_VULN> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , best_predictor , 16 * 4 ) ; <NEW_LINE>DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff , 16 ) ; <NEW_LINE> <END_VULN> int dst_stride = x -> e_mbd . dst . y_stride ; <NEW_LINE> unsigned char * dst = x -> e_mbd . dst . y_buffer + b -> offset ;
void * closure , <NEW_LINE> const char * fromSegment , <NEW_LINE> PRUint32 toOffset , <NEW_LINE> PRUint32 count , <NEW_LINE> PRUint32 * writeCount ) <NEW_LINE> { <NEW_LINE> nsStreamLoader * self = ( nsStreamLoader * ) closure ; <NEW_LINE> <START_VULN> self -> mData . Append ( fromSegment , count ) ; <NEW_LINE> <END_VULN> * writeCount = count ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsStreamLoader::OnDataAvailable ( nsIRequest * request , nsISupports * ctxt , <NEW_LINE> nsIInputStream * inStr ,
{ <NEW_LINE> const short * HFilter ; <NEW_LINE> const short * VFilter ; <NEW_LINE> <START_VULN> DECLARE_ALIGNED_ARRAY ( 4 , short , FData , 12 * 4 ) ; <NEW_LINE> <END_VULN> HFilter = vp8_sub_pel_filters [ xoffset ] ;
if ( FAILURE == phar_copy_entry_fp ( oldentry , & newentry , & error TSRMLS_CC ) ) { <NEW_LINE> efree ( newentry . filename ) ; <NEW_LINE> php_stream_close ( newentry . fp ) ; <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> return ; <NEW_LINE> }
nsCOMPtr < nsIScriptGlobalObjectOwner > globalOwner ( <NEW_LINE> do_QueryObject ( aBinding -> XBLDocumentInfo ( ) ) ) ; <NEW_LINE> nsIScriptGlobalObject * globalObject = globalOwner -> GetScriptGlobalObject ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( globalObject , NS_ERROR_UNEXPECTED ) ; <NEW_LINE> nsIScriptContext * context = globalObject -> GetContext ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( context , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> <START_VULN> JSContext * cx = context -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSObject * global = globalObject -> GetGlobalJSObject ( ) ; <NEW_LINE> JSObject * classObject ; <NEW_LINE> bool classObjectIsNew = false ; <NEW_LINE> nsresult rv = aBinding -> InitClass ( mClassName , cx , global , global , <NEW_LINE> & classObject , & classObjectIsNew ) ; <NEW_LINE> if ( NS_FAILED ( rv ) )
void dump_mm ( const struct mm_struct * mm ) <NEW_LINE> { <NEW_LINE> <START_VULN> pr_emerg ( "mm % px mmap % px seqnum % d task_size % lu\n" <NEW_LINE> <END_VULN> #ifdef CONFIG_MMU <NEW_LINE> "get_unmapped_area % px\n" <NEW_LINE> #endif
<START_VULN> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** stream ) = 0 ; <NEW_LINE> <END_VULN>
JSObject * obj = js::UncheckedUnwrap ( JSVAL_TO_OBJECT ( * vp ) ) ; <NEW_LINE> MOZ_ASSERT ( ! js::IsInnerObject ( obj ) ) ; <NEW_LINE> if ( js::IsObjectInContextCompartment ( obj , cx ) ) { <NEW_LINE> * vp = OBJECT_TO_JSVAL ( obj ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> obj = WaiveXray ( cx , obj ) ; <NEW_LINE> <END_VULN> if ( ! obj ) <NEW_LINE> return false ; <NEW_LINE> * vp = OBJECT_TO_JSVAL ( obj ) ; <NEW_LINE> return JS_WrapValue ( cx , vp ) ; <NEW_LINE> } <NEW_LINE> JSObject *
if ( ! shape -> getterValue ( ) . toObject ( ) . is < JSFunction > ( ) ) <NEW_LINE> return false ; <NEW_LINE> JSFunction & getter = shape -> getterValue ( ) . toObject ( ) . as < JSFunction > ( ) ; <NEW_LINE> if ( ! getter . isNative ( ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> if ( getter . jitInfo ( ) ) <NEW_LINE> <END_VULN> return true ; <NEW_LINE> return ! obj -> getClass ( ) -> ext . outerObject ; <NEW_LINE> } <NEW_LINE> static bool <NEW_LINE> IsCacheableGetPropCallPropertyOp ( JSObject * obj , JSObject * holder , Shape * shape )
for ( i = 0 ; i < globbuf . gl_pathc ; i ++ ) { <NEW_LINE> if ( ! checkTestFile ( globbuf . gl_pathv [ i ] ) ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> if ( ( ebcdicHandler == NULL ) && <NEW_LINE> ( strstr ( globbuf . gl_pathv [ i ] , "ebcdic" ) != NULL ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( tst -> suffix != NULL ) { <NEW_LINE> result = resultFilename ( globbuf . gl_pathv [ i ] , tst -> out ,
if ( ! pbi ) <NEW_LINE> return NULL ; <NEW_LINE> <START_VULN> vpx_memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ; <NEW_LINE> <END_VULN> if ( setjmp ( pbi -> common . error . jmp ) ) <NEW_LINE> {
} <NEW_LINE> <START_VULN> static void pack_mb_row_tokens_c ( VP8_COMP * cpi , vp8_writer * w ) <NEW_LINE> <END_VULN> { <NEW_LINE> int mb_row ;
PRUint32 Generation ( ) { return mGeneration ; } <NEW_LINE> protected: <NEW_LINE> <START_VULN> nsHTMLCanvasElement * mCanvasElement ; <NEW_LINE> <END_VULN> nsRefPtr < gl::GLContext > gl ;
bool stickDocument = mDocument != nullptr ; <NEW_LINE> child -> SendPOfflineCacheUpdateConstructor ( this , manifestURI , documentURI , <NEW_LINE> stickDocument ) ; <NEW_LINE> <START_VULN> mIPCActivated = true ; <NEW_LINE>this -> AddRef ( ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> OfflineCacheUpdateChild::RecvAssociateDocuments ( const nsCString & cacheGroupId , <NEW_LINE> const nsCString & cacheClientId ) <NEW_LINE> {
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestEventTarget::s_info ) ; <NEW_LINE> TestEventTarget * impl = static_cast < TestEventTarget * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> int index ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . toUInt32 ( exec ) ) ; <NEW_LINE> if ( index < 0 ) { <NEW_LINE> setDOMException ( exec , INDEX_SIZE_ERR ) ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsUTF16BEToUnicode::Convert ( const char * aSrc , PRInt32 * aSrcLength , <NEW_LINE> PRUnichar * aDest , PRInt32 * aDestLength ) <NEW_LINE> { <NEW_LINE> #ifdef IS_LITTLE_ENDIAN <NEW_LINE> if ( STATE_FIRST_CALL == mState ) <NEW_LINE> { <NEW_LINE> mState = STATE_NORMAL ; <NEW_LINE> <START_VULN> if ( * aSrcLength < 2 ) <NEW_LINE>return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> <END_VULN> if ( 0xFFFE == * ( ( PRUnichar * ) aSrc ) ) { <NEW_LINE> mState = STATE_FOUND_BOM ; <NEW_LINE> } else if ( 0xFEFF == * ( ( PRUnichar * ) aSrc ) ) { <NEW_LINE> * aSrcLength = 0 ; <NEW_LINE> * aDestLength = 0 ; <NEW_LINE> return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> }
#define PT ITSTRUCT ( end ) <NEW_LINE> <START_VULN> static void <NEW_LINE>image_transform_default_ini ( PNG_CONST image_transform * this , <NEW_LINE> <END_VULN> transform_display * that ) <NEW_LINE> { <NEW_LINE> this -> next -> ini ( this -> next , that ) ;
sa = sarrayCreate ( 0 ) ; <NEW_LINE> sarrayAddString ( sa , ( char * ) "
prevSibLine = lineList -> begin ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> prevSibLine -> NoteFrameAdded ( newFrame ) ; <NEW_LINE> <START_VULN> MarkLineDirty ( prevSibLine ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> aPrevSibling = newFrame ; <NEW_LINE> } <NEW_LINE> #ifdef DEBUG <NEW_LINE> VerifyLines ( true ) ; <NEW_LINE> #endif
Erase the contents of a string <NEW_LINE> @param str String to erase <NEW_LINE> @ingroup MprString <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC void serase ( char * str ) ;
static vpx_codec_err_t vp8_set_reference ( vpx_codec_alg_priv_t * ctx , <NEW_LINE> <START_VULN> int ctr_id , <NEW_LINE>va_list args ) <NEW_LINE> <END_VULN> { <NEW_LINE> vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ;
cpi -> common . MBs ) ) ; <NEW_LINE> <START_VULN> vpx_memcpy ( sortlist , cpi -> mb_activity_map , <NEW_LINE>sizeof ( unsigned int ) * cpi -> common . MBs ) ; <NEW_LINE> <END_VULN>
void RenderBox::computeLogicalWidthInRegion ( RenderRegion * region , LayoutUnit offsetFromLogicalTopOfFirstPage ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( isPositioned ( ) ) { <NEW_LINE> <END_VULN> computePositionedLogicalWidth ( region , offsetFromLogicalTopOfFirstPage ) ;
#include "vpx / vpx_codec . h" <NEW_LINE> <START_VULN> static const char * const cfg = " -- target = mips32 - linux - gcc -- disable - dspr2 -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
temp = UCH ( * bufferptr ++ ) << 8 ; <NEW_LINE> temp |= UCH ( * bufferptr ++ ) ; <NEW_LINE> if ( temp > maxval ) <NEW_LINE> <START_VULN> ERREXIT ( cinfo , JERR_PPM_TOOLARGE ) ; <NEW_LINE> <END_VULN> * ptr ++ = rescale [ temp ] ; <NEW_LINE> } <NEW_LINE> return 1 ;
static int64_t HHVM_FUNCTION ( bccomp , const String & left , const String & right , <NEW_LINE> int64_t scale ) { <NEW_LINE> <START_VULN> if ( scale < 0 ) scale = BCG ( bc_precision ) ; <NEW_LINE> <END_VULN> bc_num first , second ; <NEW_LINE> bc_init_num ( & first ) ; <NEW_LINE> bc_init_num ( & second ) ;
va_end ( ap ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) { <NEW_LINE> <END_VULN> FILE * f = input_ctx -> file ; <NEW_LINE> y4m_input * y4m = & input_ctx -> y4m ; <NEW_LINE> int shortread = 0 ;
if ( oldcode == - 1 ) { <NEW_LINE> if ( code >= MAX_BITS ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> * rowp ++ = suffix [ code ] ; <NEW_LINE> <END_VULN> if ( rowp == rowend ) <NEW_LINE> OUTPUT_ROW ( ) ;
char name [ FILE_NAME_SIZE ] ; <NEW_LINE> <START_VULN> PNG_CONST png_uint_32 id = FILEID ( colour_type , bit_depth , 0 , <NEW_LINE> <END_VULN> interlace_type , w , h , do_interlace ) ; <NEW_LINE> standard_name_from_id ( name , sizeof name , 0 , id ) ;
js_TraceScript ( trc , script ) ; <NEW_LINE> } <NEW_LINE> #if ! JS_HAS_SCRIPT_OBJECT <NEW_LINE> #define JSProto_Script JSProto_Object <NEW_LINE> #endif <NEW_LINE> JS_FRIEND_DATA ( JSClass ) js_ScriptClass = { <NEW_LINE> js_Script_str , <NEW_LINE> <START_VULN> JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS ( 1 ) | <NEW_LINE> <END_VULN> JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO ( JSProto_Script ) , <NEW_LINE> JS_PropertyStub , JS_PropertyStub , JS_PropertyStub , JS_PropertyStub , <NEW_LINE> JS_EnumerateStub , JS_ResolveStub , JS_ConvertStub , script_finalize , <NEW_LINE> NULL , NULL , script_call , NULL , <NEW_LINE> NULL , NULL , JS_CLASS_TRACE ( script_trace ) , NULL <NEW_LINE> } ; <NEW_LINE> #if JS_HAS_SCRIPT_OBJECT
bool AXLayoutObject::supportsARIADragging ( ) const { <NEW_LINE> const AtomicString & grabbed = getAttribute ( aria_grabbedAttr ) ; <NEW_LINE> <START_VULN> return equalIgnoringCase ( grabbed , "true" ) || <NEW_LINE>equalIgnoringCase ( grabbed , "false" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool AXLayoutObject::supportsARIADropping ( ) const {
if ( Name != NULL ) { <NEW_LINE> <START_VULN> strncpy ( NamedColorList -> List [ NamedColorList -> nColors ] . Name , Name , <NEW_LINE>sizeof ( NamedColorList -> List [ NamedColorList -> nColors ] . Name ) ) ; <NEW_LINE><NEW_LINE> <END_VULN> NamedColorList -> List [ NamedColorList -> nColors ] . Name [ cmsMAX_PATH - 1 ] = 0 ; <NEW_LINE> }
friend struct nsTreeRange ; <NEW_LINE> protected: <NEW_LINE> nsresult FireOnSelectHandler ( ) ; <NEW_LINE> static void SelectCallback ( nsITimer * aTimer , void * aClosure ) ; <NEW_LINE> protected: <NEW_LINE> <START_VULN> nsITreeBoxObject * mTree ; <NEW_LINE> <END_VULN> PRBool mSuppressed ; <NEW_LINE> PRInt32 mCurrentIndex ; <NEW_LINE> nsCOMPtr < nsITreeColumn > mCurrentColumn ; <NEW_LINE> PRInt32 mShiftSelectPivot ; <NEW_LINE> nsTreeRange * mFirstRange ;
} <NEW_LINE> s ++ ; <NEW_LINE> ptmp = tmp ; <NEW_LINE> <START_VULN> while ( * s && * s != '\"' ) <NEW_LINE> <END_VULN> * ptmp ++ = * s ++ ; <NEW_LINE> if ( * s != '\"' ) <NEW_LINE> return - 1 ;
} <NEW_LINE> <START_VULN> void DidFocus ( ) override { did_focus_called_ = true ; } <NEW_LINE> <END_VULN> bool DidFocusCalled ( ) const { return did_focus_called_ ; } <NEW_LINE> WebView * CreatedWebView ( ) const { return web_view_helper_ . GetWebView ( ) ; }
m_webPage -> m_inputHandler -> clearDidSpellCheckState ( ) ; <NEW_LINE> <START_VULN> PlatformMouseEvent mouseEvent ( point . m_pos , m_lastScreenPoint , PlatformEvent::MouseMoved , 1 , LeftButton , shiftActive , ctrlActive , altActive , TouchScreen ) ; <NEW_LINE>m_lastScreenPoint = point . m_screenPos ; <NEW_LINE> <END_VULN> m_webPage -> handleMouseEvent ( mouseEvent ) ; <NEW_LINE> break ; <NEW_LINE> }
if ( * argrest != 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> uschar * hn = Ustrchr ( argrest , ':' ) ; <NEW_LINE> <END_VULN> if ( hn == NULL ) <NEW_LINE> { <NEW_LINE> received_protocol = argrest ;
for ( i = 0 ; i < cmap_entries ; ++ i ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( do_background && i < num_trans && trans [ i ] < 255 ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( trans [ i ] == 0 ) <NEW_LINE> png_create_colormap_entry ( display , i , back_r , back_g ,
if ( err ) { <NEW_LINE> ERROR ( midi , " % s: couldn't enqueue request: % d\n" , <NEW_LINE> midi -> out_ep -> name , err ) ; <NEW_LINE> <START_VULN> free_ep_req ( midi -> out_ep , req ) ; <NEW_LINE> <END_VULN> return err ; <NEW_LINE> } <NEW_LINE> }
if ( mode_ == kFile ) { <NEW_LINE> if ( cluster_list_size_ > 0 ) { <NEW_LINE> <START_VULN> Cluster * const old_cluster = cluster_list_ [ cluster_list_size_ - 1 ] ; <NEW_LINE> <END_VULN> if ( ! old_cluster || ! old_cluster -> Finalize ( ) ) <NEW_LINE> return false ;
int32_t bufferSize = inHeader -> nFilledLen ; <NEW_LINE> int32_t tmp = bufferSize ; <NEW_LINE> <START_VULN> OMX_U32 frameSize = ( mWidth * mHeight * 3 ) / 2 ; <NEW_LINE> <END_VULN> if ( outHeader -> nAllocLen < frameSize ) { <NEW_LINE> android_errorWriteLog ( 0x534e4554 , "27833616" ) ; <NEW_LINE> ALOGE ( "Insufficient output buffer size" ) ;
for ( i = 0 ; i < 3 ; i ++ ) { <NEW_LINE> ff_free_vlc ( & s -> vlc [ i ] ) ; <NEW_LINE> <START_VULN> init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , <NEW_LINE>s -> bits [ i ] , 4 , 4 , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> generate_joint_tables ( s ) ;
tptr = tmpbuf ; <NEW_LINE> for ( bit = 0 , byte = 0 ; bit < ( unsigned char ) MagickMin ( 8 , ( ssize_t ) bytes_per_row - x ) ; bit ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ( y == 0 ) || ( lastrow [ x + bit ] != one_row [ x + bit ] ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> byte |= ( 1 << ( 7 - bit ) ) ; <NEW_LINE> * tptr ++ = ( char ) one_row [ x + bit ] ;
if ( ++ mInvalidateCount > kCanvasMaxInvalidateCount ) <NEW_LINE> return Redraw ( ) ; <NEW_LINE> <START_VULN> mCanvasElement -> InvalidateFrame ( & r ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> }
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . overloadedMethod4" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( int , intArg , toInt32 ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> imp -> overloadedMethod ( intArg ) ;
OggPlayErrorCode <NEW_LINE> oggplay_data_handle_cmml_data ( OggPlayDecode * decode , <NEW_LINE> unsigned char * data , <NEW_LINE> long size ) { <NEW_LINE> OggPlayTextRecord * record = NULL ; <NEW_LINE> size_t record_size = sizeof ( OggPlayTextRecord ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( ( size < 0 ) || ( size + 1 < 0 ) ) { <NEW_LINE>return E_OGGPLAY_TYPE_OVERFLOW ; <NEW_LINE> } <NEW_LINE>size += 1 ; <NEW_LINE><NEW_LINE> <END_VULN> if <NEW_LINE> ( <NEW_LINE> oggplay_check_add_overflow ( record_size , size , & record_size ) <NEW_LINE> == <NEW_LINE> E_OGGPLAY_TYPE_OVERFLOW <NEW_LINE> ) <NEW_LINE> { <NEW_LINE> return E_OGGPLAY_TYPE_OVERFLOW ;
} <NEW_LINE> mflags = add_required_remount_flags ( source , destination , <NEW_LINE> default_mounts [ i ] . flags ) ; <NEW_LINE> <START_VULN> r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ; <NEW_LINE> <END_VULN> saved_errno = errno ; <NEW_LINE> if ( r < 0 && errno == ENOENT ) { <NEW_LINE> INFO ( "Mount source or target for % s on % s doesn't exist . Skipping . " , source , destination ) ;
seg -> enabled = 0 ; <NEW_LINE> seg -> update_map = 0 ; <NEW_LINE> seg -> update_data = 0 ; <NEW_LINE> <START_VULN> vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ; <NEW_LINE> <END_VULN> vp9_clearall_segfeatures ( seg ) ; <NEW_LINE> }
#define VP9_COMMON_VP9_ENTROPYMV_H_ <NEW_LINE> #include " . / vpx_config . h" <NEW_LINE> <START_VULN> #include "vp9 / common / vp9_blockd . h" <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> extern "C" {
} <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> void PNGAPI <NEW_LINE> png_read_row ( png_structrp png_ptr , png_bytep row , png_bytep dsp_row )
<START_VULN> struct inode * isofs_iget ( struct super_block * sb , <NEW_LINE>unsigned long block , <NEW_LINE>unsigned long offset ) <NEW_LINE> <END_VULN> { <NEW_LINE> unsigned long hashval ; <NEW_LINE> struct inode * inode ;
static void copyIPv6IfDifferent ( void * dest , const void * src ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( dest != src ) { <NEW_LINE> <END_VULN> memcpy ( dest , src , sizeof ( struct in6_addr ) ) ; <NEW_LINE> } <NEW_LINE> }
else <NEW_LINE> xmlParseEndTag1 ( ctxt , 0 ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> if ( ctxt -> nameNr == 0 ) { <NEW_LINE> <END_VULN> ctxt -> instate = XML_PARSER_EPILOG ; <NEW_LINE> } else { <NEW_LINE> ctxt -> instate = XML_PARSER_CONTENT ;
} <NEW_LINE> nsresult <NEW_LINE> nsXMLHttpRequest::CreateResponseParsedJSON ( JSContext * aCx ) <NEW_LINE> { <NEW_LINE> if ( ! aCx ) { <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> <START_VULN> RootResultArrayBuffer ( ) ; <NEW_LINE> <END_VULN> if ( ! JS_ParseJSON ( aCx , <NEW_LINE> static_cast < const jschar * > ( mResponseText . get ( ) ) , <NEW_LINE> mResponseText . Length ( ) , & mResultJSON ) ) { <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> }
{ <NEW_LINE> for ( i = 0 ; i < 8 ; i ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memcpy ( upred_ptr , uabove_row , 8 ) ; <NEW_LINE>vpx_memcpy ( vpred_ptr , vabove_row , 8 ) ; <NEW_LINE> <END_VULN> upred_ptr += pred_stride ; <NEW_LINE> vpred_ptr += pred_stride ; <NEW_LINE> }
#ifdef ZEND_WIN32 <NEW_LINE> <START_VULN> static inline zend_ulong realpath_cache_key ( const char * path , int path_len ) <NEW_LINE> <END_VULN> { <NEW_LINE> register zend_ulong h ; <NEW_LINE> char * bucket_key_start = tsrm_win32_get_path_sid_key ( path ) ;
{ <NEW_LINE> nsGlobalWindow * win = nsGlobalWindow::FromWrapper ( wrapper ) ; <NEW_LINE> <START_VULN> if ( win -> IsInnerWindow ( ) ) { <NEW_LINE><NEW_LINE> <END_VULN> * _retval = obj ; <NEW_LINE> } else {
void removeWrapper ( js::WrapperMap::Ptr p ) { <NEW_LINE> crossCompartmentWrappers . remove ( p ) ; <NEW_LINE> } <NEW_LINE> struct WrapperEnum : public js::WrapperMap::Enum { <NEW_LINE> WrapperEnum ( JSCompartment * c ) : js::WrapperMap::Enum ( c -> crossCompartmentWrappers ) { } <NEW_LINE> } ; <NEW_LINE> <START_VULN> void mark ( JSTracer * trc ) ; <NEW_LINE> <END_VULN> bool isDiscardingJitCode ( JSTracer * trc ) ; <NEW_LINE> void sweep ( js::FreeOp * fop , bool releaseTypes ) ; <NEW_LINE> void sweepCrossCompartmentWrappers ( ) ; <NEW_LINE> void purge ( ) ; <NEW_LINE> void clearTables ( ) ; <NEW_LINE> bool hasObjectMetadataCallback ( ) const { return objectMetadataCallback ; } <NEW_LINE> void setObjectMetadataCallback ( js::ObjectMetadataCallback callback ) ;
mShiftSelectPivot = - 1 ; <NEW_LINE> delete mFirstRange ; <NEW_LINE> mFirstRange = new nsTreeRange ( this , 0 , rowCount - 1 ) ; <NEW_LINE> <START_VULN> mFirstRange -> Invalidate ( ) ; <NEW_LINE> <END_VULN> FireOnSelectHandler ( ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsTreeSelection::GetRangeCount ( PRInt32 * aResult ) <NEW_LINE> {
buffer_caret = 0 ; <NEW_LINE> while ( bitmap_caret < image_block_size ) { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ( decompression_buffer [ buffer_caret ] & TGA_RLE_FLAG ) == TGA_RLE_FLAG ) { <NEW_LINE> encoded_pixels = ( ( decompression_buffer [ buffer_caret ] & ~ TGA_RLE_FLAG ) + 1 ) ; <NEW_LINE> buffer_caret ++ ;
if ( header_status > 0 ) <NEW_LINE> return E_BUFFER_NOT_FULL ; <NEW_LINE> <START_VULN> assert ( m_pInfo ) ; <NEW_LINE>assert ( m_pTracks ) ; <NEW_LINE> <END_VULN> for ( ; ; ) { <NEW_LINE> const int status = LoadCluster ( ) ;
FLOATING_POINT_INIT ( ) ; <NEW_LINE> if ( num_enc == 1 ) <NEW_LINE> <START_VULN> res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <NEW_LINE> <END_VULN> duration , flags , deadline ) ; <NEW_LINE> else {
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> }
JSObject * method = ::JS_CloneFunctionObject ( aCx , mJSMethodObject , globalObject ) ; <NEW_LINE> if ( ! method ) { <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE> if ( ! ::JS_DefineUCProperty ( aCx , aTargetClassObject , <NEW_LINE> static_cast < const jschar * > ( mName ) , <NEW_LINE> name . Length ( ) , OBJECT_TO_JSVAL ( method ) , <NEW_LINE> <START_VULN> NULL , NULL , JSPROP_ENUMERATE ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsXBLProtoImplMethod::CompileMember ( nsIScriptContext * aContext , const nsCString & aClassStr ,
* <NEW_LINE> #ifdef DEBUG <NEW_LINE> <START_VULN> static const char CVS_ID [ ] = "@ ( # ) $ RCSfile: certdata . c , v $ $ Revision: 1 . 67 $ $ Date: 2010 / 04 / 08 14:28:58 $ "" ; @ ( # ) $ RCSfile: certdata . c , v $ $ Revision: 1 . 67 $ $ Date: 2010 / 04 / 08 14:28:58 $ " ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifndef BUILTINS_H <NEW_LINE> #include "builtins . h" <NEW_LINE> #endif <NEW_LINE> static const CK_BBOOL ck_false = CK_FALSE ; <NEW_LINE> static const CK_BBOOL ck_true = CK_TRUE ;
size_t <NEW_LINE> <START_VULN> js_GetDeflatedUTF8StringLength ( JSContext * cx , const jschar * chars , <NEW_LINE>size_t nchars , bool useCESU8 ) <NEW_LINE> <END_VULN> { <NEW_LINE> size_t nbytes ; <NEW_LINE> const jschar * end ;
REGISTER_LONG_CONSTANT ( "IMG_CROP_SIDES" , GD_CROP_SIDES , CONST_CS | CONST_PERSISTENT ) ; <NEW_LINE> REGISTER_LONG_CONSTANT ( "IMG_CROP_THRESHOLD" , GD_CROP_THRESHOLD , CONST_CS | CONST_PERSISTENT ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> REGISTER_LONG_CONSTANT ( "IMG_BELL" , GD_BELL , CONST_CS | CONST_PERSISTENT ) ; <NEW_LINE> REGISTER_LONG_CONSTANT ( "IMG_BESSEL" , GD_BESSEL , CONST_CS | CONST_PERSISTENT ) ; <NEW_LINE> REGISTER_LONG_CONSTANT ( "IMG_BILINEAR_FIXED" , GD_BILINEAR_FIXED , CONST_CS | CONST_PERSISTENT ) ;
LayoutUnit availableHeight ; <NEW_LINE> <START_VULN> if ( isPositioned ( ) ) <NEW_LINE> <END_VULN> availableHeight = containingBlockLogicalHeightForPositioned ( toRenderBoxModelObject ( cb ) ) ; <NEW_LINE> else { <NEW_LINE> availableHeight = toRenderBox ( cb ) -> availableLogicalHeight ( ) ;
* aIsNullPrincipal = false ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsPrincipal::GetBaseDomain ( nsACString & aBaseDomain ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( URIIsLocalFile ( mCodebase ) ) { <NEW_LINE> <END_VULN> nsCOMPtr < nsIURL > url = do_QueryInterface ( mCodebase ) ; <NEW_LINE> if ( url ) { <NEW_LINE> return url -> GetFilePath ( aBaseDomain ) ; <NEW_LINE> } <NEW_LINE> }
break ; <NEW_LINE> } <NEW_LINE> <START_VULN> convert_to_long_ex ( item ) ; <NEW_LINE><NEW_LINE>stylearr [ index ++ ] = Z_LVAL_PP ( item ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> gdImageSetStyle ( im , stylearr , index ) ;
if ( ! ( ppm -> data = jas_malloc ( ppm -> len ) ) ) { <NEW_LINE> goto error ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( JAS_CAST ( uint , jas_stream_read ( in , ppm -> data , ppm -> len ) ) != ppm -> len ) { <NEW_LINE> <END_VULN> goto error ; <NEW_LINE> } <NEW_LINE> } else {
#include "base / basictypes . h" <NEW_LINE> #include "base / compiler_specific . h" <NEW_LINE> #include "base / memory / scoped_ptr . h" <NEW_LINE> <START_VULN> #include "components / dom_distiller / content / browser / external_feedback_reporter . h" <NEW_LINE> <END_VULN> #include "content / public / browser / url_data_source . h" <NEW_LINE> namespace dom_distiller {
sock -> _wreq . bufs = sock -> _wreq . smallbufs ; <NEW_LINE> } else { <NEW_LINE> sock -> _wreq . bufs = h2o_mem_alloc ( sizeof ( h2o_iovec_t ) * bufcnt ) ; <NEW_LINE> <START_VULN> sock -> _wreq . alloced_ptr = sock -> _wreq . bufs = sock -> _wreq . bufs ; <NEW_LINE> <END_VULN> } <NEW_LINE> memcpy ( sock -> _wreq . bufs , bufs , sizeof ( h2o_iovec_t ) * bufcnt ) ; <NEW_LINE> sock -> _wreq . cnt = bufcnt ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . strictFunction" ) ; <NEW_LINE> if ( args . Length ( ) < 3 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> ExceptionCode ec = 0 ; <NEW_LINE> {
. open = ftrace_filter_open , <NEW_LINE> . read = seq_read , <NEW_LINE> . write = ftrace_filter_write , <NEW_LINE> <START_VULN> . llseek = ftrace_regex_lseek , <NEW_LINE> <END_VULN> . release = ftrace_regex_release , <NEW_LINE> } ;
#pragma once <NEW_LINE> #include "base / compiler_specific . h" <NEW_LINE> <START_VULN> #include "chrome / browser / autocomplete / autocomplete . h" <NEW_LINE> <END_VULN>
GlyphCache::GlyphCache ( const Face & face , const uint32 face_options ) <NEW_LINE> <START_VULN> : _glyph_loader ( new Loader ( face , bool ( face_options & gr_face_dumbRendering ) ) ) , <NEW_LINE> <END_VULN> _glyphs ( _glyph_loader && * _glyph_loader && _glyph_loader -> num_glyphs ( ) <NEW_LINE> ? grzeroalloc < const GlyphFace * > ( _glyph_loader -> num_glyphs ( ) ) : 0 ) , <NEW_LINE> _boxes ( _glyph_loader && _glyph_loader -> has_boxes ( ) && _glyph_loader -> num_glyphs ( )
static BOOL <NEW_LINE> IsStatusApplying ( LPCWSTR updateDirPath , BOOL & isApplying ) <NEW_LINE> { <NEW_LINE> isApplying = FALSE ; <NEW_LINE> <START_VULN> WCHAR updateStatusFilePath [ MAX_PATH + 1 ] ; <NEW_LINE>wcscpy ( updateStatusFilePath , updateDirPath ) ; <NEW_LINE> <END_VULN> if ( ! PathAppendSafe ( updateStatusFilePath , L"update . status" ) ) { <NEW_LINE> LOG_WARN ( ( "Could not append path for update . status file" ) ) ; <NEW_LINE> return FALSE ; <NEW_LINE> } <NEW_LINE> nsAutoHandle statusFile ( CreateFileW ( updateStatusFilePath , GENERIC_READ , <NEW_LINE> FILE_SHARE_READ | <NEW_LINE> FILE_SHARE_WRITE |
hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { <NEW_LINE> if ( perf_swevent_match ( event , type , event_id , data , regs ) ) <NEW_LINE> <START_VULN> perf_swevent_event ( event , nr , nmi , data , regs ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> end: <NEW_LINE> rcu_read_unlock ( ) ;
( newLineOffset will remain - 1 ) , but we will still cache it in mContent <NEW_LINE> newLineOffset = contentNewLineOffset ; <NEW_LINE> } <NEW_LINE> if ( newLineOffset >= 0 ) { <NEW_LINE> length = newLineOffset + 1 - offset ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> if ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) { <NEW_LINE> <END_VULN> int32_t skipLength = newLineOffset >= 0 ? length - 1 : length ; <NEW_LINE> int32_t whitespaceCount = <NEW_LINE> GetTrimmableWhitespaceCount ( frag , offset , skipLength , 1 ) ; <NEW_LINE> offset += whitespaceCount ; <NEW_LINE> length - = whitespaceCount ; <NEW_LINE> }
VideoCodec codec ; <NEW_LINE> VideoCodecProfile profile ; <NEW_LINE> int level ; <NEW_LINE> <START_VULN> gfx::ColorSpace::TransferID eotf ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> struct MEDIA_EXPORT KeySystemInfoForUMA {
if ( oldHeight > newHeight && maxFloatLogicalBottom > newHeight && ! childrenInline ( ) ) { <NEW_LINE> for ( RenderObject * child = firstChild ( ) ; child ; child = child -> nextSibling ( ) ) { <NEW_LINE> <START_VULN> if ( child -> isBlockFlow ( ) && ! child -> isFloatingOrPositioned ( ) ) { <NEW_LINE> <END_VULN> RenderBlock * block = toRenderBlock ( child ) ; <NEW_LINE> if ( block -> lowestFloatLogicalBottom ( ) + block -> logicalTop ( ) > newHeight ) <NEW_LINE> addOverhangingFloats ( block , false ) ;
websError ( wp , HTTP_CODE_BAD_REQUEST | WEBS_CLOSE | WEBS_NOLOG , "Bad URL" ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ( wp -> path = websNormalizeUriPath ( path ) ) == 0 ) { <NEW_LINE> <END_VULN> error ( "Cannot normalize URL: % s" , url ) ; <NEW_LINE> websError ( wp , HTTP_CODE_BAD_REQUEST | WEBS_CLOSE | WEBS_NOLOG , "Bad URL" ) ; <NEW_LINE> wfree ( buf ) ;
} <NEW_LINE> void AutoplayUmaHelper::maybeStartRecordingMutedVideoPlayMethodBecomeVisible ( ) { <NEW_LINE> <START_VULN> if ( m_source != AutoplaySource::Method || ! m_element -> isHTMLVideoElement ( ) || <NEW_LINE> ! m_element -> muted ( ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> m_mutedVideoPlayMethodVisibilityObserver = new ElementVisibilityObserver (
case EFFECT_CMD_SET_CONFIG: <NEW_LINE> <START_VULN> if ( pCmdData == NULL || <NEW_LINE>cmdSize != sizeof ( effect_config_t ) || <NEW_LINE>pReplyData == NULL || <NEW_LINE> * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Effect_command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_SET_CONFIG: ERROR" ) ; <NEW_LINE> return - EINVAL ;
return ebml_size ; <NEW_LINE> } <NEW_LINE> <START_VULN> uint64 EbmlElementSize ( uint64 type , float ) { <NEW_LINE> <END_VULN> uint64 ebml_size = GetUIntSize ( type ) ;
{ <NEW_LINE> INC_STATS ( "DOM . WebKitMutationObserver . observe" ) ; <NEW_LINE> if ( args . Length ( ) < 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> WebKitMutationObserver * imp = V8WebKitMutationObserver::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( Node * , target , V8Node::HasInstance ( args [ 0 ] ) ? V8Node::toNative ( v8::Handle < v8::Object > ::Cast ( args [ 0 ] ) ) : 0 ) ;
either version 2 of the License or ( at your option ) any later version . <NEW_LINE> #pragma once <NEW_LINE> #include "graphite2 / Types . h" <NEW_LINE> #define GR2_VERSION_MAJOR 1 <NEW_LINE> #define GR2_VERSION_MINOR 1 <NEW_LINE> <START_VULN> #define GR2_VERSION_BUGFIX 2 <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> extern "C" <NEW_LINE> { <NEW_LINE> #endif <NEW_LINE> typedef struct gr_face gr_face ; <NEW_LINE> typedef struct gr_font gr_font ;
jas_stream_putc2 ( stream , c ) ) : EOF ) <NEW_LINE> #define jas_stream_putc2 ( stream , c ) \ <NEW_LINE> ( ( ( stream ) -> bufmode_ |= JAS_STREAM_WRBUF , -- ( stream ) -> cnt_ < 0 ) ? \ <NEW_LINE> <START_VULN> jas_stream_flushbuf ( ( stream ) , ( uchar ) ( c ) ) : \ <NEW_LINE> <END_VULN> ( ++ ( stream ) -> rwcnt_ , ( int ) ( * ( stream ) -> ptr_ ++ = ( c ) ) ) )
return JS_FALSE ; <NEW_LINE> JS_ASSERT ( start == MAXINDEX ) ; <NEW_LINE> jsval tmp [ 2 ] = { JSVAL_NULL , JSVAL_NULL } ; <NEW_LINE> jsdouble * dp = js_NewWeaklyRootedDouble ( cx , MAXINDEX ) ; <NEW_LINE> if ( ! dp ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> tmp [ 0 ] = DOUBLE_TO_JSVAL ( dp ) ; <NEW_LINE> <START_VULN> JSAutoTempValueRooter ( cx , JS_ARRAY_LENGTH ( tmp ) , tmp ) ; <NEW_LINE> <END_VULN> JSAutoTempIdRooter idr ( cx ) ; <NEW_LINE> do { <NEW_LINE> tmp [ 1 ] = * vector ++ ; <NEW_LINE> if ( ! js_ValueToStringId ( cx , tmp [ 0 ] , idr . addr ( ) ) || <NEW_LINE> ! obj -> setProperty ( cx , idr . id ( ) , & tmp [ 1 ] ) ) { <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> * dp += 1 ;
buffer = ( unsigned char * ) AcquireQuantumMemory ( 512 , sizeof ( * buffer ) ) ; <NEW_LINE> if ( buffer == ( unsigned char * ) NULL ) <NEW_LINE> ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <START_VULN> packet_size = ( size_t ) ( image -> depth > 8 ? 2: 1 ) ; <NEW_LINE> <END_VULN> scanline = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , packet_size * <NEW_LINE> sizeof ( * scanline ) ) ; <NEW_LINE> if ( scanline == ( unsigned char * ) NULL )
pixmap . bits_per_pixel = 32 ; <NEW_LINE> pixmap . pack_type = 0x04 ; <NEW_LINE> transfer_mode = 0x40 ; <NEW_LINE> <START_VULN> row_bytes = ( unsigned short ) ( ( 4 * image -> columns ) | 0x8000 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> Allocate memory .
{ 12 , 3 , 3 } , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static const vp9_prob default_partition_probs [ PARTITION_CONTEXTS ] <NEW_LINE> <END_VULN> [ PARTITION_TYPES - 1 ] = { <NEW_LINE> { 199 , 122 , 141 } ,
pixels = ( const unsigned char * ) ReadBlobStream ( image , length , <NEW_LINE> GetQuantumPixels ( quantum_info ) , & count ) ; <NEW_LINE> if ( count != ( ssize_t ) length ) <NEW_LINE> <START_VULN> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; <NEW_LINE> <END_VULN> ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , <NEW_LINE> quantum_type , pixels , exception ) ; <NEW_LINE> ( void ) ReadBlobStream ( image , ( size_t ) ( - ( ssize_t ) length ) & 0x01 ,
#define png_zTXt PNG_U32 ( 122 , 84 , 88 , 116 ) <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #define sig1 PNG_U32 ( 137 , 80 , 78 , 71 ) <NEW_LINE> #define sig2 PNG_U32 ( 13 , 10 , 26 , 10 )
<START_VULN> if ( gfxPlatformMac::GetPlatform ( ) -> OSXVersion ( ) >= MAC_OS_X_VERSION_10_5_HEX ) { <NEW_LINE>realGuessMax = PR_MIN ( 500 , realGuessMax ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> return realGuessMax ; <NEW_LINE> }
* result = XPCNativeWrapper::GetNewOrUsed ( cx , parent_wrapper , nsnull ) ; <NEW_LINE> if ( ! * result ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return JS_TRUE ; <NEW_LINE> } <NEW_LINE> <START_VULN> static JSBool <NEW_LINE> <END_VULN> XPCNativeWrapperCtor ( JSContext * cx , JSObject * obj , uintN argc , jsval * argv , <NEW_LINE> jsval * rval ) <NEW_LINE> { <NEW_LINE> if ( argc < 1 ) { <NEW_LINE> return ThrowException ( NS_ERROR_XPC_NOT_ENOUGH_ARGS , cx ) ; <NEW_LINE> }
{ <NEW_LINE> while ( ! resolver . position ( ) . atEnd ( ) && ! requiresLineBox ( resolver . position ( ) , lineInfo , LeadingWhitespace ) ) { <NEW_LINE> RenderObject * object = resolver . position ( ) . m_obj ; <NEW_LINE> <START_VULN> if ( object -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> setStaticPositions ( m_block , toRenderBox ( object ) ) ; <NEW_LINE> if ( object -> style ( ) -> isOriginalDisplayInlineType ( ) ) { <NEW_LINE> resolver . runs ( ) . addRun ( createRun ( 0 , 1 , object , resolver ) ) ;
mpls_print ( ndo , p , l2info . length ) ; <NEW_LINE> return l2info . header_len ; <NEW_LINE> case JUNIPER_LSQ_L3_PROTO_ISO: <NEW_LINE> <START_VULN> isoclns_print ( ndo , p , l2info . length , l2info . caplen ) ; <NEW_LINE> <END_VULN> return l2info . header_len ; <NEW_LINE> default: <NEW_LINE> break ;
#include < atlcom . h > <NEW_LINE> #include < string > <NEW_LINE> <START_VULN> #include "base / callback . h" <NEW_LINE> <END_VULN> #include "base / threading / platform_thread . h" <NEW_LINE> #include "net / base / net_errors . h" <NEW_LINE> #include "net / http / http_response_headers . h"
domains = 0 ; <NEW_LINE> age = 0 ; <NEW_LINE> for ( option = stok ( sclone ( rest ) , " \t" , & tok ) ; option ; option = stok ( 0 , " \t" , & tok ) ) { <NEW_LINE> <START_VULN> option = stok ( option , " = \t , " , & ovalue ) ; <NEW_LINE> <END_VULN> ovalue = strim ( ovalue , "\"'" , MPR_TRIM_BOTH ) ; <NEW_LINE> if ( smatch ( option , "age" ) ) { <NEW_LINE> age = sfmt ( " % lld" , ( int64 ) httpGetTicks ( ovalue ) ) ;
} else { <NEW_LINE> spe_cp = uni_cp ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> written_k2 = write_octet_sequence ( & key [ written_k1 ] , charset , spe_cp ) ; <NEW_LINE> memcpy ( & entity [ 1 ] , mcpr [ i ] . normal_entry . entity , l ) ; <NEW_LINE> entity [ l + 1 ] = ' ; ' ;
return verify_vc_allocation ( vcs . v_active ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int verify_vc_kbmode ( int fd ) { <NEW_LINE>int curr_mode ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( ioctl ( fd , KDGKBMODE , & curr_mode ) < 0 ) <NEW_LINE>return - errno ; <NEW_LINE><NEW_LINE>return IN_SET ( curr_mode , K_XLATE , K_UNICODE ) ? 0 : - EBUSY ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> static int toggle_utf8 ( const char * name , int fd , bool utf8 ) { <NEW_LINE> int r ; <NEW_LINE> struct termios tc = { } ; <NEW_LINE> assert ( name ) ; <NEW_LINE> r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ; <NEW_LINE> if ( r < 0 ) <NEW_LINE> return log_warning_errno ( errno , "Failed to % s UTF - 8 kbdmode on % s: % m" , enable_disable ( utf8 ) , name ) ;
HeapObjectHeader * header = <NEW_LINE> reinterpret_cast < HeapObjectHeader * > ( headerAddress ) ; <NEW_LINE> if ( ! header -> isFree ( ) ) { <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> objectPayloadSize += header -> payloadSize ( ) ; <NEW_LINE> } <NEW_LINE> ASSERT ( header -> size ( ) < blinkPagePayloadSize ( ) ) ;
static inline bool isPositionedContainer ( RenderLayer * layer ) <NEW_LINE> { <NEW_LINE> RenderBoxModelObject * layerRenderer = layer -> renderer ( ) ; <NEW_LINE> <START_VULN> return layer -> isRootLayer ( ) || layerRenderer -> isPositioned ( ) || layerRenderer -> isRelPositioned ( ) || layer -> hasTransform ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline bool isFixedPositionedContainer ( RenderLayer * layer )
return ; <NEW_LINE> nsIScriptContext * scx = sgo -> GetContext ( ) ; <NEW_LINE> if ( ! scx ) <NEW_LINE> return ; <NEW_LINE> JSContext * cx = scx -> GetNativeContext ( ) ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> pusher . Push ( cx , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIXPConnectWrappedNative > wrapper ; <NEW_LINE> nsContentUtils::XPConnect ( ) -> <NEW_LINE> GetWrappedNativeOfNativeObject ( cx , sgo -> GetGlobalJSObject ( ) , thisContent , <NEW_LINE> NS_GET_IID ( nsISupports ) , <NEW_LINE> getter_AddRefs ( wrapper ) ) ; <NEW_LINE> if ( ! wrapper ) {
} <NEW_LINE> phar_flush ( phar_obj -> arc . archive , ( char * ) & zstub , len , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> } <NEW_LINE> RETURN_TRUE ;
if ( test ) { <NEW_LINE> fname = test ; <NEW_LINE> <START_VULN> fname_len = ( php_stat_len ) strlen ( fname ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 , "Could not resolve file path" ) ; <NEW_LINE> return ZEND_HASH_APPLY_STOP ;
jsval rval = JSVAL_VOID ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> if ( ! pusher . Push ( mContext , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ) <NEW_LINE> <END_VULN> return NS_ERROR_FAILURE ; <NEW_LINE> rv = sSecurityManager -> CheckFunctionAccess ( mContext , aHandler , target ) ; <NEW_LINE> nsJSContext::TerminationFuncHolder holder ( this ) ; <NEW_LINE> if ( NS_SUCCEEDED ( rv ) ) {
REGISTER_SPL_SUB_CLASS_EX ( RecursiveDirectoryIterator , FilesystemIterator , spl_filesystem_object_new , spl_RecursiveDirectoryIterator_functions ) ; <NEW_LINE> REGISTER_SPL_IMPLEMENTS ( RecursiveDirectoryIterator , RecursiveIterator ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> memcpy ( & spl_filesystem_object_check_handlers , & spl_filesystem_object_handlers , sizeof ( zend_object_handlers ) ) ; <NEW_LINE> spl_filesystem_object_check_handlers . get_method = spl_filesystem_object_get_method_check ;
PRUint32 ac = aElement -> GetAttrCount ( ) ; <NEW_LINE> nsresult rv ; <NEW_LINE> for ( PRInt32 i = ac - 1 ; i >= 0 ; -- i ) { <NEW_LINE> rv = NS_OK ; <NEW_LINE> const nsAttrName * attrName = aElement -> GetAttrNameAt ( i ) ; <NEW_LINE> PRInt32 attrNs = attrName -> NamespaceID ( ) ; <NEW_LINE> <START_VULN> nsIAtom * attrLocal = attrName -> LocalName ( ) ; <NEW_LINE> <END_VULN> if ( kNameSpaceID_None == attrNs ) { <NEW_LINE> if ( aAllowStyle && nsGkAtoms::style == attrLocal ) { <NEW_LINE> nsCOMPtr < nsIURI > baseURI = aElement -> GetBaseURI ( ) ; <NEW_LINE> nsIDocument * document = aElement -> GetOwnerDoc ( ) ; <NEW_LINE> nsCSSParser parser ( document -> CSSLoader ( ) ) ;
LayoutUnit RenderFlexibleBox::availableAlignmentSpaceForChild ( LayoutUnit lineCrossAxisExtent , RenderBox * child ) <NEW_LINE> { <NEW_LINE> LayoutUnit childCrossExtent = 0 ; <NEW_LINE> <START_VULN> if ( ! child -> isPositioned ( ) ) <NEW_LINE> <END_VULN> childCrossExtent = crossAxisMarginExtentForChild ( child ) + crossAxisExtentForChild ( child ) ; <NEW_LINE> return lineCrossAxisExtent - childCrossExtent ; <NEW_LINE> }
return ; <NEW_LINE> } <NEW_LINE> <START_VULN> l_row -- ; <NEW_LINE>l_column -- ; <NEW_LINE> <END_VULN> ( * o_row_idx ) [ l_i ] = l_row ; <NEW_LINE> ( * o_values ) [ l_i ] = l_value ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> static inline int _setEdgePixel ( const gdImagePtr src , unsigned int x , unsigned int y , gdFixed coverage , const int bgColor ) <NEW_LINE> <END_VULN> { <NEW_LINE> const gdFixed f_127 = gd_itofx ( 127 ) ; <NEW_LINE> register int c = src -> tpixels [ y ] [ x ] ;
{ <NEW_LINE> for ( i = 0 ; i < read ; i ++ ) { <NEW_LINE> <START_VULN> chase = ( ( ogg_uint32_t * ) ( book -> dec_table ) ) [ chase * 2 + ( ( lok >> i ) & 1 ) ] ; <NEW_LINE>if ( chase & 0x80000000UL ) break ; <NEW_LINE> <END_VULN> } <NEW_LINE> chase &= ~ 0x80000000UL ;
PNG_EXPORT ( 129 , png_int_32 , png_get_y_offset_microns , <NEW_LINE> ( png_const_structrp png_ptr , png_const_inforp info_ptr ) ) ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_READ_SUPPORTED
long index ; <NEW_LINE> HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; <NEW_LINE> <START_VULN> if ( ! offset ) { <NEW_LINE> <END_VULN> return & EG ( uninitialized_zval_ptr ) ; <NEW_LINE> }
if ( int ( mDepthAttachment . IsNull ( ) ) + <NEW_LINE> int ( mStencilAttachment . IsNull ( ) ) + <NEW_LINE> int ( mDepthStencilAttachment . IsNull ( ) ) <= 1 ) <NEW_LINE> { <NEW_LINE> return PR_TRUE ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> else return PR_FALSE ; <NEW_LINE> } <NEW_LINE> const WebGLFramebufferAttachment & ColorAttachment ( ) const { <NEW_LINE> return mColorAttachment ; <NEW_LINE> } <NEW_LINE> const WebGLFramebufferAttachment & DepthAttachment ( ) const {
fcic . object_ptr = NULL ; <NEW_LINE> result = zend_call_function ( & fci , & fcic TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( result == FAILURE ) { <NEW_LINE> RETVAL_FALSE ; <NEW_LINE> } else {
protected: <NEW_LINE> std::string file_name_ ; <NEW_LINE> <START_VULN> FILE * input_file_ ; <NEW_LINE>nestegg * nestegg_ctx_ ; <NEW_LINE>nestegg_packet * pkt_ ; <NEW_LINE>unsigned int video_track_ ; <NEW_LINE>unsigned int chunk_ ; <NEW_LINE>unsigned int chunks_ ; <NEW_LINE> <END_VULN> uint8_t * buf_ ; <NEW_LINE> size_t buf_sz_ ; <NEW_LINE> unsigned int frame_ ;
int re_yyget_lineno ( yyscan_t yyscanner ) <NEW_LINE> { <NEW_LINE> struct yyguts_t * yyg = ( struct yyguts_t * ) yyscanner ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ! YY_CURRENT_BUFFER ) <NEW_LINE> return 0 ;
<START_VULN> if ( ( int ) size > cdigits ) <NEW_LINE> <END_VULN> { <NEW_LINE> while ( cdigits > 0 ) * ascii ++ = exponent [ -- cdigits ] ;
@param . . . Other paths to join to the base path . List of other paths must be NULL terminated . <NEW_LINE> @returns Allocated string containing the resolved path . <NEW_LINE> @ingroup MprPath <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC char * mprJoinPaths ( cchar * base , . . . ) ;
* where += l ; <NEW_LINE> efree ( d_url ) ; <NEW_LINE> skip_cookie: <NEW_LINE> <START_VULN> if ( buf != buffer ) { <NEW_LINE>efree ( buf ) ; <NEW_LINE> } <NEW_LINE>if ( buf2 != buffer2 ) { <NEW_LINE>efree ( buf2 ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> return * where ; <NEW_LINE> }
num_discardable_containers , <NEW_LINE> total_source_bytes , <NEW_LINE> discardable_source_bytes ) ) ; <NEW_LINE> } <NEW_LINE> if ( mDecoder ) { <NEW_LINE> <START_VULN> MutexAutoLock lock ( mDecodingMutex ) ; <NEW_LINE> <END_VULN> DecodePool::StopDecoding ( this ) ; <NEW_LINE> mDecoder = nullptr ; <NEW_LINE> if ( GetNumFrames ( ) > 0 ) {
for ( MDefinitionIterator iter ( block ) ; iter ; iter ++ ) { <NEW_LINE> MDefinition * def = * iter ; <NEW_LINE> def -> computeRange ( ) ; <NEW_LINE> IonSpew ( IonSpew_Range , "computing range on % d" , def -> id ( ) ) ; <NEW_LINE> SpewRange ( def ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( block -> isLoopHeader ( ) ) <NEW_LINE>analyzeLoop ( block ) ; <NEW_LINE> <END_VULN> if ( mir -> compilingAsmJS ( ) ) { <NEW_LINE> for ( MInstructionIterator i = block -> begin ( ) ; i != block -> end ( ) ; i ++ ) { <NEW_LINE> if ( i -> isAsmJSLoadHeap ( ) ) { <NEW_LINE> MAsmJSLoadHeap * ins = i -> toAsmJSLoadHeap ( ) ; <NEW_LINE> Range * range = ins -> ptr ( ) -> range ( ) ; <NEW_LINE> if ( range && ! range -> isLowerUnbounded ( ) && range -> lower ( ) >= 0 && <NEW_LINE> ! range -> isUpperUnbounded ( ) &&
dcfg -> hash_is_enabled = HASH_DISABLED ; <NEW_LINE> dcfg -> hash_enforcement = HASH_DISABLED ; <NEW_LINE> } <NEW_LINE> <START_VULN> else return apr_psprintf ( cmd -> pool , "ModSecurity: Invalid value for SecRuleEngine: % s" , p1 ) ; <NEW_LINE> <END_VULN> return NULL ; <NEW_LINE> }
#include "vp9 / decoder / vp9_decodemv . h" <NEW_LINE> #include "vp9 / decoder / vp9_decoder . h" <NEW_LINE> #include "vp9 / decoder / vp9_dsubexp . h" <NEW_LINE> <START_VULN> #include "vp9 / decoder / vp9_dthread . h" <NEW_LINE>#include "vp9 / decoder / vp9_read_bit_buffer . h" <NEW_LINE>#include "vp9 / decoder / vp9_reader . h" <NEW_LINE>#include "vp9 / decoder / vp9_thread . h" <NEW_LINE> <END_VULN> static int is_compound_reference_allowed ( const VP9_COMMON * cm ) { <NEW_LINE> int i ;
{ <NEW_LINE> impeg2d_bit_stream_flush ( ps_stream , 9 ) ; <NEW_LINE> <START_VULN> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <NEW_LINE> <END_VULN> { <NEW_LINE> impeg2d_bit_stream_flush ( ps_stream , 9 ) ; <NEW_LINE> }
bool ms_get_authorizer ( int dest_type , AuthAuthorizer ** authorizer , bool force_new ) override ; <NEW_LINE> bool ms_verify_authorizer ( Connection * con , int peer_type , <NEW_LINE> int protocol , bufferlist & authorizer_data , bufferlist & authorizer_reply , <NEW_LINE> <START_VULN> bool & isvalid , CryptoKey & session_key ) override ; <NEW_LINE> <END_VULN> bool ms_handle_reset ( Connection * con ) override ; <NEW_LINE> void ms_handle_remote_reset ( Connection * con ) override { } <NEW_LINE> bool ms_handle_refused ( Connection * con ) override ;
} <NEW_LINE> <START_VULN> if ( png_ptr -> colorspace . flags & PNG_COLORSPACE_INVALID ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_crc_finish ( png_ptr , length ) ; <NEW_LINE> return ;
#endif <NEW_LINE> if ( cfname ) <NEW_LINE> fp = fopen ( cfname , "r" ) ; <NEW_LINE> <START_VULN> #line 4009 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> if ( ! fp ) <NEW_LINE> { <NEW_LINE> #ifdef LIBRAW_LIBRARY_BUILD
( ! strcmp ( prefix , "tutor8_2" ) ) ) <NEW_LINE> disable_err = 1 ; <NEW_LINE> <START_VULN> snprintf ( pattern , 499 , " . / test / relaxng / % s_ ? . xml" , prefix ) ; <NEW_LINE>pattern [ 499 ] = 0 ; <NEW_LINE> <END_VULN> globbuf . gl_offs = 0 ; <NEW_LINE> glob ( pattern , GLOB_DOOFFS , NULL , & globbuf ) ;
{ <NEW_LINE> OnigCodePoint gcode = wordlist [ key ] . code ; <NEW_LINE> <START_VULN> if ( code == gcode ) <NEW_LINE> <END_VULN> return & wordlist [ key ] ; <NEW_LINE> } <NEW_LINE> }
Member < FetchContext > context_ ; <NEW_LINE> <START_VULN> HashSet < String > validated_ur_ls_ ; <NEW_LINE> <END_VULN> mutable DocumentResourceMap document_resources_ ; <NEW_LINE> Member < HeapListHashSet < Member < Resource >> > preloads_ ;
class nsIconDecoder : public Decoder <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> nsIconDecoder ( RasterImage & aImage ) ; <NEW_LINE> virtual ~ nsIconDecoder ( ) ; <NEW_LINE> <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> uint8_t mWidth ; <NEW_LINE> uint8_t mHeight ; <NEW_LINE> uint32_t mPixBytesRead ; <NEW_LINE> uint32_t mState ; <NEW_LINE> } ; <NEW_LINE> enum {
( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) <NEW_LINE> { <NEW_LINE> check_here = ( neighbors [ j ] . row ) * in_what_stride + neighbors [ j ] . col + best_address ; <NEW_LINE> <START_VULN> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <NEW_LINE> <END_VULN> if ( thissad < bestsad ) <NEW_LINE> {
if ( strlen ( hdl -> c_path ) >= sizeof ( unix_addr . sun_path ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> close ( fd ) ; <END_VULN> <NEW_LINE> <START_VULN> return HSM_COM_PATH_ERR ; <END_VULN> <NEW_LINE> <NEW_LINE> <NEW_LINE> } <NEW_LINE> snprintf ( unix_addr . sun_path , sizeof ( unix_addr . sun_path ) , " % s" , hdl -> c_path ) ;
RenderBox * RenderFieldset::findLegend ( ) const <NEW_LINE> { <NEW_LINE> for ( RenderObject * legend = firstChild ( ) ; legend ; legend = legend -> nextSibling ( ) ) { <NEW_LINE> <START_VULN> if ( ! legend -> isFloatingOrPositioned ( ) && legend -> node ( ) && ( legend -> node ( ) -> hasTagName ( legendTag ) ) ) <NEW_LINE> <END_VULN> return toRenderBox ( legend ) ; <NEW_LINE> } <NEW_LINE> return 0 ;
JSString * str = ProxyHandler::fun_toString ( cx , wrapper , indent ) ; <NEW_LINE> leave ( cx , wrapper ) ; <NEW_LINE> return str ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> Wrapper::defaultValue ( JSContext * cx , JSObject * wrapper , JSType hint , Value * vp ) <NEW_LINE> { <NEW_LINE> <START_VULN> * vp = ObjectValue ( * wrappedObject ( wrapper ) ) ; <NEW_LINE> <END_VULN> if ( hint == JSTYPE_VOID ) <NEW_LINE> return ToPrimitive ( cx , vp ) ; <NEW_LINE> return ToPrimitive ( cx , hint , vp ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> Wrapper::trace ( JSTracer * trc , JSObject * wrapper ) <NEW_LINE> {
bool ms_get_authorizer ( int dest_type , AuthAuthorizer ** authorizer , bool force_new ) override ; <NEW_LINE> bool ms_verify_authorizer ( Connection * con , int peer_type , <NEW_LINE> int protocol , bufferlist & authorizer , bufferlist & authorizer_reply , <NEW_LINE> <START_VULN> bool & isvalid , CryptoKey & session_key ) override ; <NEW_LINE> <END_VULN> void ms_handle_connect ( Connection * con ) override ; <NEW_LINE> void ms_handle_fast_connect ( Connection * con ) override ; <NEW_LINE> void ms_handle_fast_accept ( Connection * con ) override ;
if ( type != Resource::kRaw ) { <NEW_LINE> if ( ! Context ( ) . IsLoadComplete ( ) && <NEW_LINE> <START_VULN> validated_ur_ls_ . Contains ( existing_resource -> Url ( ) ) ) <NEW_LINE> <END_VULN> return kUse ; <NEW_LINE> if ( existing_resource -> IsLoading ( ) ) <NEW_LINE> return kUse ;
if ( row ) { <NEW_LINE> gdFree ( row ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> return ; <NEW_LINE> <END_VULN> } <NEW_LINE> cinfo . err -> emit_message = jpeg_emit_message ;
if ( preg_options ) { <NEW_LINE> * preg_options = pce ? pce -> preg_options : 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return pce ? pce -> re : NULL ; <NEW_LINE> }
res = read_block ( fd , id_index_table [ i ] , NULL , expected , <NEW_LINE> ( ( char * ) id_table ) + i * SQUASHFS_METADATA_SIZE ) ; <NEW_LINE> if ( res == FALSE ) { <NEW_LINE> <START_VULN> ERROR ( "read_uids_guids: failed to read id table block" <NEW_LINE> <END_VULN> "\n" ) ; <NEW_LINE> return FALSE ; <NEW_LINE> }
{ <NEW_LINE> INC_STATS ( "DOM . DataView . getInt8" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> DataView * imp = V8DataView::toNative ( args . Holder ( ) ) ; <NEW_LINE> ExceptionCode ec = 0 ;
fprintf ( stderr , "Unable to select public key file: % s\n" , sc_strerror ( r ) ) ; <NEW_LINE> return 2 ; <NEW_LINE> } <NEW_LINE> <START_VULN> bufsize = file -> size ; <NEW_LINE> <END_VULN> sc_file_free ( file ) ; <NEW_LINE> r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; <NEW_LINE> if ( r < 0 ) {
return true ; <NEW_LINE> } <NEW_LINE> int32_t checkHandshake ( int32_t bytesTransfered , bool wasReading , <NEW_LINE> PRFileDesc * ssl_layer_fd , <NEW_LINE> nsNSSSocketInfo * socketInfo ) <NEW_LINE> { <NEW_LINE> <START_VULN> PRErrorCode err = PR_GetError ( ) ; <NEW_LINE> <END_VULN>
size_t a_len = a . nlimbs ; <NEW_LINE> size_t c_len = 9 * ( ( size_t ) ( a_len * ( GMP_LIMB_BITS * 0 . 03345f ) ) + 1 ) ; <NEW_LINE> <START_VULN> char * c_ptr = ( char * ) malloc ( xsum ( c_len , extra_zeroes ) ) ; <NEW_LINE> <END_VULN> if ( c_ptr != NULL ) <NEW_LINE> { <NEW_LINE> char * d_ptr = c_ptr ;
return track ; <NEW_LINE> } <NEW_LINE> <START_VULN> Chapter * Segment::AddChapter ( ) { <NEW_LINE>return chapters_ . AddChapter ( & seed_ ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> uint64 Segment::AddVideoTrack ( int32 width , int32 height , int32 number ) { <NEW_LINE> VideoTrack * const track = new ( std::nothrow ) VideoTrack ( & seed_ ) ;
unsigned char <NEW_LINE> buffer [ 4 ] ; <NEW_LINE> <START_VULN> size_t <NEW_LINE> <END_VULN> value ; <NEW_LINE> if ( * length < 4 )
int dbg_color_b_modes_flag ; <NEW_LINE> int dbg_display_mv_flag ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> vp8_decrypt_cb * decrypt_cb ; <NEW_LINE> <END_VULN> void * decrypt_state ; <NEW_LINE> vpx_image_t img ; <NEW_LINE> int img_setup ;
return NS_OK ; <NEW_LINE> nsCOMPtr < nsIWidget > widget = GetWidget ( sPresContext ) ; <NEW_LINE> if ( widget ) { <NEW_LINE> IMEState newState = GetNewIMEState ( sPresContext , nullptr ) ; <NEW_LINE> InputContextAction action ( InputContextAction::CAUSE_UNKNOWN , <NEW_LINE> InputContextAction::LOST_FOCUS ) ; <NEW_LINE> SetIMEState ( newState , nullptr , widget , action ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> sContent = nullptr ; <NEW_LINE> <END_VULN> sPresContext = nullptr ; <NEW_LINE> OnTextStateBlur ( nullptr , nullptr ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsIMEStateManager::OnRemoveContent ( nsPresContext * aPresContext , <NEW_LINE> nsIContent * aContent )
: 0 ; <NEW_LINE> } <NEW_LINE> bool isNative ( ) const { <NEW_LINE> JS_ASSERT ( ! ( flags & NON_NATIVE ) == getObjectClass ( ) -> isNative ( ) ) ; <NEW_LINE> return ! ( flags & NON_NATIVE ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> const js::Shape * previous ( ) const { <NEW_LINE> <END_VULN> return parent ; <NEW_LINE> } <NEW_LINE> class Range { <NEW_LINE> protected: <NEW_LINE> friend struct Shape ; <NEW_LINE> const Shape * cursor ;
NS_IMETHODIMP <NEW_LINE> nsDOMStringMapSH::PreCreate ( nsISupports * nativeObj , JSContext * cx , <NEW_LINE> JSObject * globalObj , JSObject ** parentObj ) <NEW_LINE> { <NEW_LINE> * parentObj = globalObj ; <NEW_LINE> nsDOMStringMap * dataset = static_cast < nsDOMStringMap * > ( nativeObj ) ; <NEW_LINE> <START_VULN> nsIDocument * document = dataset -> GetElement ( ) -> OwnerDoc ( ) ; <NEW_LINE><NEW_LINE>nsCOMPtr < nsIScriptGlobalObject > sgo = <NEW_LINE>do_GetInterface ( document -> GetScopeObject ( ) ) ; <NEW_LINE><NEW_LINE>if ( sgo ) { <NEW_LINE>JSObject * global = sgo -> GetGlobalJSObject ( ) ; <NEW_LINE><NEW_LINE>if ( global ) { <NEW_LINE> * parentObj = global ; <NEW_LINE>return NS_OK ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE><NEW_LINE>return NS_OK ; <NEW_LINE> <END_VULN> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsDOMStringMapSH::DelProperty ( nsIXPConnectWrappedNative * wrapper , <NEW_LINE> JSContext * cx , JSObject * obj , jsid id , <NEW_LINE> jsval * vp , bool * _retval ) <NEW_LINE> { <NEW_LINE> nsCOMPtr < nsIDOMDOMStringMap > dataset ( do_QueryWrappedNative ( wrapper , obj ) ) ;
if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || <NEW_LINE> qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <NEW_LINE> <END_VULN> NESTSIZE ( qtsize ) ; <NEW_LINE> continue ; <NEW_LINE> }
httpResetCredentials ( conn ) ; <NEW_LINE> if ( password == NULL && strchr ( username , ':' ) != 0 ) { <NEW_LINE> <START_VULN> conn -> username = stok ( sclone ( username ) , ":" , & ptok ) ; <NEW_LINE> <END_VULN> conn -> password = sclone ( ptok ) ; <NEW_LINE> } else { <NEW_LINE> conn -> username = sclone ( username ) ;
} <NEW_LINE> else { <NEW_LINE> for ( RenderBox * obj = firstChildBox ( ) ; obj ; obj = obj -> nextSiblingBox ( ) ) { <NEW_LINE> <START_VULN> if ( ! obj -> isFloatingOrPositioned ( ) ) { <NEW_LINE> <END_VULN> if ( obj -> isBlockFlow ( ) && ! obj -> hasOverflowClip ( ) ) <NEW_LINE> toRenderBlock ( obj ) -> adjustForBorderFit ( x + obj -> x ( ) , left , right ) ; <NEW_LINE> else if ( obj -> style ( ) -> visibility ( ) == VISIBLE ) {
atalk_print ( ndo , bp , len ) ; <NEW_LINE> break ; <NEW_LINE> case ETHERTYPE_GRE_ISO: <NEW_LINE> <START_VULN> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case ETHERTYPE_TEB: <NEW_LINE> ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;
<START_VULN> typedef png_structp version_1_2_52 ; <NEW_LINE> <END_VULN> typedef png_struct FAR * FAR * png_structpp ;
#include < stddef . h > <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> namespace mojo {
return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1268 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy95: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' , ' ) {
} <NEW_LINE> } <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x1D:
return rv ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsImageBoxFrame::UpdateImage ( ) <NEW_LINE> { <NEW_LINE> if ( mImageRequest ) { <NEW_LINE> <START_VULN> mImageRequest -> Cancel ( NS_ERROR_FAILURE ) ; <NEW_LINE> <END_VULN> mImageRequest = nsnull ; <NEW_LINE> } <NEW_LINE> nsAutoString src ; <NEW_LINE> mContent -> GetAttr ( kNameSpaceID_None , nsGkAtoms::src , src ) ; <NEW_LINE> mUseSrcAttr = ! src . IsEmpty ( ) ; <NEW_LINE> if ( mUseSrcAttr ) {
{ <NEW_LINE> INC_STATS ( "DOM . TestActiveDOMObject . excitingFunction" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestActiveDOMObject * imp = V8TestActiveDOMObject::toNative ( args . Holder ( ) ) ; <NEW_LINE> if ( ! V8BindingSecurity::canAccessFrame ( V8BindingState::Only ( ) , imp -> frame ( ) , true ) ) <NEW_LINE> return v8::Handle < v8::Value > ( ) ;
for ( i = 0 ; i < sBlk . s . fragments ; i ++ ) <NEW_LINE> SQUASHFS_INSWAP_FRAGMENT_ENTRY ( & fragment_table [ i ] ) ; <NEW_LINE> <START_VULN> * directory_table_end = fragment_table_index [ 0 ] ; <NEW_LINE> <END_VULN> return TRUE ; <NEW_LINE> }
if ( curr -> isRunIn ( ) || ( curr -> firstChild ( ) && curr -> firstChild ( ) -> isRunIn ( ) ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( curr -> isAnonymous ( ) || curr -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> RenderBoxModelObject * oldRunIn = toRenderBoxModelObject ( runIn ) ;
hashval Object::hash ( STATE ) { <NEW_LINE> if ( ! reference_p ( ) ) { <NEW_LINE> <START_VULN> #ifdef _LP64 <NEW_LINE> <END_VULN> uintptr_t key = reinterpret_cast < uintptr_t > ( this ) ; <NEW_LINE> key = ( ~ key ) + ( key << 21 ) ; <NEW_LINE> key = key ^ ( key >> 24 ) ;
} <NEW_LINE> <START_VULN> static void pack_tokens_into_partitions_c ( VP8_COMP * cpi , unsigned char * cx_data , <NEW_LINE> <END_VULN> unsigned char * cx_data_end , <NEW_LINE> int num_part ) <NEW_LINE> {
<START_VULN> if ( save ) <NEW_LINE> <END_VULN> png_push_save_buffer ( png_ptr ) ; <NEW_LINE> else <NEW_LINE> {
virtual ::ppapi::thunk::PPB_URLLoader_API * AsPPB_URLLoader_API ( ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void LastPluginRefWasDeleted ( bool instance_destroyed ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual int32_t Open ( PP_Resource request_id ,
if ( ! ValidateGLSLVariableName ( name , "getUniformLocation" ) ) <NEW_LINE> return NS_OK ; <NEW_LINE> MakeContextCurrent ( ) ; <NEW_LINE> GLint intlocation = gl -> fGetUniformLocation ( progname , NS_LossyConvertUTF16toASCII ( name ) . get ( ) ) ; <NEW_LINE> <START_VULN> nsRefPtr < nsIWebGLUniformLocation > loc = prog -> GetUniformLocationObject ( intlocation ) ; <NEW_LINE> <END_VULN> * retval = loc . forget ( ) . get ( ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> WebGLContext::GetVertexAttrib ( WebGLuint index , WebGLenum pname , nsIVariant ** retval ) <NEW_LINE> {
intern -> u . file . open_mode = "wb" ; <NEW_LINE> intern -> u . file . open_mode_len = 1 ; <NEW_LINE> intern -> u . file . zcontext = NULL ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( spl_filesystem_file_open ( intern , 0 , 0 TSRMLS_CC ) == SUCCESS ) { <NEW_LINE> intern -> _path_len = 0 ; <NEW_LINE> intern -> _path = estrndup ( "" , 0 ) ;
} <NEW_LINE> if ( ! silent ) <NEW_LINE> <START_VULN> printf ( "gamma % f: maximum 16 bit error % f\n" , g , maxerr ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return 0 ;
WORD32 index ) { <NEW_LINE> int i ; <NEW_LINE> WORD32 l1 , l2 , h2 , fft_jmp ; <NEW_LINE> <START_VULN> WORD32 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ; <NEW_LINE>WORD32 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ; <NEW_LINE> <END_VULN> WORD32 x_0 , x_1 , x_l1_0 , x_l1_1 , x_l2_0 , x_l2_1 ; <NEW_LINE> WORD32 x_h2_0 , x_h2_1 ; <NEW_LINE> WORD32 si10 , si20 , si30 , co10 , co20 , co30 ;
} <NEW_LINE> void <NEW_LINE> HTMLContentSink::FlushPendingNotifications ( mozFlushType aType ) <NEW_LINE> { <NEW_LINE> if ( ! mInNotification ) { <NEW_LINE> <START_VULN> if ( aType >= Flush_ContentAndNotify ) { <NEW_LINE>FlushTags ( ) ; <NEW_LINE> } <NEW_LINE>else if ( mCurrentContext ) { <NEW_LINE>mCurrentContext -> FlushText ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( aType >= Flush_Layout ) { <NEW_LINE> StartLayout ( PR_TRUE ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
nsCOMPtr < nsIPresShell > shell = mPresShell ; <NEW_LINE> shell -> FlushPendingNotifications ( Flush_Layout ) ; <NEW_LINE> } <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> NS_ENSURE_TRUE ( mDocument , NS_ERROR_NOT_AVAILABLE ) ; <NEW_LINE> <START_VULN> nsPIDOMWindow * window = mDocument -> GetWindow ( ) ; <NEW_LINE> <END_VULN> mLoaded = true ; <NEW_LINE> bool restoring = false ;
PK11SlotInfo ** slot , bool willEscrow ) <NEW_LINE> { <NEW_LINE> JSString * jsString ; <NEW_LINE> <START_VULN> JSAutoByteString params , keyGenAlg ; <NEW_LINE> <END_VULN> int keySize ; <NEW_LINE> nsresult rv ;
case OPT_WRITE_BINLOG: <NEW_LINE> add_option = FALSE ; <NEW_LINE> break ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> case 'h': <NEW_LINE> case 'W': <NEW_LINE> case 'P':
} <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> if ( elementid . EqualsLiteral ( "_parent" ) ) { <NEW_LINE> nsIContent * parent = mContent -> GetParent ( ) ; <NEW_LINE> <START_VULN> return parent ? parent -> FindFirstNonNativeAnonymous ( ) : nullptr ; <NEW_LINE> <END_VULN> } <NEW_LINE> return aPresShell -> GetDocument ( ) -> GetElementById ( elementid ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsResizerFrame::AdjustDimensions ( int32_t * aPos , int32_t * aSize , <NEW_LINE> int32_t aMinSize , int32_t aMaxSize ,
ast_mutex_unlock ( & iaxsl [ callno ] ) ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> default: <NEW_LINE> <END_VULN> { <NEW_LINE> unsigned short callno = PTR_TO_CALLNO ( c -> tech_pvt ) ; <NEW_LINE> struct chan_iax2_pvt * pvt ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: basic codebook pack / unpack / code / decode operations <NEW_LINE> <START_VULN> last mod: $ Id: codebook . c 16227 2009 - 07 - 08 06:58:46Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
for ( unsigned int i = 0 ; i < m_SequenceParameters . ItemCount ( ) ; i ++ ) { <NEW_LINE> inspector . AddField ( "Sequence Parameter" , m_SequenceParameters [ i ] . GetData ( ) , m_SequenceParameters [ i ] . GetDataSize ( ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> for ( unsigned int i = 0 ; i < m_SequenceParameters . ItemCount ( ) ; i ++ ) { <NEW_LINE> <END_VULN> inspector . AddField ( "Picture Parameter" , m_PictureParameters [ i ] . GetData ( ) , m_PictureParameters [ i ] . GetDataSize ( ) ) ; <NEW_LINE> } <NEW_LINE> return AP4_SUCCESS ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . intMethodWithArgs" ) ; <NEW_LINE> if ( args . Length ( ) < 3 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( int , intArg , toInt32 ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , strArg , MAYBE_MISSING_PARAMETER ( args , 1 , DefaultIsUndefined ) ) ;
InlineBox * RenderInline::culledInlineFirstLineBox ( ) const <NEW_LINE> { <NEW_LINE> for ( RenderObject * curr = firstChild ( ) ; curr ; curr = curr -> nextSibling ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> continue ;
return JS_FALSE ; <NEW_LINE> MUST_FLOW_THROUGH ( "out" ) ; <NEW_LINE> JSBool ok = JS_TRUE ; <NEW_LINE> JSBool cond ; <NEW_LINE> Value objv = ObjectValue ( * obj ) ; <NEW_LINE> AutoValueRooter tvr ( cx ) ; <NEW_LINE> <START_VULN> for ( jsint i = start ; i != end ; i += step ) { <NEW_LINE> <END_VULN> JSBool hole ; <NEW_LINE> ok = JS_CHECK_OPERATION_LIMIT ( cx ) && <NEW_LINE> GetElement ( cx , obj , i , & hole , tvr . addr ( ) ) ; <NEW_LINE> if ( ! ok ) <NEW_LINE> goto out ; <NEW_LINE> if ( hole ) <NEW_LINE> continue ;
int ji ; <NEW_LINE> for ( ITERATE_CONFIG ( route , prop , child , ji ) ) { <NEW_LINE> <START_VULN> defenses = mprGetJson ( child , "defenses" ) ; <NEW_LINE>expression = mprGetJson ( child , "expression" ) ; <NEW_LINE>period = httpGetTicks ( mprGetJson ( child , "period" ) ) ; <NEW_LINE> <END_VULN> if ( ! httpTokenize ( route , expression , " % S % S % S" , & counter , & relation , & limit ) ) { <NEW_LINE> httpParseError ( route , "Cannot add monitor: % s" , prop -> name ) ;
<START_VULN> bool PreReadImage ( const wchar_t * file_path , size_t size_to_read , <NEW_LINE>size_t step_size ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> #if defined ( OS_LINUX )
item -> HandleEvent ( aVisitor , aFlags , <NEW_LINE> aMayHaveNewListenerManagers || <NEW_LINE> createdELMs != nsEventListenerManager::sCreatedCount , <NEW_LINE> aPusher ) ; <NEW_LINE> } <NEW_LINE> if ( aFlags & NS_EVENT_FLAG_SYSTEM_EVENT ) { <NEW_LINE> <START_VULN> item -> PostHandleEvent ( aVisitor ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> aVisitor . mEvent -> flags &= ~ NS_EVENT_FLAG_CAPTURE ; <NEW_LINE> item = item -> mParent ; <NEW_LINE> while ( item ) { <NEW_LINE> nsIDOMEventTarget * newTarget = item -> GetNewTarget ( ) ; <NEW_LINE> if ( newTarget ) {
for ( int i = 0 ; i < ( int ) size ; i ++ ) { <NEW_LINE> size_t off = objects [ i ] ; <NEW_LINE> <START_VULN> if ( ( off >= offset ) && ( off < offset + len ) ) { <NEW_LINE> <END_VULN> if ( firstIndex == - 1 ) { <NEW_LINE> firstIndex = i ; <NEW_LINE> }
png_ptr -> flush_rows = 0 ; <NEW_LINE> png_flush ( png_ptr ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE><NEW_LINE>#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED <NEW_LINE>static void png_reset_filter_heuristics ( png_structrp png_ptr ) ; <NEW_LINE>#endif <NEW_LINE> <END_VULN> static void
goto out_unlock ; <NEW_LINE> memcpy ( dst -> iov_base , p , len ) ; <NEW_LINE> <START_VULN> credits = be32_to_cpu ( rmsgp -> rm_credit ) ; <NEW_LINE> <END_VULN> if ( credits == 0 ) <NEW_LINE> credits = 1 ; <NEW_LINE> else if ( credits > r_xprt -> rx_buf . rb_bc_max_requests )
ReentrantMonitorAutoEnter mon ( mDecoder -> GetReentrantMonitor ( ) ) ; <NEW_LINE> mVolume = volume ; <NEW_LINE> } <NEW_LINE> void MediaDecoderStateMachine::SetAudioCaptured ( bool aCaptured ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( NS_IsMainThread ( ) , "Should be on main thread . " ) ; <NEW_LINE> ReentrantMonitorAutoEnter mon ( mDecoder -> GetReentrantMonitor ( ) ) ; <NEW_LINE> <START_VULN> if ( ! mAudioCaptured && aCaptured ) { <NEW_LINE>StopAudioThread ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> mAudioCaptured = aCaptured ; <NEW_LINE> } <NEW_LINE> double MediaDecoderStateMachine::GetCurrentTime ( ) const <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( NS_IsMainThread ( ) || <NEW_LINE> OnStateMachineThread ( ) ||
struct mlx5_ib_resources * devr = & dev -> devr ; <NEW_LINE> int inlen = MLX5_ST_SZ_BYTES ( create_qp_in ) ; <NEW_LINE> struct mlx5_core_dev * mdev = dev -> mdev ; <NEW_LINE> <START_VULN> struct mlx5_ib_create_qp_resp resp ; <NEW_LINE> <END_VULN> struct mlx5_ib_cq * send_cq ; <NEW_LINE> struct mlx5_ib_cq * recv_cq ; <NEW_LINE> unsigned long flags ;
OMX::buffer_id makeBufferID ( OMX_BUFFERHEADERTYPE * bufferHeader ) ; <NEW_LINE> <START_VULN> OMX_BUFFERHEADERTYPE * findBufferHeader ( OMX::buffer_id buffer ) ; <NEW_LINE> <END_VULN> OMX::buffer_id findBufferID ( OMX_BUFFERHEADERTYPE * bufferHeader ) ; <NEW_LINE> void invalidateBufferID ( OMX::buffer_id buffer ) ;
printf ( "PCIe FPGA config:" ) ; <NEW_LINE> do { <NEW_LINE> <START_VULN> done = qrio_get_gpio ( GPIO_A , FPGA_DONE ) ; <NEW_LINE> <END_VULN> if ( timeout -- == 0 ) { <NEW_LINE> printf ( " FPGA_DONE timeout\n" ) ; <NEW_LINE> ret = - EFAULT ;
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsCAutoString charXferString ; <NEW_LINE> <START_VULN> charXferString . SetCapacity ( charLength ) ; <NEW_LINE> <END_VULN> char * charXferBuf = charXferString . BeginWriting ( ) ; <NEW_LINE> nsresult convert_rv = NS_OK ;
#endif <NEW_LINE> <START_VULN> bestmv -> as_mv . row <<= 3 ; <NEW_LINE>bestmv -> as_mv . col <<= 3 ; <NEW_LINE> <END_VULN> startmv = * bestmv ;
ZVAL_LONG ( rval , parse_iv ( start + 2 ) ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1214 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy83: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' / ' ) goto yy18 ;
char * buffer = ( char * ) PL_strcasestr ( spec . BeginWriting ( ) , "data:" ) ; <NEW_LINE> if ( ! buffer ) { <NEW_LINE> return NS_ERROR_MALFORMED_URI ; <NEW_LINE> } <NEW_LINE> buffer += 5 ; <NEW_LINE> char * comma = strchr ( buffer , ' , ' ) ; <NEW_LINE> <START_VULN> if ( ! comma ) <NEW_LINE> <END_VULN> return NS_ERROR_MALFORMED_URI ; <NEW_LINE> * comma = '\0' ; <NEW_LINE> char * base64 = PL_strcasestr ( buffer , BASE64_EXTENSION ) ; <NEW_LINE> if ( base64 ) { <NEW_LINE> char * beyond = base64 + strlen ( BASE64_EXTENSION ) ;
#include "Context . h" <NEW_LINE> <START_VULN> #include "Preprocessor . h" <NEW_LINE>#define YYLEX_PARAM context -> lexer <NEW_LINE> <END_VULN> #define YYDEBUG 1 <NEW_LINE> #ifndef YYDEBUG <NEW_LINE> # define YYDEBUG 0 <NEW_LINE> #endif
} <NEW_LINE> <START_VULN> png_ptr -> pixel_depth = ( png_byte ) ( png_ptr -> bit_depth * <NEW_LINE>png_ptr -> channels ) ; <NEW_LINE> <END_VULN> png_ptr -> rowbytes = PNG_ROWBYTES ( png_ptr -> pixel_depth , png_ptr -> width ) ; <NEW_LINE> png_debug1 ( 3 , "bit_depth = % d" , png_ptr -> bit_depth ) ; <NEW_LINE> png_debug1 ( 3 , "channels = % d" , png_ptr -> channels ) ;
PRInt32 interval = 0 ; <NEW_LINE> PRBool isInterval = aIsInterval ; <NEW_LINE> nsCOMPtr < nsIScriptTimeoutHandler > handler ; <NEW_LINE> <START_VULN> nsresult rv = NS_CreateJSTimeoutHandler ( GetContextInternal ( ) , <NEW_LINE> <END_VULN> & isInterval , <NEW_LINE> & interval , <NEW_LINE> getter_AddRefs ( handler ) ) ;
bool didVolSlide = false ; <NEW_LINE> <START_VULN> if ( chnMem . autoVolSlide && ! m . volcmd ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( chnMem . autoVolSlide & 0xF0 ) <NEW_LINE> {
static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) <NEW_LINE> { <NEW_LINE> <START_VULN> rcu_read_lock ( ) ; <NEW_LINE>__ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <NEW_LINE>rcu_read_unlock ( ) ; <NEW_LINE> <END_VULN> }
no_empty = flags & PREG_SPLIT_NO_EMPTY ; <NEW_LINE> delim_capture = flags & PREG_SPLIT_DELIM_CAPTURE ; <NEW_LINE> offset_capture = flags & PREG_SPLIT_OFFSET_CAPTURE ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( limit_val == 0 ) { <NEW_LINE> limit_val = - 1 ; <NEW_LINE> }
<START_VULN> if ( ( png_ptr -> mng_features_permitted & PNG_FLAG_MNG_FILTER_64 ) && <NEW_LINE> <END_VULN> ( png_ptr -> filter_type == PNG_INTRAPIXEL_DIFFERENCING ) ) <NEW_LINE> {
{ <NEW_LINE> vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstv + 4 , stride , <NEW_LINE> dstv + 4 , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> q += 32 ;
#if USE_MAGIC_HEADERS <NEW_LINE> size_t _alignment = alignment ; <NEW_LINE> size_t * _ret = 0 ; <NEW_LINE> <START_VULN> size += alignment + 3 * sizeof ( size_t ) ; <NEW_LINE> <END_VULN> _alignment = 0 ; <NEW_LINE> #endif <NEW_LINE> #if USE_ALLOCATOR == 0
<START_VULN> #define VPX_CODEC_ABI_VERSION ( 2 + VPX_IMAGE_ABI_VERSION ) <NEW_LINE> <END_VULN> typedef enum {
{ <NEW_LINE> <START_VULN> int czero , clead , cdigits ; <NEW_LINE> <END_VULN> char exponent [ 10 ] ;
<START_VULN> class SocketStreamDispatcherHost : public content::BrowserMessageFilter , <NEW_LINE>public net::SocketStream::Delegate , <NEW_LINE>public SSLErrorHandler::Delegate { <NEW_LINE> <END_VULN> public: <NEW_LINE> SocketStreamDispatcherHost ( <NEW_LINE> int render_process_id ,
1 , <NEW_LINE> - 533200896 , 1611661312 , 4 , 1 , <NEW_LINE> partial_quantlist1 , <NEW_LINE> NULL , NULL , NULL , <NEW_LINE> 0 <NEW_LINE> } ; <NEW_LINE> static float test5_result [ ] = { - 3 , - 6 , - 9 , 4 , 1 , - 2 , - 1 , - 4 , - 7 , <NEW_LINE> - 3 , 1 , - 2 , 4 , 8 , 5 , - 1 , 3 , 0 , <NEW_LINE> <START_VULN> - 3 , - 4 , - 7 , 4 , 3 , 0 , - 1 , - 2 , - 5 , <NEW_LINE> <END_VULN> - 3 , - 6 , - 2 , 4 , 1 , 5 , - 1 , - 4 , 0 , <NEW_LINE> - 3 , 1 , 5 , 4 , 8 , 12 , - 1 , 3 , 7 , <NEW_LINE> - 3 , - 4 , 0 , 4 , 3 , 7 , - 1 , - 2 , 2 , <NEW_LINE> - 3 , - 6 , - 7 , 4 , 1 , 0 , - 1 , - 4 , -
} <NEW_LINE> static CIE_color <NEW_LINE> <START_VULN> white_point ( PNG_CONST color_encoding * encoding ) <NEW_LINE> <END_VULN> { <NEW_LINE> CIE_color white ;
YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; <NEW_LINE> <START_VULN> vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <NEW_LINE> <END_VULN> cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ;
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void nsComboboxControlFrame::FireValueChangeEvent ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsCOMPtr < nsIDOMEvent > event ; <NEW_LINE>nsPresContext * presContext = PresContext ( ) ; <NEW_LINE>if ( NS_SUCCEEDED ( nsEventDispatcher::CreateEvent ( presContext , nsnull , <NEW_LINE>NS_LITERAL_STRING ( "Events" ) , <NEW_LINE>getter_AddRefs ( event ) ) ) ) { <NEW_LINE>event -> InitEvent ( NS_LITERAL_STRING ( "ValueChange" ) , PR_TRUE , PR_TRUE ) ; <NEW_LINE><NEW_LINE>nsCOMPtr < nsIPrivateDOMEvent > privateEvent ( do_QueryInterface ( event ) ) ; <NEW_LINE>privateEvent -> SetTrusted ( PR_TRUE ) ; <NEW_LINE>nsEventDispatcher::DispatchDOMEvent ( mContent , nsnull , event , nsnull , <NEW_LINE>nsnull ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsComboboxControlFrame::OnContentReset ( ) <NEW_LINE> { <NEW_LINE> if ( mListControlFrame ) { <NEW_LINE> mListControlFrame -> OnContentReset ( ) ; <NEW_LINE> }
return xpc::IsUniversalXPConnectEnabled ( GetCurrentJSContext ( ) ) ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> nsContentUtils::IsCallerXBL ( ) <NEW_LINE> { <NEW_LINE> JSScript * script ; <NEW_LINE> JSContext * cx = GetCurrentJSContext ( ) ; <NEW_LINE> <START_VULN> if ( ! cx || ! JS_DescribeScriptedCaller ( cx , & script , nullptr ) || ! script ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> return JS_GetScriptUserBit ( script ) ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> nsContentUtils::IsImageSrcSetDisabled ( ) <NEW_LINE> {
ppapi::host::ResourceHost * resource_host_ ; <NEW_LINE> <START_VULN> Delegate * delegate_ ; <NEW_LINE> <END_VULN> PP_DeviceType_Dev device_type_ ; <NEW_LINE> GURL document_url_ ;
yy_size_t yyl ; <NEW_LINE> for ( yyl = 0 ; yyl < yyleng ; ++ yyl ) <NEW_LINE> if ( yytext [ yyl ] == '\n' ) <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> do { yylineno ++ ; <NEW_LINE> yycolumn = 0 ; <NEW_LINE> } while ( 0 )
JS_ASSERT ( ( nb & pool -> mask ) == 0 ) ; <NEW_LINE> <START_VULN> for ( a = pool -> current ; a -> avail + nb > a -> limit ; pool -> current = a ) { <NEW_LINE> <END_VULN> ap = & a -> next ; <NEW_LINE> if ( ! * ap ) {
} <NEW_LINE> template < typename TClientBase > <NEW_LINE> <START_VULN> status_t Camera2ClientBase < TClientBase > ::dump ( int fd , <NEW_LINE> <END_VULN> const Vector < String16 > & args ) { <NEW_LINE> String8 result ; <NEW_LINE> result . appendFormat ( "Camera2ClientBase [ % d ] ( % p ) PID: % d , dump:\n" ,
private: <NEW_LINE> <START_VULN> PasswordAccessoryController * controller_ ; <NEW_LINE> <END_VULN> base::android::ScopedJavaGlobalRef < jobject > java_object_ ;
outHeader -> nFlags = 0 ; <NEW_LINE> outHeader -> nFilledLen = ( outputBufferWidth ( ) * outputBufferHeight ( ) * 3 ) / 2 ; <NEW_LINE> outHeader -> nTimeStamp = * ( OMX_TICKS * ) mImg -> user_priv ; <NEW_LINE> <START_VULN> if ( outHeader -> nAllocLen >= outHeader -> nFilledLen ) { <NEW_LINE> <END_VULN> uint8_t * dst = outHeader -> pBuffer ; <NEW_LINE> const uint8_t * srcY = ( const uint8_t * ) mImg -> planes [ VPX_PLANE_Y ] ; <NEW_LINE> const uint8_t * srcU = ( const uint8_t * ) mImg -> planes [ VPX_PLANE_U ] ;
<START_VULN> ReResolveStyleContext ( aPresContext , outOfFlowFrame , <NEW_LINE>content , aChangeList , <NEW_LINE>NS_SubtractHint ( aMinChange , <NEW_LINE>nsChangeHint_ReflowFrame ) , <NEW_LINE>childRestyleHint , <NEW_LINE>fireAccessibilityEvents , <NEW_LINE>aRestyleTracker ) ; <NEW_LINE> <END_VULN> ReResolveStyleContext ( aPresContext , child , content , <NEW_LINE> aChangeList , aMinChange , <NEW_LINE> childRestyleHint , <NEW_LINE> fireAccessibilityEvents , <NEW_LINE> aRestyleTracker ) ;
wp -> socket_uid = - 1 ; <NEW_LINE> wp -> socket_gid = - 1 ; <NEW_LINE> <START_VULN> wp -> socket_mode = 0666 ; <NEW_LINE> <END_VULN> if ( ! c ) { <NEW_LINE> return 0 ;
qttag != MAKEID ( 'c' , 'o' , '6' , '4' ) && <NEW_LINE> qttag != MAKEID ( 'h' , 'd' , 'l' , 'r' ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <NEW_LINE> <END_VULN> NESTSIZE ( qtsize ) ; <NEW_LINE> }
} <NEW_LINE> DEBUG_PRINT_LOW ( "omx_vdec::update_portdef" ) ; <NEW_LINE> portDefn -> nVersion . nVersion = OMX_SPEC_VERSION ; <NEW_LINE> <START_VULN> portDefn -> nSize = sizeof ( portDefn ) ; <NEW_LINE> <END_VULN> portDefn -> eDomain = OMX_PortDomainVideo ; <NEW_LINE> if ( drv_ctx . frame_rate . fps_denominator > 0 ) <NEW_LINE> portDefn -> format . video . xFramerate = ( drv_ctx . frame_rate . fps_numerator /
{ <NEW_LINE> void * rv ; <NEW_LINE> gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <NEW_LINE> <START_VULN> gdImageWBMPCtx ( im , fg , out ) ; <NEW_LINE>rv = gdDPExtractData ( out , size ) ; <NEW_LINE> <END_VULN> out -> gd_free ( out ) ; <NEW_LINE> return rv ;
vb -> pcm = _vorbis_block_alloc ( vb , sizeof ( * vb -> pcm ) * vi -> channels ) ; <NEW_LINE> for ( i = 0 ; i < vi -> channels ; i ++ ) <NEW_LINE> vb -> pcm [ i ] = _vorbis_block_alloc ( vb , vb -> pcmend * sizeof ( * vb -> pcm [ i ] ) ) ; <NEW_LINE> type = ci -> map_type [ ci -> mode_param [ mode ] -> mapping ] ; <NEW_LINE> return ( _mapping_P [ type ] -> inverse ( vb , ci -> map_param [ ci -> mode_param [ mode ] -> <NEW_LINE> <START_VULN> mapping ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> int vorbis_synthesis_trackonly ( vorbis_block * vb , ogg_packet * op ) { <NEW_LINE> vorbis_dsp_state * vd = vb -> vd ; <NEW_LINE> private_state * b = vd -> backend_state ; <NEW_LINE> vorbis_info * vi = vd -> vi ;
TypeInferenceOracle oracle ; <NEW_LINE> if ( ! oracle . init ( cx , script ) ) <NEW_LINE> return false ; <NEW_LINE> AutoFlushCache afc ( "IonCompile" ) ; <NEW_LINE> types::AutoEnterCompilation enterCompiler ( cx , types::AutoEnterCompilation::Ion ) ; <NEW_LINE> <START_VULN> enterCompiler . init ( script , false , 0 ) ; <NEW_LINE> <END_VULN> AutoTempAllocatorRooter root ( cx , temp ) ; <NEW_LINE> IonBuilder * builder = alloc -> new_ < IonBuilder > ( cx , temp , graph , & oracle , info ) ; <NEW_LINE> if ( ! Compiler ( builder , graph , autoDestroy ) ) { <NEW_LINE> IonSpew ( IonSpew_Abort , "IM Compilation failed . " ) ; <NEW_LINE> return false ; <NEW_LINE> }
PHPAPI pcre * pcre_get_compiled_regex_ex ( char * regex , pcre_extra ** extra , int * preg_options , int * compile_options TSRMLS_DC ) <NEW_LINE> { <NEW_LINE> pcre_cache_entry * pce = pcre_get_compiled_regex_cache ( regex , strlen ( regex ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( extra ) { <NEW_LINE> * extra = pce ? pce -> extra : NULL ; <NEW_LINE> }
MOZ_ASSERT ( cx ) ; <NEW_LINE> nsCOMPtr < nsIScriptGlobalObject > sgo = do_QueryInterface ( GetOwner ( ) ) ; <NEW_LINE> JSObject * ownerObj = sgo -> GetGlobalJSObject ( ) ; <NEW_LINE> NS_ENSURE_TRUE_VOID ( ownerObj ) ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> NS_ENSURE_TRUE_VOID ( pusher . Push ( cx ) ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , ownerObj ) ; <NEW_LINE> JSObject * array = JS_NewArrayObject ( cx , aItems . Length ( ) , nullptr ) ; <NEW_LINE> NS_ENSURE_TRUE_VOID ( array ) ; <NEW_LINE> bool ok ;
nsCOMPtr < nsIScriptContext > context = global -> GetContext ( ) ; <NEW_LINE> if ( context && scope ) { <NEW_LINE> JSContext * cx = context -> GetNativeContext ( ) ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> pusher . Push ( cx ) ; <NEW_LINE> <END_VULN> JSObject * scriptObject = mBoundElement -> GetWrapper ( ) ; <NEW_LINE> if ( scriptObject ) {
yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != '"' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 643 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> size_t len , maxlen ; <NEW_LINE> char * str ;
if ( this_rd < best_rd ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , <NEW_LINE>sizeof ( MB_MODE_INFO ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
desc -> obj = NULL ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> typename Traits::ResolvingIdImpl resolving ( wrapper , id ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( XrayUtils::IsTransparent ( cx , wrapper , id ) ) { <NEW_LINE>JSObject * obj = Traits::getTargetObject ( wrapper ) ; <NEW_LINE> { <NEW_LINE>JSAutoCompartment ac ( cx , obj ) ; <NEW_LINE>if ( ! JS_GetPropertyDescriptorById ( cx , obj , id , flags , desc ) ) <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE>desc -> obj = ( desc -> obj == obj ) ? wrapper . get ( ) : nullptr ; <NEW_LINE>return JS_WrapPropertyDescriptor ( cx , desc ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! Traits::singleton . resolveOwnProperty ( cx , * this , wrapper , holder , id , desc , flags ) ) <NEW_LINE> return false ; <NEW_LINE> if ( desc -> obj ) { <NEW_LINE> desc -> obj = wrapper ; <NEW_LINE> return true ;
memory_info -> blob = NULL ; <NEW_LINE> RelinquishMagickResource ( MapResource , memory_info -> length ) ; <NEW_LINE> if ( * memory_info -> filename != '\0' ) <NEW_LINE> <START_VULN> ( void ) RelinquishUniqueFileResource ( memory_info -> filename ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> } <NEW_LINE> case UnalignedVirtualMemory:
#define LIBRAW_MAJOR_VERSION 0 <NEW_LINE> #define LIBRAW_MINOR_VERSION 15 <NEW_LINE> <START_VULN> #define LIBRAW_PATCH_VERSION 3 <NEW_LINE> <END_VULN> #define LIBRAW_VERSION_TAIL Release <NEW_LINE> #define LIBRAW_SHLIB_CURRENT 9
#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED <NEW_LINE> static void <NEW_LINE> <START_VULN> modifier_current_encoding ( PNG_CONST png_modifier * pm , color_encoding * ce ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( pm -> current_encoding != 0 ) <NEW_LINE> * ce = * pm -> current_encoding ;
setLogicalTop ( lineBottom - ( logicalTop ( ) - lineTop ) - logicalHeight ( ) ) ; <NEW_LINE> for ( InlineBox * curr = firstChild ( ) ; curr ; curr = curr -> nextOnLine ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> renderer ( ) -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( curr -> isInlineFlowBox ( ) )
track_entries [ i ] = track_entries_ [ i ] ; <NEW_LINE> } <NEW_LINE> <START_VULN> delete [ ] track_entries_ ; <NEW_LINE> <END_VULN> if ( track_num == 0 ) {
static void cheby ( float * g , int ord ) { <NEW_LINE> int i , j ; <NEW_LINE> g [ 0 ] *= . 5f ; <NEW_LINE> for ( i = 2 ; i <= ord ; i ++ ) { <NEW_LINE> for ( j = ord ; j >= i ; j -- ) { <NEW_LINE> g [ j - 2 ] - = g [ j ] ; <NEW_LINE> <START_VULN> g [ j ] += g [ j ] ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> static int comp ( const void * a , const void * b ) { <NEW_LINE> return ( * ( float * ) a < * ( float * ) b ) - ( * ( float * ) a > * ( float * ) b ) ; <NEW_LINE> }
const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; <NEW_LINE> const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; <NEW_LINE> const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ; <NEW_LINE> <START_VULN> const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( - cospi_16_64 ) ; <NEW_LINE>const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <NEW_LINE> <END_VULN> const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; <NEW_LINE> const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; <NEW_LINE> const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ;
<START_VULN> if ( transforms & PNG_TRANSFORM_EXPAND ) <NEW_LINE> <END_VULN> #ifdef PNG_READ_EXPAND_SUPPORTED <NEW_LINE> png_set_expand ( png_ptr ) ; <NEW_LINE> #else
reply -> write ( params , size ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> free ( params ) ; <NEW_LINE> <END_VULN> params = NULL ; <NEW_LINE> return NO_ERROR ;
EXTRACT_32BITS ( obj_tptr + 8 ) , <NEW_LINE> EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <NEW_LINE> <START_VULN> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <NEW_LINE> <END_VULN> hexdump = TRUE ; <NEW_LINE> break ;
{ <NEW_LINE> * ( -- dp ) = * ( -- sp ) ; <NEW_LINE> * ( -- dp ) = * ( -- sp ) ; <NEW_LINE> <START_VULN> * ( -- dp ) = hi_filler ; <NEW_LINE> <END_VULN> * ( -- dp ) = lo_filler ; <NEW_LINE> } <NEW_LINE> row_info -> channels = 2 ; <NEW_LINE> row_info -> pixel_depth = 32 ;
if ( kinzi >= 0 && i > base && ( cc & Mymr_CF_AFTER_KINZI ) ) { <NEW_LINE> reordered [ len ] = Mymr_C_NGA ; <NEW_LINE> reordered [ len + 1 ] = Mymr_C_VIRAMA ; <NEW_LINE> <START_VULN> properties [ len - 1 ] = AboveForm ; <NEW_LINE> <END_VULN> properties [ len ] = AboveForm ; <NEW_LINE> len += 2 ; <NEW_LINE> kinzi = - 1 ;
if ( info_ptr != NULL ) <NEW_LINE> { <NEW_LINE> png_controlp control = png_voidcast ( png_controlp , <NEW_LINE> <START_VULN> png_malloc_warn ( png_ptr , ( sizeof * control ) ) ) ; <NEW_LINE> <END_VULN> if ( control != NULL ) <NEW_LINE> {
{ <NEW_LINE> * q ++ = ( unsigned char ) ( GetPixelLuma ( image , p ) >= ( QuantumRange / 2 . 0 ) ? <NEW_LINE> '0' : '1' ) ; <NEW_LINE> <START_VULN> * q ++ = ' ' ; <NEW_LINE> <END_VULN> if ( ( q - pixels + 1 ) >= ( ssize_t ) sizeof ( pixels ) ) <NEW_LINE> { <NEW_LINE> * q ++ = '\n' ; <NEW_LINE> ( void ) WriteBlob ( image , q - pixels , pixels ) ; <NEW_LINE> q = pixels ; <NEW_LINE> } <NEW_LINE> p ++ ; <NEW_LINE> } <NEW_LINE> * q ++ = '\n' ;
{ <NEW_LINE> int i , count = 0 ; <NEW_LINE> int * key_sizes ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> MCRYPT_GET_MODE_DIR_ARGS ( algorithms_dir ) <NEW_LINE> array_init ( return_value ) ;
virtual void SetHtml ( const base::string16 & html , const GURL & base_url ) ; <NEW_LINE> virtual bool GetString ( base::string16 * data ) const ; <NEW_LINE> <START_VULN> virtual bool GetURLAndTitle ( GURL * url , base::string16 * title ) const ; <NEW_LINE> <END_VULN> virtual bool GetFilename ( base::FilePath * path ) const ; <NEW_LINE> virtual bool GetFilenames ( <NEW_LINE> std::vector < OSExchangeData::FileInfo > * filenames ) const ;
JSContext * cx ; <NEW_LINE> nsXPConnect * xpc = nsXPConnect::GetXPConnect ( ) ; <NEW_LINE> if ( ! xpc || NS_FAILED ( xpc -> GetSafeJSContext ( & cx ) ) || ! cx ) { <NEW_LINE> NS_ERROR ( "Failed to get safe JSContext ! " ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSTracer trc ; <NEW_LINE> <END_VULN> JS_TracerInit ( & trc , cx , UnmarkGrayChildren ) ; <NEW_LINE> JS_TraceChildren ( & trc , obj , JSTRACE_OBJECT ) ; <NEW_LINE> } <NEW_LINE> struct TraversalTracer : public JSTracer <NEW_LINE> { <NEW_LINE> TraversalTracer ( nsCycleCollectionTraversalCallback & aCb ) : cb ( aCb ) <NEW_LINE> {
goto out ; <NEW_LINE> address = trans_exc_code & __FAIL_ADDR_MASK ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN> flags = FAULT_FLAG_ALLOW_RETRY ; <NEW_LINE> if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) <NEW_LINE> flags |= FAULT_FLAG_WRITE ;
NS_IMETHODIMP <NEW_LINE> nsWindow::CaptureRollupEvents ( nsIRollupListener * aListener , <NEW_LINE> PRBool aDoCapture , <NEW_LINE> PRBool aConsumeRollupEvent ) <NEW_LINE> { <NEW_LINE> if ( ! mDrawingarea ) <NEW_LINE> return NS_OK ; <NEW_LINE> <START_VULN> GtkWidget * widget = <NEW_LINE>get_gtk_widget_for_gdk_window ( mDrawingarea -> inner_window ) ; <NEW_LINE> <END_VULN> LOG ( ( "CaptureRollupEvents % p\n" , ( void * ) this ) ) ; <NEW_LINE> if ( aDoCapture ) { <NEW_LINE> gConsumeRollupEvent = aConsumeRollupEvent ; <NEW_LINE> gRollupListener = aListener ; <NEW_LINE> gRollupWindow = do_GetWeakReference ( static_cast < nsIWidget * > <NEW_LINE> ( this ) ) ;
if ( ! rt -> isHeapMinorCollecting ( ) ) { <NEW_LINE> for ( CompartmentsIter c ( rt , SkipAtoms ) ; ! c . done ( ) ; c . next ( ) ) <NEW_LINE> <START_VULN> c -> mark ( trc ) ; <NEW_LINE> <END_VULN>
} <NEW_LINE> <START_VULN> class ScopedZxHandle <NEW_LINE> <END_VULN> : public ScopedGeneric < zx_handle_t , internal::ScopedZxHandleTraits > { <NEW_LINE> public: <NEW_LINE> ScopedZxHandle ( ) = default ;
return cost ; <NEW_LINE> } <NEW_LINE> <START_VULN> void vp9_cost_tokens ( int * costs , const vp9_prob * probs , vp9_tree tree ) ; <NEW_LINE>void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) ; <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> }
aAttribute == nsGkAtoms::properties || <NEW_LINE> aAttribute == nsGkAtoms::mode || <NEW_LINE> aAttribute == nsGkAtoms::src || <NEW_LINE> aAttribute == nsGkAtoms::value || <NEW_LINE> aAttribute == nsGkAtoms::label ) { <NEW_LINE> nsIContent * parent = aContent -> GetParent ( ) ; <NEW_LINE> if ( parent ) { <NEW_LINE> nsCOMPtr < nsIContent > grandParent = parent -> GetParent ( ) ; <NEW_LINE> <START_VULN> if ( grandParent ) { <NEW_LINE> <END_VULN> PRInt32 index = FindContent ( grandParent ) ; <NEW_LINE> if ( index >= 0 && mBoxObject ) { <NEW_LINE> mBoxObject -> InvalidateRow ( index ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
png_uint_16 PNGAPI <NEW_LINE> png_get_uint_16 ( png_bytep buf ) <NEW_LINE> { <NEW_LINE> <START_VULN> png_uint_16 i = ( png_uint_16 ) ( ( ( png_uint_16 ) ( * buf ) << 8 ) + <NEW_LINE> ( png_uint_16 ) ( * ( buf + 1 ) ) ) ; <NEW_LINE> <END_VULN> return ( i ) ; <NEW_LINE> }
#include < utility > <NEW_LINE> #include < vector > <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "mojo / public / cpp / bindings / lib / array_internal . h" <NEW_LINE> #include "mojo / public / cpp / bindings / lib / bindings_internal . h" <NEW_LINE> #include "mojo / public / cpp / bindings / lib / template_util . h"
saddr = ipc . addr ; <NEW_LINE> ipc . addr = daddr ; <NEW_LINE> <START_VULN> if ( ! ipc . opt ) <NEW_LINE>ipc . opt = inet -> opt ; <NEW_LINE> <END_VULN> if ( ipc . opt ) { <NEW_LINE> err = - EINVAL ;
if ( m_out_mem_ptr ) { <NEW_LINE> DEBUG_PRINT_LOW ( "Freeing the Output Memory" ) ; <NEW_LINE> for ( i = 0 ; i < m_sOutPortDef . nBufferCountActual ; i ++ ) { <NEW_LINE> <START_VULN> free_output_buffer ( & m_out_mem_ptr [ i ] ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> free ( m_out_mem_ptr ) ; <NEW_LINE> m_out_mem_ptr = NULL ;
ZVAL_BOOL ( rval , parse_iv ( start + 2 ) ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1228 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy87: <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> #line 573 "ext / standard / var_unserializer . re"
int result = 0 ; <NEW_LINE> char sig_on = btif_hl_signal_select_exit ; <NEW_LINE> BTIF_TRACE_DEBUG ( "btif_hl_signal_select_exit" ) ; <NEW_LINE> <START_VULN> result = send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <NEW_LINE> <END_VULN> if ( btif_is_enabled ( ) ) <NEW_LINE> {
dh -> dccph_checksum = dccp_v6_csum_finish ( skb , & np -> saddr , & np -> daddr ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static inline __u32 secure_dccpv6_sequence_number ( __be32 * saddr , __be32 * daddr , <NEW_LINE>__be16 sport , __be16 dport ) <NEW_LINE> { <NEW_LINE>return secure_tcpv6_sequence_number ( saddr , daddr , sport , dport ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>static inline __u32 dccp_v6_init_sequence ( struct sk_buff * skb ) <NEW_LINE> <END_VULN> { <NEW_LINE> return secure_dccpv6_sequence_number ( ipv6_hdr ( skb ) -> daddr . s6_addr32 , <NEW_LINE> ipv6_hdr ( skb ) -> saddr . s6_addr32 ,
<START_VULN> <NEW_LINE> <END_VULN> #line 1 "ext / standard / var_unserializer . re" <NEW_LINE> + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- +
JSValue JSDirectoryEntry::getDirectory ( ExecState * exec ) <NEW_LINE> { <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> DirectoryEntry * imp = static_cast < DirectoryEntry * > ( impl ( ) ) ; <NEW_LINE> const String & path = valueToStringWithUndefinedOrNullCheck ( exec , exec -> argument ( 0 ) ) ;
& resource_is_empty ) ; <NEW_LINE> InspectorPageAgent::ResourceType type = <NEW_LINE> <START_VULN> cached_resource ? InspectorPageAgent::CachedResourceType ( * cached_resource ) <NEW_LINE>: InspectorPageAgent::kOtherResource ; <NEW_LINE> <END_VULN> InspectorPageAgent::ResourceType saved_type = <NEW_LINE> resources_data_ -> GetResourceType ( request_id ) ;
buffer [ iout ] = '\0' ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #if defined ( PNG_READ_SUPPORTED ) && defined ( PNG_ERROR_TEXT_SUPPORTED ) <NEW_LINE> PNG_FUNCTION ( void , PNGAPI
bool user_gesture , <NEW_LINE> bool last_unlocked_by_target , <NEW_LINE> bool privileged ) override ; <NEW_LINE> <START_VULN> bool IsFullscreenForCurrentTab ( ) const override ; <NEW_LINE> <END_VULN> blink::WebDisplayMode GetDisplayMode ( <NEW_LINE> RenderWidgetHostImpl * render_widget_host ) const override ; <NEW_LINE> void LostCapture ( RenderWidgetHostImpl * render_widget_host ) override ;
#define MAX_PERIODICITY VPX_TS_MAX_PERIODICITY <NEW_LINE> <START_VULN> <NEW_LINE>#define MAX_LAYERS VPX_TS_MAX_LAYERS <NEW_LINE> <END_VULN> #define VPX_SS_MAX_LAYERS 5
if ( p -> trtp ) { <NEW_LINE> <START_VULN> if ( tportno > 0 ) { <NEW_LINE> <END_VULN> ast_sockaddr_set_port ( tsa , tportno ) ; <NEW_LINE> ast_rtp_instance_set_remote_address ( p -> trtp , tsa ) ; <NEW_LINE> if ( debug ) {
if ( ( offset + 1 + ip6_optlen ) > optslen ) { <NEW_LINE> <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> }
ZEND_ARG_INFO ( 0 , pattern ) <NEW_LINE> ZEND_ARG_INFO ( 0 , subject ) <NEW_LINE> ZEND_ARG_INFO ( 0 , limit ) <NEW_LINE> <START_VULN> ZEND_ARG_INFO ( 0 , flags ) <NEW_LINE> <END_VULN> ZEND_END_ARG_INFO ( ) <NEW_LINE> ZEND_BEGIN_ARG_INFO_EX ( arginfo_preg_quote , 0 , 0 , 1 )
memmove ( vp + 1 , vp + 2 , argc * sizeof ( jsval ) ) ; <NEW_LINE> if ( ! js_ComputeThis ( cx , vp + 2 ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( argc != 0 ) { <NEW_LINE><NEW_LINE>vp [ 2 + -- argc ] = JSVAL_VOID ; <NEW_LINE> } <NEW_LINE> <END_VULN> native = <NEW_LINE> #ifdef JS_TRACER <NEW_LINE> ( fs -> flags & JSFUN_TRCINFO ) <NEW_LINE> ? JS_FUNC_TO_DATA_PTR ( JSNativeTraceInfo * , fs -> call ) -> native <NEW_LINE> : <NEW_LINE> #endif <NEW_LINE> ( JSFastNative ) fs -> call ;
zend_module_entry mcrypt_module_entry = { <NEW_LINE> STANDARD_MODULE_HEADER , <NEW_LINE> <START_VULN> "mcrypt" , <NEW_LINE> <END_VULN> mcrypt_functions , <NEW_LINE> PHP_MINIT ( mcrypt ) , PHP_MSHUTDOWN ( mcrypt ) , <NEW_LINE> NULL , NULL ,
return false ; <NEW_LINE> <START_VULN> uint64 size = EbmlElementSize ( kMkvSamplingFrequency , <NEW_LINE>static_cast < float > ( sample_rate_ ) ) ; <NEW_LINE> <END_VULN> size += EbmlElementSize ( kMkvChannels , channels_ ) ; <NEW_LINE> if ( bit_depth_ > 0 ) <NEW_LINE> size += EbmlElementSize ( kMkvBitDepth , bit_depth_ ) ;
void ErrorInvalidEnumInfo ( const char * info , WebGLenum enumvalue ) { <NEW_LINE> return ErrorInvalidEnum ( " % s: invalid enum value 0x % x" , info , enumvalue ) ; <NEW_LINE> } <NEW_LINE> void ErrorOutOfMemory ( const char * fmt = 0 , . . . ) ; <NEW_LINE> const char * ErrorName ( GLenum error ) ; <NEW_LINE> bool IsTextureFormatCompressed ( GLenum format ) ; <NEW_LINE> <START_VULN> void DummyFramebufferOperation ( const char * info ) ; <NEW_LINE> <END_VULN> WebGLTexture * activeBoundTextureForTarget ( WebGLenum target ) { <NEW_LINE> return target == LOCAL_GL_TEXTURE_2D ? mBound2DTextures [ mActiveTexture ] <NEW_LINE> : mBoundCubeMapTextures [ mActiveTexture ] ; <NEW_LINE> } <NEW_LINE> already_AddRefed < CanvasLayer > GetCanvasLayer ( nsDisplayListBuilder * aBuilder , <NEW_LINE> CanvasLayer * aOldLayer ,
} <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> void <NEW_LINE> nsPluginInstanceOwner::NotifyHostAsyncInitFailed ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsCOMPtr < nsIObjectLoadingContent > content = do_QueryInterface ( mContent ) ; <NEW_LINE> <END_VULN> content -> StopPluginInstance ( ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsPluginInstanceOwner::NotifyHostCreateWidget ( ) <NEW_LINE> { <NEW_LINE> mPluginHost -> CreateWidget ( this ) ; <NEW_LINE> #ifdef XP_MACOSX
sent = ( * ss -> sec . send ) ( ss , msg , sendLen , 0 ) ; <NEW_LINE> if ( sent < 0 ) { <NEW_LINE> if ( ss -> sec . uncache ) <NEW_LINE> ( * ss -> sec . uncache ) ( sid ) ; <NEW_LINE> rv = ( SECStatus ) sent ; <NEW_LINE> } else if ( ! ss -> opt . noCache ) { <NEW_LINE> <START_VULN> <NEW_LINE> ( * ss -> sec . cache ) ( sid ) ; <NEW_LINE> <END_VULN> rv = SECSuccess ; <NEW_LINE> } <NEW_LINE> ssl_FreeSID ( sid ) ; <NEW_LINE> ss -> sec . ci . sid = 0 ; <NEW_LINE> } <NEW_LINE> done: <NEW_LINE> ssl_ReleaseXmitBufLock ( ss ) ; <NEW_LINE> return rv ;
#ifdef PNG_READ_tRNS_SUPPORTED <NEW_LINE> else if ( chunk_name == png_tRNS ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_tRNS ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
if ( status < 0 ) <NEW_LINE> return status ; <NEW_LINE> <START_VULN> assert ( ( total < 0 ) || ( avail <= total ) ) ; <NEW_LINE> <END_VULN> const long long segment_stop = ( m_size < 0 ) ? - 1 : m_start + m_size ;
#define free ( ptr ) hunspell_free ( ptr ) <NEW_LINE> inline void * hunspell_realloc ( void * ptr , size_t size ) <NEW_LINE> { <NEW_LINE> HunspellReportMemoryDeallocation ( ptr ) ; <NEW_LINE> void * result = moz_realloc ( ptr , size ) ; <NEW_LINE> if ( result ) { <NEW_LINE> HunspellReportMemoryAllocation ( result ) ; <NEW_LINE> <START_VULN> } else { <NEW_LINE> <END_VULN> HunspellReportMemoryAllocation ( ptr ) ; <NEW_LINE> } <NEW_LINE> return result ; <NEW_LINE> } <NEW_LINE> #define realloc ( ptr , size ) hunspell_realloc ( ptr , size ) <NEW_LINE> inline char * hunspell_strdup ( const char * str )
virtual bool DidLoadingProgress ( ) = 0 ; <NEW_LINE> <START_VULN> virtual bool DidGetOpaqueResponseFromServiceWorker ( ) const = 0 ; <NEW_LINE>virtual bool HasSingleSecurityOrigin ( ) const = 0 ; <NEW_LINE>virtual bool DidPassCORSAccessCheck ( ) const = 0 ; <NEW_LINE> <END_VULN> virtual double MediaTimeForTimeValue ( double time_value ) const = 0 ;
char * <NEW_LINE> guestfs___first_line_of_file ( guestfs_h * g , const char * filename ) <NEW_LINE> { <NEW_LINE> <START_VULN> CLEANUP_FREE char ** lines = NULL ; <NEW_LINE> <END_VULN> int64_t size ; <NEW_LINE> char * ret ;
return MagickFalse ; <NEW_LINE> } <NEW_LINE> <START_VULN> SkipRGBMipmaps ( image , dds_info , 3 ) ; <NEW_LINE><NEW_LINE>return MagickTrue ; <NEW_LINE> <END_VULN> } <NEW_LINE> static MagickBooleanType ReadUncompressedRGBA ( Image * image , DDSInfo * dds_info ,
else <NEW_LINE> running_avg_y [ c ] = sig [ c ] + adjustment ; <NEW_LINE> <START_VULN> sum_diff += adjustment ; <NEW_LINE> <END_VULN> } <NEW_LINE> else <NEW_LINE> {
return ( KDC_ERR_MUST_USE_USER2USER ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) { <NEW_LINE> <END_VULN> * status = "ANONYMOUS NOT ALLOWED" ; <NEW_LINE> return ( KDC_ERR_POLICY ) ; <NEW_LINE> }
obj = js::UnwrapObject ( obj ) ; <NEW_LINE> JS_ASSERT ( js::GetObjectClass ( obj ) -> ext . innerObject ) ; <NEW_LINE> } <NEW_LINE> obj = JS_ObjectToInnerObject ( cx , obj ) ; <NEW_LINE> <START_VULN> return obj && <NEW_LINE> ( subsumes ( js::GetObjectCompartment ( wrapper ) , <NEW_LINE>js::GetObjectCompartment ( obj ) ) || <NEW_LINE>documentDomainMakesSameOrigin ( cx , obj ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> AccessCheck::isChrome ( JSCompartment * compartment ) <NEW_LINE> { <NEW_LINE> nsIScriptSecurityManager * ssm = XPCWrapper::GetSecurityManager ( ) ; <NEW_LINE> if ( ! ssm ) { <NEW_LINE> return false ;
LayoutUnit LayoutGrid::availableAlignmentSpaceForChildBeforeStretching ( LayoutUnit gridAreaBreadthForChild , const LayoutBox & child ) const <NEW_LINE> { <NEW_LINE> <START_VULN> LayoutUnit childMarginLogicalHeight = marginLogicalHeightForChild ( child ) ; <NEW_LINE><NEW_LINE>if ( childMarginLogicalHeight == 0 ) <NEW_LINE>childMarginLogicalHeight = computeMarginLogicalHeightForChild ( child ) ; <NEW_LINE><NEW_LINE>return gridAreaBreadthForChild - childMarginLogicalHeight ; <NEW_LINE> <END_VULN> }
const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; <NEW_LINE> unsigned int len ; <NEW_LINE> <START_VULN> ND_TCHECK ( * ext ) ; <NEW_LINE> <END_VULN> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; <NEW_LINE> ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; <NEW_LINE> len = ntohs ( a . h . len ) ;
ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 ) <NEW_LINE> <START_VULN> "Unknown Transfer - Encoding: % s ; " <NEW_LINE>" using read - until - close" , tenc ) ; <NEW_LINE> <END_VULN> tenc = NULL ; <NEW_LINE> } <NEW_LINE> else {
ContextGL ( ) -> ClearStencil ( clear_stencil_ ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void WebGLRenderingContextBase::DrawingBufferClientRestorePixelPackAlignment ( ) { <NEW_LINE> <END_VULN> if ( ! ContextGL ( ) ) <NEW_LINE> return ; <NEW_LINE> ContextGL ( ) -> PixelStorei ( GL_PACK_ALIGNMENT , pack_alignment_ ) ;
class RTCSessionDescriptionRequestImpl : public RTCSessionDescriptionRequest , public ActiveDOMObject { <NEW_LINE> public: <NEW_LINE> <START_VULN> static PassRefPtr < RTCSessionDescriptionRequestImpl > create ( ScriptExecutionContext * , PassRefPtr < RTCSessionDescriptionCallback > , PassRefPtr < RTCErrorCallback > ) ; <NEW_LINE> <END_VULN> virtual ~ RTCSessionDescriptionRequestImpl ( ) ; <NEW_LINE> virtual void requestSucceeded ( PassRefPtr < RTCSessionDescriptionDescriptor > ) OVERRIDE ;
#include < limits . h > <NEW_LINE> #include "args . h" <NEW_LINE> <START_VULN> #ifdef _MSC_VER <NEW_LINE>#define snprintf _snprintf <NEW_LINE>#endif <NEW_LINE> <END_VULN> #if defined ( __GNUC__ ) && __GNUC__ <NEW_LINE> extern void die ( const char * fmt , . . . ) __attribute__ ( ( noreturn ) ) ;
for ( r = 0 ; r < 16 ; r ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memset ( ypred_ptr , yleft_col [ r ] , 16 ) ; <NEW_LINE> <END_VULN> ypred_ptr += y_stride ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> FileManager::Init ( nsIFile * aDirectory , <NEW_LINE> mozIStorageConnection * aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( aDirectory , "Null directory ! " ) ; <NEW_LINE> NS_ASSERTION ( aConnection , "Null connection ! " ) ; <NEW_LINE> mFileInfos . Init ( ) ; <NEW_LINE> bool exists ; <NEW_LINE> nsresult rv = aDirectory -> Exists ( & exists ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
ion::ForbidCompilation ( cx , script ) ; <NEW_LINE> #endif <NEW_LINE> vp . setObject ( * argsobj ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> #ifdef JS_METHODJIT <NEW_LINE> <START_VULN> StackFrame * fp = iter . fp ( ) ; <NEW_LINE>if ( iter . isScript ( ) && iter . isIon ( ) ) <NEW_LINE>fp = NULL ; <NEW_LINE> <END_VULN> if ( JSID_IS_ATOM ( id , cx -> names ( ) . caller ) && fp && fp -> prev ( ) ) { <NEW_LINE> InlinedSite * inlined ;
int allow_skip_recode ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>LAST_FRAME_PARTITION_METHOD use_lastframe_partitioning ; <NEW_LINE> <END_VULN>
MODE_INFO ** mi_8x8 , const int mode_info_stride , <NEW_LINE> LOOP_FILTER_MASK * lfm ) ; <NEW_LINE> <START_VULN> void vp9_filter_block_plane ( struct VP9Common * const cm , <NEW_LINE>struct macroblockd_plane * const plane , <NEW_LINE>int mi_row , <NEW_LINE>LOOP_FILTER_MASK * lfm ) ; <NEW_LINE> <END_VULN> void vp9_loop_filter_init ( struct VP9Common * cm ) ;
help prevent buffer overflows and other potential security traps . <NEW_LINE> @defgroup WebsRuntime WebsRuntime <NEW_LINE> @see fmt wallocHandle wallocObject wfreeHandle hextoi itosbuf scaselesscmp scaselessmatch <NEW_LINE> <START_VULN> sclone scmp scopy sfmt sfmtv slen slower smatch sncaselesscmp sncmp sncopy stok strim supper <NEW_LINE> <END_VULN> @stability Stable
return E_FILE_FORMAT_INVALID ; <NEW_LINE> } else if ( id == 0x7E2 ) { <NEW_LINE> <START_VULN> delete [ ] encryption -> key_id ; <NEW_LINE> <END_VULN> encryption -> key_id = NULL ; <NEW_LINE> encryption -> key_id_len = 0 ;
static nsresult <NEW_LINE> cryptojs_ReadArgsAndGenerateKey ( JSContext * cx , <NEW_LINE> JS::Value * argv , <NEW_LINE> nsKeyPairInfo * keyGenType , <NEW_LINE> nsIInterfaceRequestor * uiCxt , <NEW_LINE> PK11SlotInfo ** slot , bool willEscrow ) <NEW_LINE> { <NEW_LINE> JSString * jsString ; <NEW_LINE> <START_VULN> JSAutoByteString params , keyGenAlg ; <NEW_LINE> <END_VULN> int keySize ; <NEW_LINE> nsresult rv ; <NEW_LINE> if ( ! JSVAL_IS_INT ( argv [ 0 ] ) ) { <NEW_LINE> JS_ReportError ( cx , " % s % s" , JS_ERROR , <NEW_LINE> "passed in non - integer for key size" ) ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> }
#ifndef imgStatusTracker_h__ <NEW_LINE> #define imgStatusTracker_h__ <NEW_LINE> class imgDecoderObserver ; <NEW_LINE> class imgIContainer ; <NEW_LINE> <START_VULN> class imgRequestProxy ; <NEW_LINE> <END_VULN> class imgStatusNotifyRunnable ; <NEW_LINE> class imgRequestNotifyRunnable ; <NEW_LINE> class imgStatusTrackerObserver ; <NEW_LINE> class imgStatusTrackerNotifyingObserver ; <NEW_LINE> class nsIRunnable ; <NEW_LINE> #include "mozilla / RefPtr . h" <NEW_LINE> #include "nsCOMPtr . h" <NEW_LINE> #include "nsTObserverArray . h" <NEW_LINE> #include "nsRect . h" <NEW_LINE> namespace mozilla { <NEW_LINE> namespace image { <NEW_LINE> class Image ; <NEW_LINE> struct ImageStatusDiff <NEW_LINE> {
while ( curr && curr != renderView ) { <NEW_LINE> if ( curr -> hasColumns ( ) || curr -> isRenderFlowThread ( ) ) <NEW_LINE> return true ; <NEW_LINE> <START_VULN> if ( curr -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> curr = curr -> containingBlock ( ) ; <NEW_LINE> }
{ <NEW_LINE> int flag [ 2 ] = { 1 , 1 } ; <NEW_LINE> vp8_initialize_rd_consts ( cpi , x , vp8_dc_quant ( cm -> base_qindex , cm -> y1dc_delta_q ) ) ; <NEW_LINE> <START_VULN> vpx_memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <NEW_LINE> <END_VULN> vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cm -> fc . mvc , flag ) ; <NEW_LINE> }
@param child JSON child to remove <NEW_LINE> @return The removed child element . <NEW_LINE> @ingroup MprJson <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC MprJson * mprRemoveJsonChild ( MprJson * obj , MprJson * child ) ;
png_debug ( 1 , "in png_do_read_intrapixel" ) ; <NEW_LINE> if ( <NEW_LINE> <START_VULN> ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> int bytes_per_pixel ; <NEW_LINE> png_uint_32 row_width = row_info -> width ;
status_t NuPlayer::GenericSource::setBuffers ( <NEW_LINE> bool audio , Vector < MediaBuffer * > & buffers ) { <NEW_LINE> <START_VULN> if ( mIsWidevine && ! audio && mVideoTrack . mSource != NULL ) { <NEW_LINE> <END_VULN> return mVideoTrack . mSource -> setBuffers ( buffers ) ; <NEW_LINE> } <NEW_LINE> return INVALID_OPERATION ;
setHasTextDescendantsOnAncestors ( this ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( descendantsHaveSameLineHeightAndBaseline ( ) && ! child -> renderer ( ) -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> RenderStyle * parentStyle = renderer ( ) -> style ( isFirstLineStyle ( ) ) ; <NEW_LINE> RenderStyle * childStyle = child -> renderer ( ) -> style ( isFirstLineStyle ( ) ) ; <NEW_LINE> bool shouldClearDescendantsHaveSameLineHeightAndBaseline = false ;
#include "compiler / OutputGLSL . h" <NEW_LINE> <START_VULN> #include "compiler / debug . h" <NEW_LINE> <END_VULN> namespace <NEW_LINE> { <NEW_LINE> TString getTypeName ( const TType & type ) <NEW_LINE> { <NEW_LINE> TInfoSinkBase out ; <NEW_LINE> if ( type . isMatrix ( ) ) <NEW_LINE> {
for ( RenderBox * child = firstChildBox ( ) ; child ; child = child -> nextSiblingBox ( ) ) { <NEW_LINE> orderValues . add ( child -> style ( ) -> order ( ) ) ; <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> child -> clearOverrideSize ( ) ;
nsIScriptContext * scriptContext ) <NEW_LINE> : mWrapper ( wrapper ) , <NEW_LINE> mContext ( scriptContext ) <NEW_LINE> { <NEW_LINE> } <NEW_LINE> NS_IMETHOD Run ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> JSContext * cx = nullptr ; <NEW_LINE>if ( mContext ) { <NEW_LINE>cx = mContext -> GetNativeContext ( ) ; <NEW_LINE> } else { <NEW_LINE>nsCOMPtr < nsIThreadJSContextStack > stack = <NEW_LINE>do_GetService ( "@mozilla . org / js / xpc / ContextStack ; 1" ) ; <NEW_LINE>NS_ENSURE_TRUE ( stack , NS_OK ) ; <NEW_LINE><NEW_LINE>cx = stack -> GetSafeJSContext ( ) ; <NEW_LINE>NS_ENSURE_TRUE ( cx , NS_OK ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> JSObject * obj = nullptr ; <NEW_LINE> mWrapper -> GetJSObject ( & obj ) ; <NEW_LINE> NS_ASSERTION ( obj , "Should never be null" ) ; <NEW_LINE> nsHTMLPluginObjElementSH::SetupProtoChain ( mWrapper , cx , obj ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> break ; <NEW_LINE> <START_VULN> } ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> } else if ( best_address == in_what ) { <NEW_LINE> ( * num00 ) ++ ;
#if CONFIG_DECODERS <NEW_LINE> if ( global -> test_decode != TEST_DECODE_OFF ) { <NEW_LINE> const VpxInterface * decoder = get_vpx_decoder_by_name ( global -> codec -> name ) ; <NEW_LINE> <START_VULN> vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif <NEW_LINE> }
mscfs_check_cache ( priv -> fs ) ; <NEW_LINE> for ( x = 0 ; x < fs -> cache . size ; x ++ ) { <NEW_LINE> <START_VULN> u8 * oid = fs -> cache . array [ x ] . objectId . id ; <NEW_LINE> <END_VULN> sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , <NEW_LINE> "FILE: % 02X % 02X % 02X % 02X\n" , <NEW_LINE> oid [ 0 ] , oid [ 1 ] , oid [ 2 ] , oid [ 3 ] ) ;
perf_sample_data_init ( & data , addr ) ; <NEW_LINE> <START_VULN> do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , nmi , & data , regs ) ; <NEW_LINE> <END_VULN> perf_swevent_put_recursion_context ( rctx ) ; <NEW_LINE> preempt_enable_notrace ( ) ;
PluginInstanceChild::NPN_NewStream ( NPMIMEType aMIMEType , const char * aWindow , <NEW_LINE> NPStream ** aStream ) <NEW_LINE> { <NEW_LINE> AssertPluginThread ( ) ; <NEW_LINE> PluginStreamChild * ps = new PluginStreamChild ( ) ; <NEW_LINE> NPError result ; <NEW_LINE> <START_VULN> CallPPluginStreamConstructor ( ps , nsDependentCString ( aMIMEType ) , <NEW_LINE>NullableString ( aWindow ) , & result ) ; <NEW_LINE> <END_VULN> if ( NPERR_NO_ERROR != result ) { <NEW_LINE> * aStream = NULL ; <NEW_LINE> PPluginStreamChild::Call__delete__ ( ps , NPERR_GENERIC_ERROR , true ) ; <NEW_LINE> return result ; <NEW_LINE> } <NEW_LINE> * aStream = & ps -> mStream ; <NEW_LINE> return NPERR_NO_ERROR ;
return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> js::Rooted < JS::Value > v ( cx , <NEW_LINE>args . length ( ) > 0 ? args [ 0 ] : JS::UndefinedValue ( ) ) ; <NEW_LINE>return JS_SetPropertyById ( cx , thisObj , id , v . address ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static JSBool
static int <NEW_LINE> tiffcp ( TIFF * in , TIFF * out ) <NEW_LINE> { <NEW_LINE> <START_VULN> uint16 bitspersample , samplesperpixel ; <NEW_LINE>uint16 input_compression , input_photometric ; <NEW_LINE> <END_VULN> copyFunc cf ; <NEW_LINE> uint32 width , length ; <NEW_LINE> struct cpTag * p ;
if ( NS_FAILED ( js . error ) ) <NEW_LINE> return js . error ; <NEW_LINE> <START_VULN> if ( mCanvasElement -> IsWriteOnly ( ) && ! nsContentUtils::IsCallerTrustedForRead ( ) ) { <NEW_LINE> <END_VULN> LogMessage ( "ReadPixels: Not allowed" ) ; <NEW_LINE> return NS_ERROR_DOM_SECURITY_ERR ; <NEW_LINE> }
fprintf ( stderr , " or: . . . | pnm2png [ options ] \n" ) ; <NEW_LINE> fprintf ( stderr , "Options:\n" ) ; <NEW_LINE> fprintf ( stderr , " - i [ nterlace ] write png - file with interlacing on\n" ) ; <NEW_LINE> <START_VULN> fprintf ( stderr , " - a [ lpha ] < file > . pgm read PNG alpha channel as pgm - file\n" ) ; <NEW_LINE> <END_VULN> fprintf ( stderr , " - h | - ? print this help - information\n" ) ; <NEW_LINE> }
if ( ! aLineLayout . GetLineEndsInBR ( ) ) { <NEW_LINE> aLine -> SetLineWrapped ( PR_TRUE ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! ( frameReflowStatus & NS_INLINE_BREAK_FIRST_LETTER_COMPLETE ) && <NEW_LINE>nsGkAtoms::placeholderFrame != frameType ) { <NEW_LINE> <END_VULN> * aLineReflowStatus = LINE_REFLOW_STOP ; <NEW_LINE> rv = SplitLine ( aState , aLineLayout , aLine , aFrame -> GetNextSibling ( ) , aLineReflowStatus ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return NS_OK ;
file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; <NEW_LINE> break ; <NEW_LINE> case 0x84: <NEW_LINE> <START_VULN> memcpy ( file -> name , d , len ) ; <NEW_LINE>file -> namelen = len ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x86: <NEW_LINE> sc_file_set_sec_attr ( file , d , len ) ;
} <NEW_LINE> unlock_sock_fast ( sk , slow ) ; <NEW_LINE> <START_VULN> if ( noblock ) <NEW_LINE>return - EAGAIN ; <NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> msg -> msg_flags &= ~ MSG_TRUNC ; <NEW_LINE> goto try_again ; <NEW_LINE> } <NEW_LINE> commit beb39db59d14990e401e235faf66a6b9b31240b0 <NEW_LINE> Author: Eric Dumazet < edumazet@google . com > <NEW_LINE> Date: Sat May 30 09:16:53 2015 - 0700 <NEW_LINE> udp: fix behavior of wrong checksums <NEW_LINE> We have two problems in UDP stack related to bogus checksums : <NEW_LINE> 1 ) We return - EAGAIN to application even if receive queue is not empty . <NEW_LINE> This breaks applications using edge trigger epoll ( ) <NEW_LINE> 2 ) Under UDP flood , we can loop forever without yielding to other <NEW_LINE> processes , potentially hanging the host , especially on non SMP . <NEW_LINE> This patch is an attempt to make things better . <NEW_LINE> We might in the future add extra support for rt applications <NEW_LINE> wanting to better control time spent doing a recv ( ) in a hostile <NEW_LINE> environment . For example we could validate checksums before queuing <NEW_LINE> packets in socket receive queue . <NEW_LINE> Signed - off - by: Eric Dumazet < edumazet@google . com > <NEW_LINE>
modifier *= modifier ; <NEW_LINE> modifier *= 3 ; <NEW_LINE> <START_VULN> modifier += 1 << ( strength - 1 ) ; <NEW_LINE> <END_VULN> modifier >> = strength ; <NEW_LINE> if ( modifier > 16 )
} <NEW_LINE> break ; <NEW_LINE> default: <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> <START_VULN> rv = UpdateDB ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> mDownloadManager -> NotifyListenersOnDownloadStateChange ( oldState , this ) ; <NEW_LINE> switch ( mDownloadState ) { <NEW_LINE> case nsIDownloadManager::DOWNLOAD_DOWNLOADING: <NEW_LINE> if ( oldState == nsIDownloadManager::DOWNLOAD_QUEUED )
sarrayDestroy ( & gplot -> plottitles ) ; <NEW_LINE> numaDestroy ( & gplot -> plotstyles ) ; <NEW_LINE> <START_VULN> ignore = fscanf ( fp , "Commandfile name: % s\n" , buf ) ; <NEW_LINE> <END_VULN> stringReplace ( & gplot -> cmdname , buf ) ; <NEW_LINE> ignore = fscanf ( fp , "\nCommandfile data:" ) ; <NEW_LINE> gplot -> cmddata = sarrayReadStream ( fp ) ;
if ( ! NS_IsMainThread ( ) ) { <NEW_LINE> HandleErrorWorker::DispatchIfNeeded ( this ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> if ( mDecoder ) { <NEW_LINE> <START_VULN> MutexAutoLock lock ( mDecodingMutex ) ; <NEW_LINE> <END_VULN> FinishedSomeDecoding ( eShutdownIntent_Error ) ; <NEW_LINE> } <NEW_LINE> mError = true ; <NEW_LINE> nsRefPtr < imgStatusTracker > statusTracker = CurrentStatusTracker ( ) ; <NEW_LINE> statusTracker -> GetDecoderObserver ( ) -> OnError ( ) ;
expectSame ( buf , "0123456789" ) ; <NEW_LINE> return getBuf ( "16000000" ) ; <NEW_LINE> } ) ) ; <NEW_LINE> <START_VULN> EXPECT_NO_THROW ( read_ . read ( queue_ ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> TEST_F ( EncryptedRecordTest , TestNoContentType ) {
|| ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) <NEW_LINE> { <NEW_LINE> IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; <NEW_LINE> <START_VULN> return SET_IVD_FATAL_ERROR ( e_error ) ; <NEW_LINE> <END_VULN> }
data_length = length - ( png_uint_32 ) ( entry_start - buffer ) ; <NEW_LINE> <START_VULN> if ( data_length % entry_size ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_warning ( png_ptr , "sPLT chunk has bad length" ) ; <NEW_LINE> return ;
do { <NEW_LINE> <START_VULN> * rowp ++ = * -- stackp ; <NEW_LINE> <END_VULN> if ( rowp == rowend ) <NEW_LINE> OUTPUT_ROW ( ) ; <NEW_LINE> } while ( stackp > stack ) ;
static void array_cleanup ( char * arr [ ] , int arr_size ) <NEW_LINE> { <NEW_LINE> int i = 0 ; <NEW_LINE> <START_VULN> for ( i = 0 ; i < arr_size ; i ++ ) { <NEW_LINE> <END_VULN> if ( arr [ i * 2 ] ) { <NEW_LINE> efree ( arr [ i * 2 ] ) ; <NEW_LINE> }
nsTArray < RangeData > temp ; <NEW_LINE> for ( PRInt32 i = overlaps . Length ( ) - 1 ; i >= 0 ; i -- ) { <NEW_LINE> nsresult rv = SubtractRange ( & overlaps [ i ] , aItem , & temp ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> } <NEW_LINE> PRInt32 insertionPoint ; <NEW_LINE> <START_VULN> nsresult rv = FindInsertionPoint ( & temp , aItem -> GetStartParent ( ) , <NEW_LINE>aItem -> StartOffset ( ) , <NEW_LINE>CompareToRangeStart , <NEW_LINE> & insertionPoint ) ; <NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> if ( ! temp . InsertElementAt ( insertionPoint , RangeData ( aItem ) ) ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> if ( ! mRanges . InsertElementsAt ( startIndex , temp ) ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ;
if ( NS_FAILED ( aStatus ) ) <NEW_LINE> finalStatus = aStatus ; <NEW_LINE> nsRefPtr < imgStatusTracker > statusTracker = CurrentStatusTracker ( ) ; <NEW_LINE> statusTracker -> GetDecoderObserver ( ) -> OnStopRequest ( aLastPart , finalStatus ) ; <NEW_LINE> { <NEW_LINE> <START_VULN> MutexAutoLock lock ( mDecodingMutex ) ; <NEW_LINE> <END_VULN> FinishedSomeDecoding ( ) ; <NEW_LINE> } <NEW_LINE> return finalStatus ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> RasterImage::OnImageDataAvailable ( nsIRequest * ,
if ( seed [ seedptr ] < lin ) seed [ seedptr ] = lin ; <NEW_LINE> } <NEW_LINE> seedptr += linesper ; <NEW_LINE> if ( seedptr >= n ) break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> static void seed_loop ( vorbis_look_psy * p , <NEW_LINE> <START_VULN> const float ** * curves , <NEW_LINE>const float * f , <NEW_LINE>const float * flr , <NEW_LINE>float * seed , <NEW_LINE>float specmax ) { <NEW_LINE> <END_VULN> vorbis_info_psy * vi = p -> vi ; <NEW_LINE> long n = p -> n , i ; <NEW_LINE> float dBoffset = vi -> max_curve_dB - specmax ; <NEW_LINE> for ( i = 0 ; i < n ; i ++ ) { <NEW_LINE> float max = f [ i ] ;
static v8::Handle < v8::Value > throwTypeError ( const char * = 0 ) ; <NEW_LINE> <START_VULN> static v8::Handle < v8::Value > throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> v8::Local < v8::Context > context ( ) ; <NEW_LINE> v8::Local < v8::Context > mainWorldContext ( ) ;
{ <NEW_LINE> int i ; <NEW_LINE> <START_VULN> png_debug1 ( 1 , "in % lx storage function" , png_ptr == NULL ? "unexpected" : <NEW_LINE> <END_VULN> ( unsigned long ) png_ptr -> chunk_name ) ; <NEW_LINE> if ( png_ptr == NULL || info_ptr == NULL || num_text <= 0 || text_ptr == NULL )
{ <NEW_LINE> struct NntpServer * nserv = data ; <NEW_LINE> struct NntpData * nntp_data = NULL ; <NEW_LINE> <START_VULN> char group [ LONG_STRING ] ; <NEW_LINE> <END_VULN> char desc [ HUGE_STRING ] = "" ; <NEW_LINE> char mod ; <NEW_LINE> anum_t first , last ;
void LocalFileSystem::resolveURL ( ExecutionContext * context , const KURL & fileSystemURL , PassOwnPtr < AsyncFileSystemCallbacks > callbacks ) <NEW_LINE> { <NEW_LINE> RefPtrWillBeRawPtr < ExecutionContext > contextPtr ( context ) ; <NEW_LINE> <START_VULN> RefPtr < CallbackWrapper > wrapper = adoptRef ( new CallbackWrapper ( callbacks ) ) ; <NEW_LINE> <END_VULN> requestFileSystemAccessInternal ( context , <NEW_LINE> bind ( & LocalFileSystem::resolveURLInternal , this , contextPtr , fileSystemURL , wrapper ) , <NEW_LINE> bind ( & LocalFileSystem::fileSystemNotAllowedInternal , this , contextPtr , wrapper ) ) ;
void DisplayPasskey ( chromeos::BluetoothDevice * device , <NEW_LINE> <START_VULN> int passkey , <NEW_LINE>int entered ) ; <NEW_LINE> <END_VULN>
destroy_bio ( struct bio * bio ) <NEW_LINE> { <NEW_LINE> pthread_cond_destroy ( & bio -> bio_wait ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> free ( bio ) ; <NEW_LINE> }
ScriptPromise BluetoothRemoteGATTCharacteristic::getDescriptorsImpl ( <NEW_LINE> ScriptState * scriptState , <NEW_LINE> mojom::blink::WebBluetoothGATTQueryQuantity quantity , <NEW_LINE> <START_VULN> const String & descriptor ) { <NEW_LINE> <END_VULN> if ( ! getGatt ( ) -> connected ( ) ) { <NEW_LINE> return ScriptPromise::rejectWithDOMException ( <NEW_LINE> scriptState ,
if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> rv = selection -> SelectAllChildren ( bodyNode ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsDocumentViewer::CopySelection ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsCopySupport::FireClipboardEvent ( NS_COPY , mPresShell , nullptr ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsDocumentViewer::CopyLinkLocation ( ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_TRUE ( mPresShell , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE> nsCOMPtr < nsIDOMNode > node ; <NEW_LINE> GetPopupLinkNode ( getter_AddRefs ( node ) ) ;
static png_bytep <NEW_LINE> <START_VULN> store_image_row ( PNG_CONST png_store * ps , png_const_structp pp , int nImage , <NEW_LINE> <END_VULN> png_uint_32 y ) <NEW_LINE> { <NEW_LINE> png_size_t coffset = ( nImage * ps -> image_h + y ) * ( ps -> cb_row + 5 ) + 2 ;
break ; <NEW_LINE> case EFFECT_CMD_SET_CONFIG: <NEW_LINE> if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) <NEW_LINE> <START_VULN> || pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> } <NEW_LINE> * ( int * ) pReplyData = LE_setConfig ( pContext ,
<START_VULN> class BrowserCompositorMac : public DelegatedFrameHostClient { <NEW_LINE> <END_VULN> public: <NEW_LINE> BrowserCompositorMac ( <NEW_LINE> ui::AcceleratedWidgetMacNSView * accelerated_widget_mac_ns_view ,
JS_ASSERT ( regs . fp ( ) -> isNonEvalFunctionFrame ( ) ) ; <NEW_LINE> PUSH_COPY ( argv [ - 2 ] ) ; <NEW_LINE> END_CASE ( JSOP_CALLEE ) <NEW_LINE> BEGIN_CASE ( JSOP_GETTER ) <NEW_LINE> BEGIN_CASE ( JSOP_SETTER ) <NEW_LINE> { <NEW_LINE> do_getter_setter: <NEW_LINE> <START_VULN> JSOp op2 = ( JSOp ) * ++ regs . pc ; <NEW_LINE> <END_VULN> jsid id ; <NEW_LINE> Value rval ; <NEW_LINE> jsint i ; <NEW_LINE> JSObject * obj ; <NEW_LINE> switch ( op2 ) { <NEW_LINE> case JSOP_INDEXBASE: <NEW_LINE> atoms += GET_INDEXBASE ( regs . pc ) ; <NEW_LINE> regs . pc += JSOP_INDEXBASE_LENGTH - 1 ;
static int <NEW_LINE> image_transform_png_set_expand_16_add ( image_transform * this , <NEW_LINE> <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE> <END_VULN> { <NEW_LINE> UNUSED ( colour_type )
static bool isPositionedContainer ( RenderLayer * layer ) <NEW_LINE> { <NEW_LINE> RenderObject * o = layer -> renderer ( ) ; <NEW_LINE> <START_VULN> return o -> isRenderView ( ) || o -> isPositioned ( ) || o -> isRelPositioned ( ) || layer -> hasTransform ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static bool isNonRenderViewFixedPositionedContainer ( RenderLayer * layer )
if ( ! mCanvasElement ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> <START_VULN> if ( mCanvasElement -> IsWriteOnly ( ) && ! IsCallerTrustedForRead ( ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_DOM_SECURITY_ERR ; <NEW_LINE> }
return NULL ; <NEW_LINE> } <NEW_LINE> Range * r = new Range ( <NEW_LINE> newLower , newUpper , <NEW_LINE> lhs -> decimal_ && rhs -> decimal_ , <NEW_LINE> Min ( lhs -> max_exponent_ , rhs -> max_exponent_ ) ) ; <NEW_LINE> <START_VULN> r -> lower_infinite_ = lhs -> lower_infinite_ && rhs -> lower_infinite_ ; <NEW_LINE>r -> upper_infinite_ = lhs -> upper_infinite_ && rhs -> upper_infinite_ ; <NEW_LINE> <END_VULN> return r ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> Range::unionWith ( const Range * other ) <NEW_LINE> { <NEW_LINE> bool decimal = decimal_ | other -> decimal_ ;
png_uint_32 n , nstop ; <NEW_LINE> int channel ; <NEW_LINE> int color_channels = row_info -> channels ; <NEW_LINE> <START_VULN> if ( row_info -> color_type > 3 ) color_channels -- ; <NEW_LINE> <END_VULN> for ( n = 0 , nstop = row_info -> width ; n < nstop ; n ++ ) <NEW_LINE> {
int n ; <NEW_LINE> int c ; <NEW_LINE> bool s ; <NEW_LINE> <START_VULN> ulong tmp ; <NEW_LINE> <END_VULN> assert ( ( ! sgnd && prec >= 1 ) || ( sgnd && prec >= 2 ) ) ; <NEW_LINE> if ( sgnd ) { <NEW_LINE> val = encode_twos_comp ( val , prec ) ;
} <NEW_LINE> #endif <NEW_LINE> <START_VULN> #ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED <NEW_LINE> <END_VULN> static png_uint_32 <NEW_LINE> get_unknown ( display * d , png_infop info_ptr , int after_IDAT ) <NEW_LINE> {
const uint8_t * source , <NEW_LINE> int64_t time_stamp ) <NEW_LINE> { <NEW_LINE> <START_VULN> #if HAVE_NEON <NEW_LINE>int64_t dx_store_reg [ 8 ] ; <NEW_LINE>#endif <NEW_LINE> <END_VULN> VP8_COMMON * cm = & pbi -> common ; <NEW_LINE> int retcode = - 1 ; <NEW_LINE> pbi -> common . error . error_code = VPX_CODEC_OK ;
bool want_stencil_buffer , <NEW_LINE> bool want_antialiasing , <NEW_LINE> PreserveDrawingBuffer preserve , <NEW_LINE> <START_VULN> WebGLVersion web_gl_version , <NEW_LINE> <END_VULN> ChromiumImageUsage chromium_image_usage , <NEW_LINE> const CanvasColorParams & color_params ) { <NEW_LINE> DCHECK ( context_provider ) ;
if ( sads [ j ] < best_sad ) { <NEW_LINE> const MV mv = { ref_mv -> row + neighbors [ j ] . row , <NEW_LINE> ref_mv -> col + neighbors [ j ] . col } ; <NEW_LINE> <START_VULN> sads [ j ] += mvsad_err_cost ( & mv , & fcenter_mv , <NEW_LINE>mvjsadcost , mvsadcost , error_per_bit ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( sads [ j ] < best_sad ) { <NEW_LINE> best_sad = sads [ j ] ; <NEW_LINE> best_site = j ;
#ifdef VP8_ENTROPY_STATS <NEW_LINE> void init_mv_ref_counts ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memset ( mv_ref_ct , 0 , sizeof ( mv_ref_ct ) ) ; <NEW_LINE>vpx_memset ( mv_mode_cts , 0 , sizeof ( mv_mode_cts ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void accum_mv_refs ( MB_PREDICTION_MODE m , const int ct [ 4 ] )
if ( ! m_element -> isHTMLElement ( ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> RefPtr < DocumentFragment > fragment = Range::createDocumentFragmentForElement ( markup , toHTMLElement ( m_element ) ) ; <NEW_LINE> <END_VULN> if ( ! fragment || ! fragment -> firstChild ( ) ) <NEW_LINE> return ;
{ <NEW_LINE> vp8_dc_only_idct_add_mmx ( q [ 48 ] * dq [ 0 ] , dst + 12 , stride , <NEW_LINE> dst + 12 , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> q += 64 ;
# endif <NEW_LINE> # if defined ( PNG_READ_SUPPORTED ) && defined ( PNG_WRITE_SUPPORTED ) <NEW_LINE> <START_VULN> else if ( ! ( png_ptr -> mode & PNG_IS_READ_STRUCT ) ) <NEW_LINE> <END_VULN> # endif <NEW_LINE> # ifdef PNG_WRITE_SUPPORTED
if ( ! style ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( ! renderLayer -> renderer ( ) -> isPositioned ( ) || renderLayer -> renderer ( ) -> style ( ) -> position ( ) != FixedPosition ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> if ( ! renderLayer -> renderer ( ) -> container ( ) -> isRenderView ( ) )
return disable ( cx , "code memory is out of range" ) ; <NEW_LINE> buffer . link ( claspGuard , slowPathStart ) ; <NEW_LINE> <START_VULN> buffer . link ( done1 , fastPathRejoin ) ; <NEW_LINE>buffer . link ( done2 , fastPathRejoin ) ; <NEW_LINE> <END_VULN> CodeLocationLabel cs = buffer . finalizeCodeAddendum ( ) ; <NEW_LINE> JaegerSpew ( JSpew_PICs , "generated getelem typed array stub at % p\n" , cs . executableAddress ( ) ) ;
calls mprStartDispatcher . <NEW_LINE> @param dispatcher Dispatcher object created via #mprCreateDispatcher <NEW_LINE> @return Zero if successful , otherwise a negative MPR status code . <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> @ingroup MprEvent <NEW_LINE> PUBLIC int mprStartDispatcher ( MprDispatcher * dispatcher ) ;
if ( ! timr -> it_interval ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <NEW_LINE>timer -> base -> get_time ( ) , <NEW_LINE>timr -> it_interval ) ; <NEW_LINE> <END_VULN> hrtimer_restart ( timer ) ; <NEW_LINE> }
} <NEW_LINE> void <NEW_LINE> nsHTMLDocumentSH::ReleaseDocument ( JSFreeOp * fop , JSObject * obj ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsIHTMLDocument * doc = ( nsIHTMLDocument * ) ::JS_GetPrivate ( obj ) ; <NEW_LINE><NEW_LINE>NS_IF_RELEASE ( doc ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JSBool <NEW_LINE> nsHTMLDocumentSH::CallToGetPropMapper ( JSContext * cx , unsigned argc , jsval * vp ) <NEW_LINE> { <NEW_LINE> if ( argc != 1 ) {
if ( pflow != NULL ) { <NEW_LINE> <START_VULN> if ( p -> proto == IPPROTO_TCP && pflow -> protoctx != NULL ) { <NEW_LINE> <END_VULN> StreamReassembleRawUpdateProgress ( pflow -> protoctx , p , <NEW_LINE> det_ctx -> raw_stream_progress ) ;
int numReturned ; <NEW_LINE> m_fbConfigs = glXChooseFBConfig ( m_display , DefaultScreen ( m_display ) , attributes , & numReturned ) ; <NEW_LINE> <START_VULN> m_glContext = glXCreateNewContext ( m_display , m_fbConfigs [ 0 ] , GLX_RGBA_TYPE , 0 , true ) ; <NEW_LINE>#endif <NEW_LINE> <END_VULN> } <NEW_LINE> ~ GraphicsSurfacePrivate ( )
} <NEW_LINE> } <NEW_LINE> if ( qs >= 0 ) { <NEW_LINE> <START_VULN> memmove ( s + j , s + qs , blen - qs ) ; <NEW_LINE>j += blen - qs ; <NEW_LINE> <END_VULN> } <NEW_LINE> buffer_string_set_length ( b , j ) ; <NEW_LINE> return qs ;
nsIPresShell * aPresShell , <NEW_LINE> StyleType aStyleType ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsIPresShell * presShell = GetPresShellForContent ( aElement ) ; <NEW_LINE> <END_VULN> if ( ! presShell ) { <NEW_LINE> presShell = aPresShell ; <NEW_LINE> if ( ! presShell ) <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> presShell -> FlushPendingNotifications ( Flush_Style ) ;
m . vol = m . param & 0xF ; <NEW_LINE> } <NEW_LINE> chnMem . autoVolSlide = 0 ; <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x0E:
} <NEW_LINE> } else { <NEW_LINE> if ( state -> space_before ) ruby_xfree ( state -> space_before ) ; <NEW_LINE> <START_VULN> state -> space_before = strdup ( RSTRING_PTR ( space_before ) ) ; <NEW_LINE> <END_VULN> state -> space_before_len = len ; <NEW_LINE> } <NEW_LINE> return Qnil ;
chunked = 1 ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> while ( header_buf [ i ] == '\r' || header_buf [ i ] == '\n' ) <NEW_LINE> <END_VULN> i ++ ; <NEW_LINE> linestart = i ; <NEW_LINE> colon = linestart ;
EXPECT_FALSE ( this -> SetCanonicalCookie ( <NEW_LINE> cs , <NEW_LINE> <START_VULN> base::MakeUnique < CanonicalCookie > ( <NEW_LINE> <END_VULN> "G" , "H" , http_foo_host , " / unique" , base::Time ( ) , base::Time ( ) , <NEW_LINE> base::Time ( ) , false , true , <NEW_LINE> CookieSameSite::DEFAULT_MODE , COOKIE_PRIORITY_DEFAULT ) ,
goto end ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! current . m_obj -> isFloatingOrPositioned ( ) ) { <NEW_LINE> <END_VULN> last = current . m_obj ; <NEW_LINE> if ( last -> isReplaced ( ) && autoWrap && ( ! last -> isImage ( ) || allowImagesToBreak ) && ( ! last -> isListMarker ( ) || toRenderListMarker ( last ) -> isInside ( ) ) ) { <NEW_LINE> width . commit ( ) ;
: public AutocompleteProvider , <NEW_LINE> public history::ShortcutsBackend::ShortcutsBackendObserver { <NEW_LINE> public: <NEW_LINE> <START_VULN> ShortcutsProvider ( ACProviderListener * listener , Profile * profile ) ; <NEW_LINE> <END_VULN>
case BGP_ATTR_EXT_COMMUNITIES: <NEW_LINE> ret = bgp_attr_ext_communities ( & attr_args ) ; <NEW_LINE> break ; <NEW_LINE> <START_VULN> #if ENABLE_BGP_VNC <NEW_LINE> <END_VULN> case BGP_ATTR_VNC: <NEW_LINE> #endif <NEW_LINE> case BGP_ATTR_ENCAP:
gTextRuns -> RemoveFromCache ( deleteTextRun ) ; <NEW_LINE> delete deleteTextRun ; <NEW_LINE> } <NEW_LINE> mTextRunsToDelete . Clear ( ) ; <NEW_LINE> } <NEW_LINE> void BuildTextRunsScanner::AccumulateRunInfo ( nsTextFrame * aFrame ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( mMaxTextLength <= mMaxTextLength + aFrame -> GetContentLength ( ) , "integer overflow" ) ; <NEW_LINE>mMaxTextLength += aFrame -> GetContentLength ( ) ; <NEW_LINE> <END_VULN> mDoubleByteText |= aFrame -> GetContent ( ) -> GetText ( ) -> Is2b ( ) ; <NEW_LINE> mLastFrame = aFrame ; <NEW_LINE> mCommonAncestorWithLastFrame = aFrame -> GetParent ( ) ; <NEW_LINE> MappedFlow * mappedFlow = & mMappedFlows [ mMappedFlows . Length ( ) - 1 ] ; <NEW_LINE> NS_ASSERTION ( mappedFlow -> mStartFrame == aFrame || <NEW_LINE> mappedFlow -> GetContentEnd ( ) == aFrame -> GetContentOffset ( ) , <NEW_LINE> "Overlapping or discontiguous frames = > BAD" ) ;
( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; <NEW_LINE> ptr_hbe_txposer -> analy_cos_sin_tab = <NEW_LINE> ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <NEW_LINE> <START_VULN> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <NEW_LINE>ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <NEW_LINE> <END_VULN> } <NEW_LINE> ptr_hbe_txposer -> synth_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ;
case '"': <NEW_LINE> ds += 5 ; <NEW_LINE> <START_VULN> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <NEW_LINE> <END_VULN> if ( NULL == tmp ) <NEW_LINE> {
if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { <NEW_LINE> struct crypto_report_larval rl ; <NEW_LINE> <START_VULN> strlcpy ( rl . type , "larval" , sizeof ( rl . type ) ) ; <NEW_LINE> <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , <NEW_LINE> sizeof ( struct crypto_report_larval ) , & rl ) ) <NEW_LINE> goto nla_put_failure ;
__m128i out23 = _mm_add_epi16 ( in23 , kOne ) ; <NEW_LINE> out01 = _mm_srai_epi16 ( out01 , 2 ) ; <NEW_LINE> out23 = _mm_srai_epi16 ( out23 , 2 ) ; <NEW_LINE> <START_VULN> _mm_store_si128 ( ( __m128i * ) ( output + 0 * 8 ) , out01 ) ; <NEW_LINE>_mm_store_si128 ( ( __m128i * ) ( output + 1 * 8 ) , out23 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static INLINE void transpose_4x4 ( __m128i * res ) {
#if ENABLE ( SPELLCHECK ) <NEW_LINE> else if ( name == g_intern_string ( "spell - checking - languages" ) ) { <NEW_LINE> <START_VULN> WebKit::EditorClient * client = static_cast < WebKit::EditorClient * > ( core ( webView ) -> editorClient ( ) ) ; <NEW_LINE>static_cast < WebKit::TextCheckerClientEnchant * > ( client -> textChecker ( ) ) -> updateSpellCheckingLanguage ( g_value_get_string ( & value ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif
bool isHorizontal = isHorizontalFlow ( ) ; <NEW_LINE> for ( size_t i = 0 ; i < children . size ( ) ; ++ i ) { <NEW_LINE> RenderBox * child = children [ i ] ; <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( isHorizontal ) { <NEW_LINE> if ( child -> style ( ) -> marginLeft ( ) . isAuto ( ) )
class ShellContentUtilityClient : public ContentUtilityClient { <NEW_LINE> public: <NEW_LINE> <START_VULN> ShellContentUtilityClient ( ) ; <NEW_LINE> <END_VULN> ~ ShellContentUtilityClient ( ) override ;
VLOG ( 4 ) << "Parsing downstream trailers streamId = " << streamId ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( sessionClosing_ != ClosingState::CLOSED ) { <NEW_LINE> <END_VULN> lastStreamID_ = streamId ; <NEW_LINE> }
nsDOMStorage2::Principal ( ) <NEW_LINE> { <NEW_LINE> return mPrincipal ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> nsDOMStorage2::CanAccess ( nsIPrincipal * aPrincipal ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( mStorage -> mSecurityChecker != this ) <NEW_LINE>return mStorage -> mSecurityChecker -> CanAccess ( aPrincipal ) ; <NEW_LINE><NEW_LINE><NEW_LINE>if ( ! aPrincipal ) <NEW_LINE>return true ; <NEW_LINE><NEW_LINE><NEW_LINE>bool subsumes ; <NEW_LINE>nsresult rv = aPrincipal -> Subsumes ( mPrincipal , & subsumes ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) <NEW_LINE>return false ; <NEW_LINE><NEW_LINE>return subsumes ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsPIDOMStorage::nsDOMStorageType <NEW_LINE> nsDOMStorage2::StorageType ( ) <NEW_LINE> { <NEW_LINE> if ( mStorage ) <NEW_LINE> return mStorage -> StorageType ( ) ;
<START_VULN> class FileVersionInfo { <NEW_LINE> <END_VULN> public: <NEW_LINE> virtual ~ FileVersionInfo ( ) { } <NEW_LINE> #if defined ( OS_WIN ) || defined ( OS_MACOSX )
{ <NEW_LINE> struct crypto_report_acomp racomp ; <NEW_LINE> <START_VULN> strlcpy ( racomp . type , "acomp" , sizeof ( racomp . type ) ) ; <NEW_LINE> <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , <NEW_LINE> sizeof ( struct crypto_report_acomp ) , & racomp ) )
#include "core / events / Event . h" <NEW_LINE> #include "core / dom / ExceptionCode . h" <NEW_LINE> #include "core / platform / mediastream / MediaStreamCenter . h" <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "modules / mediastream / MediaStreamRegistry . h" <NEW_LINE> #include "modules / mediastream / MediaStreamTrackEvent . h" <NEW_LINE> namespace WebCore {
case mState_ESC_24_28: <NEW_LINE> if ( 'C' == * src ) { <NEW_LINE> mState = mState_KSC5601_1987 ; <NEW_LINE> mRunLength = 0 ; <NEW_LINE> } else if ( 'D' == * src ) { <NEW_LINE> mState = mState_JISX0212_1990 ; <NEW_LINE> mRunLength = 0 ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> if ( ( dest + 4 ) >= destEnd ) <NEW_LINE> <END_VULN> goto error1 ; <NEW_LINE> * dest ++ = ( PRUnichar ) 0x1b ; <NEW_LINE> * dest ++ = ( PRUnichar ) ' $ ' ; <NEW_LINE> * dest ++ = ( PRUnichar ) ' ( ' ; <NEW_LINE> if ( 0x80 & * src ) <NEW_LINE> goto error2 ; <NEW_LINE> * dest ++ = ( PRUnichar ) * src ; <NEW_LINE> mState = mLastLegalState ;
#include < limits . h > <NEW_LINE> <START_VULN> #include < vector > <NEW_LINE><NEW_LINE>#include "sfntly / port / type . h" <NEW_LINE> <END_VULN> #include "sfntly / data / byte_array . h" <NEW_LINE> #include "sfntly / port / refcount . h" <NEW_LINE> namespace sfntly {
if ( strchr ( wp -> query , ' = ' ) == NULL ) { <NEW_LINE> query = sclone ( wp -> query ) ; <NEW_LINE> websDecodeUrl ( query , query , strlen ( query ) ) ; <NEW_LINE> <START_VULN> for ( cp = stok ( query , " " , & tok ) ; cp != NULL ; ) { <NEW_LINE> <END_VULN> * ( argp + n ) = cp ; <NEW_LINE> trace ( 5 , "ARG [ % d ] % s" , n , argp [ n - 1 ] ) ; <NEW_LINE> n ++ ;
} <NEW_LINE> if ( mStreamInfoValid ) { <NEW_LINE> <START_VULN> if ( getChannels ( ) == 0 || getChannels ( ) > 8 ) { <NEW_LINE> <END_VULN> ALOGE ( "unsupported channel count % u" , getChannels ( ) ) ; <NEW_LINE> return NO_INIT ; <NEW_LINE> }
IntRect PageRect ( ) override { return IntRect ( ) ; } <NEW_LINE> <START_VULN> void Focus ( ) override { } <NEW_LINE> <END_VULN> bool CanTakeFocus ( WebFocusType ) override { return false ; } <NEW_LINE> void TakeFocus ( WebFocusType ) override { }
{ <NEW_LINE> atomic_set ( & handle -> rb -> poll , POLL_IN ) ; <NEW_LINE> <START_VULN> if ( handle -> nmi ) { <NEW_LINE>handle -> event -> pending_wakeup = 1 ; <NEW_LINE>irq_work_queue ( & handle -> event -> pending ) ; <NEW_LINE> } else <NEW_LINE>perf_event_wakeup ( handle -> event ) ; <NEW_LINE> <END_VULN> }
nsAutoCString contentType ; <NEW_LINE> NS_SniffContent ( NS_DATA_SNIFFER_CATEGORY , nullptr , <NEW_LINE> aBuffer . Data ( ) , aBuffer . Length ( ) , <NEW_LINE> contentType ) ; <NEW_LINE> nsRefPtr < WebAudioDecodeJob > job = <NEW_LINE> <START_VULN> new WebAudioDecodeJob ( contentType , this , aBuffer ) ; <NEW_LINE> <END_VULN> if ( mDecoder . SyncDecodeMedia ( contentType . get ( ) , <NEW_LINE> aBuffer . Data ( ) , aBuffer . Length ( ) , * job ) && <NEW_LINE> job -> mOutput ) { <NEW_LINE> nsRefPtr < AudioBuffer > buffer = job -> mOutput . forget ( ) ; <NEW_LINE> if ( aMixToMono ) { <NEW_LINE> buffer -> MixToMono ( aJSContext ) ; <NEW_LINE> }
int err ; <NEW_LINE> union { <NEW_LINE> int_mv mv ; <NEW_LINE> <START_VULN> MB_PREDICTION_MODE mode ; <NEW_LINE> <END_VULN> } m ; <NEW_LINE> } ref [ MAX_REF_FRAMES ] ; <NEW_LINE> } MBGRAPH_MB_STATS ;
if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> RETURN_FALSE ; <NEW_LINE> }
} <NEW_LINE> ScopedUnpackParametersResetRestore temporary_reset_unpack ( <NEW_LINE> <START_VULN> this , change_unpack_alignment ) ; <NEW_LINE> <END_VULN> if ( function_id == kTexImage2D ) <NEW_LINE> TexImage2DBase ( target , level , internalformat , width , height , border , format , <NEW_LINE> type , data ) ;
return BAD_VALUE ; <NEW_LINE> } <NEW_LINE> <START_VULN> BufferMeta * buffer_meta = new BufferMeta ( params , true ) ; <NEW_LINE> <END_VULN> OMX_BUFFERHEADERTYPE * header ;
nsJSContext::IsContextInitialized ( ) <NEW_LINE> { <NEW_LINE> return mIsInitialized ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsJSContext::ScriptEvaluated ( bool aTerminated ) <NEW_LINE> { <NEW_LINE> <START_VULN> JS_MaybeGC ( mContext ) ; <NEW_LINE> <END_VULN> if ( aTerminated ) { <NEW_LINE> mOperationCallbackTime = 0 ; <NEW_LINE> mModalStateTime = 0 ; <NEW_LINE> mActive = true ; <NEW_LINE> } <NEW_LINE> }
goto err ; <NEW_LINE> } <NEW_LINE> <START_VULN> len = file ? file -> size : 4096 ; <NEW_LINE> <END_VULN> p = realloc ( * data , len ) ; <NEW_LINE> if ( ! p ) { <NEW_LINE> goto err ;
return NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> return lookup ( str , length ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> struct SpecialOperator {
return "3""SIG padding does not check out" ; <NEW_LINE> } <NEW_LINE> <START_VULN> s += padlen + 3 ; <NEW_LINE> ( * psig ) = s ; <NEW_LINE> <END_VULN> return NULL ;
#elif USHRT_MAX == 65535 <NEW_LINE> typedef unsigned short png_uint_16 ; <NEW_LINE> #else <NEW_LINE> <START_VULN> # error "libpng requires an unsigned 16 bit type" <NEW_LINE> <END_VULN> #endif <NEW_LINE> #if INT_MIN < - 2147483646 && INT_MAX > 2147483646
class MockConnectionVisitor : public QuicConnectionVisitorInterface { <NEW_LINE> public: <NEW_LINE> MockConnectionVisitor ( ) ; <NEW_LINE> <START_VULN> ~ MockConnectionVisitor ( ) ; <NEW_LINE> <END_VULN> MOCK_METHOD4 ( OnPacket , bool ( const IPEndPoint & self_address , <NEW_LINE> const IPEndPoint & peer_address , <NEW_LINE> const QuicPacketHeader & header ,
} <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ctxt -> input -> base > ctxt -> input -> cur - len ) <NEW_LINE>return ( NULL ) ; <NEW_LINE> <END_VULN> return ( xmlDictLookup ( ctxt -> dict , ctxt -> input -> cur - len , len ) ) ; <NEW_LINE> }
nsFrameManager * frameManager = mPresShell -> FrameManager ( ) ; <NEW_LINE> nsPresContext * presContext = mPresShell -> GetPresContext ( ) ; <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> nsIFrame * childFrame = <NEW_LINE> mPresShell -> FrameManager ( ) -> GetPrimaryFrameFor ( aChild , aIndexInContainer ) ; <NEW_LINE> <START_VULN> if ( ! childFrame ) { <NEW_LINE> <END_VULN> frameManager -> ClearUndisplayedContentIn ( aChild , aContainer ) ; <NEW_LINE> } <NEW_LINE> #ifdef MOZ_XUL <NEW_LINE> if ( NotifyListBoxBody ( presContext , aContainer , aChild , aIndexInContainer , <NEW_LINE> mDocument , childFrame , gUseXBLForms , CONTENT_REMOVED ) ) <NEW_LINE> return NS_OK ;
} <NEW_LINE> <START_VULN> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <NEW_LINE> <END_VULN> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; <NEW_LINE> {
break ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( inchar == EOF ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> if ( buf [ 4 ] == 73 && buf [ 5 ] == 69 && buf [ 6 ] == 78 && buf [ 7 ] == 68 )
mprLog ( "info http config" , 4 , "Already tracing . Ignoring trace configuration" ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> size = ( ssize ) httpGetNumber ( mprGetJson ( prop , "size" ) ) ; <NEW_LINE>format = mprGetJson ( prop , "format" ) ; <NEW_LINE>formatter = mprGetJson ( prop , "formatter" ) ; <NEW_LINE>location = mprGetJson ( prop , "location" ) ; <NEW_LINE>level = ( char ) stoi ( mprGetJson ( prop , "level" ) ) ; <NEW_LINE>backup = ( int ) stoi ( mprGetJson ( prop , "backup" ) ) ; <NEW_LINE>anew = smatch ( mprGetJson ( prop , "anew" ) , "true" ) ; <NEW_LINE>maxContent = ( ssize ) httpGetNumber ( mprGetJson ( prop , "content" ) ) ; <NEW_LINE> <END_VULN> if ( level < 0 ) { <NEW_LINE> level = 0 ;
mWidth = mHeight = 0 ; <NEW_LINE> mGeneration = 0 ; <NEW_LINE> mInvalidated = PR_FALSE ; <NEW_LINE> mResetLayer = PR_TRUE ; <NEW_LINE> mVerbose = PR_FALSE ; <NEW_LINE> mOptionsFrozen = PR_FALSE ; <NEW_LINE> mActiveTexture = 0 ; <NEW_LINE> <START_VULN> mSynthesizedGLError = LOCAL_GL_NO_ERROR ; <NEW_LINE> <END_VULN> mPixelStoreFlipY = PR_FALSE ; <NEW_LINE> mPixelStorePremultiplyAlpha = PR_FALSE ; <NEW_LINE> mPixelStoreColorspaceConversion = BROWSER_DEFAULT_WEBGL ; <NEW_LINE> mShaderValidation = PR_TRUE ; <NEW_LINE> mMapBuffers . Init ( ) ; <NEW_LINE> mMapTextures . Init ( ) ;
bytes_remaining - = ps_dec_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ( 1 != ps_dec_state -> u2_decode_header ) && ( ( bytes_remaining > 0 ) || ps_dec_state -> u1_flushfrm ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ps_dec_state -> u1_flushfrm ) <NEW_LINE> {
nsresult <NEW_LINE> nsXBLBinding::DoInitJSClass ( JSContext * cx , JSObject * global , JSObject * obj , <NEW_LINE> const nsAFlatCString & aClassName , <NEW_LINE> nsXBLPrototypeBinding * aProtoBinding , <NEW_LINE> <START_VULN> JSObject ** aClassObject ) <NEW_LINE> <END_VULN> { <NEW_LINE> nsAutoCString className ( aClassName ) ; <NEW_LINE> nsAutoCString xblKey ( aClassName ) ; <NEW_LINE> JSObject * parent_proto = nullptr ; <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , global ) ;
public: <NEW_LINE> ObjectElements ( uint32_t capacity , uint32_t length ) <NEW_LINE> <START_VULN> : capacity ( capacity ) , initializedLength ( 0 ) , length ( length ) <NEW_LINE> <END_VULN> { } <NEW_LINE> HeapSlot * elements ( ) { return ( HeapSlot * ) ( uintptr_t ( this ) + sizeof ( ObjectElements ) ) ; }
else <NEW_LINE> size = target -> GetSize ( ) ; <NEW_LINE> NS_ASSERTION ( ! target -> GetNextInFlow ( ) && ! target -> GetPrevInFlow ( ) , <NEW_LINE> "reflow roots should never split" ) ; <NEW_LINE> <START_VULN> <NEW_LINE>nsSize reflowSize ; <NEW_LINE>if ( target != rootFrame ) <NEW_LINE>reflowSize = nsSize ( size . width , NS_UNCONSTRAINEDSIZE ) ; <NEW_LINE>else <NEW_LINE>reflowSize = size ; <NEW_LINE> <END_VULN> nsHTMLReflowState reflowState ( mPresContext , target , rcx , reflowSize ) ; <NEW_LINE> NS_ASSERTION ( reflowState . mComputedMargin == nsMargin ( 0 , 0 , 0 , 0 ) , <NEW_LINE> "reflow state should not set margin for reflow roots" ) ; <NEW_LINE> if ( size . height != NS_UNCONSTRAINEDSIZE ) { <NEW_LINE> nscoord computedHeight = <NEW_LINE> size . height - reflowState . mComputedBorderPadding . TopBottom ( ) ;
calcViewport ( ) ; <NEW_LINE> <START_VULN> bool updatedTransform = calculateLocalTransform ( ) ; <NEW_LINE>m_didScreenScaleFactorChange = updatedTransform || SVGLayoutSupport::screenScaleFactorChanged ( parent ( ) ) ; <NEW_LINE> <END_VULN> determineIfLayoutSizeChanged ( ) ;
char ** argv ) <NEW_LINE> { <NEW_LINE> mode_t old_umask ; <NEW_LINE> <START_VULN> cleanup_free char * base_path = NULL ; <NEW_LINE> <END_VULN> int clone_flags ; <NEW_LINE> char * old_cwd = NULL ; <NEW_LINE> pid_t pid ;
PRInt32 listIndex = 0 ; <NEW_LINE> nsIAtom * childList = nsnull ; <NEW_LINE> do { <NEW_LINE> nsIFrame * child = aFrame -> GetFirstChild ( childList ) ; <NEW_LINE> while ( child ) { <NEW_LINE> <START_VULN> if ( ! ( child -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) <NEW_LINE> || ( child -> GetStateBits ( ) & NS_FRAME_IS_OVERFLOW_CONTAINER ) ) { <NEW_LINE> <END_VULN> if ( nsGkAtoms::placeholderFrame == child -> GetType ( ) ) { <NEW_LINE> nsIFrame * outOfFlowFrame = <NEW_LINE> nsPlaceholderFrame::GetRealFrameForPlaceholder ( child ) ; <NEW_LINE> do { <NEW_LINE> DoApplyRenderingChangeToTree ( outOfFlowFrame , aViewManager , <NEW_LINE> aFrameManager , aChange ) ;
if ( num_head > 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> uhp_table = ( u_header_T ** ) U_ALLOC_LINE ( <NEW_LINE> <END_VULN> num_head * sizeof ( u_header_T * ) ) ; <NEW_LINE> if ( uhp_table == NULL ) <NEW_LINE> goto error ;
rewind ( finput ) ; <NEW_LINE> <START_VULN> byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ; <NEW_LINE> <END_VULN> if ( byteStrm == NULL ) <NEW_LINE> { <NEW_LINE> printf ( "UNABLE TO ALLOCATE MEMORY\n" ) ;
{ <NEW_LINE> if ( ! Base::getOwnPropertyDescriptor ( cx , wrapper , id , set , desc ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> return FilterSetter < Policy > ( cx , wrapper , id , desc ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> template < typename Base , typename Policy >
} <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::get ( JSContext * cx , JSObject * wrapper , JSObject * receiver , jsid id , Value * vp ) <NEW_LINE> { <NEW_LINE> PIERCE ( cx , wrapper , GET , <NEW_LINE> call . destination -> wrap ( cx , & receiver ) && call . destination -> wrapId ( cx , & id ) , <NEW_LINE> DirectWrapper::get ( cx , wrapper , receiver , id , vp ) , <NEW_LINE> <START_VULN> call . origin -> wrap ( cx , vp ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::set ( JSContext * cx , JSObject * wrapper_ , JSObject * receiver_ , jsid id_ , <NEW_LINE> bool strict , Value * vp ) <NEW_LINE> { <NEW_LINE> RootedObject wrapper ( cx , wrapper_ ) , receiver ( cx , receiver_ ) ; <NEW_LINE> RootedId id ( cx , id_ ) ;
extern "C" int EffectCreate ( const effect_uuid_t * uuid , <NEW_LINE> <START_VULN> int32_t sessionId , <NEW_LINE>int32_t ioId , <NEW_LINE> <END_VULN> effect_handle_t * pHandle ) { <NEW_LINE> int ret ; <NEW_LINE> int i ;
RenderObject * prev = child -> previousSibling ( ) ; <NEW_LINE> <START_VULN> if ( prev && prev -> isBlockFlow ( ) && ! prev -> isFloatingOrPositioned ( ) ) { <NEW_LINE> <END_VULN> RenderBlock * block = toRenderBlock ( prev ) ; <NEW_LINE> if ( block -> containsFloats ( ) && block -> lowestFloatLogicalBottom ( ) > logicalTop ) <NEW_LINE> addOverhangingFloats ( block , false ) ;
Vector < CFGState , 8 , IonAllocPolicy > cfgStack_ ; <NEW_LINE> Vector < ControlFlowInfo , 4 , IonAllocPolicy > loops_ ; <NEW_LINE> Vector < ControlFlowInfo , 0 , IonAllocPolicy > switches_ ; <NEW_LINE> Vector < ControlFlowInfo , 2 , IonAllocPolicy > labels_ ; <NEW_LINE> Vector < MInstruction * , 2 , IonAllocPolicy > iterators_ ; <NEW_LINE> TypeOracle * oracle ; <NEW_LINE> <START_VULN> size_t inliningDepth ; <NEW_LINE> <END_VULN> Vector < MDefinition * , 0 , IonAllocPolicy > inlinedArguments_ ; <NEW_LINE> bool failedBoundsCheck_ ;
<START_VULN> PHP_FUNCTION ( locale_get_display_name ) <NEW_LINE> <END_VULN> { <NEW_LINE> get_icu_disp_value_src_php ( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; <NEW_LINE> }
return NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> ret = snprintf ( dest , len , " % s / lock / lxc / % s" , rundir , p ) ; <NEW_LINE> <END_VULN> if ( ret < 0 || ret >= len ) { <NEW_LINE> free ( dest ) ; <NEW_LINE> free ( rundir ) ;
nsresult <NEW_LINE> MediaPermissionManager::HandleRequest ( nsRefPtr < dom::GetUserMediaRequest > & req ) <NEW_LINE> { <NEW_LINE> nsString callID ; <NEW_LINE> req -> GetCallID ( callID ) ; <NEW_LINE> <START_VULN> nsCOMPtr < nsPIDOMWindow > innerWindow = do_QueryInterface ( req -> GetParentObject ( ) ) ; <NEW_LINE> <END_VULN> if ( ! innerWindow ) { <NEW_LINE> MOZ_ASSERT ( false , "No inner window" ) ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIGetUserMediaDevicesSuccessCallback > onSuccess = <NEW_LINE> new MediaDeviceSuccessCallback ( req ) ; <NEW_LINE> nsCOMPtr < nsIDOMGetUserMediaErrorCallback > onError =
static PRInt32 getNamespaceID ( const txXPathNode & aNode ) ; <NEW_LINE> static void getNamespaceURI ( const txXPathNode & aNode , nsAString & aURI ) ; <NEW_LINE> static PRUint16 getNodeType ( const txXPathNode & aNode ) ; <NEW_LINE> static void appendNodeValue ( const txXPathNode & aNode , nsAString & aResult ) ; <NEW_LINE> static PRBool isWhitespace ( const txXPathNode & aNode ) ; <NEW_LINE> static txXPathNode * getDocument ( const txXPathNode & aNode ) ; <NEW_LINE> static txXPathNode * getOwnerDocument ( const txXPathNode & aNode ) ; <NEW_LINE> static PRInt32 getUniqueIdentifier ( const txXPathNode & aNode ) ; <NEW_LINE> <START_VULN> static nsresult getXSLTId ( const txXPathNode & aNode , nsAString & aResult ) ; <NEW_LINE> <END_VULN> static void release ( txXPathNode * aNode ) ; <NEW_LINE> static void getBaseURI ( const txXPathNode & aNode , nsAString & aURI ) ; <NEW_LINE> static PRIntn comparePosition ( const txXPathNode & aNode , <NEW_LINE> const txXPathNode & aOtherNode ) ; <NEW_LINE> static PRBool localNameEquals ( const txXPathNode & aNode , <NEW_LINE> nsIAtom * aLocalName ) ; <NEW_LINE> static PRBool isRoot ( const txXPathNode & aNode ) ; <NEW_LINE> static PRBool isElement ( const txXPathNode & aNode ) ;
{ <NEW_LINE> OwnPtr < GIFImageDecoder > decoder = createDecoder ( ) ; <NEW_LINE> <START_VULN> RefPtr < SharedBuffer > data = readFile ( " / LayoutTests / fast / images / resources / animated - gif - with - offsets . gif" ) ; <NEW_LINE> <END_VULN> ASSERT_TRUE ( data . get ( ) ) ; <NEW_LINE> size_t frameCount = 0 ;
if ( mPos >= bmpDataOffset && mPos < bmpDataEnd ) { <NEW_LINE> uint32_t toFeed = bmpDataEnd - mPos ; <NEW_LINE> if ( toFeed > aCount ) { <NEW_LINE> toFeed = aCount ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! WriteToContainedDecoder ( aBuffer , toFeed ) ) { <NEW_LINE> <END_VULN> return ; <NEW_LINE> } <NEW_LINE> mPos += toFeed ; <NEW_LINE> aCount - = toFeed ; <NEW_LINE> aBuffer += toFeed ; <NEW_LINE> }
return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1285 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy95: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' , ' ) {
} else if ( xmlStrEqual ( validity , BAD_CAST "invalid" ) ) { <NEW_LINE> nb_schematas ++ ; <NEW_LINE> ctxt = xmlSchemaNewParserCtxt ( ( const char * ) path ) ; <NEW_LINE> <START_VULN> xmlSchemaSetParserErrors ( ctxt , <NEW_LINE> ( xmlSchemaValidityErrorFunc ) testErrorHandler , <NEW_LINE> ( xmlSchemaValidityWarningFunc ) testErrorHandler , <NEW_LINE>ctxt ) ; <NEW_LINE> <END_VULN> schemas = xmlSchemaParse ( ctxt ) ; <NEW_LINE> xmlSchemaFreeParserCtxt ( ctxt ) ; <NEW_LINE> if ( schemas != NULL ) {
WORD32 timeDelay , timeTaken ; <NEW_LINE> size_t sizeY , sizeUV ; <NEW_LINE> <START_VULN> setDecodeArgs ( & s_dec_ip , & s_dec_op , inHeader , outHeader , timeStampIx ) ; <NEW_LINE> <END_VULN> DUMP_TO_FILE ( mInFile , s_dec_ip . pv_stream_buffer , s_dec_ip . u4_num_Bytes ) ;
static inline bool isChildHitTestCandidate ( RenderBox * box ) <NEW_LINE> { <NEW_LINE> <START_VULN> return box -> height ( ) && box -> style ( ) -> visibility ( ) == VISIBLE && ! box -> isFloatingOrPositioned ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> VisiblePosition RenderBlock::positionForPoint ( const LayoutPoint & point )
} <NEW_LINE> <START_VULN> class ExtensionInfoBar : public InfoBar , <NEW_LINE> <END_VULN> public ExtensionView::Container , <NEW_LINE> public ImageLoadingTracker::Observer , <NEW_LINE> public ExtensionInfoBarDelegate::DelegateObserver ,
<START_VULN> if ( detect_transition_to_still ( twopass , i , cpi -> key_frame_frequency - i , <NEW_LINE> <END_VULN> loop_decay_rate , decay_accumulator ) ) <NEW_LINE> break ;
#ifndef SVGResourcesCache_h <NEW_LINE> #define SVGResourcesCache_h <NEW_LINE> <START_VULN> #include "core / rendering / style / RenderStyleConstants . h" <NEW_LINE> <END_VULN> #include "wtf / FastAllocBase . h" <NEW_LINE> #include "wtf / HashMap . h" <NEW_LINE> #include "wtf / Noncopyable . h"
if ( cm -> frame_type == KEY_FRAME ) <NEW_LINE> { <NEW_LINE> int i ; <NEW_LINE> <START_VULN> vp8_yv12_copy_frame ( <NEW_LINE>cpi -> Source , <NEW_LINE> & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] ) ; <NEW_LINE><NEW_LINE>vp8_yv12_extend_frame_borders ( <NEW_LINE> & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] ) ; <NEW_LINE><NEW_LINE>for ( i = 2 ; i < MAX_REF_FRAMES - 1 ; i ++ ) <NEW_LINE>vp8_yv12_copy_frame ( <NEW_LINE> & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] , <NEW_LINE> & cpi -> denoiser . yv12_running_avg [ i ] ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else <NEW_LINE> {
} <NEW_LINE> DBGPRINTF ( "imzmq3: connect for % s successful\n" , info -> description ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> rv = zsocket_bind ( * sock , info -> description ) ; <NEW_LINE> <END_VULN> if ( rv == - 1 ) { <NEW_LINE> errmsg . LogError ( 0 , <NEW_LINE> RS_RET_INVALID_PARAMS ,
return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsIScriptGlobalObject * globalObject = mDocument -> GetScriptGlobalObject ( ) ; <NEW_LINE>NS_ENSURE_TRUE ( globalObject , NS_ERROR_FAILURE ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIContent > scriptContent ( do_QueryInterface ( aRequest -> mElement ) ) ;
virtual bool IsTransportSeekable ( ) = 0 ; <NEW_LINE> <START_VULN> static MediaResource * Create ( MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <NEW_LINE> <END_VULN> virtual nsresult Open ( nsIStreamListener ** aStreamListener ) = 0 ; <NEW_LINE> #ifdef MOZ_DASH
class nsGIFDecoder2 : public Decoder <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> nsGIFDecoder2 ( RasterImage & aImage ) ; <NEW_LINE> ~ nsGIFDecoder2 ( ) ; <NEW_LINE> <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> virtual void FinishInternal ( ) ; <NEW_LINE> virtual Telemetry::ID SpeedHistogram ( ) ; <NEW_LINE> private: <NEW_LINE> void BeginGIF ( ) ;
__set_bit ( DONT_FORK_BIT , & debug ) ; <NEW_LINE> __set_bit ( NO_SYSLOG_BIT , & debug ) ; <NEW_LINE> if ( optarg && optarg [ 0 ] ) { <NEW_LINE> <START_VULN> int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <NEW_LINE> <END_VULN> if ( fd == - 1 ) { <NEW_LINE> fprintf ( stderr , "Unable to open config - test log file % s\n" , optarg ) ; <NEW_LINE> exit ( EXIT_FAILURE ) ;
png_crc_read ( png_ptr , buffer , length ) ; <NEW_LINE> <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> buffer [ length ] = 0 ;
return GetOwnPropertyDescriptor ( cx , GetProxyTargetObject ( proxy ) , id , <NEW_LINE> JSRESOLVE_QUALIFIED , desc ) ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> IndirectProxyHandler::defineProperty ( JSContext * cx , JSObject * proxy , jsid id , <NEW_LINE> PropertyDescriptor * desc ) <NEW_LINE> { <NEW_LINE> <START_VULN> return JS_DefinePropertyById ( cx , GetProxyTargetObject ( proxy ) , id , <NEW_LINE>desc -> value , desc -> getter , desc -> setter , <NEW_LINE> <END_VULN> desc -> attrs ) ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> IndirectProxyHandler::getOwnPropertyNames ( JSContext * cx , JSObject * proxy , <NEW_LINE> AutoIdVector & props ) <NEW_LINE> { <NEW_LINE> return GetPropertyNames ( cx , GetProxyTargetObject ( proxy ) ,
int ret ; <NEW_LINE> while ( s ) <NEW_LINE> { <NEW_LINE> <START_VULN> do ret = send ( sock_fd , buf , s , 0 ) ; <NEW_LINE> <END_VULN> while ( ret < 0 && errno == EINTR ) ; <NEW_LINE> if ( ret <= 0 ) <NEW_LINE> {
return 1 ; <NEW_LINE> pos += size ; <NEW_LINE> <START_VULN> assert ( ( cluster_stop < 0 ) || ( pos <= cluster_stop ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
png_debug ( 1 , "in png_handle_IHDR" ) ; <NEW_LINE> <START_VULN> if ( png_ptr -> mode & PNG_HAVE_IHDR ) <NEW_LINE> <END_VULN> png_chunk_error ( png_ptr , "out of place" ) ;
JSWorkerConstructor * jsConstructor = jsCast < JSWorkerConstructor * > ( exec -> callee ( ) ) ; <NEW_LINE> if ( ! exec -> argumentCount ( ) ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> UString scriptURL = exec -> argument ( 0 ) . toString ( exec ) -> value ( exec ) ; <NEW_LINE> if ( exec -> hadException ( ) )
if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> } <NEW_LINE> PRInt32 itemType ; <NEW_LINE> if ( ( mDocShellType == nsIDocShellTreeItem::typeAll ) || <NEW_LINE> ( NS_SUCCEEDED ( inItem -> GetItemType ( & itemType ) ) && ( itemType == mDocShellType ) ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> rv = inItemArray . AppendElement ( ( void * ) inItem ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> <END_VULN> } <NEW_LINE> return NS_OK ; <NEW_LINE> }
public: <NEW_LINE> virtual ~ Delegate ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE>virtual DWORD GetExitCode ( ) = 0 ; <NEW_LINE> <END_VULN>
<START_VULN> #ifndef BASE_THREADING_SEQUENCED_WORKER_POOL_UNITTEST_H_ <NEW_LINE>#define BASE_THREADING_SEQUENCED_WORKER_POOL_UNITTEST_H_ <NEW_LINE> <END_VULN> #include < cstddef > <NEW_LINE> #include < string >
case EQ_PARAM_CENTER_FREQ: <NEW_LINE> ALOGV ( " % s: EQ_PARAM_CENTER_FREQ" , __func__ ) ; <NEW_LINE> param2 = * param_tmp ; <NEW_LINE> <START_VULN> if ( param2 >= NUM_EQ_BANDS ) { <NEW_LINE>p -> status = - EINVAL ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> } <NEW_LINE> * ( int32_t * ) value = equalizer_get_center_frequency ( eq_ctxt , param2 ) ;
return ( MagickFalse ) ; <NEW_LINE> ( void ) QueryColorCompliance ( "#0000" , AllCompliance , <NEW_LINE> & clip_mask -> background_color , exception ) ; <NEW_LINE> <START_VULN> clip_mask -> background_color . alpha = ( Quantum ) TransparentAlpha ; <NEW_LINE> <END_VULN> ( void ) SetImageBackgroundColor ( clip_mask , exception ) ; <NEW_LINE> if ( image -> debug != MagickFalse ) <NEW_LINE> ( void ) LogMagickEvent ( DrawEvent , GetMagickModule ( ) , "\nbegin clip - path % s" ,
if ( ( ptr = strchr ( filename , ' ? ' ) ) != NULL ) <NEW_LINE> * ptr = '\0' ; <NEW_LINE> <START_VULN> if ( ( status = stat ( filename , filestats ) ) != 0 ) <NEW_LINE> <END_VULN> {
D3DPOOL_SYSTEMMEM , & newTexture , NULL ) ; <NEW_LINE> if ( FAILED ( result ) ) <NEW_LINE> { <NEW_LINE> ASSERT ( result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY ) ; <NEW_LINE> return error ( GL_OUT_OF_MEMORY ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> newTexture -> GetSurfaceLevel ( levelToFetch , & newSurface ) ; <NEW_LINE> <END_VULN> newTexture -> Release ( ) ; <NEW_LINE> } <NEW_LINE> if ( image -> surface ) <NEW_LINE> { <NEW_LINE> image -> surface -> Release ( ) ; <NEW_LINE> }
<START_VULN> static int CVE_2011_1833_ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) <NEW_LINE> <END_VULN> { <NEW_LINE> char * p ; <NEW_LINE> int rc = 0 ;
if ( pCmdData == NULL || <NEW_LINE> cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) ) || <NEW_LINE> pReplyData == NULL || <NEW_LINE> <START_VULN> * replySize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + <NEW_LINE>sizeof ( uint16_t ) ) ) { <NEW_LINE> <END_VULN> status = - EINVAL ; <NEW_LINE> ALOGV ( "EFFECT_CMD_GET_PARAM invalid command cmdSize % d * replySize % d" , <NEW_LINE> cmdSize , * replySize ) ;
int drop_mark = ( int ) ( oxcf -> drop_frames_water_mark * <NEW_LINE> <START_VULN> oxcf -> optimal_buffer_level / 100 ) ; <NEW_LINE> <END_VULN> if ( ( rc -> buffer_level > drop_mark ) && <NEW_LINE> ( rc -> decimation_factor > 0 ) ) { <NEW_LINE> -- rc -> decimation_factor ;
#include "base / strings / string16 . h" <NEW_LINE> <START_VULN> class PasswordAccessoryController ; <NEW_LINE> <END_VULN> class PasswordGenerationDialogViewInterface { <NEW_LINE> public:
} <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <NEW_LINE> <END_VULN> if ( re -> flags & JS_REGEXP_G ) <NEW_LINE> re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; <NEW_LINE> js_pushboolean ( J , 1 ) ;
PHP_FE_END <NEW_LINE> } ; <NEW_LINE> <START_VULN> ZEND_BEGIN_ARG_INFO_EX ( arginfo_r_dir___construct , 0 , 0 , 1 ) <NEW_LINE> <END_VULN> ZEND_ARG_INFO ( 0 , path ) <NEW_LINE> ZEND_ARG_INFO ( 0 , flags ) <NEW_LINE> ZEND_END_ARG_INFO ( )
<START_VULN> Chapters::Chapters ( ) <NEW_LINE>: chapters_size_ ( 0 ) , <NEW_LINE>chapters_count_ ( 0 ) , <NEW_LINE>chapters_ ( NULL ) { <NEW_LINE> } <NEW_LINE> <END_VULN> Chapters:: ~ Chapters ( ) { <NEW_LINE> while ( chapters_count_ > 0 ) {
return ; <NEW_LINE> #ifdef PNG_READ_INTERLACING_SUPPORTED <NEW_LINE> <START_VULN> if ( ! ( png_ptr -> flags & PNG_FLAG_ROW_INIT ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> pass = png_set_interlace_handling ( png_ptr ) ;
} <NEW_LINE> if ( BImgBuff ) <NEW_LINE> <START_VULN> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> } <NEW_LINE> case 1:
if ( errmsg != NULL ) <NEW_LINE> png_chunk_benign_error ( png_ptr , errmsg ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_READ_sPLT_SUPPORTED <NEW_LINE> void
j = m + 1 ; <NEW_LINE> while ( j -- ) { <NEW_LINE> double d = 0 ; <NEW_LINE> for ( i = j ; i < n ; i ++ ) d += ( double ) data [ i ] * data [ i - j ] ; <NEW_LINE> aut [ j ] = d ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> error = aut [ 0 ] * ( 1 . + 1e - 10 ) ; <NEW_LINE> epsilon = 1e - 9 * aut [ 0 ] + 1e - 10 ; <NEW_LINE> for ( i = 0 ; i < m ; i ++ ) { <NEW_LINE> double r = - aut [ i + 1 ] ;
return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>inline bool SafeAddUint32 ( uint32 a , uint32 b , uint32 * dst ) { <NEW_LINE>return SafeAdd ( a , b , dst ) ; <NEW_LINE> <END_VULN> }
} <NEW_LINE> <START_VULN> if ( mount ( "cgroup" , cgpath , "tmpfs" , 0 , "size = 10000 , mode = 755" ) ) { <NEW_LINE> <END_VULN> SYSERROR ( "Failed to mount tmpfs at % s" , cgpath ) ; <NEW_LINE> return false ; <NEW_LINE> }
int t = info -> postlist [ k + 2 ] = oggpack_read ( opb , rangebits ) ; <NEW_LINE> if ( t < 0 || t >= ( 1 << rangebits ) ) <NEW_LINE> goto err_out ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> info -> postlist [ 0 ] = 0 ; <NEW_LINE> info -> postlist [ 1 ] = 1 << rangebits ; <NEW_LINE> return ( info ) ; <NEW_LINE> err_out: <NEW_LINE> floor1_free_info ( info ) ; <NEW_LINE> return ( NULL ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int icomp ( const void * a , const void * b ) { <NEW_LINE>return ( ** ( int ** ) a - ** ( int ** ) b ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> static vorbis_look_floor * floor1_look ( vorbis_dsp_state * vd , <NEW_LINE> vorbis_info_floor * in ) { <NEW_LINE> int * sortpointer [ VIF_POSIT + 2 ] ; <NEW_LINE> vorbis_info_floor1 * info = ( vorbis_info_floor1 * ) in ; <NEW_LINE> vorbis_look_floor1 * look = _ogg_calloc ( 1 , sizeof ( * look ) ) ; <NEW_LINE> int i , j , n = 0 ;
namespace XrayUtils { <NEW_LINE> extern JSClass HolderClass ; <NEW_LINE> bool CloneExpandoChain ( JSContext * cx , JSObject * src , JSObject * dst ) ; <NEW_LINE> bool <NEW_LINE> <START_VULN> IsTransparent ( JSContext * cx , JSObject * wrapper ) ; <NEW_LINE> <END_VULN> JSObject * <NEW_LINE> GetNativePropertiesObject ( JSContext * cx , JSObject * wrapper ) ; <NEW_LINE> } <NEW_LINE> class XrayTraits ; <NEW_LINE> class XPCWrappedNativeXrayTraits ;
return ! ! bytes && <NEW_LINE> JS_ReportErrorFlagsAndNumber ( cx , <NEW_LINE> ( JSREPORT_WARNING | JSREPORT_STRICT <NEW_LINE> | JSREPORT_STRICT_MODE_ERROR ) , <NEW_LINE> js_GetErrorMessage , NULL , <NEW_LINE> JSMSG_UNDECLARED_VAR , bytes . ptr ( ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static bool <NEW_LINE>ReportReadOnly ( JSContext * cx , jsid id , unsigned report ) <NEW_LINE> <END_VULN> { <NEW_LINE> return js_ReportValueErrorFlags ( cx , report , JSMSG_READ_ONLY , <NEW_LINE> JSDVG_IGNORE_STACK , IdToValue ( id ) , NULL , <NEW_LINE> NULL , NULL ) ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> JSObject::reportNotConfigurable ( JSContext * cx , jsid id , unsigned report )
<START_VULN> c_prev = prev -> yChan + offset ; <NEW_LINE> <END_VULN> cu_prev = prev -> uChan + ( offset >> 2 ) + ( xpos >> 2 ) ;
oggpack_write ( opb , 0 , 32 ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> oggpack_write ( opb , 1 , 1 ) ; <NEW_LINE> return ( 0 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> static int _vorbis_pack_books ( oggpack_buffer * opb , vorbis_info * vi ) { <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> int i ; <NEW_LINE> if ( ! ci ) return ( OV_EFAULT ) ; <NEW_LINE> oggpack_write ( opb , 0x05 , 8 ) ; <NEW_LINE> _v_writestring ( opb , "vorbis" , 6 ) ;
SPL_METHOD ( DirectoryIterator , getFilename ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
D3DVERTEXELEMENT9 elements [ MAX_VERTEX_ATTRIBS + 1 ] ; <NEW_LINE> D3DVERTEXELEMENT9 * element = & elements [ 0 ] ; <NEW_LINE> for ( int i = 0 ; i < MAX_VERTEX_ATTRIBS ; i ++ ) <NEW_LINE> { <NEW_LINE> if ( attributes [ i ] . active ) <NEW_LINE> { <NEW_LINE> <START_VULN> device -> SetStreamSource ( i , attributes [ i ] . vertexBuffer , attributes [ i ] . offset , attributes [ i ] . stride ) ; <NEW_LINE> <END_VULN> element -> Stream = i ; <NEW_LINE> element -> Offset = 0 ; <NEW_LINE> element -> Type = attributes [ i ] . type ; <NEW_LINE> element -> Method = D3DDECLMETHOD_DEFAULT ; <NEW_LINE> element -> Usage = D3DDECLUSAGE_TEXCOORD ; <NEW_LINE> element -> UsageIndex = program -> getSemanticIndex ( i ) ; <NEW_LINE> element ++ ;
png_free ( c . png_ptr , cp ) ; <NEW_LINE> <START_VULN> if ( c . for_write ) <NEW_LINE> <END_VULN> { <NEW_LINE> # ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED <NEW_LINE> png_destroy_write_struct ( & c . png_ptr , & c . info_ptr ) ;
876 , 877 , 878 , 879 , 880 , 889 , 890 , 906 , 912 , <NEW_LINE> 914 , 916 , 918 , 920 , 923 , 925 , 936 , 938 , 940 , 950 , <NEW_LINE> 952 , 954 , 956 , 958 , 963 , 965 , 969 , 973 , 975 , 980 , <NEW_LINE> <START_VULN> 982 , 986 , 987 , 991 , 992 , 996 , 1011 , 1016 , 1024 , 1025 , <NEW_LINE>1029 , 1030 , 1031 , 1032 , 1036 , 1037 , 1038 , 1048 , 1049 , 1053 , <NEW_LINE>1055 , 1060 , 1062 , 1066 , 1071 , 1072 , 1076 , 1077 , 1081 , 1090 , <NEW_LINE>1091 , 1095 , 1096 , 1105 , 1120 , 1124 , 1125 , 1129 , 1130 , 1134 , <NEW_LINE>1135 , 1139 , 1144 , 1148 , 1152 , 1153 , 1157 , 1162 , 1163 , 1167 , <NEW_LINE>1169 , 1171 , 1173 , 1175 <NEW_LINE> <END_VULN> } ; <NEW_LINE> #endif
if ( tmp_err < * best_motion_err ) { <NEW_LINE> * best_motion_err = tmp_err ; <NEW_LINE> <START_VULN> best_mv -> row = tmp_mv . row ; <NEW_LINE>best_mv -> col = tmp_mv . col ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
int chunks = srclen / chunklen ; <NEW_LINE> int restlen = srclen - chunks * chunklen ; <NEW_LINE> <START_VULN> int out_len = ( chunks + 1 ) * endlen + srclen ; <NEW_LINE>String ret ( out_len , ReserveString ) ; <NEW_LINE> <END_VULN> char * dest = ret . bufferSlice ( ) . ptr ; <NEW_LINE> const char * p ; char * q ;
nsresult rv ; <NEW_LINE> nsIScriptContext * sc = GetContextForEventHandlers ( & rv ) ; <NEW_LINE> if ( ! sc ) { <NEW_LINE> SetError ( nsISmsRequest::INTERNAL_ERROR ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSContext * cx = sc -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( cx , "Failed to get a context ! " ) ; <NEW_LINE> JSObject * global = sc -> GetNativeGlobal ( ) ; <NEW_LINE> NS_ASSERTION ( global , "Failed to get global object ! " ) ; <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , global ) ;
# define afirst 0 <NEW_LINE> # endif <NEW_LINE> # ifdef PNG_FORMAT_BGR_SUPPORTED <NEW_LINE> <START_VULN> const int bgr = ( image -> format & PNG_FORMAT_FLAG_BGR ) ? 2 : 0 ; <NEW_LINE> <END_VULN> # else <NEW_LINE> # define bgr 0 <NEW_LINE> # endif
CuePoint ** j = jj ; <NEW_LINE> pCP = * i ; <NEW_LINE> <START_VULN> assert ( pCP ) ; <NEW_LINE> <END_VULN> if ( time_ns <= pCP -> GetTime ( m_pSegment ) ) { <NEW_LINE> pTP = pCP -> Find ( pTrack ) ;
cx -> exception = JSVAL_VOID ; <NEW_LINE> regs . sp [ - 1 ] = JSVAL_HOLE ; <NEW_LINE> PUSH ( JSVAL_FALSE ) ; <NEW_LINE> goto end_imacro ; <NEW_LINE> } <NEW_LINE> regs . pc = fp -> imacpc ; <NEW_LINE> fp -> imacpc = NULL ; <NEW_LINE> <START_VULN> atoms = script -> atomMap . vector ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_ASSERT ( ( size_t ) ( ( fp -> imacpc ? fp -> imacpc : regs . pc ) - script -> code ) < script -> length ) ; <NEW_LINE> #ifdef JS_TRACER <NEW_LINE> ok = JS_FALSE ; <NEW_LINE> } else { <NEW_LINE> JSTrapHandler handler ; <NEW_LINE> JSTryNote * tn , * tnlimit ; <NEW_LINE> uint32 offset ; <NEW_LINE> handler = cx -> debugHooks -> throwHook ; <NEW_LINE> if ( handler ) { <NEW_LINE> switch ( handler ( cx , script , regs . pc , & rval , <NEW_LINE> cx -> debugHooks -> throwHookData ) ) { <NEW_LINE> case JSTRAP_ERROR: <NEW_LINE> cx -> throwing = JS_FALSE ; <NEW_LINE> goto error ; <NEW_LINE> case JSTRAP_RETURN:
if ( cpkt . cptype == MT_CPTYPE_PASSSALT ) { <NEW_LINE> <START_VULN> memcpy ( pass_salt , cpkt . data , cpkt . length ) ; <NEW_LINE> <END_VULN> send_auth ( username , password ) ; <NEW_LINE> }
stateMask = stateMask ^ PRUint32 ( IntrinsicState ( ) ) ; <NEW_LINE> if ( stateMask && document ) { <NEW_LINE> MOZ_AUTO_DOC_UPDATE ( document , UPDATE_CONTENT_STATE , aNotify ) ; <NEW_LINE> document -> ContentStatesChanged ( this , nsnull , stateMask ) ; <NEW_LINE> } <NEW_LINE> nsNodeUtils::AttributeChanged ( this , aNamespaceID , aName , modType , <NEW_LINE> stateMask ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( aFireMutation ) { <NEW_LINE> mozAutoRemovableBlockerRemover blockerRemover ; <NEW_LINE> nsMutationEvent mutation ( PR_TRUE , NS_MUTATION_ATTRMODIFIED ) ; <NEW_LINE> nsAutoString attrName ; <NEW_LINE> aName -> ToString ( attrName ) ; <NEW_LINE> nsCOMPtr < nsIDOMAttr > attrNode ;
NS_DECL_ISUPPORTS_INHERITED <NEW_LINE> NS_DECL_NSIINPUTSTREAMCHANNEL <NEW_LINE> nsInputStreamChannel ( ) { } <NEW_LINE> protected: <NEW_LINE> virtual ~ nsInputStreamChannel ( ) { } <NEW_LINE> <START_VULN> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result ) ; <NEW_LINE> <END_VULN> private: <NEW_LINE> nsCOMPtr < nsIInputStream > mContentStream ; <NEW_LINE> } ; <NEW_LINE> #endif
v8::Local < v8::Function > function = value . As < v8::Function > ( ) ; <NEW_LINE> v8::Local < v8::Value > boundFunction = function -> GetBoundFunction ( ) ; <NEW_LINE> v8::Local < v8::Value > scopes ; <NEW_LINE> <START_VULN> if ( boundFunction -> IsUndefined ( ) && functionScopes ( function ) . ToLocal ( & scopes ) ) { <NEW_LINE> <END_VULN> properties -> Set ( properties -> Length ( ) , toV8StringInternalized ( m_isolate , " [ [ Scopes ] ] " ) ) ; <NEW_LINE> properties -> Set ( properties -> Length ( ) , scopes ) ; <NEW_LINE> }
ProxyJNIEnv & proxyEnv = GetProxyEnv ( env ) ; <NEW_LINE> nsISecureEnv * secureEnv = GetSecureEnv ( env ) ; <NEW_LINE> nsISecurityContext * securityContext = proxyEnv . getContext ( ) ; <NEW_LINE> <START_VULN> nsresult result ; <NEW_LINE>result = secureEnv -> SetField ( field -> mFieldType , obj , field -> mFieldID , value , securityContext ) ; <NEW_LINE> <END_VULN> NS_IF_RELEASE ( securityContext ) ; <NEW_LINE> }
ceph::bufferlist & authorizer , <NEW_LINE> ceph::bufferlist & authorizer_reply , <NEW_LINE> bool & isvalid , <NEW_LINE> <START_VULN> CryptoKey & session_key ) { return false ; } <NEW_LINE> <END_VULN>
else <NEW_LINE> RelinquishMagickResource ( MapResource , length ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( memory_info -> blob == NULL ) <NEW_LINE> <END_VULN> { <NEW_LINE> int <NEW_LINE> file ;
* ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; <NEW_LINE> * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ixheaacd_cmplx_anal_fft != NULL ) <NEW_LINE> ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> return - 1 ;
} <NEW_LINE> if ( ! route -> combine && ( preload = mprGetJsonObj ( route -> config , "esp . preload" ) ) != 0 ) { <NEW_LINE> for ( ITERATE_JSON ( preload , item , i ) ) { <NEW_LINE> <START_VULN> source = stok ( sclone ( item -> value ) , ":" , & kind ) ; <NEW_LINE>if ( ! kind ) kind = "controller" ; <NEW_LINE> <END_VULN> source = mprJoinPath ( httpGetDir ( route , "controllers" ) , source ) ; <NEW_LINE> if ( espLoadModule ( route , NULL , kind , source , & errMsg ) < 0 ) { <NEW_LINE> mprLog ( "error esp" , 0 , "Cannot preload esp module % s . % s" , source , errMsg ) ;
if ( yych <= '9' ) goto yy97 ; <NEW_LINE> if ( yych != ' ; ' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 499 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> long id ;
const File * file = fileList -> item ( i ) ; <NEW_LINE> if ( file -> hasBeenClosed ( ) ) <NEW_LINE> return handleError ( DataCloneError , "A File object has been closed , and could therefore not be cloned . " , next ) ; <NEW_LINE> <START_VULN> m_blobDataHandles . add ( file -> uuid ( ) , file -> blobDataHandle ( ) ) ; <NEW_LINE> <END_VULN> if ( appendFileInfo ( file , & blobIndex ) ) { <NEW_LINE> ASSERT ( ! i || blobIndex > 0 ) ; <NEW_LINE> ASSERT ( blobIndex >= 0 ) ;
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsCOMPtr < nsIHttpChannel > httpChan ( do_QueryInterface ( chan ) ) ; <NEW_LINE> if ( httpChan ) { <NEW_LINE> httpChan -> SetReferrer ( doc -> GetDocumentURI ( ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>nsContentUtils::SetUpChannelOwner ( thisContent -> NodePrincipal ( ) , <NEW_LINE>chan , mURI , true ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIScriptChannel > scriptChannel = do_QueryInterface ( chan ) ; <NEW_LINE> if ( scriptChannel ) { <NEW_LINE> scriptChannel -> SetExecutionPolicy ( nsIScriptChannel::EXECUTE_NORMAL ) ; <NEW_LINE> }
} <NEW_LINE> SECStatus <NEW_LINE> ssl3_HandleNewSessionTicket ( sslSocket * ss , SSL3Opaque * b , PRUint32 length ) <NEW_LINE> { <NEW_LINE> SECStatus rv ; <NEW_LINE> SECItem ticketData ; <NEW_LINE> <START_VULN> SSL_TRC ( 3 , ( " % d: SSL3 [ % d ] : handle session_ticket handshake" , <NEW_LINE>SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> <END_VULN> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> PORT_Assert ( ! ss -> ssl3 . hs . newSessionTicket . ticket . data ) ; <NEW_LINE> PORT_Assert ( ! ss -> ssl3 . hs . receivedNewSessionTicket ) ; <NEW_LINE> if ( ss -> ssl3 . hs . ws != wait_new_session_ticket ) {
tdata_t tilebuf ; <NEW_LINE> uint32 imagew = TIFFScanlineSize ( in ) ; <NEW_LINE> uint32 tilew = TIFFTileRowSize ( in ) ; <NEW_LINE> <START_VULN> int iskew = imagew - tilew ; <NEW_LINE> <END_VULN> uint8 * bufp = ( uint8 * ) buf ; <NEW_LINE> uint32 tw , tl ; <NEW_LINE> uint32 row ;
" and a fragment shader" ) ; <NEW_LINE> program -> SetLinkStatus ( false ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> if ( mIsMesa ) { <NEW_LINE> <START_VULN> if ( program -> UpperBoundNumSamplerUniforms ( ) > 16 ) { <NEW_LINE> <END_VULN> GenerateWarning ( "Programs with more than 16 samplers are disallowed on Mesa drivers " <NEW_LINE> "to avoid a Mesa crasher . " ) ; <NEW_LINE> program -> SetLinkStatus ( false ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> GLint ok ;
if ( ( mode_search_skip_flags & FLAG_SKIP_INTRA_BESTINTER ) && <NEW_LINE> ( this_mode >= D45_PRED && this_mode <= TM_PRED ) ) { <NEW_LINE> <START_VULN> if ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] > INTRA_FRAME ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> } <NEW_LINE> if ( mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) {
mat . Invert ( ) ; <NEW_LINE> aPatternTransform = aPatternTransform * * aOriginalTransform * mat ; <NEW_LINE> aPatternTransform . NudgeToIntegers ( ) ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> \ No newline at end of file <NEW_LINE>
for ( i = 0 ; i < get_vpx_decoder_count ( ) ; ++ i ) { <NEW_LINE> const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ; <NEW_LINE> fprintf ( stderr , " % - 6s - % s\n" , <NEW_LINE> <START_VULN> decoder -> name , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> exit ( EXIT_FAILURE ) ;
<START_VULN> bool isPositionedWithSpecifiedHeight = cb -> isPositioned ( ) && ( ! cbstyle -> logicalHeight ( ) . isAuto ( ) || ( ! cbstyle -> top ( ) . isAuto ( ) && ! cbstyle -> bottom ( ) . isAuto ( ) ) ) ; <NEW_LINE> <END_VULN> bool includeBorderPadding = isTable ( ) ;
q = tileno / p_cp -> tw ; <NEW_LINE> <START_VULN> * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ; <NEW_LINE> * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ; <NEW_LINE> * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ; <NEW_LINE> * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ; <NEW_LINE> <END_VULN> * p_max_prec = 0 ;
template < typename Base , typename Traits > <NEW_LINE> XrayWrapper < Base , Traits > :: ~ XrayWrapper ( ) <NEW_LINE> { <NEW_LINE> } <NEW_LINE> namespace XrayUtils { <NEW_LINE> bool <NEW_LINE> <START_VULN> IsTransparent ( JSContext * cx , JSObject * wrapper , jsid id ) <NEW_LINE> <END_VULN> { <NEW_LINE> nsCOMPtr < nsIContent > content ; <NEW_LINE> if ( EnsureCompartmentPrivate ( wrapper ) -> scope -> IsXBLScope ( ) && <NEW_LINE> ( content = do_QueryInterfaceNative ( cx , wrapper ) ) ) <NEW_LINE> {
if ( m_contentListener && TryContentListener ( m_contentListener , aChannel ) ) { <NEW_LINE> LOG ( ( " Success ! Our default listener likes this type" ) ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ! ( mFlags & nsIURILoader::DONT_RETARGET ) ) { <NEW_LINE> PRInt32 count = mURILoader -> m_listeners . Count ( ) ; <NEW_LINE> nsCOMPtr < nsIURIContentListener > listener ;
#endif <NEW_LINE> if ( pc -> refresh_entropy_probs == 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> pc -> refresh_last_frame = pc -> frame_type == KEY_FRAME || vp8_read_bit ( bc ) ;
if ( buf [ i ] == 0xB8 ) can_crypt ++ ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> <START_VULN> if ( sc_select_file ( card , & prkey_info . path , & f ) != SC_SUCCESS ) { <NEW_LINE> <END_VULN> sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , <NEW_LINE> "Select ( % s ) failed\n" , <NEW_LINE> sc_print_path ( & prkey_info . path ) ) ;
{ <NEW_LINE> const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; <NEW_LINE> if ( * str != '\"' ) { * ep = str ; return 0 ; } <NEW_LINE> <START_VULN> <NEW_LINE>while ( * end_ptr != '\"' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\' ) end_ptr ++ ; <NEW_LINE><NEW_LINE> <END_VULN> out = ( char * ) cJSON_malloc ( len + 1 ) ; <NEW_LINE> if ( ! out ) return 0 ; <NEW_LINE> item -> valuestring = out ;
golden_ref , cpi -> Source ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> vp9_clear_system_state ( ) ; <NEW_LINE> <END_VULN> separate_arf_mbs ( cpi ) ; <NEW_LINE> }
} <NEW_LINE> xmlNodeDump ( buf , test -> doc , test , 0 , 0 ) ; <NEW_LINE> pctxt = xmlRelaxNGNewMemParserCtxt ( ( const char * ) buf -> content , buf -> use ) ; <NEW_LINE> <START_VULN> xmlRelaxNGSetParserErrors ( pctxt , <NEW_LINE> ( xmlRelaxNGValidityErrorFunc ) testErrorHandler , <NEW_LINE> ( xmlRelaxNGValidityWarningFunc ) testErrorHandler , <NEW_LINE>pctxt ) ; <NEW_LINE> <END_VULN> rng = xmlRelaxNGParse ( pctxt ) ; <NEW_LINE> xmlRelaxNGFreeParserCtxt ( pctxt ) ; <NEW_LINE> if ( extraMemoryFromResolver )
{ <NEW_LINE> MsgToEventLog ( M_SYSERR , TEXT ( "malformed startup data: 1 byte received" ) ) ; <NEW_LINE> ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <NEW_LINE> <START_VULN> goto out ; <NEW_LINE> <END_VULN> } <NEW_LINE> data = malloc ( bytes ) ;
debug ( " % s " , genimg_get_type_name ( type ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( IS_ENABLED ( CONFIG_SPL_OS_BOOT ) && IS_ENABLED ( CONFIG_SPL_GZIP ) ) { <NEW_LINE>if ( fit_image_get_comp ( fit , node , & image_comp ) ) <NEW_LINE>puts ( "Cannot get image compression format . \n" ) ; <NEW_LINE>else <NEW_LINE>debug ( " % s " , genimg_get_comp_name ( image_comp ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( fit_image_get_load ( fit , node , & load_addr ) )
ScaleRequest * mScaleRequest ; <NEW_LINE> nsresult ShutdownDecoder ( eShutdownIntent aIntent ) ; <NEW_LINE> <START_VULN> void DoError ( ) ; <NEW_LINE> <END_VULN> bool CanDiscard ( ) ; <NEW_LINE> bool CanForciblyDiscard ( ) ; <NEW_LINE> bool DiscardingActive ( ) ; <NEW_LINE> bool StoringSourceData ( ) const ; <NEW_LINE> protected: <NEW_LINE> RasterImage ( imgStatusTracker * aStatusTracker = nullptr , nsIURI * aURI = nullptr ) ;
{ <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> int skip_dots = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_SKIPDOTS ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
} <NEW_LINE> static INLINE int vp9_is_scaled ( const struct scale_factors * sf ) { <NEW_LINE> <START_VULN> return sf -> x_scale_fp != REF_NO_SCALE || <NEW_LINE>sf -> y_scale_fp != REF_NO_SCALE ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef __cplusplus
continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> key_len = snprintf ( stats_key , sizeof ( stats_key ) , " % s: % d" , hostname , port ) ; <NEW_LINE><NEW_LINE>return_val . set ( String ( stats_key , key_len , CopyString ) , server_stats ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> free ( stats ) ;
default: <NEW_LINE> case 6: <NEW_LINE> <START_VULN> if ( ! ( png_ptr -> row_number & 1 ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_read_finish_row ( png_ptr ) ; <NEW_LINE> return ;
HttpResponse::ServerConnectionCode connection_code_ ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>SyncSessionJob * pending_nudge_ ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>scoped_ptr < SyncSessionJob > unscheduled_nudge_storage_ ; <NEW_LINE> <END_VULN> scoped_ptr < WaitInterval > wait_interval_ ;
cx -> hasSignature = ( sig != NULL ) ; <NEW_LINE> cx -> encAlg = encAlg ; <NEW_LINE> cx -> hashAlg = hashAlg ; <NEW_LINE> cx -> key = SECKEY_CopyPublicKey ( key ) ; <NEW_LINE> rv = SECSuccess ; <NEW_LINE> if ( sig ) { <NEW_LINE> switch ( type ) { <NEW_LINE> case rsaKey: <NEW_LINE> <START_VULN> rv = DecryptSigBlock ( & cx -> hashAlg , cx -> u . buffer , & cx -> rsadigestlen , <NEW_LINE>HASH_LENGTH_MAX , cx -> key , sig , ( char * ) wincx ) ; <NEW_LINE>if ( cx -> hashAlg != hashAlg && hashAlg != SEC_OID_UNKNOWN ) { <NEW_LINE>PORT_SetError ( SEC_ERROR_BAD_SIGNATURE ) ; <NEW_LINE>rv = SECFailure ; <NEW_LINE> } <NEW_LINE> <END_VULN> break ; <NEW_LINE> case dsaKey: <NEW_LINE> case ecKey: <NEW_LINE> sigLen = SECKEY_SignatureLen ( key ) ; <NEW_LINE> if ( sigLen == 0 ) { <NEW_LINE> rv = SECFailure ; <NEW_LINE> break ;
const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; <NEW_LINE> const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ; <NEW_LINE> const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; <NEW_LINE> <START_VULN> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <NEW_LINE> <END_VULN> const __m128i k__const_0 = _mm_set1_epi16 ( 0 ) ; <NEW_LINE> const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ;
#define ALLOCATE ( ptr , count , type ) \ <NEW_LINE> { \ <NEW_LINE> <START_VULN> ( ptr ) = H264SwDecMalloc ( ( count ) * sizeof ( type ) ) ; \ <NEW_LINE> <END_VULN> }
class MediaInterfaceProxy : public media::mojom::InterfaceFactory { <NEW_LINE> public: <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> MediaInterfaceProxy ( RenderFrameHost * render_frame_host , <NEW_LINE> media::mojom::InterfaceFactoryRequest request , <NEW_LINE> const base::Closure & error_handler ) ;
<START_VULN> bool CopyMetafileDataToSharedMem ( const PdfMetafileSkia & metafile , <NEW_LINE>base::SharedMemoryHandle * shared_mem_handle ) ; <NEW_LINE> <END_VULN> static void ComputePageLayoutInPointsForCss (
* ( int * ) pReplyData = 0 ; <NEW_LINE> break ; <NEW_LINE> case EFFECT_CMD_DISABLE: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> } <NEW_LINE> if ( pContext -> mState != VISUALIZER_STATE_ACTIVE ) {
type [ 0 ] , type [ 1 ] , type [ 2 ] , type [ 3 ] , ( double ) length ) ; <NEW_LINE> if ( length > PNG_UINT_31_MAX || count == 0 ) <NEW_LINE> <START_VULN> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; <NEW_LINE> <END_VULN> p = NULL ; <NEW_LINE> chunk = ( unsigned char * ) NULL ;
} \ <NEW_LINE> <START_VULN> #line 111 "hex_grammar . c" <NEW_LINE> <END_VULN> # ifndef YY_NULLPTR <NEW_LINE> # if defined __cplusplus && 201103L <= __cplusplus
return nullptr ; <NEW_LINE> nsCOMPtr < nsIDOMElement > element ; <NEW_LINE> inst -> GetDOMElement ( getter_AddRefs ( element ) ) ; <NEW_LINE> if ( ! element ) <NEW_LINE> return nullptr ; <NEW_LINE> <START_VULN> JSContext * cx = GetJSContextFromNPP ( npp ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( cx , nullptr ) ; <NEW_LINE> nsCOMPtr < nsIXPConnect > xpc ( do_GetService ( nsIXPConnect::GetCID ( ) ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( xpc , nullptr ) ; <NEW_LINE> nsCOMPtr < nsIXPConnectJSObjectHolder > holder ; <NEW_LINE> xpc -> WrapNative ( cx , ::JS_GetGlobalObject ( cx ) , element , <NEW_LINE> NS_GET_IID ( nsIDOMElement ) ,
mForSTARTTLS ( PR_FALSE ) , <NEW_LINE> mHandshakePending ( PR_TRUE ) , <NEW_LINE> mCanceled ( PR_FALSE ) , <NEW_LINE> mHasCleartextPhase ( PR_FALSE ) , <NEW_LINE> mHandshakeInProgress ( PR_FALSE ) , <NEW_LINE> mAllowTLSIntoleranceTimeout ( PR_TRUE ) , <NEW_LINE> mRememberClientAuthCertificate ( PR_FALSE ) , <NEW_LINE> mHandshakeStartTime ( 0 ) , <NEW_LINE> <START_VULN> mPort ( 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> mThreadData = new nsSSLSocketThreadData ; <NEW_LINE> } <NEW_LINE> nsNSSSocketInfo:: ~ nsNSSSocketInfo ( ) <NEW_LINE> { <NEW_LINE> delete mThreadData ;
len - = 4 ; <NEW_LINE> memcpy ( xml , filename , len ) ; <NEW_LINE> xml [ len ] = 0 ; <NEW_LINE> <START_VULN> snprintf ( result , 499 , "result / pattern / % s" , baseFilename ( xml ) ) ; <NEW_LINE>result [ 499 ] = 0 ; <NEW_LINE> <END_VULN> memcpy ( xml + len , " . xml" , 5 ) ; <NEW_LINE> if ( ! checkTestFile ( xml ) && ! update_results ) {
case 2: <NEW_LINE> data16 = get_unaligned_le16 ( & report [ i ] ) ; <NEW_LINE> break ; <NEW_LINE> <START_VULN> case 3: <NEW_LINE>size = 4 ; <NEW_LINE> <END_VULN> data32 = get_unaligned_le32 ( & report [ i ] ) ; <NEW_LINE> break ; <NEW_LINE> }
if ( ! lf -> mode_ref_delta_enabled ) { <NEW_LINE> <START_VULN> vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> int ref , mode ; <NEW_LINE> const int intra_lvl = lvl_seg + lf -> ref_deltas [ INTRA_FRAME ] * scale ;
assert ( host -> streams ) ; <NEW_LINE> if ( schr ( mime , ' ; ' ) ) { <NEW_LINE> <START_VULN> mime = stok ( sclone ( mime ) , " ; " , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ( kp = mprLookupKeyEntry ( host -> streams , mime ) ) != 0 ) { <NEW_LINE> if ( kp -> data == NULL || sstarts ( uri , kp -> data ) ) {
if ( ! buffer_uptodate ( * wait_bh ) ) <NEW_LINE> err = - EIO ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! err ) <NEW_LINE>return err ; <NEW_LINE><NEW_LINE> <END_VULN> bh = head ;
protected: <NEW_LINE> nsPresContext * mPresContext ; <NEW_LINE> nsCOMPtr < nsIPresShell > mPresShell ; <NEW_LINE> nsCOMPtr < nsISelection > mSelection ; <NEW_LINE> nsRefPtr < nsRange > mFirstSelectedRange ; <NEW_LINE> nsCOMPtr < nsIContent > mRootContent ; <NEW_LINE> nsresult Init ( nsQueryContentEvent * aEvent ) ; <NEW_LINE> nsresult Init ( nsSelectionEvent * aEvent ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> nsresult InitCommon ( ) ; <NEW_LINE> public: <NEW_LINE> static nsresult GetFlatTextOffsetOfRange ( nsIContent * aRootContent , <NEW_LINE> nsINode * aNode , <NEW_LINE> int32_t aNodeOffset ,
} <NEW_LINE> offset = param_end_offset ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> tokenlen = param_end_offset - next_offset + 1 ; <NEW_LINE>proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , <NEW_LINE>" % s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ) ; <NEW_LINE>offset = param_end_offset ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
if ( number_colormaps == 1 ) <NEW_LINE> for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == <NEW_LINE> <END_VULN> MagickFalse ) <NEW_LINE> break ; <NEW_LINE> * p = colormap [ ( ssize_t ) index ] ;
static PRUint32 GetWorkerCloseHandlerTimeoutMS ( ) ; <NEW_LINE> PRBool QueueSuspendedWorker ( nsDOMWorkerRunnable * aRunnable ) ; <NEW_LINE> nsCOMPtr < nsIThreadPool > mThreadPool ; <NEW_LINE> <START_VULN> nsRefPtrHashtable < nsISupportsHashKey , nsDOMWorkerPool > mPools ; <NEW_LINE> <END_VULN> PRMonitor * mMonitor ; <NEW_LINE> nsRefPtrHashtable < nsVoidPtrHashKey , nsDOMWorkerRunnable > mWorkersInProgress ;
PARSE_FIELD_INT ( z . multi ) ; <NEW_LINE> PARSE_FIELD_STR ( z . multi_uid ) ; <NEW_LINE> <START_VULN> if ( lose ) { <NEW_LINE>ND_PRINT ( ( ndo , " [ | zephyr ] ( % d ) " , length ) ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , " zephyr" ) ) ; <NEW_LINE> if ( strncmp ( z . version + 4 , "0 . 2" , 3 ) ) {
int rc ; <NEW_LINE> int param_num = SvIV ( param ) ; <NEW_LINE> int idx = param_num - 1 ; <NEW_LINE> <START_VULN> char err_msg [ 64 ] ; <NEW_LINE> <END_VULN> D_imp_xxh ( sth ) ; <NEW_LINE> #if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
static void locationAttributeSetter ( v8::Local < v8::Value > jsValue , const v8::PropertyCallbackInfo < void > & info ) <NEW_LINE> { <NEW_LINE> TestObject * proxyImp = V8TestObject::toNative ( info . Holder ( ) ) ; <NEW_LINE> <START_VULN> TestNode * imp = WTF::getPtr ( proxyImp -> location ( ) ) ; <NEW_LINE> <END_VULN> if ( ! imp ) <NEW_LINE> return ; <NEW_LINE> V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID ( V8StringResource < > , cppValue , jsValue ) ;
ASSERT ( ! WTF::IsTriviallyDestructible < T > ::value ) ; <NEW_LINE> HeapObjectHeader * header = HeapObjectHeader::fromPayload ( pointer ) ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> size_t length = header -> payloadSize ( ) / sizeof ( T ) ;
{ <NEW_LINE> js_delete ( functionWrappers_ ) ; <NEW_LINE> freeOsrTempData ( ) ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> IonRuntime::initialize ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> <START_VULN> AutoEnterAtomsCompartment ac ( cx ) ; <NEW_LINE> <END_VULN> IonContext ictx ( cx , NULL ) ; <NEW_LINE> AutoFlushCache afc ( "IonRuntime::initialize" ) ; <NEW_LINE> execAlloc_ = cx -> runtime ( ) -> getExecAlloc ( cx ) ; <NEW_LINE> if ( ! execAlloc_ ) <NEW_LINE> return false ;
} ; <NEW_LINE> static const uint32_t SJISCharLenTable [ ] = { 0 , 1 , 1 , 2 , 0 , 0 } ; <NEW_LINE> const SMModel SJISSMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , SJIS_cls } , <NEW_LINE> 6 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , SJIS_st } , <NEW_LINE> <START_VULN> SJISCharLenTable , <NEW_LINE> <END_VULN> "Shift_JIS" , <NEW_LINE> } ; <NEW_LINE> static const uint32_t UTF8_cls [ 256 / 8 ] = { <NEW_LINE> PCK4BITS ( 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ) , <NEW_LINE> PCK4BITS ( 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 ) ,
int syscall_nr ; <NEW_LINE> syscall_nr = trace_get_syscall_nr ( current , regs ) ; <NEW_LINE> <START_VULN> if ( syscall_nr < 0 ) <NEW_LINE> <END_VULN> return ;
sprintf ( s_path , " % s % s % d" , HSM_FM_SCK_PREFIX , mgr_prefix , hdl -> instance ) ; <NEW_LINE> <START_VULN> sprintf ( c_path , " % s % s % d_C_ % lu" , HSM_FM_SCK_PREFIX , mgr_prefix , <END_VULN> <NEW_LINE> <START_VULN> hdl -> instance , ( long unsigned ) pid ) ; <END_VULN> <NEW_LINE> <NEW_LINE> if ( * mgr_hdl == NULL ) <NEW_LINE> {
if ( row ) { <NEW_LINE> gdFree ( row ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> return ; <NEW_LINE> <END_VULN> } <NEW_LINE> cinfo . err -> error_exit = fatal_jpeg_error ;
} <NEW_LINE> if ( ! dcont && ! check_content ( cms ) ) <NEW_LINE> return 0 ; <NEW_LINE> if ( pk && ! CMS_decrypt_set1_pkey ( cms , pk , cert ) ) <NEW_LINE> return 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> cont = CMS_dataInit ( cms , dcont ) ; <NEW_LINE> if ( ! cont ) <NEW_LINE> return 0 ;
if ( args . Length ( ) != 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> WebGLRenderingContext * context = V8WebGLRenderingContext::toNative ( args . Holder ( ) ) ; <NEW_LINE> if ( args . Length ( ) > 0 && ! isUndefinedOrNull ( args [ 0 ] ) && ! V8WebGLUniformLocation::HasInstance ( args [ 0 ] ) ) {
} <NEW_LINE> bool <NEW_LINE> GetElementParIC::attachTypedArrayElement ( LockedJSContext & cx , IonScript * ion , <NEW_LINE> TypedArrayObject * tarr , const Value & idval ) <NEW_LINE> { <NEW_LINE> MacroAssembler masm ( cx ) ; <NEW_LINE> DispatchStubPrepender attacher ( * this ) ; <NEW_LINE> <START_VULN> GenerateGetTypedArrayElement ( cx , masm , attacher , tarr , idval , object ( ) , index ( ) , output ( ) ) ; <NEW_LINE> <END_VULN> return linkAndAttachStub ( cx , masm , attacher , ion , "parallel typed array" ) ; <NEW_LINE> } <NEW_LINE> ParallelResult <NEW_LINE> GetElementParIC::update ( ForkJoinSlice * slice , size_t cacheIndex , HandleObject obj , <NEW_LINE> HandleValue idval , MutableHandleValue vp ) <NEW_LINE> { <NEW_LINE> AutoFlushCache afc ( "GetElementParCache" , slice -> runtime ( ) -> ionRuntime ( ) ) ;
* ( dp ++ ) = red ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( have_alpha ) <NEW_LINE> <END_VULN> * ( dp ++ ) = * ( sp ++ ) ; <NEW_LINE> } <NEW_LINE> }
for ( j = 0 ; j < source -> y_width ; j += 16 ) <NEW_LINE> { <NEW_LINE> unsigned int sse ; <NEW_LINE> <START_VULN> Total += vp8_mse16x16 ( src + j , source -> y_stride , <NEW_LINE> <END_VULN> dst + j , dest -> y_stride , <NEW_LINE> & sse ) ; <NEW_LINE> }
} <NEW_LINE> for ( j = first ; j < last ; j ++ ) { <NEW_LINE> int ret = 0 ; <NEW_LINE> ve -> stretch ++ ; <NEW_LINE> if ( ve -> stretch > VE_MAXSTRETCH * 2 ) <NEW_LINE> ve -> stretch = VE_MAXSTRETCH * 2 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( i = 0 ; i < ve -> ch ; i ++ ) { <NEW_LINE> float * pcm = v -> pcm [ i ] + ve -> searchstep * ( j ) ; <NEW_LINE> ret |= _ve_amp ( ve , gi , pcm , ve -> band , ve -> filter + i * VE_BANDS ) ; <NEW_LINE> } <NEW_LINE> ve -> mark [ j + VE_POST ] = 0 ; <NEW_LINE> if ( ret & 1 ) { <NEW_LINE> ve -> mark [ j ] = 1 ;
: clasp ( clasp ) , proto ( proto ) , parent ( parent ) , <NEW_LINE> nfixed ( nfixed ) , baseFlags ( baseFlags ) <NEW_LINE> { } <NEW_LINE> } ; <NEW_LINE> inline InitialShapeEntry ( ) ; <NEW_LINE> inline InitialShapeEntry ( const ReadBarriered < Shape > & shape , TaggedProto proto ) ; <NEW_LINE> <START_VULN> inline Lookup getLookup ( ) ; <NEW_LINE> <END_VULN> static inline HashNumber hash ( const Lookup & lookup ) ; <NEW_LINE> static inline bool match ( const InitialShapeEntry & key , const Lookup & lookup ) ; <NEW_LINE> } ; <NEW_LINE> typedef HashSet < InitialShapeEntry , InitialShapeEntry , SystemAllocPolicy > InitialShapeSet ; <NEW_LINE> struct StackShape
MprJson * result ; <NEW_LINE> if ( key && ! strpbrk ( key , " . [ ] * " ) ) { <NEW_LINE> <START_VULN> return mprLookupJson ( obj , key ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ( result = mprQueryJson ( obj , key , 0 , 0 ) ) != 0 ) { <NEW_LINE> if ( result -> length == 1 && result -> children -> type & MPR_JSON_VALUE ) {
YV12_BUFFER_CONFIG * post , <NEW_LINE> int q , <NEW_LINE> int low_var_thresh , <NEW_LINE> <START_VULN> int flag ) ; <NEW_LINE> <END_VULN> void vp8_deblock ( struct VP8Common * oci , <NEW_LINE> YV12_BUFFER_CONFIG * source ,
if ( mShaderValidation ) { <NEW_LINE> if ( ! ShInitialize ( ) ) { <NEW_LINE> LogMessage ( "GLSL translator initialization failed ! " ) ; <NEW_LINE> return PR_FALSE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>error = gl -> fGetError ( ) ; <NEW_LINE> <END_VULN> if ( error != LOCAL_GL_NO_ERROR ) { <NEW_LINE> LogMessage ( "GL error 0x % x occurred during WebGL context initialization ! " , error ) ; <NEW_LINE> return PR_FALSE ; <NEW_LINE> } <NEW_LINE> return PR_TRUE ; <NEW_LINE> }
nsIDocument * document = aBoundElement -> GetOwnerDoc ( ) ; <NEW_LINE> if ( ! document ) return NS_OK ; <NEW_LINE> <START_VULN> nsIScriptGlobalObject * global = document -> GetScriptGlobalObject ( ) ; <NEW_LINE> <END_VULN> if ( ! global ) return NS_OK ; <NEW_LINE> nsCOMPtr < nsIScriptContext > context = global -> GetContext ( ) ;
unsigned int dest_width ) { <NEW_LINE> ( void ) dest_pitch ; <NEW_LINE> ( void ) src_pitch ; <NEW_LINE> <START_VULN> vpx_memcpy ( dest , source , dest_width ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void vp8_vertical_band_2_1_scale_i_c ( unsigned char * source ,
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #ifndef __SSL_ERR_H_ <NEW_LINE> #define __SSL_ERR_H_ <NEW_LINE> #define SSL_ERROR_BASE ( - 0x3000 ) <NEW_LINE> #define SSL_ERROR_LIMIT ( SSL_ERROR_BASE + 1000 ) <NEW_LINE> #define IS_SSL_ERROR ( code ) \
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) <NEW_LINE> { <NEW_LINE> <START_VULN> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int mount_entry_on_absolute_rootfs ( struct mntent * mntent ,
if ( ! ent1 -> data ) { <NEW_LINE> if ( stack -> top > 1 ) { <NEW_LINE> stack -> top -- ; <NEW_LINE> } else { <NEW_LINE> stack -> done = 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> efree ( ent1 ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
if ( args . Length ( ) < 3 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> bool ok = false ;
} ; <NEW_LINE> private: <NEW_LINE> <START_VULN> DISALLOW_IMPLICIT_CONSTRUCTORS ( AutoLock ) ; <NEW_LINE> <END_VULN> CRITICAL_SECTION * lock_ ; <NEW_LINE> } ;
if ( corrupted && pbi ) <NEW_LINE> { <NEW_LINE> <START_VULN> * corrupted = pbi -> common . frame_to_show -> corrupted ; <NEW_LINE><NEW_LINE> <END_VULN> return VPX_CODEC_OK ; <NEW_LINE> } <NEW_LINE> else
nsCOMPtr < nsISupports > container = mObjectFrame -> PresContext ( ) -> GetContainer ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( container , NS_ERROR_FAILURE ) ; <NEW_LINE> nsCOMPtr < nsILinkHandler > lh = do_QueryInterface ( container ) ; <NEW_LINE> NS_ENSURE_TRUE ( lh , NS_ERROR_FAILURE ) ; <NEW_LINE> nsAutoString unitarget ; <NEW_LINE> unitarget . AssignASCII ( aTarget ) ; <NEW_LINE> <START_VULN> nsCOMPtr < nsIURI > baseURI = mContent -> GetBaseURI ( ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIURI > uri ; <NEW_LINE> nsresult rv = NS_NewURI ( getter_AddRefs ( uri ) , aURL , baseURI ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , NS_ERROR_FAILURE ) ; <NEW_LINE> nsCOMPtr < nsIInputStream > headersDataStream ;
{ <NEW_LINE> NS_PRECONDITION ( ! mIsDocumentGone , "Unexpected ContentInserted" ) ; <NEW_LINE> NS_PRECONDITION ( aDocument == mDocument , "Unexpected aDocument" ) ; <NEW_LINE> if ( ! mDidInitialReflow ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE> <END_VULN> if ( aContainer ) <NEW_LINE> mFrameConstructor -> RestyleForInsertOrChange ( aContainer , aChild ) ; <NEW_LINE> mFrameConstructor -> ContentInserted ( aContainer , aChild ,
png_debug1 ( 1 , "in % s retrieval function" , "gAMA" ) ; <NEW_LINE> if ( png_ptr != NULL && info_ptr != NULL && <NEW_LINE> <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_GAMMA ) && <NEW_LINE> <END_VULN> file_gamma != NULL ) <NEW_LINE> { <NEW_LINE> * file_gamma = info_ptr -> colorspace . gamma ;
return - 1 ; <NEW_LINE> hdrlen = 2 ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> switch ( pimv2_addr_len ) { <NEW_LINE> <END_VULN> case sizeof ( struct in_addr ) : <NEW_LINE> af = AF_INET ; <NEW_LINE> break ;
unsigned int computed_mac_length ; <NEW_LINE> unsigned char iv [ AES_BLOCK_SIZE ] ; <NEW_LINE> SECItem ivItem ; <NEW_LINE> SECItem * srvName = NULL ; <NEW_LINE> PRUint32 srvNameLen = 0 ; <NEW_LINE> CK_MECHANISM_TYPE msWrapMech = 0 ; <NEW_LINE> <START_VULN> SSL_TRC ( 3 , ( " % d: SSL3 [ % d ] : send session_ticket handshake" , <NEW_LINE>SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> <END_VULN> PORT_Assert ( ss -> opt . noLocks || ssl_HaveXmitBufLock ( ss ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> ticket . ticket_lifetime_hint = TLS_EX_SESS_TICKET_LIFETIME_HINT ; <NEW_LINE> cert_length = ( ss -> opt . requestCertificate && ss -> sec . ci . sid -> peerCert ) ? <NEW_LINE> 3 + ss -> sec . ci . sid -> peerCert -> derCert . len : 0 ;
goto error ; <NEW_LINE> } <NEW_LINE> if ( ! bmp_issupported ( & hdr , info ) ) { <NEW_LINE> jas_eprintf ( "error: unsupported BMP encoding\n" ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> goto error ; <NEW_LINE> }
vA = buf [ 1 ] & 0x0f ; <NEW_LINE> vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; <NEW_LINE> vC = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> snprintf ( str , sizeof ( str ) , " v % i , v % i , 0x % 08"PFMT64x , vA , vB , a -> pc + ( vC * 2 ) ) ; <NEW_LINE> strasm = r_str_concat ( strasm , str ) ; <NEW_LINE> break ;
void SetWindowRect ( const IntRect & , LocalFrame & ) override ; <NEW_LINE> IntRect RootWindowRect ( ) override ; <NEW_LINE> IntRect PageRect ( ) override ; <NEW_LINE> <START_VULN> void Focus ( ) override ; <NEW_LINE> <END_VULN> bool CanTakeFocus ( WebFocusType ) override ; <NEW_LINE> void TakeFocus ( WebFocusType ) override ; <NEW_LINE> void FocusedNodeChanged ( Node * from_node , Node * to_node ) override ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . overloadedMethod11" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> EXCEPTION_BLOCK ( int , arg , toInt32 ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> TestObj::overloadedMethod1 ( arg ) ; <NEW_LINE> return v8::Handle < v8::Value > ( ) ;
mInitialized = PR_TRUE ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsDOMOfflineResourceList::Disconnect ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> mCheckingListeners . Clear ( ) ; <NEW_LINE>mErrorListeners . Clear ( ) ; <NEW_LINE>mNoUpdateListeners . Clear ( ) ; <NEW_LINE>mDownloadingListeners . Clear ( ) ; <NEW_LINE>mProgressListeners . Clear ( ) ; <NEW_LINE>mCachedListeners . Clear ( ) ; <NEW_LINE>mUpdateReadyListeners . Clear ( ) ; <NEW_LINE>mObsoleteListeners . Clear ( ) ; <NEW_LINE><NEW_LINE> <END_VULN> mOnCheckingListener = nsnull ; <NEW_LINE> mOnErrorListener = nsnull ; <NEW_LINE> mOnNoUpdateListener = nsnull ; <NEW_LINE> mOnDownloadingListener = nsnull ; <NEW_LINE> mOnProgressListener = nsnull ; <NEW_LINE> mOnCachedListener = nsnull ; <NEW_LINE> mOnUpdateReadyListener = nsnull ; <NEW_LINE> mOnObsoleteListener = nsnull ; <NEW_LINE> mPendingEvents . Clear ( ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsDOMOfflineResourceList::GetMozItems ( nsIDOMDOMStringList ** aItems )
rv = mSocketIn -> Read ( buffer , 512 , & count ) ; <NEW_LINE> if ( rv != NS_BASE_STREAM_WOULD_BLOCK && <NEW_LINE> ( NS_FAILED ( rv ) || count == 0 ) ) <NEW_LINE> mTCPClosed = true ; <NEW_LINE> } while ( NS_SUCCEEDED ( rv ) && count > 0 && total < 32000 ) ; <NEW_LINE> } <NEW_LINE> if ( ! mTCPClosed && mTransport && sWebSocketAdmissions && <NEW_LINE> <START_VULN> sWebSocketAdmissions -> ConnectedCount ( ) < kLingeringCloseThreshold ) { <NEW_LINE> <END_VULN>
observerService -> NotifyObservers ( static_cast < nsIOfflineCacheUpdate * > ( this ) , <NEW_LINE> "offline - cache - update - completed" , <NEW_LINE> nullptr ) ; <NEW_LINE> LOG ( ( "Done offline - cache - update - completed" ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> this -> Release ( ) ; <NEW_LINE> <END_VULN> return true ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
status_t SampleTable::setTimeToSampleParams ( <NEW_LINE> off64_t data_offset , size_t data_size ) { <NEW_LINE> <START_VULN> if ( ! mTimeToSample . empty ( ) || data_size < 8 ) { <NEW_LINE> <END_VULN> return ERROR_MALFORMED ; <NEW_LINE> }
return 0 ; <NEW_LINE> domount: <NEW_LINE> <START_VULN> if ( mount ( "proc" , path , "proc" , 0 , NULL ) ) <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> INFO ( "Mounted / proc in container for security transition" ) ; <NEW_LINE> return 1 ;
virtual int64 GetId ( ) const ; <NEW_LINE> <START_VULN> <NEW_LINE>const base::Time & GetModificationTime ( ) const ; <NEW_LINE> <END_VULN>
Vector < BlackBerry::Platform::TouchPoint > t ; <NEW_LINE> for ( Vector < BlackBerry::Platform::TouchPoint > ::iterator it = touches . begin ( ) ; it != touches . end ( ) ; ++ it ) { <NEW_LINE> <START_VULN> if ( it -> m_state != BlackBerry::Platform::TouchPoint::TouchReleased ) { <NEW_LINE>it -> m_state = BlackBerry::Platform::TouchPoint::TouchStationary ; <NEW_LINE> <END_VULN> t . append ( * it ) ; <NEW_LINE> } <NEW_LINE> }
perf_event_header__init_id ( & comm_event -> event_id . header , & sample , event ) ; <NEW_LINE> ret = perf_output_begin ( & handle , event , <NEW_LINE> <START_VULN> comm_event -> event_id . header . size , 0 , 0 ) ; <NEW_LINE> <END_VULN> if ( ret ) <NEW_LINE> goto out ;
appendItem ( result , queryLeaf ( obj , property , value , flags ) ) ; <NEW_LINE> break ; <NEW_LINE> <START_VULN> } else if ( ( child = mprLookupJsonObj ( obj , property ) ) == 0 ) { <NEW_LINE> <END_VULN> if ( value ) { <NEW_LINE> child = mprCreateJson ( termType & JSON_PROP_ARRAY ? MPR_JSON_ARRAY : MPR_JSON_OBJ ) ; <NEW_LINE> setProperty ( obj , sclone ( property ) , child ) ;
struct inode ; <NEW_LINE> <START_VULN> extern int parse_rock_ridge_inode ( struct iso_directory_record * , struct inode * ) ; <NEW_LINE> <END_VULN> extern int get_rock_ridge_filename ( struct iso_directory_record * , char * , struct inode * ) ; <NEW_LINE> extern int isofs_name_translate ( struct iso_directory_record * , char * , struct inode * ) ;
if ( ! path ) { <NEW_LINE> path = sclone ( option ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> option = stok ( option , " = \t , " , & ovalue ) ; <NEW_LINE> <END_VULN> ovalue = strim ( ovalue , "\"'" , MPR_TRIM_BOTH ) ; <NEW_LINE> if ( smatch ( option , "anew" ) ) { <NEW_LINE> flags |= MPR_LOG_ANEW ;
LOG ( ( "userfonts ( % p ) [ src % d ] failed uri: ( % s ) for ( % s ) error making platform font\n" , <NEW_LINE> this , pe -> mSrcIndex , fontURI . get ( ) , <NEW_LINE> NS_ConvertUTF16toUTF8 ( pe -> mFamily -> Name ( ) ) . get ( ) ) ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> <START_VULN> if ( aFontData ) { <NEW_LINE>NS_Free ( ( void * ) aFontData ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> #ifdef PR_LOGGING <NEW_LINE> if ( LOG_ENABLED ( ) ) { <NEW_LINE> nsCAutoString fontURI ; <NEW_LINE> pe -> mSrcList [ pe -> mSrcIndex ] . mURI -> GetSpec ( fontURI ) ; <NEW_LINE> LOG ( ( "userfonts ( % p ) [ src % d ] failed uri: ( % s ) for ( % s ) error % 8 . 8x downloading font data\n" , <NEW_LINE> this , pe -> mSrcIndex , fontURI . get ( ) , <NEW_LINE> NS_ConvertUTF16toUTF8 ( pe -> mFamily -> Name ( ) ) . get ( ) , <NEW_LINE> aDownloadStatus ) ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> LoadStatus status ; <NEW_LINE>
return ; <NEW_LINE> m_data -> context -> SetPen ( wxPen ( strokeColor ( ) , strokeThickness ( ) , strokeStyleToWxPenStyle ( strokeStyle ( ) ) ) ) ; <NEW_LINE> <START_VULN> m_data -> context -> DrawEllipticArc ( rect . x ( ) , rect . y ( ) , rect . width ( ) , rect . height ( ) , startAngle , angleSpan ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void GraphicsContext::drawConvexPolygon ( size_t npoints , const FloatPoint * points , bool shouldAntialias )
if ( saddr ) { <NEW_LINE> saddr -> family = AF_IEEE802154 ; <NEW_LINE> saddr -> addr = mac_cb ( skb ) -> sa ; <NEW_LINE> <START_VULN> } <NEW_LINE>if ( addr_len ) <NEW_LINE> <END_VULN> * addr_len = sizeof ( * saddr ) ; <NEW_LINE> if ( flags & MSG_TRUNC ) <NEW_LINE> copied = skb -> len ;
} <NEW_LINE> if ( IS_NOT_NULL ( Else ) ) { <NEW_LINE> <START_VULN> int else_len = compile_length_tree ( Else , reg ) ; <NEW_LINE>r = add_op ( reg , OP_JUMP ) ; <NEW_LINE>if ( r != 0 ) return r ; <NEW_LINE>COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ; <NEW_LINE> <END_VULN> r = compile_tree ( Else , reg , env ) ; <NEW_LINE> } <NEW_LINE> }
ND_TCHECK2 ( * ptr , len ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( EXTRACT_16BITS ( ptr ) & L2TP_AVP_HDR_FLAG_MANDATORY ) { <NEW_LINE> ND_PRINT ( ( ndo , " * " ) ) ;
if ( args . Length ( ) != 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> bool ok = false ; <NEW_LINE> int index = - 1 ;
ALOGV ( "setDataSource ( % s ) " , url ) ; <NEW_LINE> status_t err = BAD_VALUE ; <NEW_LINE> if ( url != NULL ) { <NEW_LINE> <START_VULN> const sp < IMediaPlayerService > & service ( getMediaPlayerService ( ) ) ; <NEW_LINE> <END_VULN> if ( service != 0 ) { <NEW_LINE> sp < IMediaPlayer > player ( service -> create ( this , mAudioSessionId ) ) ; <NEW_LINE> if ( ( NO_ERROR != doSetRetransmitEndpoint ( player ) ) ||
} <NEW_LINE> if ( MOZ_UNLIKELY ( aHeight <= 0 || aWidth <= 0 ) ) { <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> int32_t tmp = aWidth * aHeight ; <NEW_LINE>if ( MOZ_UNLIKELY ( tmp / aHeight != aWidth ) ) { <NEW_LINE>NS_WARNING ( "width or height too large" ) ; <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE>tmp = tmp * 4 ; <NEW_LINE>if ( MOZ_UNLIKELY ( tmp / 4 != aWidth * aHeight ) ) { <NEW_LINE> <END_VULN> NS_WARNING ( "width or height too large" ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> #if defined ( XP_MACOSX ) <NEW_LINE> if ( MOZ_UNLIKELY ( aHeight > SHRT_MAX ) ) { <NEW_LINE> NS_WARNING ( "image too big" ) ; <NEW_LINE> return false ;
NS_IMPL_ELEMENT_CLONE ( nsHTMLStyleElement ) <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsHTMLStyleElement::GetDisabled ( PRBool * aDisabled ) <NEW_LINE> { <NEW_LINE> nsresult result = NS_OK ; <NEW_LINE> <START_VULN> if ( mStyleSheet ) { <NEW_LINE>nsCOMPtr < nsIDOMStyleSheet > ss ( do_QueryInterface ( mStyleSheet ) ) ; <NEW_LINE> <END_VULN> if ( ss ) { <NEW_LINE> result = ss -> GetDisabled ( aDisabled ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> * aDisabled = PR_FALSE ; <NEW_LINE> }
{ <NEW_LINE> JSTestSerializedScriptValueInterfaceConstructor * castedThis = jsCast < JSTestSerializedScriptValueInterfaceConstructor * > ( exec -> callee ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 2 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> const String & hello ( ustringToString ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . isEmpty ( ) ? UString ( ) : MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . toString ( exec ) -> value ( exec ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
return ; <NEW_LINE> ASSERT ( filter -> isSVGResourceFilter ( ) ) ; <NEW_LINE> <START_VULN> if ( diff == StyleDifferenceEqual || ! oldStyle ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> const SVGRenderStyle * newStyle = this -> style ( ) -> svgStyle ( ) ;
NS_ENSURE_TRUE ( result , NS_ERROR_FAILURE ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> GetHelper::ReleaseMainThreadObjects ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( mCloneReadInfo . mCloneBuffer ) ; <NEW_LINE> <END_VULN> GetKeyHelper::ReleaseMainThreadObjects ( ) ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> GetHelper::PackArgumentsForParentProcess ( IndexRequestParams & aParams ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( mKeyRange , "This should never be null ! " ) ;
nsPluginInstanceOwner::GetContentsScaleFactor ( double * result ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_ARG_POINTER ( result ) ; <NEW_LINE> double scaleFactor = 1 . 0 ; <NEW_LINE> #if defined ( XP_MACOSX ) <NEW_LINE> <START_VULN> nsIPresShell * presShell = nsContentUtils::FindPresShellForDocument ( mContent -> OwnerDoc ( ) ) ; <NEW_LINE> <END_VULN> if ( presShell ) { <NEW_LINE> scaleFactor = double ( nsPresContext::AppUnitsPerCSSPixel ( ) ) / <NEW_LINE> presShell -> GetPresContext ( ) -> DeviceContext ( ) -> UnscaledAppUnitsPerDevPixel ( ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> * result = scaleFactor ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
} <NEW_LINE> } else { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>mElements . RemoveElement ( aContent ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
case EFFECT_CMD_ENABLE: <NEW_LINE> ALOGV ( "\tEffect_command cmdCode Case: EFFECT_CMD_ENABLE start" ) ; <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_ENABLE: ERROR" ) ; <NEW_LINE> return - EINVAL ; <NEW_LINE> }
#ifdef FLOAT_LOOKUP <NEW_LINE> #include "vorbis_lookup . c" <NEW_LINE> void vorbis_lsp_to_curve ( float * curve , int * map , int n , int ln , float * lsp , int m , <NEW_LINE> <START_VULN> float amp , float ampoffset ) { <NEW_LINE> <END_VULN> int i ; <NEW_LINE> float wdel = M_PI / ln ; <NEW_LINE> vorbis_fpu_control fpu ; <NEW_LINE> vorbis_fpu_setround ( & fpu ) ; <NEW_LINE> for ( i = 0 ; i < m ; i ++ ) lsp [ i ] = vorbis_coslook ( lsp [ i ] ) ; <NEW_LINE> i = 0 ;
if ( mKeys [ currKey ] . matchPattern -> matches ( aNode , & aEs ) ) { <NEW_LINE> txSingleNodeContext evalContext ( aNode , & aEs ) ; <NEW_LINE> nsresult rv = aEs . pushEvalContext ( & evalContext ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsRefPtr < txAExprResult > exprResult ; <NEW_LINE> rv = mKeys [ currKey ] . useExpr -> evaluate ( & evalContext , <NEW_LINE> getter_AddRefs ( exprResult ) ) ; <NEW_LINE> <START_VULN> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <END_VULN> aEs . popEvalContext ( ) ; <NEW_LINE> if ( exprResult -> getResultType ( ) == txAExprResult::NODESET ) { <NEW_LINE> txNodeSet * res = static_cast < txNodeSet * > <NEW_LINE> ( static_cast < txAExprResult * > <NEW_LINE> ( exprResult ) ) ; <NEW_LINE> PRInt32 i ; <NEW_LINE> for ( i = 0 ; i < res -> size ( ) ; ++ i ) { <NEW_LINE> val . Truncate ( ) ;
if ( p_stream -> p_headers ) <NEW_LINE> { <NEW_LINE> memcpy ( ( unsigned char * ) p_stream -> p_headers + p_stream -> i_headers - p_oggpacket -> bytes , <NEW_LINE> <START_VULN> p_oggpacket -> packet , p_stream -> i_headers ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else <NEW_LINE> {
if ( c == 'R' || c == '0' ) { <NEW_LINE> PINC ; <NEW_LINE> <START_VULN> if ( ! PPEEK_IS ( ' ) ' ) ) return ONIGERR_INVALID_GROUP_NAME ; <NEW_LINE> <END_VULN> PINC ; <NEW_LINE> name_end = name = p ; <NEW_LINE> gnum = 0 ;
virtual void SetLateness ( PRIntervalTime aHowLate ) ; <NEW_LINE> <START_VULN> nsresult Init ( nsIScriptContext * aContext , PRBool * aIsInterval , <NEW_LINE> <END_VULN> PRInt32 * aInterval ) ; <NEW_LINE> void ReleaseJSObjects ( ) ;
memcpy ( png_ptr -> prev_row , png_ptr -> row_buf , row_info . rowbytes + 1 ) ; <NEW_LINE> #ifdef PNG_READ_TRANSFORMS_SUPPORTED <NEW_LINE> <START_VULN> if ( png_ptr -> transformations ) <NEW_LINE> <END_VULN> png_do_read_transformations ( png_ptr , & row_info ) ; <NEW_LINE> #endif
base::WeakPtrFactory < WebGraphicsContext3DCommandBufferImpl > weak_ptr_factory_ ; <NEW_LINE> #ifdef FLIP_FRAMEBUFFER_VERTICALLY <NEW_LINE> <START_VULN> scoped_array < uint8 > scanline_ ; <NEW_LINE> <END_VULN> void FlipVertically ( uint8 * framebuffer , <NEW_LINE> unsigned int width , <NEW_LINE> unsigned int height ) ;
#ifdef PNG_READ_SUPPORTED <NEW_LINE> static void <NEW_LINE> <START_VULN> store_image_check ( PNG_CONST png_store * ps , png_const_structp pp , int iImage ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_const_bytep image = ps -> image ;
<START_VULN> void AddSharedWorker ( const GURL & worker , const std::string & name ) ; <NEW_LINE> <END_VULN> void Reset ( ) ;
} <NEW_LINE> if ( ! mIsValid ) { <NEW_LINE> NS_WARNING ( "invalid font ! expect incorrect text rendering" ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> bool ok = false ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>SetupCairoFont ( aContext ) ; <NEW_LINE> <END_VULN> #ifdef MOZ_GRAPHITE <NEW_LINE> if ( mGraphiteShaper && gfxPlatform::GetPlatform ( ) -> UseGraphiteShaping ( ) ) { <NEW_LINE> ok = mGraphiteShaper -> ShapeWord ( aContext , aShapedWord , aString ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> if ( ! ok && mHarfBuzzShaper ) {
case ( AVIFOURCC_vids ) : <NEW_LINE> p_strh -> strh . i_samplesize = 0 ; <NEW_LINE> p_chk -> strf . vids . i_cat = VIDEO_ES ; <NEW_LINE> <START_VULN> p_chk -> strf . vids . p_bih = malloc ( p_chk -> common . i_chunk_size ) ; <NEW_LINE> <END_VULN> AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSize ) ; <NEW_LINE> AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biWidth ) ; <NEW_LINE> AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biHeight ) ;
if ( popupType == eXULPopupType_popup ) { <NEW_LINE> nsCOMPtr < nsIContent > targetContent = do_QueryInterface ( target ) ; <NEW_LINE> <START_VULN> nsIAtom * tag = targetContent -> Tag ( ) ; <NEW_LINE>if ( tag == nsXULAtoms::menu || tag == nsXULAtoms::menuitem ) <NEW_LINE>return NS_OK ; <NEW_LINE> <END_VULN> }
RenderObject * curr = start ; <NEW_LINE> bool sawInline ; <NEW_LINE> do { <NEW_LINE> <START_VULN> while ( curr && ! ( curr -> isInline ( ) || curr -> isFloatingOrPositioned ( ) ) ) <NEW_LINE> <END_VULN> curr = curr -> nextSibling ( ) ; <NEW_LINE> inlineRunStart = inlineRunEnd = curr ;
return script ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> JSScript * script = fp -> script ( ) ; <NEW_LINE> if ( script -> compartment ( ) != cx_ -> compartment ) <NEW_LINE> return NULL ; <NEW_LINE> <START_VULN> if ( ppc ) <NEW_LINE> * ppc = fp -> pcQuadratic ( * this ) ; <NEW_LINE> <END_VULN> return script ; <NEW_LINE> } <NEW_LINE> inline JSObject * <NEW_LINE> ContextStack::currentScriptedScopeChain ( ) const <NEW_LINE> { <NEW_LINE> return & fp ( ) -> scopeChain ( ) ; <NEW_LINE> }
~ RenderFrameDevToolsAgentHost ( ) override ; <NEW_LINE> <START_VULN> void AttachSession ( DevToolsSession * session ) override ; <NEW_LINE> <END_VULN> void DetachSession ( DevToolsSession * session ) override ; <NEW_LINE> void InspectElement ( RenderFrameHost * frame_host , int x , int y ) override ; <NEW_LINE> void DispatchProtocolMessage ( DevToolsSession * session ,
{ <NEW_LINE> if ( ! mScope ) { <NEW_LINE> NS_WARNING ( "mScope must not be null when nsXPCComponents::PreCreate is called" ) ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> * parentObj = mScope -> GetGlobalJSObject ( ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> \ No newline at end of file <NEW_LINE>
#if defined ( OS_MACOSX ) <NEW_LINE> <START_VULN> void GetSettingsWithUI ( gfx::NativeWindow parent_window , <NEW_LINE> <END_VULN> int document_page_count , <NEW_LINE> bool has_selection ) ; <NEW_LINE> #endif
return ( in_cksum ( vec , 2 ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void <NEW_LINE> <END_VULN> ip_printts ( netdissect_options * ndo , <NEW_LINE> register const u_char * cp , u_int length ) <NEW_LINE> {
std::string * error ) const ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>bool CanCaptureVisiblePage ( int tab_id , std::string * error ) const ; <NEW_LINE> <END_VULN> const TabPermissionsMap & tab_specific_permissions ( ) const { <NEW_LINE> DCHECK ( ! thread_checker_ || thread_checker_ -> CalledOnValidThread ( ) ) ;
break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> } <NEW_LINE>if ( ptr_hbe_txposer -> k_start < 0 ) { <NEW_LINE>return - 1 ; <NEW_LINE> <END_VULN> } <NEW_LINE> return 0 ; <NEW_LINE> }
return 1 ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> <START_VULN> if ( sc_select_file ( card , & pin_info . path , & f ) != SC_SUCCESS ) { <NEW_LINE> <END_VULN> sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , "Select ( % s ) failed\n" , path ) ; <NEW_LINE> return 1 ; <NEW_LINE> }
public: <NEW_LINE> JSBool IsAvailable ( ) const { return mInterface == nsnull ; } <NEW_LINE> JSBool IsReserved ( ) const { return mInterface == ( XPCNativeInterface * ) 1 ; } <NEW_LINE> JSBool IsValid ( ) const { return ! IsAvailable ( ) && ! IsReserved ( ) ; } <NEW_LINE> void SetReserved ( ) { mInterface = ( XPCNativeInterface * ) 1 ; } <NEW_LINE> XPCNativeInterface * GetInterface ( ) const { return mInterface ; } <NEW_LINE> nsISupports * GetNative ( ) const { return mNative ; } <NEW_LINE> <START_VULN> JSObject * GetJSObject ( ) const ; <NEW_LINE> <END_VULN> void SetInterface ( XPCNativeInterface * Interface ) { mInterface = Interface ; } <NEW_LINE> void SetNative ( nsISupports * Native ) { mNative = Native ; } <NEW_LINE> void SetJSObject ( JSObject * JSObj ) ; <NEW_LINE> void JSObjectFinalized ( ) { SetJSObject ( nsnull ) ; } <NEW_LINE> XPCWrappedNativeTearOff ( ) <NEW_LINE> : mInterface ( nsnull ) , mNative ( nsnull ) , mJSObject ( nsnull ) { }
#ifdef PNG_READ_oFFs_SUPPORTED <NEW_LINE> else if ( chunk_name == png_oFFs ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_oFFs ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> } <NEW_LINE> #endif
static vpx_image_t * encoder_get_preview ( vpx_codec_alg_priv_t * ctx ) { <NEW_LINE> YV12_BUFFER_CONFIG sd ; <NEW_LINE> <START_VULN> vp9_ppflags_t flags = { 0 } ; <NEW_LINE> <END_VULN> if ( ctx -> preview_ppcfg . post_proc_flag ) { <NEW_LINE> flags . post_proc_flag = ctx -> preview_ppcfg . post_proc_flag ;
char buff [ MAXPATHLEN ] ; <NEW_LINE> char * filename ; <NEW_LINE> zend_error_handling error_handling ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
#define MAJOR_VERSION 0 <NEW_LINE> #define MINOR_VERSION 0 <NEW_LINE> #define BUILD_VERSION 0 <NEW_LINE> <START_VULN> #define BUILD_REVISION 740 <NEW_LINE> <END_VULN> #define STRINGIFY ( x ) #x <NEW_LINE> #define MACRO_STRINGIFY ( x ) STRINGIFY ( x ) <NEW_LINE> #define REVISION_STRING MACRO_STRINGIFY ( BUILD_REVISION ) <NEW_LINE> #define VERSION_STRING MACRO_STRINGIFY ( MAJOR_VERSION ) " . " MACRO_STRINGIFY ( MINOR_VERSION ) " . " MACRO_STRINGIFY ( BUILD_VERSION ) " . " MACRO_STRINGIFY ( BUILD_REVISION )
} <NEW_LINE> else <NEW_LINE> { <NEW_LINE> self -> mLanguage = nsIProgrammingLanguage::JAVASCRIPT ; <NEW_LINE> JSScript * script = JS_GetFrameScript ( cx , fp ) ; <NEW_LINE> jsbytecode * pc = JS_GetFramePC ( cx , fp ) ; <NEW_LINE> if ( script && pc ) <NEW_LINE> { <NEW_LINE> <START_VULN> JS::AutoEnterScriptCompartment ac ; <NEW_LINE>if ( ac . enter ( cx , script ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> const char * filename = JS_GetScriptFilename ( cx , script ) ; <NEW_LINE> if ( filename ) <NEW_LINE> { <NEW_LINE> self -> mFilename = ( char * ) <NEW_LINE> nsMemory::Clone ( filename , <NEW_LINE> sizeof ( char ) * ( strlen ( filename ) + 1 ) ) ; <NEW_LINE> }
autofill::RegionDataLoader * region_data_loader_ ; <NEW_LINE> PaymentRequestDialogView::ObserverForTest * observer_ ; <NEW_LINE> <START_VULN> bool is_incognito_ ; <NEW_LINE>bool is_valid_ssl_ ; <NEW_LINE> <END_VULN> DISALLOW_COPY_AND_ASSIGN ( TestChromePaymentRequestDelegate ) ; <NEW_LINE> } ;
DISALLOW_ALLOCATION ( ) ; <NEW_LINE> public: <NEW_LINE> typedef ResultType * ReturnType ; <NEW_LINE> <START_VULN> typedef Persistent < ResultType > StorageType ; <NEW_LINE> <END_VULN> static ReturnType createFromCallbackArg ( CallbackArg argument ) <NEW_LINE> {
} <NEW_LINE> if ( set_name ) { <NEW_LINE> <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <NEW_LINE> <END_VULN> fprintf ( stdout , "BT adapter is up\n" ) ; <NEW_LINE> bt_property_t * property = property_new_name ( bd_name ) ;
} <NEW_LINE> <START_VULN> if ( scrollableArea ( ) -> scroll ( pressedPartScrollDirection ( ) , pressedPartScrollGranularity ( ) ) ) <NEW_LINE> <END_VULN> startTimerIfNeeded ( delay ) ; <NEW_LINE> }
class nsHTMLParanoidFragmentSink : public nsHTMLFragmentContentSink <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> <START_VULN> nsHTMLParanoidFragmentSink ( ) ; <NEW_LINE> <END_VULN> static nsresult Init ( ) ; <NEW_LINE> static void Cleanup ( ) ; <NEW_LINE> NS_DECL_ISUPPORTS_INHERITED <NEW_LINE> NS_IMETHOD OpenContainer ( const nsIParserNode & aNode ) ;
JSTokenStream * ts ; <NEW_LINE> JSPrincipals * principals ; <NEW_LINE> jschar * collected_args , * cp ; <NEW_LINE> <START_VULN> size_t arg_length , args_length ; <NEW_LINE> <END_VULN> JSTokenType tt ; <NEW_LINE> JSBool ok ;
switch ( elem -> id ) { <NEW_LINE> case MFIE_TYPE_SSID: <NEW_LINE> <START_VULN> bss -> ssid_len = elem -> len ; <NEW_LINE>memcpy ( bss -> ssid , elem -> data , elem -> len ) ; <NEW_LINE> <END_VULN> lbs_deb_scan ( "got SSID IE: ' % s' , len % u\n" , <NEW_LINE> escape_essid ( bss -> ssid , bss -> ssid_len ) , <NEW_LINE> bss -> ssid_len ) ;
if ( ( regs -> sr & SR_IMASK ) != SR_IMASK ) <NEW_LINE> local_irq_enable ( ) ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN>
int mif_validate ( jas_stream_t * in ) <NEW_LINE> { <NEW_LINE> <START_VULN> uchar buf [ MIF_MAGICLEN ] ; <NEW_LINE> <END_VULN> uint_fast32_t magic ; <NEW_LINE> int i ; <NEW_LINE> int n ;
status_t OMXNodeInstance::fillBuffer ( OMX::buffer_id buffer , int fenceFd ) { <NEW_LINE> Mutex::Autolock autoLock ( mLock ) ; <NEW_LINE> <START_VULN> OMX_BUFFERHEADERTYPE * header = findBufferHeader ( buffer ) ; <NEW_LINE> <END_VULN> header -> nFilledLen = 0 ; <NEW_LINE> header -> nOffset = 0 ; <NEW_LINE> header -> nFlags = 0 ;
{ <NEW_LINE> unsigned int i ; <NEW_LINE> <START_VULN> for ( i = 0 ; i < TTABLE_SIZE ; ++ i ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( transform_info [ i ] . when & TRANSFORM_R ) <NEW_LINE> read_transforms |= transform_info [ i ] . transform ;
SQLITE_EXTENSION_INIT2 ( pApi ) ; <NEW_LINE> #ifndef SQLITE_OMIT_VIRTUALTABLE <NEW_LINE> rc = sqlite3_create_module ( db , "carray" , & carrayModule , 0 ) ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> return rc ; <NEW_LINE> }
case ESIS_OPTION_PROTOCOLS: <NEW_LINE> while ( opli > 0 ) { <NEW_LINE> <START_VULN> ND_TCHECK ( * pptr ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , " % s ( 0x % 02x ) " , <NEW_LINE> tok2str ( nlpid_values , <NEW_LINE> "unknown" ,
return ClipPaintPropertyNode::Create ( parent , std::move ( state ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> inline scoped_refptr < ClipPaintPropertyNode > CreateClipPathClip ( <NEW_LINE>scoped_refptr < const ClipPaintPropertyNode > parent , <NEW_LINE>scoped_refptr < const TransformPaintPropertyNode > local_transform_space , <NEW_LINE> <END_VULN> const FloatRoundedRect & clip_rect ) { <NEW_LINE> ClipPaintPropertyNode::State state ; <NEW_LINE> state . local_transform_space = local_transform_space ;
fsize += pkt -> data . frame . sz ; <NEW_LINE> if ( ! ( pkt -> data . frame . flags & VPX_FRAME_IS_FRAGMENT ) ) { <NEW_LINE> <START_VULN> off_t currpos = ftello ( stream -> file ) ; <NEW_LINE> <END_VULN> fseeko ( stream -> file , ivf_header_pos , SEEK_SET ) ; <NEW_LINE> ivf_write_frame_size ( stream -> file , fsize ) ; <NEW_LINE> fseeko ( stream -> file , currpos , SEEK_SET ) ;
if ( ! data ) { <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> IntSize size = data -> GetSize ( ) ; <NEW_LINE> gfxASurface::gfxImageFormat format = OptimalFormatForContent ( ContentForFormat ( data -> GetFormat ( ) ) ) ; <NEW_LINE> <START_VULN> surf = <NEW_LINE>new gfxImageSurface ( data -> GetData ( ) , gfxIntSize ( size . width , size . height ) , <NEW_LINE>data -> Stride ( ) , format ) ; <NEW_LINE><NEW_LINE>surf -> SetData ( & kDrawSourceSurface , data . forget ( ) . drop ( ) , DataSourceSurfaceDestroy ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> surf -> AddRef ( ) ; <NEW_LINE> aTarget -> AddUserData ( & kThebesSurfaceKey , surf . get ( ) , DestroyThebesSurface ) ; <NEW_LINE> return surf . forget ( ) ;
new_images = RemoveFirstImageFromList ( & _images ) ; <NEW_LINE> hald_image = RemoveLastImageFromList ( & _images ) ; <NEW_LINE> if ( hald_image == ( Image * ) NULL ) <NEW_LINE> <START_VULN> break ; <NEW_LINE> <END_VULN> ( void ) HaldClutImage ( new_images , hald_image , _exception ) ; <NEW_LINE> hald_image = DestroyImage ( hald_image ) ; <NEW_LINE> break ;
void set_config ( QuicStringPiece config ) { config . CopyToString ( & config_ ) ; } <NEW_LINE> QuicServerConfigProtobuf::PrivateKey * add_key ( ) { <NEW_LINE> <START_VULN> keys_ . push_back ( base::MakeUnique < PrivateKey > ( ) ) ; <NEW_LINE> <END_VULN> return keys_ . back ( ) . get ( ) ; <NEW_LINE> }
incode = code ; <NEW_LINE> <START_VULN> if ( code >= max_code ) <NEW_LINE> <END_VULN> { <NEW_LINE> * sp ++ = firstcode ; <NEW_LINE> code = oldcode ;
if ( ( pce = pcre_get_compiled_regex_cache ( regex , regex_len TSRMLS_CC ) ) == NULL ) { <NEW_LINE> RETURN_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> php_pcre_match_impl ( pce , subject , subject_len , return_value , subpats , <NEW_LINE> <END_VULN> global , ZEND_NUM_ARGS ( ) >= 4 , flags , start_offset TSRMLS_CC ) ; <NEW_LINE> }
return mHTMLEditor -> DeleteNode ( aNode -> AsDOMNode ( ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> for ( nsIContent * child = aNode -> GetLastChild ( ) ; <NEW_LINE> <END_VULN> child ; <NEW_LINE> child = child -> GetPreviousSibling ( ) ) { <NEW_LINE> nsresult rv = DeleteNonTableElements ( child ) ;
int vp9_release_frame_buffer ( void * cb_priv , vpx_codec_frame_buffer_t * fb ) { <NEW_LINE> InternalFrameBuffer * const int_fb = ( InternalFrameBuffer * ) fb -> priv ; <NEW_LINE> ( void ) cb_priv ; <NEW_LINE> <START_VULN> int_fb -> in_use = 0 ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , <NEW_LINE> errmsg ( "invalid input syntax for type polygon: \" % s\"" , str ) ) ) ; <NEW_LINE> <START_VULN> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <NEW_LINE> <END_VULN> poly = ( POLYGON * ) palloc0 ( size ) ; <NEW_LINE> SET_VARSIZE ( poly , size ) ;
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> Dictionary oo ( exec , MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
namespace blink { <NEW_LINE> <START_VULN> class CSSCustomIdentValue : public CSSValue { <NEW_LINE> <END_VULN> public: <NEW_LINE> static CSSCustomIdentValue * Create ( const AtomicString & str ) { <NEW_LINE> return new CSSCustomIdentValue ( str ) ;
nsCOMPtr < nsIURI > requestingURI ; <NEW_LINE> nsCOMPtr < nsIURI > popupURI ; <NEW_LINE> <START_VULN> nsCOMPtr < nsIWebNavigation > webNav ( do_GetInterface ( topWindow ) ) ; <NEW_LINE> <END_VULN> if ( webNav ) <NEW_LINE> webNav -> GetCurrentURI ( getter_AddRefs ( requestingURI ) ) ;
keyPairInfo -> ecPopPubKey = CERT_ExtractPublicKey ( keyPairInfo -> ecPopCert ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> if ( keyPairInfo -> ecPopPubKey ) <NEW_LINE> <END_VULN> { <NEW_LINE> returnParams = SECITEM_DupItem ( & keyPairInfo -> ecPopPubKey -> u . ec . DEREncodedParams ) ; <NEW_LINE> } <NEW_LINE> if ( ! returnParams && curve ) <NEW_LINE> { <NEW_LINE> returnParams = decode_ec_params ( curve ) ;
mTestControllingRefreshes = true ; <NEW_LINE> } <NEW_LINE> mMostRecentRefreshEpochTime += aMilliseconds * 1000 ; <NEW_LINE> mMostRecentRefresh += TimeDuration::FromMilliseconds ( ( double ) aMilliseconds ) ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> if ( pusher . PushNull ( ) ) { <NEW_LINE>DoTick ( ) ; <NEW_LINE>pusher . Pop ( ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsRefreshDriver::RestoreNormalRefresh ( ) <NEW_LINE> { <NEW_LINE> mTestControllingRefreshes = false ; <NEW_LINE> EnsureTimerStarted ( false ) ; <NEW_LINE> }
} ; <NEW_LINE> <START_VULN> const InterpKernel vp9_sub_pel_filters_8 [ SUBPEL_SHIFTS ] = { <NEW_LINE> <END_VULN> { 0 , 0 , 0 , 128 , 0 , 0 , 0 , 0 } , <NEW_LINE> { 0 , 1 , - 5 , 126 , 8 , - 3 , 1 , 0 } , <NEW_LINE> { - 1 , 3 , - 10 , 122 , 18 , - 6 , 2 , 0 } ,
double sigma ; <NEW_LINE> int ai = a , qi = q , i ; <NEW_LINE> <START_VULN> vp9_clear_system_state ( ) ; <NEW_LINE> <END_VULN> sigma = ai + . 5 + . 6 * ( 63 - qi ) / 63 . 0 ;
rv = NS_NewHTMLElement ( getter_AddRefs ( content ) , nodeInfo , PR_FALSE ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> AddAttributes ( aNode , content ) ; <NEW_LINE> ProcessBaseTag ( content ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> if ( ! sAllowedTags || ! sAllowedTags -> GetEntry ( name ) ) { <NEW_LINE> <START_VULN> return NS_OK ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> return nsHTMLFragmentContentSink::AddLeaf ( aNode ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsHTMLParanoidFragmentSink::AddComment ( const nsIParserNode & aNode )
void <NEW_LINE> mozJSComponentLoader::NoteSubScript ( HandleScript aScript , HandleObject aThisObject ) <NEW_LINE> { <NEW_LINE> if ( ! mInitialized && NS_FAILED ( ReallyInit ( ) ) ) { <NEW_LINE> MOZ_CRASH ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> mThisObjects . Put ( aScript , aThisObject ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> size_t <NEW_LINE> mozJSComponentLoader::DataEntrySizeOfExcludingThis ( const nsACString & aKey , <NEW_LINE> ModuleEntry * const & aData , <NEW_LINE> MallocSizeOf aMallocSizeOf , void * ) <NEW_LINE> { <NEW_LINE> return aKey . SizeOfExcludingThisIfUnshared ( aMallocSizeOf ) +
#define R TO_SMALL_CHAR <NEW_LINE> const StaticStrings::SmallChar StaticStrings::toSmallChar [ ] = { R7 ( 0 ) } ; <NEW_LINE> #undef R <NEW_LINE> bool <NEW_LINE> StaticStrings::init ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> <START_VULN> AutoEnterAtomsCompartment ac ( cx ) ; <NEW_LINE> <END_VULN> for ( uint32_t i = 0 ; i < UNIT_STATIC_LIMIT ; i ++ ) { <NEW_LINE> jschar buffer [ ] = { jschar ( i ) , '\0' } ; <NEW_LINE> JSFlatString * s = js_NewStringCopyN < CanGC > ( cx , buffer , 1 ) ; <NEW_LINE> if ( ! s ) <NEW_LINE> return false ; <NEW_LINE> unitStaticTable [ i ] = s -> morphAtomizedStringIntoAtom ( ) ; <NEW_LINE> }
static inline int btif_hl_select_wakeup ( void ) { <NEW_LINE> char sig_on = btif_hl_signal_select_wakeup ; <NEW_LINE> BTIF_TRACE_DEBUG ( "btif_hl_select_wakeup" ) ; <NEW_LINE> <START_VULN> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <NEW_LINE> <END_VULN> }
png_debug ( 1 , "in png_set_alpha_mode" ) ; <NEW_LINE> <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> output_gamma = translate_gamma_flags ( png_ptr , output_gamma , 1 ) ;
#ifndef MODULE_MAGIC_NUMBER_MAJOR <NEW_LINE> #define MODULE_MAGIC_NUMBER_MAJOR 20150222 <NEW_LINE> #endif <NEW_LINE> <START_VULN> #define MODULE_MAGIC_NUMBER_MINOR 2 <NEW_LINE> <END_VULN> AP_DECLARE ( int ) ap_some_auth_required ( request_rec * r ) ;
vpx_codec_err_t vpx_codec_enc_config_default ( vpx_codec_iface_t * iface , <NEW_LINE> vpx_codec_enc_cfg_t * cfg , <NEW_LINE> <START_VULN> unsigned int usage ) ; <NEW_LINE> <END_VULN>
} <NEW_LINE> } <NEW_LINE> <START_VULN> #if HAVE_NEON <NEW_LINE> <END_VULN> if ( mask & HAS_NEON ) { <NEW_LINE> __try {
if ( ( mContent -> Tag ( ) == nsGkAtoms::mtd_ ) && ! GetStyleContext ( ) -> GetPseudoType ( ) ) { <NEW_LINE> nsAutoString value ; <NEW_LINE> mContent -> GetAttr ( kNameSpaceID_None , nsGkAtoms::columnspan_ , value ) ; <NEW_LINE> if ( ! value . IsEmpty ( ) ) { <NEW_LINE> PRInt32 error ; <NEW_LINE> colspan = value . ToInteger ( & error ) ; <NEW_LINE> <START_VULN> if ( error || colspan < 0 ) <NEW_LINE> <END_VULN> colspan = 1 ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return colspan ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsMathMLmtdFrame::AttributeChanged ( PRInt32 aNameSpaceID ,
<START_VULN> <NEW_LINE> <END_VULN> if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || <NEW_LINE> ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ||
const char * auto_generate_sql_type = "mixed" ; <NEW_LINE> static unsigned long connect_flags = CLIENT_MULTI_RESULTS | <NEW_LINE> <START_VULN> CLIENT_MULTI_STATEMENTS | <END_VULN> <NEW_LINE> <START_VULN> CLIENT_REMEMBER_OPTIONS ; <END_VULN> <NEW_LINE> static int verbose , delimiter_length ;
: mDontLoadStyle ( PR_FALSE ) <NEW_LINE> , mUpdatesEnabled ( PR_TRUE ) <NEW_LINE> , mLineNumber ( 1 ) <NEW_LINE> { <NEW_LINE> } <NEW_LINE> nsStyleLinkElement:: ~ nsStyleLinkElement ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsCOMPtr < nsICSSStyleSheet > cssSheet = do_QueryInterface ( mStyleSheet ) ; <NEW_LINE>if ( cssSheet ) { <NEW_LINE>cssSheet -> SetOwningNode ( nsnull ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsStyleLinkElement::SetStyleSheet ( nsIStyleSheet * aStyleSheet ) <NEW_LINE> { <NEW_LINE> nsCOMPtr < nsICSSStyleSheet > cssSheet = do_QueryInterface ( mStyleSheet ) ; <NEW_LINE> if ( cssSheet ) { <NEW_LINE> cssSheet -> SetOwningNode ( nsnull ) ;
JSString * str = JSVAL_TO_STRING ( sConstructor_id ) ; <NEW_LINE> <START_VULN> if ( ! ::JS_SetUCProperty ( cx , obj , ::JS_GetStringChars ( str ) , <NEW_LINE>::JS_GetStringLength ( str ) , & val ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_UNEXPECTED ; <NEW_LINE> }
NS_IMETHODIMP <NEW_LINE> nsBaseChannel::Open ( nsIInputStream ** result ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_TRUE ( mURI , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE> NS_ENSURE_TRUE ( ! mPump , NS_ERROR_IN_PROGRESS ) ; <NEW_LINE> NS_ENSURE_TRUE ( ! mWasOpened , NS_ERROR_IN_PROGRESS ) ; <NEW_LINE> <START_VULN> nsresult rv = OpenContentStream ( PR_FALSE , result ) ; <NEW_LINE>if ( rv == NS_ERROR_NOT_IMPLEMENTED ) <NEW_LINE> <END_VULN> return NS_ImplementChannelOpen ( this , result ) ; <NEW_LINE> mWasOpened = NS_SUCCEEDED ( rv ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP
bool is_send_base_page_url_disabled_ ; <NEW_LINE> bool is_decode_mentions_disabled_cached_ ; <NEW_LINE> bool is_decode_mentions_disabled_ ; <NEW_LINE> <START_VULN> bool is_now_on_tap_bar_integration_enabled_cached_ ; <NEW_LINE>bool is_now_on_tap_bar_integration_enabled_ ; <NEW_LINE> <END_VULN> DISALLOW_COPY_AND_ASSIGN ( ContextualSearchFieldTrial ) ; <NEW_LINE> } ;
m_pOutput_pmem [ i ] . size = m_sOutPortDef . nBufferSize ; <NEW_LINE> m_pOutput_pmem [ i ] . offset = 0 ; <NEW_LINE> <START_VULN> m_pOutput_pmem [ i ] . buffer = ( OMX_U8 * ) SECURE_BUFPTR ; <NEW_LINE> <END_VULN> if ( ! secure_session ) { <NEW_LINE> #ifdef _MSM8974_ <NEW_LINE> m_pOutput_pmem [ i ] . buffer = ( unsigned char * ) mmap ( NULL ,
ext = strrchr ( szName , ' . ' ) ; <NEW_LINE> if ( ext && strlen ( ext ) > 19 ) ext = NULL ; <NEW_LINE> <START_VULN> if ( ext && strlen ( ext ) > 1 ) { <NEW_LINE> <END_VULN> strcpy ( szExt , & ext [ 1 ] ) ; <NEW_LINE> strlwr ( szExt ) ; <NEW_LINE> #ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS
} <NEW_LINE> listener = aWidget -> GetAttachedWidgetListener ( ) ; <NEW_LINE> return listener ? listener -> GetView ( ) : nullptr ; <NEW_LINE> } <NEW_LINE> void nsView::Destroy ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> delete this ; <NEW_LINE> <END_VULN> } <NEW_LINE> void nsView::SetPosition ( nscoord aX , nscoord aY ) <NEW_LINE> { <NEW_LINE> mDimBounds . x += aX - mPosX ; <NEW_LINE> mDimBounds . y += aY - mPosY ; <NEW_LINE> mPosX = aX ; <NEW_LINE> mPosY = aY ;
<START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> void OnMouseMoved ( const ui::MouseEvent & event ) override { } <NEW_LINE> AutofillPopupController * controller ( ) { return controller_ ; }
_y4m -> convert = y4m_convert_444_420jpeg ; <NEW_LINE> } else { <NEW_LINE> _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; <NEW_LINE> <START_VULN> _y4m -> vpx_bps = 32 ; <NEW_LINE> <END_VULN> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; <NEW_LINE> _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; <NEW_LINE> _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ;
} <NEW_LINE> void <NEW_LINE> IonBuilder::insertRecompileCheck ( ) <NEW_LINE> { <NEW_LINE> if ( ! inliningEnabled ( ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( inliningDepth > 0 ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> if ( script ( ) -> getUseCount ( ) >= js_IonOptions . usesBeforeInlining ( ) ) <NEW_LINE> return ;
( ( s3 - 1 ) -> bbox . xMax + ( s3 - 1 ) -> pos . x ) - <NEW_LINE> ( w -> bbox . xMin + w -> pos . x ) ) ; <NEW_LINE> <START_VULN> if ( DIFF ( l1_new , l2_new ) < DIFF ( l1 , l2 ) ) { <NEW_LINE> <END_VULN> w -> linebreak = 1 ; <NEW_LINE> s2 -> linebreak = 0 ; <NEW_LINE> exit = 0 ;
int flimit ) { <NEW_LINE> uint8_t const * p_src ; <NEW_LINE> uint8_t * p_dst ; <NEW_LINE> <START_VULN> int row ; <NEW_LINE>int col ; <NEW_LINE>int i ; <NEW_LINE>int v ; <NEW_LINE> <END_VULN> int pitch = src_pixels_per_line ; <NEW_LINE> uint8_t d [ 8 ] ; <NEW_LINE> ( void ) dst_pixels_per_line ;
} ; <NEW_LINE> JSBool <NEW_LINE> js_json_parse ( JSContext * cx , uintN argc , jsval * vp ) <NEW_LINE> { <NEW_LINE> JSString * s = NULL ; <NEW_LINE> jsval * argv = vp + 2 ; <NEW_LINE> jsval reviver = JSVAL_NULL ; <NEW_LINE> <START_VULN> JSAutoTempValueRooter ( cx , 1 , & reviver ) ; <NEW_LINE> <END_VULN> if ( ! JS_ConvertArguments ( cx , argc , argv , "S / v" , & s , & reviver ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> JSONParser * jp = js_BeginJSONParse ( cx , vp ) ; <NEW_LINE> JSBool ok = jp != NULL ; <NEW_LINE> if ( ok ) { <NEW_LINE> const jschar * chars ;
<START_VULN> static PNG_CONST <NEW_LINE> <END_VULN> png_byte adam7 [ 8 ] [ 8 ] = <NEW_LINE> { <NEW_LINE> { 1 , 6 , 4 , 6 , 2 , 6 , 4 , 6 } ,
int num_unknowns = png_get_unknown_chunks ( read_ptr , read_info_ptr , <NEW_LINE> & unknowns ) ; <NEW_LINE> <START_VULN> if ( num_unknowns ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_set_unknown_chunks ( write_ptr , write_info_ptr , unknowns , <NEW_LINE> num_unknowns ) ;
#ifndef BaseButtonInputType_h <NEW_LINE> #define BaseButtonInputType_h <NEW_LINE> <START_VULN> #include "core / html / forms / BaseClickableWithKeyInputType . h" <NEW_LINE> <END_VULN> #include "core / html / forms / InputType . h" <NEW_LINE> namespace blink {
unsigned OffsetVal ; <NEW_LINE> OffsetVal = Get32u ( DirEntry + 8 ) ; <NEW_LINE> <START_VULN> if ( OffsetVal + ByteCount > ExifLength ) { <NEW_LINE> <END_VULN> ErrNonfatal ( "Illegal value pointer for tag % 04x" , Tag , 0 ) ; <NEW_LINE> continue ;
ZVAL_DOUBLE ( * rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1068 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy65: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' , ' ) {
return NS_OK ; <NEW_LINE> nsCOMPtr < nsIPresShell > ps = do_QueryReferent ( mPresShellWeak ) ; <NEW_LINE> if ( ! ps ) return NS_ERROR_NOT_INITIALIZED ; <NEW_LINE> nsresult res ; <NEW_LINE> nsCOMPtr < nsIDOMNode > parentNode ; <NEW_LINE> <START_VULN> res = mTopLeftHandle -> GetParentNode ( getter_AddRefs ( parentNode ) ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( res , res ) ; <NEW_LINE>nsCOMPtr < nsIContent > parentContent = do_QueryInterface ( parentNode ) ; <NEW_LINE> <END_VULN> NS_NAMED_LITERAL_STRING ( mousedown , "mousedown" ) ; <NEW_LINE> RemoveListenerAndDeleteRef ( mousedown , mMouseListenerP , PR_TRUE , <NEW_LINE> mTopLeftHandle , parentContent , ps ) ; <NEW_LINE> mTopLeftHandle = nsnull ; <NEW_LINE> RemoveListenerAndDeleteRef ( mousedown , mMouseListenerP , PR_TRUE ,
( sub . rm_so != - 1 && sub . rm_eo == - 1 ) || <NEW_LINE> ( sub . rm_so != - 1 && sub . rm_so < 0 ) || <NEW_LINE> ( sub . rm_eo != - 1 && sub . rm_eo < 0 ) ) { <NEW_LINE> <START_VULN> sprintf ( grump , "start % ld end % ld" , ( long ) sub . rm_so , <NEW_LINE> <END_VULN> ( long ) sub . rm_eo ) ; <NEW_LINE> return ( grump ) ; <NEW_LINE> }
namespace chromeos { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> class LowBatteryObserver : public PowerManagerClient::Observer { <NEW_LINE> public: <NEW_LINE> explicit LowBatteryObserver ( Profile * profile ) ;
if ( ! mValid ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> <START_VULN> if ( mCanvasElement && mCanvasElement -> IsWriteOnly ( ) && ! nsContentUtils::IsCallerTrustedForRead ( ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_DOM_SECURITY_ERR ; <NEW_LINE> }
} <NEW_LINE> <START_VULN> class WebsiteSettingsPopupView <NEW_LINE>: public PermissionSelectorViewObserver , <NEW_LINE>public views::BubbleDelegateView , <NEW_LINE>public views::ButtonListener , <NEW_LINE>public views::LinkListener , <NEW_LINE>public views::TabbedPaneListener , <NEW_LINE>public WebsiteSettingsUI { <NEW_LINE> <END_VULN> public: <NEW_LINE> ~ WebsiteSettingsPopupView ( ) override ;
{ <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> long size ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "l" , & size ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
if ( ! node -> isElementNode ( ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> return equalIgnoringCase ( toElement ( node ) -> getAttribute ( aria_hiddenAttr ) , <NEW_LINE>"false" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void AXObjectCacheImpl::postPlatformNotification ( AXObject * obj ,
{ <NEW_LINE> for ( size_t i = 0 ; i < m_waitingForCompositorAnimationStart . size ( ) ; ++ i ) { <NEW_LINE> Player * player = m_waitingForCompositorAnimationStart [ i ] . get ( ) ; <NEW_LINE> <START_VULN> player -> setStartTime ( monotonicAnimationStartTime - player -> timeline ( ) . zeroTime ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> m_waitingForCompositorAnimationStart . clear ( ) ;
gMediaCache -> NoteBlockUsage ( this , cacheBlock , mCurrentMode , TimeStamp::Now ( ) ) ; <NEW_LINE> PRInt64 offset = cacheBlock * BLOCK_SIZE + offsetInStreamBlock ; <NEW_LINE> <START_VULN> nsresult rv = gMediaCache -> ReadCacheFile ( offset , aBuffer + count , size , & bytes ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) { <NEW_LINE> if ( count == 0 ) <NEW_LINE> return rv ;
if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> } <NEW_LINE> PRInt32 itemType ; <NEW_LINE> if ( ( mDocShellType == nsIDocShellTreeItem::typeAll ) || <NEW_LINE> ( NS_SUCCEEDED ( inItem -> GetItemType ( & itemType ) ) && ( itemType == mDocShellType ) ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! inItemArray . AppendElement ( inItem ) ) <NEW_LINE> <END_VULN> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> }
void <NEW_LINE> png_app_error ( png_const_structrp png_ptr , png_const_charp error_message ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> flags & PNG_FLAG_APP_ERRORS_WARN ) <NEW_LINE> <END_VULN> png_warning ( png_ptr , error_message ) ; <NEW_LINE> else <NEW_LINE> png_error ( png_ptr , error_message ) ;
~ DOMHandler ( ) override ; <NEW_LINE> void Wire ( UberDispatcher * dispatcher ) override ; <NEW_LINE> <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) override ; <NEW_LINE> Response Disable ( ) override ;
<START_VULN> static void get_icu_value_src_php ( char * tag_name , INTERNAL_FUNCTION_PARAMETERS ) <NEW_LINE> <END_VULN> { <NEW_LINE> const char * loc_name = NULL ;
thread_t * read_thread = thread_new ( "read_thread" ) ; <NEW_LINE> eager_reader_register ( reader , thread_get_reactor ( read_thread ) , expect_data_multibyte , ( void * ) large_data ) ; <NEW_LINE> <START_VULN> write ( pipefd [ 1 ] , large_data , strlen ( large_data ) ) ; <NEW_LINE> <END_VULN> semaphore_wait ( done ) ; <NEW_LINE> eager_reader_free ( reader ) ;
std::size_t writeAttributeData ( ArrayVertexBuffer * vertexBuffer , GLint start , GLsizei count , const VertexAttribute & attribute ) ; <NEW_LINE> Context * const mContext ; <NEW_LINE> IDirect3DDevice9 * const mDevice ; <NEW_LINE> StreamingVertexBuffer * mStreamingBuffer ; <NEW_LINE> bool mDirtyCurrentValue [ MAX_VERTEX_ATTRIBS ] ; <NEW_LINE> <START_VULN> ConstantVertexBuffer * mCurrentValueBuffer [ MAX_VERTEX_ATTRIBS ] ; <NEW_LINE> <END_VULN> struct FormatConverter <NEW_LINE> { <NEW_LINE> bool identity ; <NEW_LINE> std::size_t outputElementSize ; <NEW_LINE> void ( * convertArray ) ( const void * in , std::size_t stride , std::size_t n , void * out ) ; <NEW_LINE> D3DDECLTYPE d3dDeclType ;
MOZ_GUARD_OBJECT_NOTIFIER_INIT ; <NEW_LINE> if ( ! aSafe ) { <NEW_LINE> mCx = nsContentUtils::GetCurrentJSContext ( ) ; <NEW_LINE> } <NEW_LINE> if ( ! mCx ) { <NEW_LINE> mCx = nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE> <START_VULN> bool result = mPusher . Push ( mCx ) ; <NEW_LINE>if ( ! result || ! mCx ) { <NEW_LINE>MOZ_CRASH ( ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> AutoJSContext::operator JSContext * ( ) <NEW_LINE> { <NEW_LINE> return mCx ; <NEW_LINE> }
return ( fi . spdist - fp -> down -> script -> nfixed ) + <NEW_LINE> ( ( fun -> nargs > fp -> argc ) ? fun -> nargs - fp -> argc : 0 ) + <NEW_LINE> script -> nfixed ; <NEW_LINE> } <NEW_LINE> static void <NEW_LINE> <START_VULN> SynthesizeSlowNativeFrame ( JSContext * cx , VMSideExit * exit ) <NEW_LINE> <END_VULN> { <NEW_LINE> void * mark ; <NEW_LINE> JSInlineFrame * ifp ; <NEW_LINE> mark = JS_ARENA_MARK ( & cx -> stackPool ) ; <NEW_LINE> JS_ARENA_ALLOCATE_CAST ( ifp , JSInlineFrame * , & cx -> stackPool , sizeof ( JSInlineFrame ) ) ; <NEW_LINE> JS_ASSERT ( ifp ) ;
void SetBackgroundUnknown ( ) ; <NEW_LINE> already_AddRefed < gfxContext > BeginUpdateBackground ( const nsIntRect & aRect ) ; <NEW_LINE> void EndUpdateBackground ( gfxContext * aContext , const nsIntRect & aRect ) ; <NEW_LINE> bool UseAsyncRendering ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> private: <NEW_LINE> bool IsUpToDate ( ) <NEW_LINE> { <NEW_LINE> nsIntSize size ; <NEW_LINE> return NS_SUCCEEDED ( mInstance -> GetImageSize ( & size ) ) && <NEW_LINE> size == nsIntSize ( mPluginWindow -> width , mPluginWindow -> height ) ;
SetGeometryDirty ( ) ; <NEW_LINE> #ifdef DEBUG_TABLE_CELLMAP <NEW_LINE> printf ( " == = TableFrame::InsertFrames\n" ) ; <NEW_LINE> Dump ( true , true , true ) ; <NEW_LINE> #endif <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> NS_IMETHODIMP <NEW_LINE>nsTableFrame::RemoveFrame ( ChildListID aListID , <NEW_LINE>nsIFrame * aOldFrame ) <NEW_LINE> { <NEW_LINE>NS_ASSERTION ( aListID == kColGroupList || <NEW_LINE>NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP != <NEW_LINE>aOldFrame -> GetStyleDisplay ( ) -> mDisplay , <NEW_LINE>"Wrong list name ; use kColGroupList iff colgroup" ) ; <NEW_LINE> <END_VULN> if ( aListID == kColGroupList ) { <NEW_LINE> nsIFrame * nextColGroupFrame = aOldFrame -> GetNextSibling ( ) ; <NEW_LINE> nsTableColGroupFrame * colGroup = ( nsTableColGroupFrame * ) aOldFrame ; <NEW_LINE> int32_t firstColIndex = colGroup -> GetStartColumnIndex ( ) ; <NEW_LINE> int32_t lastColIndex = firstColIndex + colGroup -> GetColCount ( ) - 1 ; <NEW_LINE> mColGroups . DestroyFrame ( aOldFrame ) ; <NEW_LINE> nsTableColGroupFrame::ResetColIndices ( nextColGroupFrame , firstColIndex ) ;
if ( ! v ) return - 1 ; <NEW_LINE> for ( i = offset ; i < offset + n ; ) { <NEW_LINE> if ( decode_map ( book , b , v , point ) ) return - 1 ; <NEW_LINE> <START_VULN> for ( j = 0 ; j < book -> dim ; j ++ ) { <NEW_LINE>a [ chptr ++ ] [ i ] += v [ j ] ; <NEW_LINE>if ( chptr == ch ) { <NEW_LINE>chptr = 0 ; <NEW_LINE>i ++ ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
sp < IMediaPlayerService > MediaMetadataRetriever::sService ; <NEW_LINE> sp < MediaMetadataRetriever::DeathNotifier > MediaMetadataRetriever::sDeathNotifier ; <NEW_LINE> <START_VULN> const sp < IMediaPlayerService > & MediaMetadataRetriever::getService ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> Mutex::Autolock lock ( sServiceLock ) ; <NEW_LINE> if ( sService == 0 ) {
static void <NEW_LINE> <START_VULN> store_pool_error ( png_store * ps , png_const_structp pp , PNG_CONST char * msg ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( pp != NULL ) <NEW_LINE> png_error ( pp , msg ) ;
virtual void initialize ( WKContextRef contextRef = 0 , WKPageGroupRef pageGroupRef = 0 ) ; <NEW_LINE> <START_VULN> virtual void onComponentComplete ( ) { } <NEW_LINE> <END_VULN> virtual void enableMouseEvents ( ) { } <NEW_LINE> virtual void disableMouseEvents ( ) { }
bool ProcessData ( int len , const u_char * data , bool orig ) ; <NEW_LINE> void ClearEndpointState ( bool orig ) ; <NEW_LINE> <START_VULN> bool AddToBuffer ( Endpoint * endp , int target_len , const u_char ** data , int * len ) ; <NEW_LINE> <END_VULN> bool ParseAppLayer ( Endpoint * endp ) ; <NEW_LINE> bool CheckCRC ( int len , const u_char * data , const u_char * crc16 , const char * where ) ; <NEW_LINE> unsigned int CalcCRC ( int len , const u_char * data ) ;
re = js_toregexp ( J , - 1 ) ; <NEW_LINE> <START_VULN> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <NEW_LINE> <END_VULN> js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; <NEW_LINE> else <NEW_LINE> js_pushnumber ( J , - 1 ) ;
static int calc_iframe_target_size_one_pass_vbr ( const VP9_COMP * const cpi ) { <NEW_LINE> static const int kf_ratio = 25 ; <NEW_LINE> const RATE_CONTROL * rc = & cpi -> rc ; <NEW_LINE> <START_VULN> int target = rc -> av_per_frame_bandwidth * kf_ratio ; <NEW_LINE> <END_VULN> return vp9_rc_clamp_iframe_target_size ( cpi , target ) ; <NEW_LINE> }
return 1 ; <NEW_LINE> } <NEW_LINE> mpz_init ( temp ) ; <NEW_LINE> <START_VULN> mpz_powm ( r , key -> g , k , key -> p ) ; <NEW_LINE> <END_VULN> mpz_mod ( r , r , key -> q ) ; <NEW_LINE> mpz_invert ( s , k , key -> q ) ; <NEW_LINE> mpz_mul ( temp , key -> x , r ) ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> nsDependentString handlerText ( mHandlerText ) ; <NEW_LINE> NS_ENSURE_TRUE ( ! handlerText . IsEmpty ( ) , NS_ERROR_FAILURE ) ; <NEW_LINE> <START_VULN> JSContext * cx = aBoundContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSObject * globalObject = aGlobal -> GetGlobalJSObject ( ) ; <NEW_LINE> JSObject * scopeObject = xpc::GetXBLScope ( cx , globalObject ) ; <NEW_LINE> nsAutoCString bindingURI ; <NEW_LINE> mPrototypeBinding -> DocURI ( ) -> GetSpec ( bindingURI ) ; <NEW_LINE> uint32_t argCount ; <NEW_LINE> const char ** argNames ;
bytecnt = m -> str_range ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( bytecnt == 0 || bytecnt > nbytes - offset ) <NEW_LINE>bytecnt = nbytes - offset ; <NEW_LINE> <END_VULN> buf = RCAST ( const char * , s ) + offset ; <NEW_LINE> end = last = RCAST ( const char * , s ) + bytecnt ;
error = PutImageData_explicit ( JS_DoubleToInt32 ( dx ) , JS_DoubleToInt32 ( dy ) , <NEW_LINE> imageData . Width ( ) , imageData . Height ( ) , <NEW_LINE> <START_VULN> arr . Data ( ) , arr . Length ( ) , false , 0 , 0 , 0 , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void
{ D45_PRED , { INTRA_FRAME , NONE } } , <NEW_LINE> } ; <NEW_LINE> <START_VULN> const REF_DEFINITION vp9_ref_order [ MAX_REFS ] = { <NEW_LINE> <END_VULN> { { LAST_FRAME , NONE } } , <NEW_LINE> { { GOLDEN_FRAME , NONE } } , <NEW_LINE> { { ALTREF_FRAME , NONE } } ,
<START_VULN> char bogus_public [ 40 ] ; <NEW_LINE>char bogus_secret [ 40 ] ; <NEW_LINE> <END_VULN> zmq_curve_keypair ( bogus_public , bogus_secret ) ; <NEW_LINE> client = zmq_socket ( ctx , ZMQ_DEALER ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: registry for time , floor , res backends and channel mappings <NEW_LINE> <START_VULN> last mod: $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_REG_H_ <NEW_LINE> #define _V_REG_H_ <NEW_LINE> #define VI_TRANSFORMB 1 <NEW_LINE> #define VI_WINDOWB 1
NS_ENSURE_STATE ( context ) ; <NEW_LINE> AutoPushJSContext cx ( context -> GetNativeContext ( ) ) ; <NEW_LINE> JS::Rooted < JSObject * > handler ( cx ) ; <NEW_LINE> JS::Rooted < JSObject * > scope ( cx , listener -> GetEventScope ( ) ) ; <NEW_LINE> <START_VULN> nsIAtom * attrName = aListenerStruct -> mTypeAtom ; <NEW_LINE> <END_VULN> if ( aListenerStruct -> mHandlerIsString ) { <NEW_LINE> aListenerStruct -> mHandlerIsString = false ;
SVGPointList & InternalList ( ) const ; <NEW_LINE> SVGAnimatedPointList & InternalAList ( ) const ; <NEW_LINE> <START_VULN> void EnsureItemAt ( uint32_t aIndex ) ; <NEW_LINE> <END_VULN> void MaybeInsertNullInAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> void MaybeRemoveItemFromAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> FallibleTArray < nsISVGPoint * > mItems ;
} <NEW_LINE> <START_VULN> static int64_t <NEW_LINE> <END_VULN> vpx_usec_timer_elapsed ( struct vpx_usec_timer * t ) { <NEW_LINE> #if defined ( _WIN32 ) <NEW_LINE> LARGE_INTEGER freq , diff ;
{ <NEW_LINE> u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; <NEW_LINE> if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) <NEW_LINE> <START_VULN> return ERROR_INV_SPS_PPS_T ; <NEW_LINE> <END_VULN> u1_redundant_pic_cnt = u4_temp ; <NEW_LINE> COPYTHECONTEXT ( "SH: redundant_pic_cnt" , u1_redundant_pic_cnt ) ; <NEW_LINE> }
<START_VULN> void ConfigureStreams ( bool require_photo ) ; <NEW_LINE> <END_VULN> void OnConfiguredStreams ( <NEW_LINE> int32_t result , <NEW_LINE> cros::mojom::Camera3StreamConfigurationPtr updated_config ) ;
uint32_t offset ; <NEW_LINE> uint32_t size ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> SkAutoFree dirEntryBuffer ( sk_malloc_flags ( sizeof ( Entry ) * numImages , <NEW_LINE>SK_MALLOC_TEMP ) ) ; <NEW_LINE> <END_VULN> if ( ! dirEntryBuffer ) { <NEW_LINE> SkCodecPrintf ( "Error: OOM allocating ICO directory for % i images . \n" , <NEW_LINE> numImages ) ;
SECItem algorithms = { siBuffer , NULL , 0 } ; <NEW_LINE> CERTDistNames ca_list ; <NEW_LINE> SSL_TRC ( 3 , ( " % d: SSL3 [ % d ] : handle certificate_request handshake" , <NEW_LINE> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> <START_VULN> if ( ss -> ssl3 . hs . ws != wait_cert_request && <NEW_LINE>ss -> ssl3 . hs . ws != wait_server_key ) { <NEW_LINE>desc = unexpected_message ; <NEW_LINE>errCode = SSL_ERROR_RX_UNEXPECTED_CERT_REQUEST ; <NEW_LINE>goto alert_loser ; <NEW_LINE> <END_VULN> } <NEW_LINE> PORT_Assert ( ss -> ssl3 . clientCertChain == NULL ) ; <NEW_LINE> PORT_Assert ( ss -> ssl3 . clientCertificate == NULL ) ; <NEW_LINE> PORT_Assert ( ss -> ssl3 . clientPrivateKey == NULL ) ; <NEW_LINE> isTLS = ( PRBool ) ( ss -> ssl3 . prSpec -> version > SSL_LIBRARY_VERSION_3_0 ) ; <NEW_LINE> isTLS12 = ( PRBool ) ( ss -> ssl3 . prSpec -> version >= SSL_LIBRARY_VERSION_TLS_1_2 ) ;
JSObject * holder = Traits::singleton . ensureHolder ( cx , wrapper ) ; <NEW_LINE> if ( Traits::isResolving ( cx , holder , id ) ) { <NEW_LINE> desc -> obj = NULL ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> typename Traits::ResolvingIdImpl resolving ( wrapper , id ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( XrayUtils::IsTransparent ( cx , wrapper , id ) ) { <NEW_LINE>JSObject * obj = Traits::getTargetObject ( wrapper ) ; <NEW_LINE> { <NEW_LINE>JSAutoCompartment ac ( cx , obj ) ; <NEW_LINE>if ( ! JS_GetPropertyDescriptorById ( cx , obj , id , flags , desc ) ) <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( desc -> obj ) <NEW_LINE>desc -> obj = wrapper ; <NEW_LINE>return JS_WrapPropertyDescriptor ( cx , desc ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! holder ) <NEW_LINE> return false ;
protected: <NEW_LINE> virtual ~ PlatformSensor ( ) ; <NEW_LINE> PlatformSensor ( mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> PlatformSensorProvider * provider ) ; <NEW_LINE> using ReadingBuffer = SensorReadingSharedBuffer ;
} <NEW_LINE> JS::Value result ; <NEW_LINE> nsresult rv ; <NEW_LINE> nsIScriptContext * sc = GetContextForEventHandlers ( & rv ) ; <NEW_LINE> NS_ENSURE_STATE ( sc ) ; <NEW_LINE> <START_VULN> JSContext * cx = sc -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( cx , "Failed to get a context ! " ) ; <NEW_LINE> JSObject * global = sc -> GetNativeGlobal ( ) ; <NEW_LINE> NS_ASSERTION ( global , "Failed to get global object ! " ) ; <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , global ) ;
ContentEncoding * const content_encoding = <NEW_LINE> new ( std::nothrow ) ContentEncoding ( ) ; <NEW_LINE> if ( ! content_encoding ) { <NEW_LINE> <START_VULN> delete [ ] content_encoding_entries ; <NEW_LINE> <END_VULN> return false ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> mDelayedBlurFocusEvents . AppendElement ( <NEW_LINE> nsDelayedBlurOrFocusEvent ( aType , aPresShell , aDocument , eventTarget ) ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsCOMPtr < nsPresContext > presContext = aPresShell -> GetPresContext ( ) ; <NEW_LINE><NEW_LINE>nsEventStatus status = nsEventStatus_eIgnore ; <NEW_LINE>nsEvent event ( PR_TRUE , aType ) ; <NEW_LINE>event . flags |= NS_EVENT_FLAG_CANT_BUBBLE ; <NEW_LINE><NEW_LINE>nsEventDispatcher::Dispatch ( aTarget , presContext , & event , nsnull , & status ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsFocusManager::ScrollIntoView ( nsIPresShell * aPresShell , <NEW_LINE> nsIContent * aContent , <NEW_LINE> PRUint32 aFlags ) <NEW_LINE> {
#ifdef PNG_READ_cHRM_SUPPORTED <NEW_LINE> else if ( png_ptr -> chunk_name == png_cHRM ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_cHRM ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
#include "vpx / vpx_codec . h" <NEW_LINE> <START_VULN> static const char * const cfg = " -- target = generic - gnu -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
) { <NEW_LINE> carray_cursor * pCur = ( carray_cursor * ) pVtabCursor ; <NEW_LINE> if ( idxNum ) { <NEW_LINE> <START_VULN> pCur -> iPtr = sqlite3_value_int64 ( argv [ 0 ] ) ; <NEW_LINE>pCur -> iCnt = sqlite3_value_int64 ( argv [ 1 ] ) ; <NEW_LINE> <END_VULN> if ( idxNum < 3 ) { <NEW_LINE> pCur -> eType = CARRAY_INT32 ; <NEW_LINE> } else {
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeContentView::GetProgressMode ( PRInt32 aRow , nsITreeColumn * aCol , PRInt32 * _retval ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ENSURE_ARG_POINTER ( aCol ) ; <NEW_LINE> <END_VULN> NS_PRECONDITION ( aRow >= 0 && aRow < PRInt32 ( mRows . Length ( ) ) , "bad row" ) ; <NEW_LINE> if ( aRow < 0 || aRow >= PRInt32 ( mRows . Length ( ) ) ) <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> * _retval = nsITreeView::PROGRESS_NONE ; <NEW_LINE> Row * row = mRows [ aRow ] ;
if ( SyncAuthenticPixels ( image , & image -> exception ) == MagickFalse ) <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! image -> ping ) <NEW_LINE> <END_VULN> SyncImage ( image ) ; <NEW_LINE> } else { <NEW_LINE> #if DEBUG
int max_key_size , key_size , iv_size ; <NEW_LINE> php_mcrypt * pm ; <NEW_LINE> int result = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "rss" , & mcryptind , & key , & key_len , & iv , & iv_len ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
{ <NEW_LINE> uint8 * bufp = buf ; <NEW_LINE> int32 bytes_read = 0 ; <NEW_LINE> <START_VULN> uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ; <NEW_LINE> <END_VULN> uint32 stripsize = TIFFStripSize ( in ) ; <NEW_LINE> uint32 rows = 0 ; <NEW_LINE> uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ;
static inline Quantum GetPixelChannel ( const Image * magick_restrict image , <NEW_LINE> const PixelChannel channel , const Quantum * magick_restrict pixel ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( image -> channel_map [ channel ] . traits == UndefinedPixelTrait ) <NEW_LINE> <END_VULN> return ( ( Quantum ) 0 ) ; <NEW_LINE> return ( pixel [ image -> channel_map [ channel ] . offset ] ) ; <NEW_LINE> }
length = ( size_t ) number_pixels ; <NEW_LINE> pixel_info = AcquireVirtualMemory ( length , sizeof ( * pixels ) ) ; <NEW_LINE> if ( pixel_info == ( MemoryInfo * ) NULL ) <NEW_LINE> <START_VULN> { <NEW_LINE>xref = ( MagickOffsetType * ) RelinquishMagickMemory ( xref ) ; <NEW_LINE>ThrowPDFException ( ResourceLimitError , <NEW_LINE>"MemoryAllocationFailed" ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; <NEW_LINE> Dump Runlength encoded pixels .
} <NEW_LINE> <START_VULN> class CallbackWrapper : public RefCounted < CallbackWrapper > { <NEW_LINE> <END_VULN> public: <NEW_LINE> CallbackWrapper ( PassOwnPtr < AsyncFileSystemCallbacks > c ) <NEW_LINE> : m_callbacks ( c )
#ifdef ACCESSIBILITY <NEW_LINE> already_AddRefed < nsIAccessible > nsWindow::GetRootAccessible ( ) <NEW_LINE> { <NEW_LINE> nsWindow::gIsAccessibilityOn = TRUE ; <NEW_LINE> <START_VULN> if ( mIsDestroying || mOnDestroyCalled || mWindowType == eWindowType_invisible ) { <NEW_LINE> <END_VULN> return nsnull ; <NEW_LINE> } <NEW_LINE> nsIAccessible * rootAccessible = nsnull ;
bool onceThrough = endOp . m_nextOp == notFound ; <NEW_LINE> if ( onceThrough ) <NEW_LINE> m_backtrackingState . linkTo ( endOp . m_reentry , this ) ; <NEW_LINE> else { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>int deltaLastAlternativeToFirstAlternativePlusOne = ( beginOp -> m_alternative -> m_minimumSize - alternative -> m_minimumSize ) + 1 ; <NEW_LINE><NEW_LINE>if ( ! deltaLastAlternativeToFirstAlternativePlusOne && m_pattern . m_body -> m_hasFixedSize ) <NEW_LINE> <END_VULN> m_backtrackingState . linkTo ( beginOp -> m_reentry , this ) ; <NEW_LINE> else { <NEW_LINE> m_backtrackingState . link ( this ) ; <NEW_LINE> if ( ! m_pattern . m_body -> m_hasFixedSize ) {
void vp9_cyclic_refresh_update_segment ( VP9_COMP * const cpi , <NEW_LINE> MB_MODE_INFO * const mbmi , <NEW_LINE> int mi_row , int mi_col , <NEW_LINE> <START_VULN> BLOCK_SIZE bsize , int use_rd ) { <NEW_LINE> <END_VULN> const VP9_COMMON * const cm = & cpi -> common ; <NEW_LINE> CYCLIC_REFRESH * const cr = cpi -> cyclic_refresh ; <NEW_LINE> const int bw = num_8x8_blocks_wide_lookup [ bsize ] ;
JSObject * helper = GetDocumentAllHelper ( cx , obj ) ; <NEW_LINE> if ( helper ) { <NEW_LINE> <START_VULN> jsval v = JSVAL_VOID ; <NEW_LINE>::JS_SetProperty ( cx , helper , "all" , & v ) ; <NEW_LINE> <END_VULN> * objp = helper ; <NEW_LINE> }
#include "vp9 / common / vp9_blockd . h" <NEW_LINE> <START_VULN> MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , <NEW_LINE>const MODE_INFO * left_mi , int b ) { <NEW_LINE> <END_VULN> if ( b == 0 || b == 2 ) { <NEW_LINE> if ( ! left_mi || is_inter_block ( & left_mi -> mbmi ) ) <NEW_LINE> return DC_PRED ;
if ( doInterrupt ) { <NEW_LINE> UNLOCK_TX_MANAGER ( this ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> result = tx -> UndoTransaction ( this ) ; <NEW_LINE> if ( NS_SUCCEEDED ( result ) ) { <NEW_LINE> <START_VULN> result = mUndoStack . Pop ( & tx ) ; <NEW_LINE> <END_VULN> if ( NS_SUCCEEDED ( result ) ) <NEW_LINE> result = mRedoStack . Push ( tx ) ; <NEW_LINE> } <NEW_LINE> nsresult result2 = DidUndoNotify ( t , result ) ; <NEW_LINE> if ( NS_SUCCEEDED ( result ) )
{ \ <NEW_LINE> if ( thissad < bestsad ) { \ <NEW_LINE> if ( use_mvcost ) \ <NEW_LINE> <START_VULN> thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , \ <NEW_LINE>mvjsadcost , mvsadcost , sad_per_bit ) ; \ <NEW_LINE> <END_VULN> if ( thissad < bestsad ) { \ <NEW_LINE> bestsad = thissad ; \ <NEW_LINE> best_site = i ; \
if ( ( ms -> flags & MAGIC_DEBUG ) != 0 ) <NEW_LINE> fprintf ( stderr , "indirect + offs = % u\n" , offset ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( mcopy ( ms , p , m -> type , 0 , s , offset , nbytes , count ) == - 1 ) <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> ms -> offset = offset ;
return ( PTA * ) ERROR_PTR ( "not a pta file" , procName , NULL ) ; <NEW_LINE> if ( version != PTA_VERSION_NUMBER ) <NEW_LINE> return ( PTA * ) ERROR_PTR ( "invalid pta version" , procName , NULL ) ; <NEW_LINE> <START_VULN> if ( fscanf ( fp , " Number of pts = % d ; format = % s\n" , & n , typestr ) != 2 ) <NEW_LINE> <END_VULN> return ( PTA * ) ERROR_PTR ( "not a pta file" , procName , NULL ) ; <NEW_LINE> if ( ! strcmp ( typestr , "float" ) ) <NEW_LINE> type = 0 ;
if ( ( atts == NULL ) || ( nbatts + 5 > maxatts ) ) { <NEW_LINE> if ( xmlCtxtGrowAttrs ( ctxt , nbatts + 5 ) < 0 ) { <NEW_LINE> <START_VULN> return ( NULL ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> maxatts = ctxt -> maxatts ; <NEW_LINE> atts = ctxt -> atts ;
This is how the time string is formatted: <NEW_LINE> snprintf ( p , sizeof ( p ) , " % 02d % 02d % 02d % 02d % 02d % 02dZ" , ts -> tm_year % 100 , <NEW_LINE> <START_VULN> ts -> tm_mon + 1 , ts -> tm_mday , ts -> tm_hour , ts -> tm_min , ts -> tm_sec ) ; <NEW_LINE> <END_VULN> time_t ret ;
if ( fCon ) { <NEW_LINE> unsigned char	 tCon ; <NEW_LINE> unsigned char	 tByte ; <NEW_LINE> <START_VULN> unsigned char	 tpiLen ; <NEW_LINE> <END_VULN> tvbuff_t		 * tmp_tvb ; <NEW_LINE> vHeader = 0 ;
FD_ZERO ( & writefds ) ; <NEW_LINE> FD_ZERO ( & exceptfds ) ; <NEW_LINE> <START_VULN> curl_multi_fdset ( mh -> multi , & readfds , & writefds , & exceptfds , & maxfd ) ; <NEW_LINE> <END_VULN> if ( maxfd == - 1 ) { <NEW_LINE> RETURN_LONG ( - 1 ) ; <NEW_LINE> }
char * msg ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> struct ikev2_auth { <NEW_LINE> struct isakmp_gen h ; <NEW_LINE> uint8_t auth_method ;
if ( yych <= '9' ) goto yy79 ; <NEW_LINE> if ( yych != ' ; ' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 558 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> #if SIZEOF_LONG == 4 <NEW_LINE> int digits = YYCURSOR - start - 3 ;
<START_VULN> void UpdateAppState ( content::WebContents * tab , AppState app_state ) ; <NEW_LINE> <END_VULN> void SetRefocusURLPattern ( ash::LauncherID id , const GURL & url ) ;
( ctxt -> value -> type == XPATH_NODESET ) && <NEW_LINE> ( ctxt -> value -> nodesetval != NULL ) && <NEW_LINE> ( ctxt -> value -> nodesetval -> nodeTab != NULL ) && <NEW_LINE> <START_VULN> ( ctxt -> value -> nodesetval -> nodeNr > 1 ) ) { <NEW_LINE>ctxt -> value -> nodesetval -> nodeTab [ 0 ] = <NEW_LINE>ctxt -> value -> nodesetval -> nodeTab [ ctxt -> <NEW_LINE>value -> <NEW_LINE>nodesetval -> <NEW_LINE>nodeNr - <NEW_LINE>1 ] ; <NEW_LINE>ctxt -> value -> nodesetval -> nodeNr = 1 ; <NEW_LINE> } <NEW_LINE> <END_VULN> return ( total ) ; <NEW_LINE> } <NEW_LINE> }
gMediaCache -> NoteBlockUsage ( this , cacheBlock , mCurrentMode , TimeStamp::Now ( ) ) ; <NEW_LINE> PRInt64 offset = cacheBlock * BLOCK_SIZE + offsetInStreamBlock ; <NEW_LINE> <START_VULN> nsresult rv = gMediaCache -> ReadCacheFile ( offset , aBuffer + count , size , & bytes ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) { <NEW_LINE> if ( count == 0 ) <NEW_LINE> return rv ;
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void nsComboboxControlFrame::FireValueChangeEvent ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsCOMPtr < nsIDOMEvent > event ; <NEW_LINE>nsPresContext * presContext = PresContext ( ) ; <NEW_LINE>if ( NS_SUCCEEDED ( nsEventDispatcher::CreateEvent ( presContext , nsnull , <NEW_LINE>NS_LITERAL_STRING ( "Events" ) , <NEW_LINE>getter_AddRefs ( event ) ) ) ) { <NEW_LINE>event -> InitEvent ( NS_LITERAL_STRING ( "ValueChange" ) , PR_TRUE , PR_TRUE ) ; <NEW_LINE><NEW_LINE>nsCOMPtr < nsIPrivateDOMEvent > privateEvent ( do_QueryInterface ( event ) ) ; <NEW_LINE>privateEvent -> SetTrusted ( PR_TRUE ) ; <NEW_LINE>nsEventDispatcher::DispatchDOMEvent ( mContent , nsnull , event , nsnull , <NEW_LINE>nsnull ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsComboboxControlFrame::OnContentReset ( ) <NEW_LINE> { <NEW_LINE> if ( mListControlFrame ) { <NEW_LINE> mListControlFrame -> OnContentReset ( ) ; <NEW_LINE> }
u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; <NEW_LINE> while ( ( u4_start_code == EXTENSION_START_CODE || <NEW_LINE> u4_start_code == USER_DATA_START_CODE ) && <NEW_LINE> <START_VULN> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( u4_start_code == USER_DATA_START_CODE ) <NEW_LINE> {
return ; <NEW_LINE> ptr = buffer ; <NEW_LINE> <START_VULN> if ( png_ptr -> save_buffer_size ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_size_t save_size ;
( XPCWrappedNative ** ) _retval ) ; <NEW_LINE> } <NEW_LINE> static JSDHashOperator <NEW_LINE> MoveableWrapperFinder ( JSDHashTable * table , JSDHashEntryHdr * hdr , <NEW_LINE> uint32 number , void * arg ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsTArray < nsRefPtr < XPCWrappedNative > > * array = <NEW_LINE>static_cast < nsTArray < nsRefPtr < XPCWrappedNative > > * > ( arg ) ; <NEW_LINE>array -> AppendElement ( ( ( Native2WrappedNativeMap::Entry * ) hdr ) -> value ) ; <NEW_LINE> <END_VULN> return JS_DHASH_NEXT ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsXPConnect::ReparentScopeAwareWrappers ( JSContext * aJSContext , <NEW_LINE> JSObject * aOldScope , <NEW_LINE> JSObject * aNewScope )
perf_prepare_sample ( & header , data , event , regs ) ; <NEW_LINE> <START_VULN> if ( perf_output_begin ( & handle , event , header . size , nmi , 1 ) ) <NEW_LINE> <END_VULN> goto exit ; <NEW_LINE> perf_output_sample ( & handle , & header , data , event ) ;
if ( obj2 != obj ) { <NEW_LINE> JS_UNLOCK_OBJ ( cx , obj ) ; <NEW_LINE> <START_VULN> JS_LOCK_OBJ ( cx , obj2 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> protoIndex = 0 ; <NEW_LINE> for ( proto = start ; proto && proto != obj2 ;
if ( scale == ( Quantum * ) NULL ) <NEW_LINE> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> range = GetQuantumRange ( depth ) ; <NEW_LINE> <START_VULN> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) <NEW_LINE> <END_VULN> scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; <NEW_LINE> } <NEW_LINE> if ( image -> compression == RLECompression )
retval = * rc ; <NEW_LINE> } <NEW_LINE> out: <NEW_LINE> <START_VULN> return retval ; <NEW_LINE> <END_VULN> }
rc = 0 ; <NEW_LINE> if ( formData ) { <NEW_LINE> for ( rc = next = 0 ; rc >= 0 && ( pair = mprGetNextItem ( formData , & next ) ) != 0 ; ) { <NEW_LINE> <START_VULN> key = stok ( sclone ( pair ) , " = " , & value ) ; <NEW_LINE> <END_VULN> rc += httpWrite ( conn -> writeq , " % s\r\nContent - Disposition: form - data ; name = \" % s\" ; \r\n" , conn -> boundary , key ) ; <NEW_LINE> rc += httpWrite ( conn -> writeq , "Content - Type: application / x - www - form - urlencoded\r\n\r\n % s\r\n" , value ) ; <NEW_LINE> }
OMX_U32 portIndex , sp < IGraphicBufferConsumer > bufferConsumer , MetadataBufferType * type ) { <NEW_LINE> status_t err ; <NEW_LINE> <START_VULN> const sp < GraphicBufferSource > & surfaceCheck = getGraphicBufferSource ( ) ; <NEW_LINE> <END_VULN> if ( surfaceCheck != NULL ) { <NEW_LINE> if ( portIndex < NELEM ( mMetadataType ) && type != NULL ) { <NEW_LINE> * type = mMetadataType [ portIndex ] ;
if ( status != CL_SUCCESS ) <NEW_LINE> { <NEW_LINE> hb_log ( "OpenCL: hb_generat_bin_from_kernel_source: clGetProgramInfo for CL_PROGRAM_DEVICES failed" ) ; <NEW_LINE> <START_VULN> return 0 ; <NEW_LINE> <END_VULN> }
return nsnull ; <NEW_LINE> if ( pTearOff ) <NEW_LINE> * pTearOff = to ; <NEW_LINE> return wrapper ; <NEW_LINE> } <NEW_LINE> JSObject * unsafeObj = cx <NEW_LINE> <START_VULN> ? XPCWrapper::Unwrap ( cx , cur ) <NEW_LINE>: XPCWrapper::UnsafeUnwrapSecurityWrapper ( cur ) ; <NEW_LINE> <END_VULN> if ( unsafeObj ) { <NEW_LINE> obj = unsafeObj ; <NEW_LINE> goto restart ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( pobj2 ) <NEW_LINE> * pobj2 = nsnull ;
nsAutoPtr < Expr > test ; <NEW_LINE> rv = getExprAttr ( aAttributes , aAttrCount , nsGkAtoms::test , true , <NEW_LINE> aState , test ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsAutoPtr < txConditionalGoto > condGoto ( new txConditionalGoto ( test , nsnull ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( condGoto , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> <START_VULN> rv = aState . pushPtr ( condGoto ) ; <NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsAutoPtr < txInstruction > instr ( condGoto . forget ( ) ) ; <NEW_LINE> rv = aState . addInstruction ( instr ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return aState . pushHandlerTable ( gTxTemplateHandler ) ; <NEW_LINE> }
NULL , <NEW_LINE> #endif <NEW_LINE> global_data -> instance_name ) ; <NEW_LINE> <START_VULN> fp = fopen ( file_name , "a" ) ; <NEW_LINE> <END_VULN> FREE ( file_name ) ; <NEW_LINE> set_time_now ( ) ;
<START_VULN> #ifndef BASE_DEBUG_PROFILER_H <NEW_LINE>#define BASE_DEBUG_PROFILER_H <NEW_LINE> <END_VULN> #include < string >
DomDistillerViewerSource ( <NEW_LINE> DomDistillerServiceInterface * dom_distiller_service , <NEW_LINE> const std::string & scheme , <NEW_LINE> <START_VULN> scoped_ptr < ExternalFeedbackReporter > external_reporter ) ; <NEW_LINE> <END_VULN> ~ DomDistillerViewerSource ( ) override ; <NEW_LINE> class RequestViewerHandle ;
{ <NEW_LINE> FILE * f ; <NEW_LINE> <START_VULN> sprintf ( buf , " % s . conf" , set ) ; <NEW_LINE> <END_VULN> if ( ( f = fopen ( buf , "r" ) ) == NULL ) { <NEW_LINE> fprintf ( stderr , " % s: can't read conf file for charset % s\n" , prog , set ) ;
static int <NEW_LINE> image_transform_png_set_gray_to_rgb_add ( image_transform * this , <NEW_LINE> <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE> <END_VULN> { <NEW_LINE> UNUSED ( bit_depth )
return NS_OK ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> nsresult nsPluginInstanceOwner::Init ( nsIContent * aContent ) <NEW_LINE> { <NEW_LINE> mLastEventloopNestingLevel = GetEventloopNestingLevel ( ) ; <NEW_LINE> <START_VULN> mContent = aContent ; <NEW_LINE> <END_VULN> nsIFrame * frame = aContent -> GetPrimaryFrame ( ) ; <NEW_LINE> nsIObjectFrame * iObjFrame = do_QueryFrame ( frame ) ; <NEW_LINE> nsObjectFrame * objFrame = static_cast < nsObjectFrame * > ( iObjFrame ) ; <NEW_LINE> if ( objFrame ) { <NEW_LINE> SetFrame ( objFrame ) ;
1 , <NEW_LINE> - 533200896 , 1611661312 , 4 , 0 , <NEW_LINE> partial_quantlist1 , <NEW_LINE> NULL , NULL , NULL , <NEW_LINE> 0 <NEW_LINE> } ; <NEW_LINE> static float test4_result [ ] = { - 3 , - 3 , - 3 , 4 , - 3 , - 3 , - 1 , - 3 , - 3 , <NEW_LINE> - 3 , 4 , - 3 , 4 , 4 , - 3 , - 1 , 4 , - 3 , <NEW_LINE> <START_VULN> - 3 , - 1 , - 3 , 4 , - 1 , - 3 , - 1 , - 1 , - 3 , <NEW_LINE> <END_VULN> - 3 , - 3 , 4 , 4 , - 3 , 4 , - 1 , - 3 , 4 , <NEW_LINE> - 3 , 4 , 4 , 4 , 4 , 4 , - 1 , 4 , 4 , <NEW_LINE> - 3 , - 1 , 4 , 4 , - 1 , 4 , - 1 , - 1 , 4 , <NEW_LINE> - 3 , - 3 , - 1 , 4 , - 3 , - 1
while ( i < len && ( c = fast_getc ( fp ) ) != EOF ) <NEW_LINE> buf [ i ++ ] = ( jschar ) ( unsigned char ) c ; <NEW_LINE> } <NEW_LINE> JS_ASSERT ( i <= len ) ; <NEW_LINE> len = i ; <NEW_LINE> uint32 tcflags = JS_OPTIONS_TO_TCFLAGS ( cx ) | TCF_NEED_SCRIPT_GLOBAL ; <NEW_LINE> <START_VULN> script = frontend::CompileScript ( cx , obj , NULL , principals , tcflags , buf , len , filename , 1 , <NEW_LINE>cx -> findVersion ( ) ) ; <NEW_LINE> <END_VULN> cx -> free_ ( buf ) ; <NEW_LINE> return script ; <NEW_LINE> } <NEW_LINE> JS_PUBLIC_API ( JSScript * ) <NEW_LINE> JS_CompileFile ( JSContext * cx , JSObject * obj , const char * filename ) <NEW_LINE> { <NEW_LINE> JS_THREADSAFE_ASSERT ( cx -> compartment != cx -> runtime -> atomsCompartment ) ;
while ( ! nshape -> isEmptyShape ( ) ) { <NEW_LINE> ids [ nshape -> slot ( ) ] . set ( nshape -> propid ( ) ) ; <NEW_LINE> nshape = nshape -> previous ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> RootedId id ( cx ) ; <NEW_LINE> <START_VULN> RootedShape newShape ( cx , res -> lastProperty ( ) ) ; <NEW_LINE> <END_VULN> for ( unsigned i = 0 ; i < ids . length ( ) ; i ++ ) { <NEW_LINE> id = ids [ i ] ; <NEW_LINE> MOZ_ASSERT ( ! res -> contains ( cx , id ) ) ; <NEW_LINE> uint32_t index ; <NEW_LINE> bool indexed = js_IdIsIndex ( id , & index ) ; <NEW_LINE> Rooted < UnownedBaseShape * > nbase ( cx , newShape -> base ( ) -> unowned ( ) ) ;
if ( everHadLayout ( ) && needsLayout ( ) ) <NEW_LINE> SVGResourcesCache::clientLayoutChanged ( this ) ; <NEW_LINE> <START_VULN> if ( m_needsBoundariesUpdate || updatedTransform ) { <NEW_LINE> <END_VULN> updateCachedBoundaries ( ) ; <NEW_LINE> m_needsBoundariesUpdate = false ;
return BAD_VALUE ; <NEW_LINE> } <NEW_LINE> <START_VULN> BufferMeta * buffer_meta = new BufferMeta ( params ) ; <NEW_LINE> <END_VULN> OMX_BUFFERHEADERTYPE * header ;
while ( pos < stop ) { <NEW_LINE> long len ; <NEW_LINE> <START_VULN> const long long id = ReadUInt ( pReader , pos , len ) ; <NEW_LINE>assert ( id >= 0 ) ; <NEW_LINE>assert ( ( pos + len ) <= stop ) ; <NEW_LINE> <END_VULN> pos += len ;
const APIPermission::CheckParam * param ) const ; <NEW_LINE> <START_VULN> <NEW_LINE>bool HasAccessToFunction ( const std::string & function_name ) const ; <NEW_LINE> <END_VULN> bool HasExplicitAccessToOrigin ( const GURL & origin ) const ;
virtual void TabInsertedAt ( content::WebContents * contents , <NEW_LINE> int model_index , <NEW_LINE> bool is_active ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void TabDetachedAt ( TabContents * contents , <NEW_LINE> <END_VULN> int model_index ) OVERRIDE ; <NEW_LINE> virtual void TabSelectionChanged ( <NEW_LINE> TabStripModel * tab_strip_model ,
mDownstreamZlib . opaque = Z_NULL ; <NEW_LINE> inflateInit ( & mDownstreamZlib ) ; <NEW_LINE> mUpstreamZlib . zalloc = SpdyStream3::zlib_allocator ; <NEW_LINE> mUpstreamZlib . zfree = SpdyStream3::zlib_destructor ; <NEW_LINE> mUpstreamZlib . opaque = Z_NULL ; <NEW_LINE> <START_VULN> deflateInit ( & mUpstreamZlib , Z_DEFAULT_COMPRESSION ) ; <NEW_LINE> <END_VULN> deflateSetDictionary ( & mUpstreamZlib , <NEW_LINE> SpdyStream3::kDictionary , <NEW_LINE> sizeof ( SpdyStream3::kDictionary ) ) ; <NEW_LINE> } <NEW_LINE> nsresult
return ; <NEW_LINE> } <NEW_LINE> fAllocCount = newAllocCount ; <NEW_LINE> <START_VULN> void * newMemArray = sk_malloc_throw ( fAllocCount * sizeof ( T ) ) ; <NEW_LINE> <END_VULN> this -> move ( newMemArray ) ; <NEW_LINE> if ( fOwnMemory ) { <NEW_LINE> sk_free ( fMemArray ) ;
LOG ( ( "OBJLC [ % p ] : CheckContentProcessPolicy rejected load" , this ) ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> nsObjectLoadingContent::ParameterUpdateFlags <NEW_LINE> <START_VULN> nsObjectLoadingContent::UpdateObjectParameters ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> nsCOMPtr < nsIContent > thisContent = <NEW_LINE> do_QueryInterface ( static_cast < nsIImageLoadingContent * > ( this ) ) ; <NEW_LINE> NS_ASSERTION ( thisContent , "Must be an instance of content" ) ; <NEW_LINE> uint32_t caps = GetCapabilities ( ) ; <NEW_LINE> LOG ( ( "OBJLC [ % p ] : Updating object parameters" , this ) ) ;
cp [ 3 ] == 'n' && <NEW_LINE> cp [ 4 ] == 'e' ) { <NEW_LINE> SkipChars ( ts , 5 ) ; <NEW_LINE> <START_VULN> while ( ( c = GetChar ( ts ) ) != '\n' && JS_ISSPACE ( c ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( JS7_ISDEC ( c ) ) { <NEW_LINE> line = JS7_UNDEC ( c ) ;
if ( ! boundBuffer ) <NEW_LINE> return ErrorInvalidOperation ( "bufferData: no buffer bound ! " ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ! CheckedInt < GLsizeiptr > ( data . Length ( ) ) . isValid ( ) ) <NEW_LINE> return ErrorOutOfMemory ( "bufferData: bad size" ) ;
case MESSAGE_UPDATE: { <NEW_LINE> if ( ! ndo -> ndo_vflag ) { <NEW_LINE> ND_PRINT ( ( ndo , " update" ) ) ; <NEW_LINE> <START_VULN> if ( len < 1 ) <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , " / truncated" ) ) ; <NEW_LINE> else <NEW_LINE> ND_PRINT ( ( ndo , " % s % s % s" ,
& parameters . subsampling_dx , & parameters . subsampling_dy ) ; <NEW_LINE> property = GetImageProperty ( image , "comment" ) ; <NEW_LINE> if ( property != ( const char * ) NULL ) <NEW_LINE> <START_VULN> parameters . cp_comment = property ; <NEW_LINE> <END_VULN> channels = 3 ; <NEW_LINE> jp2_colorspace = OPJ_CLRSPC_SRGB ; <NEW_LINE> if ( image -> colorspace == YUVColorspace )
bool Check ( ) const { <NEW_LINE> if ( ! initialized_ ) return false ; <NEW_LINE> int64_t post_store [ 8 ] ; <NEW_LINE> <START_VULN> vp9_push_neon ( post_store ) ; <NEW_LINE> <END_VULN> for ( int i = 0 ; i < 8 ; ++ i ) { <NEW_LINE> EXPECT_EQ ( pre_store_ [ i ] , post_store [ i ] ) << "d" <NEW_LINE> << i + 8 << " has been modified" ;
EXPECT_CALL ( umaHelper ( ) , handleContextDestroyed ( ) ) ; <NEW_LINE> mediaElement ( ) . setMuted ( true ) ; <NEW_LINE> <START_VULN> umaHelper ( ) . onAutoplayInitiated ( AutoplaySource::Attribute ) ; <NEW_LINE> <END_VULN> umaHelper ( ) . handlePlayingEvent ( ) ; <NEW_LINE> pageHolder ( ) . reset ( ) ; <NEW_LINE> ::testing::Mock::VerifyAndClear ( & umaHelper ( ) ) ;
#include "vpx / vpx_codec . h" <NEW_LINE> <START_VULN> static const char * const cfg = " -- target = armv7 - linux - gcc -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
if ( ! stringIsBase64EncodingOf256bitValue ( pin ) ) { <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> } <NEW_LINE> sha256keys . AppendElement ( pin ) ; <NEW_LINE> } <NEW_LINE> SiteHPKPState dynamicEntry ( expireTime , SecurityPropertySet , <NEW_LINE> aIncludeSubdomains , sha256keys ) ; <NEW_LINE> <START_VULN> nsAutoCString host ( aHost ) ; <NEW_LINE> <END_VULN> nsAutoCString storageKey ; <NEW_LINE> SetStorageKey ( storageKey , host , nsISiteSecurityService::HEADER_HPKP ) ; <NEW_LINE> mozilla::DataStorageType storageType = mozilla::DataStorage_Persistent ; <NEW_LINE> nsAutoCString stateString ; <NEW_LINE> dynamicEntry . ToString ( stateString ) ; <NEW_LINE> nsresult rv = mSiteStateStorage -> Put ( storageKey , stateString , storageType ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
void ** buffer_data ) { <NEW_LINE> Mutex::Autolock autoLock ( mLock ) ; <NEW_LINE> <START_VULN> BufferMeta * buffer_meta = new BufferMeta ( size ) ; <NEW_LINE> <END_VULN> OMX_BUFFERHEADERTYPE * header ;
entry . manifest_pos = manifest_index ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( entry . filename_len + 20 > endbuffer - buffer ) { <NEW_LINE> <END_VULN> MAPPHAR_FAIL ( "internal corruption of phar \" % s\" ( truncated manifest entry ) " ) ; <NEW_LINE> }
return_value -> value . obj = spl_filesystem_object_new_ex ( ce , & intern TSRMLS_CC ) ; <NEW_LINE> Z_TYPE_P ( return_value ) = IS_OBJECT ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> spl_filesystem_object_get_file_name ( source TSRMLS_CC ) ; <NEW_LINE> if ( ce -> constructor -> common . scope != spl_ce_SplFileObject ) {
if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a ) <NEW_LINE> <START_VULN> res = VPX_CODEC_UNSUP_BITSTREAM ; <NEW_LINE> <END_VULN> si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ; <NEW_LINE> si -> h = ( clear [ 8 ] | ( clear [ 9 ] << 8 ) ) & 0x3fff ;
JSObject * object = nullptr ; <NEW_LINE> wrappedJS -> GetJSObject ( & object ) ; <NEW_LINE> if ( ! object ) { <NEW_LINE> return NS_ERROR_UNEXPECTED ; <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> NS_ENSURE_STATE ( pusher . Push ( cx , nsCxPusher::ALWAYS_PUSH ) ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , object ) ; <NEW_LINE> JS::Value thisValue = JSVAL_VOID ; <NEW_LINE> JS::Value funval ; <NEW_LINE> if ( ! JS_GetProperty ( cx , object , "constructor" , & funval ) || ! funval . isObject ( ) ) { <NEW_LINE> return NS_ERROR_UNEXPECTED ;
if ( relayoutChildren || ( child -> isReplaced ( ) && ( child -> style ( ) -> width ( ) . isPercent ( ) || child -> style ( ) -> height ( ) . isPercent ( ) ) ) ) <NEW_LINE> child -> setChildNeedsLayout ( true , MarkOnlyThis ) ; <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ;
const PRUint16 platformID = ReadShortAt ( table , TableOffsetPlatformID ) ; <NEW_LINE> if ( ! acceptablePlatform ( platformID ) ) <NEW_LINE> continue ; <NEW_LINE> const PRUint16 encodingID = ReadShortAt ( table , TableOffsetEncodingID ) ; <NEW_LINE> const PRUint32 offset = ReadLongAt ( table , TableOffsetOffset ) ; <NEW_LINE> NS_ASSERTION ( offset < aBufLength , "cmap table offset is longer than table size" ) ; <NEW_LINE> <START_VULN> NS_ENSURE_TRUE ( offset < aBufLength , NS_ERROR_FAILURE ) ; <NEW_LINE> <END_VULN> const PRUint8 * subtable = aBuf + offset ; <NEW_LINE> const PRUint16 format = ReadShortAt ( subtable , SubtableOffsetFormat ) ; <NEW_LINE> if ( isSymbol ( platformID , encodingID ) ) { <NEW_LINE> aUnicodeFont = PR_FALSE ; <NEW_LINE> aSymbolFont = PR_TRUE ; <NEW_LINE> keepFormat = format ;
} <NEW_LINE> <START_VULN> #endif <NEW_LINE><NEW_LINE> <END_VULN>
{ <NEW_LINE> MsgToEventLog ( M_SYSERR , TEXT ( "PeekNamedPipeAsync failed" ) ) ; <NEW_LINE> ReturnLastError ( pipe , L"PeekNamedPipeAsync" ) ; <NEW_LINE> <START_VULN> goto out ; <NEW_LINE> <END_VULN> } <NEW_LINE> size = bytes / sizeof ( * data ) ;
return ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( length > png_ptr -> num_palette || length > PNG_MAX_PALETTE_LENGTH || <NEW_LINE> <END_VULN> length == 0 ) <NEW_LINE> { <NEW_LINE> png_crc_finish ( png_ptr , length ) ;
tpgt_str += 5 ; <NEW_LINE> tpgt = ( unsigned short int ) simple_strtoul ( tpgt_str , & end_ptr , 0 ) ; <NEW_LINE> <START_VULN> if ( tpgt > TL_TPGS_PER_HBA ) { <NEW_LINE> <END_VULN> printk ( KERN_ERR "Passed tpgt: % hu exceeds TL_TPGS_PER_HBA:" <NEW_LINE> " % u\n" , tpgt , TL_TPGS_PER_HBA ) ; <NEW_LINE> return ERR_PTR ( - EINVAL ) ;
RenderBlock * columnsBlockAncestor = 0 ; <NEW_LINE> if ( ! newChild -> isText ( ) && newChild -> style ( ) -> columnSpan ( ) && ! newChild -> isBeforeOrAfterContent ( ) <NEW_LINE> <START_VULN> && ! newChild -> isFloatingOrPositioned ( ) && ! newChild -> isInline ( ) && ! isAnonymousColumnSpanBlock ( ) ) { <NEW_LINE> <END_VULN> columnsBlockAncestor = containingColumnsBlock ( false ) ; <NEW_LINE> if ( columnsBlockAncestor ) {
class nsJPEGDecoder : public Decoder <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> nsJPEGDecoder ( RasterImage & aImage , Decoder::DecodeStyle aDecodeStyle ) ; <NEW_LINE> virtual ~ nsJPEGDecoder ( ) ; <NEW_LINE> virtual void InitInternal ( ) ; <NEW_LINE> <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> virtual void FinishInternal ( ) ; <NEW_LINE> virtual Telemetry::ID SpeedHistogram ( ) ; <NEW_LINE> void NotifyDone ( ) ; <NEW_LINE> protected: <NEW_LINE> Orientation ReadOrientationFromEXIF ( ) ; <NEW_LINE> void OutputScanlines ( bool * suspend ) ;
void <NEW_LINE> nsIFrame::InlineMinWidthData::ForceBreak ( nsRenderingContext * aRenderingContext ) <NEW_LINE> { <NEW_LINE> currentLine - = trailingWhitespace ; <NEW_LINE> prevLines = NS_MAX ( prevLines , currentLine ) ; <NEW_LINE> currentLine = trailingWhitespace = 0 ; <NEW_LINE> for ( PRUint32 i = 0 , i_end = floats . Length ( ) ; i != i_end ; ++ i ) { <NEW_LINE> <START_VULN> nsIFrame * floatFrame = floats [ i ] ; <NEW_LINE>nscoord float_min = <NEW_LINE>nsLayoutUtils::IntrinsicForContainer ( aRenderingContext , floatFrame , <NEW_LINE>nsLayoutUtils::MIN_WIDTH ) ; <NEW_LINE> <END_VULN> if ( float_min > prevLines ) <NEW_LINE> prevLines = float_min ; <NEW_LINE> } <NEW_LINE> floats . Clear ( ) ; <NEW_LINE> trailingTextFrame = nullptr ; <NEW_LINE> skipWhitespace = true ; <NEW_LINE> }
make_random_bytes ( seed , bytes , 4 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #ifdef PNG_READ_SUPPORTED <NEW_LINE> <END_VULN> static void <NEW_LINE> randomize ( void * pv , size_t size ) <NEW_LINE> {
error = 0 ; <NEW_LINE> for ( i = 0 ; i < ord ; i ++ ) { <NEW_LINE> double pp = 0 . , delta ; <NEW_LINE> double rooti = root [ i ] ; <NEW_LINE> double p = a [ ord ] ; <NEW_LINE> for ( k = ord - 1 ; k >= 0 ; k -- ) { <NEW_LINE> <START_VULN> pp = pp * rooti + p ; <NEW_LINE>p = p * rooti + a [ k ] ; <NEW_LINE> <END_VULN> } <NEW_LINE> delta = p / pp ; <NEW_LINE> root [ i ] - = delta ; <NEW_LINE> error += delta * delta ; <NEW_LINE> } <NEW_LINE> if ( count > 40 ) return ( - 1 ) ;
virtual void SetUnmanagedState ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE>void StopAutoRetry ( ) ; <NEW_LINE> <END_VULN> virtual void HandleRegisterResponse (
nsCOMPtr < nsIAutoCompleteInput > input ; <NEW_LINE> mController -> GetInput ( getter_AddRefs ( input ) ) ; <NEW_LINE> if ( input == this ) <NEW_LINE> mController -> SetInput ( nsnull ) ; <NEW_LINE> if ( mFocusedInputNode ) { <NEW_LINE> <START_VULN> mFocusedInputNode -> RemoveMutationObserver ( this ) ; <NEW_LINE> <END_VULN> mFocusedInputNode = nsnull ; <NEW_LINE> mFocusedInput = nsnull ; <NEW_LINE> } <NEW_LINE> mFocusedPopup = nsnull ; <NEW_LINE> } <NEW_LINE> nsIDocShell * <NEW_LINE> nsFormFillController::GetDocShellForInput ( nsIDOMHTMLInputElement * aInput )
{ <NEW_LINE> NS_PRECONDITION ( ! mIsDocumentGone , "Unexpected AttributeChanged" ) ; <NEW_LINE> NS_PRECONDITION ( aDocument == mDocument , "Unexpected aDocument" ) ; <NEW_LINE> if ( mDidInitialReflow ) { <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE> <END_VULN> mFrameConstructor -> AttributeChanged ( aContent , aNameSpaceID , <NEW_LINE> aAttribute , aModType , aStateMask ) ; <NEW_LINE> VERIFY_STYLE_TREE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> PresShell::ContentAppended ( nsIDocument * aDocument ,
<START_VULN> key = stok ( key , ":\r\n\t " , & junk ) ; <NEW_LINE> <END_VULN> httpSetHeaderString ( conn , key , value ) ; <NEW_LINE> } <NEW_LINE> }
return js_InitXMLClass ( cx , obj ) ; <NEW_LINE> } <NEW_LINE> namespace js { <NEW_LINE> bool <NEW_LINE> GlobalObject::getFunctionNamespace ( JSContext * cx , Value * vp ) <NEW_LINE> { <NEW_LINE> <START_VULN> HeapSlot & v = getSlotRef ( FUNCTION_NS ) ; <NEW_LINE> <END_VULN> if ( v . isUndefined ( ) ) { <NEW_LINE> JSRuntime * rt = cx -> runtime ; <NEW_LINE> JSLinearString * prefix = rt -> atomState . typeAtoms [ JSTYPE_FUNCTION ] ; <NEW_LINE> JSLinearString * uri = rt -> atomState . functionNamespaceURIAtom ; <NEW_LINE> JSObject * obj = NewXMLNamespace ( cx , prefix , uri , JS_FALSE ) ; <NEW_LINE> if ( ! obj ) <NEW_LINE> return false ;
xdr -> reghash = NULL ; <NEW_LINE> xdr -> userdata = NULL ; <NEW_LINE> xdr -> script = NULL ; <NEW_LINE> <START_VULN> xdr -> state = NULL ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_PUBLIC_API ( JSXDRState * )
jsvUnLock ( stringVar ) ; <NEW_LINE> return l ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> strncpy ( str , "" , len ) ; <NEW_LINE> <END_VULN> jsExceptionHere ( JSET_INTERNALERROR , "Variable type cannot be converted to string" ) ; <NEW_LINE> return 0 ; <NEW_LINE> }
if ( ( ( cache_info -> type == UndefinedCache ) && ( status != MagickFalse ) ) || <NEW_LINE> ( cache_info -> type == MemoryCache ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> AllocatePixelCachePixels ( cache_info ) ; <NEW_LINE> <END_VULN> if ( cache_info -> pixels == ( PixelPacket * ) NULL ) <NEW_LINE> cache_info -> pixels = source_info . pixels ; <NEW_LINE> else
JS_SetContextCallback ( mJSRuntime , ContextCallback ) ; <NEW_LINE> JS_SetDestroyCompartmentCallback ( mJSRuntime , CompartmentDestroyedCallback ) ; <NEW_LINE> JS_SetGCCallback ( mJSRuntime , GCCallback ) ; <NEW_LINE> JS_SetFinalizeCallback ( mJSRuntime , FinalizeCallback ) ; <NEW_LINE> JS_SetExtraGCRootsTracer ( mJSRuntime , TraceBlackJS , this ) ; <NEW_LINE> JS_SetGrayGCRootsTracer ( mJSRuntime , TraceGrayJS , this ) ; <NEW_LINE> JS_SetWrapObjectCallbacks ( mJSRuntime , <NEW_LINE> xpc::WrapperFactory::Rewrap , <NEW_LINE> <START_VULN> NULL , <NEW_LINE> <END_VULN> xpc::WrapperFactory::PrepareForWrapping ) ; <NEW_LINE> js::SetPreserveWrapperCallback ( mJSRuntime , PreserveWrapper ) ; <NEW_LINE> #ifdef MOZ_CRASHREPORTER <NEW_LINE> JS_EnumerateDiagnosticMemoryRegions ( DiagnosticMemoryCallback ) ; <NEW_LINE> #endif <NEW_LINE> JS_SetAccumulateTelemetryCallback ( mJSRuntime , AccumulateTelemetryCallback ) ; <NEW_LINE> js::SetActivityCallback ( mJSRuntime , ActivityCallback , this ) ;
if ( ( int ) sub . rm_eo > ( int ) strlen ( str ) ) { <NEW_LINE> <START_VULN> sprintf ( grump , "start % ld end % ld , past end of string" , <NEW_LINE> <END_VULN> ( long ) sub . rm_so , ( long ) sub . rm_eo ) ; <NEW_LINE> return ( grump ) ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> RasterImage::DecodePool::DecodeABitOf ( RasterImage * aImg , DecodeStrategy aStrategy ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( NS_IsMainThread ( ) ) ; <NEW_LINE> <START_VULN> aImg -> mDecodingMutex . AssertCurrentThreadOwns ( ) ; <NEW_LINE> <END_VULN> if ( aImg -> mDecodeRequest ) { <NEW_LINE> if ( aImg -> mDecodeRequest -> mRequestStatus == DecodeRequest::REQUEST_WORK_DONE ) { <NEW_LINE> aImg -> FinishedSomeDecoding ( ) ; <NEW_LINE> } <NEW_LINE> }
<START_VULN> extern const void * lh_table_lookup ( struct lh_table * t , const void * k ) ; <NEW_LINE> <END_VULN>
return xpc::NonVoidStringToJsval ( cx , str , vp ) ; <NEW_LINE> } <NEW_LINE> static JSObject * <NEW_LINE> CreateInterfaceObject ( JSContext * cx , JSObject * global , JSObject * receiver , <NEW_LINE> JSClass * constructorClass , JSNative constructorNative , <NEW_LINE> unsigned ctorNargs , JSObject * proto , <NEW_LINE> <START_VULN> Prefable < JSFunctionSpec > * staticMethods , <NEW_LINE>Prefable < ConstantSpec > * constants , <NEW_LINE> <END_VULN> const char * name ) <NEW_LINE> { <NEW_LINE> JSObject * constructor ; <NEW_LINE> if ( constructorClass ) { <NEW_LINE> JSObject * functionProto = JS_GetFunctionPrototype ( cx , global ) ; <NEW_LINE> if ( ! functionProto ) { <NEW_LINE> return NULL ; <NEW_LINE> }
if ( ! value . IsEmpty ( ) ) <NEW_LINE> mutation . mPrevAttrValue = do_GetAtom ( value ) ; <NEW_LINE> mutation . mAttrChange = nsIDOMMutationEvent::REMOVAL ; <NEW_LINE> mozAutoSubtreeModified subtree ( GetOwnerDoc ( ) , this ) ; <NEW_LINE> nsEventDispatcher::Dispatch ( this , nsnull , & mutation ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> return AfterSetAttr ( aNameSpaceID , aName , nsnull , aNotify ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> const nsAttrName * <NEW_LINE> nsGenericElement::GetAttrNameAt ( PRUint32 aIndex ) const <NEW_LINE> { <NEW_LINE> return mAttrsAndChildren . GetSafeAttrNameAt ( aIndex ) ; <NEW_LINE> }
} ; <NEW_LINE> <START_VULN> const InterpKernel vp9_sub_pel_filters_8s [ SUBPEL_SHIFTS ] = { <NEW_LINE> <END_VULN> { 0 , 0 , 0 , 128 , 0 , 0 , 0 , 0 } , <NEW_LINE> { - 1 , 3 , - 7 , 127 , 8 , - 3 , 1 , 0 } , <NEW_LINE> { - 2 , 5 , - 13 , 125 , 17 , - 6 , 3 , - 1 } ,
} <NEW_LINE> } <NEW_LINE> int32_t selectedIndex ; <NEW_LINE> if ( NS_SUCCEEDED ( GetIndexFromDOMEvent ( aMouseEvent , selectedIndex ) ) ) { <NEW_LINE> mButtonDown = true ; <NEW_LINE> CaptureMouseEvents ( true ) ; <NEW_LINE> <START_VULN> mChangesSinceDragStart = HandleListSelection ( aMouseEvent , selectedIndex ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> if ( mComboboxFrame ) { <NEW_LINE> if ( ! IgnoreMouseEventForSelection ( aMouseEvent ) ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> if ( ! nsComboboxControlFrame::ToolkitHasNativePopup ( ) )
} <NEW_LINE> ix = 0 ; <NEW_LINE> <START_VULN> if ( ( parent == NULL ) || ( node -> doc == NULL ) || isRVT ) <NEW_LINE> <END_VULN> nocache = 1 ; <NEW_LINE> if ( nocache == 0 ) {
goto error ; <NEW_LINE> } <NEW_LINE> DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <NEW_LINE> <START_VULN> if ( p + l > buf + n ) { <NEW_LINE> <END_VULN> syslog ( LOG_WARNING , "bad request ( length encoding ) " ) ; <NEW_LINE> goto error ; <NEW_LINE> }
aState , select ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsAutoPtr < txVariableItem > var ( <NEW_LINE> new txVariableItem ( name , select , aLocalName == nsGkAtoms::param ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( var , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> aState . openInstructionContainer ( var ) ; <NEW_LINE> <START_VULN> rv = aState . pushPtr ( var ) ; <NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> if ( var -> mValue ) { <NEW_LINE> rv = aState . pushHandlerTable ( gTxIgnoreHandler ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> } <NEW_LINE> else {
virtual ~ IMediaDeathNotifier ( ) { removeObitRecipient ( this ) ; } <NEW_LINE> virtual void died ( ) = 0 ; <NEW_LINE> <START_VULN> static const sp < IMediaPlayerService > & getMediaPlayerService ( ) ; <NEW_LINE> <END_VULN> private: <NEW_LINE> IMediaDeathNotifier & operator = ( const IMediaDeathNotifier & ) ;
} <NEW_LINE> void AutoplayUmaHelper::maybeStartRecordingMutedVideoOffscreenDuration ( ) { <NEW_LINE> <START_VULN> if ( ! m_element -> isHTMLVideoElement ( ) || ! m_element -> muted ( ) ) <NEW_LINE> <END_VULN> return ;
put_recursion_context ( swhash -> recursion , rctx ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void __perf_sw_event ( u32 event_id , u64 nr , int nmi , <NEW_LINE>struct pt_regs * regs , u64 addr ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct perf_sample_data data ; <NEW_LINE> int rctx ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x17:
<START_VULN> #ifndef CHROME_BROWSER_CHROMEOS_KIOSK_NEXT_HOME_APP_CONTROLLER_IMPL_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_KIOSK_NEXT_HOME_APP_CONTROLLER_IMPL_H_ <NEW_LINE> <END_VULN> #include < map > <NEW_LINE> #include < memory >
SPL_METHOD ( DirectoryIterator , valid ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
RETURN_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> buffer = zend_string_alloc ( len , 0 ) ; <NEW_LINE> <END_VULN> n = zip_fread ( zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ; <NEW_LINE> if ( n < 1 ) { <NEW_LINE> zend_string_free ( buffer ) ;
} <NEW_LINE> if ( b < 0 . ) return - sqrt ( a * a + b * b ) ; <NEW_LINE> if ( - a > b ) return - sqrt ( a * a + b * b ) ; <NEW_LINE> return sqrt ( b * b + a * a ) ; <NEW_LINE> } <NEW_LINE> float ** _vp_quantize_couple_memo ( vorbis_block * vb , <NEW_LINE> <START_VULN> vorbis_info_psy_global * g , <NEW_LINE>vorbis_look_psy * p , <NEW_LINE>vorbis_info_mapping0 * vi , <NEW_LINE>float ** mdct ) { <NEW_LINE> <END_VULN> int i , j , n = p -> n ; <NEW_LINE> float ** ret = _vorbis_block_alloc ( vb , vi -> coupling_steps * sizeof ( * ret ) ) ; <NEW_LINE> int limit = g -> coupling_pointlimit [ p -> vi -> blockflag ] [ PACKETBLOBS / 2 ] ; <NEW_LINE> for ( i = 0 ; i < vi -> coupling_steps ; i ++ ) { <NEW_LINE> float * mdctM = mdct [ vi -> coupling_mag [ i ] ] ; <NEW_LINE> float * mdctA = mdct [ vi -> coupling_ang [ i ] ] ;
else <NEW_LINE> { <NEW_LINE> double samples = 3 . 0 / 2 * cpi -> count * <NEW_LINE> <START_VULN> lst_yv12 -> y_width * lst_yv12 -> y_height ; <NEW_LINE> <END_VULN> double total_psnr = vpx_sse_to_psnr ( samples , 255 . 0 , <NEW_LINE> cpi -> total_sq_error ) ; <NEW_LINE> double total_psnr2 = vpx_sse_to_psnr ( samples , 255 . 0 ,
class DOMHandler : public DevToolsDomainHandler , <NEW_LINE> public DOM::Backend { <NEW_LINE> public: <NEW_LINE> <START_VULN> DOMHandler ( ) ; <NEW_LINE> <END_VULN> ~ DOMHandler ( ) override ; <NEW_LINE> void Wire ( UberDispatcher * dispatcher ) override ;
case FILE_LEDATE: <NEW_LINE> case FILE_MEDATE: <NEW_LINE> if ( file_printf ( ms , F ( ms , m , " % s" ) , <NEW_LINE> <START_VULN> file_fmttime ( p -> l , FILE_T_LOCAL , tbuf ) ) == - 1 ) <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> t = ms -> offset + sizeof ( uint32_t ) ; <NEW_LINE> break ;
else if ( aNotify && IsInDoc ( ) ) { <NEW_LINE> modification = ! ! mAttrsAndChildren . GetAttr ( nsGkAtoms::style ) ; <NEW_LINE> } <NEW_LINE> nsAttrValue attrValue ( aStyleRule ) ; <NEW_LINE> return SetAttrAndNotify ( kNameSpaceID_None , nsGkAtoms::style , nsnull , <NEW_LINE> oldValueStr , attrValue , modification , hasListeners , <NEW_LINE> <START_VULN> aNotify ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsICSSStyleRule * <NEW_LINE> nsStyledElement::GetInlineStyleRule ( ) <NEW_LINE> { <NEW_LINE> if ( ! HasFlag ( NODE_MAY_HAVE_STYLE ) ) { <NEW_LINE> return nsnull ; <NEW_LINE> }
line_iterator aLine , <NEW_LINE> PRBool * aKeepReflowGoing ) ; <NEW_LINE> <START_VULN> nsresult MarkLineDirty ( line_iterator aLine ) ; <NEW_LINE> <END_VULN> PRBool ShouldJustifyLine ( nsBlockReflowState & aState , <NEW_LINE> line_iterator aLine ) ; <NEW_LINE> void DeleteLine ( nsBlockReflowState & aState , <NEW_LINE> nsLineList::iterator aLine , <NEW_LINE> nsLineList::iterator aLineEnd ) ;
port = args -> args [ 0 ] ; <NEW_LINE> idx = args -> args [ 1 ] ; <NEW_LINE> <START_VULN> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <NEW_LINE> <END_VULN> struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ; <NEW_LINE> if ( idx != macro -> idx )
while ( 0x80 != plaintext [ cipher_len - 2 ] && ( cipher_len - 2 > 0 ) ) <NEW_LINE> cipher_len -- ; <NEW_LINE> <START_VULN> if ( 2 == cipher_len ) <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> memcpy ( out , plaintext , cipher_len - 2 ) ;
SPL_METHOD ( SplFileObject , getMaxLineLen ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
#define PPAPI_C_PPB_FILE_REF_H_ <NEW_LINE> #include "ppapi / c / pp_bool . h" <NEW_LINE> #include "ppapi / c / pp_file_info . h" <NEW_LINE> <START_VULN> #include "ppapi / c / pp_instance . h" <NEW_LINE> <END_VULN> #include "ppapi / c / pp_resource . h" <NEW_LINE> #include "ppapi / c / pp_var . h"
NS_ENSURE_TRUE ( mIsInitialized , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE> * aRetValue = JSVAL_VOID ; <NEW_LINE> if ( ! mScriptsEnabled ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> if ( ! pusher . Push ( mContext ) ) <NEW_LINE> <END_VULN> return NS_ERROR_FAILURE ; <NEW_LINE> xpc_UnmarkGrayObject ( & aScopeObject ) ; <NEW_LINE> nsAutoMicroTask mt ; <NEW_LINE> JSPrincipals * p = JS_GetCompartmentPrincipals ( js::GetObjectCompartment ( & aScopeObject ) ) ; <NEW_LINE> aOptions . setPrincipals ( p ) ;
( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; <NEW_LINE> if ( res != TEE_SUCCESS ) <NEW_LINE> return res ; <NEW_LINE> <START_VULN> utee_param_to_param ( param , callee_params ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) {
result = MakeDate ( Day ( lorutime ) , msec_time ) ; <NEW_LINE> if ( local ) <NEW_LINE> result = UTC ( result ) ; <NEW_LINE> <START_VULN> result = TIMECLIP ( result ) ; <NEW_LINE>if ( ! SetUTCTime ( cx , obj , NULL , result ) ) <NEW_LINE>return JS_FALSE ; <NEW_LINE><NEW_LINE>return js_NewNumberInRootedValue ( cx , result , vp ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static JSBool <NEW_LINE> date_setMilliseconds ( JSContext * cx , uintN argc , jsval * vp ) <NEW_LINE> { <NEW_LINE> return date_makeTime ( cx , 1 , JS_TRUE , argc , vp ) ; <NEW_LINE> } <NEW_LINE> static JSBool
ipx_print ( ndo , p , length ) ; <NEW_LINE> break ; <NEW_LINE> case PPP_OSI: <NEW_LINE> <START_VULN> isoclns_print ( ndo , p , length , length ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case PPP_MPLS_UCAST: <NEW_LINE> case PPP_MPLS_MCAST:
<START_VULN> virtual void UpdateCredentials ( const std::string & account_id , <NEW_LINE>const std::string & refresh_token ) ; <NEW_LINE><NEW_LINE>virtual void RevokeCredentials ( const std::string & account_id ) ; <NEW_LINE> <END_VULN>
{ <NEW_LINE> double gamma ; <NEW_LINE> <START_VULN> if ( png_get_gAMA ( read_ptr , read_info_ptr , & gamma ) ) <NEW_LINE> <END_VULN> png_set_gAMA ( write_ptr , write_info_ptr , gamma ) ; <NEW_LINE> } <NEW_LINE> #endif
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: LSP ( also called LSF ) conversion routines <NEW_LINE> <START_VULN> last mod: $ Id: lsp . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> The LSP generation code is taken ( with minimal modification and a <NEW_LINE> few bugfixes ) from "On the Computation of the LSP Frequencies" by <NEW_LINE> Joseph Rothweiler ( see http: <NEW_LINE> The paper is available at: <NEW_LINE> http:
#ifdef HAVE_ICU <NEW_LINE> else if ( sVar == "clientencoding" ) { <NEW_LINE> pUser -> SetClientEncoding ( sValue ) ; <NEW_LINE> <START_VULN> PutModule ( "ClientEncoding = " + sValue ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif <NEW_LINE> else
} ; <NEW_LINE> <START_VULN> const InterpKernel vp9_sub_pel_filters_8lp [ SUBPEL_SHIFTS ] = { <NEW_LINE> <END_VULN> { 0 , 0 , 0 , 128 , 0 , 0 , 0 , 0 } , <NEW_LINE> { - 3 , - 1 , 32 , 64 , 38 , 1 , - 3 , 0 } , <NEW_LINE> { - 2 , - 2 , 29 , 63 , 41 , 2 , - 3 , 0 } ,
virtual void RestoreTab ( ) = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE>virtual bool CanCloseContentsAt ( int index ) = 0 ; <NEW_LINE> <END_VULN>
if ( pCmdData == NULL || <NEW_LINE> cmdSize < ( int ) sizeof ( effect_param_t ) || <NEW_LINE> pReplyData == NULL || <NEW_LINE> <START_VULN> * replySize < ( int ) sizeof ( effect_param_t ) ) { <NEW_LINE> <END_VULN> ALOGV ( "fx_command ( ) EFFECT_CMD_GET_PARAM invalid args" ) ; <NEW_LINE> return - EINVAL ; <NEW_LINE> }
tstrip_t s , ns = TIFFNumberOfStrips ( in ) ; <NEW_LINE> uint32 row = 0 ; <NEW_LINE> _TIFFmemset ( buf , 0 , stripsize ) ; <NEW_LINE> <START_VULN> for ( s = 0 ; s < ns ; s ++ ) { <NEW_LINE> <END_VULN> tsize_t cc = ( row + rowsperstrip > imagelength ) ? <NEW_LINE> TIFFVStripSize ( in , imagelength - row ) : stripsize ; <NEW_LINE> if ( TIFFReadEncodedStrip ( in , s , buf , cc ) < 0
0 . 9994740570F , 0 . 9995575079F , 0 . 9996306699F , 0 . 9996944099F , <NEW_LINE> 0 . 9997495605F , 0 . 9997969190F , 0 . 9998372465F , 0 . 9998712678F , <NEW_LINE> 0 . 9998996704F , 0 . 9999231041F , 0 . 9999421807F , 0 . 9999574732F , <NEW_LINE> 0 . 9999695157F , 0 . 9999788026F , 0 . 9999857885F , 0 . 9999908879F , <NEW_LINE> 0 . 9999944746F , 0 . 9999968817F , 0 . 9999984010F , 0 . 9999992833F , <NEW_LINE> 0 . 9999997377F , 0 . 9999999317F , 0 . 9999999911F , 0 . 9999999999F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin1024 [ 512 ] = { <NEW_LINE> <END_VULN> 0 . 0000036962F , 0 . 0000332659F , 0 . 0000924041F , 0 . 0001811086F , <NEW_LINE> 0 . 0002993761F , 0 . 0004472021F , 0 . 0006245811F , 0 . 0008315063F , <NEW_LINE> 0 . 0010679699F , 0 . 0013339631F , 0 . 0016294757F , 0 . 0019544965F , <NEW_LINE> 0 . 0023090133F , 0 . 0026930125F , 0 . 0031064797F , 0 . 0035493989F , <NEW_LINE> 0 . 0040217533F , 0 . 0045235250F , 0 . 0050546946F , 0 . 0056152418F ,
png_colorspace_set_rgb_coefficients ( png_structrp png_ptr ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! png_ptr -> rgb_to_gray_coefficients_set && <NEW_LINE> <END_VULN> ( png_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) != 0 ) <NEW_LINE> {
typedef struct { <NEW_LINE> <START_VULN> uchar * data ; <NEW_LINE> <END_VULN> uint_fast16_t len ;
if ( mStopped ) <NEW_LINE> return ; <NEW_LINE> mStopped = 1 ; <NEW_LINE> if ( mTransport && reason != NS_BASE_STREAM_CLOSED && <NEW_LINE> ! mRequestedClose && ! mClientClosed && ! mServerClosed ) { <NEW_LINE> mRequestedClose = 1 ; <NEW_LINE> mSocketThread -> Dispatch ( <NEW_LINE> new OutboundEnqueuer ( this , new OutboundMessage ( kMsgTypeFin , nsnull ) ) , <NEW_LINE> nsIEventTarget::DISPATCH_NORMAL ) ; <NEW_LINE> <START_VULN> mStopOnClose = reason ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> StopSession ( reason ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> WebSocketChannel::ReleaseSession ( )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: basic shared codebook operations <NEW_LINE> <START_VULN> last mod: $ Id: sharedbook . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "os . h"
<START_VULN> if ( stop >= 0 && pos >= stop ) <NEW_LINE> <END_VULN> return E_FILE_FORMAT_INVALID ; <NEW_LINE> return 0 ;
p -> n = n ; <NEW_LINE> p -> rate = rate ; <NEW_LINE> p -> m_val = 1 . ; <NEW_LINE> if ( rate < 26000 ) p -> m_val = 0 ; <NEW_LINE> else if ( rate < 38000 ) p -> m_val = . 94 ; <NEW_LINE> else if ( rate > 46000 ) p -> m_val = 1 . 275 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( i = 0 , j = 0 ; i < MAX_ATH - 1 ; i ++ ) { <NEW_LINE> int endpos = rint ( fromOC ( ( i + 1 ) * . 125 - 2 . ) * 2 * n / rate ) ; <NEW_LINE> float base = ATH [ i ] ; <NEW_LINE> if ( j < endpos ) { <NEW_LINE> float delta = ( ATH [ i + 1 ] - base ) / ( endpos - j ) ; <NEW_LINE> for ( ; j < endpos && j < n ; j ++ ) {
if ( sArray . IsEmpty ( ) ) { <NEW_LINE> sArray . AppendElement ( ) ; <NEW_LINE> ( ( nsTArrayHeader * ) sArray . DebugGetHeader ( ) ) -> mLength = UINT32_MAX ; <NEW_LINE> } <NEW_LINE> return sArray ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> TEST ( TArray , assign ) <NEW_LINE> <END_VULN> { <NEW_LINE> nsTArray < int > array ; <NEW_LINE> array . Assign ( DummyArray ( ) ) ; <NEW_LINE> ASSERT_EQ ( DummyArray ( ) , array ) ; <NEW_LINE> ASSERT_TRUE ( array . Assign ( DummyArray ( ) , fallible ) ) ; <NEW_LINE> ASSERT_EQ ( DummyArray ( ) , array ) ;
#undef mem_put_le24 <NEW_LINE> #define mem_put_le24 mem_ops_wrap_symbol ( mem_put_le24 ) <NEW_LINE> <START_VULN> static void mem_put_le24 ( void * vmem , MEM_VALUE_T val ) { <NEW_LINE> <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; <NEW_LINE> mem [ 0 ] = ( val >> 0 ) & 0xff ;
return ; <NEW_LINE> <START_VULN> ASSERT ( result -> IsFunction ( ) ) ; <NEW_LINE> <END_VULN> v8::Local < v8::Function > intermediateFunction = result . As < v8::Function > ( ) ; <NEW_LINE> HTMLFormElement * formElement = 0 ;
return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> return 0 ; <NEW_LINE> <END_VULN> } <NEW_LINE> static krb5_error_code
virtual void SetCookieInfo ( const CookieInfoList & cookie_info_list ) = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> virtual void SetPermissionInfo ( <NEW_LINE> const PermissionInfoList & permission_info_list ) = 0 ;
{ <NEW_LINE> if ( isFloating ( ) ) <NEW_LINE> return "RenderDeprecatedFlexibleBox ( floating ) " ; <NEW_LINE> <START_VULN> if ( isPositioned ( ) ) <NEW_LINE> <END_VULN> return "RenderDeprecatedFlexibleBox ( positioned ) " ; <NEW_LINE> if ( isAnonymous ( ) ) <NEW_LINE> return "RenderDeprecatedFlexibleBox ( generated ) " ;
{ <NEW_LINE> JS_SetPendingException ( cx , STRING_TO_JSVAL ( JS_NewStringCopyZ ( cx , msg ) ) ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> mozJSSubScriptLoader::ReadScript ( nsIURI * uri , JSContext * cx , JSObject * target_obj , <NEW_LINE> jschar * charset , const char * uriStr , <NEW_LINE> <START_VULN> nsIIOService * serv , JSObject ** scriptObjp ) <NEW_LINE> <END_VULN> { <NEW_LINE> nsCOMPtr < nsIChannel > chan ; <NEW_LINE> nsCOMPtr < nsIInputStream > instream ; <NEW_LINE> JSPrincipals * jsPrincipals ; <NEW_LINE> JSErrorReporter er ; <NEW_LINE> nsresult rv ;
extern SECStatus ssl3_HandleHelloExtensions ( sslSocket * ss , <NEW_LINE> SSL3Opaque ** b , PRUint32 * length ) ; <NEW_LINE> extern PRBool ssl3_ExtensionNegotiated ( sslSocket * ss , PRUint16 ex_type ) ; <NEW_LINE> extern void ssl3_SetSIDSessionTicket ( sslSessionID * sid , <NEW_LINE> <START_VULN> NewSessionTicket * session_ticket , <NEW_LINE>PRBool isTicketRenewal ) ; <NEW_LINE> <END_VULN> extern SECStatus ssl3_SendNewSessionTicket ( sslSocket * ss ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeys ( unsigned char * keyName , <NEW_LINE> unsigned char * encKey , unsigned char * macKey ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeysPKCS11 ( SECKEYPrivateKey * svrPrivKey , <NEW_LINE> SECKEYPublicKey * svrPubKey , void * pwArg , <NEW_LINE> unsigned char * keyName , PK11SymKey ** aesKey , <NEW_LINE> PK11SymKey ** macKey ) ;
#endif <NEW_LINE> <START_VULN> if ( ( mask & PNG_FREE_PLTE ) & info_ptr -> free_me ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_free ( png_ptr , info_ptr -> palette ) ; <NEW_LINE> info_ptr -> palette = NULL ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> <END_VULN> <NEW_LINE> <START_VULN> return res ; <END_VULN> <NEW_LINE> <START_VULN> <END_VULN> <NEW_LINE> <START_VULN> <END_VULN> <NEW_LINE> <START_VULN> cleanup: <END_VULN> <NEW_LINE> <START_VULN> <END_VULN> <NEW_LINE> <START_VULN> if ( hdl ) { <END_VULN> <NEW_LINE> <START_VULN> free ( hdl ) ; <END_VULN> <NEW_LINE> <START_VULN> hdl = NULL ; <END_VULN> <NEW_LINE> <START_VULN> } <END_VULN> <NEW_LINE> <START_VULN> <END_VULN> <NEW_LINE> <NEW_LINE> return res ; <NEW_LINE> }
#ifndef MOJO_EDK_EMBEDDER_SCOPED_PLATFORM_HANDLE_H_ <NEW_LINE> #define MOJO_EDK_EMBEDDER_SCOPED_PLATFORM_HANDLE_H_ <NEW_LINE> #include "base / macros . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "mojo / edk / embedder / platform_handle . h" <NEW_LINE> #include "mojo / edk / system / system_impl_export . h" <NEW_LINE> #include "mojo / public / c / system / macros . h"
<START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>void updateCoefficientsIfNecessary ( bool useSmoothing , bool forceUpdate ) ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> }
public: <NEW_LINE> ~ SendTabToSelfInfoBar ( ) override ; <NEW_LINE> <START_VULN> static void ShowInfoBar ( content::WebContents * web_contents , <NEW_LINE>SendTabToSelfInfoBarDelegate * delegate ) ; <NEW_LINE> <END_VULN> private: <NEW_LINE> explicit SendTabToSelfInfoBar (
NS_ASSERTION ( oldProto -> GetScriptableInfo ( ) -> GetScriptableShared ( ) == <NEW_LINE> newProto -> GetScriptableInfo ( ) -> GetScriptableShared ( ) , <NEW_LINE> "Changing proto is also changing JSObject Classname or " <NEW_LINE> "helper's nsIXPScriptable flags . This is not allowed ! " ) ; <NEW_LINE> wrapper -> UpdateScriptableInfo ( newProto -> GetScriptableInfo ( ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> NS_ASSERTION ( ! newMap -> Find ( wrapper -> GetIdentityObject ( ) ) , <NEW_LINE>"wrapper already in new scope ! " ) ; <NEW_LINE> <END_VULN> if ( ! newMap -> Add ( wrapper ) ) <NEW_LINE> MOZ_CRASH ( ) ; <NEW_LINE> } <NEW_LINE> JSObject * ww = wrapper -> GetWrapper ( ) ; <NEW_LINE> if ( ww ) { <NEW_LINE> JSObject * newwrapper ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: bitrate tracking and management <NEW_LINE> <START_VULN> last mod: $ Id: bitrate . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_BITRATE_H_ <NEW_LINE> #define _V_BITRATE_H_ <NEW_LINE> #include "vorbis / codec . h" <NEW_LINE> #include "codec_internal . h"
#include "core / platform / mediastream / MediaStreamDescriptor . h" <NEW_LINE> #include "core / platform / mediastream / MediaStreamComponent . h" <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "platform / UUID . h" <NEW_LINE> #include "wtf / RefCounted . h" <NEW_LINE> #include "wtf / Vector . h"
for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) <NEW_LINE> for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + <NEW_LINE> <END_VULN> ( * p & mask ) ) , & index , exception ) == MagickFalse ) <NEW_LINE> break ; <NEW_LINE> * p = colormap [ ( ssize_t ) index ] ;
return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> nsDependentString name ( mName ) ; <NEW_LINE> if ( ! ::JS_DefineUCProperty ( aCx , aTargetClassObject , <NEW_LINE> static_cast < const jschar * > ( mName ) , <NEW_LINE> name . Length ( ) , JSVAL_VOID , <NEW_LINE> JS_DATA_TO_FUNC_PTR ( JSPropertyOp , getter ) , <NEW_LINE> JS_DATA_TO_FUNC_PTR ( JSStrictPropertyOp , setter ) , <NEW_LINE> <START_VULN> mJSAttributes ) ) <NEW_LINE> <END_VULN> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsXBLProtoImplProperty::CompileMember ( nsIScriptContext * aContext , const nsCString & aClassStr , <NEW_LINE> JSObject * aClassObject )
#ifdef PPM_SUPPORTED <NEW_LINE> JMESSAGE ( JERR_PPM_COLORSPACE , "PPM output must be grayscale or RGB" ) <NEW_LINE> JMESSAGE ( JERR_PPM_NONNUMERIC , "Nonnumeric data in PPM file" ) <NEW_LINE> <START_VULN> JMESSAGE ( JERR_PPM_TOOLARGE , "Integer value too large in PPM file" ) <NEW_LINE> <END_VULN> JMESSAGE ( JERR_PPM_NOT , "Not a PPM / PGM file" ) <NEW_LINE> JMESSAGE ( JTRC_PGM , " % ux % u PGM image" ) <NEW_LINE> JMESSAGE ( JTRC_PGM_TEXT , " % ux % u text PGM image" ) <NEW_LINE> JMESSAGE ( JTRC_PPM , " % ux % u PPM image" )
} ; <NEW_LINE> extern nsresult <NEW_LINE> <START_VULN> NS_CreateJSTimeoutHandler ( nsIScriptContext * aContext , <NEW_LINE> <END_VULN> PRBool * aIsInterval , <NEW_LINE> PRInt32 * aInterval , <NEW_LINE> nsIScriptTimeoutHandler ** aRet ) ;
for ( i = 0 , rp = row ; i < row_width ; i ++ , rp += bytes_per_pixel ) <NEW_LINE> { <NEW_LINE> <START_VULN> * ( rp ) = ( png_byte ) ( ( * rp - * ( rp + 1 ) ) & 0xff ) ; <NEW_LINE> * ( rp + 2 ) = ( png_byte ) ( ( * ( rp + 2 ) - * ( rp + 1 ) ) & 0xff ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
} ; <NEW_LINE> static const struct multistate multistate_compression [ ] = { <NEW_LINE> { "delayed" , COMP_DELAYED } , <NEW_LINE> <START_VULN> { "yes" , COMP_ZLIB } , <NEW_LINE> <END_VULN> { "no" , COMP_NONE } , <NEW_LINE> { NULL , - 1 } <NEW_LINE> } ;
nsIDocument * ownerDoc = thisContent -> OwnerDoc ( ) ; <NEW_LINE> ownerDoc -> RemovePlugin ( this ) ; <NEW_LINE> if ( mType == eType_Plugin && mInstanceOwner ) { <NEW_LINE> <START_VULN> nsCOMPtr < nsIRunnable > event = new CheckPluginStopEvent ( this ) ; <NEW_LINE>mPendingCheckPluginStopEvent = event ; <NEW_LINE><NEW_LINE>nsCOMPtr < nsIAppShell > appShell = do_GetService ( kAppShellCID ) ; <NEW_LINE>if ( appShell ) { <NEW_LINE>appShell -> RunInStableState ( event ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } else if ( mType != eType_Image ) { <NEW_LINE> UnloadObject ( ) ; <NEW_LINE> }
if ( ! ndo -> ndo_eflag ) <NEW_LINE> ND_PRINT ( ( ndo , "OSI NLPID 0x % 02x unknown" , * p ) ) ; <NEW_LINE> ND_PRINT ( ( ndo , " % slength: % u" , ndo -> ndo_eflag ? "" : " , " , length ) ) ; <NEW_LINE> <START_VULN> if ( caplen > 1 ) <NEW_LINE>print_unknown_data ( ndo , p , "\n\t" , caplen ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> } <NEW_LINE> }
bool shouldFlipMainAxis = ! isColumnFlow ( ) && ! isLeftToRightFlow ( ) ; <NEW_LINE> for ( size_t i = 0 ; i < children . size ( ) ; ++ i ) { <NEW_LINE> RenderBox * child = children [ i ] ; <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> prepareChildForPositionedLayout ( child , mainAxisOffset , crossAxisOffset , FlipForRowReverse ) ; <NEW_LINE> mainAxisOffset += justifyContentSpaceBetweenChildren ( availableFreeSpace , style ( ) -> justifyContent ( ) , childSizes . size ( ) ) ; <NEW_LINE> continue ;
} <NEW_LINE> if ( count > kCount ) { <NEW_LINE> <START_VULN> const uint64_t size64 = sk_64_mul ( count , sizeof ( T ) ) ; <NEW_LINE>const size_t size = static_cast < size_t > ( size64 ) ; <NEW_LINE>if ( size != size64 ) { <NEW_LINE>sk_out_of_memory ( ) ; <NEW_LINE> } <NEW_LINE>fArray = ( T * ) sk_malloc_throw ( size ) ; <NEW_LINE> <END_VULN> } else if ( count > 0 ) { <NEW_LINE> fArray = ( T * ) fStorage ; <NEW_LINE> } else {
{ <NEW_LINE> int i ; <NEW_LINE> for ( i = 31 ; i >= 0 ; i -- ) { <NEW_LINE> <START_VULN> if ( x & ( 1 << i ) ) return i ; <NEW_LINE> <END_VULN> } <NEW_LINE> return 0 ; <NEW_LINE> }
uint16_t transmitted_length = 0 ; <NEW_LINE> while ( length > 0 ) { <NEW_LINE> <START_VULN> ssize_t ret = write ( uart_fd , data + transmitted_length , length ) ; <NEW_LINE> <END_VULN> switch ( ret ) { <NEW_LINE> case - 1: <NEW_LINE> LOG_ERROR ( "In % s , error writing to the uart serial port: % s" , __func__ , strerror ( errno ) ) ;
if ( writer -> Position ( duration_pos_ ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> if ( ! WriteEbmlElement ( writer , <NEW_LINE>kMkvDuration , <NEW_LINE> <END_VULN> static_cast < float > ( duration_ ) ) ) <NEW_LINE> return false ;
@param . . . Variable arguments to format <NEW_LINE> @return Returns the number of bytes written <NEW_LINE> @ingroup MprString <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC ssize mprEprintf ( cchar * fmt , . . . ) PRINTF_ATTRIBUTE ( 1 , 2 ) ;
Address addressForDataRemat ( const FrameEntry * fe ) const ; <NEW_LINE> <START_VULN> Address addressForInlineReturn ( ) const ; <NEW_LINE> <END_VULN> inline StateRemat dataRematInfo ( const FrameEntry * fe ) const ;
q = p_tileno / p_cp -> tw ; <NEW_LINE> <START_VULN> * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , <NEW_LINE> ( OPJ_INT32 ) p_image -> x0 ) ; <NEW_LINE> * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , <NEW_LINE> ( OPJ_INT32 ) p_image -> x1 ) ; <NEW_LINE> * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , <NEW_LINE> ( OPJ_INT32 ) p_image -> y0 ) ; <NEW_LINE> * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , <NEW_LINE> ( OPJ_INT32 ) p_image -> y1 ) ; <NEW_LINE> <END_VULN> * p_max_prec = 0 ;
<START_VULN> static bool neuterViews ( JSContext * cx , Handle < ArrayBufferObject * > buffer ) ; <NEW_LINE> <END_VULN> uint8_t * dataPointer ( ) const ;
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestActiveDOMObject::s_info ) ; <NEW_LINE> TestActiveDOMObject * impl = static_cast < TestActiveDOMObject * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> const String & message ( ustringToString ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . isEmpty ( ) ? UString ( ) : MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . toString ( exec ) -> value ( exec ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
( ( mUcs4 & 0xFFFFF800 ) == 0xD800 ) || <NEW_LINE> ( mUcs4 > 0x10FFFF ) ) { <NEW_LINE> res = NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> if ( mUcs4 > 0xFFFF ) { <NEW_LINE> <START_VULN> mUcs4 - = 0x00010000 ; <NEW_LINE> * out ++ = 0xD800 | ( 0x000003FF & ( mUcs4 >> 10 ) ) ; <NEW_LINE> * out ++ = 0xDC00 | ( 0x000003FF & mUcs4 ) ; <NEW_LINE> <END_VULN> } else if ( UNICODE_BYTE_ORDER_MARK != mUcs4 || ! mFirst ) { <NEW_LINE> * out ++ = mUcs4 ; <NEW_LINE> } <NEW_LINE> mUcs4 = 0 ; <NEW_LINE> mState = 0 ; <NEW_LINE> mBytes = 1 ;
{ <NEW_LINE> JSObject * class_obj = <NEW_LINE> ::JS_InitClass ( ccx , aGlobalObject , nsnull , & sXPC_NW_JSClass . base , <NEW_LINE> <START_VULN> XPCNativeWrapperCtor , 0 , nsnull , sXPC_NW_JSClass_methods , <NEW_LINE> <END_VULN> nsnull , nsnull ) ; <NEW_LINE> if ( ! class_obj ) { <NEW_LINE> NS_WARNING ( "can't initialize the XPCNativeWrapper class" ) ;
#include "vpx / vpx_codec . h" <NEW_LINE> <START_VULN> static const char * const cfg = " -- target = mips64 - linux - gcc -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> }
JSObject * obj = rt -> gcWeakMapList ; <NEW_LINE> while ( obj ) { <NEW_LINE> WeakMap * table = fromJSObject ( obj ) ; <NEW_LINE> <START_VULN> for ( js::HashMap < JSObject * , Value > ::Range r = table -> map . all ( ) ; ! r . empty ( ) ; r . popFront ( ) ) { <NEW_LINE> <END_VULN> JSObject * key = r . front ( ) . key ; <NEW_LINE> Value & value = r . front ( ) . value ; <NEW_LINE> if ( value . isMarkable ( ) && ! IsAboutToBeFinalized ( cx , key ) ) {
} <NEW_LINE> if ( finish ) { <NEW_LINE> <START_VULN> if ( ( ! fifo -> skbuff -> data [ fifo -> skbuff -> len - 1 ] ) <NEW_LINE> && ( fifo -> skbuff -> len > 3 ) ) { <NEW_LINE> <END_VULN> if ( fifon == HFCUSB_D_RX ) { <NEW_LINE> DBG ( HFCUSB_DBG_DCHANNEL ,
JSContext * context = GetContextFromObject ( wrapper -> GetJSObject ( ) ) ; <NEW_LINE> XPCCallContext ccx ( NATIVE_CALLER , context ) ; <NEW_LINE> if ( ! ccx . IsValid ( ) ) <NEW_LINE> return retval ; <NEW_LINE> XPCContext * xpcc = ccx . GetXPCContext ( ) ; <NEW_LINE> <START_VULN> JSContext * cx = ccx . GetJSContext ( ) ; <NEW_LINE> <END_VULN> if ( ! cx || ! xpcc || ! IsReflectable ( methodIndex ) ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> JSObject * obj = wrapper -> GetJSObject ( ) ; <NEW_LINE> JSObject * thisObj = obj ; <NEW_LINE> JSAutoEnterCompartment ac ;
jas_cmprof_t * cmprof_ ; <NEW_LINE> <START_VULN> bool inmem_ ; <NEW_LINE> <END_VULN> } jas_image_t ;
m . instr = static_cast < ModCommand::INSTR > ( nonLooped [ m . instr - 1 ] ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x19:
mFoundBOM = PR_FALSE ; <NEW_LINE> return nsUTF16ToUnicodeBase::Reset ( ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsUTF16ToUnicode::Convert ( const char * aSrc , PRInt32 * aSrcLength , <NEW_LINE> PRUnichar * aDest , PRInt32 * aDestLength ) <NEW_LINE> { <NEW_LINE> if ( STATE_FIRST_CALL == mState ) <NEW_LINE> { <NEW_LINE> mState = STATE_NORMAL ; <NEW_LINE> <START_VULN> if ( * aSrcLength < 2 ) <NEW_LINE>return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE><NEW_LINE> <END_VULN> if ( 0xFF == PRUint8 ( aSrc [ 0 ] ) && 0xFE == PRUint8 ( aSrc [ 1 ] ) ) { <NEW_LINE> mState = STATE_FOUND_BOM ; <NEW_LINE> mEndian = kLittleEndian ; <NEW_LINE> mFoundBOM = PR_TRUE ; <NEW_LINE> } <NEW_LINE> else if ( 0xFE == PRUint8 ( aSrc [ 0 ] ) && 0xFF == PRUint8 ( aSrc [ 1 ] ) ) {
if ( ! m_element -> isHTMLElement ( ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> RefPtr < DocumentFragment > fragment = Range::createDocumentFragmentForElement ( markup , toHTMLElement ( m_element ) ) ; <NEW_LINE> <END_VULN> ExceptionCode exception = 0 ;
int received_content_length , <NEW_LINE> int original_content_length , <NEW_LINE> bool with_data_reduction_proxy_enabled , <NEW_LINE> <START_VULN> bool via_data_reduction_proxy , <NEW_LINE> <END_VULN> PrefService * prefs ) ; <NEW_LINE> }
fp -> regs = NULL ; <NEW_LINE> fp -> imacpc = NULL ; <NEW_LINE> fp -> slots = NULL ; <NEW_LINE> fp -> callobj = NULL ; <NEW_LINE> fp -> argsobj = NULL ; <NEW_LINE> fp -> varobj = cx -> fp -> varobj ; <NEW_LINE> fp -> script = NULL ; <NEW_LINE> <START_VULN> fp -> thisp = ( JSObject * ) cx -> nativeVp [ 1 ] ; <NEW_LINE>fp -> argc = cx -> nativeVpLen - 2 ; <NEW_LINE>fp -> argv = cx -> nativeVp + 2 ; <NEW_LINE> <END_VULN> fp -> fun = GET_FUNCTION_PRIVATE ( cx , JSVAL_TO_OBJECT ( fp -> argv [ - 2 ] ) ) ; <NEW_LINE> fp -> rval = JSVAL_VOID ; <NEW_LINE> fp -> down = cx -> fp ; <NEW_LINE> fp -> annotation = NULL ; <NEW_LINE> JS_ASSERT ( cx -> fp -> scopeChain ) ; <NEW_LINE> fp -> scopeChain = cx -> fp -> scopeChain ; <NEW_LINE> fp -> blockChain = NULL ; <NEW_LINE> fp -> sharpDepth = 0 ;
<START_VULN> bool InitPrintSettings ( WebKit::WebFrame * frame , <NEW_LINE>WebKit::WebNode * node , <NEW_LINE>bool is_preview ) ; <NEW_LINE> <END_VULN> bool InitPrintSettingsAndPrepareFrame ( <NEW_LINE> WebKit::WebFrame * frame , <NEW_LINE> WebKit::WebNode * node ,
PairingDelegate * pairing_delegate_ ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>bool pairing_delegate_used_ ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>scoped_ptr < BluetoothAgentServiceProvider > agent_ ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>PinCodeCallback pincode_callback_ ; <NEW_LINE>PasskeyCallback passkey_callback_ ; <NEW_LINE>ConfirmationCallback confirmation_callback_ ; <NEW_LINE> <END_VULN>
#define PROGNAME "rpng2 - x" <NEW_LINE> #define LONGNAME "Progressive PNG Viewer for X" <NEW_LINE> <START_VULN> #define VERSION "2 . 03 of 25 February 2010" <NEW_LINE> <END_VULN> #define RESNAME "rpng2" <NEW_LINE> #define RESCLASS "Rpng"
parsedOptions . flipY ) ; <NEW_LINE> } else { <NEW_LINE> RefPtr < ArrayBuffer > dstBuffer = ArrayBuffer::createOrNull ( <NEW_LINE> <START_VULN> static_cast < size_t > ( parsedOptions . cropRect . height ( ) ) * <NEW_LINE> <END_VULN> parsedOptions . cropRect . width ( ) , <NEW_LINE> bytesPerPixel ) ; <NEW_LINE> if ( ! dstBuffer )
<START_VULN> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <NEW_LINE>vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <NEW_LINE>vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <NEW_LINE> <END_VULN> cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ;
PHPAPI char * xml_utf8_decode ( const XML_Char * s , int len , int * newlen , const XML_Char * encoding ) <NEW_LINE> { <NEW_LINE> <START_VULN> int pos = len ; <NEW_LINE> <END_VULN> char * newbuf = emalloc ( len + 1 ) ; <NEW_LINE> unsigned int c ; <NEW_LINE> char ( * decoder ) ( unsigned short ) = NULL ;
char * saved_ptr = NULL ; <NEW_LINE> intl_error_reset ( NULL TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "s" , <NEW_LINE> & loc_name , & loc_name_len ) == FAILURE ) <NEW_LINE> {
#ifndef NDEBUG <NEW_LINE> <START_VULN> class NonThreadSafe : public NonThreadSafeImpl { <NEW_LINE> <END_VULN> } ; <NEW_LINE> #else <NEW_LINE> class NonThreadSafe : public NonThreadSafeDoNothing {
namespace xpc { <NEW_LINE> class WrapperFactory { <NEW_LINE> public: <NEW_LINE> enum { WAIVE_XRAY_WRAPPER_FLAG = js::Wrapper::LAST_USED_FLAG << 1 , <NEW_LINE> IS_XRAY_WRAPPER_FLAG = WAIVE_XRAY_WRAPPER_FLAG << 1 , <NEW_LINE> SCRIPT_ACCESS_ONLY_FLAG = IS_XRAY_WRAPPER_FLAG << 1 , <NEW_LINE> PARTIALLY_TRANSPARENT = SCRIPT_ACCESS_ONLY_FLAG << 1 , <NEW_LINE> <START_VULN> SOW_FLAG = PARTIALLY_TRANSPARENT << 1 } ; <NEW_LINE> <END_VULN> static bool HasWrapperFlag ( JSObject * wrapper , unsigned flag ) { <NEW_LINE> unsigned flags = 0 ; <NEW_LINE> js::UnwrapObject ( wrapper , true , & flags ) ; <NEW_LINE> return ! ! ( flags & flag ) ; <NEW_LINE> }
snprintf ( buffer , buffersize , "NaN" ) ; <NEW_LINE> } else if ( number == 0 && xmlXPathGetSign ( number ) != 0 ) { <NEW_LINE> snprintf ( buffer , buffersize , "0" ) ; <NEW_LINE> <START_VULN> } else if ( number == ( ( int ) number ) ) { <NEW_LINE> <END_VULN> char work [ 30 ] ; <NEW_LINE> char * ptr , * cur ; <NEW_LINE> int value = ( int ) number ;
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> UpgradeSchemaFrom5To6 ( mozIStorageConnection * aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "UpgradeSchemaFrom5To6" ) ; <NEW_LINE> nsresult rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( <NEW_LINE> "DROP INDEX key_index ; " <NEW_LINE> ) ) ;
return SECFailure ; <NEW_LINE> } <NEW_LINE> return SECSuccess ; <NEW_LINE> } <NEW_LINE> static SECStatus <NEW_LINE> ValidateCert ( CERTCertDBHandle * handle , char * name , char * date , <NEW_LINE> <START_VULN> char * certUsage , PRBool checkSig , PRBool logit , secuPWData * pwdata ) <NEW_LINE> <END_VULN> { <NEW_LINE> SECStatus rv ; <NEW_LINE> CERTCertificate * cert = NULL ; <NEW_LINE> int64 timeBoundary ; <NEW_LINE> SECCertificateUsage usage ; <NEW_LINE> CERTVerifyLog reallog ; <NEW_LINE> CERTVerifyLog * log = NULL ;
Vector < uint8_t > data ; <NEW_LINE> IntRect sub_rect = source_image_rect ; <NEW_LINE> <START_VULN> if ( sub_rect == SentinelEmptyRect ( ) ) { <NEW_LINE> <END_VULN> sub_rect = SafeGetImageSize ( image ) ; <NEW_LINE> }
clearFailedLoadURL ( ) ; <NEW_LINE> } else if ( ! attr . isNull ( ) ) { <NEW_LINE> <START_VULN> <NEW_LINE>m_element -> dispatchEvent ( Event::create ( eventNames ( ) . errorEvent , false , false ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> CachedImage * oldImage = m_image . get ( ) ;
} <NEW_LINE> snprintf ( log_name , log_name_len , " / tmp / % s_mem . % d . log" , prog_name , getpid ( ) ) ; <NEW_LINE> <START_VULN> log_op = fopen ( log_name , "a" ) ; <NEW_LINE> <END_VULN> if ( log_op == NULL ) { <NEW_LINE> log_message ( LOG_INFO , "Unable to open % s for appending" , log_name ) ; <NEW_LINE> log_op = stderr ;
if ( png_ptr != NULL && info_ptr != NULL && <NEW_LINE> <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_debug1 ( 1 , "in % s retrieval function" , "cHRM" ) ;
if ( stack . top == 1 ) { <NEW_LINE> wddx_stack_top ( & stack , ( void ** ) & ent ) ; <NEW_LINE> <START_VULN> * return_value = * ( ent -> data ) ; <NEW_LINE>zval_copy_ctor ( return_value ) ; <NEW_LINE>retval = SUCCESS ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> retval = FAILURE ; <NEW_LINE> }
"only allowed for add and delete group modifications" ) ; <NEW_LINE> return OFPERR_OFPBPC_BAD_VALUE ; <NEW_LINE> default: <NEW_LINE> <START_VULN> OVS_NOT_REACHED ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( payload -> size < sizeof * prop ) {
for ( i = 0 ; i < B43_NR_FWTYPES ; i ++ ) { <NEW_LINE> errmsg = ctx -> errors [ i ] ; <NEW_LINE> if ( strlen ( errmsg ) ) <NEW_LINE> <START_VULN> b43err ( dev -> wl , errmsg ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> b43_print_fw_helptext ( dev -> wl , 1 ) ; <NEW_LINE> goto out ;
LayoutUnit lineBreak = lineBreakLength ( ) ; <NEW_LINE> for ( RenderBox * child = iterator . currentChild ( ) ; child ; child = iterator . next ( ) ) { <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> orderedChildren . append ( child ) ; <NEW_LINE> continue ; <NEW_LINE> }
return false ; <NEW_LINE> WeakMap * weakmap = fromJSObject ( obj ) ; <NEW_LINE> if ( weakmap ) { <NEW_LINE> <START_VULN> js::HashMap < JSObject * , Value > ::Ptr ptr = weakmap -> map . lookup ( key ) ; <NEW_LINE> <END_VULN> if ( ptr ) { <NEW_LINE> * vp = BooleanValue ( true ) ; <NEW_LINE> return true ;
#include " . / vpx_integer . h" <NEW_LINE> <START_VULN> #define VPX_MAXIMUM_WORK_BUFFERS 1 <NEW_LINE> <END_VULN>
nsXPConnect * xpc = nsXPConnect::GetXPConnect ( ) ; <NEW_LINE> if ( xpc ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE>JSObject * glob = JS_GetGlobalObject ( cx ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIXPConnectJSObjectHolder > holder ; <NEW_LINE> nsresult rv = xpc -> WrapNative ( cx , glob , e ,
} <NEW_LINE> } <NEW_LINE> <START_VULN> int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( Stream_GetRemainingLength ( s ) < 12 ) <NEW_LINE> return - 1 ;
saved_pos = strlen ( cur_loc_range ) ; <NEW_LINE> while ( saved_pos > 0 ) { <NEW_LINE> <START_VULN> for ( i = 0 ; i < cur_arr_len ; i ++ ) { <NEW_LINE>if ( cur_arr [ i * 2 ] != NULL && strlen ( cur_arr [ i * 2 ] ) == saved_pos && strncmp ( cur_loc_range , cur_arr [ i * 2 ] , saved_pos ) == 0 ) { <NEW_LINE> <END_VULN> return_value = estrdup ( canonicalize ? cur_arr [ i * 2 ] :cur_arr [ i * 2 + 1 ] ) ; <NEW_LINE> efree ( cur_loc_range ) ;
gss_ctx_id_t * context_handle , <NEW_LINE> gss_buffer_t output_token ) <NEW_LINE> { <NEW_LINE> <START_VULN> OM_uint32 major_status = GSS_S_COMPLETE ; <NEW_LINE> <END_VULN> if ( output_token != GSS_C_NO_BUFFER ) { <NEW_LINE> output_token -> length = 0 ;
NS_DECL_ISUPPORTS <NEW_LINE> NS_DECL_NSIWEBGLPROGRAM <NEW_LINE> protected: <NEW_LINE> WebGLuint mName ; <NEW_LINE> PRPackedBool mDeleted ; <NEW_LINE> PRPackedBool mDeletePending ; <NEW_LINE> PRPackedBool mLinkStatus ; <NEW_LINE> <START_VULN> nsTArray < WebGLShader * > mAttachedShaders ; <NEW_LINE> <END_VULN> CheckedUint32 mGeneration ; <NEW_LINE> nsRefPtrHashtable < nsUint32HashKey , WebGLUniformLocation > mMapUniformLocations ; <NEW_LINE> GLint mUniformMaxNameLength ; <NEW_LINE> GLint mAttribMaxNameLength ; <NEW_LINE> GLint mUniformCount ; <NEW_LINE> GLint mAttribCount ;
CVE_2013_1726_mar_read_product_info_block ( MarFile * mar , <NEW_LINE> struct ProductInformationBlock * infoBlock ) <NEW_LINE> { <NEW_LINE> <START_VULN> int i , hasAdditionalBlocks , offset , <NEW_LINE> <END_VULN> offsetAdditionalBlocks , numAdditionalBlocks , <NEW_LINE> additionalBlockSize , additionalBlockID ;
#ifdef PNG_READ_BACKGROUND_SUPPORTED <NEW_LINE> static int <NEW_LINE> image_transform_default_add ( image_transform * this , <NEW_LINE> <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE> <END_VULN> { <NEW_LINE> UNUSED ( colour_type ) <NEW_LINE> UNUSED ( bit_depth )
png_byte colour_type = 0 , bit_depth = 0 ; <NEW_LINE> unsigned int npalette = 0 ; <NEW_LINE> <START_VULN> while ( next_format ( & colour_type , & bit_depth , & npalette , 1 ) ) <NEW_LINE> <END_VULN> if ( ( colour_type & PNG_COLOR_MASK_ALPHA ) == 0 && <NEW_LINE> ( ( colour_type == 3 && sbit < 8 ) || <NEW_LINE> ( colour_type != 3 && sbit < bit_depth ) ) )
pack_mb_row_tokens ( cpi , & cpi -> bc [ 1 ] ) ; <NEW_LINE> else <NEW_LINE> #endif <NEW_LINE> <START_VULN> pack_tokens ( & cpi -> bc [ 1 ] , cpi -> tok , cpi -> tok_count ) ; <NEW_LINE> <END_VULN> vp8_stop_encode ( & cpi -> bc [ 1 ] ) ;
errmsg = "too many profiles" ; <NEW_LINE> <START_VULN> if ( ! finished ) <NEW_LINE> <END_VULN> png_crc_finish ( png_ptr , length ) ; <NEW_LINE> png_ptr -> colorspace . flags |= PNG_COLORSPACE_INVALID ;
stopSharedTimer ( ) ; <NEW_LINE> if ( intervalInMS == 0 ) <NEW_LINE> <START_VULN> sharedTimer = g_idle_add_full ( G_PRIORITY_DEFAULT , timeout_cb , NULL , NULL ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> sharedTimer = g_timeout_add_full ( G_PRIORITY_DEFAULT , intervalInMS , timeout_cb , NULL , NULL ) ; <NEW_LINE> }
<START_VULN> static const char * const cfg = " -- force - target = mips32 - android - gcc -- disable - runtime - cpu - detect -- sdk - path = / usr / local / google / home / hkuang / Downloads / android - ndk - r9d -- enable - dspr2 -- disable - examples -- disable - docs -- enable - realtime - only" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
LANG_ID_MAC_KOREAN = 23 , <NEW_LINE> LANG_ID_MAC_POLISH = 25 , <NEW_LINE> LANG_ID_MAC_FARSI = 31 , <NEW_LINE> LANG_ID_MAC_SIMP_CHINESE = 33 , <NEW_LINE> LANG_ID_MAC_ROMANIAN = 37 , <NEW_LINE> LANG_ID_MAC_CZECH = 38 , <NEW_LINE> LANG_ID_MAC_SLOVAK = 39 , <NEW_LINE> <START_VULN> LANG_ID_MICROSOFT_EN_US = 0x0409 <NEW_LINE> <END_VULN> } ; <NEW_LINE> struct NameHeader { <NEW_LINE> mozilla::AutoSwap_PRUint16 format ; <NEW_LINE> mozilla::AutoSwap_PRUint16 count ; <NEW_LINE> mozilla::AutoSwap_PRUint16 stringOffset ;
} <NEW_LINE> NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc ( nedpool * p , size_t no , size_t size ) THROWSPEC <NEW_LINE> { <NEW_LINE> <START_VULN> unsigned flags = NEDMALLOC_FORCERESERVE ( p , 0 , no * size ) ; <NEW_LINE>return nedpmalloc2 ( p , size * no , 0 , M2_ZERO_MEMORY | flags ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedprealloc ( nedpool * p , void * mem , size_t size ) THROWSPEC <NEW_LINE> {
signal ( SIGTERM , cleanup_handler ) ; <NEW_LINE> nalloc = 0 ; <NEW_LINE> <START_VULN> if ( pledge ( "stdio cpath unix id proc exec" , NULL ) == - 1 ) <NEW_LINE> <END_VULN> fatal ( " % s: pledge: % s" , __progname , strerror ( errno ) ) ; <NEW_LINE> while ( 1 ) {
if ( ! FixBitmapWidth ( reinterpret_cast < int8_t * > ( mBIHraw ) ) ) { <NEW_LINE> PostDataError ( ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! WriteToContainedDecoder ( mBIHraw , sizeof ( mBIHraw ) ) ) { <NEW_LINE> <END_VULN> return ; <NEW_LINE> } <NEW_LINE> PostSize ( mContainedDecoder -> GetImageMetadata ( ) . GetWidth ( ) , <NEW_LINE> mContainedDecoder -> GetImageMetadata ( ) . GetHeight ( ) ) ;
} <NEW_LINE> #endif <NEW_LINE> #ifdef ACCESSIBILITY <NEW_LINE> already_AddRefed < nsIAccessible > nsWindow::GetRootAccessible ( ) <NEW_LINE> { <NEW_LINE> nsWindow::sIsAccessibilityOn = TRUE ; <NEW_LINE> <START_VULN> if ( mIsDestroying || mOnDestroyCalled || mWindowType == eWindowType_invisible ) { <NEW_LINE> <END_VULN> return nsnull ; <NEW_LINE> } <NEW_LINE> nsIAccessible * rootAccessible = nsnull ;
case FILE_BEQLDATE: <NEW_LINE> case FILE_LEQLDATE: <NEW_LINE> if ( file_printf ( ms , F ( ms , m , " % s" ) , <NEW_LINE> <START_VULN> file_fmttime ( p -> q , 0 , tbuf ) ) == - 1 ) <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> t = ms -> offset + sizeof ( uint64_t ) ; <NEW_LINE> break ;
<START_VULN> class LogMessageVoidify { <NEW_LINE> <END_VULN> public: <NEW_LINE> LogMessageVoidify ( ) { }
removeActiveBuffer ( portIndex , buffer ) ; <NEW_LINE> <START_VULN> OMX_BUFFERHEADERTYPE * header = findBufferHeader ( buffer ) ; <NEW_LINE> <END_VULN> BufferMeta * buffer_meta = static_cast < BufferMeta * > ( header -> pAppPrivate ) ; <NEW_LINE> OMX_ERRORTYPE err = OMX_FreeBuffer ( mHandle , portIndex , header ) ;
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; <NEW_LINE> uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; <NEW_LINE> uint8_t * from = rowp + mGIFStruct . width ; <NEW_LINE> uint32_t * to = ( ( uint32_t * ) rowp ) + mGIFStruct . width ; <NEW_LINE> uint32_t * cmap = mColormap ; <NEW_LINE> <START_VULN> if ( mColorMask == 0xFF ) { <NEW_LINE>for ( uint32_t c = mGIFStruct . width ; c > 0 ; c -- ) { <NEW_LINE> * -- to = cmap [ * -- from ] ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE><NEW_LINE>uint8_t mask = mColorMask ; <NEW_LINE>for ( uint32_t c = mGIFStruct . width ; c > 0 ; c -- ) { <NEW_LINE> * -- to = cmap [ ( * -- from ) & mask ] ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> if ( mGIFStruct . is_transparent && ! mSawTransparency ) { <NEW_LINE> const uint32_t * rgb = ( uint32_t * ) rowp ; <NEW_LINE> for ( uint32_t i = mGIFStruct . width ; i > 0 ; i -- ) { <NEW_LINE> if ( * rgb ++ == 0 )
return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> QuotaManager::EnsureOriginIsInitialized ( const nsACString & aOrigin , <NEW_LINE> bool aTrackQuota , <NEW_LINE> nsIFile ** aDirectory ) <NEW_LINE> { <NEW_LINE> <START_VULN> #ifdef DEBUG <NEW_LINE> { <NEW_LINE>bool correctThread ; <NEW_LINE>NS_ASSERTION ( NS_SUCCEEDED ( mIOThread -> IsOnCurrentThread ( & correctThread ) ) && <NEW_LINE>correctThread , <NEW_LINE>"Running on the wrong thread ! " ) ; <NEW_LINE> } <NEW_LINE>#endif <NEW_LINE> <END_VULN> nsCOMPtr < nsIFile > directory ; <NEW_LINE> nsresult rv = GetDirectoryForOrigin ( aOrigin , getter_AddRefs ( directory ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> bool exists ; <NEW_LINE> rv = directory -> Exists ( & exists ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
nsCOMPtr < nsIDocument > document ; <NEW_LINE> if ( content ) { <NEW_LINE> <START_VULN> document = content -> GetDocument ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! document ) {
if ( ! data ) { <NEW_LINE> if ( _retval ) <NEW_LINE> * _retval = NULL ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> JSContext * cx = data -> GetJSContextStack ( ) -> Pop ( ) ; <NEW_LINE> if ( _retval ) <NEW_LINE> <START_VULN> * _retval = cx ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsXPConnect::Push ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> XPCPerThreadData * data = XPCPerThreadData::GetData ( cx ) ;
<START_VULN> <NEW_LINE> <END_VULN> if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || <NEW_LINE> ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ||
const void * data , size_t datalen ) <NEW_LINE> { <NEW_LINE> struct snmp_ctx * ctx = ( struct snmp_ctx * ) context ; <NEW_LINE> <START_VULN> __be32 * pdata = ( __be32 * ) data ; <NEW_LINE> <END_VULN> if ( * pdata == ctx -> from ) { <NEW_LINE> pr_debug ( " % s: % pI4 to % pI4\n" , __func__ , <NEW_LINE> ( void * ) & ctx -> from , ( void * ) & ctx -> to ) ;
GetLastError ( ) ) ) ; <NEW_LINE> } <NEW_LINE> return FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> WCHAR installDirUpdater [ MAX_PATH + 1 ] = { L'\0' } ; <NEW_LINE> <END_VULN> wcsncpy ( installDirUpdater , installDir , MAX_PATH ) ; <NEW_LINE> if ( ! PathAppendSafe ( installDirUpdater , L"updater . exe" ) ) { <NEW_LINE> LOG_WARN ( ( "Install directory updater could not be determined . " ) ) ; <NEW_LINE> result = FALSE ; <NEW_LINE> } <NEW_LINE> BOOL updaterIsCorrect ; <NEW_LINE> if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater ,
size += 16 ; <NEW_LINE> <START_VULN> if ( ! ( buf = g_try_malloc ( size ) ) ) { <NEW_LINE> <END_VULN> #ifdef DEBUG <NEW_LINE> g_assert_not_reached ( ) ; <NEW_LINE> #endif
current_element = object -> child ; <NEW_LINE> if ( case_sensitive ) <NEW_LINE> { <NEW_LINE> <START_VULN> while ( ( current_element != NULL ) && ( strcmp ( name , current_element -> string ) != 0 ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> current_element = current_element -> next ; <NEW_LINE> }
bool calledDebugEpilogue = false ; <NEW_LINE> HandleExceptionBaseline ( cx , iter , rfe , & calledDebugEpilogue ) ; <NEW_LINE> if ( rfe -> kind != ResumeFromException::RESUME_ENTRY_FRAME ) <NEW_LINE> return ; <NEW_LINE> JSScript * script = iter . script ( ) ; <NEW_LINE> <START_VULN> probes::ExitScript ( cx , script , script -> function ( ) , iter . baselineFrame ( ) ) ; <NEW_LINE> <END_VULN> iter . baselineFrame ( ) -> unsetPushedSPSFrame ( ) ; <NEW_LINE> if ( cx -> compartment ( ) -> debugMode ( ) && ! calledDebugEpilogue ) {
static void OnSSLCertificateError ( <NEW_LINE> <START_VULN> base::WeakPtr < SSLErrorHandler::Delegate > delegate , <NEW_LINE> <END_VULN> const content::GlobalRequestID & id , <NEW_LINE> ResourceType::Type resource_type , <NEW_LINE> const GURL & url ,
mDocument = nsnull ; <NEW_LINE> mDoc = nsnull ; <NEW_LINE> NS_ASSERTION ( ! mArguments , "mArguments wasn't cleaned up properly ! " ) ; <NEW_LINE> CleanUp ( PR_TRUE ) ; <NEW_LINE> <START_VULN> NS_ASSERTION ( ! mHasDeviceMotion , "Window still registered with device motion . " ) ; <NEW_LINE><NEW_LINE> <END_VULN> #ifdef DEBUG <NEW_LINE> nsCycleCollector_DEBUG_wasFreed ( static_cast < nsIScriptGlobalObject * > ( this ) ) ; <NEW_LINE> #endif <NEW_LINE> if ( mURLProperty ) { <NEW_LINE> mURLProperty -> ClearWindowReference ( ) ; <NEW_LINE> } <NEW_LINE> nsLayoutStatics::Release ( ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsGlobalWindow::ShutDown ( ) <NEW_LINE> { <NEW_LINE> NS_IF_RELEASE ( sGlobalStorageList ) ;
if ( status == MagickFalse ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , ( size_t ) level , <NEW_LINE>exception ) ; <NEW_LINE> <END_VULN> if ( q == ( PixelPacket * ) NULL ) <NEW_LINE> { <NEW_LINE> status = MagickFalse ;
#if USE_MAGIC_HEADERS <NEW_LINE> size_t _alignment = alignment ; <NEW_LINE> size_t * _ret = 0 ; <NEW_LINE> <START_VULN> size += alignment + 3 * sizeof ( size_t ) ; <END_VULN> <NEW_LINE> <NEW_LINE> <NEW_LINE> <NEW_LINE> <NEW_LINE> <NEW_LINE> _alignment = 0 ; <NEW_LINE> #endif <NEW_LINE> #if USE_ALLOCATOR == 0
int leftLimit = - 1 , rightLimit ; <NEW_LINE> int i , restoreAlphaBlending = 0 ; <NEW_LINE> <START_VULN> if ( border < 0 ) { <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
ref_costs_single [ INTRA_FRAME ] = vp9_cost_bit ( intra_inter_p , 0 ) ; <NEW_LINE> if ( cm -> reference_mode != COMPOUND_REFERENCE ) { <NEW_LINE> <START_VULN> vp9_prob ref_single_p1 = vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ; <NEW_LINE>vp9_prob ref_single_p2 = vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ; <NEW_LINE> <END_VULN> unsigned int base_cost = vp9_cost_bit ( intra_inter_p , 1 ) ; <NEW_LINE> if ( cm -> reference_mode == REFERENCE_MODE_SELECT )
png_const_bytep row = png_voidcast ( png_const_bytep , display -> buffer ) ; <NEW_LINE> ptrdiff_t row_bytes = display -> row_stride ; <NEW_LINE> <START_VULN> if ( linear ) <NEW_LINE> <END_VULN> row_bytes *= ( sizeof ( png_uint_16 ) ) ; <NEW_LINE> if ( row_bytes < 0 )
* <NEW_LINE> * <NEW_LINE> * <NEW_LINE> <START_VULN> void Write ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> void Finish ( RasterImage::eShutdownIntent aShutdownIntent ) ;
} <NEW_LINE> <START_VULN> if ( pread ( fd , xsh_addr , xsh_sizeof , off + size * strtab ) == - 1 ) { <NEW_LINE> <END_VULN> file_badread ( ms ) ; <NEW_LINE> return - 1 ; <NEW_LINE> }
} <NEW_LINE> JSContext * cx = scx ? scx -> GetNativeContext ( ) : nullptr ; <NEW_LINE> <START_VULN> return Push ( cx ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> nsCxPusher::RePush ( nsIDOMEventTarget * aCurrentTarget ) <NEW_LINE> { <NEW_LINE> if ( ! mPushedSomething ) { <NEW_LINE> return Push ( aCurrentTarget ) ; <NEW_LINE> }
class nsHttpHeaderArray <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> nsHttpHeaderArray ( ) { } <NEW_LINE> ~ nsHttpHeaderArray ( ) { Clear ( ) ; } <NEW_LINE> const char * PeekHeader ( nsHttpAtom header ) ; <NEW_LINE> <START_VULN> nsresult SetHeader ( nsHttpAtom header , const nsACString & value , PRBool merge = PR_FALSE ) ; <NEW_LINE> <END_VULN> nsresult GetHeader ( nsHttpAtom header , nsACString & value ) ; <NEW_LINE> void ClearHeader ( nsHttpAtom h ) ; <NEW_LINE> const char * FindHeaderValue ( nsHttpAtom header , const char * value ) { <NEW_LINE> return nsHttp::FindToken ( PeekHeader ( header ) , value , <NEW_LINE> HTTP_HEADER_VALUE_SEPS ) ; <NEW_LINE> }
gfxCtx -> NewPath ( ) ; <NEW_LINE> gfxPoint p [ ] = { <NEW_LINE> rect . TopRight ( ) , <NEW_LINE> rect . TopRight ( ) + gfxPoint ( - w - . 4 * h , std::max ( - e / 2 . 0 , h - . 4 * w ) ) , <NEW_LINE> rect . TopRight ( ) + gfxPoint ( - . 7 * w , . 7 * h ) , <NEW_LINE> rect . TopRight ( ) + gfxPoint ( std::min ( e / 2 . 0 , - w + . 4 * h ) , h + . 4 * w ) , <NEW_LINE> rect . TopRight ( ) <NEW_LINE> } ; <NEW_LINE> <START_VULN> gfxCtx -> Polygon ( p , sizeof ( p ) ) ; <NEW_LINE> <END_VULN> gfxCtx -> Fill ( ) ; <NEW_LINE> } <NEW_LINE> break ; <NEW_LINE> default: <NEW_LINE> NS_NOTREACHED ( "This notation can not be drawn using nsDisplayNotation" ) ; <NEW_LINE> break ; <NEW_LINE> }
#if 0 <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " [ | truncated ] " ) ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> #endif
if ( frame_timecode < last_cluster_timecode ) <NEW_LINE> <START_VULN> return - 1 ; <NEW_LINE> <END_VULN>
} <NEW_LINE> Catch ( fault ) <NEW_LINE> <START_VULN> ps = fault ; <NEW_LINE> <END_VULN> #undef exception__prev <NEW_LINE> #undef exception__env
return ret ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> free ( ptr ) ; <NEW_LINE> }
nsCOMPtr < nsPIDOMEventTarget > mChromeEventHandler ; <NEW_LINE> nsCOMPtr < nsIDOMDocument > mDocument ; <NEW_LINE> <START_VULN> nsIDOMElement * mFrameElement ; <NEW_LINE> <END_VULN> nsIDocShell * mDocShell ; <NEW_LINE> PRUint32 mModalStateDepth ; <NEW_LINE> nsTimeout * mRunningTimeout ; <NEW_LINE> PRUint32 mMutationBits ;
" the following codes . Notice that the results for each file are combined" , <NEW_LINE> " together - check one file at a time to get a meaningful error code ! " , <NEW_LINE> " 0x01: The zlib too - far - back error existed in at least one chunk . " , <NEW_LINE> <START_VULN> " 0x02: At least once chunk had a CRC error . " , <NEW_LINE> <END_VULN> " 0x04: A chunk length was incorrect . " , <NEW_LINE> " 0x08: The file was truncated . " , <NEW_LINE> " Errors less than 16 are potentially recoverable , for a single file if the" ,
number_planes , <NEW_LINE> number_planes_filled , <NEW_LINE> one , <NEW_LINE> <START_VULN> offset , <NEW_LINE> <END_VULN> pixel_info_length ; <NEW_LINE> ssize_t <NEW_LINE> count , <NEW_LINE> y ; <NEW_LINE> unsigned char
const std::vector < uint8_t > & data ) ; <NEW_LINE> <START_VULN> const int instance_id_ ; <NEW_LINE> <END_VULN> scoped_refptr < base::SingleThreadTaskRunner > thread_runner_ ;
case PKT_REC_PACKET: <NEW_LINE> if ( ( printer = lookup_printer ( dlt ) ) != NULL ) { <NEW_LINE> <START_VULN> hdrlen += printer ( ndo , h , p ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> if ( ! ndo -> ndo_eflag ) <NEW_LINE> pktap_header_print ( ndo , ( const u_char * ) hdr ,
int ret ; <NEW_LINE> char buff [ MAXPATHLEN ] ; <NEW_LINE> zend_error_handling error_handling ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
Value <NEW_LINE> StackIter::calleev ( ) const <NEW_LINE> { <NEW_LINE> switch ( state_ ) { <NEW_LINE> case DONE: <NEW_LINE> break ; <NEW_LINE> case SCRIPTED: <NEW_LINE> JS_ASSERT ( isFunctionFrame ( ) ) ; <NEW_LINE> <START_VULN> return fp ( ) -> calleev ( ) ; <NEW_LINE> <END_VULN> case ION: <NEW_LINE> #ifdef JS_ION <NEW_LINE> return ObjectValue ( * callee ( ) ) ; <NEW_LINE> #else <NEW_LINE> break ; <NEW_LINE> #endif <NEW_LINE> case NATIVE: <NEW_LINE> return nativeArgs ( ) . calleev ( ) ;
RenderObject * previousObject = 0 ; <NEW_LINE> for ( BidiRun * r = firstRun ; r ; r = r -> next ( ) ) { <NEW_LINE> <START_VULN> if ( ! r -> m_box || r -> m_object -> isPositioned ( ) || r -> m_box -> isLineBreak ( ) ) <NEW_LINE> <END_VULN> continue ;
const TOKENEXTRA * stop = cpi -> tplist [ mb_row ] . stop ; <NEW_LINE> int tokens = ( int ) ( stop - p ) ; <NEW_LINE> <START_VULN> vp8_pack_tokens_c ( w , p , tokens ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> vp8_stop_encode ( w ) ;
compact_pixels = ( unsigned char * ) NULL ; <NEW_LINE> if ( next_image -> compression == RLECompression ) <NEW_LINE> { <NEW_LINE> <START_VULN> compact_pixels = AcquireCompactPixels ( image ) ; <NEW_LINE> <END_VULN> if ( compact_pixels == ( unsigned char * ) NULL ) <NEW_LINE> return ( 0 ) ; <NEW_LINE> }
goto badCharacter ; <NEW_LINE> } <NEW_LINE> v = Utf8ToOneUcs4Char ( ( uint8 * ) src , n ) ; <NEW_LINE> <START_VULN> if ( v >= 0x10000 && ! useCESU8 ) { <NEW_LINE> <END_VULN> v - = 0x10000 ; <NEW_LINE> if ( v > 0xFFFFF || dstlen < 2 ) { <NEW_LINE> * dstlenp = ( origDstlen - dstlen ) ;
mse [ 1 ] , mse [ 2 ] , mse [ 3 ] ) ; <NEW_LINE> bytes_total += si -> bytes_sum [ i ] ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> si -> bytes_sum [ i ] = 0 ; <NEW_LINE> for ( j = 0 ; j < COMPONENTS ; ++ j ) { <NEW_LINE> si -> psnr_sum [ i ] [ j ] = 0 ;
} <NEW_LINE> size_t frameSize = getFrameSize ( mode ) ; <NEW_LINE> <START_VULN> CHECK_GE ( inHeader -> nFilledLen , frameSize ) ; <NEW_LINE> <END_VULN> int16_t * outPtr = ( int16_t * ) outHeader -> pBuffer ;
PHP_FUNCTION ( mcrypt_module_is_block_algorithm_mode ) <NEW_LINE> { <NEW_LINE> MCRYPT_GET_MODE_DIR_ARGS ( modes_dir ) <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( mcrypt_module_is_block_algorithm_mode ( module , dir ) == 1 ) { <NEW_LINE> RETURN_TRUE ; <NEW_LINE> } else {
@param join String to use as the element join string . <NEW_LINE> @return String consisting of the joined hash keys <NEW_LINE> @ingroup MprHash <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC char * mprHashKeysToString ( MprHash * hash , cchar * join ) ;
if ( ps_cur_slice -> u1_nal_ref_idc != 0 ) <NEW_LINE> { <NEW_LINE> if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) <NEW_LINE> <START_VULN> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> WebGLContext::GetError ( WebGLenum * _retval ) <NEW_LINE> { <NEW_LINE> MakeContextCurrent ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>WebGLenum err = gl -> GetAndClearError ( ) ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( mWebGLError != LOCAL_GL_NO_ERROR ) { <NEW_LINE>err = mWebGLError ; <NEW_LINE>mWebGLError = LOCAL_GL_NO_ERROR ; <NEW_LINE> } <NEW_LINE><NEW_LINE> * _retval = err ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> WebGLContext::GetProgramParameter ( nsIWebGLProgram * pobj , PRUint32 pname , nsIVariant ** retval ) <NEW_LINE> { <NEW_LINE> * retval = nsnull ;
static char error_string [ 64 ] ; <NEW_LINE> DWORD error_code = GetLastError ( ) ; <NEW_LINE> <START_VULN> if ( ( error_code >> 16 ) != 0x8009 ) <NEW_LINE> <END_VULN> return WindowsErrorString ( ) ; <NEW_LINE> switch ( error_code ) {
static void Create ( <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> PlatformSensorProvider * provider , <NEW_LINE> std::unique_ptr < PlatformSensorFusionAlgorithm > fusion_algorithm , <NEW_LINE> const PlatformSensorProviderBase::CreateSensorCallback & callback ) ;
#endif <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsContinuingTextFrame::Destroy ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> ClearTextRun ( ) ; <NEW_LINE>if ( mPrevContinuation || mNextContinuation ) { <NEW_LINE>nsSplittableFrame::RemoveFromFlow ( this ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> nsFrame::Destroy ( ) ; <NEW_LINE> } <NEW_LINE> nsIFrame * <NEW_LINE> nsContinuingTextFrame::GetFirstInFlow ( ) const <NEW_LINE> {
blue_y ; <NEW_LINE> if ( png_get_cHRM ( read_ptr , read_info_ptr , & white_x , & white_y , & red_x , <NEW_LINE> <START_VULN> & red_y , & green_x , & green_y , & blue_x , & blue_y ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_set_cHRM ( write_ptr , write_info_ptr , white_x , white_y , red_x , <NEW_LINE> red_y , green_x , green_y , blue_x , blue_y ) ;
const size_t buflen = static_cast < size_t > ( size ) ; <NEW_LINE> if ( buflen ) { <NEW_LINE> <START_VULN> typedef unsigned char * buf_t ; <NEW_LINE><NEW_LINE>const buf_t buf = new ( std::nothrow ) unsigned char [ buflen ] ; <NEW_LINE> <END_VULN> if ( buf == NULL ) <NEW_LINE> return - 1 ;
} <NEW_LINE> mozStorageTransaction transaction ( mDBState -> dbConn , PR_TRUE ) ; <NEW_LINE> nsDependentCString cookieHeader ( aCookieHeader ) ; <NEW_LINE> <START_VULN> while ( SetCookieInternal ( aHostURI , aChannel , cookieHeader , serverTime , aFromHttp ) ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsCookieService::NotifyRejected ( nsIURI * aHostURI ) <NEW_LINE> {
} <NEW_LINE> nsRefPtr < nsGlobalWindow > newInnerWindow ; <NEW_LINE> bool createdInnerWindow = false ; <NEW_LINE> bool thisChrome = IsChromeWindow ( ) ; <NEW_LINE> nsCxPusher cxPusher ; <NEW_LINE> <START_VULN> if ( ! cxPusher . Push ( cx ) ) { <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> <END_VULN> XPCAutoRequest ar ( cx ) ; <NEW_LINE> nsCOMPtr < WindowStateHolder > wsh = do_QueryInterface ( aState ) ; <NEW_LINE> NS_ASSERTION ( ! aState || wsh , "What kind of weird state are you giving me here ? " ) ; <NEW_LINE> if ( reUseInnerWindow ) {
SPL_METHOD ( FilesystemIterator , key ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
if ( renderer ( ) -> style ( ) -> hasBorderRadius ( ) ) <NEW_LINE> newOverflowClip . setHasRadius ( true ) ; <NEW_LINE> clipRects . setOverflowClipRect ( intersection ( newOverflowClip , clipRects . overflowClipRect ( ) ) ) ; <NEW_LINE> <START_VULN> if ( renderer ( ) -> isPositioned ( ) || renderer ( ) -> isRelPositioned ( ) ) <NEW_LINE> <END_VULN> clipRects . setPosClipRect ( intersection ( newOverflowClip , clipRects . posClipRect ( ) ) ) ; <NEW_LINE> } <NEW_LINE> if ( renderer ( ) -> hasClip ( ) ) {
HDC mMemoryDC ; <NEW_LINE> nsTransparencyMode mTransparencyMode ; <NEW_LINE> #endif <NEW_LINE> PRPackedBool mIsTopWidgetWindow ; <NEW_LINE> PRPackedBool mHas3DBorder ; <NEW_LINE> PRPackedBool mIsShiftDown ; <NEW_LINE> PRPackedBool mIsControlDown ; <NEW_LINE> PRPackedBool mIsAltDown ; <NEW_LINE> <START_VULN> PRPackedBool mIsDestroying ; <NEW_LINE> <END_VULN> PRPackedBool mIsVisible ; <NEW_LINE> PRPackedBool mIsInMouseCapture ; <NEW_LINE> PRPackedBool mIsInMouseWheelProcessing ; <NEW_LINE> PRPackedBool mUnicodeWidget ; <NEW_LINE> PRPackedBool mIsPluginWindow ; <NEW_LINE> PRPackedBool mPainting ; <NEW_LINE> char mLeadByte ;
{ <NEW_LINE> int pixel_depth = pixel_depth_of_type ( color_type , bit_depth ) ; <NEW_LINE> <START_VULN> if ( pixel_depth < 8 ) <NEW_LINE> <END_VULN> return 64 ; <NEW_LINE> else if ( pixel_depth > 16 )
} <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::iterate ( JSContext * cx , JSObject * wrapper , unsigned flags , Value * vp ) <NEW_LINE> { <NEW_LINE> PIERCE ( cx , wrapper , GET , <NEW_LINE> NOTHING , <NEW_LINE> DirectWrapper::iterate ( cx , wrapper , flags , vp ) , <NEW_LINE> <START_VULN> CanReify ( vp ) ? Reify ( cx , call . origin , vp ) : call . origin -> wrap ( cx , vp ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::call ( JSContext * cx , JSObject * wrapper_ , unsigned argc , Value * vp ) <NEW_LINE> { <NEW_LINE> RootedObject wrapper ( cx , wrapper_ ) ; <NEW_LINE> AutoCompartment call ( cx , wrappedObject ( wrapper ) ) ;
#include "vpx / vpx_codec . h" <NEW_LINE> <START_VULN> static const char * const cfg = " -- target = x86 - linux - gcc -- disable - sse4_1 -- disable - avx -- disable - avx2 -- as = yasm -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
p_chk -> common . i_chunk_fourcc == AVIFOURCC_ON2 || <NEW_LINE> p_chk -> common . i_chunk_fourcc == AVIFOURCC_LIST ) <NEW_LINE> { <NEW_LINE> <START_VULN> sprintf ( str + i_level * 5 , <NEW_LINE> <END_VULN> " % c % 4 . 4s - % 4 . 4s size: % "PRIu64" pos: % "PRIu64 , <NEW_LINE> i_level ? ' + ' : ' * ' , <NEW_LINE> ( char * ) & p_chk -> common . i_chunk_fourcc ,
static void spl_filesystem_dir_it_rewind ( zend_object_iterator * iter TSRMLS_DC ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * object = spl_filesystem_iterator_to_object ( ( spl_filesystem_iterator * ) iter ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> object -> u . dir . index = 0 ; <NEW_LINE> if ( object -> u . dir . dirp ) { <NEW_LINE> php_stream_rewinddir ( object -> u . dir . dirp ) ;
~ PlatformSensorProviderLinux ( ) override ; <NEW_LINE> void CreateSensorInternal ( mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> const CreateSensorCallback & callback ) override ; <NEW_LINE> void FreeResources ( ) override ;
CHECK_MEM_ERROR ( cpi -> active_map , <NEW_LINE> vpx_calloc ( cm -> mb_rows * cm -> mb_cols , <NEW_LINE> sizeof ( * cpi -> active_map ) ) ) ; <NEW_LINE> <START_VULN> vpx_memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <NEW_LINE> <END_VULN> #if CONFIG_MULTITHREAD <NEW_LINE> if ( width < 640 )
read_mv_probs ( nmvc , cm -> allow_high_precision_mv , & r ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> return vp9_reader_has_error ( & r ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>void vp9_init_dequantizer ( VP9_COMMON * cm ) { <NEW_LINE>int q ; <NEW_LINE><NEW_LINE>for ( q = 0 ; q < QINDEX_RANGE ; q ++ ) { <NEW_LINE>cm -> y_dequant [ q ] [ 0 ] = vp9_dc_quant ( q , cm -> y_dc_delta_q ) ; <NEW_LINE>cm -> y_dequant [ q ] [ 1 ] = vp9_ac_quant ( q , 0 ) ; <NEW_LINE><NEW_LINE>cm -> uv_dequant [ q ] [ 0 ] = vp9_dc_quant ( q , cm -> uv_dc_delta_q ) ; <NEW_LINE>cm -> uv_dequant [ q ] [ 1 ] = vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef NDEBUG
#include "nsTArray . h" <NEW_LINE> #include "imgFrame . h" <NEW_LINE> #include "nsThreadUtils . h" <NEW_LINE> #include "DecodeStrategy . h" <NEW_LINE> #include "DiscardTracker . h" <NEW_LINE> #include "Orientation . h" <NEW_LINE> #include "nsIObserver . h" <NEW_LINE> #include "mozilla / MemoryReporting . h" <NEW_LINE> #include "mozilla / TimeStamp . h" <NEW_LINE> #include "mozilla / StaticPtr . h" <NEW_LINE> #include "mozilla / WeakPtr . h" <NEW_LINE> <START_VULN> #include "mozilla / Mutex . h" <NEW_LINE> <END_VULN> #ifdef DEBUG <NEW_LINE> #include "imgIContainerDebug . h" <NEW_LINE> #endif <NEW_LINE> class nsIInputStream ; <NEW_LINE> class nsIThreadPool ; <NEW_LINE> class nsIRequest ;
} ; <NEW_LINE> <START_VULN> static void <NEW_LINE> <END_VULN> vpx_usec_timer_start ( struct vpx_usec_timer * t ) { <NEW_LINE> #if defined ( _WIN32 ) <NEW_LINE> QueryPerformanceCounter ( & t -> begin ) ;
for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) <NEW_LINE> { <NEW_LINE> <START_VULN> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <NEW_LINE>Min ( 4 , dds_info -> height - y ) , exception ) ; <NEW_LINE> <END_VULN> if ( q == ( PixelPacket * ) NULL ) <NEW_LINE> return MagickFalse ;
Client * client_ = nullptr ; <NEW_LINE> const PreserveDrawingBuffer preserve_drawing_buffer_ ; <NEW_LINE> <START_VULN> const WebGLVersion web_gl_version_ ; <NEW_LINE> <END_VULN> std::unique_ptr < WebGraphicsContext3DProviderWrapper > context_provider_ ;
hasAttribute ( requiredAttr ) ) <NEW_LINE> return toHTMLFormControlElement ( n ) -> isRequired ( ) ; <NEW_LINE> <START_VULN> if ( equalIgnoringCase ( getAttribute ( aria_requiredAttr ) , "true" ) ) <NEW_LINE> <END_VULN> return true ; <NEW_LINE> return false ;
bool shouldDelay ; <NEW_LINE> <START_VULN> switch ( fileHeader . speedFrac & 3 ) <NEW_LINE> <END_VULN> { <NEW_LINE> default: shouldDelay = false ; break ;
q = p ; <NEW_LINE> <START_VULN> if ( ! vct_iscrlf ( * p ) ) { <NEW_LINE>for ( ; ! vct_iscrlf ( * p ) ; p ++ ) <NEW_LINE> <END_VULN> if ( ! vct_issep ( * p ) && vct_isctl ( * p ) ) <NEW_LINE> return ( 400 ) ; <NEW_LINE> }
#ifdef PNG_iCCP_SUPPORTED <NEW_LINE> <START_VULN> if ( ( mask & PNG_FREE_ICCP ) & info_ptr -> free_me ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_free ( png_ptr , info_ptr -> iccp_name ) ; <NEW_LINE> png_free ( png_ptr , info_ptr -> iccp_profile ) ;
{ <NEW_LINE> unsigned stage1_idx = ENT_STAGE1_INDEX ( k ) ; <NEW_LINE> const entity_stage3_row * c ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( stage1_idx > 0x1D ) { <NEW_LINE> * entity = NULL ; <NEW_LINE> * entity_len = 0 ;
return PR_TRUE ; <NEW_LINE> } <NEW_LINE> PRBool <NEW_LINE> CSSParserImpl::ParsePageRule ( RuleAppendFunc aAppendFunc , void * aData ) <NEW_LINE> { <NEW_LINE> <START_VULN> return PR_FALSE ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> CSSParserImpl::SkipUntil ( PRUnichar aStopSymbol ) <NEW_LINE> { <NEW_LINE> nsCSSToken * tk = & mToken ; <NEW_LINE> nsAutoTArray < PRUnichar , 16 > stack ; <NEW_LINE> stack . AppendElement ( aStopSymbol ) ;
( ::JS_GetStringChars ( mExpr ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsresult NS_CreateJSTimeoutHandler ( nsIScriptContext * aContext , <NEW_LINE> <END_VULN> PRBool * aIsInterval , <NEW_LINE> PRInt32 * aInterval , <NEW_LINE> nsIScriptTimeoutHandler ** aRet )
nsresult rv ; <NEW_LINE> nsAutoCString uriSpec ; <NEW_LINE> aBindingDocURI -> GetSpec ( uriSpec ) ; <NEW_LINE> <START_VULN> JSContext * cx = aContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( ! ::JS_IsExceptionPending ( cx ) , <NEW_LINE> "Shouldn't get here when an exception is pending ! " ) ; <NEW_LINE> nsCOMPtr < nsIScriptContext > context = aContext ; <NEW_LINE> JSAutoRequest ar ( cx ) ;
return rv ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsLocation::Replace ( const nsAString & aUrl ) <NEW_LINE> { <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>nsCOMPtr < nsIJSContextStack > <NEW_LINE>stack ( do_GetService ( "@mozilla . org / js / xpc / ContextStack ; 1" ) ) ; <NEW_LINE><NEW_LINE>if ( stack ) { <NEW_LINE>JSContext * cx ; <NEW_LINE><NEW_LINE>rv = GetContextFromStack ( stack , & cx ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE>if ( cx ) { <NEW_LINE>return SetHrefWithContext ( cx , aUrl , true ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> nsAutoString oldHref ; <NEW_LINE> rv = GetHref ( oldHref ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsCOMPtr < nsIURI > oldUri ;
remote ( ) -> transact ( CONFIGURE_VIDEO_TUNNEL_MODE , data , & reply ) ; <NEW_LINE> status_t err = reply . readInt32 ( ) ; <NEW_LINE> <START_VULN> if ( sidebandHandle ) { <NEW_LINE> <END_VULN> * sidebandHandle = ( native_handle_t * ) reply . readNativeHandle ( ) ; <NEW_LINE> } <NEW_LINE> return err ;
<START_VULN> #ifndef CHROME_RENDERER_DEVTOOLS_AGENT_H_ <NEW_LINE>#define CHROME_RENDERER_DEVTOOLS_AGENT_H_ <NEW_LINE> <END_VULN> #pragma once <NEW_LINE> #include < map >
} <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> outerpc -> blockidGen = funpc . blockidGen ; <NEW_LINE> parser -> tokenStream . tell ( & position ) ; <NEW_LINE> <START_VULN> tokenStream . seek ( position , parser -> tokenStream ) ; <NEW_LINE> <END_VULN> pn -> pn_pos . end = tokenStream . currentToken ( ) . pos . end ; <NEW_LINE> } <NEW_LINE> if ( ! addFreeVariablesFromLazyFunction ( fun , pc ) ) <NEW_LINE> return false ;
#define RETURN ( xxx ) { param -> res = xxx ; goto CLEANRET ; } <NEW_LINE> <START_VULN> #define LINESIZE 2048 <NEW_LINE> <END_VULN> extern FILE * writable ; <NEW_LINE> FILE * confopen ( ) ;
nsComboboxControlFrame::DestroyFrom ( nsIFrame * aDestructRoot ) <NEW_LINE> { <NEW_LINE> mRedisplayTextEvent . Revoke ( ) ; <NEW_LINE> nsFormControlFrame::RegUnRegAccessKey ( static_cast < nsIFrame * > ( this ) , false ) ; <NEW_LINE> if ( mDroppedDown ) { <NEW_LINE> <START_VULN> <NEW_LINE>nsIFrame * listFrame = do_QueryFrame ( mListControlFrame ) ; <NEW_LINE>if ( listFrame ) { <NEW_LINE>nsIView * view = listFrame -> GetView ( ) ; <NEW_LINE>NS_ASSERTION ( view , "nsComboboxControlFrame view is null" ) ; <NEW_LINE>if ( view ) { <NEW_LINE>nsIWidget * widget = view -> GetWidget ( ) ; <NEW_LINE>if ( widget ) <NEW_LINE>widget -> CaptureRollupEvents ( this , false , true ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> mPopupFrames . DestroyFramesFrom ( aDestructRoot ) ; <NEW_LINE> nsContentUtils::DestroyAnonymousContent ( & mDisplayContent ) ; <NEW_LINE> nsContentUtils::DestroyAnonymousContent ( & mButtonContent ) ; <NEW_LINE> nsBlockFrame::DestroyFrom ( aDestructRoot ) ;
if ( newbest ) { <NEW_LINE> best_rd = rd ; <NEW_LINE> <START_VULN> * best_filter = mbmi -> interp_filter ; <NEW_LINE> <END_VULN> if ( cm -> interp_filter == SWITCHABLE && i && ! intpel_mv ) <NEW_LINE> best_needs_copy = ! best_needs_copy ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsPlaintextEditor::PasteTransferable ( nsITransferable * aTransferable ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! FireClipboardEvent ( NS_PASTE ) ) <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> if ( ! IsModifiable ( ) ) <NEW_LINE> return NS_OK ; <NEW_LINE> nsCOMPtr < nsIDOMDocument > domdoc = GetDOMDocument ( ) ; <NEW_LINE> if ( ! nsEditorHookUtils::DoInsertionHook ( domdoc , nullptr , aTransferable ) )
EP_CHECK_CANARY ( ( "before dissecting frame % d" , fd -> num ) ) ; <NEW_LINE> TRY { <NEW_LINE> <START_VULN> edt -> tvb = tvb_new_real_data ( pd , fd -> cap_len , fd -> pkt_len ) ; <NEW_LINE> <END_VULN> add_new_data_source ( & edt -> pi , edt -> tvb , "Frame" ) ;
static const struct net_offload ipip_offload = { <NEW_LINE> . callbacks = { <NEW_LINE> . gso_segment = inet_gso_segment , <NEW_LINE> <START_VULN> . gro_receive = inet_gro_receive , <NEW_LINE> <END_VULN> . gro_complete = ipip_gro_complete , <NEW_LINE> } , <NEW_LINE> } ;
forward = sjoin ( forward , def , NULL ) ; <NEW_LINE> for ( i = 0 ; i < fieldCount ; i ++ ) { <NEW_LINE> <START_VULN> field = stok ( sclone ( fields [ i ] ) , ":" , & typeString ) ; <NEW_LINE> <END_VULN> if ( ( type = ediParseTypeString ( typeString ) ) < 0 ) { <NEW_LINE> fail ( "Unknown type ' % s' for field ' % s'" , typeString , field ) ; <NEW_LINE> return ;
ColorSpace color_space , <NEW_LINE> bool has_alpha ) override ; <NEW_LINE> bool IsOffscreen ( ) override ; <NEW_LINE> <START_VULN> gfx::SwapResult SwapBuffers ( PresentationCallback callback ) override ; <NEW_LINE>void SwapBuffersAsync ( SwapCompletionCallback completion_callback , <NEW_LINE>PresentationCallback presentation_callback ) override ; <NEW_LINE>gfx::SwapResult CommitOverlayPlanes ( PresentationCallback callback ) override ; <NEW_LINE>void CommitOverlayPlanesAsync ( <NEW_LINE>SwapCompletionCallback completion_callback , <NEW_LINE>PresentationCallback presentation_callback ) override ; <NEW_LINE> <END_VULN> gfx::Size GetSize ( ) override ; <NEW_LINE> bool OnMakeCurrent ( GLContext * context ) override ; <NEW_LINE> bool ScheduleOverlayPlane ( int z_order ,
distortion2 += distortion ; <NEW_LINE> if ( cm -> interp_filter == SWITCHABLE ) <NEW_LINE> <START_VULN> rate2 += vp9_get_switchable_rate ( x ) ; <NEW_LINE> <END_VULN> if ( ! mode_excluded ) <NEW_LINE> mode_excluded = comp_pred ? cm -> reference_mode == SINGLE_REFERENCE
, mQueriedProgressSink ( PR_TRUE ) <NEW_LINE> , mSynthProgressEvents ( PR_FALSE ) <NEW_LINE> , mWasOpened ( PR_FALSE ) <NEW_LINE> { <NEW_LINE> mContentType . AssignLiteral ( UNKNOWN_CONTENT_TYPE ) ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> <START_VULN> nsBaseChannel::Redirect ( nsIChannel * newChannel , PRUint32 redirectFlags ) <NEW_LINE> <END_VULN> { <NEW_LINE> SUSPEND_PUMP_FOR_SCOPE ( ) ; <NEW_LINE> newChannel -> SetOriginalURI ( OriginalURI ( ) ) ; <NEW_LINE> newChannel -> SetLoadGroup ( mLoadGroup ) ; <NEW_LINE> newChannel -> SetNotificationCallbacks ( mCallbacks ) ;
#define INDEX_LEN 2 <NEW_LINE> #define INDEX_HI ( i ) ( ( jsbytecode ) ( ( i ) >> 8 ) ) <NEW_LINE> #define INDEX_LO ( i ) ( ( jsbytecode ) ( i ) ) <NEW_LINE> #define GET_INDEX ( pc ) GET_UINT16 ( pc ) <NEW_LINE> #define SET_INDEX ( pc , i ) ( ( pc ) [ 1 ] = INDEX_HI ( i ) , ( pc ) [ 2 ] = INDEX_LO ( i ) ) <NEW_LINE> <START_VULN> #define GET_INDEXBASE ( pc ) ( JS_ASSERT ( * ( pc ) == JSOP_INDEXBASE ) , \ <NEW_LINE> <END_VULN> ( ( uintN ) ( ( pc ) [ 1 ] ) ) << 16 ) <NEW_LINE> #define INDEXBASE_LEN 1 <NEW_LINE> #define UINT24_HI ( i ) ( ( jsbytecode ) ( ( i ) >> 16 ) ) <NEW_LINE> #define UINT24_MID ( i ) ( ( jsbytecode ) ( ( i ) >> 8 ) ) <NEW_LINE> #define UINT24_LO ( i ) ( ( jsbytecode ) ( i ) ) <NEW_LINE> #define GET_UINT24 ( pc ) ( ( jsatomid ) ( ( ( pc ) [ 1 ] << 16 ) | \ <NEW_LINE> ( ( pc ) [ 2 ]
void mdct_clear ( mdct_lookup * l ) { <NEW_LINE> if ( l ) { <NEW_LINE> if ( l -> trig ) _ogg_free ( l -> trig ) ; <NEW_LINE> if ( l -> bitrev ) _ogg_free ( l -> bitrev ) ; <NEW_LINE> memset ( l , 0 , sizeof ( * l ) ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> STIN void mdct_bitreverse ( mdct_lookup * init , <NEW_LINE> <END_VULN> DATA_TYPE * x ) { <NEW_LINE> int n = init -> n ; <NEW_LINE> int * bit = init -> bitrev ; <NEW_LINE> DATA_TYPE * w0 = x ; <NEW_LINE> DATA_TYPE * w1 = x = w0 + ( n >> 1 ) ; <NEW_LINE> DATA_TYPE * T = init -> trig + n ; <NEW_LINE> do {
<START_VULN> #define EXTRACT_LE_8BITS ( p ) ( * ( p ) ) <NEW_LINE> <END_VULN> #define EXTRACT_LE_16BITS ( p ) \ <NEW_LINE> ( ( uint16_t ) ( ( ( uint16_t ) ( * ( ( const uint8_t * ) ( p ) + 1 ) ) << 8 ) | \ <NEW_LINE> ( ( uint16_t ) ( * ( ( const uint8_t * ) ( p ) + 0 ) ) << 0 ) ) )
return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> JSJavaThreadState * jsj_env = NULL ; <NEW_LINE> JSObjectHandle * handle = ( JSObjectHandle * ) obj ; <NEW_LINE> JSObject * js_obj = handle -> js_obj ; <NEW_LINE> JSContext * cx = NULL ; <NEW_LINE> jsval js_val ; <NEW_LINE> JSErrorReporter saved_state = NULL ; <NEW_LINE> jsj_env = jsj_enter_js ( jEnv , mJavaClient , NULL , & cx , NULL , & saved_state , principalsArray , numPrincipals , securitySupports ) ; <NEW_LINE> if ( ! jsj_env ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> <START_VULN> AutoPushJSContext autopush ( securitySupports , cx ) ; <NEW_LINE>if ( NS_FAILED ( autopush . ResultOfPush ( ) ) ) <NEW_LINE>goto done ; <NEW_LINE><NEW_LINE> <END_VULN> if ( ! jsj_ConvertJavaObjectToJSValue ( cx , jEnv , java_obj , & js_val ) ) <NEW_LINE> goto done ; <NEW_LINE> JS_SetElement ( cx , js_obj , slot , & js_val ) ; <NEW_LINE> done: <NEW_LINE> jsj_exit_js ( cx , jsj_env , saved_state ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
mState = LIST_DIRTY ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>mElements . RemoveElement ( aContent ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
* aResult = nsnull ; <NEW_LINE> nsSVGScriptElement * it = new nsSVGScriptElement ( aNodeInfo ) ; <NEW_LINE> if ( ! it ) { <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsINode > kungFuDeathGrip = it ; <NEW_LINE> <START_VULN> nsresult rv = CopyInnerTo ( it ) ; <NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> it -> mIsEvaluated = mIsEvaluated ; <NEW_LINE> it -> mLineNumber = mLineNumber ; <NEW_LINE> it -> mMalformed = mMalformed ; <NEW_LINE> kungFuDeathGrip . swap ( * aResult ) ;
ale = cg -> upvarList . add ( cg -> parser , atom ) ; <NEW_LINE> if ( ! ale ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> <START_VULN> if ( ! vector ) { <NEW_LINE>uint32 length = cg -> lexdeps . count ; <NEW_LINE><NEW_LINE>vector = ( UpvarCookie * ) js_calloc ( length * sizeof * vector ) ; <NEW_LINE> <END_VULN> if ( ! vector ) { <NEW_LINE> JS_ReportOutOfMemory ( cx ) ; <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> cg -> upvarMap . vector = vector ; <NEW_LINE> cg -> upvarMap . length = length ; <NEW_LINE> }
if ( ( ! ( aVisitor . mEvent -> flags & NS_EVENT_FLAG_NO_CONTENT_DISPATCH ) || <NEW_LINE> item -> ForceContentDispatch ( ) ) && <NEW_LINE> ! ( aVisitor . mEvent -> flags & NS_EVENT_FLAG_STOP_DISPATCH ) ) { <NEW_LINE> item -> HandleEvent ( aVisitor , aFlags & NS_EVENT_BUBBLE_MASK , <NEW_LINE> createdELMs != nsEventListenerManager::sCreatedCount , <NEW_LINE> aPusher ) ; <NEW_LINE> } <NEW_LINE> if ( aFlags & NS_EVENT_FLAG_SYSTEM_EVENT ) { <NEW_LINE> <START_VULN> item -> PostHandleEvent ( aVisitor ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> item = item -> mParent ; <NEW_LINE> } <NEW_LINE> aVisitor . mEvent -> flags &= ~ NS_EVENT_FLAG_BUBBLE ; <NEW_LINE> if ( ! ( aFlags & NS_EVENT_FLAG_SYSTEM_EVENT ) ) {
RUN_CALLBACK ( LIBRAW_PROGRESS_DARK_FRAME , 1 , 2 ) ; <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> <START_VULN> #line 10142 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> #ifndef NO_LCMS <NEW_LINE> void CLASS apply_profile ( const char * input , const char * output ) <NEW_LINE> {
return FALSE ; <NEW_LINE> } <NEW_LINE> sock_cmd_t cmd = { CMD_EXIT , 0 , 0 , 0 , 0 } ; <NEW_LINE> <START_VULN> if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> pthread_join ( ts [ h ] . thread_id , 0 ) ; <NEW_LINE> pthread_mutex_lock ( & thread_slot_lock ) ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . methodWithCallbackArg" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> if ( args . Length ( ) <= 0 || ! args [ 0 ] -> IsFunction ( ) ) <NEW_LINE> return throwError ( TYPE_MISMATCH_ERR , args . GetIsolate ( ) ) ;
} <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> RETURN_FALSE ; <NEW_LINE> }
return ClipPaintPropertyNode::Create ( parent , std::move ( state ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> inline scoped_refptr < TransformPaintPropertyNode > CreateTransform ( <NEW_LINE>scoped_refptr < const TransformPaintPropertyNode > parent , <NEW_LINE> <END_VULN> const TransformationMatrix & matrix , <NEW_LINE> const FloatPoint3D & origin = FloatPoint3D ( ) , <NEW_LINE> CompositingReasons compositing_reasons = CompositingReason::kNone ) {
ProxyJNIEnv & proxyEnv = GetProxyEnv ( env ) ; <NEW_LINE> nsISecureEnv * secureEnv = GetSecureEnv ( env ) ; <NEW_LINE> nsISecurityContext * securityContext = proxyEnv . getContext ( ) ; <NEW_LINE> <START_VULN> nsresult rv = secureEnv -> CallNonvirtualMethod ( method -> mReturnType , obj , clazz , method -> mMethodID , args , & outValue , securityContext ) ; <NEW_LINE> <END_VULN> NS_IF_RELEASE ( securityContext ) ; <NEW_LINE> return NS_SUCCEEDED ( rv ) ? outValue : kErrorValue ; <NEW_LINE> }
} <NEW_LINE> case PHP_MODE_REFLECTION_EXT_INFO: <NEW_LINE> { <NEW_LINE> <START_VULN> int len = ( int ) strlen ( reflection_what ) ; <NEW_LINE> <END_VULN> char * lcname = zend_str_tolower_dup ( reflection_what , len ) ; <NEW_LINE> zend_module_entry * module ;
} <NEW_LINE> probe::willSendRequest ( GetFrame ( ) -> GetDocument ( ) , identifier , <NEW_LINE> MasterDocumentLoader ( ) , request , redirect_response , <NEW_LINE> <START_VULN> initiator_info ) ; <NEW_LINE> <END_VULN> if ( IdlenessDetector * idleness_detector = GetFrame ( ) -> GetIdlenessDetector ( ) ) <NEW_LINE> idleness_detector -> OnWillSendRequest ( ) ; <NEW_LINE> if ( GetFrame ( ) -> FrameScheduler ( ) )
png_debug1 ( 1 , "in % s storage function" , "tIME" ) ; <NEW_LINE> if ( png_ptr == NULL || info_ptr == NULL || mod_time == NULL || <NEW_LINE> <START_VULN> ( png_ptr -> mode & PNG_WROTE_tIME ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> if ( mod_time -> month == 0 || mod_time -> month > 12 ||
* <NEW_LINE> <START_VULN> if ( ! do_local_compose && do_local_background != 2 ) <NEW_LINE> <END_VULN> passes = png_set_interlace_handling ( png_ptr ) ; <NEW_LINE> png_read_update_info ( png_ptr , info_ptr ) ;
read_sequnlock_excl ( & mount_lock ) ; <NEW_LINE> } <NEW_LINE> hlist_add_head ( & child -> mnt_hash , list ) ; <NEW_LINE> <START_VULN> return 0 ; <NEW_LINE> <END_VULN> }
encryption -> signature_len = buflen ; <NEW_LINE> } else if ( id == 0x7E4 ) { <NEW_LINE> <START_VULN> delete [ ] encryption -> sig_key_id ; <NEW_LINE> <END_VULN> encryption -> sig_key_id = NULL ; <NEW_LINE> encryption -> sig_key_id_len = 0 ;
virtual void appendElement ( StringBuilder & , Element * , Namespaces * ) ; <NEW_LINE> void appendOpenTag ( StringBuilder & , Element * , Namespaces * ) ; <NEW_LINE> void appendCloseTag ( StringBuilder & , Element * ) ; <NEW_LINE> <START_VULN> virtual void appendAttribute ( StringBuilder & , Element * , const Attribute & , Namespaces * ) ; <NEW_LINE> <END_VULN> void appendCDATASection ( StringBuilder & , const String & ) ; <NEW_LINE> void appendStartMarkup ( StringBuilder & , const Node * , Namespaces * ) ; <NEW_LINE> bool shouldSelfClose ( const Node * ) ;
beforeChildParent = flow ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( newChild -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> return beforeChildParent -> addChildIgnoringContinuation ( newChild , beforeChild ) ;
png_free ( png_ptr , png_ptr -> big_row_buf ) ; <NEW_LINE> png_free ( png_ptr , png_ptr -> big_prev_row ) ; <NEW_LINE> <START_VULN> if ( png_ptr -> interlaced ) <NEW_LINE> <END_VULN> png_ptr -> big_row_buf = ( png_bytep ) png_calloc ( png_ptr , <NEW_LINE> row_bytes + 48 ) ;
return ; <NEW_LINE> local = date_msecFromDate ( YearFromTime ( local ) , <NEW_LINE> MonthFromTime ( local ) , <NEW_LINE> date , <NEW_LINE> HourFromTime ( local ) , <NEW_LINE> MinFromTime ( local ) , <NEW_LINE> SecFromTime ( local ) , <NEW_LINE> msFromTime ( local ) ) ; <NEW_LINE> <START_VULN> SetUTCTime ( cx , obj , NULL , UTC ( local ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_FRIEND_API ( void ) <NEW_LINE> js_DateSetHours ( JSContext * cx , JSObject * obj , int hours ) <NEW_LINE> { <NEW_LINE> jsdouble local ; <NEW_LINE> if ( ! GetAndCacheLocalTime ( cx , obj , NULL , & local ) ) <NEW_LINE> return ;
<START_VULN> #ifndef BASE_MEMORY_PRESSURE_LISTENER_H_ <NEW_LINE>#define BASE_MEMORY_PRESSURE_LISTENER_H_ <NEW_LINE> <END_VULN> #include "base / base_export . h" <NEW_LINE> #include "base / basictypes . h"
uint32_t lineIndexToNum ( uint32_t lineIndex ) const { return lineIndex + initialLineNum_ ; } <NEW_LINE> uint32_t lineNumToIndex ( uint32_t lineNum ) const { return lineNum - initialLineNum_ ; } <NEW_LINE> public: <NEW_LINE> SourceCoords ( JSContext * cx , uint32_t ln ) ; <NEW_LINE> void add ( uint32_t lineNum , uint32_t lineStartOffset ) ; <NEW_LINE> <START_VULN> void fill ( const SourceCoords & other ) ; <NEW_LINE> <END_VULN> bool isOnThisLine ( uint32_t offset , uint32_t lineNum ) const { <NEW_LINE> uint32_t lineIndex = lineNumToIndex ( lineNum ) ; <NEW_LINE> JS_ASSERT ( lineIndex + 1 < lineStartOffsets_ . length ( ) ) ; <NEW_LINE> return lineStartOffsets_ [ lineIndex ] <= offset && <NEW_LINE> offset < lineStartOffsets_ [ lineIndex + 1 ] ; <NEW_LINE> }
virtual bool HasAcceleratedSurface ( const gfx::Size & desired_size ) OVERRIDE ; <NEW_LINE> virtual void AcceleratedSurfaceNew ( int32 width_in_pixel , <NEW_LINE> int32 height_in_pixel , <NEW_LINE> <START_VULN> uint64 surface_id ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual void SetHasHorizontalScrollbar ( <NEW_LINE> bool has_horizontal_scrollbar ) OVERRIDE ; <NEW_LINE> virtual void SetScrollOffsetPinning (
, 5 , 3 , 0 , <NEW_LINE> 2 , 1 , 1 , 1 , 1 , 1 , 3 , 4 , 4 , 0 , <NEW_LINE> 1 , 1 , 3 , 1 , 1 , 1 , 1 , 3 , 3 , 1 , <NEW_LINE> <START_VULN> 3 , 3 , 0 , 0 , 11 , 0 , 9 , 3 , 2 , 0 , <NEW_LINE>4 , 0 , 4 , 3 , 3 , 3 , 3 , 3 , 3 , 1 , <NEW_LINE>3 , 3 , 1 , 5 , 1 , 3 , 0 , 4 , 1 , 1 , <NEW_LINE>3 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , 4 , <NEW_LINE>1 , 1 , 1 , 1 , 4 , 1 , 4 , 1 , 1 , 2 , <NEW_LINE>3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 2 , 3 , <NEW_LINE>3 , 1 <NEW_LINE> <END_VULN> } ;
struct perf_event * event , <NEW_LINE> struct pt_regs * regs ) ; <NEW_LINE> <START_VULN> extern int perf_event_overflow ( struct perf_event * event , int nmi , <NEW_LINE> <END_VULN> struct perf_sample_data * data , <NEW_LINE> struct pt_regs * regs ) ;
zend_throw_exception_ex ( spl_ce_DomainException , 0 TSRMLS_CC , "Maximum line length must be greater than or equal zero" ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> intern -> u . file . max_line_len = max_len ; <NEW_LINE> }
#ifndef _V_LOOKUP_H_ <NEW_LINE> #ifdef FLOAT_LOOKUP <NEW_LINE> extern float vorbis_coslook ( float a ) ; <NEW_LINE> extern float vorbis_invsqlook ( float a ) ; <NEW_LINE> extern float vorbis_invsq2explook ( int a ) ; <NEW_LINE> extern float vorbis_fromdBlook ( float a ) ; <NEW_LINE> #endif <NEW_LINE> #ifdef INT_LOOKUP <NEW_LINE> extern long vorbis_invsqlook_i ( long a , long e ) ; <NEW_LINE> extern long vorbis_coslook_i ( long a ) ; <NEW_LINE> extern float vorbis_fromdBlook_i ( long a ) ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #endif
friend class FileManager ; <NEW_LINE> public: <NEW_LINE> FileInfo ( FileManager * aFileManager ) <NEW_LINE> : mFileManager ( aFileManager ) <NEW_LINE> { } <NEW_LINE> virtual ~ FileInfo ( ) <NEW_LINE> <START_VULN> { <NEW_LINE>#ifdef DEBUG <NEW_LINE>NS_ASSERTION ( NS_IsMainThread ( ) , "File info destroyed on wrong thread ! " ) ; <NEW_LINE>#endif <NEW_LINE> } <NEW_LINE> <END_VULN> static <NEW_LINE> FileInfo * Create ( FileManager * aFileManager , int64_t aId ) ; <NEW_LINE> void AddRef ( ) <NEW_LINE> { <NEW_LINE> if ( IndexedDatabaseManager::IsClosed ( ) ) { <NEW_LINE> NS_AtomicIncrementRefcnt ( mRefCnt ) ;
void * params = NULL ; <NEW_LINE> size_t pageSize = 0 ; <NEW_LINE> size_t allocSize = 0 ; <NEW_LINE> <START_VULN> if ( code != SET_INTERNAL_OPTION && size < 8 ) { <NEW_LINE> <END_VULN> ALOGE ( "b / 27207275 ( % zu ) " , size ) ;
JS_BEGIN_EXTERN_C <NEW_LINE> extern JSClass js_MathClass ; <NEW_LINE> extern JSObject * <NEW_LINE> js_InitMathClass ( JSContext * cx , JSObject * obj ) ; <NEW_LINE> extern void <NEW_LINE> <START_VULN> js_InitRandom ( JSThreadData * data ) ; <NEW_LINE> <END_VULN> extern JSBool <NEW_LINE> js_math_ceil ( JSContext * cx , uintN argc , jsval * vp ) ; <NEW_LINE> extern JSBool <NEW_LINE> js_math_floor ( JSContext * cx , uintN argc , jsval * vp ) ; <NEW_LINE> extern JSBool
{ <NEW_LINE> png_debug1 ( 1 , "in % s retrieval function" , "iCCP" ) ; <NEW_LINE> <START_VULN> if ( png_ptr != NULL && info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_iCCP ) <NEW_LINE> && name != NULL && compression_type != NULL && profile != NULL && <NEW_LINE>proflen != NULL ) <NEW_LINE> <END_VULN> { <NEW_LINE> * name = info_ptr -> iccp_name ; <NEW_LINE> * profile = info_ptr -> iccp_profile ;
nsresult <NEW_LINE> CVE_2011_3000_nsHttpHeaderArray::SetHeader ( nsHttpAtom header , <NEW_LINE> const nsACString & value , <NEW_LINE> <START_VULN> PRBool merge ) <NEW_LINE> <END_VULN> { <NEW_LINE> nsEntry * entry = nsnull ; <NEW_LINE> PRInt32 index ;
static String HHVM_FUNCTION ( bcadd , const String & left , const String & right , <NEW_LINE> int64_t scale ) { <NEW_LINE> <START_VULN> if ( scale < 0 ) scale = BCG ( bc_precision ) ; <NEW_LINE> <END_VULN> bc_num first , second , result ; <NEW_LINE> bc_init_num ( & first ) ; <NEW_LINE> bc_init_num ( & second ) ;
return ; <NEW_LINE> local = date_msecFromDate ( YearFromTime ( local ) , <NEW_LINE> month , <NEW_LINE> DateFromTime ( local ) , <NEW_LINE> HourFromTime ( local ) , <NEW_LINE> MinFromTime ( local ) , <NEW_LINE> SecFromTime ( local ) , <NEW_LINE> msFromTime ( local ) ) ; <NEW_LINE> <START_VULN> SetUTCTime ( cx , obj , NULL , UTC ( local ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_FRIEND_API ( void ) <NEW_LINE> js_DateSetDate ( JSContext * cx , JSObject * obj , int date ) <NEW_LINE> { <NEW_LINE> jsdouble local ; <NEW_LINE> if ( ! GetAndCacheLocalTime ( cx , obj , NULL , & local ) ) <NEW_LINE> return ;
smart_str_free ( & tmp1 ) ; <NEW_LINE> smart_str_free ( & tmp2 ) ; <NEW_LINE> php_info_print_table_end ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> DISPLAY_INI_ENTRIES ( ) ; <NEW_LINE> }
if ( src -> interpolation_id == GD_BILINEAR_FIXED || src -> interpolation_id == GD_BICUBIC_FIXED || src -> interpolation_id == GD_NEAREST_NEIGHBOUR ) { <NEW_LINE> interpolation_id_bak = src -> interpolation_id ; <NEW_LINE> interpolation_bak = src -> interpolation ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> gdImageSetInterpolationMethod ( src , GD_BICUBIC ) ; <NEW_LINE> }
if ( ! data ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> delete [ ] frame_ ; <NEW_LINE> <END_VULN> frame_ = data ; <NEW_LINE> length_ = length ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: PCM data vector blocking , windowing and dis / reassembly <NEW_LINE> <START_VULN> last mod: $ Id: block . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> Handle windowing , overlap - add , etc of the PCM vectors . This is made <NEW_LINE> more amusing by Vorbis' current two allowed block sizes . <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < stdlib . h >
void fCompileShader ( GLuint shader ) { <NEW_LINE> BEFORE_GL_CALL ; <NEW_LINE> mSymbols . fCompileShader ( shader ) ; <NEW_LINE> AFTER_GL_CALL ; <NEW_LINE> } <NEW_LINE> void raw_fCopyTexImage2D ( GLenum target , GLint level , GLenum internalformat , GLint x , GLint y , GLsizei width , GLsizei height , GLint border ) { <NEW_LINE> BEFORE_GL_CALL ; <NEW_LINE> <START_VULN> mSymbols . fCopyTexImage2D ( target , level , internalformat , <NEW_LINE>x , FixYValue ( y , height ) , <NEW_LINE>width , height , border ) ; <NEW_LINE> <END_VULN> AFTER_GL_CALL ; <NEW_LINE> } <NEW_LINE> void raw_fCopyTexSubImage2D ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLint x , GLint y , GLsizei width , GLsizei height ) { <NEW_LINE> BEFORE_GL_CALL ; <NEW_LINE> mSymbols . fCopyTexSubImage2D ( target , level , xoffset , yoffset , <NEW_LINE> x , FixYValue ( y , height ) , <NEW_LINE> width , height ) ;
nsresult <NEW_LINE> RasterImage::DecodePool::DecodeSomeOfImage ( RasterImage * aImg , <NEW_LINE> DecodeStrategy aStrategy , <NEW_LINE> DecodeType aDecodeType , <NEW_LINE> uint32_t bytesToDecode ) <NEW_LINE> { <NEW_LINE> NS_ABORT_IF_FALSE ( aImg -> mInitialized , <NEW_LINE> "Worker active for uninitialized container ! " ) ; <NEW_LINE> <START_VULN> aImg -> mDecodingMutex . AssertCurrentThreadOwns ( ) ; <NEW_LINE> <END_VULN> if ( aImg -> mError ) <NEW_LINE> return NS_OK ;
<START_VULN> if ( isRoot ( ) || isBody ( ) || ( isPositioned ( ) && style ( ) -> position ( ) == FixedPosition ) ) <NEW_LINE> <END_VULN> return 0 ;
for ( int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK ; i > 0 ; i -- , to ++ ) { <NEW_LINE> JSBool marked = to -> IsMarked ( ) ; <NEW_LINE> to -> Unmark ( ) ; <NEW_LINE> if ( marked ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> if ( ! to -> GetJSObject ( ) ) { <NEW_LINE> <END_VULN> nsISupports * obj = to -> GetNative ( ) ; <NEW_LINE> if ( obj ) { <NEW_LINE> obj -> Release ( ) ; <NEW_LINE> to -> SetNative ( nsnull ) ; <NEW_LINE> } <NEW_LINE> to -> SetInterface ( nsnull ) ; <NEW_LINE> } <NEW_LINE> }
int dst_pitch <NEW_LINE> ) <NEW_LINE> { <NEW_LINE> <START_VULN> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , FData2 , 4 * 9 ) ; <NEW_LINE> <END_VULN> if ( xoffset ) <NEW_LINE> {
const bool bcached = <NEW_LINE> <START_VULN> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <NEW_LINE> <END_VULN> ctx -> hdrs [ i ] -> old = false ; <NEW_LINE> ctx -> hdrs [ i ] -> read = false ; <NEW_LINE> if ( hcached )
ALOGV_IF ( mIsFirst , "insufficient data for first frame , sending silence" ) ; <NEW_LINE> <START_VULN> memset ( outHeader -> pBuffer , <NEW_LINE>0 , <NEW_LINE>mConfig -> outputFrameSize * sizeof ( int16_t ) ) ; <NEW_LINE> <END_VULN> if ( inHeader ) { <NEW_LINE> mConfig -> inputBufferUsedLength = inHeader -> nFilledLen ;
else if ( eobs [ 0 ] == 1 ) <NEW_LINE> { <NEW_LINE> vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( eobs [ 1 ] > 1 )
static int pgx_gethdr ( jas_stream_t * in , pgx_hdr_t * hdr ) <NEW_LINE> { <NEW_LINE> int c ; <NEW_LINE> <START_VULN> uchar buf [ 2 ] ; <NEW_LINE> <END_VULN> if ( ( c = jas_stream_getc ( in ) ) == EOF ) { <NEW_LINE> goto error ;
if ( hexadecimal && ( ** buf != '\0' ) ) <NEW_LINE> ( * buf ) ++ ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ( hexadecimal && ! isxdigit ( ** buf ) ) ||
default: <NEW_LINE> { <NEW_LINE> NS_WARNING ( "Don't know how to adopt this nodetype for adoptNode . " ) ; <NEW_LINE> return NS_ERROR_DOM_NOT_SUPPORTED_ERR ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> nsIDocument * oldDocument = adoptedNode -> OwnerDoc ( ) ; <NEW_LINE> <END_VULN> bool sameDocument = oldDocument == this ; <NEW_LINE> JSContext * cx = nsnull ; <NEW_LINE> JSObject * newScope = nsnull ; <NEW_LINE> if ( ! sameDocument ) { <NEW_LINE> rv = GetContextAndScope ( oldDocument , this , & cx , & newScope ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> }
error = PutImageData_explicit ( JS_DoubleToInt32 ( dx ) , JS_DoubleToInt32 ( dy ) , <NEW_LINE> imageData . Width ( ) , imageData . Height ( ) , <NEW_LINE> <START_VULN> arr . Data ( ) , arr . Length ( ) , true , <NEW_LINE> <END_VULN> JS_DoubleToInt32 ( dirtyX ) , <NEW_LINE> JS_DoubleToInt32 ( dirtyY ) , <NEW_LINE> JS_DoubleToInt32 ( dirtyWidth ) ,
int ret ; <NEW_LINE> perf_event_header__init_id ( & read_event . header , & sample , event ) ; <NEW_LINE> <START_VULN> ret = perf_output_begin ( & handle , event , read_event . header . size , 0 , 0 ) ; <NEW_LINE> <END_VULN> if ( ret ) <NEW_LINE> return ;
inflateEnd ( strm ) ; <NEW_LINE> g_free ( strm ) ; <NEW_LINE> g_free ( strmbuf ) ; <NEW_LINE> <START_VULN> g_free ( compr ) ; <NEW_LINE> <END_VULN> if ( uncompr == NULL ) { <NEW_LINE> return NULL ; <NEW_LINE> }
bool AssociateForeignSpecifics ( const sync_pb::SessionSpecifics & specifics , <NEW_LINE> <START_VULN> const base::Time & modification_time ) ; <NEW_LINE> <END_VULN> void DisassociateForeignSession ( const std::string & foreign_session_tag ) ;
} <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> SECKEY_DestroyPublicKey ( pubKey ) ; <NEW_LINE> pubKey = NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> ss -> ssl3 . hs . ws = wait_cert_request ; <NEW_LINE>if ( ss -> ssl3 . hs . kea_def -> is_limited || <NEW_LINE><NEW_LINE>#ifndef NSS_DISABLE_ECC <NEW_LINE>ss -> ssl3 . hs . kea_def -> kea == kea_ecdhe_ecdsa || <NEW_LINE>ss -> ssl3 . hs . kea_def -> kea == kea_ecdhe_rsa || <NEW_LINE>#endif <NEW_LINE>ss -> ssl3 . hs . kea_def -> exchKeyType == kt_dh ) { <NEW_LINE>ss -> ssl3 . hs . ws = wait_server_key ; <NEW_LINE> } <NEW_LINE> <END_VULN> } else { <NEW_LINE> ss -> ssl3 . hs . ws = wait_client_key ; <NEW_LINE> } <NEW_LINE> PORT_Assert ( rv == SECSuccess ) ; <NEW_LINE> if ( rv != SECSuccess ) { <NEW_LINE> errCode = SEC_ERROR_LIBRARY_FAILURE ; <NEW_LINE> rv = SECFailure ;
if ( xpc::IsUniversalXPConnectEnabled ( cx ) ) { <NEW_LINE> perm = PermitPropertyAccess ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> return Deny ( cx , id , act ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
#ifndef COMPONENTS_DOM_DISTILLER_CONTENT_BROWSER_DISTILLER_JAVASCRIPT_SERVICE_IMPL_H_ <NEW_LINE> #define COMPONENTS_DOM_DISTILLER_CONTENT_BROWSER_DISTILLER_JAVASCRIPT_SERVICE_IMPL_H_ <NEW_LINE> <START_VULN> #include "components / dom_distiller / content / browser / external_feedback_reporter . h" <NEW_LINE> <END_VULN> #include "components / dom_distiller / content / common / distiller_javascript_service . mojom . h" <NEW_LINE> #include "third_party / mojo / src / mojo / public / cpp / bindings / string . h" <NEW_LINE> #include "third_party / mojo / src / mojo / public / cpp / bindings / strong_binding . h"
{ <NEW_LINE> JSTestInterfaceConstructor * castedThis = jsCast < JSTestInterfaceConstructor * > ( exec -> callee ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> const String & str1 ( ustringToString ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . isEmpty ( ) ? UString ( ) : MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . toString ( exec ) -> value ( exec ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) )
const base::string16 & object_store_name ) ; <NEW_LINE> std::unique_ptr < Storage::Frontend > frontend_ ; <NEW_LINE> <START_VULN> RenderProcessHost * process_ ; <NEW_LINE> <END_VULN> std::unique_ptr < CacheStorageObserver > cache_storage_observer_ ; <NEW_LINE> std::unique_ptr < IndexedDBObserver > indexed_db_observer_ ;
( rd -> distortion2 - rd -> distortion_uv ) ) ; <NEW_LINE> best_mode -> rd = this_rd ; <NEW_LINE> <START_VULN> vpx_memcpy ( & best_mode -> mbmode , & x -> e_mbd . mode_info_context -> mbmi , sizeof ( MB_MODE_INFO ) ) ; <NEW_LINE>vpx_memcpy ( & best_mode -> partition , x -> partition_info , sizeof ( PARTITION_INFO ) ) ; <NEW_LINE> <END_VULN> if ( ( this_mode == B_PRED ) || ( this_mode == SPLITMV ) ) <NEW_LINE> {
* b += diff ; <NEW_LINE> * avail - = diff ; <NEW_LINE> tested = len ; <NEW_LINE> <START_VULN> len = get_line_size ( * b , * avail , nl ) ; <NEW_LINE> <END_VULN> if ( len >= 0 ) <NEW_LINE> len += tested ; <NEW_LINE> }
} <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> <START_VULN> option = stok ( option , " = \t , " , & ovalue ) ; <NEW_LINE> <END_VULN> ovalue = strim ( ovalue , "\"'" , MPR_TRIM_BOTH ) ; <NEW_LINE> if ( ( int ) isdigit ( ( uchar ) * option ) ) { <NEW_LINE> lifespan = httpGetTicks ( option ) ;
screen -> columns = ( size_t ) GetDeviceCaps ( hDC , HORZRES ) ; <NEW_LINE> screen -> rows = ( size_t ) GetDeviceCaps ( hDC , VERTRES ) ; <NEW_LINE> screen -> storage_class = DirectClass ; <NEW_LINE> status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ; <NEW_LINE> if ( status == MagickFalse ) <NEW_LINE> { <NEW_LINE> InheritException ( exception , & image -> exception ) ; <NEW_LINE> return ( DestroyImageList ( image ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( image == ( Image * ) NULL ) <NEW_LINE>image = screen ; <NEW_LINE>else <NEW_LINE>AppendImageToList ( & image , screen ) ; <NEW_LINE> <END_VULN> bitmapDC = CreateCompatibleDC ( hDC ) ; <NEW_LINE> if ( bitmapDC == ( HDC ) NULL )
if ( name ) <NEW_LINE> { <NEW_LINE> <START_VULN> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <NEW_LINE> <END_VULN> sprintf ( dst_name , " % s / % s" , name , name ) ; <NEW_LINE> if ( ( c = strrchr ( dst_name , ' . ' ) ) && ( strncmp ( c , " . pdf" , 4 ) == 0 ) )
#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED <NEW_LINE> <START_VULN> if ( png_ptr -> transformations ) <NEW_LINE> <END_VULN> png_do_write_transformations ( png_ptr , & row_info ) ; <NEW_LINE> #endif
if ( r == 0 ) { <NEW_LINE> num_records = oggplay_callback_info_prepare ( me , & info ) ; <NEW_LINE> for ( i = 0 ; i < me -> num_tracks ; i ++ ) { <NEW_LINE> me -> decode_data [ i ] -> active = 0 ; <NEW_LINE> <START_VULN> me -> active_tracks = 0 ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( info != NULL ) { <NEW_LINE> me -> callback ( me , num_records , info , me -> callback_user_ptr ) ; <NEW_LINE> oggplay_callback_info_destroy ( me , info ) ; <NEW_LINE> } <NEW_LINE> decoder -> stream_info = OGGPLAY_STREAM_UNINITIALISED ;
OpenSSL_add_all_algorithms ( ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> while ( ( ch = getopt ( ac , av , "cDdksE:a:t:" ) ) != - 1 ) { <NEW_LINE> <END_VULN> switch ( ch ) { <NEW_LINE> case 'E': <NEW_LINE> fingerprint_hash = ssh_digest_alg_by_name ( optarg ) ;
pStorage -> activePps = pStorage -> pps [ ppsId ] ; <NEW_LINE> pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; <NEW_LINE> pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; <NEW_LINE> <START_VULN> pStorage -> picSizeInMbs = <NEW_LINE>pStorage -> activeSps -> picWidthInMbs * <NEW_LINE>pStorage -> activeSps -> picHeightInMbs ; <NEW_LINE> <END_VULN> pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; <NEW_LINE> pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ;
{ <NEW_LINE> return 2 ; <NEW_LINE> } <NEW_LINE> <START_VULN> mpz_powm ( b , b , key -> e , key -> n ) ; <NEW_LINE> <END_VULN> mpz_mul ( v , v , b ) ; <NEW_LINE> mpz_mod ( v , v , key -> n ) ; <NEW_LINE> return 0 ;
if ( ! ie1 && ! ie2 ) <NEW_LINE> return 0 ; <NEW_LINE> <START_VULN> if ( ! ie1 ) <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> r = memcmp ( ie1 + 2 , ie2 + 2 , min ( ie1 [ 1 ] , ie2 [ 1 ] ) ) ;
} <NEW_LINE> #define mem_get_sse_aligned_generic ( end , sz ) \ <NEW_LINE> <START_VULN> static signed MEM_VALUE_T mem_get_s##end##sz##_aligned ( const void * vmem ) { \ <NEW_LINE> <END_VULN> const int##sz##_t * mem = ( const int##sz##_t * ) vmem ; \ <NEW_LINE> unsigned MEM_VALUE_T val , raw = * mem ; \ <NEW_LINE> swap_endian_##sz##_se ( val , raw ) ; \
} <NEW_LINE> } <NEW_LINE> <START_VULN> static void copyMultiCh16 ( short * dst , const int * const * src , unsigned nSamples , unsigned nChannels ) <NEW_LINE> <END_VULN> { <NEW_LINE> for ( unsigned i = 0 ; i < nSamples ; ++ i ) { <NEW_LINE> for ( unsigned c = 0 ; c < nChannels ; ++ c ) {
extern int perf_output_begin ( struct perf_output_handle * handle , <NEW_LINE> struct perf_event * event , unsigned int size , <NEW_LINE> <START_VULN> int nmi , int sample ) ; <NEW_LINE> <END_VULN> extern void perf_output_end ( struct perf_output_handle * handle ) ; <NEW_LINE> extern void perf_output_copy ( struct perf_output_handle * handle , <NEW_LINE> const void * buf , unsigned int len ) ;
explicit DevToolsDomainHandler ( const std::string & name ) ; <NEW_LINE> virtual ~ DevToolsDomainHandler ( ) ; <NEW_LINE> <START_VULN> virtual void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) ; <NEW_LINE> virtual void Wire ( UberDispatcher * dispatcher ) ; <NEW_LINE> virtual Response Disable ( ) ;
JS_ASSERT ( obj -> isDenseArray ( ) ) ; <NEW_LINE> uint32_t initlen = obj -> getDenseArrayInitializedLength ( ) ; <NEW_LINE> <START_VULN> obj -> moveDenseArrayElements ( 0 , 1 , initlen ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif <NEW_LINE> JSBool <NEW_LINE> js::array_shift ( JSContext * cx , uintN argc , Value * vp ) <NEW_LINE> { <NEW_LINE> CallArgs args = CallArgsFromVp ( argc , vp ) ; <NEW_LINE> JSObject * obj = ToObject ( cx , & args . thisv ( ) ) ;
if ( count >= size ) { <NEW_LINE> const long n = ( size <= 0 ) ? 2048 : 2 * size ; <NEW_LINE> <START_VULN> Cluster ** const qq = new Cluster * [ n ] ; <NEW_LINE> <END_VULN> Cluster ** q = qq ; <NEW_LINE> Cluster ** p = m_clusters ;
NS_IMETHODIMP <NEW_LINE> nsWindow::CaptureMouse ( PRBool aCapture ) <NEW_LINE> { <NEW_LINE> LOG ( ( "CaptureMouse % p\n" , ( void * ) this ) ) ; <NEW_LINE> if ( ! mDrawingarea ) <NEW_LINE> return NS_OK ; <NEW_LINE> <START_VULN> GtkWidget * widget = <NEW_LINE>get_gtk_widget_for_gdk_window ( mDrawingarea -> inner_window ) ; <NEW_LINE> <END_VULN> if ( aCapture ) { <NEW_LINE> gtk_grab_add ( widget ) ; <NEW_LINE> GrabPointer ( ) ; <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> ReleaseGrabs ( ) ; <NEW_LINE> gtk_grab_remove ( widget ) ;
private int32_t moffset ( struct magic_set * , struct magic * ) ; <NEW_LINE> private void mdebug ( uint32_t , const char * , size_t ) ; <NEW_LINE> private int mcopy ( struct magic_set * , union VALUETYPE * , int , int , <NEW_LINE> <START_VULN> const unsigned char * , uint32_t , size_t , size_t ) ; <NEW_LINE> <END_VULN> private int mconvert ( struct magic_set * , struct magic * , int ) ; <NEW_LINE> private int print_sep ( struct magic_set * , int ) ; <NEW_LINE> private int handle_annotation ( struct magic_set * , struct magic * ) ;
for ( r = 0 ; r < 4 ; r ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> #if ! ( CONFIG_FAST_UNALIGNED ) <NEW_LINE>dst [ 0 ] = src [ 0 ] ; <NEW_LINE>dst [ 1 ] = src [ 1 ] ; <NEW_LINE>dst [ 2 ] = src [ 2 ] ; <NEW_LINE>dst [ 3 ] = src [ 3 ] ; <NEW_LINE>dst [ 4 ] = src [ 4 ] ; <NEW_LINE>dst [ 5 ] = src [ 5 ] ; <NEW_LINE>dst [ 6 ] = src [ 6 ] ; <NEW_LINE>dst [ 7 ] = src [ 7 ] ; <NEW_LINE>#else <NEW_LINE> ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ; <NEW_LINE> ( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ; <NEW_LINE>#endif <NEW_LINE> <END_VULN> src += src_stride ; <NEW_LINE> dst += dst_stride ;
length *= image -> colorspace == CMYKColorspace ? 4UL : 3UL ; <NEW_LINE> pixel_info = AcquireVirtualMemory ( length , sizeof ( * pixels ) ) ; <NEW_LINE> if ( pixel_info == ( MemoryInfo * ) NULL ) <NEW_LINE> <START_VULN> ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <END_VULN> pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; <NEW_LINE> Dump runlength encoded pixels .
return r ; <NEW_LINE> if ( cipher_get_keycontext ( state -> receive_context , p ) != ( int ) rlen ) <NEW_LINE> return SSH_ERR_INTERNAL_ERROR ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( ( r = ssh_packet_get_compress_state ( m , ssh ) ) != 0 || <NEW_LINE> ( r = sshbuf_put_stringb ( m , state -> input ) ) != 0 || <NEW_LINE> <END_VULN> ( r = sshbuf_put_stringb ( m , state -> output ) ) != 0 ) <NEW_LINE> return r ;
TString TType::getCompleteString ( ) const <NEW_LINE> { <NEW_LINE> TStringStream stream ; <NEW_LINE> if ( qualifier != EvqTemporary && qualifier != EvqGlobal ) <NEW_LINE> stream << getQualifierString ( ) << " " << getPrecisionString ( ) << " " ; <NEW_LINE> if ( array ) <NEW_LINE> <START_VULN> stream << "array of " ; <NEW_LINE> <END_VULN> if ( matrix ) <NEW_LINE> stream << size << "X" << size << " matrix of " ; <NEW_LINE> else if ( size > 1 ) <NEW_LINE> stream << size << " - component vector of " ; <NEW_LINE> stream << getBasicString ( ) ; <NEW_LINE> return stream . str ( ) ; <NEW_LINE> }
if ( ! strchr ( nm , ' . ' ) ) { <NEW_LINE> if ( ( sscanf ( nm , " % 30d" , & x ) == 1 ) && ( x >= 0 ) && ( x <= 32 ) ) <NEW_LINE> <START_VULN> ha -> netmask . s_addr = htonl ( 0xFFFFFFFF << ( 32 - x ) ) ; <NEW_LINE> <END_VULN> else { <NEW_LINE> ast_log ( LOG_WARNING , "Invalid CIDR in % s\n" , stuff ) ; <NEW_LINE> ast_free ( ha ) ;
r += 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return ret ; <NEW_LINE> }
bool hasSelfPaintingLayer ( ) const ; <NEW_LINE> RenderLayer * layer ( ) const { return m_layer ; } <NEW_LINE> <START_VULN> virtual bool requiresLayer ( ) const { return isRoot ( ) || isPositioned ( ) || isRelPositioned ( ) || isTransparent ( ) || hasTransform ( ) || hasHiddenBackface ( ) || hasMask ( ) || hasReflection ( ) || hasFilter ( ) || style ( ) -> specifiesColumns ( ) ; } <NEW_LINE> <END_VULN> virtual IntRect borderBoundingBox ( ) const = 0 ;
} <NEW_LINE> <START_VULN> const PRUint8 * <NEW_LINE> <END_VULN> PrepareOpenTypeData ( const PRUint8 * aData , PRUint32 * aLength ) <NEW_LINE> { <NEW_LINE> switch ( gfxFontUtils::DetermineFontDataType ( aData , * aLength ) ) { <NEW_LINE> case GFX_USERFONT_OPENTYPE: <NEW_LINE> return aData ;
#endif <NEW_LINE> extern SECStatus ssl3_HandleHelloExtensions ( sslSocket * ss , <NEW_LINE> SSL3Opaque ** b , PRUint32 * length ) ; <NEW_LINE> extern PRBool ssl3_ExtensionNegotiated ( sslSocket * ss , PRUint16 ex_type ) ; <NEW_LINE> <START_VULN> extern SECStatus ssl3_SetSIDSessionTicket ( sslSessionID * sid , <NEW_LINE>NewSessionTicket * session_ticket ) ; <NEW_LINE> <END_VULN> extern SECStatus ssl3_SendNewSessionTicket ( sslSocket * ss ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeys ( unsigned char * keyName , <NEW_LINE> unsigned char * encKey , unsigned char * macKey ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeysPKCS11 ( SECKEYPrivateKey * svrPrivKey , <NEW_LINE> SECKEYPublicKey * svrPubKey , void * pwArg , <NEW_LINE> unsigned char * keyName , PK11SymKey ** aesKey , <NEW_LINE> PK11SymKey ** macKey ) ;
} <NEW_LINE> static vpx_codec_err_t vp8e_set_scalemode ( vpx_codec_alg_priv_t * ctx , <NEW_LINE> <START_VULN> int ctr_id , <NEW_LINE>va_list args ) <NEW_LINE> <END_VULN> { <NEW_LINE> vpx_scaling_mode_t * data = va_arg ( args , vpx_scaling_mode_t * ) ;
unsigned __int64 __rdtsc ( void ) ; <NEW_LINE> #pragma intrinsic ( __rdtsc ) <NEW_LINE> #endif <NEW_LINE> <START_VULN> static unsigned int <NEW_LINE> <END_VULN> x86_readtsc ( void ) { <NEW_LINE> #if defined ( __GNUC__ ) && __GNUC__ <NEW_LINE> unsigned int tsc ;
static void locationWithCallWithAttributeSetter ( v8::Local < v8::Value > jsValue , const v8::PropertyCallbackInfo < void > & info ) <NEW_LINE> { <NEW_LINE> TestObjectPython * proxyImp = V8TestObjectPython::toNative ( info . Holder ( ) ) ; <NEW_LINE> <START_VULN> TestNode * imp = WTF::getPtr ( proxyImp -> locationWithCallWith ( ) ) ; <NEW_LINE> <END_VULN> if ( ! imp ) <NEW_LINE> return ; <NEW_LINE> V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID ( V8StringResource < > , cppValue , jsValue ) ;
nsIURI * uri = doc -> GetDocumentURI ( ) ; <NEW_LINE> if ( uri ) { <NEW_LINE> uri -> GetSpec ( url ) ; <NEW_LINE> lineNo = 1 ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> if ( aNeedsCxPush && ! pusher . Push ( cx ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> uint32_t argCount ; <NEW_LINE> const char ** argNames ;
Token currentToken ; <NEW_LINE> unsigned lookahead ; <NEW_LINE> Token lookaheadTokens [ maxLookahead ] ; <NEW_LINE> } ; <NEW_LINE> void advance ( size_t position ) ; <NEW_LINE> void tell ( Position * ) ; <NEW_LINE> void seek ( const Position & pos ) ; <NEW_LINE> <START_VULN> void seek ( const Position & pos , const TokenStream & other ) ; <NEW_LINE> <END_VULN> size_t positionToOffset ( const Position & pos ) const { <NEW_LINE> return pos . buf - userbuf . base ( ) ; <NEW_LINE> } <NEW_LINE> const jschar * rawBase ( ) const { <NEW_LINE> return userbuf . base ( ) ; <NEW_LINE> }
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> UpgradeSchemaFrom6To7 ( mozIStorageConnection * aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "UpgradeSchemaFrom6To7" ) ; <NEW_LINE> nsresult rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( <NEW_LINE> "CREATE TEMPORARY TABLE temp_upgrade ( " <NEW_LINE> "id , " <NEW_LINE> "name , "
} <NEW_LINE> p += tag_len ; <NEW_LINE> <START_VULN> left - = ( p - gdo ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! iccsn_found && iccsn_len )
} <NEW_LINE> ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; <NEW_LINE> if ( bits == 32 ) { <NEW_LINE> <START_VULN> for ( i = 0 ; i < sec -> size ; i += 4 ) { <NEW_LINE> <END_VULN> ut32 addr32 = r_read_le32 ( buf + i ) ; <NEW_LINE> if ( addr32 ) { <NEW_LINE> RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ;
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> RefPtr < SerializedScriptValue > serializedArg ( SerializedScriptValue::create ( exec , MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
<START_VULN> PHP_FUNCTION ( locale_get_display_variant ) <NEW_LINE> <END_VULN> { <NEW_LINE> get_icu_disp_value_src_php ( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; <NEW_LINE> }
= <NEW_LINE> static_cast < BufferMeta * > ( header -> pAppPrivate ) ; <NEW_LINE> <START_VULN> sp < ABuffer > backup = buffer_meta -> getBuffer ( header , true , false ) ; <NEW_LINE>sp < ABuffer > codec = buffer_meta -> getBuffer ( header , false , false ) ; <NEW_LINE><NEW_LINE><NEW_LINE>if ( mMetadataType [ kPortIndexInput ] == kMetadataBufferTypeGrallocSource <NEW_LINE> && backup -> capacity ( ) >= sizeof ( VideoNativeMetadata ) <NEW_LINE> && codec -> capacity ( ) >= sizeof ( VideoGrallocMetadata ) <NEW_LINE> && ( ( VideoNativeMetadata * ) backup -> base ( ) ) -> eType <NEW_LINE> == kMetadataBufferTypeANWBuffer ) { <NEW_LINE>VideoNativeMetadata & backupMeta = * ( VideoNativeMetadata * ) backup -> base ( ) ; <NEW_LINE>VideoGrallocMetadata & codecMeta = * ( VideoGrallocMetadata * ) codec -> base ( ) ; <NEW_LINE>CLOG_BUFFER ( emptyBuffer , "converting ANWB % p to handle % p" , <NEW_LINE>backupMeta . pBuffer , backupMeta . pBuffer -> handle ) ; <NEW_LINE>codecMeta . pHandle = backupMeta . pBuffer != NULL ? backupMeta . pBuffer -> handle : NULL ; <NEW_LINE>codecMeta . eType = kMetadataBufferTypeGrallocSource ; <NEW_LINE>header -> nFilledLen = rangeLength ? sizeof ( codecMeta ) : 0 ; <NEW_LINE> <END_VULN> header -> nOffset = 0 ;
bool unique_ ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> URL_EXPORT std::ostream & operator << ( std::ostream & out , <NEW_LINE>const Origin & origin ) ; <NEW_LINE> <END_VULN> }
} <NEW_LINE> static int _make_decode_table ( codebook * s , char * lengthlist , long quantvals , <NEW_LINE> <START_VULN> oggpack_buffer * opb , int maptype ) { <NEW_LINE> <END_VULN> int i ; <NEW_LINE> ogg_uint32_t * work ;
kdebug ( " - % u" , key -> serial ) ; <NEW_LINE> key_check ( key ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( key -> type -> destroy ) <NEW_LINE> <END_VULN> key -> type -> destroy ( key ) ; <NEW_LINE> security_key_free ( key ) ;
ui4_payload_size = 0 ; <NEW_LINE> u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <NEW_LINE> <START_VULN> while ( 0xff == u4_bits ) <NEW_LINE> <END_VULN> { <NEW_LINE> u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <NEW_LINE> ui4_payload_size += 255 ;
COPYTHECONTEXT ( "SH: frame_num" , u2_frame_num ) ; <NEW_LINE> <START_VULN> if ( ! ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; <NEW_LINE> pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ;
} ; <NEW_LINE> static const uint32_t ISO2022CNCharLenTable [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; <NEW_LINE> const SMModel ISO2022CNSMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , ISO2022CN_cls } , <NEW_LINE> 9 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , ISO2022CN_st } , <NEW_LINE> <START_VULN> ISO2022CNCharLenTable , <NEW_LINE> <END_VULN> "ISO - 2022 - CN" , <NEW_LINE> } ; <NEW_LINE> static const uint32_t ISO2022JP_cls [ 256 / 8 ] = { <NEW_LINE> PCK4BITS ( 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) , <NEW_LINE> PCK4BITS ( 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 ) , <NEW_LINE> PCK4BITS ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) , <NEW_LINE> PCK4BITS ( 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ) ,
RefPtr < Node > prev = previousSibling ( ) ; <NEW_LINE> RefPtr < Node > next = nextSibling ( ) ; <NEW_LINE> <START_VULN> RefPtr < DocumentFragment > fragment = createFragmentFromSource ( html , parent . get ( ) , ec ) ; <NEW_LINE> <END_VULN> if ( ec ) <NEW_LINE> return ;
png_write_tEXt ( png_ptr , info_ptr -> text [ i ] . key , <NEW_LINE> info_ptr -> text [ i ] . text , 0 ) ; <NEW_LINE> #else <NEW_LINE> png_warning ( png_ptr , "Unable to write uncompressed text" ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>info_ptr -> text [ i ] . compression = PNG_TEXT_COMPRESSION_NONE_WR ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> #endif
} <NEW_LINE> if ( mFirstPicture && ! outQueue . empty ( ) ) { <NEW_LINE> <START_VULN> drainOneOutputBuffer ( mFirstPictureId , mFirstPicture ) ; <NEW_LINE> <END_VULN> delete [ ] mFirstPicture ; <NEW_LINE> mFirstPicture = NULL ; <NEW_LINE> mFirstPictureId = - 1 ;
if ( m_inp_mem_ptr || m_inp_heap_ptr ) { <NEW_LINE> DEBUG_PRINT_LOW ( "Freeing the Input Memory" ) ; <NEW_LINE> for ( i = 0 ; i < drv_ctx . ip_buf . actualcount ; i ++ ) { <NEW_LINE> <START_VULN> if ( m_inp_mem_ptr ) <NEW_LINE>free_input_buffer ( i , & m_inp_mem_ptr [ i ] ) ; <NEW_LINE>else <NEW_LINE>free_input_buffer ( i , NULL ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> free_input_buffer_header ( ) ; <NEW_LINE> free_output_buffer_header ( ) ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> MB_PREDICTION_MODE vp9_above_block_mode ( const MODE_INFO * cur_mi , <NEW_LINE>const MODE_INFO * above_mi , int b ) { <NEW_LINE> <END_VULN> if ( b == 0 || b == 1 ) { <NEW_LINE> if ( ! above_mi || is_inter_block ( & above_mi -> mbmi ) ) <NEW_LINE> return DC_PRED ;
initializeHolderIfNeeded ( scriptState , classObject , holder ) ; <NEW_LINE> v8::TryCatch block ( scriptState -> isolate ( ) ) ; <NEW_LINE> v8::Local < v8::Value > result ; <NEW_LINE> <START_VULN> if ( ! V8ScriptRunner::callFunction ( v8::Local < v8::Function > ::Cast ( method ) , scriptState -> getExecutionContext ( ) , holder , argc , argv , scriptState -> isolate ( ) ) . ToLocal ( & result ) ) { <NEW_LINE> <END_VULN> rethrowExceptionInPrivateScript ( scriptState -> isolate ( ) , block , scriptStateInUserScript , ExceptionState::ExecutionContext , methodName , className ) ; <NEW_LINE> block . ReThrow ( ) ; <NEW_LINE> return v8::Local < v8::Value > ( ) ;
<START_VULN> #ifndef CHROME_BROWSER_CHROMEOS_SETTING_LEVEL_BUBBLE_VIEW_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_SETTING_LEVEL_BUBBLE_VIEW_H_ <NEW_LINE> <END_VULN> #pragma once <NEW_LINE> #include "base / gtest_prod_util . h"
virtual ~ WorkerProcessIpcDelegate ( ) { } <NEW_LINE> <START_VULN> virtual void OnChannelConnected ( ) = 0 ; <NEW_LINE> <END_VULN> virtual bool OnMessageReceived ( const IPC::Message & message ) = 0 ;
unsigned int value_pos ; <NEW_LINE> unsigned int numer , denom ; <NEW_LINE> <START_VULN> field_type = iw_get_ui16_e ( & e -> d [ tag_pos + 2 ] , e -> endian ) ; <NEW_LINE>value_count = iw_get_ui32_e ( & e -> d [ tag_pos + 4 ] , e -> endian ) ; <NEW_LINE> <END_VULN> if ( value_count != 1 ) return 0 ;
nsCOMPtr < nsIScriptContext > context = global -> GetContext ( ) ; <NEW_LINE> if ( context && scope ) { <NEW_LINE> JSContext * cx = context -> GetNativeContext ( ) ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> pusher . Push ( cx , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ; <NEW_LINE> <END_VULN> JSObject * scriptObject = mBoundElement -> GetWrapper ( ) ; <NEW_LINE> if ( scriptObject ) {
<START_VULN> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <NEW_LINE> <END_VULN> { <NEW_LINE> impeg2d_bit_stream_get ( ps_stream , 9 ) ; <NEW_LINE> }
LOOKUP_CLEAN_RETURN ( NULL ) ; <NEW_LINE> } <NEW_LINE> cur_arr [ i * 2 ] = erealloc ( cur_arr [ i * 2 ] , strlen ( lang_tag ) + 1 ) ; <NEW_LINE> <START_VULN> result = strToMatch ( lang_tag , cur_arr [ i * 2 ] ) ; <NEW_LINE> <END_VULN> efree ( lang_tag ) ; <NEW_LINE> if ( result == 0 ) { <NEW_LINE> intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "lookup_loc_range: unable to canonicalize lang_tag" , 0 TSRMLS_CC ) ;
&& ( 'w' == 119 ) && ( 'x' == 120 ) && ( 'y' == 121 ) && ( 'z' == 122 ) \ <NEW_LINE> && ( ' { ' == 123 ) && ( ' | ' == 124 ) && ( ' } ' == 125 ) && ( ' ~ ' == 126 ) ) <NEW_LINE> <START_VULN> #error "gperf generated tables don't work with this execution character set . Please report a bug to < bug - gperf@gnu . org > . " <NEW_LINE> <END_VULN> #endif <NEW_LINE> #line 1 "fcobjshash . gperf"
uint8_t * dst_ptr2 = src + width ; <NEW_LINE> for ( i = 0 ; i < height ; ++ i ) { <NEW_LINE> <START_VULN> vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <NEW_LINE>vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; <NEW_LINE> <END_VULN> src_ptr1 += src_stride ; <NEW_LINE> src_ptr2 += src_stride ; <NEW_LINE> dst_ptr1 += src_stride ;
#define CHROME_BROWSER_UI_VIEWS_INFOBARS_EXTENSION_INFOBAR_H_ <NEW_LINE> #pragma once <NEW_LINE> <START_VULN> #include "chrome / browser / ui / views / infobars / infobars . h" <NEW_LINE> <END_VULN> #include "chrome / browser / extensions / extension_infobar_delegate . h" <NEW_LINE> #include "chrome / browser / extensions / image_loading_tracker . h"
void GatherGlobalUsageComplete ( ) ; <NEW_LINE> void GatherHostUsageComplete ( const std::string & host ) ; <NEW_LINE> <START_VULN> int64 GetCachedHostUsage ( const std::string & host ) ; <NEW_LINE> <END_VULN> int64 GetCachedGlobalUnlimitedUsage ( ) ; <NEW_LINE> virtual void OnSpecialStoragePolicyChanged ( ) OVERRIDE ; <NEW_LINE> void NoopHostUsageCallback (
<START_VULN> Copyright ( c ) 2000 , 2013 , Oracle and / or its affiliates . All rights reserved . <NEW_LINE> <END_VULN> This program is free software ; you can redistribute it and / or modify <NEW_LINE> it under the terms of the GNU General Public License as published by
int max ; <NEW_LINE> X509_OBJECT ret ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> unsigned char * ek = NULL ; <NEW_LINE>int eklen ; <NEW_LINE> <END_VULN> if ( ( etmp = BIO_new ( BIO_f_cipher ( ) ) ) == NULL ) <NEW_LINE> {
namespace web { <NEW_LINE> class NavigationItem ; <NEW_LINE> <START_VULN> class NavigationManager ; <NEW_LINE> <END_VULN> } <NEW_LINE> @protocol CRWSSLStatusUpdaterDataSource ;
- ( instancetype ) initWithDataSource: ( id < CRWSSLStatusUpdaterDataSource > ) dataSource <NEW_LINE> <START_VULN> navigationManager: ( web::NavigationManager * ) navigationManager <NEW_LINE> <END_VULN> NS_DESIGNATED_INITIALIZER ; <NEW_LINE> - ( instancetype ) init NS_UNAVAILABLE ;
if ( PASS == ( ret = PACKET_READ ( stats_header , conn ) ) ) { <NEW_LINE> <START_VULN> * message = estrndup ( stats_header -> message , stats_header -> message_len ) ; <NEW_LINE> <END_VULN> * message_len = stats_header -> message_len ; <NEW_LINE> DBG_INF ( * message ) ; <NEW_LINE> }
{ <NEW_LINE> ASSERT ( oldChild -> parent ( ) == owner ) ; <NEW_LINE> <START_VULN> if ( oldChild -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> toRenderBox ( oldChild ) -> removeFloatingOrPositionedChildFromBlockLists ( ) ;
static v8::Handle < v8::Value > getNamedProperty ( HTMLDocument * htmlDocument , const AtomicString & key , v8::Handle < v8::Object > creationContext , v8::Isolate * isolate ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! htmlDocument -> hasNamedItem ( key . impl ( ) ) && ! htmlDocument -> hasExtraNamedItem ( key . impl ( ) ) ) <NEW_LINE> <END_VULN> return v8Undefined ( ) ; <NEW_LINE> RefPtr < HTMLCollection > items = htmlDocument -> documentNamedItems ( key ) ;
public: <NEW_LINE> nsCryptoRunArgs ( ) ; <NEW_LINE> virtual ~ nsCryptoRunArgs ( ) ; <NEW_LINE> <START_VULN> JSContext * m_cx ; <NEW_LINE> <END_VULN> JSObject * m_scope ; <NEW_LINE> nsCOMPtr < nsIPrincipal > m_principals ; <NEW_LINE> nsXPIDLCString m_jsCallback ;
} <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #if defined ( PNG_READ_USER_TRANSFORM_SUPPORTED ) || \ <NEW_LINE> defined ( PNG_WRITE_USER_TRANSFORM_SUPPORTED )
carray_cursor * pCur = ( carray_cursor * ) cur ; <NEW_LINE> sqlite3_int64 x = 0 ; <NEW_LINE> switch ( i ) { <NEW_LINE> <START_VULN> case CARRAY_COLUMN_POINTER: x = pCur -> iPtr ; break ; <NEW_LINE> <END_VULN> case CARRAY_COLUMN_COUNT: x = pCur -> iCnt ; break ; <NEW_LINE> case CARRAY_COLUMN_CTYPE: { <NEW_LINE> sqlite3_result_text ( ctx , azType [ pCur -> eType ] , - 1 , SQLITE_STATIC ) ;
ret = btrfs_insert_dir_item ( trans , root , name , name_len , <NEW_LINE> parent_inode , & key , <NEW_LINE> btrfs_inode_type ( inode ) , index ) ; <NEW_LINE> <START_VULN> if ( ret == - EEXIST ) <NEW_LINE> <END_VULN> goto fail_dir_item ; <NEW_LINE> else if ( ret ) { <NEW_LINE> btrfs_abort_transaction ( trans , root , ret ) ;
blink::WebString GetErrorMessage ( ) const override ; <NEW_LINE> bool DidLoadingProgress ( ) override ; <NEW_LINE> <START_VULN> bool DidGetOpaqueResponseFromServiceWorker ( ) const override ; <NEW_LINE>bool HasSingleSecurityOrigin ( ) const override ; <NEW_LINE>bool DidPassCORSAccessCheck ( ) const override ; <NEW_LINE> <END_VULN> double MediaTimeForTimeValue ( double timeValue ) const override ;
InitClass ( JSContext * aCx , JSObject * aObj ) <NEW_LINE> { <NEW_LINE> JSObject * proto = JS_InitClass ( aCx , aObj , NULL , & sClass , Construct , 0 , <NEW_LINE> <START_VULN> sProperties , sFunctions , sStaticProperties , <NEW_LINE>NULL ) ; <NEW_LINE>if ( proto && ! JS_DefineProperties ( aCx , proto , sStaticProperties ) ) { <NEW_LINE> <END_VULN> return NULL ; <NEW_LINE> }
<START_VULN> extern bool cephx_verify_authorizer ( CephContext * cct , KeyStore * keys , <NEW_LINE>bufferlist::iterator & indata , <NEW_LINE>CephXServiceTicketInfo & ticket_info , bufferlist & reply_bl ) ; <NEW_LINE> <END_VULN>
} <NEW_LINE> <START_VULN> double GetGPMFSampleRate ( size_t handle , uint32_t fourcc , uint32_t flags ) <NEW_LINE> <END_VULN> { <NEW_LINE> mp4object * mp4 = ( mp4object * ) handle ; <NEW_LINE> if ( mp4 == NULL ) return 0 . 0 ;
} ; <NEW_LINE> static const uint32_t ISO2022KRCharLenTable [ ] = { 0 , 0 , 0 , 0 , 0 , 0 } ; <NEW_LINE> const SMModel ISO2022KRSMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , ISO2022KR_cls } , <NEW_LINE> 6 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , ISO2022KR_st } , <NEW_LINE> <START_VULN> ISO2022KRCharLenTable , <NEW_LINE> <END_VULN> "ISO - 2022 - KR" , <NEW_LINE> } ;
gTextRuns -> RemoveFromCache ( deleteTextRun ) ; <NEW_LINE> delete deleteTextRun ; <NEW_LINE> } <NEW_LINE> mTextRunsToDelete . Clear ( ) ; <NEW_LINE> } <NEW_LINE> void BuildTextRunsScanner::AccumulateRunInfo ( nsTextFrame * aFrame ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( mMaxTextLength <= mMaxTextLength + aFrame -> GetContentLength ( ) , "integer overflow" ) ; <NEW_LINE>mMaxTextLength += aFrame -> GetContentLength ( ) ; <NEW_LINE> <END_VULN> mDoubleByteText |= aFrame -> GetFragment ( ) -> Is2b ( ) ; <NEW_LINE> mLastFrame = aFrame ; <NEW_LINE> mCommonAncestorWithLastFrame = aFrame -> GetParent ( ) ; <NEW_LINE> MappedFlow * mappedFlow = & mMappedFlows [ mMappedFlows . Length ( ) - 1 ] ; <NEW_LINE> NS_ASSERTION ( mappedFlow -> mStartFrame == aFrame || <NEW_LINE> mappedFlow -> GetContentEnd ( ) == aFrame -> GetContentOffset ( ) , <NEW_LINE> "Overlapping or discontiguous frames = > BAD" ) ;
ALLOC_ZVAL ( result_set ) ; <NEW_LINE> array_init ( result_set ) ; <NEW_LINE> INIT_PZVAL ( result_set ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( i = 0 ; i < count ; i ++ ) { <NEW_LINE> if ( offset_capture ) {
} <NEW_LINE> #endif <NEW_LINE> <START_VULN> if ( ! ( png_ptr -> mode & PNG_HAVE_IDAT ) ) <NEW_LINE> <END_VULN> png_error ( png_ptr , "Invalid attempt to read row data" ) ;
#include "prenv . h" <NEW_LINE> #include "mozilla / Preferences . h" <NEW_LINE> #include "mozilla / StandardInteger . h" <NEW_LINE> #include "mozilla / Util . h" <NEW_LINE> namespace mozilla { <NEW_LINE> <START_VULN> using namespace layers ; <NEW_LINE> <END_VULN> using namespace mozilla::dom ; <NEW_LINE> #ifdef PR_LOGGING <NEW_LINE> extern PRLogModuleInfo * gMediaDecoderLog ; <NEW_LINE> #define LOG ( type , msg ) PR_LOG ( gMediaDecoderLog , type , msg ) <NEW_LINE> #else <NEW_LINE> #define LOG ( type , msg ) <NEW_LINE> #endif
#endif <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE>#endif <NEW_LINE> <END_VULN>
mBoxObject -> InvalidateRow ( index ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> else if ( childTag == nsGkAtoms::optgroup ) { <NEW_LINE> InsertRowFor ( aContainer , aChild ) ; <NEW_LINE> } <NEW_LINE> else if ( childTag == nsGkAtoms::option ) { <NEW_LINE> PRInt32 parentIndex = FindContent ( aContainer ) ; <NEW_LINE> <START_VULN> PRInt32 count = InsertRow ( parentIndex , aIndexInContainer , aChild ) ; <NEW_LINE> <END_VULN> if ( mBoxObject ) <NEW_LINE> mBoxObject -> RowCountChanged ( parentIndex + aIndexInContainer + 1 , count ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsTreeContentView::ContentRemoved ( nsIDocument * aDocument , <NEW_LINE> nsIContent * aContainer ,
Randomizer * r = state -> new_object < Randomizer > ( G ( randomizer ) ) ; <NEW_LINE> r -> lock_ = RBX_SPINLOCK_INIT ; <NEW_LINE> r -> rng_data ( state , ByteArray::create ( state , sizeof ( struct random_state ) ) ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return r ; <NEW_LINE> }
} <NEW_LINE> XPCWrappedNativeTearOffChunk * chunk ; <NEW_LINE> for ( chunk = & mFirstChunk ; chunk ; chunk = chunk -> mNextChunk ) { <NEW_LINE> XPCWrappedNativeTearOff * to = chunk -> mTearOffs ; <NEW_LINE> for ( int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK - 1 ; i >= 0 ; i -- , to ++ ) { <NEW_LINE> <START_VULN> if ( to -> GetJSObject ( ) ) { <NEW_LINE>JS_SetPrivate ( cx , to -> GetJSObject ( ) , nsnull ) ; <NEW_LINE> <END_VULN> to -> SetJSObject ( nsnull ) ; <NEW_LINE> } <NEW_LINE> to -> SetNative ( nsnull ) ; <NEW_LINE> to -> SetInterface ( nsnull ) ; <NEW_LINE> } <NEW_LINE> }
nsISupportsArray ** _retval ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_ARG_POINTER ( aElement ) ; <NEW_LINE> * _retval = nsnull ; <NEW_LINE> nsRuleNode * ruleNode = nsnull ; <NEW_LINE> nsCOMPtr < nsIContent > content = do_QueryInterface ( aElement ) ; <NEW_LINE> <START_VULN> GetRuleNodeForContent ( content , & ruleNode ) ; <NEW_LINE> <END_VULN> if ( ! ruleNode ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsISupportsArray > rules ; <NEW_LINE> NS_NewISupportsArray ( getter_AddRefs ( rules ) ) ;
char delimiter [ 2 ] , enclosure [ 2 ] ; <NEW_LINE> array_init ( return_value ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> delimiter [ 0 ] = intern -> u . file . delimiter ; <NEW_LINE> delimiter [ 1 ] = '\0' ; <NEW_LINE> enclosure [ 0 ] = intern -> u . file . enclosure ;
return ; <NEW_LINE> } <NEW_LINE> for ( i = 0 ; i < argc ; i ++ ) { <NEW_LINE> <START_VULN> key = stok ( sclone ( argv [ i ] ) , " = " , ( char ** ) & value ) ; <NEW_LINE> <END_VULN> if ( value ) { <NEW_LINE> setPackageKey ( key , value ) ; <NEW_LINE> } else {
<START_VULN> #ifndef BASE_ALLOCATOR_ALLOCATOR_EXTENSION_H <NEW_LINE>#define BASE_ALLOCATOR_ALLOCATOR_EXTENSION_H <NEW_LINE> <END_VULN> #include < stddef . h >
{ <NEW_LINE> png_fixed_point input_gamma_default ; <NEW_LINE> <START_VULN> if ( ( base_format & PNG_FORMAT_FLAG_LINEAR ) && <NEW_LINE> ( image -> flags & PNG_IMAGE_FLAG_16BIT_sRGB ) == 0 ) <NEW_LINE> <END_VULN> input_gamma_default = PNG_GAMMA_LINEAR ; <NEW_LINE> else <NEW_LINE> input_gamma_default = PNG_DEFAULT_sRGB ;
static int le_mcrypt ; <NEW_LINE> <START_VULN> typedef struct _php_mcrypt { <NEW_LINE> <END_VULN> MCRYPT td ; <NEW_LINE> zend_bool init ; <NEW_LINE> } php_mcrypt ;
} <NEW_LINE> #endif <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
if ( ! shouldAddURL ( url ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( ! image || ! image -> hasImage ( ) || image -> image ( ) == Image::nullImage ( ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> RefPtr < SharedBuffer > data = imageRenderer ? image -> imageForRenderer ( imageRenderer ) -> data ( ) : 0 ;
if ( err < 0 ) <NEW_LINE> return err ; <NEW_LINE> } <NEW_LINE> <START_VULN> kern_msg -> msg_name = kern_address ; <NEW_LINE> <END_VULN> } else <NEW_LINE> kern_msg -> msg_name = NULL ;
@param lastIndex Pointer to an integer that will hold the last index retrieved . <NEW_LINE> @ingroup MprList <NEW_LINE> @internal <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC void * mprGetNextStableItem ( MprList * list , int * lastIndex ) ;
if ( imsx > max_x || imsy > max_y ) { <NEW_LINE> dmsx = max_x ; <NEW_LINE> dmsy = max_y ; <NEW_LINE> <START_VULN> if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ) == NULL ) { <NEW_LINE> <END_VULN> imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; <NEW_LINE> return ( MagickFalse ) ; <NEW_LINE> }
{ <NEW_LINE> case TUNNEL_PASS: <NEW_LINE> if ( length < 3 ) <NEW_LINE> <START_VULN> { <NEW_LINE>ND_PRINT ( ( ndo , " % s" , tstr ) ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE> <END_VULN> if ( * data && ( * data <= 0x1F ) ) <NEW_LINE> ND_PRINT ( ( ndo , "Tag [ % u ] " , * data ) ) ; <NEW_LINE> else
m_pInput_pmem [ i ] . size = m_sInPortDef . nBufferSize ; <NEW_LINE> m_pInput_pmem [ i ] . offset = 0 ; <NEW_LINE> <START_VULN> m_pInput_pmem [ i ] . buffer = ( OMX_U8 * ) SECURE_BUFPTR ; <NEW_LINE> <END_VULN> if ( ! secure_session ) { <NEW_LINE> m_pInput_pmem [ i ] . buffer = ( unsigned char * ) mmap ( <NEW_LINE> NULL , m_pInput_pmem [ i ] . size , PROT_READ | PROT_WRITE ,
InstallNewDocumentReason , <NEW_LINE> ParserSynchronizationPolicy , <NEW_LINE> const KURL & overriding_url ) ; <NEW_LINE> <START_VULN> void DidInstallNewDocument ( Document * ) ; <NEW_LINE> <END_VULN> void WillCommitNavigation ( ) ; <NEW_LINE> void DidCommitNavigation ( ) ;
BTIF_TRACE_DEBUG ( " % s: % x % x % x" , __FUNCTION__ , <NEW_LINE> hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; <NEW_LINE> bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ; <NEW_LINE> <START_VULN> usleep ( 200000 ) ; <NEW_LINE> <END_VULN> memset ( hidreport , 0 , 9 ) ; <NEW_LINE> hidreport [ 0 ] = 1 ; <NEW_LINE> BTIF_TRACE_DEBUG ( "Writing hidreport #2 to os: "\
<< " ) @ ( " << sub_rect . X ( ) << " , " << sub_rect . Y ( ) << " ) , image = ( " <NEW_LINE> << image_width << " x " << image_height << " ) " ; <NEW_LINE> <START_VULN> if ( sub_rect . X ( ) < 0 || sub_rect . Y ( ) < 0 || sub_rect . MaxX ( ) > image_width || <NEW_LINE>sub_rect . MaxY ( ) > image_height || sub_rect . Width ( ) < 0 || <NEW_LINE>sub_rect . Height ( ) < 0 ) { <NEW_LINE> <END_VULN> SynthesizeGLError ( GL_INVALID_OPERATION , function_name , <NEW_LINE> "source sub - rectangle specified via pixel unpack " <NEW_LINE> "parameters is invalid" ) ;
for ( i = 1 ; ( i < ( ssize_t ) dds_info -> mipmapcount ) && w && h ; i ++ ) <NEW_LINE> { <NEW_LINE> offset = ( MagickOffsetType ) ( ( w + 3 ) / 4 ) * ( ( h + 3 ) / 4 ) * texel_size ; <NEW_LINE> <START_VULN> ( void ) SeekBlob ( image , offset , SEEK_CUR ) ; <NEW_LINE><NEW_LINE> <END_VULN> w = DIV2 ( w ) ; <NEW_LINE> h = DIV2 ( h ) ; <NEW_LINE> }
png_error ( png_ptr , msg ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_WARNINGS_SUPPORTED <NEW_LINE> void PNGAPI
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 2 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> const String & strArg ( ustringToString ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . isEmpty ( ) ? UString ( ) : MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . toString ( exec ) -> value ( exec ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) )
<START_VULN> png_ptr = png_create_write_struct ( PNG_LIBPNG_VER_STRING , mainprog_ptr , <NEW_LINE> <END_VULN> writepng_error_handler , NULL ) ; <NEW_LINE> if ( ! png_ptr ) <NEW_LINE> return 4 ;
switch ( op ) { <NEW_LINE> case JSOP_GETLOCAL: <NEW_LINE> case JSOP_LOCALINC: <NEW_LINE> case JSOP_INCLOCAL: <NEW_LINE> case JSOP_GETARG: <NEW_LINE> case JSOP_ARGINC: <NEW_LINE> case JSOP_INCARG: { <NEW_LINE> <START_VULN> if ( cv . frame != CrossScriptSSA::OUTER_FRAME ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> uint32 slot = GetBytecodeSlot ( outerScript , pc ) ; <NEW_LINE> if ( outerAnalysis -> slotEscapes ( slot ) ) <NEW_LINE> return false ; <NEW_LINE> uint32 write = outerAnalysis -> liveness ( slot ) . firstWrite ( lifetime ) ; <NEW_LINE> if ( write != uint32 ( - 1 ) && write < v . pushedOffset ( ) ) { <NEW_LINE> return false ;
* <NEW_LINE> that -> pm -> limit += pow ( <NEW_LINE> <START_VULN> # if DIGITIZE <NEW_LINE>1 . 1 <NEW_LINE># else <NEW_LINE>1 . <NEW_LINE># endif <NEW_LINE> / 255 , data . gamma ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
rowsize = sp -> rowsize ; <NEW_LINE> assert ( rowsize > 0 ) ; <NEW_LINE> <START_VULN> assert ( ( cc0 % rowsize ) == 0 ) ; <NEW_LINE> <END_VULN> while ( cc > 0 ) { <NEW_LINE> ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; <NEW_LINE> cc - = rowsize ;
return oidc_util_html_send_error ( r , c -> error_template , "Invalid Request" , <NEW_LINE> apr_psprintf ( r -> pool , <NEW_LINE> <START_VULN> "The OpenID Connect callback URL received an invalid request: % s" , <NEW_LINE>r -> args ) , HTTP_INTERNAL_SERVER_ERROR ) ; <NEW_LINE> <END_VULN> }
} <NEW_LINE> # ifdef PNG_WRITE_SUPPORTED <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> else if ( unsupported_chunks > 0 ) <NEW_LINE> { <NEW_LINE> fprintf ( STDERR , "\n % s: unsupported chunks ( % d ) % s" ,
ret = gpiochip_add_data ( & gpio_dev -> gc , gpio_dev ) ; <NEW_LINE> if ( ret ) <NEW_LINE> <START_VULN> goto out1 ; <NEW_LINE> <END_VULN> ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , <NEW_LINE> 0 , 0 , TOTAL_NUMBER_OF_PINS ) ;
class TlsHandshakeFilter : public TlsRecordFilter { <NEW_LINE> public: <NEW_LINE> TlsHandshakeFilter ( ) { } <NEW_LINE> protected: <NEW_LINE> virtual bool FilterRecord ( uint8_t content_type , uint16_t version , <NEW_LINE> const DataBuffer & input , DataBuffer * output ) ; <NEW_LINE> virtual bool FilterHandshake ( uint16_t version , uint8_t handshake_type , <NEW_LINE> const DataBuffer & input , DataBuffer * output ) = 0 ; <NEW_LINE> private: <NEW_LINE> <START_VULN> bool CheckDtls ( TlsParser & parser , size_t length ) ; <NEW_LINE> <END_VULN> size_t ApplyFilter ( uint16_t version , uint8_t handshake_type , <NEW_LINE> const DataBuffer & record , DataBuffer * output , <NEW_LINE> size_t length_offset , size_t value_offset , bool * changed ) ; <NEW_LINE> } ; <NEW_LINE> class TlsInspectorRecordHandshakeMessage : public TlsHandshakeFilter { <NEW_LINE> public:
return true ; <NEW_LINE> if ( ! WrapperFactory::IsPartiallyTransparent ( wrapper ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> if ( ContentScriptHasUniversalXPConnect ( ) ) <NEW_LINE>return true ; <NEW_LINE><NEW_LINE>return AccessCheck::documentDomainMakesSameOrigin ( cx , UnwrapObject ( wrapper ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JSObject * <NEW_LINE> GetNativePropertiesObject ( JSContext * cx , JSObject * wrapper ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( js::IsWrapper ( wrapper ) && WrapperFactory::IsXrayWrapper ( wrapper ) , <NEW_LINE> "bad object passed in" ) ;
{ <NEW_LINE> BTIF_TRACE_DEBUG ( " % s" , __FUNCTION__ ) ; <NEW_LINE> if ( uinput_fd > 0 ) { <NEW_LINE> <START_VULN> ioctl ( uinput_fd , UI_DEV_DESTROY ) ; <NEW_LINE> <END_VULN> close ( uinput_fd ) ; <NEW_LINE> uinput_fd = - 1 ;
png_error ( png_ptr , "internal error handling cHRM -> XYZ" ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #endif
if ( isFloating ( ) ) <NEW_LINE> return "RenderBlock ( floating ) " ; <NEW_LINE> <START_VULN> if ( isPositioned ( ) ) <NEW_LINE> <END_VULN> return "RenderBlock ( positioned ) " ; <NEW_LINE> if ( isAnonymousColumnsBlock ( ) ) <NEW_LINE> return "RenderBlock ( anonymous multi - column ) " ;
static const char * LEGACY_CONFIG_FILE_PATH = " / data / misc / bluedroid / bt_config . xml" ; <NEW_LINE> static const period_ms_t CONFIG_SETTLE_PERIOD_MS = 3000 ; <NEW_LINE> <START_VULN> static void timer_config_save ( void * data ) ; <NEW_LINE> <END_VULN>
bool bRet = false ; <NEW_LINE> unsigned i = 0 , j = 0 ; <NEW_LINE> <START_VULN> DEBUG_PRINT_LOW ( "Value of m_out_mem_ptr % p" , m_inp_mem_ptr ) ; <NEW_LINE> <END_VULN> if ( m_out_mem_ptr ) { <NEW_LINE> for ( ; j < drv_ctx . op_buf . actualcount ; j ++ ) { <NEW_LINE> if ( BITMASK_PRESENT ( & m_out_bm_count , j ) ) {
xmlXPathCompOpEval ( ctxt , <NEW_LINE> & comp -> steps [ op -> ch2 ] ) ; <NEW_LINE> if ( ctxt -> error != XPATH_EXPRESSION_OK ) { <NEW_LINE> <START_VULN> xmlXPathFreeObject ( obj ) ; <NEW_LINE>return ( 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> res = valuePop ( ctxt ) ;
aBpd -> FrameAt ( newIndex ) == NS_BIDI_CONTROL_FRAME ) ; <NEW_LINE> if ( newIndex < frameCount ) { <NEW_LINE> RemoveBidiContinuation ( aBpd , frame , <NEW_LINE> frameIndex , newIndex , lineOffset ) ; <NEW_LINE> } <NEW_LINE> } else if ( runLength == fragmentLength ) { <NEW_LINE> nsIFrame * next = frame -> GetNextInFlow ( ) ; <NEW_LINE> if ( next ) { <NEW_LINE> <START_VULN> frame -> SetNextContinuation ( next ) ; <NEW_LINE>next -> SetPrevContinuation ( frame ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> frame -> AdjustOffsetsForBidi ( contentOffset , contentOffset + fragmentLength ) ; <NEW_LINE> currentLine -> MarkDirty ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> ++ lineOffset ;
exit ( - 1 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( pkthdr -> len < pkthdr -> caplen ) { <NEW_LINE>fprintf ( stderr , "safe_pcap_next ERROR: Invalid packet length in % s: % s ( ) line % d: packet length % u is less than capture length % u\n" , <NEW_LINE> <END_VULN> file , funcname , line , pkthdr -> len , pkthdr -> caplen ) ; <NEW_LINE> exit ( - 1 ) ; <NEW_LINE> }
a = text ; <NEW_LINE> e = text + strlen ( text ) ; <NEW_LINE> while ( a <= e ) { <NEW_LINE> <START_VULN> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> b = m . sub [ 0 ] . sp ;
if ( ! loadFile ( filename , fileBytes ) ) { return false ; } <NEW_LINE> <START_VULN> if ( * ( U32 * ) fileBytes . data ( ) == 0x6d736100 ) <NEW_LINE> <END_VULN> { return loadBinaryModule ( fileBytes . data ( ) , fileBytes . size ( ) , outModule ) ; } <NEW_LINE> else <NEW_LINE> {
event . theText != mIMELastDispatchedComposingText ) { <NEW_LINE> nsCompositionEvent compositionUpdate ( true , <NEW_LINE> NS_COMPOSITION_UPDATE , <NEW_LINE> this ) ; <NEW_LINE> InitEvent ( compositionUpdate , nsnull ) ; <NEW_LINE> compositionUpdate . data = event . theText ; <NEW_LINE> mIMELastDispatchedComposingText = event . theText ; <NEW_LINE> DispatchEvent ( & compositionUpdate ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> } <NEW_LINE> ALOGIME ( "IME: IME_SET_TEXT: l = % u , r = % u" , <NEW_LINE> event . theText . Length ( ) , mIMERanges . Length ( ) ) ; <NEW_LINE> DispatchEvent ( & event ) ; <NEW_LINE> mIMERanges . Clear ( ) ; <NEW_LINE> }
\ ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** / <NEW_LINE> <START_VULN> #if defined ( HAVE_GETTIMEOFDAY ) <NEW_LINE> <END_VULN> void jas_tmr_start ( jas_tmr_t * tmr ) <NEW_LINE> {
for ( i = 0 ; i < no_tracks ; i ++ ) { <NEW_LINE> running_event [ i ] = 0 ; <NEW_LINE> do { <NEW_LINE> <START_VULN> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <NEW_LINE> <END_VULN> if ( setup_ret == 0 ) { <NEW_LINE> goto _end ; <NEW_LINE> }
case EFFECT_CMD_SET_CONFIG: <NEW_LINE> if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) <NEW_LINE> <START_VULN> || pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> } <NEW_LINE> * ( int * ) pReplyData = Downmix_Configure ( pDwmModule ,
# if PNG_sRGB_PROFILE_CHECKS == 0 <NEW_LINE> <START_VULN> if ( png_sRGB_checks [ i ] . have_md5 ) <NEW_LINE> <END_VULN> return 1 + png_sRGB_checks [ i ] . is_broken ; <NEW_LINE> # endif
{ <NEW_LINE> JSBool inArray ; <NEW_LINE> op = JSOP_NOP ; <NEW_LINE> rval = PopStr ( ss , op , & rvalpc ) ; <NEW_LINE> sn = js_GetSrcNote ( jp -> script , pc ) ; <NEW_LINE> <START_VULN> for ( xval = rval ; * xval != ' [ ' && * xval != ' { ' ; xval ++ ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> inArray = ( * xval == ' [ ' ) ; <NEW_LINE> if ( inArray ) <NEW_LINE> -- ss -> inArrayInit ; <NEW_LINE> todo = ss -> sprinter . getOffset ( ) ; <NEW_LINE> SprintOpcode ( ss , rval , rvalpc , pc , todo ) ; <NEW_LINE> Sprint ( & ss -> sprinter , " % s % c" , <NEW_LINE> ( sn && SN_TYPE ( sn ) == SRC_CONTINUE ) ? " , " : "" ,
<START_VULN> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <NEW_LINE> <END_VULN> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; <NEW_LINE> best_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ;
sibling = ElementTraversal::nextSibling ( * sibling ) ) { <NEW_LINE> const AtomicString & siblingAriaRole = <NEW_LINE> AccessibleNode::getProperty ( sibling , AOMStringProperty::kRole ) ; <NEW_LINE> <START_VULN> if ( equalIgnoringCase ( siblingAriaRole , role ) ) <NEW_LINE> <END_VULN> return sibling ; <NEW_LINE> }
#ifdef PNG_16BIT_SUPPORTED <NEW_LINE> #if defined ( PNG_READ_SWAP_SUPPORTED ) || defined ( PNG_WRITE_SWAP_SUPPORTED ) <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> void <NEW_LINE> png_do_swap ( png_row_infop row_info , png_bytep row ) <NEW_LINE> {
const media::AudioParameters & params , <NEW_LINE> const std::string & raw_device_id ) > ; <NEW_LINE> <START_VULN> AudioOutputAuthorizationHandler ( media::AudioManager * audio_manager , <NEW_LINE> <END_VULN> MediaStreamManager * media_stream_manager , <NEW_LINE> int render_process_id_ , <NEW_LINE> const std::string & salt ) ;
} <NEW_LINE> if ( tap_if_up ( TAP_IF_NAME , controller_get_interface ( ) -> get_address ( ) ) == 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> int flags = fcntl ( fd , F_GETFL , 0 ) ; <NEW_LINE>fcntl ( fd , F_SETFL , flags | O_NONBLOCK ) ; <NEW_LINE> <END_VULN> return fd ; <NEW_LINE> } <NEW_LINE> BTIF_TRACE_ERROR ( "can not bring up tap interface: % s" , TAP_IF_NAME ) ;
<START_VULN> #ifndef CHROME_BROWSER_CHROMEOS_SETTING_LEVEL_BUBBLE_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_SETTING_LEVEL_BUBBLE_H_ <NEW_LINE> <END_VULN> #pragma once <NEW_LINE> #include "base / basictypes . h"
static void locationWithPerWorldBindingsAttributeSetter ( v8::Local < v8::Value > jsValue , const v8::PropertyCallbackInfo < void > & info ) <NEW_LINE> { <NEW_LINE> TestObjectPython * proxyImp = V8TestObjectPython::toNative ( info . Holder ( ) ) ; <NEW_LINE> <START_VULN> TestNode * imp = WTF::getPtr ( proxyImp -> locationWithPerWorldBindings ( ) ) ; <NEW_LINE> <END_VULN> if ( ! imp ) <NEW_LINE> return ; <NEW_LINE> V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID ( V8StringResource < > , cppValue , jsValue ) ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <NEW_LINE> <END_VULN> if ( ! other_branch ) <NEW_LINE> return - EFAULT ; <NEW_LINE> other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ;
SPL_METHOD ( GlobIterator , count ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
<START_VULN> #ifndef BASE_PROCESS_LINUX_INTERNAL_H_ <NEW_LINE>#define BASE_PROCESS_LINUX_INTERNAL_H_ <NEW_LINE> <END_VULN> #include < unistd . h >
c = * chars ; <NEW_LINE> if ( c < 0x80 ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> if ( 0xD800 <= c && c <= 0xDFFF && ! useCESU8 ) { <NEW_LINE> <END_VULN> chars ++ ;
atPoint: ( CGPoint ) touchLocation <NEW_LINE> atIndexPath: ( nonnull NSIndexPath * ) indexPath ; <NEW_LINE> <START_VULN> - ( void ) dismissContextMenu ; <NEW_LINE> <END_VULN> - ( void ) handlePromoTapped ;
enqueue_goaway ( conn , ( int ) ret , <NEW_LINE> err_desc != NULL ? ( h2o_iovec_t ) { ( char * ) err_desc , strlen ( err_desc ) } : ( h2o_iovec_t ) { } ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> close_connection ( conn ) ; <NEW_LINE>return ; <NEW_LINE> <END_VULN> } <NEW_LINE> h2o_buffer_consume ( & conn -> sock -> input , ret ) ;
virtual void DidManualLoadFail ( ) ; <NEW_LINE> virtual void InstallMissingPlugin ( ) ; <NEW_LINE> virtual webkit_glue::WebPluginResourceClient * CreateResourceClient ( <NEW_LINE> <START_VULN> unsigned long resource_id , <NEW_LINE>const GURL & url , <NEW_LINE>bool notify_needed , <NEW_LINE>intptr_t notify_data , <NEW_LINE>intptr_t stream ) ; <NEW_LINE> <END_VULN> bool IsWindowless ( ) const { return windowless_ ; }
static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx , <NEW_LINE> <START_VULN> int ctr_id , <NEW_LINE>va_list args ) <NEW_LINE> <END_VULN> { <NEW_LINE> vpx_active_map_t * data = va_arg ( args , vpx_active_map_t * ) ;
return false ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIScriptContext > context = global -> GetContext ( ) ; <NEW_LINE> if ( ! context ) { <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSContext * cx = context -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIDocument > ourDocument = <NEW_LINE> mPrototypeBinding -> XBLDocumentInfo ( ) -> GetDocument ( ) ; <NEW_LINE> bool canExecute ; <NEW_LINE> nsresult rv = <NEW_LINE> mgr -> CanExecuteScripts ( cx , ourDocument -> NodePrincipal ( ) , & canExecute ) ; <NEW_LINE> return NS_SUCCEEDED ( rv ) && canExecute ; <NEW_LINE> }
browserInfo . lpszTitle = mTitle . get ( ) ; <NEW_LINE> browserInfo . ulFlags = BIF_USENEWUI | BIF_RETURNONLYFSDIRS ; <NEW_LINE> if ( initialDir . Length ( ) ) { <NEW_LINE> browserInfo . lParam = ( LPARAM ) initialDir . get ( ) ; <NEW_LINE> browserInfo . lpfn = & BrowseCallbackProc ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> browserInfo . lParam = nsnull ; <NEW_LINE> <END_VULN> browserInfo . lpfn = nsnull ; <NEW_LINE> } <NEW_LINE> browserInfo . iImage = nsnull ; <NEW_LINE> LPITEMIDLIST list = ::SHBrowseForFolderW ( & browserInfo ) ; <NEW_LINE> if ( list != NULL ) { <NEW_LINE> result = ::SHGetPathFromIDListW ( list , ( LPWSTR ) fileBuffer ) ; <NEW_LINE> if ( result ) {
} ; <NEW_LINE> <START_VULN> DXVAVideoDecodeAccelerator ( <NEW_LINE>media::VideoDecodeAccelerator::Client * client , <NEW_LINE>base::ProcessHandle renderer_process ) ; <NEW_LINE> <END_VULN> virtual ~ DXVAVideoDecodeAccelerator ( ) ;
} <NEW_LINE> RelinquishMagickMemory ( BImgBuff ) ; <NEW_LINE> <START_VULN> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <NEW_LINE> <END_VULN> END_OF_READING: <NEW_LINE> clone_info = DestroyImageInfo ( clone_info ) ; <NEW_LINE> CloseBlob ( image ) ;
if ( img ) img += num_enc - 1 ; <NEW_LINE> for ( i = num_enc - 1 ; i >= 0 ; i -- ) { <NEW_LINE> <START_VULN> if ( ( res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <NEW_LINE> <END_VULN> duration , flags , deadline ) ) ) <NEW_LINE> break ;
if ( yych <= '9' ) goto yy79 ; <NEW_LINE> if ( yych != ' ; ' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 557 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> #if SIZEOF_LONG == 4 <NEW_LINE> int digits = YYCURSOR - start - 3 ;
* <NEW_LINE> <START_VULN> #define LIBXML_MODULE_EXTENSION " . dll" <NEW_LINE> <END_VULN> #endif
struct StringWrapper <NEW_LINE> { <NEW_LINE> JSString * str ; <NEW_LINE> bool strOk ; <NEW_LINE> } sw ; <NEW_LINE> void <NEW_LINE> <START_VULN> FinalizeCallback ( JSFreeOp * fop , JSFinalizeStatus status ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( status == JSFINALIZE_START ) <NEW_LINE> sw . strOk = ! JS_IsAboutToBeFinalized ( sw . str ) ; <NEW_LINE> } <NEW_LINE> BEGIN_TEST ( testInternAcrossGC ) <NEW_LINE> { <NEW_LINE> sw . str = JS_InternString ( cx , "wrapped chars that another test shouldn't be using" ) ;
#ifdef PNG_READ_tIME_SUPPORTED <NEW_LINE> else if ( chunk_name == png_tIME ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_tIME ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
return rv ; <NEW_LINE> } <NEW_LINE> frame -> SetInitialChildList ( nsnull , childItems . childList ) ; <NEW_LINE> fc -> EndUpdate ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( mCallback ) <NEW_LINE> <END_VULN> mCallback ( mContent , frame , mArg ) ; <NEW_LINE> mPresShell -> GetDocument ( ) -> BindingManager ( ) -> ProcessAttachedQueue ( ) ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> }
ASSERT ( context ) ; <NEW_LINE> ASSERT_WITH_SECURITY_IMPLICATION ( context -> isDocument ( ) ) ; <NEW_LINE> <START_VULN> RefPtr < CallbackWrapper > wrapper = adoptRef ( new CallbackWrapper ( callbacks ) ) ; <NEW_LINE> <END_VULN> requestFileSystemAccessInternal ( context , <NEW_LINE> bind ( & LocalFileSystem::deleteFileSystemInternal , this , contextPtr , type , wrapper ) , <NEW_LINE> bind ( & LocalFileSystem::fileSystemNotAllowedInternal , this , contextPtr , wrapper ) ) ;
<START_VULN> #ifndef BASE_SIMPLE_TEST_TICK_CLOCK_H_ <NEW_LINE>#define BASE_SIMPLE_TEST_TICK_CLOCK_H_ <NEW_LINE> <END_VULN> #include "base / compiler_specific . h" <NEW_LINE> #include "base / synchronization / lock . h"
} ; <NEW_LINE> static void initialize ( ) ; <NEW_LINE> <START_VULN> static void postTask ( PassOwnPtr < Task > ) ; <NEW_LINE> <END_VULN> private: <NEW_LINE> static void performTask ( void * ) ; <NEW_LINE> } ;
SkASSERT ( fPtr != fStorage ) ; <NEW_LINE> fPtr = fStorage ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> fPtr = sk_malloc_flags ( size , SK_MALLOC_THROW | SK_MALLOC_TEMP ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> fSize = size ;
nsCOMPtr < nsIScriptGlobalObject > scriptGlobal ( do_GetInterface ( mRequestor ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( scriptGlobal , NS_ERROR_FAILURE ) ; <NEW_LINE> nsIScriptContext * context = scriptGlobal -> GetContext ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( context , NS_ERROR_FAILURE ) ; <NEW_LINE> <START_VULN> JSContext * cx = context -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSObject * global = JS_GetGlobalObject ( cx ) ; <NEW_LINE> static NS_DEFINE_CID ( kXPConnectCID , NS_XPCONNECT_CID ) ; <NEW_LINE> nsCOMPtr < nsIXPConnect > xpc ( do_GetService ( kXPConnectCID , & rv ) ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> nsCOMPtr < nsIXPConnectJSObjectHolder > wrapper ;
gPlatform -> overrideObserver = new SRGBOverrideObserver ( ) ; <NEW_LINE> FontPrefsObserver * fontPrefObserver = new FontPrefsObserver ( ) ; <NEW_LINE> nsCOMPtr < nsIPrefBranch2 > prefs = do_GetService ( NS_PREFSERVICE_CONTRACTID ) ; <NEW_LINE> if ( prefs ) { <NEW_LINE> prefs -> AddObserver ( CMForceSRGBPrefName , gPlatform -> overrideObserver , PR_TRUE ) ; <NEW_LINE> <START_VULN> prefs -> AddObserver ( GFX_DOWNLOADABLE_FONTS_ENABLED , fontPrefObserver , PR_FALSE ) ; <NEW_LINE> <END_VULN> prefs -> AddObserver ( "gfx . font_rendering . " , fontPrefObserver , PR_FALSE ) ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> gfxPlatform::Shutdown ( )
if ( s -> peer -> shutdown ) { <NEW_LINE> s -> peer -> shutdown ( s -> peer ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> s -> peer -> peer = 0 ; <NEW_LINE><NEW_LINE>if ( s -> peer -> close == local_socket_close ) { <NEW_LINE>local_socket_close_locked ( s -> peer ) ; <NEW_LINE> } else { <NEW_LINE>s -> peer -> close ( s -> peer ) ; <NEW_LINE> } <NEW_LINE>s -> peer = 0 ; <NEW_LINE> <END_VULN> }
ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; <NEW_LINE> ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; <NEW_LINE> ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; <NEW_LINE> <START_VULN> if ( ps_dec -> u1_first_slice_in_stream ) <NEW_LINE> <END_VULN> { <NEW_LINE> ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ;
\ <NEW_LINE> if ( ! wa || JS_GetTypedArrayType ( wa ) != js::TypedArray::arrayType ) \ <NEW_LINE> return ErrorInvalidValue ( #name ": array must be " #arrayType ) ; \ <NEW_LINE> if ( JS_GetTypedArrayLength ( wa ) == 0 || JS_GetTypedArrayLength ( wa ) % ( dim * dim ) != 0 ) \ <NEW_LINE> return ErrorInvalidValue ( #name ": array length must be > 0 and multiple of % d" , dim * dim ) ; \ <NEW_LINE> if ( transpose ) \ <NEW_LINE> return ErrorInvalidValue ( #name ": transpose must be FALSE as per the OpenGL ES 2 . 0 spec" ) ; \ <NEW_LINE> MakeContextCurrent ( ) ; \ <NEW_LINE> <START_VULN> gl -> f##name ( location , JS_GetTypedArrayLength ( wa ) / ( dim * dim ) , transpose , ( ptrType * ) JS_GetTypedArrayData ( wa ) ) ; \ <NEW_LINE> <END_VULN> return NS_OK ; \ <NEW_LINE> } <NEW_LINE> #define SIMPLE_METHOD_UNIFORM_1 ( glname , name , t1 ) \ <NEW_LINE> NS_IMETHODIMP WebGLContext::name ( nsIWebGLUniformLocation * ploc , t1 a1 ) { \ <NEW_LINE> if ( mContextLost ) \ <NEW_LINE> return NS_OK ; \ <NEW_LINE> OBTAIN_UNIFORM_LOCATION ( #name ": location" ) \
png_free ( png_ptr , old_buffer ) ; <NEW_LINE> png_error ( png_ptr , "Insufficient memory for save_buffer" ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> png_memcpy ( png_ptr -> save_buffer , old_buffer , png_ptr -> save_buffer_size ) ; <NEW_LINE>png_free ( png_ptr , old_buffer ) ; <NEW_LINE>png_ptr -> save_buffer_max = new_max ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( png_ptr -> current_buffer_size ) <NEW_LINE> {
{ <NEW_LINE> } <NEW_LINE> <START_VULN> #if BLINK_IMPLEMENTATION <NEW_LINE>WebMediaConstraint ( const WebCore::MediaConstraint & ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> WebString m_name ;
this -> sd = - 1 ; <NEW_LINE> this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ; <NEW_LINE> if ( this -> sd < 0 ) { <NEW_LINE> <START_VULN> ERR ( "sockect open failed" ) ; <NEW_LINE> <END_VULN> goto error ; <NEW_LINE> }
& cipher , & cipher_len , & module , & module_len ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> td = mcrypt_module_open ( cipher , cipher_dir_string , module , module_dir_string ) ; <NEW_LINE> if ( td != MCRYPT_FAILED ) { <NEW_LINE> RETVAL_LONG ( mcrypt_enc_get_iv_size ( td ) ) ;
' < session - name >= < session - id > ' to allow URLs of the form <NEW_LINE> http: <NEW_LINE> <START_VULN> if ( ! PS ( id ) && <NEW_LINE> <END_VULN> zend_hash_find ( & EG ( symbol_table ) , "REQUEST_URI" , <NEW_LINE> sizeof ( "REQUEST_URI" ) , ( void ** ) & data ) == SUCCESS && <NEW_LINE> Z_TYPE_PP ( data ) == IS_STRING &&
if ( nsLayoutAtoms::tableRowFrame == aHighestType ) return rv ; <NEW_LINE> } <NEW_LINE> if ( aPseudoFrames . mRowGroup . mFrame ) { <NEW_LINE> <START_VULN> rv = ProcessPseudoFrame ( aPresContext , aPseudoFrames . mRowGroup , aHighestFrame ) ; <NEW_LINE> <END_VULN> if ( nsLayoutAtoms::tableRowGroupFrame == aHighestType ) return rv ; <NEW_LINE> } <NEW_LINE> if ( aPseudoFrames . mColGroup . mFrame ) {
} <NEW_LINE> pos += size ; <NEW_LINE> <START_VULN> assert ( pos <= stop ) ; <NEW_LINE> <END_VULN> }
else if ( ! ctx -> iface -> enc . get_preview ) <NEW_LINE> ctx -> err = VPX_CODEC_INCAPABLE ; <NEW_LINE> else <NEW_LINE> <START_VULN> img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return img ;
size_t mMaxBufferSize ; <NEW_LINE> MediaBufferGroup * mGroup ; <NEW_LINE> <START_VULN> void ( * mCopy ) ( short * dst , const int * const * src , unsigned nSamples , unsigned nChannels ) ; <NEW_LINE> <END_VULN> FLAC__StreamDecoder * mDecoder ;
chnMem . autoPortaDown = m . param ; <NEW_LINE> chnMem . autoTonePorta = 0 ; <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x07:
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: residue backend 0 , 1 and 2 implementation <NEW_LINE> <START_VULN> last mod: $ Id: res0 . c 16327 2009 - 07 - 24 00:49:25Z xiphmont $ <NEW_LINE> <END_VULN>
#ifdef DEBUG_rginda <NEW_LINE> fprintf ( stderr , " , % p" , maybe_glob ) ; <NEW_LINE> #endif <NEW_LINE> target_obj = maybe_glob ; <NEW_LINE> maybe_glob = JS_GetParent ( cx , maybe_glob ) ; <NEW_LINE> } <NEW_LINE> #ifdef DEBUG_rginda <NEW_LINE> fprintf ( stderr , "\n" ) ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> } <NEW_LINE> JSClass * target_class = JS_GET_CLASS ( cx , target_obj ) ; <NEW_LINE> if ( target_class -> flags & JSCLASS_IS_EXTENDED ) <NEW_LINE> { <NEW_LINE> JSExtendedClass * extended = ( JSExtendedClass * ) target_class ;
Bytecode * code = analysis -> maybeCode ( offset ) ; <NEW_LINE> if ( ! code ) <NEW_LINE> op = JSOP_NOP ; <NEW_LINE> bool finishChunk = false ; <NEW_LINE> <START_VULN> bool preserveChunk = false ; <NEW_LINE> <END_VULN> uint32_t type = JOF_TYPE ( js_CodeSpec [ op ] . format ) ; <NEW_LINE> if ( type == JOF_JUMP && op != JSOP_LABEL ) { <NEW_LINE> CrossChunkEdge edge ;
NP_HasProperty , <NEW_LINE> NP_GetProperty , <NEW_LINE> NP_SetProperty , <NEW_LINE> <START_VULN> 0 , <NEW_LINE> <END_VULN> NP_Enumerate , <NEW_LINE> NP_Construct <NEW_LINE> } ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File: apprentice . c , v 1 . 209 2014 / 05 / 13 16:42:17 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include "magic . h"
NS_IMETHODIMP <NEW_LINE> nsXPConnect::EvalInSandboxObject ( const nsAString & source , JSContext * cx , <NEW_LINE> nsIXPConnectJSObjectHolder * sandbox , <NEW_LINE> <START_VULN> jsval * rval ) <NEW_LINE> <END_VULN> { <NEW_LINE> #ifdef XPCONNECT_STANDALONE <NEW_LINE> return NS_ERROR_NOT_AVAILABLE ;
TFunctionSign3 , <NEW_LINE> TFunctionSign4 , <NEW_LINE> TFunctionUnknown <NEW_LINE> } ; <NEW_LINE> TBuiltInFunction IdentifyFunction ( TOperator op , const TType & returnType ) ; <NEW_LINE> <START_VULN> TVector < TBuiltInFunction > mFunctions ; <NEW_LINE> <END_VULN> unsigned int mFunctionGroupMask ; <NEW_LINE> } ; <NEW_LINE> #endif
{ <NEW_LINE> mDelayedShowDropDown = false ; <NEW_LINE> nsEventStates eventStates = mContent -> AsElement ( ) -> State ( ) ; <NEW_LINE> if ( aDoDropDown && eventStates . HasState ( NS_EVENT_STATE_DISABLED ) ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> if ( ! mDroppedDown && aDoDropDown ) { <NEW_LINE> <START_VULN> if ( mFocused == this ) { <NEW_LINE> <END_VULN> DropDownPositionState state = AbsolutelyPositionDropDown ( ) ; <NEW_LINE> if ( state == eDropDownPositionFinal ) { <NEW_LINE> ShowList ( aDoDropDown ) ; <NEW_LINE> } else if ( state == eDropDownPositionPendingResize ) { <NEW_LINE> mDelayedShowDropDown = true ; <NEW_LINE> } <NEW_LINE> } else {
<START_VULN> bool verify_authorizer ( Connection * con , int peer_type , int protocol , bufferlist & auth , bufferlist & auth_reply , <NEW_LINE>bool & isvalid , CryptoKey & session_key ) ; <NEW_LINE> <END_VULN>
JSBool <NEW_LINE> js_InflateUTF8StringToBuffer ( JSContext * cx , const char * src , size_t srclen , <NEW_LINE> <START_VULN> jschar * dst , size_t * dstlenp , bool useCESU8 ) <NEW_LINE> <END_VULN> { <NEW_LINE> size_t dstlen , origDstlen , offset , j , n ; <NEW_LINE> uint32 v ;
} <NEW_LINE> JS_REQUIRES_STACK AbortableRecordingStatus <NEW_LINE> TraceRecorder::record_JSOP_ARGSUB ( ) <NEW_LINE> { <NEW_LINE> JSStackFrame * fp = cx -> fp ; <NEW_LINE> if ( ! ( fp -> fun -> flags & JSFUN_HEAVYWEIGHT ) ) { <NEW_LINE> uintN slot = GET_ARGNO ( fp -> regs -> pc ) ; <NEW_LINE> <START_VULN> if ( slot < fp -> argc ) <NEW_LINE>stack ( 0 , get ( & cx -> fp -> argv [ slot ] ) ) ; <NEW_LINE>else <NEW_LINE>stack ( 0 , INS_VOID ( ) ) ; <NEW_LINE> <END_VULN> return ARECORD_CONTINUE ; <NEW_LINE> } <NEW_LINE> RETURN_STOP_A ( "can't trace JSOP_ARGSUB hard case" ) ; <NEW_LINE> } <NEW_LINE> JS_REQUIRES_STACK LIns * <NEW_LINE> TraceRecorder::guardArgsLengthNotAssigned ( LIns * argsobj_ins ) <NEW_LINE> {
size += EbmlElementSize ( kMkvCueTrack , track_ ) ; <NEW_LINE> if ( output_block_number_ && block_number_ > 1 ) <NEW_LINE> size += EbmlElementSize ( kMkvCueBlockNumber , block_number_ ) ; <NEW_LINE> <START_VULN> const uint64 track_pos_size = EbmlMasterElementSize ( kMkvCueTrackPositions , <NEW_LINE>size ) + size ; <NEW_LINE>const uint64 payload_size = EbmlElementSize ( kMkvCueTime , time_ ) + <NEW_LINE>track_pos_size ; <NEW_LINE> <END_VULN> if ( ! WriteEbmlMasterElement ( writer , kMkvCuePoint , payload_size ) ) <NEW_LINE> return false ;
} <NEW_LINE> <START_VULN> void open_input_file ( struct VpxInputContext * input ) { <NEW_LINE> <END_VULN> input -> file = strcmp ( input -> filename , " - " ) <NEW_LINE> ? fopen ( input -> filename , "rb" ) : set_binary_mode ( stdin ) ;
#if DCHECK_IS_ON ( ) <NEW_LINE> <START_VULN> scoped_refptr < ScrollPaintPropertyNode > Clone ( ) const { <NEW_LINE>return base::AdoptRef ( new ScrollPaintPropertyNode ( Parent ( ) , State ( state_ ) ) ) ; <NEW_LINE> <END_VULN> }
addr = compute_effective_address ( regs , insn , <NEW_LINE> ( ( insn >> 25 ) & 0x1f ) ) ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <NEW_LINE> <END_VULN> switch ( asi ) { <NEW_LINE> case ASI_NL: <NEW_LINE> case ASI_AIUPL:
return false ; <NEW_LINE> HeapObjectHeader * header = HeapObjectHeader::fromPayload ( address ) ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> NormalPageArena * arena = static_cast < NormalPage * > ( page ) -> arenaForNormalPage ( ) ;
void Track::set_language ( const char * language ) { <NEW_LINE> if ( language ) { <NEW_LINE> <START_VULN> delete [ ] language_ ; <NEW_LINE> <END_VULN> const size_t length = strlen ( language ) + 1 ; <NEW_LINE> language_ = new ( std::nothrow ) char [ length ] ;
function attemptServiceInstall ( aSkipTest ) { <NEW_LINE> <START_VULN> const CSIDL_PROGRAM_FILES = 0x26 ; <NEW_LINE>const CSIDL_PROGRAM_FILESX86 = 0x2A ; <NEW_LINE><NEW_LINE>let maintSvcDir = getSpecialFolderDir ( CSIDL_PROGRAM_FILESX86 ) ; <NEW_LINE>if ( maintSvcDir ) { <NEW_LINE>maintSvcDir . append ( "Mozilla Maintenance Service" ) ; <NEW_LINE>logTestInfo ( "using CSIDL_PROGRAM_FILESX86 - maintenance service install " + <NEW_LINE>"directory path: " + maintSvcDir . path ) ; <NEW_LINE> } <NEW_LINE>if ( ! maintSvcDir || ! maintSvcDir . exists ( ) ) { <NEW_LINE>maintSvcDir = getSpecialFolderDir ( CSIDL_PROGRAM_FILES ) ; <NEW_LINE>if ( maintSvcDir ) { <NEW_LINE>maintSvcDir . append ( "Mozilla Maintenance Service" ) ; <NEW_LINE>logTestInfo ( "using CSIDL_PROGRAM_FILES - maintenance service install " + <NEW_LINE>"directory path: " + maintSvcDir . path ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <END_VULN> if ( ! maintSvcDir || ! maintSvcDir . exists ( ) ) { <NEW_LINE> do_throw ( "maintenance service install directory doesn't exist ! " ) ; <NEW_LINE> } <NEW_LINE> let oldMaintSvcBin = maintSvcDir . clone ( ) ; <NEW_LINE> oldMaintSvcBin . append ( FILE_MAINTENANCE_SERVICE_BIN ) ; <NEW_LINE> if ( ! oldMaintSvcBin . exists ( ) ) { <NEW_LINE> do_throw ( "maintenance service install directory binary doesn't exist ! " + <NEW_LINE> "Path: " + oldMaintSvcBin . path ) ;
void OnDidGetPreviewPageCount ( <NEW_LINE> const PrintHostMsg_DidGetPreviewPageCount_Params & params ) ; <NEW_LINE> void OnDidPreviewPage ( const PrintHostMsg_DidPreviewPage_Params & params ) ; <NEW_LINE> <START_VULN> void OnCheckForCancel ( const std::string & preview_ui_addr , <NEW_LINE> <END_VULN> int preview_request_id , <NEW_LINE> bool * cancel ) ;
png_error ( png_ptr , "ASCII conversion buffer too small" ) ; <NEW_LINE> } <NEW_LINE> # endif <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #if defined ( PNG_FLOATING_POINT_SUPPORTED ) && \ <NEW_LINE> ! defined ( PNG_FIXED_POINT_MACRO_SUPPORTED ) && \
return UNKNOWN_ERROR ; <NEW_LINE> } <NEW_LINE> <START_VULN> BufferMeta * bufferMeta = new BufferMeta ( graphicBuffer ) ; <NEW_LINE> <END_VULN> OMX_BUFFERHEADERTYPE * header = NULL ; <NEW_LINE> OMX_U8 * bufferHandle = const_cast < OMX_U8 * > (
header [ 11 ] = ( rec -> length ) >> 8 ; <NEW_LINE> header [ 12 ] = ( rec -> length ) & 0xff ; <NEW_LINE> <START_VULN> if ( ! send && ! SSL_USE_ETM ( ssl ) && <NEW_LINE> <END_VULN> EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && <NEW_LINE> ssl3_cbc_record_digest_supported ( mac_ctx ) ) {
unsigned int svcrdma_max_bc_requests = RPCRDMA_MAX_BC_REQUESTS ; <NEW_LINE> static unsigned int min_max_requests = 4 ; <NEW_LINE> static unsigned int max_max_requests = 16384 ; <NEW_LINE> <START_VULN> unsigned int svcrdma_max_req_size = RPCRDMA_MAX_REQ_SIZE ; <NEW_LINE>static unsigned int min_max_inline = 4096 ; <NEW_LINE>static unsigned int max_max_inline = 65536 ; <NEW_LINE> <END_VULN> atomic_t rdma_stat_recv ; <NEW_LINE> atomic_t rdma_stat_read ;
backgroundCodegen_ ( NULL ) , <NEW_LINE> recompileInfo ( cx -> compartment -> types . compiledInfo ) , <NEW_LINE> cx ( cx ) , <NEW_LINE> abortReason_ ( AbortReason_Disable ) , <NEW_LINE> loopDepth_ ( loopDepth ) , <NEW_LINE> callerResumePoint_ ( NULL ) , <NEW_LINE> callerBuilder_ ( NULL ) , <NEW_LINE> oracle ( oracle ) , <NEW_LINE> <START_VULN> inliningDepth ( inliningDepth ) , <NEW_LINE> <END_VULN> failedBoundsCheck_ ( info -> script ( ) -> failedBoundsCheck ) , <NEW_LINE> failedShapeGuard_ ( info -> script ( ) -> failedShapeGuard ) , <NEW_LINE> lazyArguments_ ( NULL ) <NEW_LINE> { <NEW_LINE> script_ . init ( info -> script ( ) ) ; <NEW_LINE> pc = info -> startPC ( ) ; <NEW_LINE> }
} <NEW_LINE> else <NEW_LINE> { <NEW_LINE> <START_VULN> ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ; <NEW_LINE> <END_VULN> }
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> void generate_filename ( const char * pattern , char * out , size_t q_len , <NEW_LINE>unsigned int d_w , unsigned int d_h , <NEW_LINE>unsigned int frame_in ) { <NEW_LINE> <END_VULN> const char * p = pattern ; <NEW_LINE> char * q = out ;
#include < arm_neon . h > <NEW_LINE> <START_VULN> static const uint16_t bifilter4_coeff [ 8 ] [ 2 ] = { <NEW_LINE> <END_VULN> { 128 , 0 } , <NEW_LINE> { 112 , 16 } , <NEW_LINE> { 96 , 32 } ,
recorderTree = recorder -> getTree ( ) ; <NEW_LINE> shouldAbortRecording = HasUnreachableGCThings ( cx , recorderTree ) ; <NEW_LINE> } <NEW_LINE> for ( size_t i = 0 ; i < FRAGMENT_TABLE_SIZE ; ++ i ) { <NEW_LINE> TreeFragment ** fragp = & vmfragments [ i ] ; <NEW_LINE> while ( TreeFragment * frag = * fragp ) { <NEW_LINE> TreeFragment * peer = frag ; <NEW_LINE> do { <NEW_LINE> <START_VULN> if ( peer -> code ( ) && HasUnreachableGCThings ( cx , peer ) ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> peer = peer -> peer ; <NEW_LINE> } while ( peer ) ; <NEW_LINE> if ( ! peer ) { <NEW_LINE> fragp = & frag -> next ; <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> debug_only_printf ( LC_TMTracer ,
spl_filesystem_file_free_line ( intern TSRMLS_CC ) ; <NEW_LINE> ret = spl_filesystem_file_read_line_ex ( this_ptr , intern , silent TSRMLS_CC ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return ret ; <NEW_LINE> }
DocumentLoader * loader , <NEW_LINE> ResourceRequest & request , <NEW_LINE> const ResourceResponse & redirect_response , <NEW_LINE> <START_VULN> const FetchInitiatorInfo & ) { <NEW_LINE> <END_VULN> LocalFrame * frame = loader ? loader -> GetFrame ( ) : nullptr ; <NEW_LINE> TRACE_EVENT_INSTANT1 ( <NEW_LINE> "devtools . timeline" , "ResourceSendRequest" , TRACE_EVENT_SCOPE_THREAD ,
const TOKENEXTRA * stop = cpi -> tplist [ mb_row ] . stop ; <NEW_LINE> int tokens = ( int ) ( stop - p ) ; <NEW_LINE> <START_VULN> vp8_pack_tokens_c ( w , p , tokens ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
int flags = 0 ; <NEW_LINE> Elf32_Ehdr elf32hdr ; <NEW_LINE> Elf64_Ehdr elf64hdr ; <NEW_LINE> <START_VULN> uint16_t type , phnum , shnum ; <NEW_LINE> <END_VULN> if ( ms -> flags & ( MAGIC_MIME | MAGIC_APPLE ) ) <NEW_LINE> return 0 ;
int i ; <NEW_LINE> const int n = mv_class + CLASS0_BITS - 1 ; <NEW_LINE> for ( i = 0 ; i < n ; ++ i ) <NEW_LINE> <START_VULN> vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ; <NEW_LINE> <END_VULN> }
def = sfmt ( " { password:' % s' , roles: [ % s ] } " , encodedPassword , sjoinArgs ( argc - 3 , ( cchar ** ) & argv [ 3 ] , " , " ) ) ; <NEW_LINE> credentials = mprParseJson ( def ) ; <NEW_LINE> key = sfmt ( "app . http . auth . users . % s" , username ) ; <NEW_LINE> <START_VULN> if ( mprSetJsonObj ( app -> config , key , credentials ) < 0 ) { <NEW_LINE> <END_VULN> fail ( "Cannot update % s" , key ) ; <NEW_LINE> return ; <NEW_LINE> }
TrackTicks inputEndTicks = TimeToTicksRoundUp ( rate , inputEnd ) ; <NEW_LINE> TrackTicks inputStartTicks = inputEndTicks - ticks ; <NEW_LINE> <START_VULN> segment -> AppendSlice ( * inputTrack -> GetSegment ( ) , <NEW_LINE> <END_VULN> NS_MIN ( inputTrackEndPoint , inputStartTicks ) , <NEW_LINE> NS_MIN ( inputTrackEndPoint , inputEndTicks ) ) ; <NEW_LINE> LOG ( PR_LOG_DEBUG , ( "TrackUnionStream % p appending % lld ticks of input data to track % d" , <NEW_LINE> this , ( long long ) ( NS_MIN ( inputTrackEndPoint , inputEndTicks ) - NS_MIN ( inputTrackEndPoint , inputStartTicks ) ) , <NEW_LINE> outputTrack -> GetID ( ) ) ) ; <NEW_LINE> } <NEW_LINE> for ( uint32_t j = 0 ; j < mListeners . Length ( ) ; ++ j ) { <NEW_LINE> MediaStreamListener * l = mListeners [ j ] ;
class ResizeGripperDelegate { <NEW_LINE> <START_VULN> public: <NEW_LINE> <END_VULN>
return obj ; <NEW_LINE> } <NEW_LINE> JSObject * <NEW_LINE> ArrayBufferObject::createSlice ( JSContext * cx , ArrayBufferObject & arrayBuffer , <NEW_LINE> uint32_t begin , uint32_t end ) <NEW_LINE> { <NEW_LINE> <START_VULN> JS_ASSERT ( begin <= arrayBuffer . byteLength ( ) ) ; <NEW_LINE>JS_ASSERT ( end <= arrayBuffer . byteLength ( ) ) ; <NEW_LINE>JS_ASSERT ( begin <= end ) ; <NEW_LINE> <END_VULN> uint32_t length = end - begin ; <NEW_LINE> if ( arrayBuffer . hasData ( ) ) <NEW_LINE> return create ( cx , length , arrayBuffer . dataPointer ( ) + begin ) ; <NEW_LINE> return create ( cx , 0 ) ; <NEW_LINE> }
if ( args -> flags & ATTR_CREATE ) <NEW_LINE> return retval ; <NEW_LINE> retval = xfs_attr_shortform_remove ( args ) ; <NEW_LINE> <START_VULN> ASSERT ( retval == 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( args -> namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||
* s = ' / ' ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> s [ 1 ] = '\0' ; <NEW_LINE> <END_VULN> if ( resource -> path && * ( resource -> path ) == ' / ' && * ( resource -> path + 1 ) == '\0' ) { <NEW_LINE> snprintf ( loc_path , sizeof ( loc_path ) - 1 , " % s % s" , resource -> path , location ) ; <NEW_LINE> } else {
#include "config . h" <NEW_LINE> <START_VULN> #if USE ( THREADED_COMPOSITING ) <NEW_LINE><NEW_LINE> <END_VULN> #include "cc / CCLayerTreeHost . h" <NEW_LINE> #include "cc / CCLayerImpl . h" <NEW_LINE> #include "cc / CCLayerTreeHostImpl . h" <NEW_LINE> #include "cc / CCMainThreadTask . h" <NEW_LINE> #include "cc / CCThreadTask . h" <NEW_LINE> #include "GraphicsContext3DPrivate . h" <NEW_LINE> #include < gtest / gtest . h >
rv = ss -> ShareData ( aBuffer , aLen ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) <NEW_LINE> return rv ; <NEW_LINE> nsCOMPtr < nsIInputStream > inStream ( do_QueryInterface ( ss , & rv ) ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> <START_VULN> return mFinalListener -> OnDataAvailable ( mPartChannel , mContext , inStream , offset , aLen ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> PRInt32 <NEW_LINE> nsMultiMixedConv::PushOverLine ( char * & aPtr , PRUint32 & aLen ) { <NEW_LINE> PRInt32 chars = 0 ; <NEW_LINE> if ( ( aLen > 0 ) && ( * aPtr == nsCRT::CR || * aPtr == nsCRT::LF ) ) { <NEW_LINE> if ( ( aLen > 1 ) && ( aPtr [ 1 ] == nsCRT::LF ) ) <NEW_LINE> chars ++ ;
JSObject * argv6 = JSVAL_TO_OBJECT ( argv [ 6 ] ) ; <NEW_LINE> jsval js_width , js_height , js_data ; <NEW_LINE> JS_GetProperty ( cx , argv6 , "width" , & js_width ) ; <NEW_LINE> JS_GetProperty ( cx , argv6 , "height" , & js_height ) ; <NEW_LINE> JS_GetProperty ( cx , argv6 , "data" , & js_data ) ; <NEW_LINE> if ( js_width == JSVAL_VOID || <NEW_LINE> js_height == JSVAL_VOID || <NEW_LINE> <START_VULN> js_data == JSVAL_VOID ) <NEW_LINE> <END_VULN> { <NEW_LINE> xpc_qsThrowBadArg ( cx , NS_ERROR_FAILURE , vp , 6 ) ; <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> int32_t int_width , int_height ; <NEW_LINE> JSObject * obj_data = JSVAL_TO_OBJECT ( js_data ) ; <NEW_LINE> if ( ! JS_ValueToECMAInt32 ( cx , js_width , & int_width ) || <NEW_LINE> ! JS_ValueToECMAInt32 ( cx , js_height , & int_height ) )
ds = s + 1 ; <NEW_LINE> if ( s ) <NEW_LINE> <START_VULN> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <NEW_LINE> <END_VULN> if ( NULL == tmp ) <NEW_LINE> {
bool mFinished ; <NEW_LINE> } ; <NEW_LINE> void <NEW_LINE> nsPluginInstanceOwner::NotifyPaintWaiter ( nsDisplayListBuilder * aBuilder ) <NEW_LINE> { <NEW_LINE> if ( ! mWaitingForPaint && ! IsUpToDate ( ) && aBuilder -> ShouldSyncDecodeImages ( ) ) { <NEW_LINE> <START_VULN> nsCOMPtr < nsIRunnable > event = new AsyncPaintWaitEvent ( mContent , false ) ; <NEW_LINE> <END_VULN> mWaitingForPaint = nsContentUtils::AddScriptRunner ( event ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> already_AddRefed < ImageContainer > <NEW_LINE> nsPluginInstanceOwner::GetImageContainer ( )
else if ( row_info -> bit_depth == 16 ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( at_start ) <NEW_LINE> <END_VULN> sp += 2 ; <NEW_LINE> else <NEW_LINE> sp += 4 , dp += 2 ;
DISALLOW_COPY_AND_ASSIGN ( ChromeWebUIControllerFactory ) ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
char name [ 256 ] ; <NEW_LINE> strcpy ( name , hdr -> prefix ) ; <NEW_LINE> <START_VULN> strcat ( name , hdr -> name ) ; <NEW_LINE> <END_VULN> entry . filename_len = strlen ( hdr -> prefix ) + 100 ; <NEW_LINE> if ( name [ entry . filename_len - 1 ] == ' / ' ) {
<START_VULN> if ( pCmdData == NULL || <NEW_LINE>cmdSize < ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || <NEW_LINE>pReplyData == NULL || <NEW_LINE> * replySize != sizeof ( int32_t ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Volume_command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_SET_PARAM: ERROR" ) ; <NEW_LINE> return - EINVAL ;
} <NEW_LINE> nsTArray < JSGCCallback > callbacks ( self -> extraGCCallbacks ) ; <NEW_LINE> for ( PRUint32 i = 0 ; i < callbacks . Length ( ) ; ++ i ) <NEW_LINE> callbacks [ i ] ( rt , status ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> <START_VULN> XPCJSRuntime::FinalizeCallback ( JSFreeOp * fop , JSFinalizeStatus status ) <NEW_LINE> <END_VULN> { <NEW_LINE> XPCJSRuntime * self = nsXPConnect::GetRuntimeInstance ( ) ; <NEW_LINE> if ( ! self ) <NEW_LINE> return ; <NEW_LINE> switch ( status ) { <NEW_LINE> case JSFINALIZE_START: <NEW_LINE> {
extern struct _mdi * _WM_initMDI ( void ) ; <NEW_LINE> extern void _WM_freeMDI ( struct _mdi * mdi ) ; <NEW_LINE> <START_VULN> extern uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) ; <NEW_LINE> <END_VULN> extern void _WM_ResetToStart ( struct _mdi * mdi ) ; <NEW_LINE> extern void _WM_do_pan_adjust ( struct _mdi * mdi , uint8_t ch ) ; <NEW_LINE> extern void _WM_do_note_off_extra ( struct _note * nte ) ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . idbKey" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( RefPtr < IDBKey > , key , createIDBKeyFromValue ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> imp -> idbKey ( key . get ( ) ) ;
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "cert . h" <NEW_LINE> #include "ssl . h" <NEW_LINE> #include "cryptohi . h" <NEW_LINE> #include "keyhi . h" <NEW_LINE> #include "secder . h" <NEW_LINE> #include "secitem . h"
int __init CVE_2008_3527_sysenter_setup ( void ) <NEW_LINE> { <NEW_LINE> <START_VULN> syscall_page = ( void * ) get_zeroed_page ( GFP_ATOMIC ) ; <NEW_LINE> <END_VULN> #ifdef CONFIG_COMPAT_VDSO <NEW_LINE> __set_fixmap ( FIX_VDSO , __pa ( syscall_page ) , PAGE_READONLY ) ;
else if ( NormalizeIDN ( flat , hostBuf ) ) { <NEW_LINE> host = hostBuf . get ( ) ; <NEW_LINE> len = hostBuf . Length ( ) ; <NEW_LINE> } <NEW_LINE> else <NEW_LINE> len = flat . Length ( ) ; <NEW_LINE> if ( mHost . mLen < 0 ) { <NEW_LINE> <START_VULN> mHost . mPos = mAuthority . mPos ; <NEW_LINE> <END_VULN> mHost . mLen = 0 ; <NEW_LINE> } <NEW_LINE> int32_t shift = ReplaceSegment ( mHost . mPos , mHost . mLen , host , len ) ; <NEW_LINE> if ( shift ) { <NEW_LINE> mHost . mLen = len ; <NEW_LINE> mAuthority . mLen += shift ;
} <NEW_LINE> static void perf_swevent_event ( struct perf_event * event , u64 nr , <NEW_LINE> <START_VULN> int nmi , struct perf_sample_data * data , <NEW_LINE> <END_VULN> struct pt_regs * regs ) <NEW_LINE> { <NEW_LINE> struct hw_perf_event * hwc = & event -> hw ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> long WebPImage::getHeaderOffset ( byte * data , long data_size , <NEW_LINE>byte * header , long header_size ) { <NEW_LINE> <END_VULN> long pos = - 1 ; <NEW_LINE> for ( long i = 0 ; i < data_size - header_size ; i ++ ) { <NEW_LINE> if ( memcmp ( header , & data [ i ] , header_size ) == 0 ) {
if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , "vertical_byte" , 0 ) ) ) { <NEW_LINE> if ( gfx . data . bpp == 1 ) <NEW_LINE> gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ; <NEW_LINE> <START_VULN> else <NEW_LINE>jsWarn ( "vertical_byte only works for 1bpp ArrayBuffers\n" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JsVar * colorv = jsvObjectGetChild ( options , "color_order" , 0 ) ; <NEW_LINE> if ( colorv ) {
Element * GetElement ( ) const { return element_ ; } <NEW_LINE> const ContainerNode * ParentNode ( ) const { return parent_node_ ; } <NEW_LINE> const ContainerNode * LayoutParent ( ) const { return layout_parent_ ; } <NEW_LINE> <START_VULN> const ComputedStyle * RootElementStyle ( ) const { return root_element_style_ ; } <NEW_LINE> <END_VULN> const ComputedStyle * ParentStyle ( ) const { <NEW_LINE> return ParentNode ( ) && ParentNode ( ) -> IsElementNode ( ) <NEW_LINE> ? ParentNode ( ) -> GetComputedStyle ( )
precache = true ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) ) { <NEW_LINE> <END_VULN>
SkAutoSTMalloc ( size_t count ) { <NEW_LINE> if ( count > kCount ) { <NEW_LINE> <START_VULN> fPtr = ( T * ) sk_malloc_flags ( count * sizeof ( T ) , SK_MALLOC_THROW | SK_MALLOC_TEMP ) ; <NEW_LINE> <END_VULN> } else if ( count ) { <NEW_LINE> fPtr = fTStorage ; <NEW_LINE> } else {
beforeChildParent = toRenderBlock ( lastChild ( ) ) ; <NEW_LINE> <START_VULN> if ( newChild -> isFloatingOrPositioned ( ) ) { <NEW_LINE> <END_VULN> beforeChildParent -> addChildIgnoringAnonymousColumnBlocks ( newChild , beforeChild ) ; <NEW_LINE> return ; <NEW_LINE> }
class nsBindingManager ; <NEW_LINE> class nsIDOMNodeList ; <NEW_LINE> class mozAutoSubtreeModified ; <NEW_LINE> struct JSObject ; <NEW_LINE> class nsFrameLoader ; <NEW_LINE> #define NS_IDOCUMENT_IID \ <NEW_LINE> <START_VULN> { 0x5f0203a8 , 0xd926 , 0x4adf , \ <NEW_LINE> { 0xba , 0x96 , 0xe6 , 0xc3 , 0xe6 , 0xbb , 0x1b , 0xe5 } } <NEW_LINE> <END_VULN> #define NS_STYLESHEET_FROM_CATALOG ( 1 << 0 )
if ( * endptr || umask_long < 0 || umask_long & ~ 0777L ) { <NEW_LINE> fprintf ( stderr , "Invalid -- umask option % s" , optarg ) ; <NEW_LINE> <START_VULN> return ; <NEW_LINE> <END_VULN> } <NEW_LINE> umask_val = umask_long & 0777 ;
{ <NEW_LINE> assign ( 0 ) ; <NEW_LINE> return reinterpret_cast < void ** > ( & mRawPtr ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> assign ( T * newPtr ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ABORT_IF_FALSE ( mRawPtr != newPtr || ! newPtr , "This makes no sense ! " ) ; <NEW_LINE> <END_VULN> T * oldPtr = mRawPtr ; <NEW_LINE> mRawPtr = newPtr ; <NEW_LINE> delete oldPtr ; <NEW_LINE> }
zval_dtor ( * zcount ) ; <NEW_LINE> ZVAL_LONG ( * zcount , replace_count ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> }
ctxt = xmlSchemaNewValidCtxt ( schema ) ; <NEW_LINE> xmlSchemaSetValidErrors ( ctxt , <NEW_LINE> <START_VULN> ( xmlSchemaValidityErrorFunc ) fprintf , <NEW_LINE> ( xmlSchemaValidityWarningFunc ) fprintf , <NEW_LINE>stderr ) ; <NEW_LINE> <END_VULN> ret = xmlSchemaValidateDoc ( ctxt , doc ) ; <NEW_LINE> if ( ret == 0 ) { <NEW_LINE> printf ( " % s validates\n" , argv [ i ] ) ;
} <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
{ BGP_ATTR_AS_PATHLIMIT , "AS_PATHLIMIT" } , <NEW_LINE> { BGP_ATTR_PMSI_TUNNEL , "PMSI_TUNNEL_ATTRIBUTE" } , <NEW_LINE> { BGP_ATTR_ENCAP , "ENCAP" } , <NEW_LINE> <START_VULN> #if ENABLE_BGP_VNC <NEW_LINE> <END_VULN> { BGP_ATTR_VNC , "VNC" } , <NEW_LINE> #endif <NEW_LINE> { BGP_ATTR_LARGE_COMMUNITIES , "LARGE_COMMUNITY" } ,
if ( ( ms -> flags & MAGIC_CHECK ) == 0 ) <NEW_LINE> return 0 ; <NEW_LINE> <START_VULN> if ( m -> type != FILE_PSTRING && ( m -> str_flags & PSTRING_LEN ) != 0 ) { <NEW_LINE> <END_VULN> file_magwarn ( ms , <NEW_LINE> "' / BHhLl' modifiers are only allowed for pascal strings\n" ) ; <NEW_LINE> return - 1 ;
if ( m_context . isEmpty ( ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( document -> hasNamedItem ( name . impl ( ) ) || document -> hasExtraNamedItem ( name . impl ( ) ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> v8::HandleScope handleScope ( m_isolate ) ;
png_ptr -> background = * background_color ; <NEW_LINE> png_ptr -> background_gamma = background_gamma ; <NEW_LINE> png_ptr -> background_gamma_type = ( png_byte ) ( background_gamma_code ) ; <NEW_LINE> <START_VULN> if ( need_expand ) <NEW_LINE> <END_VULN> png_ptr -> transformations |= PNG_BACKGROUND_EXPAND ; <NEW_LINE> else <NEW_LINE> png_ptr -> transformations &= ~ PNG_BACKGROUND_EXPAND ;
LIBRAW_WARN_RAWSPEED_PROBLEM = 1 << 12 , <NEW_LINE> LIBRAW_WARN_RAWSPEED_UNSUPPORTED = 1 << 13 , <NEW_LINE> LIBRAW_WARN_RAWSPEED_PROCESSED = 1 << 14 , <NEW_LINE> <START_VULN> LIBRAW_WARN_FALLBACK_TO_AHD = 1 << 15 <NEW_LINE> <END_VULN> } ; <NEW_LINE> enum LibRaw_exceptions
nsIFrame * kidFrame = mFrames . FirstChild ( ) ; <NEW_LINE> nsIScrollableFrame * scrollingFrame = do_QueryFrame ( kidFrame ) ; <NEW_LINE> if ( scrollingFrame ) { <NEW_LINE> nsMargin scrollbars = scrollingFrame -> GetActualScrollbarSizes ( ) ; <NEW_LINE> aReflowState -> SetComputedWidth ( aReflowState -> ComputedWidth ( ) - <NEW_LINE> scrollbars . LeftRight ( ) ) ; <NEW_LINE> aReflowState -> availableWidth - = scrollbars . LeftRight ( ) ; <NEW_LINE> <START_VULN> aReflowState -> SetComputedHeight ( aReflowState -> ComputedHeight ( ) - <NEW_LINE>scrollbars . TopBottom ( ) ) ; <NEW_LINE><NEW_LINE> <END_VULN> return nsPoint ( scrollbars . left , scrollbars . top ) ; <NEW_LINE> } <NEW_LINE> return nsPoint ( 0 , 0 ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> ViewportFrame::Reflow ( nsPresContext * aPresContext , <NEW_LINE> nsHTMLReflowMetrics & aDesiredSize ,
EXPECT_EQ ( kNotificationBody , notificationData . body ) ; <NEW_LINE> EXPECT_EQ ( kNotificationTag , notificationData . tag ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> ASSERT_EQ ( vibrationPattern . size ( ) , notificationData . vibrate . size ( ) ) ; <NEW_LINE> for ( size_t i = 0 ; i < vibrationPattern . size ( ) ; ++ i )
SECItem dsasig ; <NEW_LINE> rv = SECFailure ; <NEW_LINE> cx = vfy_CreateContext ( key , sig , encAlg , hashAlg , NULL , wincx ) ; <NEW_LINE> if ( cx != NULL ) { <NEW_LINE> switch ( key -> keyType ) { <NEW_LINE> case rsaKey: <NEW_LINE> <START_VULN> if ( ( digest -> len != cx -> rsadigestlen ) || <NEW_LINE>PORT_Memcmp ( digest -> data , cx -> u . buffer , digest -> len ) ) { <NEW_LINE>PORT_SetError ( SEC_ERROR_BAD_SIGNATURE ) ; <NEW_LINE> } else { <NEW_LINE>rv = SECSuccess ; <NEW_LINE> } <NEW_LINE> <END_VULN> break ; <NEW_LINE> case dsaKey: <NEW_LINE> case ecKey: <NEW_LINE> dsasig . data = cx -> u . buffer ; <NEW_LINE> dsasig . len = SECKEY_SignatureLen ( cx -> key ) ; <NEW_LINE> if ( dsasig . len == 0 ) { <NEW_LINE> break ; <NEW_LINE> }
unsigned height , <NEW_LINE> GLenum format , <NEW_LINE> GLenum type , <NEW_LINE> <START_VULN> unsigned unpack_alignment , <NEW_LINE> <END_VULN> bool flip_y , <NEW_LINE> bool premultiply_alpha , <NEW_LINE> const void * pixels ,
#include "base / synchronization / lock . h" <NEW_LINE> #include "base / synchronization / waitable_event . h" <NEW_LINE> #include "base / threading / thread . h" <NEW_LINE> <START_VULN> #include "chrome / browser / chromeos / audio_mixer . h" <NEW_LINE> <END_VULN> class PrefService ;
if ( aIncludeRoot ) { <NEW_LINE> if ( Match ( aContent ) ) { <NEW_LINE> <START_VULN> mElements . AppendElement ( aContent ) ; <NEW_LINE> <END_VULN> -- aElementsToAppend ; <NEW_LINE> if ( aElementsToAppend == 0 ) <NEW_LINE> return ;
String packet_end ( ) ; <NEW_LINE> bool serialize_value ( const Variant & varVariant ) ; <NEW_LINE> bool recursiveAddVar ( const String & varName , const Variant & varVariant , <NEW_LINE> <START_VULN> bool hasVarTag ) ; <NEW_LINE> <END_VULN> private: <NEW_LINE> String getWddxEncoded ( const String & varType ,
Sprinter sprinter ( cx ) ; <NEW_LINE> sprinter . init ( ) ; <NEW_LINE> size_t depth = 0 ; <NEW_LINE> for ( StackIter i ( cx ) ; ! i . done ( ) ; ++ i , ++ depth ) { <NEW_LINE> if ( i . isScript ( ) ) { <NEW_LINE> const char * filename = JS_GetScriptFilename ( cx , i . script ( ) ) ; <NEW_LINE> unsigned line = JS_PCToLineNumber ( cx , i . script ( ) , i . pc ( ) ) ; <NEW_LINE> sprinter . printf ( "# % d % 14p % s: % d ( % p @ % d ) \n" , <NEW_LINE> <START_VULN> depth , ( i . isIon ( ) ? 0 : i . fp ( ) ) , filename , line , <NEW_LINE> <END_VULN> i . script ( ) , i . pc ( ) - i . script ( ) -> code ) ; <NEW_LINE> } else { <NEW_LINE> sprinter . printf ( "# % d ? ? ? \n" , depth ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> fprintf ( stdout , " % s" , sprinter . string ( ) ) ;
status_t SampleTable::setTimeToSampleParams ( <NEW_LINE> off64_t data_offset , size_t data_size ) { <NEW_LINE> <START_VULN> if ( mTimeToSample != NULL || data_size < 8 ) { <NEW_LINE> <END_VULN> return ERROR_MALFORMED ; <NEW_LINE> }
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> e * ( toe ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
#endif <NEW_LINE> #ifdef PNG_WRITE_sPLT_SUPPORTED <NEW_LINE> <START_VULN> if ( info_ptr -> valid & PNG_INFO_sPLT ) <NEW_LINE> <END_VULN> for ( i = 0 ; i < ( int ) info_ptr -> splt_palettes_num ; i ++ ) <NEW_LINE> png_write_sPLT ( png_ptr , info_ptr -> splt_palettes + i ) ; <NEW_LINE> #endif
} else { <NEW_LINE> fit_valueB [ ln ] = ly0 ; <NEW_LINE> if ( ln == 0 ) fit_valueA [ ln ] = ly0 ; <NEW_LINE> fit_valueA [ i ] = ly1 ; <NEW_LINE> fit_valueB [ i ] = hy0 ; <NEW_LINE> fit_valueA [ hn ] = hy1 ; <NEW_LINE> if ( hn == 1 ) fit_valueB [ hn ] = hy1 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ly1 >= 0 || hy0 >= 0 ) { <NEW_LINE> for ( j = sortpos - 1 ; j >= 0 ; j -- ) <NEW_LINE> if ( hineighbor [ j ] == hn ) <NEW_LINE> hineighbor [ j ] = i ; <NEW_LINE> else <NEW_LINE> break ; <NEW_LINE> for ( j = sortpos + 1 ; j < posts ; j ++ )
} <NEW_LINE> template < typename Base , typename Traits > <NEW_LINE> bool <NEW_LINE> XrayWrapper < Base , Traits > ::enumerate ( JSContext * cx , JSObject * wrapper , unsigned flags , <NEW_LINE> JS::AutoIdVector & props ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( XrayUtils::IsTransparent ( cx , wrapper ) ) { <NEW_LINE> <END_VULN> JSObject * obj = Traits::getTargetObject ( wrapper ) ; <NEW_LINE> JSAutoCompartment ac ( cx , obj ) ; <NEW_LINE> return js::GetPropertyNames ( cx , obj , flags , & props ) ; <NEW_LINE> } <NEW_LINE> if ( ! AccessCheck::wrapperSubsumes ( wrapper ) ) { <NEW_LINE> JS_ReportError ( cx , "Not allowed to enumerate cross origin objects" ) ; <NEW_LINE> return false ;
nsCOMPtr < nsIChannel > channel ; <NEW_LINE> nsresult rv = OpenContentStream ( PR_TRUE , getter_AddRefs ( stream ) , <NEW_LINE> getter_AddRefs ( channel ) ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) <NEW_LINE> return rv ; <NEW_LINE> NS_ASSERTION ( ! stream || ! channel , "Got both a channel and a stream ? " ) ; <NEW_LINE> <START_VULN> if ( channel ) <NEW_LINE>return NS_DispatchToCurrentThread ( new RedirectRunnable ( this , channel ) ) ; <NEW_LINE> <END_VULN> rv = nsInputStreamPump::Create ( getter_AddRefs ( mPump ) , stream , - 1 , - 1 , 0 , 0 ,
gplot -> plotstyles = numaReadStream ( fp ) ; <NEW_LINE> ignore = fscanf ( fp , "Number of plots: % d\n" , & gplot -> nplots ) ; <NEW_LINE> <START_VULN> ignore = fscanf ( fp , "Output file name: % s\n" , buf ) ; <NEW_LINE> <END_VULN> stringReplace ( & gplot -> outname , buf ) ; <NEW_LINE> ignore = fscanf ( fp , "Axis scaling: % d\n" , & gplot -> scaling ) ;
v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m08_p24 ) ; <NEW_LINE> v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m08_p24 ) ; <NEW_LINE> <START_VULN> v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ; <NEW_LINE>v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_m08 ) ; <NEW_LINE>v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m08_p24 ) ; <NEW_LINE>v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m08_p24 ) ; <NEW_LINE> <END_VULN> v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ; <NEW_LINE> v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;
static bool shouldSkipCreatingRunsForObject ( RenderObject * obj ) <NEW_LINE> { <NEW_LINE> <START_VULN> return obj -> isFloating ( ) || ( obj -> isPositioned ( ) && ! obj -> style ( ) -> isOriginalDisplayInlineType ( ) && ! obj -> container ( ) -> isRenderInline ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void appendRunsForObject ( BidiRunList < BidiRun > & , int start , int end , RenderObject * , InlineBidiResolver & ) ;
Vector < uint8_t > request ; <NEW_LINE> String8 defaultUrl ; <NEW_LINE> <START_VULN> DrmPlugin::KeyRequestType keyRequestType ; <NEW_LINE> <END_VULN> status_t result = getKeyRequest ( sessionId , initData , mimeType , <NEW_LINE> keyType , optionalParameters , request , defaultUrl ,
template < typename T , typename . . . Args > <NEW_LINE> std::unique_ptr < T > QuicMakeUniqueImpl ( Args && . . . args ) { <NEW_LINE> <START_VULN> return base::MakeUnique < T > ( std::forward < Args > ( args ) . . . ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> template < typename T >
uint16_t prev_hdrextlen = hdrextlen ; <NEW_LINE> hdrextlen = sizeof ( IPV6FragHdr ) ; <NEW_LINE> if ( hdrextlen > plen ) { <NEW_LINE> <START_VULN> ENGINE_SET_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <NEW_LINE> <END_VULN> SCReturn ; <NEW_LINE> }
number_lines ++ ; <NEW_LINE> textlist = AcquireQuantumMemory ( number_lines + 1 , sizeof ( * textlist ) ) ; <NEW_LINE> if ( textlist == ( char ** ) NULL ) <NEW_LINE> <START_VULN> return ( MagickFalse ) ; <NEW_LINE> <END_VULN> p = text ; <NEW_LINE> for ( i = 0 ; i < number_lines ; i ++ ) <NEW_LINE> {
mbd -> current_bc = & pbi -> mbc [ 0 ] ; <NEW_LINE> <START_VULN> vpx_memcpy ( mbd -> dequant_y1_dc , xd -> dequant_y1_dc , sizeof ( xd -> dequant_y1_dc ) ) ; <NEW_LINE>vpx_memcpy ( mbd -> dequant_y1 , xd -> dequant_y1 , sizeof ( xd -> dequant_y1 ) ) ; <NEW_LINE>vpx_memcpy ( mbd -> dequant_y2 , xd -> dequant_y2 , sizeof ( xd -> dequant_y2 ) ) ; <NEW_LINE>vpx_memcpy ( mbd -> dequant_uv , xd -> dequant_uv , sizeof ( xd -> dequant_uv ) ) ; <NEW_LINE> <END_VULN> mbd -> fullpixel_mask = 0xffffffff ;
class SuccessCallbackImpl FINAL : public SuccessCallback { <NEW_LINE> public: <NEW_LINE> <START_VULN> static PassOwnPtr < SuccessCallbackImpl > create ( PassRefPtr < HelperType > helper ) <NEW_LINE> <END_VULN> { <NEW_LINE> return adoptPtr ( new SuccessCallbackImpl ( helper ) ) ; <NEW_LINE> }
return - 1 ; <NEW_LINE> } <NEW_LINE> fclose ( pathfile ) ; <NEW_LINE> <START_VULN> if ( mount ( hostpath , path , 0 , MS_BIND , NULL ) != 0 ) { <NEW_LINE> <END_VULN> SYSERROR ( "Failed bind mounting device % s from host into container" , <NEW_LINE> d -> name ) ; <NEW_LINE> return - 1 ;
LayoutUnit crossExtent = crossAxisExtent ( ) ; <NEW_LINE> for ( RenderBox * child = iterator . first ( ) ; child ; child = iterator . next ( ) ) { <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> LayoutPoint location = flowAwareLocationForChild ( child ) ; <NEW_LINE> location . setY ( crossExtent - crossAxisExtentForChild ( child ) - location . y ( ) ) ;
break ; <NEW_LINE> case ARPOP_REVREPLY: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " % s at % s" , <NEW_LINE>linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <NEW_LINE>ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case ARPOP_INVREQUEST:
while ( 1 ) <NEW_LINE> { <NEW_LINE> <START_VULN> ret = poll ( & pfd , 1 , 1 ) ; <NEW_LINE> <END_VULN> BTIF_TRACE_VERBOSE ( " % s ( ) - polling fd % d , revents: 0x % x , ret % d" , <NEW_LINE> __FUNCTION__ , pfd . fd , pfd . revents , ret ) ;
<START_VULN> #ifndef BASE_ANDROID_TRACE_EVENT_H_ <NEW_LINE>#define BASE_ANDROID_TRACE_EVENT_H_ <NEW_LINE> <END_VULN> #include < jni . h >
<< reinterpret_cast < const size_t * > ( tr . data . ptr . offsets ) << endl ; <NEW_LINE> } <NEW_LINE> if ( tr . target . ptr ) { <NEW_LINE> <START_VULN> sp < BBinder > b ( ( BBinder * ) tr . cookie ) ; <NEW_LINE>error = b -> transact ( tr . code , buffer , & reply , tr . flags ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> error = the_context_object -> transact ( tr . code , buffer , & reply , tr . flags ) ;
if ( index < 0 || index >= ( int ) touches . size ( ) ) <NEW_LINE> return JSValueMakeUndefined ( context ) ; <NEW_LINE> <START_VULN> touches [ index ] . m_state = BlackBerry::Platform::TouchPoint::TouchReleased ; <NEW_LINE> <END_VULN> return JSValueMakeUndefined ( context ) ; <NEW_LINE> }
if ( ! src -> trueColor ) { <NEW_LINE> gdImagePaletteToTrueColor ( src ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> gdAffineTranslate ( m , - bbox . x , - bbox . y ) ; <NEW_LINE> gdAffineConcat ( m , affine , m ) ;
if ( oldfp && oldfp != down ) { <NEW_LINE> JS_ASSERT ( ! oldfp -> dormantNext ) ; <NEW_LINE> oldfp -> dormantNext = cx -> dormantFrameChain ; <NEW_LINE> cx -> dormantFrameChain = oldfp ; <NEW_LINE> } <NEW_LINE> cx -> fp = & frame ; <NEW_LINE> if ( ! down ) { <NEW_LINE> <START_VULN> OBJ_TO_OUTER_OBJECT ( cx , frame . thisp ) ; <NEW_LINE> <END_VULN> if ( ! frame . thisp ) { <NEW_LINE> ok = JS_FALSE ; <NEW_LINE> goto out2 ; <NEW_LINE> } <NEW_LINE> frame . flags |= JSFRAME_COMPUTED_THIS ; <NEW_LINE> } <NEW_LINE> if ( hook ) {
nsCxPusher pusher ; <NEW_LINE> NS_ENSURE_STATE ( pusher . Push ( aTarget ) ) ; <NEW_LINE> rv = EnsureEventHandler ( boundGlobal , boundContext , onEventAtom , handler ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> JSContext * cx = boundContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSObject * globalObject = boundGlobal -> GetGlobalJSObject ( ) ; <NEW_LINE> JSObject * scopeObject = xpc::GetXBLScope ( cx , globalObject ) ;
if ( ! logged ) { <NEW_LINE> NS_ConvertUTF16toUTF8 msg ( aMessage ) ; <NEW_LINE> #ifdef ANDROID <NEW_LINE> <START_VULN> __android_log_print ( ANDROID_LOG_INFO , "Gecko" , msg . get ( ) ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> fputs ( msg . get ( ) , stderr ) ; <NEW_LINE> fflush ( stderr ) ;
AutoValueVector vals ( cx ) ; <NEW_LINE> if ( ! vals . resize ( keys . length ( ) ) ) <NEW_LINE> return false ; <NEW_LINE> for ( size_t i = 0 , len = keys . length ( ) ; i < len ; i ++ ) { <NEW_LINE> jsid id = keys [ i ] ; <NEW_LINE> if ( JSID_IS_INT ( id ) ) { <NEW_LINE> <START_VULN> JSString * str = js_IntToString ( cx , JSID_TO_INT ( id ) ) ; <NEW_LINE> <END_VULN> if ( ! str ) <NEW_LINE> return false ; <NEW_LINE> vals [ i ] . setString ( str ) ; <NEW_LINE> } else if ( JSID_IS_ATOM ( id ) ) { <NEW_LINE> vals [ i ] . setString ( JSID_TO_STRING ( id ) ) ; <NEW_LINE> } else { <NEW_LINE> vals [ i ] . setObject ( * JSID_TO_OBJECT ( id ) ) ; <NEW_LINE> }
txFnEndCopy ( txStylesheetCompilerState & aState ) <NEW_LINE> { <NEW_LINE> nsAutoPtr < txInstruction > instr ( new txEndElement ) ; <NEW_LINE> NS_ENSURE_TRUE ( instr , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> nsresult rv = aState . addInstruction ( instr ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> txCopy * copy = static_cast < txCopy * > ( aState . popPtr ( ) ) ; <NEW_LINE> <END_VULN> rv = aState . addGotoTarget ( & copy -> mBailTarget ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> xsl:copy - of
char * sub_name ; <NEW_LINE> int len ; <NEW_LINE> char slash = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_UNIXPATHS ) ? ' / ' : DEFAULT_SLASH ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
mState = mState_GB2312_1980 ; <NEW_LINE> mRunLength = 0 ; <NEW_LINE> } else if ( 'B' == * src ) { <NEW_LINE> mState = mState_JISX0208_1983 ; <NEW_LINE> mRunLength = 0 ; <NEW_LINE> } else if ( ' ( ' == * src ) { <NEW_LINE> mState = mState_ESC_24_28 ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> if ( ( dest + 3 ) >= destEnd ) <NEW_LINE> <END_VULN> goto error1 ; <NEW_LINE> * dest ++ = ( PRUnichar ) 0x1b ; <NEW_LINE> * dest ++ = ( PRUnichar ) ' $ ' ; <NEW_LINE> if ( 0x80 & * src ) <NEW_LINE> goto error2 ; <NEW_LINE> * dest ++ = ( PRUnichar ) * src ; <NEW_LINE> mState = mLastLegalState ; <NEW_LINE> }
RenderStyle * blockStyle = block -> style ( ) ; <NEW_LINE> <START_VULN> m_canCollapseWithChildren = ! block -> isRenderView ( ) && ! block -> isRoot ( ) && ! block -> isPositioned ( ) <NEW_LINE> <END_VULN> && ! block -> isFloating ( ) && ! block -> isTableCell ( ) && ! block -> hasOverflowClip ( ) && ! block -> isInlineBlockOrInlineTable ( ) <NEW_LINE> && ! block -> isWritingModeRoot ( ) && blockStyle -> hasAutoColumnCount ( ) && blockStyle -> hasAutoColumnWidth ( ) <NEW_LINE> && ! blockStyle -> columnSpan ( ) ;
<START_VULN> return - ( png_int_32 ) uval ; <NEW_LINE> <END_VULN> }
JSContext::typeInferenceEnabled ( ) const <NEW_LINE> { <NEW_LINE> return compartment -> types . inferenceEnabled ; <NEW_LINE> } <NEW_LINE> inline js::Handle < js::GlobalObject * > <NEW_LINE> JSContext::global ( ) const <NEW_LINE> { <NEW_LINE> <START_VULN> return js::Handle < js::GlobalObject * > ::fromMarkedLocation ( & compartment -> global_ ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> namespace js { <NEW_LINE> class AssertCompartmentUnchanged { <NEW_LINE> protected: <NEW_LINE> JSContext * const cx ; <NEW_LINE> JSCompartment * const oldCompartment ;
} <NEW_LINE> static int getStrrtokenPos ( char * str , int savedPos ) <NEW_LINE> { <NEW_LINE> int result = - 1 ; <NEW_LINE> int i ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( i = savedPos - 1 ; i >= 0 ; i -- ) { <NEW_LINE> if ( isIDSeparator ( * ( str + i ) ) ) {
if ( png_ptr != NULL ) <NEW_LINE> { <NEW_LINE> #ifdef PNG_ERROR_NUMBERS_SUPPORTED <NEW_LINE> <START_VULN> if ( png_ptr -> flags & <NEW_LINE> ( PNG_FLAG_STRIP_ERROR_NUMBERS | PNG_FLAG_STRIP_ERROR_TEXT ) ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> { <NEW_LINE> if ( * warning_message == PNG_LITERAL_SHARP )
body = rbuf ; <NEW_LINE> <START_VULN> if ( sc_asn1_read_tag ( & body , 0xffff , & cla_out , & tag_out , & bodylen ) != SC_SUCCESS <NEW_LINE> <END_VULN> || body == NULL ) { <NEW_LINE> sc_log ( card -> ctx , " ** ** * received buffer tag MISSING " ) ;
size += EbmlElementSize ( kMkvCodecDelay , codec_delay_ ) ; <NEW_LINE> if ( seek_pre_roll_ ) <NEW_LINE> size += EbmlElementSize ( kMkvSeekPreRoll , seek_pre_roll_ ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> const int64 payload_position = writer -> Position ( ) ; <NEW_LINE> if ( payload_position < 0 )
} <NEW_LINE> } <NEW_LINE> <START_VULN> if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { <NEW_LINE>return - EACCES ; <NEW_LINE> <END_VULN> }
} <NEW_LINE> offsets = ( int * ) safe_emalloc ( size_offsets , sizeof ( int ) , 0 ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> alloc_len = 2 * subject_len + 1 ; <NEW_LINE> result = safe_emalloc ( alloc_len , sizeof ( char ) , 0 ) ;
for ( seg_id = 0 ; seg_id < MAX_SEGMENTS ; seg_id ++ ) { <NEW_LINE> int lvl_seg = default_filt_lvl ; <NEW_LINE> <START_VULN> if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) { <NEW_LINE>const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ; <NEW_LINE> <END_VULN> lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? <NEW_LINE> data : default_filt_lvl + data , <NEW_LINE> 0 , MAX_LOOP_FILTER ) ;
& cipher , & cipher_len , & module , & module_len ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> td = mcrypt_module_open ( cipher , cipher_dir_string , module , module_dir_string ) ; <NEW_LINE> if ( td != MCRYPT_FAILED ) { <NEW_LINE> RETVAL_LONG ( mcrypt_enc_get_block_size ( td ) ) ;
#define VERSION ( ) \ <NEW_LINE> <START_VULN> printf ( "unsquashfs version 4 . 3 - git ( 2019 / 07 / 05 ) \n" ) ; \ <NEW_LINE> <END_VULN> printf ( "copyright ( C ) 2019 Phillip Lougher "\ <NEW_LINE> " < phillip@squashfs . org . uk > \n\n" ) ; \ <NEW_LINE> printf ( "This program is free software ; you can redistribute it and / or"\
png_ptr -> flags |= PNG_FLAG_ROW_INIT ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
sem_post ( & cpi -> h_event_end_lpf ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> if ( cm -> filter_level > 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> vp8_loop_filter_frame ( cm , & cpi -> mb . e_mbd , frame_type ) ; <NEW_LINE> }
#endif <NEW_LINE> static void markPointer ( Visitor * visitor , HeapObjectHeader * header ) { <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> const GCInfo * gcInfo = ThreadHeap::gcInfo ( header -> gcInfoIndex ( ) ) ; <NEW_LINE> if ( gcInfo -> hasVTable ( ) && ! vTableInitialized ( header -> payload ( ) ) ) {
struct windows_device_priv * priv = _device_priv ( dev_handle -> dev ) ; <NEW_LINE> int i ; <NEW_LINE> <START_VULN> if ( ( api_id < USB_API_WINUSBX ) || ( api_id > USB_API_HID ) ) { <NEW_LINE> <END_VULN> usbi_dbg ( "unsupported API ID" ) ; <NEW_LINE> return - 1 ; <NEW_LINE> }
<START_VULN> class Pickle { <NEW_LINE> <END_VULN> public: <NEW_LINE> Pickle ( ) ;
get_trust_val ( trust , valstr , sizeof valstr ) ; <NEW_LINE> PR_LOG ( modlog , 4 , ( fmt_s_s_d , <NEW_LINE> atype , valstr , attr -> ulValueLen ) ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> case CKA_KEY_TYPE: <NEW_LINE> if ( attr -> ulValueLen > 0 && attr -> pValue ) { <NEW_LINE> CK_KEY_TYPE keyType = * ( ( CK_KEY_TYPE * ) attr -> pValue ) ; <NEW_LINE> <START_VULN> get_obj_class ( keyType , valstr , sizeof valstr ) ; <NEW_LINE> <END_VULN> PR_LOG ( modlog , 4 , ( fmt_s_s_d , <NEW_LINE> atype , valstr , attr -> ulValueLen ) ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> case CKA_LABEL: <NEW_LINE> case CKA_NETSCAPE_EMAIL: <NEW_LINE> case CKA_NETSCAPE_URL: <NEW_LINE> if ( attr -> ulValueLen > 0 && attr -> pValue ) {
location &= ( PNG_HAVE_IHDR | PNG_HAVE_PLTE | PNG_AFTER_IDAT ) ; <NEW_LINE> <START_VULN> if ( location == 0 && ! ( png_ptr -> mode & PNG_IS_READ_STRUCT ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_app_warning ( png_ptr ,
ts_log ( "skt_read recv" , len , NULL ) ; <NEW_LINE> <START_VULN> if ( ( read = recv ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 ) <NEW_LINE> <END_VULN> { <NEW_LINE> ERROR ( "write failed with errno = % d\n" , errno ) ; <NEW_LINE> return - 1 ;
n = e -> band [ j ] . end ; <NEW_LINE> e -> band [ j ] . window = _ogg_malloc ( n * sizeof ( * e -> band [ 0 ] . window ) ) ; <NEW_LINE> for ( i = 0 ; i < n ; i ++ ) { <NEW_LINE> e -> band [ j ] . window [ i ] = sin ( ( i + . 5 ) / n * M_PI ) ; <NEW_LINE> e -> band [ j ] . total += e -> band [ j ] . window [ i ] ; <NEW_LINE> } <NEW_LINE> e -> band [ j ] . total = 1 . / e -> band [ j ] . total ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> e -> filter = _ogg_calloc ( VE_BANDS * ch , sizeof ( * e -> filter ) ) ; <NEW_LINE> e -> mark = _ogg_calloc ( e -> storage , sizeof ( * e -> mark ) ) ; <NEW_LINE> } <NEW_LINE> void _ve_envelope_clear ( envelope_lookup * e ) { <NEW_LINE> int i ; <NEW_LINE> mdct_clear ( & e -> mdct ) ;
private: <NEW_LINE> nsRefPtr < DecodeRequest > mRequest ; <NEW_LINE> nsRefPtr < RasterImage > mImage ; <NEW_LINE> } ; <NEW_LINE> private: <NEW_LINE> <START_VULN> mozilla::Mutex mThreadPoolMutex ; <NEW_LINE>nsCOMPtr < nsIThreadPool > mThreadPool ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> class DecodeDoneWorker : public nsRunnable <NEW_LINE> { <NEW_LINE> public:
static int compare_img ( const vpx_image_t * const img1 , <NEW_LINE> const vpx_image_t * const img2 ) { <NEW_LINE> <START_VULN> const uint32_t c_w = <NEW_LINE> <END_VULN> ( img1 -> d_w + img1 -> x_chroma_shift ) >> img1 -> x_chroma_shift ; <NEW_LINE> const uint32_t c_h = <NEW_LINE> ( img1 -> d_h + img1 -> y_chroma_shift ) >> img1 -> y_chroma_shift ;
ao2_unlock ( peer ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! peer && sip_cfg . alwaysauthreject ) { <NEW_LINE> <END_VULN> transmit_response ( p , "100 Trying" , req ) ;
nsISecureEnv * secureEnv = GetSecureEnv ( env ) ; <NEW_LINE> JNIMethod * method = ( JNIMethod * ) methodID ; <NEW_LINE> nsISecurityContext * securityContext = proxyEnv . getContext ( ) ; <NEW_LINE> <START_VULN> nsresult result ; <NEW_LINE>result = secureEnv -> NewObject ( clazz , method -> mMethodID , args , & outObject , securityContext ) ; <NEW_LINE> <END_VULN> NS_IF_RELEASE ( securityContext ) ; <NEW_LINE> return outObject ; <NEW_LINE> }
UpdateListIndicesFromIndex ( animVal -> mItems , aIndex + 1 ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> DOMSVGLengthList::MaybeRemoveItemFromAnimValListAt ( PRUint32 aIndex ) <NEW_LINE> { <NEW_LINE> NS_ABORT_IF_FALSE ( ! IsAnimValList ( ) , "call from baseVal to animVal" ) ; <NEW_LINE> <START_VULN> DOMSVGLengthList * animVal = mAList -> mAnimVal ; <NEW_LINE> <END_VULN> if ( ! animVal || mAList -> IsAnimating ( ) ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> NS_ABORT_IF_FALSE ( animVal -> mItems . Length ( ) == mItems . Length ( ) , <NEW_LINE> "animVal list not in sync ! " ) ;
} <NEW_LINE> } else { <NEW_LINE> mState &= ~ XML_HTTP_REQUEST_PARSEBODY ; <NEW_LINE> } <NEW_LINE> if ( mState & XML_HTTP_REQUEST_PARSEBODY ) { <NEW_LINE> nsCOMPtr < nsIURI > baseURI , docURI ; <NEW_LINE> <START_VULN> nsCOMPtr < nsIDocument > doc = GetDocumentFromScriptContext ( mScriptContext ) ; <NEW_LINE> <END_VULN> if ( doc ) { <NEW_LINE> docURI = doc -> GetDocumentURI ( ) ; <NEW_LINE> baseURI = doc -> GetBaseURI ( ) ; <NEW_LINE> }
JS_ASSERT_IF ( mine -> canonicalSpill ( ) && other -> canonicalSpill ( ) , <NEW_LINE> mine -> canonicalSpill ( ) -> isStackSlot ( ) == other -> canonicalSpill ( ) -> isStackSlot ( ) ) ; <NEW_LINE> LinearScanVirtualRegister * candidate = mine -> canonicalSpill ( ) ? mine : other ; <NEW_LINE> if ( ! candidate -> canonicalSpill ( ) -> isStackSlot ( ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> finishedDoubleSlots_ . append ( candidate -> lastInterval ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> void <NEW_LINE> LinearScanAllocator::finishInterval ( LiveInterval * interval ) <NEW_LINE> { <NEW_LINE> LAllocation * alloc = interval -> getAllocation ( ) ;
return hdrlen ; <NEW_LINE> } <NEW_LINE> if ( ndo -> ndo_vflag ) <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " % 04x: % s " , panid , le64addr_string ( ndo , p + 2 ) ) ) ; <NEW_LINE> <END_VULN> p += 8 ; <NEW_LINE> caplen - = 8 ; <NEW_LINE> hdrlen += 8 ;
const GURL & final_redirect , <NEW_LINE> RedirectDataMap * redirect_data ) ; <NEW_LINE> <START_VULN> void LearnOrigins ( const std::string & host , <NEW_LINE>const GURL & main_frame_origin , <NEW_LINE>const std::map < GURL , OriginRequestSummary > & summaries ) ; <NEW_LINE> <END_VULN> void OnURLsDeleted ( history::HistoryService * history_service ,
sk_free ( fPtr ) ; <NEW_LINE> } <NEW_LINE> if ( count > kCount ) { <NEW_LINE> <START_VULN> fPtr = ( T * ) sk_malloc_throw ( count * sizeof ( T ) ) ; <NEW_LINE> <END_VULN> } else if ( count ) { <NEW_LINE> fPtr = fTStorage ; <NEW_LINE> } else {
#define VIEWS_REPEAT_CONTROLLER_H_ <NEW_LINE> #pragma once <NEW_LINE> <START_VULN> #include "base / callback . h" <NEW_LINE> <END_VULN> #include "base / memory / scoped_ptr . h" <NEW_LINE> #include "base / timer . h"
if ( m_frame ) <NEW_LINE> m_frame -> loader ( ) . didExplicitOpen ( ) ; <NEW_LINE> <START_VULN> if ( m_loadEventProgress != LoadEventInProgress && m_loadEventProgress != UnloadEventInProgress ) <NEW_LINE> <END_VULN> m_loadEventProgress = LoadEventNotRun ; <NEW_LINE> }
continue ; <NEW_LINE> } <NEW_LINE> JSObject * object = nullptr ; <NEW_LINE> wrappedJS -> GetJSObject ( & object ) ; <NEW_LINE> if ( ! object ) { <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> NS_ENSURE_STATE ( pusher . Push ( ctx ) ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( ctx ) ; <NEW_LINE> JSAutoCompartment ac ( ctx , object ) ; <NEW_LINE> JSObject * param = JS_NewObject ( ctx , NULL , NULL , NULL ) ; <NEW_LINE> NS_ENSURE_TRUE ( param , NS_ERROR_OUT_OF_MEMORY ) ;
aoff , loff ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static INLINE void add_token ( TOKENEXTRA ** t , const vp9_prob * context_tree , <NEW_LINE>int16_t extra , uint8_t token , <NEW_LINE> <END_VULN> uint8_t skip_eob_node , <NEW_LINE> unsigned int * counts ) { <NEW_LINE> ( * t ) -> token = token ;
{ <NEW_LINE> THIS_DEBUGGER ( cx , argc , vp , "getNewestFrame" , args , dbg ) ; <NEW_LINE> for ( AllFramesIter i ( cx -> stack . space ( ) ) ; ! i . done ( ) ; ++ i ) { <NEW_LINE> <START_VULN> if ( dbg -> observesFrame ( i . fp ( ) ) ) <NEW_LINE>return dbg -> getScriptFrame ( cx , i . fp ( ) , vp ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> args . rval ( ) . setNull ( ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> JSBool <NEW_LINE> Debugger::clearAllBreakpoints ( JSContext * cx , unsigned argc , Value * vp ) <NEW_LINE> {
mUploadTransferred = 0 ; <NEW_LINE> mUploadTotal = 0 ; <NEW_LINE> mUploadComplete = true ; <NEW_LINE> mErrorLoad = false ; <NEW_LINE> mLoadLengthComputable = false ; <NEW_LINE> mLoadTotal = 0 ; <NEW_LINE> if ( ( aVariant || ! aBody . IsNull ( ) ) && httpChannel && <NEW_LINE> <START_VULN> ! method . EqualsLiteral ( "GET" ) ) { <NEW_LINE> <END_VULN> nsAutoCString charset ; <NEW_LINE> nsAutoCString defaultContentType ; <NEW_LINE> nsCOMPtr < nsIInputStream > postDataStream ; <NEW_LINE> rv = GetRequestBody ( aVariant , aBody , getter_AddRefs ( postDataStream ) , <NEW_LINE> & mUploadTotal , defaultContentType , charset ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
elems_ ( Move ( rhs . elems_ ) ) <NEW_LINE> { } <NEW_LINE> Signature & sig ( ) { return sig_ ; } <NEW_LINE> const Signature & sig ( ) const { return sig_ ; } <NEW_LINE> unsigned mask ( ) const { return mask_ ; } <NEW_LINE> unsigned globalDataOffset ( ) const { return globalDataOffset_ ; } <NEW_LINE> <START_VULN> void initElems ( FuncPtrVector && elems ) { elems_ = Move ( elems ) ; JS_ASSERT ( ! elems_ . empty ( ) ) ; } <NEW_LINE>unsigned numElems ( ) const { JS_ASSERT ( ! elems_ . empty ( ) ) ; return elems_ . length ( ) ; } <NEW_LINE> <END_VULN> const Func & elem ( unsigned i ) const { return * elems_ [ i ] ; } <NEW_LINE> } ; <NEW_LINE> typedef js::Vector < FuncPtrTable > FuncPtrTableVector ; <NEW_LINE> class ExitDescriptor <NEW_LINE> { <NEW_LINE> PropertyName * name_ ;
if ( aTypeHint ) { <NEW_LINE> mTypeHint = aTypeHint ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> NS_IMETHOD <NEW_LINE> Run ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> return mDocShell -> InternalLoad ( mURI , mReferrer , <NEW_LINE> <END_VULN> mReferrerPolicy , <NEW_LINE> mOwner , mFlags , <NEW_LINE> nullptr , mTypeHint . get ( ) , <NEW_LINE> NullString ( ) , mPostData , mHeadersData , <NEW_LINE> mLoadType , mSHEntry , mFirstParty , <NEW_LINE> mSrcdoc , mSourceDocShell , mBaseURI , <NEW_LINE> nullptr , nullptr ) ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( mStyleSheet ) { <NEW_LINE> doc -> BeginUpdate ( UPDATE_STYLE ) ; <NEW_LINE> doc -> RemoveStyleSheet ( mStyleSheet ) ; <NEW_LINE> doc -> EndUpdate ( UPDATE_STYLE ) ; <NEW_LINE> <START_VULN> mStyleSheet = nsnull ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! uri && ! isInline ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsAutoString title , type , media ; <NEW_LINE> PRBool isAlternate ;
else <NEW_LINE> valx = startx + i * delx ; <NEW_LINE> numaGetFValue ( nay , i , & valy ) ; <NEW_LINE> <START_VULN> snprintf ( buf , L_BUF_SIZE , " % f % f\n" , valx , valy ) ; <NEW_LINE> <END_VULN> sarrayAddString ( sa , buf , L_COPY ) ; <NEW_LINE> } <NEW_LINE> datastr = sarrayToString ( sa , 0 ) ;
ND_PRINT ( ( ndo , " ) " ) ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> return hdrlen + 2 + len ; <NEW_LINE> <END_VULN> default: <NEW_LINE> return - 1 ; <NEW_LINE> }
Mpi2DiagBufferPostReply_t * mpi_reply ; <NEW_LINE> int rc , i ; <NEW_LINE> u8 buffer_type ; <NEW_LINE> <START_VULN> unsigned long timeleft ; <NEW_LINE> <END_VULN> u16 smid ; <NEW_LINE> u16 ioc_status ; <NEW_LINE> u8 issue_reset = 0 ;
<START_VULN> m_hasBorderOrPaddingLogicalWidthChanged = oldStyle && diff == StyleDifferenceLayout && needsLayout ( ) && borderOrPaddingLogicalWidthChanged ( oldStyle , newStyle ) ; <NEW_LINE> <END_VULN>
WORD32 ihevcd_ref_list ( codec_t * ps_codec , pps_t * ps_pps , sps_t * ps_sps , slice_header_t * ps_slice_hdr ) <NEW_LINE> { <NEW_LINE> <START_VULN> WORD32 i ; <NEW_LINE> <END_VULN> WORD32 st_rps_idx ; <NEW_LINE> WORD32 num_neg_pics , num_pos_pics ; <NEW_LINE> WORD8 * pi1_used ;
num = length / 2 ; <NEW_LINE> <START_VULN> if ( num != png_ptr -> num_palette || num > PNG_MAX_PALETTE_LENGTH ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_crc_finish ( png_ptr , length ) ; <NEW_LINE> png_chunk_benign_error ( png_ptr , "invalid" ) ;
, 509 , 508 , 524 , 523 , 539 , 553 , <NEW_LINE> 554 , 559 , 560 , 561 , 562 , 567 , 652 , 698 , 756 , 801 , <NEW_LINE> <START_VULN> 802 , 806 , 831 , 867 , 913 , 935 , 944 , 953 , 968 , 980 , <NEW_LINE>994 , 1007 , 1018 , 1027 , 1057 , 1026 , 1171 , 1170 , 1249 , 1255 , <NEW_LINE>1262 , 1261 , 1324 , 1323 , 1384 , 1393 , 1402 , 1411 , 1420 , 1429 , <NEW_LINE>1438 , 1442 , 1450 , 1451 , 1456 , 1478 , 1490 , 1506 , 1505 , 1511 , <NEW_LINE>1522 , 1523 , 1528 , 1535 , 1546 , 1547 , 1551 , 1559 , 1563 , 1573 , <NEW_LINE>1587 , 1603 , 1613 , 1622 , 1647 , 1659 , 1671 , 1687 , 1699 , 1715 , <NEW_LINE>1760 , 1779 , 1797 , 1815 , 1833 , 1859 , 1877 , 1887 , 1897 , 1907 , <NEW_LINE>1917 , 1927 , 1937 <NEW_LINE> <END_VULN> } ; <NEW_LINE> #endif
if ( r . upper_ < r . lower_ ) { <NEW_LINE> <START_VULN> * nullRange = true ; <NEW_LINE> <END_VULN> r . makeRangeInfinite ( ) ; <NEW_LINE> } <NEW_LINE> return r ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> Range::unionWith ( const Range * other ) <NEW_LINE> {
base::ProcessId parentPID = strtol ( parentPIDString , & end , 10 ) ; <NEW_LINE> NS_ABORT_IF_FALSE ( ! * end , "invalid parent PID" ) ; <NEW_LINE> <START_VULN> base::ProcessHandle parentHandle ; <NEW_LINE>mozilla::DebugOnly < bool > ok = base::OpenProcessHandle ( parentPID , & parentHandle ) ; <NEW_LINE>NS_ABORT_IF_FALSE ( ok , "can't open handle to parent" ) ; <NEW_LINE> <END_VULN> #if defined ( XP_WIN )
DeleteInsertionPointEntry , <NEW_LINE> nsnull , 4 ) ; <NEW_LINE> if ( ! mInsertionPointTable ) <NEW_LINE> return ; <NEW_LINE> PRInt32 i ; <NEW_LINE> for ( i = 0 ; i < count ; i ++ ) { <NEW_LINE> nsIContent * child = childrenElements [ i ] ; <NEW_LINE> <START_VULN> nsIContent * parent = child -> GetParent ( ) ; <NEW_LINE> <END_VULN> nsXBLInsertionPointEntry * xblIns = nsXBLInsertionPointEntry::Create ( parent ) ; <NEW_LINE> nsAutoString includes ; <NEW_LINE> child -> GetAttr ( kNameSpaceID_None , nsGkAtoms::includes , includes ) ; <NEW_LINE> if ( includes . IsEmpty ( ) ) { <NEW_LINE> nsISupportsKey key ( nsGkAtoms::children ) ;
#include "content / browser / media / media_devices_permission_checker . h" <NEW_LINE> #include "content / browser / renderer_host / media / media_stream_manager . h" <NEW_LINE> #include "media / audio / audio_device_description . h" <NEW_LINE> <START_VULN> #include "media / audio / audio_manager . h" <NEW_LINE> <END_VULN> #include "media / base / audio_parameters . h" <NEW_LINE> #include "media / base / output_device_info . h" <NEW_LINE> namespace content {
<START_VULN> if ( transforms & PNG_TRANSFORM_SCALE_16 ) <NEW_LINE><NEW_LINE> <END_VULN> #ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED <NEW_LINE> png_set_scale_16 ( png_ptr ) ; <NEW_LINE> #else
#endif <NEW_LINE> } else { <NEW_LINE> current -> min_flt ++ ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <NEW_LINE> <END_VULN> regs , address ) ; <NEW_LINE> } <NEW_LINE> up_read ( & mm -> mmap_sem ) ;
DecodeType type = DECODE_TYPE_UNTIL_DONE_BYTES ; <NEW_LINE> if ( NS_IsMainThread ( ) ) { <NEW_LINE> type = DECODE_TYPE_UNTIL_TIME ; <NEW_LINE> } <NEW_LINE> <START_VULN> DecodePool::Singleton ( ) -> DecodeSomeOfImage ( mImage , type , mRequest -> mBytesToDecode ) ; <NEW_LINE> <END_VULN> uint32_t bytesDecoded = mImage -> mBytesDecoded - oldByteCount ; <NEW_LINE> mRequest -> mRequestStatus = DecodeRequest::REQUEST_WORK_DONE ; <NEW_LINE> if ( mImage -> mDecoder && mImage -> mDecoder -> NeedsNewFrame ( ) ) {
{ <NEW_LINE> struct crypto_report_comp rcomp ; <NEW_LINE> <START_VULN> strlcpy ( rcomp . type , "compression" , sizeof ( rcomp . type ) ) ; <NEW_LINE> <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , <NEW_LINE> sizeof ( struct crypto_report_comp ) , & rcomp ) ) <NEW_LINE> goto nla_put_failure ;
extern const char kEnableAccessibilityTabSwitcher [ ] ; <NEW_LINE> extern const char kEnableAppLink [ ] ; <NEW_LINE> extern const char kEnableContextualSearch [ ] ; <NEW_LINE> <START_VULN> extern const char kEnableContextualSearchNowOnTapBarIntegration [ ] ; <NEW_LINE> <END_VULN> extern const char kEnableHostedMode [ ] ; <NEW_LINE> extern const char kEnableHungRendererInfoBar [ ] ; <NEW_LINE> extern const char kEnableVrShell [ ] ;
std::string array_index , abuf ; <NEW_LINE> char * lbuf = nullptr ; <NEW_LINE> int total_bytes = 0 , cancel_upload = 0 , is_arr_upload = 0 , array_len = 0 ; <NEW_LINE> <START_VULN> int max_file_size = 0 , skip_upload = 0 , anonindex = 0 , is_anonymous ; <NEW_LINE> <END_VULN> std::set < std::string > & uploaded_files = s_rfc1867_data -> rfc1867UploadedFiles ; <NEW_LINE> multipart_buffer * mbuff ; <NEW_LINE> int fd = - 1 ;
bits [ 1 ] = cpu_to_be64 ( sctx -> count [ 0 ] << 3 ) ; <NEW_LINE> <START_VULN> bits [ 0 ] = cpu_to_be64 ( sctx -> count [ 1 ] << 3 ) | sctx -> count [ 0 ] >> 61 ; <NEW_LINE> <END_VULN>
goto MATLAB_KO ; <NEW_LINE> if ( strncmp ( MATLAB_HDR . identific , "MATLAB" , 6 ) ) <NEW_LINE> <START_VULN> MATLAB_KO: ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE> <END_VULN> filepos = TellBlob ( image ) ; <NEW_LINE> while ( ! EOFBlob ( image ) )
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsObjectLoadingContent::NotifyOwnerDocumentActivityChanged ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! mInstanceOwner ) { <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>nsCOMPtr < nsIContent > thisContent = <NEW_LINE>do_QueryInterface ( static_cast < nsIImageLoadingContent * > ( this ) ) ; <NEW_LINE>nsIDocument * ownerDoc = thisContent -> OwnerDoc ( ) ; <NEW_LINE>if ( ! ownerDoc -> IsActive ( ) ) { <NEW_LINE>StopPluginInstance ( ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsObjectLoadingContent::OnStartRequest ( nsIRequest * aRequest , <NEW_LINE> nsISupports * aContext ) <NEW_LINE> { <NEW_LINE> SAMPLE_LABEL ( "nsObjectLoadingContent" , "OnStartRequest" ) ;
void OnCancelDocumentLoad ( ) ; <NEW_LINE> void OnInitiateHTTPRangeRequest ( const std::string & url , <NEW_LINE> const std::string & range_info , <NEW_LINE> <START_VULN> intptr_t existing_stream , <NEW_LINE>bool notify_needed , <NEW_LINE>intptr_t notify_data ) ; <NEW_LINE> <END_VULN> void OnDeferResourceLoading ( unsigned long resource_id , bool defer ) ; <NEW_LINE> #if defined ( OS_MACOSX )
<START_VULN> const long long seekIdId = ReadUInt ( pReader , pos , len ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( seekIdId != 0x13AB ) <NEW_LINE> return false ;
windowInfo . windowSize = m_document -> settings ( ) -> textAutosizingWindowSizeOverride ( ) ; <NEW_LINE> if ( windowInfo . windowSize . isEmpty ( ) ) { <NEW_LINE> bool includeScrollbars = ! InspectorInstrumentation::shouldApplyScreenWidthOverride ( mainFrame ) ; <NEW_LINE> <START_VULN> windowInfo . windowSize = mainFrame -> view ( ) -> visibleContentRect ( includeScrollbars ) . size ( ) ; <NEW_LINE> <END_VULN> }
while ( * s && d < e ) { <NEW_LINE> if ( unlikely ( * s == ' % ' ) ) { <NEW_LINE> if ( likely ( s [ 1 ] && s [ 2 ] ) ) { <NEW_LINE> <START_VULN> * d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ; <NEW_LINE> <END_VULN> s += 2 ; <NEW_LINE> } <NEW_LINE> }
if ( req -> trb ) <NEW_LINE> memset ( req -> trb , 0 , sizeof ( struct dwc3_trb ) ) ; <NEW_LINE> dep -> queued_requests -- ; <NEW_LINE> <START_VULN> dwc3_gadget_giveback ( dep , req , ret ) ; <NEW_LINE> <END_VULN> return ret ; <NEW_LINE> }
struct { <NEW_LINE> struct vm_area_struct * mmap ; <NEW_LINE> struct rb_root mm_rb ; <NEW_LINE> <START_VULN> u32 vmacache_seqnum ; <NEW_LINE> <END_VULN> #ifdef CONFIG_MMU <NEW_LINE> unsigned long ( * get_unmapped_area ) ( struct file * filp , <NEW_LINE> unsigned long addr , unsigned long len ,
png_error ( png_ptr , "internal sequential row size calculation error" ) ; <NEW_LINE> #ifdef PNG_READ_INTERLACING_SUPPORTED <NEW_LINE> <START_VULN> <NEW_LINE>if ( png_ptr -> interlaced && <NEW_LINE> ( png_ptr -> transformations & PNG_INTERLACE ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( png_ptr -> pass < 6 ) <NEW_LINE> png_do_read_interlace ( & row_info , png_ptr -> row_buf + 1 , png_ptr -> pass ,
} <NEW_LINE> case GET_RELEASED_BUFFERS: { <NEW_LINE> CHECK_INTERFACE ( IGraphicBufferConsumer , data , reply ) ; <NEW_LINE> <START_VULN> uint64_t slotMask ; <NEW_LINE> <END_VULN> status_t result = getReleasedBuffers ( & slotMask ) ; <NEW_LINE> reply -> writeInt64 ( static_cast < int64_t > ( slotMask ) ) ; <NEW_LINE> reply -> writeInt32 ( result ) ;
typedef void vorbis_info_residue ; <NEW_LINE> typedef void vorbis_info_mapping ; <NEW_LINE> #include "psy . h" <NEW_LINE> #include "bitrate . h" <NEW_LINE> typedef struct private_state { <NEW_LINE> <START_VULN> envelope_lookup * ve ; <NEW_LINE> <END_VULN> int window [ 2 ] ; <NEW_LINE> vorbis_look_transform ** transform [ 2 ] ; <NEW_LINE> drft_lookup fft_look [ 2 ] ; <NEW_LINE> int modebits ; <NEW_LINE> vorbis_look_floor ** flr ; <NEW_LINE> vorbis_look_residue ** residue ; <NEW_LINE> vorbis_look_psy * psy ;
if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE ) <NEW_LINE> truelen = 1 ; <NEW_LINE> <START_VULN> else if ( png_ptr -> color_type & PNG_COLOR_MASK_COLOR ) <NEW_LINE> <END_VULN> truelen = 6 ; <NEW_LINE> else
qrio_enable_app_buffer ( ) ; <NEW_LINE> <START_VULN> return ret ; <NEW_LINE> <END_VULN> } <NEW_LINE> unsigned long get_board_sys_clk ( unsigned long dummy )
NS_LossyConvertUTF16toASCII cname ( name ) ; <NEW_LINE> nsCString mappedName ; <NEW_LINE> prog -> MapIdentifier ( cname , & mappedName ) ; <NEW_LINE> MakeContextCurrent ( ) ; <NEW_LINE> GLint intlocation = gl -> fGetUniformLocation ( progname , mappedName . get ( ) ) ; <NEW_LINE> WebGLUniformLocation * loc = nsnull ; <NEW_LINE> <START_VULN> if ( intlocation >= 0 ) <NEW_LINE>NS_ADDREF ( loc = new WebGLUniformLocation ( this , prog , intlocation ) ) ; <NEW_LINE> <END_VULN> * retval = loc ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> WebGLContext::GetVertexAttrib ( WebGLuint index , WebGLenum pname , nsIVariant ** retval ) <NEW_LINE> { <NEW_LINE> if ( ! IsContextStable ( ) )
virtual void DidUpdateSecurityOrigin ( ) = 0 ; <NEW_LINE> SandboxFlags GetSandboxFlags ( ) const { return sandbox_flags_ ; } <NEW_LINE> <START_VULN> bool IsSandboxed ( SandboxFlags mask ) const { return sandbox_flags_ & mask ; } <NEW_LINE> <END_VULN> virtual void EnforceSandboxFlags ( SandboxFlags mask ) ; <NEW_LINE> void SetAddressSpace ( mojom::IPAddressSpace space ) { address_space_ = space ; }
NS_IMETHODIMP <NEW_LINE> nsMathMLTokenFrame::AttributeChanged ( PRInt32 aNameSpaceID , <NEW_LINE> nsIAtom * aAttribute , <NEW_LINE> PRInt32 aModType ) <NEW_LINE> { <NEW_LINE> if ( nsGkAtoms::lquote_ == aAttribute || <NEW_LINE> nsGkAtoms::rquote_ == aAttribute ) { <NEW_LINE> <START_VULN> SetQuotes ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return nsMathMLContainerFrame:: <NEW_LINE> AttributeChanged ( aNameSpaceID , aAttribute , aModType ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsMathMLTokenFrame::ProcessTextData ( )
int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; <NEW_LINE> int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; <NEW_LINE> int filt_val ; <NEW_LINE> <START_VULN> int best_filt_val = cm -> filter_level ; <NEW_LINE> <END_VULN> YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ;
NS_PRECONDITION ( ! mIsDocumentGone , "Unexpected ContentAppended" ) ; <NEW_LINE> NS_PRECONDITION ( aDocument == mDocument , "Unexpected aDocument" ) ; <NEW_LINE> NS_PRECONDITION ( aContainer , "must have container" ) ; <NEW_LINE> if ( ! mDidInitialReflow ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE> <END_VULN> MOZ_TIMER_DEBUGLOG ( ( "Start: Frame Creation: PresShell::ContentAppended ( ) , this = % p\n" , this ) ) ; <NEW_LINE> MOZ_TIMER_START ( mFrameCreationWatch ) ; <NEW_LINE> mFrameConstructor -> RestyleForAppend ( aContainer , aNewIndexInContainer ) ;
AVFormatContext * ctx ; <NEW_LINE> AVOutputFormat * fmt_out ; <NEW_LINE> Bool ret = GF_FALSE ; <NEW_LINE> <START_VULN> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <NEW_LINE> <END_VULN> const char * szExtList ; <NEW_LINE> FFDemux * ffd ; <NEW_LINE> if ( ! plug || ! url )
nsresult rv = aImg -> FinishedSomeDecoding ( ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> aImg -> DoError ( ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> nsresult rv = DecodeSomeOfImage ( aImg , DECODE_TYPE_UNTIL_SIZE ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) { <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> if ( aImg -> mDecoder && aImg -> mDecoder -> NeedsNewFrame ( ) ) { <NEW_LINE> FrameNeededWorker::GetNewFrame ( aImg ) ;
return JS_FALSE ; <NEW_LINE> if ( oldlen < newlen ) { <NEW_LINE> obj -> fslots [ JSSLOT_ARRAY_LENGTH ] = newlen ; <NEW_LINE> return JS_TRUE ; <NEW_LINE> } <NEW_LINE> if ( OBJ_IS_DENSE_ARRAY ( cx , obj ) ) { <NEW_LINE> <START_VULN> if ( ARRAY_DENSE_LENGTH ( obj ) && ! ResizeSlots ( cx , obj , oldlen , newlen ) ) <NEW_LINE> <END_VULN> return JS_FALSE ; <NEW_LINE> } else if ( oldlen - newlen < ( 1 << 24 ) ) { <NEW_LINE> do { <NEW_LINE> -- oldlen ; <NEW_LINE> if ( ! JS_CHECK_OPERATION_LIMIT ( cx , JSOW_JUMP ) || <NEW_LINE> ! DeleteArrayElement ( cx , obj , oldlen ) ) { <NEW_LINE> return JS_FALSE ; <NEW_LINE> }
static int nntp_hcache_namer ( const char * path , char * dest , size_t destlen ) <NEW_LINE> { <NEW_LINE> <START_VULN> return snprintf ( dest , destlen , " % s . hcache" , path ) ; <NEW_LINE> <END_VULN> }
if ( ! hasInlineChild && o -> isInline ( ) ) <NEW_LINE> hasInlineChild = true ; <NEW_LINE> <START_VULN> if ( o -> isReplaced ( ) || o -> isFloating ( ) || o -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> RenderBox * box = toRenderBox ( o ) ; <NEW_LINE> if ( relayoutChildren || box -> hasRelativeDimensions ( ) )
size_t item_size = decode_length ( & source , length_size ) ; <NEW_LINE> source . discard_next ( item_size ) ; <NEW_LINE> <START_VULN> length += item_size + length_size + tag_size ; <NEW_LINE> <END_VULN> if ( type_tag == EOC && class_tag == UNIVERSAL ) <NEW_LINE> break ;
#if ! defined ( CONFIG_ARCH_UNIPHIER ) && ! defined ( CONFIG_ARCH_STI ) && \ <NEW_LINE> <START_VULN> ! defined ( CONFIG_ARCH_K3 ) && ! defined ( CONFIG_ARCH_BCM6858 ) && \ <NEW_LINE> ! defined ( CONFIG_ARCH_BCM63158 ) && ! defined ( CONFIG_ARCH_ROCKCHIP ) && \ <NEW_LINE> ! defined ( CONFIG_ARCH_LX2160A ) && ! defined ( CONFIG_ARCH_LS1028A ) && \ <NEW_LINE> ! defined ( CONFIG_ARCH_LS2080A ) && ! defined ( CONFIG_ARCH_LS1088A ) && \ <NEW_LINE> ! defined ( CONFIG_ARCH_ASPEED ) <NEW_LINE> <END_VULN> #include < asm / arch / gpio . h > <NEW_LINE> #endif <NEW_LINE> #include < asm - generic / gpio . h >
# if defined ( PNG_READ_SUPPORTED ) && defined ( PNG_WRITE_SUPPORTED ) <NEW_LINE> <START_VULN> if ( png_ptr -> mode & PNG_IS_READ_STRUCT ) <NEW_LINE> <END_VULN> # endif <NEW_LINE> # ifdef PNG_READ_SUPPORTED
return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> RasterImage::DecodePool::RequestDecode ( RasterImage * aImg ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( aImg -> mDecoder ) ; <NEW_LINE> <START_VULN> aImg -> mDecodingMutex . AssertCurrentThreadOwns ( ) ; <NEW_LINE> <END_VULN> if ( ! aImg -> mDecoder -> NeedsNewFrame ( ) ) { <NEW_LINE> aImg -> mDecodeRequest -> mBytesToDecode = aImg -> mSourceData . Length ( ) - aImg -> mBytesDecoded ;
Ci -> green = Ai -> green - Bi -> green ; <NEW_LINE> Cr -> blue = Ar -> blue - Br -> blue ; <NEW_LINE> Ci -> blue = Ai -> blue - Bi -> blue ; <NEW_LINE> <START_VULN> if ( images -> matte != MagickFalse ) <NEW_LINE> <END_VULN> { <NEW_LINE> Cr -> opacity = Ar -> opacity - Br -> opacity ; <NEW_LINE> Ci -> opacity = Ai -> opacity - Bi -> opacity ;
void Segment::MoveCuesBeforeClusters ( ) { <NEW_LINE> const uint64 current_cue_size = cues_ . Size ( ) ; <NEW_LINE> <START_VULN> uint64 cue_size = current_cue_size ; <NEW_LINE>for ( int32 i = 0 ; i < cues_ . cue_entries_size ( ) ; i ++ ) <NEW_LINE> <END_VULN> MoveCuesBeforeClustersHelper ( current_cue_size , i , & cue_size ) ;
ipv6_iface_scope_id ( & sin6 -> sin6_addr , <NEW_LINE> IP6CB ( skb ) -> iif ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> } <NEW_LINE> if ( is_udp4 ) { <NEW_LINE> if ( inet -> cmsg_flags )
if ( png_muldiv ( & gtest , output_gamma , png_ptr -> colorspace . gamma , <NEW_LINE> <START_VULN> PNG_FP_1 ) && ! png_gamma_significant ( gtest ) ) <NEW_LINE> <END_VULN> do_local_background = 0 ; <NEW_LINE> else if ( mode == PNG_ALPHA_STANDARD )
if ( p -> vrtp ) { <NEW_LINE> <START_VULN> if ( vportno > 0 ) { <NEW_LINE> <END_VULN> ast_sockaddr_set_port ( vsa , vportno ) ; <NEW_LINE> ast_rtp_instance_set_remote_address ( p -> vrtp , vsa ) ; <NEW_LINE> if ( debug ) {
} <NEW_LINE> void <NEW_LINE> nsNavigator::LoadingNewDocument ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> mMimeTypes = nsnull ; <NEW_LINE>mPlugins = nsnull ; <NEW_LINE> <END_VULN> if ( mGeolocation ) <NEW_LINE> { <NEW_LINE> mGeolocation -> Shutdown ( ) ; <NEW_LINE> mGeolocation = nsnull ; <NEW_LINE> } <NEW_LINE> }
<START_VULN> class ComponentContext { <NEW_LINE> <END_VULN> public: <NEW_LINE> ComponentContext ( ) ; <NEW_LINE> ~ ComponentContext ( ) ;
imsx = 2048 ; <NEW_LINE> imsy = 2048 ; <NEW_LINE> <START_VULN> imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx * imsy , 1 ) ; <NEW_LINE> <END_VULN> if ( imbuf == NULL ) { <NEW_LINE> return ( MagickFalse ) ;
{ <NEW_LINE> unsigned long chunks = <NEW_LINE> png_get_valid ( dp -> read_pp , dp -> read_ip , 0xffffffff ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( chunks != dp -> chunks ) <NEW_LINE> display_log ( dp , APP_FAIL , "PNG chunks changed from 0x % lx to 0x % lx" , <NEW_LINE> ( unsigned long ) dp -> chunks , chunks ) ;
srcConsumed = PR_MAX ( srcConsumed , 0 ) ; <NEW_LINE> mConverter -> Reset ( ) ; <NEW_LINE> } <NEW_LINE> NS_ASSERTION ( srcConsumed <= mByteData -> GetLength ( ) , <NEW_LINE> "Whoa . The converter should have returned NS_OK_UDEC_MOREINPUT before this point ! " ) ; <NEW_LINE> } while ( mReplacementChar && <NEW_LINE> <START_VULN> NS_FAILED ( * aErrorCode ) ) ; <NEW_LINE> <END_VULN> mLeftOverBytes = mByteData -> GetLength ( ) - srcConsumed ; <NEW_LINE> return mUnicharDataLength ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsConverterInputStream::ReadLine ( nsAString & aLine , PRBool * aResult )
content::SiteInstance * site_instance ) OVERRIDE ; <NEW_LINE> virtual void SiteInstanceDeleting ( content::SiteInstance * site_instance ) <NEW_LINE> OVERRIDE ; <NEW_LINE> <START_VULN> virtual bool ShouldSwapProcessesForNavigation ( const GURL & current_url , <NEW_LINE>const GURL & new_url ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual bool ShouldSwapProcessesForRedirect ( <NEW_LINE> content::ResourceContext * resource_context , <NEW_LINE> const GURL & current_url ,
namespace js { <NEW_LINE> <START_VULN> typedef js::HashMap < JSObject * , Value > ObjectValueMap ; <NEW_LINE> <END_VULN> class WeakMap { <NEW_LINE> ObjectValueMap map ;
{ <NEW_LINE> struct crypto_report_hash rhash ; <NEW_LINE> <START_VULN> snprintf ( rhash . type , CRYPTO_MAX_ALG_NAME , " % s" , "ahash" ) ; <NEW_LINE> <END_VULN> rhash . blocksize = alg -> cra_blocksize ; <NEW_LINE> rhash . digestsize = __crypto_hash_alg_common ( alg ) -> digestsize ;
int chunk_type ; <NEW_LINE> int inter ; <NEW_LINE> <START_VULN> if ( buf_size < 17 ) { <NEW_LINE> <END_VULN> av_log ( avctx , AV_LOG_ERROR , "Input buffer too small\n" ) ; <NEW_LINE> * data_size = 0 ; <NEW_LINE> return - 1 ;
#ifdef PNG_READ_TRANSFORMS_SUPPORTED <NEW_LINE> static unsigned int <NEW_LINE> sample ( png_const_bytep row , png_byte colour_type , png_byte bit_depth , <NEW_LINE> <START_VULN> png_uint_32 x , unsigned int sample_index ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_uint_32 bit_index , result ;
const std::vector < InputComponentInfo > & input_components ( ) const { <NEW_LINE> return input_components_ ; <NEW_LINE> } <NEW_LINE> <START_VULN> const GURL & background_url ( ) const { return background_url_ ; } <NEW_LINE> <END_VULN> const GURL & options_url ( ) const { return options_url_ ; } <NEW_LINE> const GURL & devtools_url ( ) const { return devtools_url_ ; } <NEW_LINE> const ExtensionPermissionSet * optional_permission_set ( ) const {
if ( row_info . pixel_depth != png_ptr -> pixel_depth || <NEW_LINE> <START_VULN> row_info . pixel_depth != png_ptr -> transformed_pixel_depth ) <NEW_LINE> <END_VULN> png_error ( png_ptr , "internal write transform logic error" ) ; <NEW_LINE> #ifdef PNG_MNG_FEATURES_SUPPORTED
" SKP: The chunk was skipped because of a zlib issue ( zlib - rc ) with" , <NEW_LINE> " explanation 'message'" , <NEW_LINE> " ERR: The read of the file was aborted . The parameters explain why . " , <NEW_LINE> <START_VULN> " $ 3 status: For 'ERR' the accumulate status code from 'EXIT CODES' above . " , <NEW_LINE> <END_VULN> " This is printed as a 2 digit hexadecimal value" , <NEW_LINE> " comp - level: The recorded compression level ( FLEVEL ) of a zlib stream" , <NEW_LINE> " expressed as a string { supfast , stdfast , default , maximum } " ,
return true ; <NEW_LINE> } <NEW_LINE> else <NEW_LINE> <START_VULN> return options & gr_face_dumbRendering ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
if ( cipher_def -> type == type_block ) { <NEW_LINE> <START_VULN> const unsigned int blockSize = cipher_def -> iv_size ; <NEW_LINE> <END_VULN> const unsigned int macSize = crSpec -> mac_size ; <NEW_LINE> if ( crSpec -> version <= SSL_LIBRARY_VERSION_3_0 ) {
png_pass_ystart [ png_ptr -> pass ] ) / <NEW_LINE> png_pass_yinc [ png_ptr -> pass ] ; <NEW_LINE> <START_VULN> if ( png_ptr -> transformations & PNG_INTERLACE ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> } while ( png_ptr -> usr_width == 0 || png_ptr -> num_rows == 0 ) ;
#ifdef PNG_TEXT_SUPPORTED <NEW_LINE> static void <NEW_LINE> <START_VULN> pngtest_check_text_support ( png_const_structp png_ptr , png_textp text_ptr , <NEW_LINE> <END_VULN> int num_text ) <NEW_LINE> { <NEW_LINE> while ( num_text > 0 )
nsresult <NEW_LINE> nsDOMDataTransfer::Clone ( uint32_t aEventType , bool aUserCancelled , <NEW_LINE> bool aIsCrossDomainSubFrameDrop , <NEW_LINE> nsIDOMDataTransfer ** aNewDataTransfer ) <NEW_LINE> { <NEW_LINE> nsDOMDataTransfer * newDataTransfer = <NEW_LINE> new nsDOMDataTransfer ( aEventType , mEffectAllowed , mCursorState , <NEW_LINE> mIsExternal , aUserCancelled , aIsCrossDomainSubFrameDrop , <NEW_LINE> <START_VULN> mItems , mDragImage , mDragImageX , mDragImageY ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( newDataTransfer , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> * aNewDataTransfer = newDataTransfer ; <NEW_LINE> NS_ADDREF ( * aNewDataTransfer ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> already_AddRefed < nsISupportsArray >
void InsertTimeoutIntoList ( nsTimeout * aTimeout ) ; <NEW_LINE> static void TimerCallback ( nsITimer * aTimer , void * aClosure ) ; <NEW_LINE> nsresult GetTreeOwner ( nsIDocShellTreeOwner ** aTreeOwner ) ; <NEW_LINE> nsresult GetTreeOwner ( nsIBaseWindow ** aTreeOwner ) ; <NEW_LINE> nsresult GetWebBrowserChrome ( nsIWebBrowserChrome ** aBrowserChrome ) ; <NEW_LINE> nsresult SecurityCheckURL ( const char * aURL ) ; <NEW_LINE> <START_VULN> nsresult BuildURIfromBase ( const char * aURL , <NEW_LINE>nsIURI ** aBuiltURI , <NEW_LINE>bool * aFreeSecurityPass , JSContext ** aCXused ) ; <NEW_LINE> <END_VULN> bool PopupWhitelisted ( ) ; <NEW_LINE> PopupControlState RevisePopupAbuseLevel ( PopupControlState ) ; <NEW_LINE> void FireAbuseEvents ( bool aBlocked , bool aWindow , <NEW_LINE> const nsAString & aPopupURL , <NEW_LINE> const nsAString & aPopupWindowName , <NEW_LINE> const nsAString & aPopupWindowFeatures ) ; <NEW_LINE> void FireOfflineStatusEvent ( ) ;
* <NEW_LINE> bool NS_FASTCALL SetCapacity ( size_type newCapacity ) ; <NEW_LINE> <START_VULN> void NS_FASTCALL SetLength ( size_type newLength ) ; <NEW_LINE> <END_VULN> void Truncate ( size_type newLength = 0 ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( newLength <= mLength , "Truncate cannot make string longer" ) ; <NEW_LINE> SetLength ( newLength ) ; <NEW_LINE> }
if ( ! nsContentUtils::IsSafeToRunScript ( ) ) <NEW_LINE> return false ; <NEW_LINE> bool doDefault = true ; <NEW_LINE> nsRefPtr < nsDOMDataTransfer > clipboardData ; <NEW_LINE> if ( Preferences::GetBool ( "dom . event . clipboardevents . enabled" , true ) ) { <NEW_LINE> <START_VULN> clipboardData = new nsDOMDataTransfer ( aType , aType == NS_PASTE ) ; <NEW_LINE> <END_VULN> nsEventStatus status = nsEventStatus_eIgnore ; <NEW_LINE> nsClipboardEvent evt ( true , aType ) ; <NEW_LINE> evt . clipboardData = clipboardData ; <NEW_LINE> nsEventDispatcher::Dispatch ( content , presShell -> GetPresContext ( ) , & evt , nullptr , <NEW_LINE> & status ) ; <NEW_LINE> doDefault = ( status != nsEventStatus_eConsumeNoDefault ) ;
<START_VULN> bool BaseInitLoggingImpl ( const PathChar * log_file , <NEW_LINE>LoggingDestination logging_dest , <NEW_LINE>LogLockingState lock_log , <NEW_LINE>OldFileDeletionState delete_old , <NEW_LINE>DcheckState dcheck_state ) ; <NEW_LINE> <END_VULN>
return NS_ERROR_NOT_INITIALIZED ; <NEW_LINE> nsCOMPtr < nsINode > kungfuDeathGrip = aParentNode ; <NEW_LINE> mFrameSelection -> InvalidateDesiredX ( ) ; <NEW_LINE> if ( ! IsValidSelectionPoint ( mFrameSelection , aParentNode ) ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> nsresult result ; <NEW_LINE> <START_VULN> nsRefPtr < nsPresContext > presContext = GetPresContext ( ) ; <NEW_LINE> <END_VULN> Clear ( presContext ) ; <NEW_LINE> mFrameSelection -> ClearTableCellSelection ( ) ; <NEW_LINE> nsRefPtr < nsRange > range = new nsRange ( aParentNode ) ; <NEW_LINE> result = range -> SetEnd ( aParentNode , aOffset ) ; <NEW_LINE> if ( NS_FAILED ( result ) )
if ( mCaret ) { <NEW_LINE> mCaret -> InvalidateOutsideCaret ( ) ; <NEW_LINE> } <NEW_LINE> mPresContext -> EventStateManager ( ) -> ContentRemoved ( aChild ) ; <NEW_LINE> <START_VULN> nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE> <END_VULN> if ( aContainer ) <NEW_LINE> mFrameConstructor -> RestyleForRemove ( aContainer , aChild , aIndexInContainer ) ; <NEW_LINE> PRBool didReconstruct ;
smart_str_free ( & eval_buf ) ; <NEW_LINE> if ( err <= - 2 ) { <NEW_LINE> <START_VULN> smart_str_free ( & out_buf ) ; <NEW_LINE> <END_VULN> RETVAL_FALSE ; <NEW_LINE> } else { <NEW_LINE> smart_str_appendc ( & out_buf , '\0' ) ;
} <NEW_LINE> if ( discover ) { <NEW_LINE> <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <NEW_LINE> <END_VULN> fprintf ( stdout , "BT adapter is up\n" ) ; <NEW_LINE> fprintf ( stdout , "Starting to start discovery\n" ) ;
} <NEW_LINE> <START_VULN> #line 10231 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> void CLASS convert_to_rgb ( ) <NEW_LINE> { <NEW_LINE> #ifndef LIBRAW_LIBRARY_BUILD
void initPrepareCall ( MDefinition * start ) { <NEW_LINE> JS_ASSERT ( start -> isPrepareCall ( ) ) ; <NEW_LINE> return initOperand ( PrepareCallOperandIndex , start ) ; <NEW_LINE> } <NEW_LINE> void initFunction ( MDefinition * func ) { <NEW_LINE> JS_ASSERT ( ! func -> isPassArg ( ) ) ; <NEW_LINE> return initOperand ( FunctionOperandIndex , func ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> MDefinition * getFunction ( ) const { <NEW_LINE> return getOperand ( FunctionOperandIndex ) ; <NEW_LINE> } <NEW_LINE> void replaceFunction ( MInstruction * newfunc ) { <NEW_LINE> replaceOperand ( FunctionOperandIndex , newfunc ) ; <NEW_LINE> } <NEW_LINE> void addArg ( size_t argnum , MPassArg * arg ) ;
m_internalURL = BlobURL::createInternalURL ( ) ; <NEW_LINE> <START_VULN> ThreadableBlobRegistry::registerBlobURL ( m_internalURL , blobData ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> Blob::Blob ( const KURL & srcURL , const String & type , long long size )
Document * getSVGDocument ( ExceptionState & ) const ; <NEW_LINE> <START_VULN> virtual bool LoadedNonEmptyDocument ( ) const { return false ; } <NEW_LINE>virtual void DidLoadNonEmptyDocument ( ) { } <NEW_LINE> <END_VULN> void SetEmbeddedContentView ( EmbeddedContentView * ) ; <NEW_LINE> EmbeddedContentView * ReleaseEmbeddedContentView ( ) ;
if ( env -> log . level > 1 ) <NEW_LINE> verbose ( env , " % d:" , env -> insn_idx ) ; <NEW_LINE> else <NEW_LINE> <START_VULN> verbose ( env , "\nfrom % d to % d:" , <NEW_LINE>env -> prev_insn_idx , env -> insn_idx ) ; <NEW_LINE> <END_VULN> print_verifier_state ( env , state -> frame [ state -> curframe ] ) ; <NEW_LINE> do_print_state = false ; <NEW_LINE> }
else { <NEW_LINE> int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; <NEW_LINE> <START_VULN> char * buff = malloc ( bytes_to_copy ) ; <NEW_LINE> <END_VULN> if ( debug_logging_mode ) <NEW_LINE> error_line ( "extra unknown chunk \" % c % c % c % c\" of % d bytes" ,
<START_VULN> #ifndef CHROME_BROWSER_CHROMEOS_AUDIO_HANDLER_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_AUDIO_HANDLER_H_ <NEW_LINE> <END_VULN> #pragma once <NEW_LINE> #include "base / basictypes . h"
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: bitrate tracking and management <NEW_LINE> <START_VULN> last mod: $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_BITRATE_H_ <NEW_LINE> #define _V_BITRATE_H_ <NEW_LINE> #include "vorbis / codec . h" <NEW_LINE> #include "codec_internal . h"
int compression_type ; <NEW_LINE> if ( png_get_iCCP ( read_ptr , read_info_ptr , & name , & compression_type , <NEW_LINE> <START_VULN> & profile , & proflen ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_set_iCCP ( write_ptr , write_info_ptr , name , compression_type , <NEW_LINE> profile , proflen ) ;
if ( doInterrupt ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> result = item -> RedoTransaction ( aTxMgr ) ; <NEW_LINE> if ( NS_SUCCEEDED ( result ) ) { <NEW_LINE> <START_VULN> result = mRedoStack -> Pop ( & item ) ; <NEW_LINE> <END_VULN> if ( NS_SUCCEEDED ( result ) ) { <NEW_LINE> result = mUndoStack -> Push ( item ) ; <NEW_LINE> } <NEW_LINE> }
{ <NEW_LINE> spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ; <NEW_LINE> spl_filesystem_object * object = spl_filesystem_iterator_to_object ( iterator ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> object -> u . dir . index = 0 ; <NEW_LINE> if ( object -> u . dir . dirp ) { <NEW_LINE> php_stream_rewinddir ( object -> u . dir . dirp ) ;
FeatureMap testFeatureMap ; <NEW_LINE> dummyFace . replace_table ( TtfUtil::Tag::Feat , & testBadOffset , sizeof testBadOffset ) ; <NEW_LINE> <START_VULN> face = gr_make_face_with_ops ( & dummyFace , & face_handle::ops , gr_face_dumbRendering ) ; <NEW_LINE>bool readStatus = testFeatureMap . readFeats ( * face ) ; <NEW_LINE>testAssert ( "fail gracefully on bad table" , ! readStatus ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> catch ( std::exception & e ) <NEW_LINE> {
stream << id << "_" ; <NEW_LINE> stream << name . substr ( 0 , MAX_IDENTIFIER_NAME_SIZE - stream . str ( ) . size ( ) ) ; <NEW_LINE> return stream . str ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> MapLongVariableNames::MapLongVariableNames ( <NEW_LINE> <START_VULN> TMap < TString , TString > & varyingLongNameMap ) <NEW_LINE> <END_VULN> : mVaryingLongNameMap ( varyingLongNameMap ) <NEW_LINE> { <NEW_LINE> } <NEW_LINE> void MapLongVariableNames::visitSymbol ( TIntermSymbol * symbol ) <NEW_LINE> { <NEW_LINE> ASSERT ( symbol != NULL ) ; <NEW_LINE> if ( symbol -> getSymbol ( ) . size ( ) > MAX_IDENTIFIER_NAME_SIZE ) {
bool shouldListenToContextDestroyed ( ) const ; <NEW_LINE> bool shouldRecordUserPausedAutoplayingCrossOriginVideo ( ) const ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>AutoplaySource m_source ; <NEW_LINE> <END_VULN> Member < HTMLMediaElement > m_element ;
fReserved = false ; <NEW_LINE> if ( count > preallocCount ) { <NEW_LINE> fAllocCount = SkTMax ( count , kMinHeapAllocCount ) ; <NEW_LINE> <START_VULN> fMemArray = sk_malloc_throw ( fAllocCount * sizeof ( T ) ) ; <NEW_LINE> <END_VULN> fOwnMemory = true ; <NEW_LINE> } else { <NEW_LINE> fAllocCount = preallocCount ;
msg [ 0 ] -> msg_style == PAM_PROMPT_ECHO_ON ) ) { <NEW_LINE> * resp = malloc ( sizeof ( struct pam_response ) ) ; <NEW_LINE> assert ( * resp ) ; <NEW_LINE> <START_VULN> ( * resp ) -> resp = calloc ( 1024 , 0 ) ; <NEW_LINE> <END_VULN> struct termios termios = old_termios ; <NEW_LINE> if ( msg [ 0 ] -> msg_style == PAM_PROMPT_ECHO_OFF ) { <NEW_LINE> termios . c_lflag &= ~ ( ECHO | ECHONL ) ;
if ( ! CheckGlobalObjectShape ( cx , tm , f -> globalObj ) ) { <NEW_LINE> Backoff ( cx , ( jsbytecode * ) localRootIP ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> AUDIT ( recorderStarted ) ; <NEW_LINE> <START_VULN> if ( tm -> outOfMemory ( ) || OverfullJITCache ( tm ) ) { <NEW_LINE> <END_VULN> Backoff ( cx , ( jsbytecode * ) f -> root -> ip ) ; <NEW_LINE> ResetJIT ( cx , FR_OOM ) ; <NEW_LINE> debug_only_print0 ( LC_TMTracer , <NEW_LINE> "Out of memory recording new tree , flushing cache . \n" ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> JS_ASSERT ( ! f -> code ( ) ) ;
CImg < ucharT > buffer ; <NEW_LINE> if ( buf_size < cimg_iobuffer ) { <NEW_LINE> <START_VULN> buffer . assign ( cimg::abs ( dy ) * ( dx_bytes + align_bytes ) , 1 , 1 , 1 , 0 ) ; <NEW_LINE> <END_VULN> cimg::fread ( buffer . _data , buf_size , nfile ) ; <NEW_LINE> } else buffer . assign ( dx_bytes + align_bytes ) ; <NEW_LINE> unsigned char * ptrs = buffer ;
height = 0 ; <NEW_LINE> depth = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { <NEW_LINE>abort ( ) ; <NEW_LINE> } <NEW_LINE>printf ( " % s % d % d % d % d % ld\n" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ; <NEW_LINE> <END_VULN> jas_image_destroy ( image ) ; <NEW_LINE> jas_image_clearfmts ( ) ;
int setting = ( 2 + ( onoff != 0 ) ) << option ; <NEW_LINE> int current = png_ptr -> options ; <NEW_LINE> <START_VULN> png_ptr -> options = ( png_byte ) ( ( current & ~ mask ) | setting ) ; <NEW_LINE> <END_VULN> return ( current & mask ) >> option ; <NEW_LINE> }
#define VARIANT_HN ( VARIANT_INHERIT | VARIANT_NUMBER ) <NEW_LINE> #define VARIANT_HON ( VARIANT_HN | VARIANT_NONE ) <NEW_LINE> #define VARIANT_HOS ( VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING ) <NEW_LINE> #define VARIANT_ANGLE_OR_ZERO ( VARIANT_ANGLE | VARIANT_ZERO_ANGLE ) <NEW_LINE> <START_VULN> class CSSParserImpl : public nsICSSParser { <NEW_LINE> <END_VULN> public: <NEW_LINE> CSSParserImpl ( ) ; <NEW_LINE> virtual ~ CSSParserImpl ( ) ; <NEW_LINE> NS_DECL_ISUPPORTS <NEW_LINE> NS_IMETHOD SetStyleSheet ( nsICSSStyleSheet * aSheet ) ;
{ <NEW_LINE> aReturn . Truncate ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE>PRUint32 textLength = PRUint32 ( mText . GetLength ( ) ) ; <NEW_LINE> <END_VULN> if ( aStart > textLength ) { <NEW_LINE> return NS_ERROR_DOM_INDEX_SIZE_ERR ; <NEW_LINE> }
phar_flush ( entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> RETURN_FALSE ; <NEW_LINE> } else {
if ( ! script ) <NEW_LINE> { <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> <START_VULN> StartupCache * cache = StartupCache::GetSingleton ( ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIIOService > serv = do_GetService ( NS_IOSERVICE_CONTRACTID ) ; <NEW_LINE> if ( ! serv ) { <NEW_LINE> return ReportError ( cx , LOAD_ERROR_NOSERVICE ) ; <NEW_LINE> } <NEW_LINE> rv = NS_NewURI ( getter_AddRefs ( uri ) , urlbytes . ptr ( ) , nsnull , serv ) ;
based temporary image . * / <NEW_LINE> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <NEW_LINE> if ( ! pim ) { <NEW_LINE> <START_VULN> return ; <NEW_LINE> <END_VULN> } <NEW_LINE> tim = pim ; <NEW_LINE> }
if ( ( ISOFS_SB ( inode -> i_sb ) -> s_rock_offset == - 1 ) <NEW_LINE> && ( ISOFS_SB ( inode -> i_sb ) -> s_rock == 2 ) ) { <NEW_LINE> <START_VULN> result = parse_rock_ridge_inode_internal ( de , inode , 14 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return result ; <NEW_LINE> }
else if ( output_gamma == PNG_GAMMA_MAC_18 || <NEW_LINE> output_gamma == PNG_FP_1 / PNG_GAMMA_MAC_18 ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( is_screen ) <NEW_LINE> <END_VULN> output_gamma = PNG_GAMMA_MAC_OLD ; <NEW_LINE> else <NEW_LINE> output_gamma = PNG_GAMMA_MAC_INVERSE ;
<START_VULN> class MEDIA_GPU_EXPORT H264Picture : public base::RefCounted < H264Picture > { <NEW_LINE> <END_VULN> public: <NEW_LINE> using Vector = std::vector < scoped_refptr < H264Picture >> ;
if ( scontains ( value , " = " ) ) { <NEW_LINE> for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { <NEW_LINE> <START_VULN> option = stok ( option , " = , " , & ovalue ) ; <NEW_LINE> <END_VULN> ovalue = strim ( ovalue , "\"'" , MPR_TRIM_BOTH ) ; <NEW_LINE> if ( smatch ( option , "methods" ) ) { <NEW_LINE> methods = ovalue ;
_vp_offset_and_mix ( psy_look , <NEW_LINE> noise , <NEW_LINE> tone , <NEW_LINE> 1 , <NEW_LINE> logmask , <NEW_LINE> mdct , <NEW_LINE> logmdct ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #if 0 <NEW_LINE> if ( vi -> channels == 2 ) { <NEW_LINE> if ( i == 0 ) <NEW_LINE> _analysis_output ( "aotuvM1_L" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ; <NEW_LINE> else <NEW_LINE> _analysis_output ( "aotuvM1_R" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ; <NEW_LINE> } else { <NEW_LINE> _analysis_output ( "aotuvM1" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ;
<START_VULN> #ifndef ThreadableBlobRegistry_h <NEW_LINE>#define ThreadableBlobRegistry_h <NEW_LINE> <END_VULN> #include "wtf / Forward . h" <NEW_LINE> #include "wtf / PassOwnPtr . h"
status = h2_stream_add_header ( stream , ( const char * ) name , namelen , <NEW_LINE> ( const char * ) value , valuelen ) ; <NEW_LINE> <START_VULN> if ( status != APR_SUCCESS && ! h2_stream_is_ready ( stream ) ) { <NEW_LINE> <END_VULN> return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ; <NEW_LINE> } <NEW_LINE> return 0 ;
reset_for ( type_byte_only ) ; <NEW_LINE> char byte = DATA_TYPE_ACL ; <NEW_LINE> <START_VULN> write ( sockfd [ 1 ] , & byte , 1 ) ; <NEW_LINE> <END_VULN> fd_set read_fds ;
bool cacheable_ ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>bool has_opaque_data_ ; <NEW_LINE> <END_VULN>
size_t resultLen = inputLen * 2 ; <NEW_LINE> <START_VULN> output . SetLength ( resultLen ) ; <NEW_LINE> <END_VULN> nsACString::iterator out_iter ; <NEW_LINE> output . BeginWriting ( out_iter ) ;
nsCOMPtr < nsIScriptGlobalObject > sgo = do_QueryInterface ( GetOwner ( ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( sgo , NS_ERROR_FAILURE ) ; <NEW_LINE> nsIScriptContext * scriptContext = sgo -> GetContext ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( scriptContext , NS_ERROR_FAILURE ) ; <NEW_LINE> <START_VULN> JSContext * cx = scriptContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( cx , NS_ERROR_FAILURE ) ; <NEW_LINE> jsval jsData ; <NEW_LINE> { <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> if ( isBinary ) { <NEW_LINE> if ( mBinaryType == BinaryTypeValues::Blob ) {
<START_VULN> v8::Maybe < bool > unused = instance -> Set ( info . GetIsolate ( ) -> GetCurrentContext ( ) , property , value ) ; <NEW_LINE>ALLOW_UNUSED_LOCAL ( unused ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
PRUint32 mPreferredWidth ; <NEW_LINE> PRUint32 mPreferredHeight ; <NEW_LINE> private: <NEW_LINE> PRBool IsVisible ( ) ; <NEW_LINE> void GetToplevelWidget ( GtkWidget ** aWidget ) ; <NEW_LINE> GtkWidget * GetMozContainerWidget ( ) ; <NEW_LINE> <START_VULN> void GetContainerWindow ( nsWindow ** aWindow ) ; <NEW_LINE> <END_VULN> void SetUrgencyHint ( GtkWidget * top_window , PRBool state ) ; <NEW_LINE> void * SetupPluginPort ( void ) ; <NEW_LINE> nsresult SetWindowIconList ( const nsTArray < nsCString > & aIconList ) ; <NEW_LINE> void SetDefaultIcon ( void ) ; <NEW_LINE> void InitButtonEvent ( nsMouseEvent & aEvent , GdkEventButton * aGdkEvent ) ; <NEW_LINE> PRBool DispatchCommandEvent ( nsIAtom * aCommand ) ; <NEW_LINE> GtkWidget * mShell ;
nsresult <NEW_LINE> RasterImage::DecodeSomeData ( uint32_t aMaxBytes , DecodeStrategy aStrategy ) <NEW_LINE> { <NEW_LINE> NS_ABORT_IF_FALSE ( mDecoder , "trying to decode without decoder ! " ) ; <NEW_LINE> <START_VULN> mDecodingMutex . AssertCurrentThreadOwns ( ) ; <NEW_LINE> <END_VULN> if ( mDecodeRequest -> mAllocatedNewFrame ) { <NEW_LINE> mDecodeRequest -> mAllocatedNewFrame = false ; <NEW_LINE> nsresult rv = WriteToDecoder ( nullptr , 0 , aStrategy ) ; <NEW_LINE> if ( NS_FAILED ( rv ) || mDecoder -> NeedsNewFrame ( ) ) {
that unused memory . This might only be a problem if calculations <NEW_LINE> are leaving cruft in those unused bits . However , since Bignums <NEW_LINE> are immutable , this shouldn't happen to us . * / <NEW_LINE> <START_VULN> return String::hash_str ( ( unsigned char * ) a -> dp , a -> used * sizeof ( mp_digit ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> size_t Bignum::managed_memory_size ( STATE ) {
} <NEW_LINE> nsresult <NEW_LINE> nsTransactionItem::GetTransaction ( nsITransaction ** aTransaction ) <NEW_LINE> { <NEW_LINE> if ( ! aTransaction ) <NEW_LINE> return NS_ERROR_NULL_POINTER ; <NEW_LINE> <START_VULN> * aTransaction = mTransaction ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsTransactionItem::GetIsBatch ( PRBool * aIsBatch ) <NEW_LINE> { <NEW_LINE> if ( ! aIsBatch )
if ( ! isNativeTextControl ( ) && ! isNonNativeTextControl ( ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> return equalIgnoringCase ( getAttribute ( aria_multilineAttr ) , "true" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool AXObject::ariaPressedIsPresent ( ) const {
} <NEW_LINE> else <NEW_LINE> { <NEW_LINE> <START_VULN> sprintf ( str + i_level * 5 , <NEW_LINE> <END_VULN> " + % 4 . 4s size: % "PRIu64" pos: % "PRIu64 , <NEW_LINE> ( char * ) & p_chk -> common . i_chunk_fourcc , <NEW_LINE> p_chk -> common . i_chunk_size ,
{ <NEW_LINE> nsAString::const_iterator fromBegin , fromEnd ; <NEW_LINE> nsAString::iterator toBegin ; <NEW_LINE> <START_VULN> aDest . SetLength ( aSource . Length ( ) ) ; <NEW_LINE> <END_VULN> CopyToLowerCase converter ( aDest . BeginWriting ( toBegin ) ) ; <NEW_LINE> copy_string ( aSource . BeginReading ( fromBegin ) , aSource . EndReading ( fromEnd ) , <NEW_LINE> converter ) ;
<START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> @interface WebsiteSettingsBubbleController : BaseBubbleController { <NEW_LINE> @private <NEW_LINE> content::WebContents * webContents_ ;
void <NEW_LINE> mozJSComponentLoader::NoteSubScript ( HandleScript aScript , HandleObject aThisObject ) <NEW_LINE> { <NEW_LINE> if ( ! mInitialized && NS_FAILED ( ReallyInit ( ) ) ) { <NEW_LINE> MOZ_CRASH ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> mThisObjects . Put ( aScript , aThisObject ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> size_t <NEW_LINE> mozJSComponentLoader::DataEntrySizeOfExcludingThis ( const nsACString & aKey , <NEW_LINE> ModuleEntry * const & aData , <NEW_LINE> MallocSizeOf aMallocSizeOf , void * ) <NEW_LINE> { <NEW_LINE> return aKey . SizeOfExcludingThisIfUnshared ( aMallocSizeOf ) +
CVE_2012_3979_nsFrameMessageManager::Dump ( const nsAString & aStr ) <NEW_LINE> { <NEW_LINE> #ifdef ANDROID <NEW_LINE> <START_VULN> __android_log_print ( ANDROID_LOG_INFO , "Gecko" , NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> fputs ( NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) , stdout ) ; <NEW_LINE> fflush ( stdout ) ;
phar_obj -> arc . archive -> ufp = pass . fp ; <NEW_LINE> phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> } <NEW_LINE> } else {
nsCOMPtr < nsILoadGroup > mLoadGroup ; <NEW_LINE> nsCOMPtr < nsIStreamListener > mListener ; <NEW_LINE> nsCOMPtr < nsISupports > mListenerContext ; <NEW_LINE> nsCString mContentType ; <NEW_LINE> nsCString mContentCharset ; <NEW_LINE> PRInt32 mContentLength ; <NEW_LINE> PRUint32 mLoadFlags ; <NEW_LINE> nsresult mStatus ; <NEW_LINE> <START_VULN> PRBool mIsPending ; <NEW_LINE> <END_VULN> nsJARInputThunk * mJarInput ; <NEW_LINE> nsCOMPtr < nsIStreamListener > mDownloader ; <NEW_LINE> nsCOMPtr < nsIInputStreamPump > mPump ; <NEW_LINE> nsCOMPtr < nsIFile > mJarFile ; <NEW_LINE> nsCOMPtr < nsIURI > mJarBaseURI ; <NEW_LINE> nsCString mJarEntry ; <NEW_LINE> } ;
if ( aAttribute == nsGkAtoms::ref ) <NEW_LINE> nsContentUtils::AddScriptRunner ( <NEW_LINE> NS_NewRunnableMethod ( this , & nsXULTemplateBuilder::RunnableRebuild ) ) ; <NEW_LINE> else if ( aAttribute == nsGkAtoms::datasources ) { <NEW_LINE> <START_VULN> Uninit ( PR_FALSE ) ; <NEW_LINE><NEW_LINE>PRBool shouldDelay ; <NEW_LINE>LoadDataSources ( aDocument , & shouldDelay ) ; <NEW_LINE>if ( ! shouldDelay ) <NEW_LINE>nsContentUtils::AddScriptRunner ( <NEW_LINE>NS_NewRunnableMethod ( this , & nsXULTemplateBuilder::RunnableRebuild ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsXULTemplateBuilder::ContentRemoved ( nsIDocument * aDocument , <NEW_LINE> nsIContent * aContainer , <NEW_LINE> nsIContent * aChild ,
} <NEW_LINE> <START_VULN> if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) { <NEW_LINE>vfy |= RPMVERIFY_LSTATFAIL ; <NEW_LINE>goto exit ; <NEW_LINE> <END_VULN> }
-- currentElement ; <NEW_LINE> nsCOMPtr < nsIRDFResource > resource ; <NEW_LINE> <START_VULN> nsXULContentUtils::GetElementResource ( child , getter_AddRefs ( resource ) ) ; <NEW_LINE> <END_VULN> contentSortInfo * contentInfo = CreateContentSortInfo ( child , resource ) ; <NEW_LINE> if ( contentInfo ) <NEW_LINE> contentSortInfoArray [ currentElement ] = contentInfo ;
int num_unknowns = png_get_unknown_chunks ( read_ptr , end_info_ptr , <NEW_LINE> & unknowns ) ; <NEW_LINE> <START_VULN> if ( num_unknowns ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_set_unknown_chunks ( write_ptr , write_end_info_ptr , unknowns , <NEW_LINE> num_unknowns ) ;
if ( cm -> refresh_entropy_probs == 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memcpy ( & cm -> lfc , & cm -> fc , sizeof ( cm -> fc ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> vp8_update_coef_context ( cpi ) ;
fp -> updateEpilogueFlags ( ) ; <NEW_LINE> return ok ? Jaeger_Returned : Jaeger_Throwing ; <NEW_LINE> } <NEW_LINE> static inline JaegerStatus <NEW_LINE> CheckStackAndEnterMethodJIT ( JSContext * cx , StackFrame * fp , void * code , bool partial ) <NEW_LINE> { <NEW_LINE> <START_VULN> JS_CHECK_RECURSION ( cx , return Jaeger_Throwing ) ; <NEW_LINE> <END_VULN> JS_ASSERT ( ! cx -> compartment -> activeAnalysis ) ; <NEW_LINE> JS_ASSERT ( code ) ; <NEW_LINE> Value * stackLimit = cx -> stack . space ( ) . getStackLimit ( cx , REPORT_ERROR ) ; <NEW_LINE> if ( ! stackLimit ) <NEW_LINE> return Jaeger_ThrowBeforeEnter ;
if ( ( c = strstr ( fname , " . pdf" ) ) ) <NEW_LINE> * c = '\0' ; <NEW_LINE> <START_VULN> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <NEW_LINE> <END_VULN> snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , <NEW_LINE> " % s / % s - version - % d . pdf" , dirname , fname , xref -> version ) ;
#define char_to_int ( p ) ( p - '0' ) <NEW_LINE> #define OSSL_MAX ( p , q ) ( ( p >= q ) ? p : q ) <NEW_LINE> <START_VULN> static void <NEW_LINE> <END_VULN> _dopr ( char ** sbuffer , <NEW_LINE> char ** buffer , <NEW_LINE> size_t * maxlen ,
if ( mp4 -> mediafp ) <NEW_LINE> { <NEW_LINE> <START_VULN> uint32_t qttag , qtsize32 , len ; <NEW_LINE> <END_VULN> int32_t nest = 0 ; <NEW_LINE> uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; <NEW_LINE> uint64_t lastsize = 0 , qtsize ;
if ( zip -> codec == _7Z_COPY && zip -> codec2 == ( unsigned long ) - 1 ) { <NEW_LINE> <START_VULN> <NEW_LINE> * buff = __archive_read_ahead ( a , 1 , & bytes_avail ) ; <NEW_LINE> <END_VULN> if ( bytes_avail <= 0 ) { <NEW_LINE> archive_set_error ( & a -> archive , <NEW_LINE> ARCHIVE_ERRNO_FILE_FORMAT ,
PRPackedBool mValid ; <NEW_LINE> PRPackedBool mOpaque ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>nsICanvasElement * mCanvasElement ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIDocShell > mDocShell ;
tx = conn -> tx ; <NEW_LINE> value = sclone ( value ) ; <NEW_LINE> <START_VULN> if ( value == 0 ) { <NEW_LINE>return 0 ; <NEW_LINE> } <NEW_LINE> <END_VULN>
for ( i = 0 ; i < PACKETBLOBS ; i ++ ) { <NEW_LINE> if ( i == PACKETBLOBS / 2 ) { <NEW_LINE> vbi -> packetblob [ i ] = & vb -> opb ; <NEW_LINE> } else { <NEW_LINE> vbi -> packetblob [ i ] = <NEW_LINE> _ogg_calloc ( 1 , sizeof ( oggpack_buffer ) ) ; <NEW_LINE> } <NEW_LINE> oggpack_writeinit ( vbi -> packetblob [ i ] ) ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> } <NEW_LINE> return ( 0 ) ; <NEW_LINE> } <NEW_LINE> void * _vorbis_block_alloc ( vorbis_block * vb , long bytes ) { <NEW_LINE> bytes = ( bytes + ( WORD_ALIGN - 1 ) ) & ~ ( WORD_ALIGN - 1 ) ; <NEW_LINE> if ( bytes + vb -> localtop > vb -> localalloc ) {
PNG_DFN "OS2 CODE PRELOAD MOVEABLE DISCARDABLE" <NEW_LINE> PNG_DFN "" <NEW_LINE> PNG_DFN "EXPORTS" <NEW_LINE> <START_VULN> PNG_DFN " ; Version 1 . 6 . 10" <NEW_LINE> <END_VULN> #define PNG_EXPORTA ( ordinal , type , name , args , attributes ) \ <NEW_LINE> PNG_DFN "@" SYMBOL_PREFIX "@@" name "@"
nsGenericElement::UnbindFromTree ( PRBool aDeep , PRBool aNullParent ) <NEW_LINE> { <NEW_LINE> NS_PRECONDITION ( aDeep || ( ! GetCurrentDoc ( ) && ! GetBindingParent ( ) ) , <NEW_LINE> "Shallow unbind won't clear document and binding parent on " <NEW_LINE> "kids ! " ) ; <NEW_LINE> nsIDocument * document = <NEW_LINE> HasFlag ( NODE_FORCE_XBL_BINDINGS ) ? GetOwnerDoc ( ) : GetCurrentDoc ( ) ; <NEW_LINE> if ( document ) { <NEW_LINE> document -> BindingManager ( ) -> ChangeDocumentFor ( this , document , nsnull ) ; <NEW_LINE> if ( HasAttr ( kNameSpaceID_XLink , nsGkAtoms::href ) ) { <NEW_LINE> document -> ForgetLink ( this ) ; <NEW_LINE> } <NEW_LINE> document -> ClearBoxObjectFor ( this ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>mParentPtrBits = aNullParent ? 0 : mParentPtrBits & ~ PARENT_BIT_INDOCUMENT ; <NEW_LINE><NEW_LINE> <END_VULN> UnsetFlags ( NODE_FORCE_XBL_BINDINGS ) ; <NEW_LINE> #ifdef MOZ_XUL <NEW_LINE> nsXULElement * xulElem = nsXULElement::FromContent ( this ) ; <NEW_LINE> if ( xulElem ) { <NEW_LINE> xulElem -> SetXULBindingParent ( nsnull ) ; <NEW_LINE> }
bool isVector ( ) const { return size > 1 && ! matrix ; } <NEW_LINE> bool isScalar ( ) const { return size == 1 && ! matrix && ! structure ; } <NEW_LINE> TTypeList * getStruct ( ) const { return structure ; } <NEW_LINE> void setStruct ( TTypeList * s ) { structure = s ; computeDeepestStructNesting ( ) ; } <NEW_LINE> const TString & getTypeName ( ) const <NEW_LINE> { <NEW_LINE> <START_VULN> assert ( typeName ) ; <NEW_LINE> <END_VULN> return * typeName ; <NEW_LINE> } <NEW_LINE> void setTypeName ( const TString & n ) <NEW_LINE> { <NEW_LINE> typeName = NewPoolTString ( n . c_str ( ) ) ; <NEW_LINE> } <NEW_LINE> bool isField ( ) const { return fieldName != 0 ; }
nsAutoTArray < nsIContent * , 8 > ungenerated ; <NEW_LINE> if ( ungenerated . AppendElement ( aElement ) == nsnull ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> PRUint32 count ; <NEW_LINE> while ( 0 != ( count = ungenerated . Length ( ) ) ) { <NEW_LINE> PRUint32 last = count - 1 ; <NEW_LINE> <START_VULN> nsIContent * element = ungenerated [ last ] ; <NEW_LINE> <END_VULN> ungenerated . RemoveElementAt ( last ) ; <NEW_LINE> PRUint32 i = element -> GetChildCount ( ) ; <NEW_LINE> while ( i -- > 0 ) { <NEW_LINE> nsCOMPtr < nsIContent > child = element -> GetChildAt ( i ) ;
m_scrollableArea -> updateAfterStyleChange ( oldStyle ) ; <NEW_LINE> if ( ! oldStyle || oldStyle -> visibility ( ) != renderer ( ) -> style ( ) -> visibility ( ) ) { <NEW_LINE> <START_VULN> ASSERT ( ! oldStyle || diff >= StyleDifferenceRepaint ) ; <NEW_LINE> <END_VULN> compositor ( ) -> setNeedsUpdateCompositingRequirementsState ( ) ; <NEW_LINE> }
tmp = end ; <NEW_LINE> <START_VULN> error = prctl_update_vma_anon_name ( vma , & prev , start , end , <NEW_LINE> <END_VULN> ( const char __user * ) arg ) ; <NEW_LINE> if ( error ) <NEW_LINE> return error ;
} <NEW_LINE> LayoutUnit totalLogicalHeight = lineHeight + max ( ZERO_LAYOUT_UNIT , logicalOffset ) ; <NEW_LINE> LayoutUnit pageLogicalHeightAtNewOffset = hasUniformPageLogicalHeight ? pageLogicalHeight : pageLogicalHeightForOffset ( logicalOffset + remainingLogicalHeight ) ; <NEW_LINE> <START_VULN> if ( lineBox == firstRootBox ( ) && totalLogicalHeight < pageLogicalHeightAtNewOffset && ! isPositioned ( ) && ! isTableCell ( ) ) <NEW_LINE> <END_VULN> setPaginationStrut ( remainingLogicalHeight + max ( ZERO_LAYOUT_UNIT , logicalOffset ) ) ; <NEW_LINE> else { <NEW_LINE> delta += remainingLogicalHeight ;
if ( smatch ( expr , " * " ) ) { <NEW_LINE> expr = "x" ; <NEW_LINE> } <NEW_LINE> <START_VULN> version = stok ( sclone ( version ) , " - " , & preVersion ) ; <NEW_LINE>base = stok ( sclone ( expr ) , " - " , & pre ) ; <NEW_LINE> <END_VULN> if ( op && ( * op == ' ~ ' || * op == ' ^ ' ) ) { <NEW_LINE> if ( * op == ' ^ ' && schr ( version , ' - ' ) ) { <NEW_LINE> return 0 ;
<START_VULN> PRInt32 approxLen = 3 ; <NEW_LINE> <END_VULN> if ( mScheme . mLen > 0 )
cchar * name , * args ; <NEW_LINE> if ( prop -> type & MPR_JSON_OBJ ) { <NEW_LINE> <START_VULN> name = mprGetJson ( prop , "operation" ) ; <NEW_LINE>args = mprGetJson ( prop , "args" ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> name = "run" ; <NEW_LINE> args = prop -> value ;
MOZ_ASSERT ( cx ) ; <NEW_LINE> nsCOMPtr < nsIScriptGlobalObject > sgo = do_QueryInterface ( GetOwner ( ) ) ; <NEW_LINE> JSObject * ownerObj = sgo -> GetGlobalJSObject ( ) ; <NEW_LINE> NS_ENSURE_TRUE_VOID ( ownerObj ) ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> NS_ENSURE_TRUE_VOID ( pusher . Push ( cx , false ) ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , ownerObj ) ; <NEW_LINE> JSObject * array = JS_NewArrayObject ( cx , aItems . Length ( ) , nullptr ) ; <NEW_LINE> NS_ENSURE_TRUE_VOID ( array ) ; <NEW_LINE> bool ok ;
#else <NEW_LINE> <START_VULN> static inline zend_ulong realpath_cache_key ( const char * path , int path_len ) <NEW_LINE> <END_VULN> { <NEW_LINE> register zend_ulong h ; <NEW_LINE> const char * e = path + path_len ;
virtual ~ SerializerMarkupAccumulator ( ) ; <NEW_LINE> protected: <NEW_LINE> <START_VULN> virtual void appendText ( StringBuilder & , Text * ) OVERRIDE ; <NEW_LINE>virtual void appendElement ( StringBuilder & , Element * , Namespaces * ) OVERRIDE ; <NEW_LINE>virtual void appendCustomAttributes ( StringBuilder & , Element * , Namespaces * ) OVERRIDE ; <NEW_LINE>virtual void appendEndTag ( Node * ) OVERRIDE ; <NEW_LINE> <END_VULN> PageSerializer * m_serializer ; <NEW_LINE> Document * m_document ; <NEW_LINE> } ;
ENTROPY_CONTEXT * ta_b ; <NEW_LINE> ENTROPY_CONTEXT * tl_b ; <NEW_LINE> <START_VULN> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE> <END_VULN> ta = ( ENTROPY_CONTEXT * ) & t_above ; <NEW_LINE> tl = ( ENTROPY_CONTEXT * ) & t_left ;
{ <NEW_LINE> char sig_on = 1 ; <NEW_LINE> BTIF_TRACE_EVENT ( "UIPC SEND WAKE UP" ) ; <NEW_LINE> <START_VULN> send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int uipc_setup_server_locked ( tUIPC_CH_ID ch_id , char * name , tUIPC_RCV_CBACK * cback )
} <NEW_LINE> NS_ENSURE_TRUE ( uri , NS_ERROR_FAILURE ) ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> if ( ! pusher . PushNull ( ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIXULWindow > newWindow ; <NEW_LINE> appShell -> CreateTopLevelWindow ( this , uri , <NEW_LINE> aChromeFlags , 615 , 480 , <NEW_LINE> getter_AddRefs ( newWindow ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( newWindow , NS_ERROR_FAILURE ) ; <NEW_LINE> pusher . Pop ( ) ;
int yy_bs_column ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsUTF16LEToUnicode::Convert ( const char * aSrc , PRInt32 * aSrcLength , <NEW_LINE> PRUnichar * aDest , PRInt32 * aDestLength ) <NEW_LINE> { <NEW_LINE> #ifdef IS_BIG_ENDIAN <NEW_LINE> if ( STATE_FIRST_CALL == mState ) <NEW_LINE> { <NEW_LINE> mState = STATE_NORMAL ; <NEW_LINE> <START_VULN> if ( * aSrcLength < 2 ) <NEW_LINE>return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> <END_VULN> if ( 0xFFFE == * ( ( PRUnichar * ) aSrc ) ) { <NEW_LINE> mState = STATE_FOUND_BOM ; <NEW_LINE> } else if ( 0xFEFF == * ( ( PRUnichar * ) aSrc ) ) { <NEW_LINE> * aSrcLength = 0 ; <NEW_LINE> * aDestLength = 0 ; <NEW_LINE> return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> <START_VULN> singletonPos = getSingletonPos ( loc_name ) ; <NEW_LINE> <END_VULN> if ( singletonPos == 0 ) {
void * SoftMP3::memsetSafe ( OMX_BUFFERHEADERTYPE * outHeader , int c , size_t len ) { <NEW_LINE> if ( len > outHeader -> nAllocLen ) { <NEW_LINE> <START_VULN> ALOGE ( "memset buffer too small: got % lu , expected % zu" , outHeader -> nAllocLen , len ) ; <NEW_LINE> <END_VULN> android_errorWriteLog ( 0x534e4554 , "29422022" ) ; <NEW_LINE> notify ( OMX_EventError , OMX_ErrorUndefined , OUTPUT_BUFFER_TOO_SMALL , NULL ) ; <NEW_LINE> mSignalledError = true ;
CheckInvalidateSizeChange ( aDesiredSize ) ; <NEW_LINE> FinishAndStoreOverflow ( & aDesiredSize ) ; <NEW_LINE> aDesiredSize . mCarriedOutBottomMargin = carriedOutBottomMargin ; <NEW_LINE> NS_FRAME_SET_TRUNCATION ( aStatus , aReflowState , aDesiredSize ) ; <NEW_LINE> <START_VULN> NS_ASSERTION ( NS_FRAME_IS_COMPLETE ( aStatus ) || <NEW_LINE> <END_VULN> aReflowState . availableHeight != NS_UNCONSTRAINEDSIZE , <NEW_LINE> "Column set should be complete if the available height is unconstrained" ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsColumnSetFrame::BuildDisplayList ( nsDisplayListBuilder * aBuilder ,
#include < jasper / jas_config . h > <NEW_LINE> #include < jasper / jas_types . h > <NEW_LINE> <START_VULN> uchar jas_iccprofdata_srgb [ ] = <NEW_LINE> <END_VULN> { <NEW_LINE> 0x00 , 0x00 , 0x0c , 0x48 , 0x4c , 0x69 , 0x6e , 0x6f , <NEW_LINE> 0x02 , 0x10 , 0x00 , 0x00 , 0x6d , 0x6e , 0x74 , 0x72 ,
PORT_ZFree ( slotPw . data , PL_strlen ( slotPw . data ) ) ; <NEW_LINE> if ( p12FilePw . data != NULL ) <NEW_LINE> PORT_ZFree ( p12FilePw . data , PL_strlen ( p12FilePw . data ) ) ; <NEW_LINE> if ( slot ) <NEW_LINE> PK11_FreeSlot ( slot ) ; <NEW_LINE> if ( NSS_Shutdown ( ) != SECSuccess ) { <NEW_LINE> pk12uErrno = 1 ; <NEW_LINE> } <NEW_LINE> PR_Cleanup ( ) ; <NEW_LINE> <START_VULN> PL_ArenaFinish ( ) ; <NEW_LINE> <END_VULN> return pk12uErrno ; <NEW_LINE> }
#include "vpx_config . h" <NEW_LINE> #include "vp8_rtcd . h" <NEW_LINE> <START_VULN> #include "quantize . h" <NEW_LINE> <END_VULN> #include "vp8 / common / reconintra4x4 . h" <NEW_LINE> #include "encodemb . h" <NEW_LINE> #include "vp8 / common / invtrans . h"
#define LIBRAW_MAJOR_VERSION 0 <NEW_LINE> #define LIBRAW_MINOR_VERSION 16 <NEW_LINE> <START_VULN> #define LIBRAW_PATCH_VERSION 0 <NEW_LINE> <END_VULN> #define LIBRAW_VERSION_TAIL Release <NEW_LINE> #define LIBRAW_SHLIB_CURRENT 10
@param obj Parsed JSON object returned by mprParseJson <NEW_LINE> @return The number of direct dependent child properties <NEW_LINE> @ingroup MprJson <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC ssize mprGetJsonLength ( MprJson * obj ) ;
} <NEW_LINE> JSJavaThreadState * jsj_env = NULL ; <NEW_LINE> JSObjectHandle * handle = ( JSObjectHandle * ) obj ; <NEW_LINE> JSObject * js_obj = handle -> js_obj ; <NEW_LINE> JSContext * cx = NULL ; <NEW_LINE> JSErrorReporter saved_state = NULL ; <NEW_LINE> jstring result = NULL ; <NEW_LINE> JSString * jsstr = NULL ; <NEW_LINE> jsj_env = jsj_enter_js ( jEnv , mJavaClient , NULL , & cx , NULL , & saved_state , NULL , 0 , NULL ) ; <NEW_LINE> if ( ! jsj_env ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> result = NULL ; <NEW_LINE> <START_VULN> AutoPushJSContext autopush ( nsnull , cx ) ; <NEW_LINE>if ( NS_FAILED ( autopush . ResultOfPush ( ) ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> <END_VULN> jsstr = JS_ValueToString ( cx , OBJECT_TO_JSVAL ( js_obj ) ) ; <NEW_LINE> if ( jsstr ) <NEW_LINE> result = jsj_ConvertJSStringToJavaString ( cx , jEnv , jsstr ) ; <NEW_LINE> if ( ! result ) <NEW_LINE> result = jEnv -> NewStringUTF ( " * JavaObject * " ) ; <NEW_LINE> if ( ! jsj_exit_js ( cx , jsj_env , saved_state ) ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> * pjstring = result ;
template < typename T , typename . . . Args > <NEW_LINE> std::unique_ptr < T > SpdyMakeUniqueImpl ( Args && . . . args ) { <NEW_LINE> <START_VULN> return base::MakeUnique < T > ( std::forward < Args > ( args ) . . . ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> template < typename T >
& _vq_book_res0a_13 , NULL } ; <NEW_LINE> float * testvec [ ] = { test1 , test3 } ; <NEW_LINE> int main ( ) { <NEW_LINE> oggpack_buffer write ; <NEW_LINE> oggpack_buffer read ; <NEW_LINE> long ptr = 0 , i ; <NEW_LINE> oggpack_writeinit ( & write ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> fprintf ( stderr , "Testing codebook abstraction . . . :\n" ) ; <NEW_LINE> while ( testlist [ ptr ] ) { <NEW_LINE> codebook c ; <NEW_LINE> static_codebook s ; <NEW_LINE> float * qv = alloca ( sizeof ( * qv ) * TESTSIZE ) ; <NEW_LINE> float * iv = alloca ( sizeof ( * iv ) * TESTSIZE ) ; <NEW_LINE> memcpy ( qv , testvec [ ptr ] , sizeof ( * qv ) * TESTSIZE ) ;
for ( i = 0 ; i < h ; i ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , el ) ; <NEW_LINE>vpx_memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; <NEW_LINE>vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , er ) ; <NEW_LINE> <END_VULN> src_ptr1 += sp ; <NEW_LINE> src_ptr2 += sp ; <NEW_LINE> dest_ptr1 += dp ;
compression = image_info -> compression ; <NEW_LINE> range = GetQuantumRange ( 5UL ) ; <NEW_LINE> tga_info . id_length = 0 ; <NEW_LINE> <START_VULN> value = GetImageProperty ( image , "comment" ) ; <NEW_LINE>if ( value != ( const char * ) NULL ) <NEW_LINE>tga_info . id_length = ( unsigned char ) MagickMin ( strlen ( value ) , 255 ) ; <NEW_LINE> <END_VULN> tga_info . colormap_type = 0 ; <NEW_LINE> tga_info . colormap_index = 0 ; <NEW_LINE> tga_info . colormap_length = 0 ;
IPC_MESSAGE_ROUTED3 ( AcceleratedVideoDecoderMsg_Decode , <NEW_LINE> base::SharedMemoryHandle , <NEW_LINE> int32 , <NEW_LINE> <START_VULN> int32 ) <NEW_LINE> <END_VULN>
#include "core / platform / graphics / FontCache . h" <NEW_LINE> #include "core / platform / graphics / FontDescription . h" <NEW_LINE> #include "core / platform / graphics / chromium / FontPlatformDataChromiumWin . h" <NEW_LINE> <START_VULN> #include "core / platform / win / HWndDC . h" <NEW_LINE> <END_VULN> #include "platform / geometry / FloatRect . h" <NEW_LINE> #include "wtf / MathExtras . h" <NEW_LINE> namespace WebCore {
gpointer user_data ) <NEW_LINE> { <NEW_LINE> struct tcmur_handler * handler = find_handler_by_subtype ( subtype ) ; <NEW_LINE> <START_VULN> struct dbus_info * info = handler -> opaque ; <NEW_LINE> <END_VULN> if ( ! handler ) { <NEW_LINE> g_dbus_method_invocation_return_value ( invocation ,
virtual Session * session ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> virtual void Disconnect ( ) ;
bool AXObject::isLiveRegion ( ) const { <NEW_LINE> const AtomicString & liveRegion = liveRegionStatus ( ) ; <NEW_LINE> <START_VULN> return equalIgnoringCase ( liveRegion , "polite" ) || <NEW_LINE>equalIgnoringCase ( liveRegion , "assertive" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> AXObject * AXObject::liveRegionRoot ( ) const {
iPinCount = iACLen - 1 ; <NEW_LINE> if ( buf [ iOffset ] & 0x20 ) { <NEW_LINE> <START_VULN> int iSC = buf [ iOffset + iACLen ] ; <NEW_LINE> <END_VULN> switch ( ( iSC >> 5 ) & 0x03 ) { <NEW_LINE> case 0:
png_crc_read ( png_ptr , buf , 9 ) ; <NEW_LINE> <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> res_x = png_get_uint_32 ( buf ) ;
if ( v . isArray ( ) ) { <NEW_LINE> Array subarr1 = v . toArray ( ) ; <NEW_LINE> const ArrNR & arr_value = value . toArrNR ( ) ; <NEW_LINE> <START_VULN> php_array_replace_recursive ( seen , couldRecur ( v , subarr1 ) , <NEW_LINE> <END_VULN> subarr1 , arr_value ) ; <NEW_LINE> v = subarr1 ; <NEW_LINE> } else {
<START_VULN> if ( cdigits + czero - clead + 1 < ( int ) precision ) <NEW_LINE> <END_VULN> fp = modf ( fp , & d ) ; <NEW_LINE> else
break ; <NEW_LINE> o -> m_bitfields . setPreferredLogicalWidthsDirty ( true ) ; <NEW_LINE> <START_VULN> if ( o -> style ( ) -> isPositioned ( ) ) <NEW_LINE> <END_VULN> break ;
} <NEW_LINE> return pdu_len + 4 ; <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , "\n\t\t packet exceeded snapshot" ) ) ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 784 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy25: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' , ' ) {
if ( compile_options ) { <NEW_LINE> * compile_options = pce ? pce -> compile_options : 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return pce ? pce -> re : NULL ; <NEW_LINE> }
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void nsComboboxControlFrame::FireValueChangeEvent ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsCOMPtr < nsIDOMEvent > event ; <NEW_LINE>nsPresContext * presContext = PresContext ( ) ; <NEW_LINE>if ( NS_SUCCEEDED ( nsEventDispatcher::CreateEvent ( presContext , nsnull , <NEW_LINE>NS_LITERAL_STRING ( "Events" ) , <NEW_LINE>getter_AddRefs ( event ) ) ) ) { <NEW_LINE>event -> InitEvent ( NS_LITERAL_STRING ( "ValueChange" ) , PR_TRUE , PR_TRUE ) ; <NEW_LINE><NEW_LINE>nsCOMPtr < nsIPrivateDOMEvent > privateEvent ( do_QueryInterface ( event ) ) ; <NEW_LINE>privateEvent -> SetTrusted ( PR_TRUE ) ; <NEW_LINE>nsEventDispatcher::DispatchDOMEvent ( mContent , nsnull , event , nsnull , <NEW_LINE>nsnull ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsComboboxControlFrame::OnContentReset ( ) <NEW_LINE> { <NEW_LINE> if ( mListControlFrame ) { <NEW_LINE> mListControlFrame -> OnContentReset ( ) ; <NEW_LINE> }
extern const char kInvalidWebview [ ] ; <NEW_LINE> extern const char kInvalidWebviewAccessibleResourcesList [ ] ; <NEW_LINE> extern const char kInvalidWebviewAccessibleResource [ ] ; <NEW_LINE> <START_VULN> extern const char kInvalidWebviewPrivilegedPartitionList [ ] ; <NEW_LINE>extern const char kInvalidWebviewPrivilegedPartition [ ] ; <NEW_LINE> <END_VULN> extern const char kInvalidWebURL [ ] ; <NEW_LINE> extern const char kInvalidWebURLs [ ] ; <NEW_LINE> extern const char kInvalidZipHash [ ] ;
resetPlugin ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void SoftAVC::setDecodeArgs ( <NEW_LINE> <END_VULN> ivd_video_decode_ip_t * ps_dec_ip , <NEW_LINE> ivd_video_decode_op_t * ps_dec_op , <NEW_LINE> OMX_BUFFERHEADERTYPE * inHeader ,
if ( aReflowState . ShouldReflowAllKids ( ) ) { <NEW_LINE> reflowContent = mContentFrame != nsnull ; <NEW_LINE> reflowLegend = mLegendFrame != nsnull ; <NEW_LINE> } else { <NEW_LINE> reflowContent = mContentFrame && NS_SUBTREE_DIRTY ( mContentFrame ) ; <NEW_LINE> reflowLegend = mLegendFrame && NS_SUBTREE_DIRTY ( mLegendFrame ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsSize availSize ( aReflowState . ComputedWidth ( ) , aReflowState . availableHeight ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( ! mContentFrame || <NEW_LINE> nsLayoutUtils::IntrinsicForContainer ( aReflowState . rendContext , <NEW_LINE> mContentFrame , <NEW_LINE> nsLayoutUtils::MIN_WIDTH ) <= <NEW_LINE> availSize . width , <NEW_LINE> "Bogus availSize . width ; should be bigger" ) ; <NEW_LINE> NS_ASSERTION ( ! mLegendFrame || <NEW_LINE> nsLayoutUtils::IntrinsicForContainer ( aReflowState . rendContext ,
nsIURI * uri = doc -> GetDocumentURI ( ) ; <NEW_LINE> if ( uri ) { <NEW_LINE> uri -> GetSpec ( url ) ; <NEW_LINE> lineNo = 1 ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> if ( aNeedsCxPush && ! pusher . Push ( cx ) ) { <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> <END_VULN> } <NEW_LINE> uint32_t argCount ; <NEW_LINE> const char ** argNames ;
UCHAR ucTV_BootUpDefaultStandard ; <NEW_LINE> UCHAR ucExt_TV_ASIC_ID ; <NEW_LINE> UCHAR ucExt_TV_ASIC_SlaveAddr ; <NEW_LINE> <START_VULN> ATOM_DTD_FORMAT aModeTimings [ MAX_SUPPORTED_TV_TIMING ] ; <NEW_LINE> <END_VULN> } ATOM_ANALOG_TV_INFO_V1_2 ; <NEW_LINE> typedef struct _ATOM_DPCD_INFO
Compatible Regular Expression library . It defines the things POSIX says should <NEW_LINE> be there . I hope . <NEW_LINE> <START_VULN> Copyright ( c ) 1997 - 2007 University of Cambridge <NEW_LINE> <END_VULN> -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - <NEW_LINE> Redistribution and use in source and binary forms , with or without
* sp = ( png_byte ) ( tmp & 0xff ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! shift ) <NEW_LINE> <END_VULN> { <NEW_LINE> shift = 7 ; <NEW_LINE> sp ++ ;
mul: <NEW_LINE> #endif <NEW_LINE> MBEDTLS_MPI_CHK ( mbedtls_ecp_mul_restartable ( grp , & R , pk , & grp -> G , <NEW_LINE> <START_VULN> f_rng , p_rng , ECDSA_RS_ECP ) ) ; <NEW_LINE> <END_VULN> MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pr , & R . X , & grp -> N ) ) ; <NEW_LINE> } <NEW_LINE> while ( mbedtls_mpi_cmp_int ( pr , 0 ) == 0 ) ;
if ( pszFileName [ 0 ] == ' / ' ) <NEW_LINE> { <NEW_LINE> <START_VULN> strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else <NEW_LINE> {
class nsHttpResponseHead <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> <START_VULN> nsHttpResponseHead ( ) : mHeaders ( nsHttpHeaderArray::HTTP_RESPONSE_HEADERS ) <NEW_LINE> , mVersion ( NS_HTTP_VERSION_1_1 ) <NEW_LINE> <END_VULN> , mStatus ( 200 ) <NEW_LINE> , mContentLength ( LL_MAXUINT ) <NEW_LINE> , mCacheControlNoStore ( PR_FALSE ) <NEW_LINE> , mCacheControlNoCache ( PR_FALSE ) <NEW_LINE> , mPragmaNoCache ( PR_FALSE ) { } <NEW_LINE> ~ nsHttpResponseHead ( ) <NEW_LINE> { <NEW_LINE> Reset ( ) ;
{ <NEW_LINE> unsigned int back_alpha ; <NEW_LINE> <START_VULN> if ( output_format & PNG_FORMAT_FLAG_ALPHA ) <NEW_LINE> <END_VULN> back_alpha = 0 ; <NEW_LINE> else
command = sclone ( mprLookupKey ( args , "CMD" ) ) ; <NEW_LINE> data = 0 ; <NEW_LINE> if ( scontains ( command , " | " ) ) { <NEW_LINE> <START_VULN> data = stok ( command , " | " , & command ) ; <NEW_LINE> <END_VULN> data = stemplate ( data , args ) ; <NEW_LINE> } <NEW_LINE> command = strim ( command , " \t" , MPR_TRIM_BOTH ) ;
( void ) SetImageArtifact ( image , key , token ) ; <NEW_LINE> ( void ) FormatLocaleString ( key , MagickPathExtent , " % s - type" , name ) ; <NEW_LINE> ( void ) SetImageArtifact ( image , key , type ) ; <NEW_LINE> <START_VULN> ( void ) FormatLocaleString ( key , MagickPathExtent , " % s - geometry" , name ) ; <NEW_LINE> <END_VULN> ( void ) FormatLocaleString ( geometry , MagickPathExtent , <NEW_LINE> " % gx % g % + . 15g % + . 15g" , <NEW_LINE> MagickMax ( fabs ( bounds . x2 - bounds . x1 + 1 . 0 ) , 1 . 0 ) ,
else if ( color_type == PNG_COLOR_TYPE_GRAY ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( tran -> gray >= ( 1 << png_ptr -> bit_depth ) ) <NEW_LINE> { <NEW_LINE> png_app_warning ( png_ptr ,
void RenderBox::positionLineBox ( InlineBox * box ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( isPositioned ( ) ) { <NEW_LINE> <END_VULN> bool wasInline = style ( ) -> isOriginalDisplayInlineType ( ) ; <NEW_LINE> if ( wasInline ) {
& LogController , NJConfig ) ; <NEW_LINE> verbose_only ( branches = NULL ; ) <NEW_LINE> PodArrayZero ( vmfragments ) ; <NEW_LINE> tracedScripts . clear ( ) ; <NEW_LINE> needFlush = JS_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> inline bool <NEW_LINE>HasUnreachableGCThings ( JSContext * cx , TreeFragment * f ) <NEW_LINE> { <NEW_LINE> <END_VULN> if ( IsAboutToBeFinalized ( cx , f -> globalObj ) ) <NEW_LINE> return true ; <NEW_LINE> Value * vp = f -> gcthings . data ( ) ; <NEW_LINE> for ( unsigned len = f -> gcthings . length ( ) ; len ; -- len ) {
#ifdef CONFIG_COMPAT <NEW_LINE> . compat_ioctl = ecryptfs_compat_ioctl , <NEW_LINE> #endif <NEW_LINE> <START_VULN> . mmap = generic_file_mmap , <NEW_LINE> <END_VULN> . open = ecryptfs_open , <NEW_LINE> . flush = ecryptfs_flush , <NEW_LINE> . release = ecryptfs_release ,
continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> CHECK ( dstOffset + 4 <= mBuffer -> size ( ) ) ; <NEW_LINE> <END_VULN> dstData [ dstOffset ++ ] = 0 ; <NEW_LINE> dstData [ dstOffset ++ ] = 0 ;
{ <NEW_LINE> png_debug ( 1 , "in png_set_gamma_fixed" ) ; <NEW_LINE> <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ;
infobars::InfoBarDelegate::InfoBarIdentifier GetIdentifier ( ) const override ; <NEW_LINE> private: <NEW_LINE> <START_VULN> explicit SendTabToSelfInfoBarDelegate ( const SendTabToSelfEntry * entry ) ; <NEW_LINE> <END_VULN> const SendTabToSelfEntry * entry_ = nullptr ;
return args . Holder ( ) ; <NEW_LINE> if ( args . Length ( ) == 0 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> v8::TryCatch tryCatch ; <NEW_LINE> v8::Handle < v8::String > urlstring = args [ 0 ] -> ToString ( ) ;
#include < windows . h > <NEW_LINE> #include "nscore . h" <NEW_LINE> #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN <NEW_LINE> #include < dwmapi . h > <NEW_LINE> #endif <NEW_LINE> <START_VULN> #if defined ( WINCE ) || ( MOZ_WINSDK_TARGETVER == MOZ_NTDDI_WS03 ) <NEW_LINE> <END_VULN> struct MARGINS <NEW_LINE> { <NEW_LINE> int cxLeftWidth ; <NEW_LINE> int cxRightWidth ; <NEW_LINE> int cyTopHeight ; <NEW_LINE> int cyBottomHeight ; <NEW_LINE> } ; <NEW_LINE> #endif
spec = sfmt ( "mdb: <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> <START_VULN> provider = stok ( sclone ( spec ) , ": <NEW_LINE>if ( provider == 0 || path == 0 ) { <NEW_LINE> <END_VULN> return MPR_ERR_BAD_ARGS ; <NEW_LINE> } <NEW_LINE> path = mprJoinPath ( httpGetDir ( route , "db" ) , path ) ;
} <NEW_LINE> <START_VULN> virtual void cryptographicallyRandomValues ( unsigned char * buffer , size_t length ) { ASSERT_NOT_REACHED ( ) ; } <NEW_LINE> <END_VULN> virtual const unsigned char * getTraceCategoryEnabledFlag ( const char * categoryName ) <NEW_LINE> { <NEW_LINE> return & kAConstUnsignedCharZero ;
i = ac - 1 ; <NEW_LINE> limit = - 1 ; <NEW_LINE> step = - 1 ; <NEW_LINE> } <NEW_LINE> nsAutoString key ; <NEW_LINE> for ( ; i != limit ; i += step ) { <NEW_LINE> <START_VULN> nsContentUtils::ASCIIToLower ( aNode . GetKeyAt ( i ) , key ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIAtom > keyAtom = do_GetAtom ( key ) ; <NEW_LINE> if ( aCheckIfPresent && aContent -> HasAttr ( kNameSpaceID_None , keyAtom ) ) { <NEW_LINE> continue ; <NEW_LINE> }
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . methodWithNonOptionalArgAndTwoOptionalArgs" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( int , nonOpt , toInt32 ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( args . Length ( ) <= 1 ) {
if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && <NEW_LINE> qttag != MAKEID ( 'u' , 'd' , 't' , 'a' ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <NEW_LINE> <END_VULN> NESTSIZE ( qtsize ) ; <NEW_LINE> continue ; <NEW_LINE> }
<START_VULN> #ifndef BASE_ANDROID_LIBRARY_LOAD_FROM_APK_STATUS_CODES_H_ <NEW_LINE>#define BASE_ANDROID_LIBRARY_LOAD_FROM_APK_STATUS_CODES_H_ <NEW_LINE> <END_VULN> namespace base { <NEW_LINE> namespace android {
} <NEW_LINE> } <NEW_LINE> <START_VULN> if ( pmd_none_or_clear_bad ( pmd ) ) <NEW_LINE> <END_VULN> mincore_unmapped_range ( vma , addr , next , vec ) ; <NEW_LINE> else <NEW_LINE> mincore_pte_range ( vma , pmd , addr , next , vec ) ;
else <NEW_LINE> dstStartCopyPosition = ( dstPoint . y ( ) + i ) * dstPixelBytesPerRow + <NEW_LINE> dstPoint . x ( ) * bytesPerPixel ; <NEW_LINE> <START_VULN> for ( size_t j = 0 ; j < srcEndCopyPosition - srcStartCopyPosition ; <NEW_LINE> <END_VULN> j ++ ) { <NEW_LINE> if ( kN32_SkColorType == kBGRA_8888_SkColorType ) {
} <NEW_LINE> * tail = vp ; <NEW_LINE> <START_VULN> while ( * tail ) tail = & vp -> next ; <NEW_LINE> <END_VULN> p += alen ; <NEW_LINE> } <NEW_LINE> }
} <NEW_LINE> #endif <NEW_LINE> nsHttpTransaction::nsHttpTransaction ( ) <NEW_LINE> <START_VULN> : mCallbacksLock ( "transaction mCallbacks lock" ) <NEW_LINE> <END_VULN> , mRequestSize ( 0 ) <NEW_LINE> , mConnection ( nullptr ) <NEW_LINE> , mConnInfo ( nullptr ) <NEW_LINE> , mRequestHead ( nullptr ) <NEW_LINE> , mResponseHead ( nullptr ) <NEW_LINE> , mContentLength ( - 1 ) <NEW_LINE> , mContentRead ( 0 ) <NEW_LINE> , mInvalidResponseBytesRead ( 0 )
lfm -> int_4x4_y &= mask_y ; <NEW_LINE> lfm -> int_4x4_uv &= mask_uv ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( rows == 1 ) { <NEW_LINE> lfm -> above_uv [ TX_8X8 ] |= lfm -> above_uv [ TX_16X16 ] ;
conn -> sasl_mechanism = SASL_MECHANISM_PLAIN ; <NEW_LINE> if ( ircnet -> sasl_username != NULL && * ircnet -> sasl_username && <NEW_LINE> ircnet -> sasl_password != NULL && * ircnet -> sasl_password ) { <NEW_LINE> <START_VULN> conn -> sasl_username = ircnet -> sasl_username ; <NEW_LINE>conn -> sasl_password = ircnet -> sasl_password ; <NEW_LINE> <END_VULN> } else <NEW_LINE> g_warning ( "The fields sasl_username and sasl_password are either missing or empty" ) ; <NEW_LINE> }
return - 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> return mount_entry_on_generic ( mntent , path ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int mount_file_entries ( const struct lxc_rootfs * rootfs , FILE * file ,
draw_info -> miterlimit = 10 ; <NEW_LINE> draw_info -> decorate = NoDecoration ; <NEW_LINE> draw_info -> pointsize = 12 . 0 ; <NEW_LINE> <START_VULN> draw_info -> undercolor . alpha = ( Quantum ) TransparentAlpha ; <NEW_LINE> <END_VULN> draw_info -> compose = OverCompositeOp ; <NEW_LINE> draw_info -> render = MagickTrue ; <NEW_LINE> draw_info -> debug = IsEventLogging ( ) ;
} <NEW_LINE> void BindBuffer ( GLenum target , GLuint buffer ) override { <NEW_LINE> <START_VULN> if ( target == GL_PIXEL_UNPACK_BUFFER ) <NEW_LINE>state_ . pixel_unpack_buffer_binding = buffer ; <NEW_LINE> <END_VULN> } <NEW_LINE> GLuint64 InsertFenceSyncCHROMIUM ( ) override {
const size_t len = strlen ( src ) ; <NEW_LINE> <START_VULN> dst = new ( std::nothrow ) char [ len + 1 ] ; <NEW_LINE> <END_VULN> if ( dst == NULL ) <NEW_LINE> return - 1 ;
UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; <NEW_LINE> UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; <NEW_LINE> UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <NEW_LINE> <START_VULN> WORD16 i2_level_arr [ 16 ] ; <NEW_LINE> <END_VULN> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; <NEW_LINE> WORD16 * pi2_coeff_data ;
} <NEW_LINE> if ( bdynamic ) { <NEW_LINE> reserved . newbslots = ( HeapSlot * ) cx -> malloc_ ( sizeof ( HeapSlot ) * bdynamic ) ; <NEW_LINE> if ( ! reserved . newbslots ) <NEW_LINE> return false ; <NEW_LINE> Debug_SetSlotRangeToCrashOnTouch ( reserved . newbslots , bdynamic ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> return true ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> JSObject::TradeGuts ( JSContext * cx , JSObject * a , JSObject * b , TradeGutsReserved & reserved ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( a -> compartment ( ) == b -> compartment ( ) ) ; <NEW_LINE> JS_ASSERT ( a -> isFunction ( ) == b -> isFunction ( ) ) ;
} <NEW_LINE> } <NEW_LINE> * q = '\0' ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> RETVAL_STRINGL ( erealloc ( out_str , q - out_str + 1 ) , q - out_str , 0 ) ; <NEW_LINE> }
if ( ! op -> b_o_s ) stream -> delivered_non_b_o_s = 1 ; <NEW_LINE> } <NEW_LINE> else <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> if ( cb_ret == OGGZ_STOP_OK || <NEW_LINE>cb_ret == OGGZ_STOP_ERR || <NEW_LINE>cb_ret == OGGZ_ERR_HOLE_IN_DATA ) <NEW_LINE> <END_VULN> return cb_ret ; <NEW_LINE> if ( oggz_read_get_next_page ( oggz , & og ) < 0 ) <NEW_LINE> return OGGZ_READ_EMPTY ; <NEW_LINE> serialno = ogg_page_serialno ( & og ) ; <NEW_LINE> reader -> current_serialno = serialno ;
} <NEW_LINE> else if ( childTag == nsGkAtoms::option ) { <NEW_LINE> PRInt32 parentIndex = FindContent ( aContainer ) ; <NEW_LINE> <START_VULN> PRInt32 index = 0 ; <NEW_LINE>GetIndexInSubtree ( aContainer , aChild , & index ) ; <NEW_LINE>PRInt32 count = InsertRow ( parentIndex , index , aChild ) ; <NEW_LINE>if ( mBoxObject ) <NEW_LINE>mBoxObject -> RowCountChanged ( parentIndex + index + 1 , count ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
<START_VULN> # if PNG_LIBPNG_BUILD_BASE_TYPE >= PNG_LIBPNG_BUILD_RC <NEW_LINE> <END_VULN> png_ptr -> flags |= PNG_FLAG_APP_WARNINGS_WARN ; <NEW_LINE> # endif <NEW_LINE> # endif
MprList * files ; <NEW_LINE> if ( ! version || smatch ( version , " * " ) ) { <NEW_LINE> <START_VULN> name = stok ( sclone ( name ) , "#" , ( char ** ) & version ) ; <NEW_LINE>if ( ! version ) { <NEW_LINE> <END_VULN> files = mprGetPathFiles ( mprJoinPath ( app -> paksCacheDir , name ) , MPR_PATH_RELATIVE ) ; <NEW_LINE> mprSortList ( files , ( MprSortProc ) reverseSortFiles , 0 ) ; <NEW_LINE> if ( ( dp = mprGetFirstItem ( files ) ) != 0 ) {
} <NEW_LINE> <START_VULN> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <NEW_LINE>memcpy ( buf2 , value , value_len ) ; <NEW_LINE>buf2 [ value_len ] = 0 ; <NEW_LINE> } else { <NEW_LINE>buf2 = estrndup ( value , value_len ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> value_len = php_url_decode ( buf2 , value_len ) ;
static void setConfigDefaults ( HttpRoute * route ) <NEW_LINE> { <NEW_LINE> <START_VULN> route -> mode = mprGetJson ( route -> config , "app . mode" ) ; <NEW_LINE> <END_VULN> if ( smatch ( route -> mode , "debug" ) ) { <NEW_LINE> httpSetRouteShowErrors ( route , 1 ) ; <NEW_LINE> route -> keepSource = 1 ;
new_str = php_base64_decode ( Z_STRVAL_P ( ent1 -> data ) , Z_STRLEN_P ( ent1 -> data ) , & new_len ) ; <NEW_LINE> STR_FREE ( Z_STRVAL_P ( ent1 -> data ) ) ; <NEW_LINE> <START_VULN> Z_STRVAL_P ( ent1 -> data ) = new_str ; <NEW_LINE>Z_STRLEN_P ( ent1 -> data ) = new_len ; <NEW_LINE> <END_VULN> }
<START_VULN> enum StyleDifference { <NEW_LINE> <END_VULN> StyleDifferenceEqual , <NEW_LINE> StyleDifferenceRecompositeLayer , <NEW_LINE> StyleDifferenceRepaint ,
if ( ! tcptls_session -> parent -> tls_cfg ) { <NEW_LINE> <START_VULN> tcptls_session -> f = fdopen ( tcptls_session -> fd , "w + " ) ; <NEW_LINE>setvbuf ( tcptls_session -> f , NULL , _IONBF , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef DO_SSL <NEW_LINE> else if ( ( tcptls_session -> ssl = SSL_new ( tcptls_session -> parent -> tls_cfg -> ssl_ctx ) ) ) {
const xmlChar ** atts = ctxt -> atts ; <NEW_LINE> int maxatts = ctxt -> maxatts ; <NEW_LINE> int nratts , nbatts , nbdef ; <NEW_LINE> <START_VULN> int i , j , nbNs , attval , oldline , oldcol , inputNr ; <NEW_LINE>const xmlChar * base ; <NEW_LINE> <END_VULN> unsigned long cur ; <NEW_LINE> int nsNr = ctxt -> nsNr ;
<START_VULN> struct XPCNativeScriptableSharedJSClass <NEW_LINE> <END_VULN> { <NEW_LINE> js::Class base ; <NEW_LINE> PRUint32 interfacesBitmap ; <NEW_LINE> } ; <NEW_LINE> class XPCNativeScriptableShared <NEW_LINE> { <NEW_LINE> public:
DEBUG ( "emulate a2dp read delay ( % d us ) " , us_delay ) ; <NEW_LINE> <START_VULN> usleep ( us_delay ) ; <NEW_LINE> <END_VULN> pthread_mutex_unlock ( & in -> common . lock ) ; <NEW_LINE> return - 1 ; <NEW_LINE> }
ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , <NEW_LINE> u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> ps_dec -> u1_mb_idx = 0 ; <NEW_LINE> ps_dec -> u4_num_mbs_cur_nmb = 0 ; <NEW_LINE> }
return NS_OK ; <NEW_LINE> } <NEW_LINE> StringResult * strRes ; <NEW_LINE> rv = aContext -> recycler ( ) -> getStringResult ( & strRes ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> txXPathNodeUtils::getXSLTId ( nodes -> get ( 0 ) , strRes -> mValue ) ; <NEW_LINE> <END_VULN> * aResult = strRes ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> Expr::ResultType <NEW_LINE> GenerateIdFunctionCall::getReturnType ( )
InspectorDOMAgent * domAgent = domAgentPtr . get ( ) ; <NEW_LINE> m_agents . append ( domAgentPtr . release ( ) ) ; <NEW_LINE> <START_VULN> OwnPtr < InspectorResourceAgent > resourceAgentPtr ( InspectorResourceAgent::create ( m_instrumentingAgents . get ( ) , pageAgent , inspectorClient , m_state . get ( ) , m_overlay . get ( ) ) ) ; <NEW_LINE> <END_VULN> InspectorResourceAgent * resourceAgent = resourceAgentPtr . get ( ) ; <NEW_LINE> m_agents . append ( resourceAgentPtr . release ( ) ) ;
PRUint32 i ; <NEW_LINE> for ( i = 0 ; i < XPCCCX_STRING_CACHE_SIZE ; ++ i ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( ! se [ i ] . mInUse , "Uh , string wrapper still in use ! " ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> NS_IF_RELEASE ( mXPC ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> XPCReadableJSStringWrapper * <NEW_LINE> XPCCallContext::NewStringWrapper ( PRUnichar * str , PRUint32 len ) <NEW_LINE> { <NEW_LINE> StringWrapperEntry * se = <NEW_LINE> reinterpret_cast < StringWrapperEntry * > ( & mStringWrapperData ) ;
if ( value . IsEmpty ( ) ) { <NEW_LINE> <START_VULN> if ( ! merge && entry ) <NEW_LINE> <END_VULN> mHeaders . RemoveElementAt ( index ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
thisTypes -> getKnownClass ( ) == & ArrayClass && <NEW_LINE> ! thisTypes -> hasObjectFlags ( cx , types::OBJECT_FLAG_SPARSE_INDEXES | <NEW_LINE> types::OBJECT_FLAG_LENGTH_OVERFLOW ) && <NEW_LINE> argTypes -> getKnownClass ( ) == & ArrayClass && <NEW_LINE> ! argTypes -> hasObjectFlags ( cx , types::OBJECT_FLAG_SPARSE_INDEXES | <NEW_LINE> types::OBJECT_FLAG_LENGTH_OVERFLOW ) && <NEW_LINE> ! types::ArrayPrototypeHasIndexedProperty ( cx , outerScript ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> return compileArrayConcat ( thisTypes , argTypes , thisValue , arg ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } else if ( argc == 2 ) { <NEW_LINE> FrameEntry * arg1 = frame . peek ( - 2 ) ; <NEW_LINE> FrameEntry * arg2 = frame . peek ( - 1 ) ; <NEW_LINE> JSValueType arg1Type = arg1 -> isTypeKnown ( ) ? arg1 -> getKnownType ( ) : JSVAL_TYPE_UNKNOWN ; <NEW_LINE> JSValueType arg2Type = arg2 -> isTypeKnown ( ) ? arg2 -> getKnownType ( ) : JSVAL_TYPE_UNKNOWN ;
} <NEW_LINE> png_ptr -> num_palette = ( png_uint_16 ) num_palette ; <NEW_LINE> <START_VULN> if ( full_quantize ) <NEW_LINE> <END_VULN> { <NEW_LINE> int i ; <NEW_LINE> png_bytep distance ;
goto end ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( current . m_obj -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> RenderBox * box = toRenderBox ( current . m_obj ) ;
mHandle , & decodedPicture , eos ) ) { <NEW_LINE> int32_t picId = decodedPicture . picId ; <NEW_LINE> uint8_t * data = ( uint8_t * ) decodedPicture . pOutputPicture ; <NEW_LINE> <START_VULN> drainOneOutputBuffer ( picId , data ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
return res ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> static int <NEW_LINE> dwarf_elf_object_access_load_section ( void * obj_in , <NEW_LINE> Dwarf_Half section_index ,
void Wire ( UberDispatcher * dispatcher ) override ; <NEW_LINE> <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) override ; <NEW_LINE> Response Disable ( ) override ;
if ( p -> rtp ) { <NEW_LINE> <START_VULN> if ( portno > 0 ) { <NEW_LINE> <END_VULN> ast_sockaddr_set_port ( sa , portno ) ; <NEW_LINE> ast_rtp_instance_set_remote_address ( p -> rtp , sa ) ; <NEW_LINE> if ( debug ) {
uep -> ue_size = undo_read_4c ( bi ) ; <NEW_LINE> if ( uep -> ue_size > 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> array = ( char_u ** ) U_ALLOC_LINE ( sizeof ( char_u * ) * uep -> ue_size ) ; <NEW_LINE> <END_VULN> if ( array == NULL ) <NEW_LINE> { <NEW_LINE> * error = TRUE ;
#else <NEW_LINE> png_fixed_point res ; <NEW_LINE> <START_VULN> if ( png_muldiv ( & res , 100000 , 100000 , a ) ) <NEW_LINE> <END_VULN> return res ; <NEW_LINE> #endif
@param sp Socket object returned from #mprCreateSocket <NEW_LINE> @return True if the socket has pending data to read or write . <NEW_LINE> @ingroup MprSocket <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC bool mprSocketHasBuffered ( MprSocket * sp ) ;
if ( alpha ) <NEW_LINE> { <NEW_LINE> if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , colorchannels ) , <NEW_LINE> <START_VULN> pa , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <NEW_LINE> <END_VULN> && img -> stoponerr ) <NEW_LINE> { <NEW_LINE> ret = 0 ;
switch ( ( state & PNG_FP_STATE ) + ( type & PNG_FP_SAW_ANY ) ) <NEW_LINE> { <NEW_LINE> case PNG_FP_INTEGER + PNG_FP_SAW_SIGN: <NEW_LINE> <START_VULN> if ( state & PNG_FP_SAW_ANY ) <NEW_LINE> <END_VULN> goto PNG_FP_End ; <NEW_LINE> png_fp_add ( state , type ) ;
XPCPerThreadData * data = XPCPerThreadData::GetData ( nsnull ) ; <NEW_LINE> if ( ! data ) { <NEW_LINE> * _retval = nsnull ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> <START_VULN> * _retval = data -> GetJSContextStack ( ) -> Peek ( ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsXPConnect::CheckForDebugMode ( JSRuntime * rt ) { <NEW_LINE> JSContext * cx = NULL ; <NEW_LINE> if ( gDebugMode == gDesiredDebugMode ) {
static size_t <NEW_LINE> store_message ( png_store * ps , png_const_structp pp , char * buffer , size_t bufsize , <NEW_LINE> <START_VULN> size_t pos , PNG_CONST char * msg ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( pp != NULL && pp == ps -> pread ) <NEW_LINE> {
bool requestSucceeded ; <NEW_LINE> rv = httpChannel -> GetRequestSucceeded ( & requestSucceeded ) ; <NEW_LINE> if ( NS_SUCCEEDED ( rv ) && ! requestSucceeded ) { <NEW_LINE> return NS_ERROR_NOT_AVAILABLE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIChannel > channel = do_QueryInterface ( req ) ; <NEW_LINE> <START_VULN> NS_GetFinalChannelURI ( channel , getter_AddRefs ( aRequest -> mFinalURI ) ) ; <NEW_LINE> <END_VULN> if ( aStringLen ) { <NEW_LINE> nsAutoString hintCharset ; <NEW_LINE> if ( ! aRequest -> IsPreload ( ) ) { <NEW_LINE> aRequest -> mElement -> GetScriptCharset ( hintCharset ) ; <NEW_LINE> } else { <NEW_LINE> nsTArray < PreloadInfo > ::index_type i = <NEW_LINE> mPreloads . IndexOf ( aRequest , 0 , PreloadRequestComparator ( ) ) ;
<START_VULN> #line 495 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> { <NEW_LINE> YYCTYPE yych ; <NEW_LINE> static const unsigned char yybm [ ] = {
"aFirstToNotRemove should have a fluid prev continuation" ) ; <NEW_LINE> NS_ASSERTION ( aFrame -> GetPrevContinuation ( ) == <NEW_LINE> aFrame -> GetPrevInFlow ( ) && <NEW_LINE> aFrame -> GetPrevInFlow ( ) != nsnull , <NEW_LINE> "aFrame should have a fluid prev continuation" ) ; <NEW_LINE> nsIFrame * prevContinuation = aFrame -> GetPrevContinuation ( ) ; <NEW_LINE> nsIFrame * lastRemoved = aFirstToNotRemove -> GetPrevContinuation ( ) ; <NEW_LINE> prevContinuation -> SetNextInFlow ( aFirstToNotRemove ) ; <NEW_LINE> aFirstToNotRemove -> SetPrevInFlow ( prevContinuation ) ; <NEW_LINE> aFrame -> SetPrevInFlow ( nsnull ) ; <NEW_LINE> lastRemoved -> SetNextInFlow ( nsnull ) ; <NEW_LINE> <START_VULN> nsIFrame * parent = aFrame -> GetParent ( ) ; <NEW_LINE>nsBlockFrame * parentBlock = nsLayoutUtils::GetAsBlock ( parent ) ; <NEW_LINE> <END_VULN> if ( parentBlock ) { <NEW_LINE> parentBlock -> DoRemoveFrame ( aFrame , nsBlockFrame::FRAMES_ARE_EMPTY ) ; <NEW_LINE> } else { <NEW_LINE> parent -> RemoveFrame ( nsIFrame::kNoReflowPrincipalList , aFrame ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsTextFrame::SetLength ( PRInt32 aLength , nsLineLayout * aLineLayout , <NEW_LINE> PRUint32 aSetLengthFlags ) <NEW_LINE> {
if ( ! haveLineClamp && ( relayoutChildren || ( child -> isReplaced ( ) && ( child -> style ( ) -> width ( ) . isPercent ( ) || child -> style ( ) -> height ( ) . isPercent ( ) ) ) ) ) <NEW_LINE> child -> setChildNeedsLayout ( true , MarkOnlyThis ) ; <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> child -> containingBlock ( ) -> insertPositionedObject ( child ) ; <NEW_LINE> RenderLayer * childLayer = child -> layer ( ) ; <NEW_LINE> childLayer -> setStaticInlinePosition ( borderStart ( ) + paddingStart ( ) ) ;
status = MagickFalse ; <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> for ( x = 0 ; x < ( ssize_t ) images -> columns ; x ++ ) <NEW_LINE> <END_VULN> { <NEW_LINE> switch ( op ) <NEW_LINE> {
valuePush ( ctxt , val ) ; <NEW_LINE> return ( xmlXPathCompareValues ( ctxt , inf , strict ) ) ; <NEW_LINE> default: <NEW_LINE> <START_VULN> TODO <NEW_LINE> <END_VULN> } <NEW_LINE> return ( 0 ) ; <NEW_LINE> }
if ( ! obj -> clearType ( cx ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> v . set ( this , FUNCTION_NS , ObjectValue ( * obj ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> * vp = v ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> }
static std::vector < NetworkHandler * > ForAgentHost ( DevToolsAgentHostImpl * host ) ; <NEW_LINE> void Wire ( UberDispatcher * dispatcher ) override ; <NEW_LINE> <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) override ; <NEW_LINE> Response Enable ( Maybe < int > max_total_size ,
} <NEW_LINE> ctxt = xmlSchemaNewValidCtxt ( schemas ) ; <NEW_LINE> <START_VULN> xmlSchemaSetValidErrors ( ctxt , <NEW_LINE> ( xmlSchemaValidityErrorFunc ) testErrorHandler , <NEW_LINE> ( xmlSchemaValidityWarningFunc ) testErrorHandler , <NEW_LINE>ctxt ) ; <NEW_LINE> <END_VULN> validResult = xmlSchemaValidateDoc ( ctxt , doc ) ; <NEW_LINE> if ( validResult == 0 ) { <NEW_LINE> fprintf ( schemasOutput , " % s validates\n" , filename ) ;
WORD32 timeDelay , timeTaken ; <NEW_LINE> size_t sizeY , sizeUV ; <NEW_LINE> <START_VULN> setDecodeArgs ( & s_dec_ip , & s_dec_op , inHeader , outHeader , timeStampIx ) ; <NEW_LINE> <END_VULN> GETTIME ( & mTimeStart , NULL ) ;
for ( int i = 0 ; err == NO_ERROR && i < numFds ; i ++ ) { <NEW_LINE> h -> data [ i ] = dup ( readFileDescriptor ( ) ) ; <NEW_LINE> <START_VULN> if ( h -> data [ i ] < 0 ) err = BAD_VALUE ; <NEW_LINE> <END_VULN> } <NEW_LINE> err = read ( h -> data + numFds , sizeof ( int ) * numInts ) ; <NEW_LINE> if ( err != NO_ERROR ) {
else <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> flags & PNG_FLAG_CRC_CRITICAL_IGNORE ) <NEW_LINE> <END_VULN> need_crc = 0 ; <NEW_LINE> }
rcu_read_lock ( ) ; <NEW_LINE> dev = dev_get_by_index_rcu ( sock_net ( sk ) , pkt_sk ( sk ) -> ifindex ) ; <NEW_LINE> if ( dev ) <NEW_LINE> <START_VULN> strlcpy ( uaddr -> sa_data , dev -> name , 15 ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> memset ( uaddr -> sa_data , 0 , 14 ) ; <NEW_LINE> rcu_read_unlock ( ) ;
png_crc_read ( png_ptr , buffer , length ) ; <NEW_LINE> <START_VULN> if ( png_crc_finish ( png_ptr , skip ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> key = ( png_charp ) buffer ;
class ShellMainDelegate : public ContentMainDelegate { <NEW_LINE> public: <NEW_LINE> <START_VULN> ShellMainDelegate ( ) ; <NEW_LINE> <END_VULN> ~ ShellMainDelegate ( ) override ;
{ <NEW_LINE> struct crypto_report_comp rcomp ; <NEW_LINE> <START_VULN> snprintf ( rcomp . type , CRYPTO_MAX_ALG_NAME , " % s" , "compression" ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , <NEW_LINE> sizeof ( struct crypto_report_comp ) , & rcomp ) ) <NEW_LINE> goto nla_put_failure ;
bc + candidates [ s ] [ i ] . col } ; <NEW_LINE> thissad = vfp -> sdf ( what -> buf , what -> stride , <NEW_LINE> get_buf_from_mv ( in_what , & this_mv ) , <NEW_LINE> <START_VULN> in_what -> stride , bestsad ) ; <NEW_LINE> <END_VULN> CHECK_BETTER <NEW_LINE> } <NEW_LINE> } else {
PRBool HaveForcedBreakPosition ( ) { return mForceBreakContent != nsnull ; } <NEW_LINE> PRInt32 GetForcedBreakPosition ( nsIContent * aContent ) { <NEW_LINE> return mForceBreakContent == aContent ? mForceBreakContentOffset : - 1 ; <NEW_LINE> } <NEW_LINE> nsIFrame * GetLineContainerFrame ( ) const { return mBlockReflowState -> frame ; } <NEW_LINE> const nsLineList::iterator * GetLine ( ) const { <NEW_LINE> return GetFlag ( LL_GOTLINEBOX ) ? & mLineBox : nsnull ; <NEW_LINE> } <NEW_LINE> static void <NEW_LINE> BuildTextRuns ( gfxContext * aContext , nsTextFrame * aForFrame , <NEW_LINE> nsIFrame * aLineContainer , const nsLineList::iterator * aForFrameLine ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( aForFrame || aForFrameLine , <NEW_LINE>"One of aForFrame or aForFrameLine must be set ! " ) ; <NEW_LINE><NEW_LINE>if ( ! aLineContainer ) { <NEW_LINE> <END_VULN> aLineContainer = FindLineContainer ( aForFrame ) ; <NEW_LINE> } else { <NEW_LINE> NS_ASSERTION ( ! aForFrame || aLineContainer == FindLineContainer ( aForFrame ) , "Wrong line container hint" ) ; <NEW_LINE> } <NEW_LINE> nsPresContext * presContext = aLineContainer -> PresContext ( ) ; <NEW_LINE> BuildTextRunsScanner scanner ( presContext , aContext , aLineContainer ) ;
const char * ylabel ) <NEW_LINE> { <NEW_LINE> char * newroot ; <NEW_LINE> <START_VULN> char buf [ L_BUF_SIZE ] ; <NEW_LINE> <END_VULN> l_int32 badchar ; <NEW_LINE> GPLOT * gplot ;
WORD32 timeDelay , timeTaken ; <NEW_LINE> size_t sizeY , sizeUV ; <NEW_LINE> <START_VULN> setDecodeArgs ( & s_dec_ip , & s_dec_op , inHeader , outHeader , timeStampIx ) ; <NEW_LINE> <END_VULN> DUMP_TO_FILE ( mInFile , s_dec_ip . pv_stream_buffer , s_dec_ip . u4_num_Bytes ) ;
content = content -> GetParent ( ) ; <NEW_LINE> } <NEW_LINE> if ( content && content -> IsElement ( ) ) { <NEW_LINE> <START_VULN> elementStyle = nsComputedDOMStyle::GetStyleContextForElement ( content -> AsElement ( ) , <NEW_LINE>nullptr , <NEW_LINE>ps ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! elementStyle )
num_new_palette -- ; <NEW_LINE> palette [ png_ptr -> index_to_palette [ j ] ] <NEW_LINE> = palette [ num_new_palette ] ; <NEW_LINE> <START_VULN> if ( ! full_quantize ) <NEW_LINE> <END_VULN> { <NEW_LINE> int k ;
nsresult SetAttrAndNotify ( PRInt32 aNamespaceID , <NEW_LINE> nsIAtom * aName , <NEW_LINE> nsIAtom * aPrefix , <NEW_LINE> const nsAString & aOldValue , <NEW_LINE> nsAttrValue & aParsedValue , <NEW_LINE> PRBool aModification , <NEW_LINE> PRBool aFireMutation , <NEW_LINE> <START_VULN> PRBool aNotify ) ; <NEW_LINE> <END_VULN> *
domEventToFire . Assign ( NS_LITERAL_STRING ( "DOMMenuItemInactive" ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> FireDOMEvent ( mPresContext , domEventToFire ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> }
if ( ! m_element -> isHTMLElement ( ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> RefPtr < DocumentFragment > fragment = Range::createDocumentFragmentForElement ( markup , toHTMLElement ( m_element ) ) ; <NEW_LINE> <END_VULN> ExceptionCode exception = 0 ; <NEW_LINE> m_element -> appendChild ( fragment , exception ) ;
if ( in_stop_all_loaders_ ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> in_stop_all_loaders_ = true ; <NEW_LINE> <END_VULN> for ( Frame * child = frame_ -> Tree ( ) . FirstChild ( ) ; child ; <NEW_LINE> child = child -> Tree ( ) . NextSibling ( ) ) {
nsCOMPtr < nsIDOMDataTransfer > initialDataTransfer ; <NEW_LINE> dragSession -> GetDataTransfer ( getter_AddRefs ( initialDataTransfer ) ) ; <NEW_LINE> if ( ! initialDataTransfer ) { <NEW_LINE> <START_VULN> initialDataTransfer = new nsDOMDataTransfer ( aDragEvent -> message , true ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( initialDataTransfer , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> dragSession -> SetDataTransfer ( initialDataTransfer ) ; <NEW_LINE> } <NEW_LINE> bool isCrossDomainSubFrameDrop = false ;
png_ptr -> num_palette_max = - 1 ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
void UpdateAtlas::didSwapBuffers ( ) <NEW_LINE> { <NEW_LINE> m_areaAllocator . clear ( ) ; <NEW_LINE> <START_VULN> buildLayoutIfNeeded ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> PassOwnPtr < GraphicsContext > UpdateAtlas::beginPaintingOnAvailableBuffer ( ShareableSurface::Handle & handle , const WebCore::IntSize & size , IntPoint & offset ) <NEW_LINE> { <NEW_LINE> buildLayoutIfNeeded ( ) ; <NEW_LINE> IntRect rect = m_areaAllocator -> allocate ( size ) ;
{ <NEW_LINE> return png_ptr -> chunk_name ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED <NEW_LINE> # ifdef PNG_GET_PALETTE_MAX_SUPPORTED
hao -> ip6hao_len = ip6_optlen ; <NEW_LINE> if ( ip6_optlen < sizeof ( hao -> ip6hao_hoa ) ) { <NEW_LINE> <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> }
{ <NEW_LINE> if ( ps_codec -> i4_pic_present ) <NEW_LINE> { <NEW_LINE> <START_VULN> slice_header_t * ps_slice_hdr_next ; <NEW_LINE>ps_codec -> i4_slice_error = 1 ; <NEW_LINE>ps_codec -> s_parse . i4_cur_slice_idx -- ; <NEW_LINE>if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) <NEW_LINE>ps_codec -> s_parse . i4_cur_slice_idx = 0 ; <NEW_LINE><NEW_LINE>ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; <NEW_LINE>ps_slice_hdr_next -> i2_ctb_x = slice_address % ps_sps -> i2_pic_wd_in_ctb ; <NEW_LINE>ps_slice_hdr_next -> i2_ctb_y = slice_address / ps_sps -> i2_pic_wd_in_ctb ; <NEW_LINE>return ret ; <NEW_LINE> <END_VULN> } <NEW_LINE> else <NEW_LINE> {
l_int32 <NEW_LINE> gplotMakeOutput ( GPLOT * gplot ) <NEW_LINE> { <NEW_LINE> <START_VULN> char buf [ L_BUF_SIZE ] ; <NEW_LINE> <END_VULN> char * cmdname ; <NEW_LINE> l_int32 ignore ;
status = QuantizeImage ( quantize_info , image ) ; <NEW_LINE> quantize_info = DestroyQuantizeInfo ( quantize_info ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> image -> colors = 2 ; <NEW_LINE> <END_VULN> image -> matte = MagickFalse ; <NEW_LINE> break ; <NEW_LINE> }
if ( mono_class_is_subclass_of ( src_class , dest_class , FALSE ) ) <NEW_LINE> ; <NEW_LINE> <START_VULN> else if ( mono_class_is_subclass_of ( dest_class , src_class , FALSE ) ) <NEW_LINE> <END_VULN> return FALSE ; <NEW_LINE> }
if ( ! init_done_ ) { <NEW_LINE> const vpx_codec_err_t res = vpx_codec_dec_init ( & decoder_ , <NEW_LINE> CodecInterface ( ) , <NEW_LINE> <START_VULN> & cfg_ , 0 ) ; <NEW_LINE> <END_VULN> ASSERT_EQ ( VPX_CODEC_OK , res ) << DecodeError ( ) ; <NEW_LINE> init_done_ = true ; <NEW_LINE> }
Uint8Array::create ( dstBuffer , 0 , dstBuffer -> byteLength ( ) ) ; <NEW_LINE> SkPixmap pixmap ( <NEW_LINE> resizedInfo , resizedPixels -> data ( ) , <NEW_LINE> <START_VULN> static_cast < size_t > ( resizeWidth ) * resizedInfo . bytesPerPixel ( ) ) ; <NEW_LINE> <END_VULN> skImage -> scalePixels ( pixmap , resizeQuality ) ; <NEW_LINE> return SkImage::MakeFromRaster ( pixmap , <NEW_LINE> [ ] ( const void * , void * pixels ) {
jsbytecode * pc = script -> code + offset ; <NEW_LINE> JSOp op = JSOp ( * pc ) ; <NEW_LINE> nextOffset = offset + GetBytecodeLength ( pc ) ; <NEW_LINE> Bytecode * code = analysis -> maybeCode ( offset ) ; <NEW_LINE> if ( ! code ) <NEW_LINE> <START_VULN> continue ; <NEW_LINE> <END_VULN> bool finishChunk = false ; <NEW_LINE> bool preserveChunk = false ;
do_QueryInterface ( static_cast < nsIAttribute * > ( this ) ) ; <NEW_LINE> subtree . UpdateTarget ( GetOwnerDoc ( ) , this ) ; <NEW_LINE> nsEventDispatcher::Dispatch ( mChild , nsnull , & mutation ) ; <NEW_LINE> } <NEW_LINE> if ( guard . Mutated ( 0 ) && mChild != child ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> doRemoveChild ( ) ; <NEW_LINE> <END_VULN> nsString nullString ; <NEW_LINE> SetDOMStringToNull ( nullString ) ; <NEW_LINE> SetValue ( nullString ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult
quotaManager -> AcquireExclusiveAccess ( mOriginOrPattern , this , <NEW_LINE> InvalidateOpenedStorages , nullptr ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> case IO: { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> AdvanceState ( ) ; <NEW_LINE> DeleteFiles ( quotaManager ) ; <NEW_LINE> if ( NS_FAILED ( NS_DispatchToMainThread ( this , NS_DISPATCH_NORMAL ) ) ) { <NEW_LINE> NS_WARNING ( "Failed to dispatch to main thread ! " ) ;
tempLeafName . Append ( ext ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #ifdef XP_WIN <NEW_LINE><NEW_LINE> <END_VULN> nsCOMPtr < nsIFile > dummyFile ;
} <NEW_LINE> nsresult <NEW_LINE> FileManager::InitDirectory ( nsIFile * aDirectory , <NEW_LINE> nsIFile * aDatabaseFile , <NEW_LINE> const nsACString & aOrigin ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( aDirectory , "Null directory ! " ) ; <NEW_LINE> NS_ASSERTION ( aDatabaseFile , "Null database file ! " ) ; <NEW_LINE> bool exists ; <NEW_LINE> nsresult rv = aDirectory -> Exists ( & exists ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> if ( ! exists ) {
case ' < ': <NEW_LINE> len = format ? 13 : 4 ; <NEW_LINE> ds += len - 1 ; <NEW_LINE> <START_VULN> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <NEW_LINE> <END_VULN> if ( NULL == tmp ) <NEW_LINE> {
WebGLContext ( ) ; <NEW_LINE> virtual ~ WebGLContext ( ) ; <NEW_LINE> <START_VULN> NS_DECL_ISUPPORTS <NEW_LINE> <END_VULN> NS_DECL_NSICANVASRENDERINGCONTEXTWEBGL
if ( ! smatch ( location , "stdout" ) && ! smatch ( location , "stderr" ) ) { <NEW_LINE> location = httpMakePath ( route , 0 , location ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ( levels = mprGetJsonObj ( prop , "levels" ) ) != 0 ) { <NEW_LINE> <END_VULN> for ( ITERATE_CONFIG ( route , prop , child , ji ) ) { <NEW_LINE> httpSetTraceEventLevel ( route -> trace , child -> name , ( int ) stoi ( child -> value ) ) ; <NEW_LINE> }
else <NEW_LINE> { <NEW_LINE> back_g = display -> background -> green ; <NEW_LINE> <START_VULN> if ( output_format & PNG_FORMAT_FLAG_COLOR ) <NEW_LINE> <END_VULN> { <NEW_LINE> back_r = display -> background -> red ; <NEW_LINE> back_b = display -> background -> blue ;
#include "config . h" <NEW_LINE> <START_VULN> #include "core / platform / win / SystemInfo . h" <NEW_LINE> <END_VULN> #include < windows . h >
mState = eFiringEvents ; <NEW_LINE> return this -> Run ( ) ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> OpenDatabaseHelper::DoDatabaseWork ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> #ifdef DEBUG <NEW_LINE> { <NEW_LINE>bool correctThread ; <NEW_LINE>NS_ASSERTION ( NS_SUCCEEDED ( QuotaManager::Get ( ) -> IOThread ( ) -> <NEW_LINE>IsOnCurrentThread ( & correctThread ) ) && <NEW_LINE>correctThread , <NEW_LINE>"Running on the wrong thread ! " ) ; <NEW_LINE> } <NEW_LINE>#endif <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "OpenDatabaseHelper::DoDatabaseWork" ) ; <NEW_LINE> mState = eFiringEvents ; <NEW_LINE> if ( QuotaManager::IsShuttingDown ( ) ) { <NEW_LINE> return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ;
inline void setNextView ( ArrayBufferViewObject * view ) ; <NEW_LINE> <START_VULN> void neuter ( JSContext * cx ) ; <NEW_LINE> <END_VULN> static void trace ( JSTracer * trc , JSObject * obj ) ;
if ( ts -> flags & TSF_NEWLINES ) <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> <START_VULN> } while ( JS_ISSPACE ( c ) ) ; <NEW_LINE> <END_VULN> tp = NewToken ( ts , - 1 ) ; <NEW_LINE> if ( c == EOF ) {
} <NEW_LINE> JSAtom * <NEW_LINE> <START_VULN> js_Atomize ( JSContext * cx , const char * bytes , size_t length , uintN flags , bool useCESU8 ) <NEW_LINE> <END_VULN> { <NEW_LINE> JS_ASSERT ( ! ( flags & ATOM_NOCOPY ) ) ; <NEW_LINE> CHECK_REQUEST ( cx ) ;
NS_tchar callbackLongPath [ MAXPATHLEN ] ; <NEW_LINE> ZeroMemory ( callbackLongPath , sizeof ( callbackLongPath ) ) ; <NEW_LINE> NS_tchar * targetPath = argv [ callbackIndex ] ; <NEW_LINE> <START_VULN> NS_tchar buffer [ MAXPATHLEN * 2 ] ; <NEW_LINE> <END_VULN> if ( sReplaceRequest ) {
<START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> MOJO_SYSTEM_EXPORT MojoResult MojoUnwrapPlatformSharedBufferHandle ( <NEW_LINE> MojoHandle mojo_handle , <NEW_LINE> struct MojoPlatformHandle * platform_handle ,
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return xpc_EvalInSandbox ( cx , obj , source , <NEW_LINE> <START_VULN> NS_ConvertUTF16toUTF8 ( source ) . get ( ) , 1 , rval ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> }
bool mFullScreen ; <NEW_LINE> void * mJavaView ; <NEW_LINE> #endif <NEW_LINE> nsPluginNativeWindow * mPluginWindow ; <NEW_LINE> nsRefPtr < nsNPAPIPluginInstance > mInstance ; <NEW_LINE> nsObjectFrame * mObjectFrame ; <NEW_LINE> <START_VULN> nsIContent * mContent ; <NEW_LINE> <END_VULN> nsCString mDocumentBase ; <NEW_LINE> bool mWidgetCreationComplete ; <NEW_LINE> nsCOMPtr < nsIWidget > mWidget ; <NEW_LINE> nsRefPtr < nsPluginHost > mPluginHost ; <NEW_LINE> #ifdef XP_MACOSX <NEW_LINE> NP_CGContext mCGPluginPortCopy ; <NEW_LINE> int32_t mInCGPaintLevel ;
{ <NEW_LINE> mArray . SizeTo ( aOther . Count ( ) ) ; <NEW_LINE> AppendObjects ( aOther ) ; <NEW_LINE> } <NEW_LINE> nsCOMArray_base:: ~ nsCOMArray_base ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> PRInt32 count = Count ( ) , i ; <NEW_LINE>for ( i = 0 ; i < count ; ++ i ) { <NEW_LINE>nsISupports * obj = ObjectAt ( i ) ; <NEW_LINE>NS_IF_RELEASE ( obj ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> PRInt32 <NEW_LINE> nsCOMArray_base::IndexOfObject ( nsISupports * aObject ) const { <NEW_LINE> nsCOMPtr < nsISupports > supports = do_QueryInterface ( aObject ) ; <NEW_LINE> NS_ENSURE_TRUE ( supports , - 1 ) ; <NEW_LINE> PRInt32 i , count ;
double toX = isIdentity ( to ) ? 0 : to -> translate . x ; <NEW_LINE> double toY = isIdentity ( to ) ? 0 : to -> translate . y ; <NEW_LINE> double toZ = isIdentity ( to ) ? 0 : to -> translate . z ; <NEW_LINE> <START_VULN> toReturn . translate3d ( blendDoubles ( fromX , toX , progress ) , <NEW_LINE>blendDoubles ( fromY , toY , progress ) , <NEW_LINE>blendDoubles ( fromZ , toZ , progress ) ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> } <NEW_LINE> case WebTransformOperation::WebTransformOperationRotate: {
} <NEW_LINE> else if ( ! strncmp ( dff_chunk_header . ckID , "DSD " , 4 ) ) { <NEW_LINE> <START_VULN> if ( ! config -> num_channels ) { <NEW_LINE> <END_VULN> error_line ( " % s is not a valid . DFF file ! " , infilename ) ; <NEW_LINE> return WAVPACK_SOFT_ERROR ; <NEW_LINE> }
p = a = text ; <NEW_LINE> while ( a < e ) { <NEW_LINE> <START_VULN> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> b = m . sub [ 0 ] . sp ;
referencePoint . move ( curr -> parent ( ) -> offsetForColumns ( referencePoint ) ) ; <NEW_LINE> curr = curr -> parent ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( offsetParent -> isBox ( ) && offsetParent -> isBody ( ) && ! offsetParent -> isRelPositioned ( ) && ! offsetParent -> isPositioned ( ) ) <NEW_LINE> <END_VULN> referencePoint . moveBy ( toRenderBox ( offsetParent ) -> topLeftLocation ( ) ) ; <NEW_LINE> } <NEW_LINE> }
extern "C" { <NEW_LINE> #endif <NEW_LINE> <START_VULN> void vp8_init_mode_costs ( VP8_COMP * x ) ; <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> }
{ <NEW_LINE> ASSERT ( resultElement ) ; <NEW_LINE> SVGElement * targetElement = this -> targetElement ( ) ; <NEW_LINE> <START_VULN> if ( ! targetElement ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> ASSERT ( m_animatedPropertyType == determineAnimatedPropertyType ( targetElement ) ) ;
pfd . fd = sfd ; <NEW_LINE> pfd . events = POLLIN ; <NEW_LINE> <START_VULN> if ( poll ( & pfd , 1 , 0 ) == 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> BTIF_TRACE_EVENT ( "accept poll timeout" ) ; <NEW_LINE> return - 1 ;
const PRUnichar * script = handler -> GetHandlerText ( ) ; <NEW_LINE> NS_ASSERTION ( script , "timeout has no script nor handler text ! " ) ; <NEW_LINE> const char * filename = nullptr ; <NEW_LINE> uint32_t lineNo = 0 ; <NEW_LINE> handler -> GetLocation ( & filename , & lineNo ) ; <NEW_LINE> <START_VULN> JS::CompileOptions options ( aScx -> GetNativeContext ( ) ) ; <NEW_LINE> <END_VULN> options . setFileAndLine ( filename , lineNo ) <NEW_LINE> . setVersion ( JSVERSION_DEFAULT ) ; <NEW_LINE> aScx -> EvaluateString ( nsDependentString ( script ) , * FastGetGlobalJSObject ( ) , <NEW_LINE> options , false , nullptr ) ; <NEW_LINE> } else { <NEW_LINE> nsCOMPtr < nsIVariant > dummy ; <NEW_LINE> nsCOMPtr < nsISupports > me ( static_cast < nsIDOMWindow * > ( this ) ) ; <NEW_LINE> aScx -> CallEventHandler ( me , FastGetGlobalJSObject ( ) ,
quantum = ( size_t ) alpha ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> quantum = MagickMin ( quantum / number_coordinates , BezierQuantum ) ; <NEW_LINE> <END_VULN> primitive_info = ( * mvg_info -> primitive_info ) + mvg_info -> offset ; <NEW_LINE> coefficients = ( double * ) AcquireQuantumMemory ( number_coordinates , <NEW_LINE> sizeof ( * coefficients ) ) ; <NEW_LINE> points = ( PointInfo * ) AcquireQuantumMemory ( quantum , number_coordinates *
ReadOrderFromArray ( Order ( ) , fileHeader . orderList , fileHeader . numOrders ) ; <NEW_LINE> std::vector < STPLoopList > loopInfo ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> std::vector < SAMPLEINDEX > nonLooped ;
if ( 0 == size ) { <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> void * pixels = sk_malloc_flags ( size , 0 ) ; <NEW_LINE> <END_VULN> if ( nullptr == pixels ) { <NEW_LINE> return false ; <NEW_LINE> }
XPC_LOG_ERROR ( ( "XPCConvert::NativeData2JS : void * params not supported" ) ) ; <NEW_LINE> return false ; <NEW_LINE> case nsXPTType::T_IID: <NEW_LINE> { <NEW_LINE> nsID * iid2 = * ( ( nsID ** ) s ) ; <NEW_LINE> if ( ! iid2 ) <NEW_LINE> break ; <NEW_LINE> <START_VULN> RootedObject scope ( cx , lccx . GetScopeForNewJSObjects ( ) ) ; <NEW_LINE> <END_VULN> JSObject * obj ; <NEW_LINE> if ( ! ( obj = xpc_NewIDObject ( cx , scope , * iid2 ) ) ) <NEW_LINE> return false ; <NEW_LINE> * d = OBJECT_TO_JSVAL ( obj ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> case nsXPTType::T_ASTRING:
: public IPC::Listener , <NEW_LINE> virtual public ChildThread { <NEW_LINE> public: <NEW_LINE> <START_VULN> struct CONTENT_EXPORT Options { <NEW_LINE>Options ( ) ; <NEW_LINE>explicit Options ( bool mojo ) ; <NEW_LINE>Options ( std::string name , bool mojo ) ; <NEW_LINE> ~ Options ( ) ; <NEW_LINE><NEW_LINE>std::string channel_name ; <NEW_LINE>bool use_mojo_channel ; <NEW_LINE>bool in_browser_process ; <NEW_LINE>std::vector < IPC::MessageFilter * > startup_filters ; <NEW_LINE> } ; <NEW_LINE> <END_VULN> ChildThreadImpl ( ) ;
q = r = p ; <NEW_LINE> while ( r < t . e ) { <NEW_LINE> <START_VULN> if ( ! vct_iscrlf ( * r ) ) { <NEW_LINE> <END_VULN> r ++ ; <NEW_LINE> continue ; <NEW_LINE> }
{ <NEW_LINE> if ( output != 0 && output_size > count ) <NEW_LINE> { <NEW_LINE> <START_VULN> int copy = output_size - count ; <NEW_LINE>if ( avail < copy ) copy = avail ; <NEW_LINE> <END_VULN> png_memcpy ( output + count , png_ptr -> zbuf , copy ) ; <NEW_LINE> } <NEW_LINE> count += avail ;
{ <NEW_LINE> int len = strlen ( buffer ) ; <NEW_LINE> <START_VULN> if ( ( len + * stringlen ) > * stralloc ) { <NEW_LINE> <END_VULN> char * newptr = realloc ( string , * stralloc * 2 ) ; <NEW_LINE> if ( newptr ) { <NEW_LINE> string = newptr ;
text . text_length = 0 ; <NEW_LINE> text . itxt_length = uncompressed_length ; <NEW_LINE> <START_VULN> if ( png_set_text_2 ( png_ptr , info_ptr , & text , 1 ) ) <NEW_LINE> <END_VULN> errmsg = "insufficient memory" ; <NEW_LINE> } <NEW_LINE> }
nsIFrame * rootFrame = ps -> GetRootFrame ( ) ; <NEW_LINE> if ( ! rootFrame ) <NEW_LINE> return NS_OK ; <NEW_LINE> nsAutoTArray < nsIFrame * , 8 > outFrames ; <NEW_LINE> nsLayoutUtils::GetFramesForArea ( rootFrame , rect , outFrames , <NEW_LINE> <START_VULN> nsLayoutUtils::IGNORE_PAINT_SUPPRESSION | <NEW_LINE> <END_VULN> ( aIgnoreRootScrollFrame ? nsLayoutUtils::IGNORE_ROOT_SCROLL_FRAME : 0 ) ) ; <NEW_LINE> nsIContent * lastAdded = nullptr ; <NEW_LINE> for ( uint32_t i = 0 ; i < outFrames . Length ( ) ; i ++ ) { <NEW_LINE> nsIContent * node = GetContentInThisDocument ( outFrames [ i ] ) ;
INC_STATS ( "DOM . WebGLRenderingContext . getProgramParameter ( ) " ) ; <NEW_LINE> if ( args . Length ( ) != 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> WebGLRenderingContext * context = V8WebGLRenderingContext::toNative ( args . Holder ( ) ) ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . overloadedMethod2" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( TestObj * , objArg , V8TestObj::HasInstance ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ? V8TestObj::toNative ( v8::Handle < v8::Object > ::Cast ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) : 0 ) ; <NEW_LINE> if ( args . Length ( ) <= 1 ) {
if ( usehp ) <NEW_LINE> <START_VULN> vp9_write ( w , hp , <NEW_LINE> <END_VULN> mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ; <NEW_LINE> }
} <NEW_LINE> } while ( base_was_tested ) ; <NEW_LINE> mpz_init_set ( tested [ i ] , a ) ; <NEW_LINE> <START_VULN> mpz_powm ( z , a , m , n ) ; <NEW_LINE> <END_VULN> if ( ( mpz_cmp_ui ( z , 1 ) == 0 ) || ( mpz_cmp ( z , n_1 ) == 0 ) ) <NEW_LINE> continue ; <NEW_LINE> composite = 1 ;
#define FileInputType_h <NEW_LINE> #include "core / CoreExport . h" <NEW_LINE> <START_VULN> #include "core / html / forms / BaseClickableWithKeyInputType . h" <NEW_LINE> <END_VULN> #include "core / html / forms / InputType . h" <NEW_LINE> #include "platform / FileChooser . h" <NEW_LINE> #include "platform / heap / Handle . h" <NEW_LINE> #include "wtf / RefPtr . h"
int i , rec_no = 0 ; <NEW_LINE> if ( prkey_info . path . len >= 2 ) prkey_info . path . len - = 2 ; <NEW_LINE> sc_append_file_id ( & prkey_info . path , 0x5349 ) ; <NEW_LINE> <START_VULN> if ( sc_select_file ( card , & prkey_info . path , NULL ) != SC_SUCCESS ) { <NEW_LINE> <END_VULN> sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , <NEW_LINE> "Select ( % s ) failed\n" , <NEW_LINE> sc_print_path ( & prkey_info . path ) ) ;
<START_VULN> if ( ! png_muldiv ( & xy -> whitex , whiteX , PNG_FP_1 , dwhite ) ) return 1 ; <NEW_LINE>if ( ! png_muldiv ( & xy -> whitey , whiteY , PNG_FP_1 , dwhite ) ) return 1 ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
} else { <NEW_LINE> if ( l_header_read == 0 ) { <NEW_LINE> <START_VULN> if ( sscanf ( l_line , " % u % u % u" , o_row_count , o_column_count , o_element_count ) == 3 ) { <NEW_LINE> <END_VULN> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; <NEW_LINE> * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( ( size_t ) ( * o_row_count ) + 1 ) ) ;
<START_VULN> const chromeos::InputMethodDescriptor * GetInputMethodDescriptorFromId ( <NEW_LINE> <END_VULN> const std::string & input_method_id ) ;
} <NEW_LINE> static void <NEW_LINE> <START_VULN> image_transform_set_end ( PNG_CONST image_transform * this , <NEW_LINE> <END_VULN> transform_display * that , png_structp pp , png_infop pi ) <NEW_LINE> { <NEW_LINE> UNUSED ( this )
TouchEventHandler ( WebPagePrivate * webpage ) ; <NEW_LINE> ~ TouchEventHandler ( ) ; <NEW_LINE> <START_VULN> void doFatFingers ( Platform::TouchPoint & ) ; <NEW_LINE>void handleTouchPoint ( Platform::TouchPoint & , unsigned modifiers ) ; <NEW_LINE> <END_VULN> void sendClickAtFatFingersPoint ( unsigned modifiers = 0 ) ; <NEW_LINE> const FatFingersResult & lastFatFingersResult ( ) const { return m_lastFatFingersResult ; }
VisiblePositionForContentsPoint ( point , GetFrame ( ) ) ; <NEW_LINE> SelectionInDOMTree::Builder builder ; <NEW_LINE> builder . SetIsDirectional ( GetSelectionInDOMTree ( ) . IsDirectional ( ) ) ; <NEW_LINE> <START_VULN> builder . SetIsHandleVisible ( true ) ; <NEW_LINE> <END_VULN> if ( position . IsNotNull ( ) ) <NEW_LINE> builder . Collapse ( position . ToPositionWithAffinity ( ) ) ; <NEW_LINE> SetSelection ( builder . Build ( ) , SetSelectionData::Builder ( ) <NEW_LINE> . SetShouldCloseTyping ( true ) <NEW_LINE> . SetShouldClearTypingStyle ( true ) <NEW_LINE> . SetSetSelectionBy ( SetSelectionBy::kUser ) <NEW_LINE> . Build ( ) ) ; <NEW_LINE> }
int vp9_get_reference_mode_context ( const VP9_COMMON * cm , <NEW_LINE> const MACROBLOCKD * xd ) { <NEW_LINE> int ctx ; <NEW_LINE> <START_VULN> const MB_MODE_INFO * const above_mbmi = get_mbmi ( get_above_mi ( xd ) ) ; <NEW_LINE>const MB_MODE_INFO * const left_mbmi = get_mbmi ( get_left_mi ( xd ) ) ; <NEW_LINE>const int has_above = above_mbmi != NULL ; <NEW_LINE>const int has_left = left_mbmi != NULL ; <NEW_LINE> <END_VULN>
void SetVolumePercent ( double volume_percent ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> void AdjustVolumeByPercent ( double adjust_by_percent ) ;
const InString * input , int pos , const widechar * passInstructions , int passIC ) { <NEW_LINE> int k ; <NEW_LINE> int kk = pos ; <NEW_LINE> <START_VULN> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <NEW_LINE> <END_VULN> if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) <NEW_LINE> return 0 ; <NEW_LINE> return 1 ;
#pragma warning ( disable:4351 ) <NEW_LINE> #endif <NEW_LINE> TokenStream::TokenStream ( JSContext * cx , JSPrincipals * prin , JSPrincipals * originPrin ) <NEW_LINE> : tokens ( ) , tokensRoot ( cx , & tokens ) , <NEW_LINE> cursor ( ) , lookahead ( ) , flags ( ) , <NEW_LINE> linebaseRoot ( cx , & linebase ) , prevLinebaseRoot ( cx , & prevLinebase ) , userbufRoot ( cx , & userbuf ) , <NEW_LINE> <START_VULN> listenerTSData ( ) , tokenbuf ( cx ) , <NEW_LINE> <END_VULN> cx ( cx ) , originPrincipals ( JSScript::normalizeOriginPrincipals ( prin , originPrin ) ) <NEW_LINE> { <NEW_LINE> if ( originPrincipals ) <NEW_LINE> JS_HoldPrincipals ( originPrincipals ) ; <NEW_LINE> } <NEW_LINE> #ifdef _MSC_VER <NEW_LINE> #pragma warning ( pop )
create_struct . zstream . opaque = png_ptr ; <NEW_LINE> # ifdef PNG_SETJMP_SUPPORTED <NEW_LINE> <START_VULN> <NEW_LINE>create_struct . jmp_buf_ptr = NULL ; <NEW_LINE>create_struct . jmp_buf_size = 0 ; <NEW_LINE>create_struct . longjmp_fn = 0 ; <NEW_LINE> <END_VULN> # endif <NEW_LINE> * png_ptr = create_struct ;
static void set_active_map ( const vpx_codec_enc_cfg_t * cfg , <NEW_LINE> vpx_codec_ctx_t * codec ) { <NEW_LINE> unsigned int i ; <NEW_LINE> <START_VULN> vpx_active_map_t map = { 0 } ; <NEW_LINE> <END_VULN> map . rows = ( cfg -> g_h + 15 ) / 16 ; <NEW_LINE> map . cols = ( cfg -> g_w + 15 ) / 16 ;
#include "gfxQuartzSurface . h" <NEW_LINE> #include "gfxContext . h" <NEW_LINE> #include "cairo - quartz . h" <NEW_LINE> gfxQuartzSurface::gfxQuartzSurface ( const gfxSize & size , gfxImageFormat format , <NEW_LINE> PRBool aForPrinting ) <NEW_LINE> <START_VULN> : mSize ( size ) , mForPrinting ( aForPrinting ) <NEW_LINE> <END_VULN> { <NEW_LINE> unsigned int width = ( unsigned int ) floor ( size . width ) ; <NEW_LINE> unsigned int height = ( unsigned int ) floor ( size . height ) ; <NEW_LINE> if ( ! CheckSurfaceSize ( gfxIntSize ( width , height ) ) ) <NEW_LINE> return ; <NEW_LINE> cairo_surface_t * surf = cairo_quartz_surface_create
#if defined ( __APPLE__ ) <NEW_LINE> if ( ( node -> getLeft ( ) != NULL ) && ( node -> getRight ( ) != NULL ) && <NEW_LINE> ( node -> getLeft ( ) -> getAsSymbolNode ( ) ) ) { <NEW_LINE> TIntermSymbol * symbol = node -> getLeft ( ) -> getAsSymbolNode ( ) ; <NEW_LINE> <START_VULN> if ( IsSampler ( symbol -> getBasicType ( ) ) && symbol -> isArray ( ) ) { <NEW_LINE>ValidateLoopIndexExpr validate ( mLoopStack ) ; <NEW_LINE>node -> getRight ( ) -> traverse ( & validate ) ; <NEW_LINE>if ( validate . usesFloatLoopIndex ( ) ) { <NEW_LINE>error ( node -> getLine ( ) , <NEW_LINE>"sampler array index is float loop index" , <NEW_LINE>"for" ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> #endif <NEW_LINE> validateIndexing ( node ) ; <NEW_LINE> break ; <NEW_LINE> default: break ; <NEW_LINE> } <NEW_LINE> return true ; <NEW_LINE> }
{ <NEW_LINE> assign ( 0 ) ; <NEW_LINE> return reinterpret_cast < void ** > ( & mRawPtr ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> assign ( T * newPtr ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ABORT_IF_FALSE ( mRawPtr != newPtr || ! newPtr , "This makes no sense ! " ) ; <NEW_LINE> <END_VULN> T * oldPtr = mRawPtr ; <NEW_LINE> mRawPtr = newPtr ; <NEW_LINE> delete oldPtr ; <NEW_LINE> }
#define DATA_SOURCE_H_ <NEW_LINE> #include < sys / types . h > <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include < media / stagefright / MediaErrors . h > <NEW_LINE> #include < utils / Errors . h > <NEW_LINE> #include < utils / KeyedVector . h >
vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , <NEW_LINE> vpx_codec_iface_t * iface , <NEW_LINE> <START_VULN> vpx_codec_dec_cfg_t * cfg , <NEW_LINE> <END_VULN> vpx_codec_flags_t flags , <NEW_LINE> int ver ) ;
if ( scontains ( value , " = " ) ) { <NEW_LINE> for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { <NEW_LINE> <START_VULN> option = stok ( option , " = \t , " , & ovalue ) ; <NEW_LINE> <END_VULN> ovalue = strim ( ovalue , "\"'" , MPR_TRIM_BOTH ) ; <NEW_LINE> if ( smatch ( option , "auth" ) ) { <NEW_LINE> auth = ovalue ;
if ( overflow || sumSubsampleSizes != totalSize ) { <NEW_LINE> result = - EINVAL ; <NEW_LINE> <START_VULN> } else if ( offset + totalSize > sharedBuffer -> size ( ) ) { <NEW_LINE> <END_VULN> result = - EINVAL ; <NEW_LINE> } else { <NEW_LINE> result = decrypt (
png_error ( png_ptr , "invalid compression buffer size" ) ; <NEW_LINE> # ifdef PNG_SEQUENTIAL_READ_SUPPORTED <NEW_LINE> <START_VULN> if ( png_ptr -> mode & PNG_IS_READ_STRUCT ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_ptr -> IDAT_read_size = ( png_uint_32 ) size ; <NEW_LINE> return ;
current -> pop ( ) ; <NEW_LINE> MGetPropertyCache * load = MGetPropertyCache::New ( obj , name ) ; <NEW_LINE> load -> setResultType ( rvalType ) ; <NEW_LINE> <START_VULN> if ( obj -> type ( ) == MIRType_Object && ! invalidatedIdempotentCache ( ) ) { <NEW_LINE> <END_VULN> if ( PropertyReadIsIdempotent ( cx , obj , name ) ) <NEW_LINE> load -> setIdempotent ( ) ; <NEW_LINE> } <NEW_LINE> if ( JSOp ( * pc ) == JSOP_CALLPROP ) { <NEW_LINE> if ( ! annotateGetPropertyCache ( cx , obj , load , obj -> resultTypeSet ( ) , types ) ) <NEW_LINE> return false ; <NEW_LINE> }
} <NEW_LINE> <START_VULN> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <NEW_LINE> <END_VULN> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;
void vorbis_dsp_clear ( vorbis_dsp_state * v ) { <NEW_LINE> int i ; <NEW_LINE> if ( v ) { <NEW_LINE> vorbis_info * vi = v -> vi ; <NEW_LINE> codec_setup_info * ci = ( vi ? vi -> codec_setup:NULL ) ; <NEW_LINE> private_state * b = v -> backend_state ; <NEW_LINE> if ( b ) { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( b -> ve ) { <NEW_LINE> _ve_envelope_clear ( b -> ve ) ; <NEW_LINE> _ogg_free ( b -> ve ) ; <NEW_LINE> } <NEW_LINE> if ( b -> transform [ 0 ] ) { <NEW_LINE> mdct_clear ( b -> transform [ 0 ] [ 0 ] ) ; <NEW_LINE> _ogg_free ( b -> transform [ 0 ] [ 0 ] ) ;
NS_IMETHODIMP nsHankakuToZenkaku::Change ( const PRUnichar * aText , PRInt32 aTextLength , nsString & aResult ) <NEW_LINE> { <NEW_LINE> PRInt32 ol ; <NEW_LINE> <START_VULN> aResult . SetCapacity ( aTextLength ) ; <NEW_LINE><NEW_LINE> <END_VULN> HankakuToZenkaku ( aText , aTextLength , aResult . BeginWriting ( ) , aTextLength , & ol ) ; <NEW_LINE> aResult . SetLength ( ol ) ;
return true ; <NEW_LINE> for ( InlineBox * curr = firstChild ( ) ; curr ; curr = curr -> nextOnLine ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> renderer ( ) -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( curr -> isInlineFlowBox ( ) ) {
<START_VULN> #define PNG_LIBPNG_VER 10252 <NEW_LINE> <END_VULN> #ifndef PNG_VERSION_INFO_ONLY
bool altActive = modifiers & KEYMOD_ALT ; <NEW_LINE> bool ctrlActive = modifiers & KEYMOD_CTRL ; <NEW_LINE> <START_VULN> switch ( point . m_state ) { <NEW_LINE> <END_VULN> case Platform::TouchPoint::TouchPressed: <NEW_LINE> {
JS_ASSERT ( setflag ? ! SPROP_HAS_STUB_SETTER ( sprop ) : ! SPROP_HAS_STUB_GETTER_OR_IS_METHOD ( sprop ) ) ; <NEW_LINE> enterDeepBailCall ( ) ; <NEW_LINE> LIns * vp_ins = lir -> insAlloc ( sizeof ( jsval ) ) ; <NEW_LINE> <START_VULN> lir -> insStorei ( vp_ins , cx_ins , offsetof ( JSContext , nativeVp ) ) ; <NEW_LINE>lir -> insStorei ( INS_CONST ( 1 ) , cx_ins , offsetof ( JSContext , nativeVpLen ) ) ; <NEW_LINE> <END_VULN> if ( setflag ) <NEW_LINE> lir -> insStorei ( boxed_ins , vp_ins , 0 ) ; <NEW_LINE> CallInfo * ci = ( CallInfo * ) lir -> insSkip ( sizeof ( struct CallInfo ) ) -> payload ( ) ; <NEW_LINE> ci -> _address = uintptr_t ( setflag ? sprop -> setter : sprop -> getter ) ; <NEW_LINE> ci -> _argtypes = ARGSIZE_I << ( 0 * ARGSIZE_SHIFT ) | <NEW_LINE> ARGSIZE_P << ( 1 * ARGSIZE_SHIFT ) | <NEW_LINE> ARGSIZE_P << ( 2 * ARGSIZE_SHIFT ) |
protected: <NEW_LINE> nsIntSize mLastSize ; <NEW_LINE> nsIntPoint mLastPoint ; <NEW_LINE> HWND mWnd ; <NEW_LINE> WNDPROC mPrevWndProc ; <NEW_LINE> HBRUSH mBrush ; <NEW_LINE> PRPackedBool mIsTopWidgetWindow ; <NEW_LINE> PRPackedBool mHas3DBorder ; <NEW_LINE> <START_VULN> PRPackedBool mIsDestroying ; <NEW_LINE> <END_VULN> PRPackedBool mIsVisible ; <NEW_LINE> PRPackedBool mIsInMouseCapture ; <NEW_LINE> PRPackedBool mInWheelProcessing ; <NEW_LINE> PRPackedBool mUnicodeWidget ; <NEW_LINE> PRPackedBool mIsPluginWindow ; <NEW_LINE> PRPackedBool mPainting ; <NEW_LINE> char mLeadByte ; <NEW_LINE> PRUint32 mBlurSuppressLevel ;
void vp8_sixtap_predict4x4_c ( unsigned char * src , int src_pitch , int xofst , int yofst , unsigned char * dst , int dst_pitch ) ; <NEW_LINE> void vp8_sixtap_predict4x4_armv6 ( unsigned char * src , int src_pitch , int xofst , int yofst , unsigned char * dst , int dst_pitch ) ; <NEW_LINE> <START_VULN> void vp8_sixtap_predict4x4_neon ( unsigned char * src , int src_pitch , int xofst , int yofst , unsigned char * dst , int dst_pitch ) ; <NEW_LINE>#define vp8_sixtap_predict4x4 vp8_sixtap_predict4x4_neon <NEW_LINE> <END_VULN> void vp8_sixtap_predict8x4_c ( unsigned char * src , int src_pitch , int xofst , int yofst , unsigned char * dst , int dst_pitch ) ; <NEW_LINE> void vp8_sixtap_predict8x4_armv6 ( unsigned char * src , int src_pitch , int xofst , int yofst , unsigned char * dst , int dst_pitch ) ;
#include < utility > <NEW_LINE> #include "base / callback . h" <NEW_LINE> #include "base / memory / ptr_util . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "third_party / WebKit / public / platform / WebCallbacks . h"
int size ; <NEW_LINE> syscall_nr = trace_get_syscall_nr ( current , regs ) ; <NEW_LINE> <START_VULN> if ( syscall_nr < 0 ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> if ( ! test_bit ( syscall_nr , enabled_perf_enter_syscalls ) ) <NEW_LINE> return ;
case NLPID_ISIS: <NEW_LINE> if ( ! isis_print ( ndo , p , length ) ) <NEW_LINE> <START_VULN> print_unknown_data ( ndo , p , "\n\t" , caplen ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case NLPID_NULLNS:
if ( ! high_sierra ) { <NEW_LINE> <START_VULN> parse_rock_ridge_inode ( de , inode ) ; <NEW_LINE> <END_VULN> if ( sbi -> s_uid_set ) <NEW_LINE> inode -> i_uid = sbi -> s_uid ;
double scal_width , scal_height ; <NEW_LINE> if ( png_get_sCAL ( read_ptr , read_info_ptr , & unit , & scal_width , <NEW_LINE> <START_VULN> & scal_height ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_set_sCAL ( write_ptr , write_info_ptr , unit , scal_width , scal_height ) ; <NEW_LINE> }
if ( argc == 0 ) { <NEW_LINE> <START_VULN> while ( ( tmp = OBJ_GET_PARENT ( cx , obj ) ) != NULL ) <NEW_LINE>obj = tmp ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> if ( ! js_ValueToObject ( cx , argv [ 0 ] , & obj ) )
if ( ! codec_private || length < 1 ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> delete [ ] codec_private_ ; <NEW_LINE> <END_VULN> codec_private_ = <NEW_LINE> new ( std::nothrow ) uint8 [ static_cast < size_t > ( length ) ] ;
{ <NEW_LINE> nsRefPtr < AccEvent > event = <NEW_LINE> new AccTextChangeEvent ( mHyperText , mTextOffset + aAddlOffset , <NEW_LINE> aText , PR_FALSE ) ; <NEW_LINE> aEvents . AppendElement ( event ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void UpdateTextNFireEvent ( const nsAString & aNewText , <NEW_LINE>const nsAString & aChangeText , PRUint32 aAddlOffset , <NEW_LINE>PRBool aIsInserted ) ; <NEW_LINE> <END_VULN> private: <NEW_LINE> nsDocAccessible * mDocument ; <NEW_LINE> nsTextAccessible * mTextLeaf ; <NEW_LINE> nsHyperTextAccessible * mHyperText ; <NEW_LINE> PRInt32 mTextOffset ; <NEW_LINE> } ;
xpc_UnmarkGrayScript ( aScriptObject ) ; <NEW_LINE> JSContext * cx = mContext ; <NEW_LINE> JSXDRState * xdr = ::JS_XDRNewMem ( cx , JSXDR_ENCODE ) ; <NEW_LINE> if ( ! xdr ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> xdr -> userdata = ( void * ) aStream ; <NEW_LINE> <START_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> <END_VULN> if ( ! ::JS_XDRScript ( xdr , & aScriptObject ) ) { <NEW_LINE> rv = NS_ERROR_FAILURE ; <NEW_LINE> } else {
nsresult <NEW_LINE> nsListBoxBodyFrame::GetIndexOfItem ( nsIDOMElement * aItem , PRInt32 * _retval ) <NEW_LINE> { <NEW_LINE> if ( aItem ) { <NEW_LINE> * _retval = 0 ; <NEW_LINE> nsCOMPtr < nsIContent > itemContent ( do_QueryInterface ( aItem ) ) ; <NEW_LINE> <START_VULN> nsIContent * listbox = mContent -> GetBindingParent ( ) ; <NEW_LINE>NS_ENSURE_STATE ( listbox ) ; <NEW_LINE><NEW_LINE>PRUint32 childCount = listbox -> GetChildCount ( ) ; <NEW_LINE>for ( PRUint32 childIndex = 0 ; childIndex < childCount ; childIndex ++ ) { <NEW_LINE>nsIContent * child = listbox -> GetChildAt ( childIndex ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( child -> Tag ( ) == nsGkAtoms::listitem ) { <NEW_LINE> if ( child == itemContent ) <NEW_LINE> return NS_OK ; <NEW_LINE> ++ ( * _retval ) ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> <START_VULN> rv = xpc_EvalInSandbox ( cx , sandbox , source , filename . get ( ) , lineNo , rval ) ; <NEW_LINE> <END_VULN> if ( NS_SUCCEEDED ( rv ) ) { <NEW_LINE> if ( JS_IsExceptionPending ( cx ) ) {
{ <NEW_LINE> char * cp = ( char * ) p ; <NEW_LINE> struct kvec * vec = & rqstp -> rq_arg . head [ 0 ] ; <NEW_LINE> <START_VULN> return cp >= ( char * ) vec -> iov_base <NEW_LINE> && cp <= ( char * ) vec -> iov_base + vec -> iov_len ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline int
return NULL ; <NEW_LINE> } else { <NEW_LINE> newIdentity = target ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! RemapWrappers ( cx , origobj , newIdentity ) ) <NEW_LINE> <END_VULN> return NULL ; <NEW_LINE> if ( origobj -> compartment ( ) != destination ) { <NEW_LINE> AutoCompartment ac ( cx , origobj ) ; <NEW_LINE> JSObject * newIdentityWrapper = newIdentity ; <NEW_LINE> if ( ! ac . enter ( ) || ! JS_WrapObject ( cx , & newIdentityWrapper ) ) <NEW_LINE> return NULL ;
int * sortpointer [ VIF_POSIT + 2 ] ; <NEW_LINE> vorbis_info_floor1 * info = ( vorbis_info_floor1 * ) in ; <NEW_LINE> vorbis_look_floor1 * look = _ogg_calloc ( 1 , sizeof ( * look ) ) ; <NEW_LINE> int i , j , n = 0 ; <NEW_LINE> look -> vi = info ; <NEW_LINE> look -> n = info -> postlist [ 1 ] ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( i = 0 ; i < info -> partitions ; i ++ ) n += info -> class_dim [ info -> partitionclass [ i ] ] ;
WebGLContextOptions mOptions ; <NEW_LINE> PRPackedBool mInvalidated ; <NEW_LINE> PRPackedBool mResetLayer ; <NEW_LINE> PRPackedBool mVerbose ; <NEW_LINE> PRPackedBool mOptionsFrozen ; <NEW_LINE> WebGLuint mActiveTexture ; <NEW_LINE> <START_VULN> WebGLenum mSynthesizedGLError ; <NEW_LINE> <END_VULN> PRBool mShaderValidation ; <NEW_LINE> PRInt32 mGLMaxVertexAttribs ; <NEW_LINE> PRInt32 mGLMaxTextureUnits ; <NEW_LINE> PRInt32 mGLMaxTextureSize ;
<START_VULN> static InputMethodDescriptors * CreateInputMethodDescriptors ( ) ; <NEW_LINE> <END_VULN> chromeos::CrosLibrary::TestApi * test_api ( ) ;
static void copyTrespass ( <NEW_LINE> short * , <NEW_LINE> <START_VULN> const int * const * , <NEW_LINE> <END_VULN> unsigned , <NEW_LINE> unsigned ) { <NEW_LINE> TRESPASS ( ) ;
"selectAll . Then they shouldn't be present " <NEW_LINE> "after it . " ; <NEW_LINE> <START_VULN> Selection ( ) . SetSelection ( SelectionInDOMTree::Builder ( ) <NEW_LINE> . Collapse ( end_of_text ) <NEW_LINE> . SetIsHandleVisible ( true ) <NEW_LINE> . Build ( ) ) ; <NEW_LINE> <END_VULN> EXPECT_TRUE ( Selection ( ) . IsHandleVisible ( ) ) ; <NEW_LINE> Selection ( ) . SelectAll ( ) ; <NEW_LINE> EXPECT_TRUE ( Selection ( ) . IsHandleVisible ( ) )
sawInline = curr -> isInline ( ) ; <NEW_LINE> curr = curr -> nextSibling ( ) ; <NEW_LINE> <START_VULN> while ( curr && ( curr -> isInline ( ) || curr -> isFloatingOrPositioned ( ) ) && ( curr != boundary ) ) { <NEW_LINE> <END_VULN> inlineRunEnd = curr ; <NEW_LINE> if ( curr -> isInline ( ) ) <NEW_LINE> sawInline = true ;
docViewer ( do_QueryInterface ( mContentViewer ) ) ; <NEW_LINE> if ( ! docViewer ) <NEW_LINE> return nsnull ; <NEW_LINE> docViewer -> GetDocument ( getter_AddRefs ( document ) ) ; <NEW_LINE> } <NEW_LINE> if ( document ) { <NEW_LINE> <START_VULN> return document -> NodePrincipal ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return nsnull ; <NEW_LINE> } <NEW_LINE> PRBool <NEW_LINE> nsDocShell::ShouldCheckAppCache ( nsIURI * aURI ) <NEW_LINE> {
this_mv . as_mv . col = bc + neighbors [ i ] . col ; <NEW_LINE> CHECK_POINT <NEW_LINE> this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <NEW_LINE> <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <NEW_LINE> <END_VULN> CHECK_BETTER <NEW_LINE> } <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE>#endif <NEW_LINE>#endif <NEW_LINE> <END_VULN> return flags & mask ; <NEW_LINE> }
nsIFrame * nextFrame = frame -> GetNextInFlow ( ) ; <NEW_LINE> NS_ASSERTION ( nextFrame , "We're supposed to have a next - in - flow by now" ) ; <NEW_LINE> if ( NS_FRAME_IS_NOT_COMPLETE ( frameReflowStatus ) ) { <NEW_LINE> if ( ! madeContinuation && <NEW_LINE> ( NS_FRAME_IS_OVERFLOW_CONTAINER & nextFrame -> GetStateBits ( ) ) ) { <NEW_LINE> <START_VULN> aState . mOverflowTracker -> Finish ( frame ) ; <NEW_LINE> <END_VULN> nsContainerFrame * parent = <NEW_LINE> static_cast < nsContainerFrame * > ( nextFrame -> GetParent ( ) ) ; <NEW_LINE> rv = parent -> StealFrame ( aState . mPresContext , nextFrame ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> if ( parent != this ) <NEW_LINE> ReparentFrame ( nextFrame , parent , this ) ; <NEW_LINE> mFrames . InsertFrame ( nullptr , frame , nextFrame ) ; <NEW_LINE> madeContinuation = true ;
static inline void schedule_debug ( struct task_struct * prev ) <NEW_LINE> { <NEW_LINE> #ifdef CONFIG_SCHED_STACK_END_CHECK <NEW_LINE> <START_VULN> BUG_ON ( task_stack_end_corrupted ( prev ) ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> if ( unlikely ( in_atomic_preempt_off ( ) ) ) {
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> RefPtr < FileSystemSyncCallbackHelper > helper = FileSystemSyncCallbackHelper::create ( ) ; <NEW_LINE> <END_VULN> OwnPtr < AsyncFileSystemCallbacks > callbacks = FileSystemCallbacks::create ( helper -> successCallback ( ) , helper -> errorCallback ( ) , & worker , fileSystemType ) ; <NEW_LINE> callbacks -> setShouldBlockUntilCompletion ( true ) ;
continue ; <NEW_LINE> split_huge_page_pmd ( walk -> mm , pmd ) ; <NEW_LINE> <START_VULN> if ( pmd_none_or_clear_bad ( pmd ) ) <NEW_LINE> <END_VULN> goto again ; <NEW_LINE> err = walk_pte_range ( pmd , addr , next , walk ) ; <NEW_LINE> if ( err )
{ <NEW_LINE> spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ; <NEW_LINE> spl_filesystem_object * object = spl_filesystem_iterator_to_object ( iterator ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> object -> u . dir . index ++ ; <NEW_LINE> do { <NEW_LINE> spl_filesystem_dir_read ( object TSRMLS_CC ) ;
JSContext * cx = lccx . GetJSContext ( ) ; <NEW_LINE> <START_VULN> NS_ABORT_IF_FALSE ( js::IsObjectInContextCompartment ( lccx . GetScopeForNewJSObjects ( ) , cx ) , <NEW_LINE>"bad scope for new JSObjects" ) ; <NEW_LINE><NEW_LINE>JSObject * jsscope = lccx . GetScopeForNewJSObjects ( ) ; <NEW_LINE>XPCWrappedNativeScope * xpcscope = GetObjectScope ( jsscope ) ; <NEW_LINE> <END_VULN> if ( ! xpcscope ) <NEW_LINE> return false ;
goto out ; <NEW_LINE> } <NEW_LINE> <START_VULN> fprintf ( stderr , "rmdir: verifying access to % s: % s ( req path % s ) \n" , <NEW_LINE>controller , cgdir , path ) ; <NEW_LINE> <END_VULN> if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) { <NEW_LINE> ret = - EACCES ; <NEW_LINE> goto out ;
size_t <NEW_LINE> extent ; <NEW_LINE> <START_VULN> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <NEW_LINE> <END_VULN> return ( ( MemoryInfo * ) NULL ) ; <NEW_LINE> memory_info = ( MemoryInfo * ) MagickAssumeAligned ( AcquireAlignedMemory ( 1 , <NEW_LINE> sizeof ( * memory_info ) ) ) ;
for ( size_t n = 0 ; n < argc ; ++ n ) { <NEW_LINE> if ( ! call . destination -> wrap ( cx , & argv [ n ] ) ) <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> if ( ! DirectWrapper::construct ( cx , wrapper , argc , argv , rval ) ) <NEW_LINE> return false ; <NEW_LINE> call . leave ( ) ; <NEW_LINE> <START_VULN> return call . origin -> wrap ( cx , rval ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> extern JSBool <NEW_LINE> js_generic_native_method_dispatcher ( JSContext * cx , unsigned argc , Value * vp ) ; <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::nativeCall ( JSContext * cx , JSObject * wrapper , Class * clasp , Native native , CallArgs srcArgs ) <NEW_LINE> {
assert ( alarm_timer != NULL ) ; <NEW_LINE> assert ( config != NULL ) ; <NEW_LINE> <START_VULN> alarm_set ( alarm_timer , CONFIG_SETTLE_PERIOD_MS , timer_config_save , NULL ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void btif_config_flush ( void ) {
NS_ASSERTION ( view , "nsComboboxControlFrame view is null" ) ; <NEW_LINE> if ( view ) { <NEW_LINE> nsIWidget * widget = view -> GetWidget ( ) ; <NEW_LINE> if ( widget ) { <NEW_LINE> widget -> CaptureRollupEvents ( this , mDroppedDown ) ; <NEW_LINE> if ( ! aShowList ) { <NEW_LINE> nsCOMPtr < nsIRunnable > widgetDestroyer = <NEW_LINE> <START_VULN> new DestroyWidgetRunnable ( GetContent ( ) ) ; <NEW_LINE> <END_VULN> NS_DispatchToMainThread ( widgetDestroyer ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return weakFrame . IsAlive ( ) ; <NEW_LINE> }
return false ; <NEW_LINE> if ( ! WriteEbmlElement ( writer , kMkvDocType , "webm" ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> if ( ! WriteEbmlElement ( writer , kMkvDocTypeVersion , 2ULL ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> if ( ! WriteEbmlElement ( writer , kMkvDocTypeReadVersion , 2ULL ) ) <NEW_LINE> return false ;
printf ( " ] ( % llu ) \n" , ddword_tmp ) ; <NEW_LINE> break ; <NEW_LINE> case PT_LONG: <NEW_LINE> <START_VULN> printf ( " Value: % li\n" , * ( ( long * ) mapidata -> data ) ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case PT_I2: <NEW_LINE> printf ( " Value: % hi\n" , * ( ( short int * ) mapidata -> data ) ) ;
nsNSSSocketInfo * infoObject = ( nsNSSSocketInfo * ) fd -> higher -> secret ; <NEW_LINE> nsRefPtr < nsSSLStatus > status = infoObject -> SSLStatus ( ) ; <NEW_LINE> nsRefPtr < nsNSSCertificate > nsc ; <NEW_LINE> if ( ! status || ! status -> mServerCert ) { <NEW_LINE> nsc = new nsNSSCertificate ( serverCert ) ; <NEW_LINE> } <NEW_LINE> if ( SECSuccess == rv ) { <NEW_LINE> if ( nsc ) { <NEW_LINE> PRBool dummyIsEV ; <NEW_LINE> nsc -> GetIsExtendedValidation ( & dummyIsEV ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> CERTCertList * certList = CERT_GetCertChainFromCert ( serverCert , PR_Now ( ) , certUsageSSLCA ) ; <NEW_LINE><NEW_LINE> <END_VULN> nsCOMPtr < nsINSSComponent > nssComponent ; <NEW_LINE> for ( CERTCertListNode * node = CERT_LIST_HEAD ( certList ) ; <NEW_LINE> ! CERT_LIST_END ( node , certList ) ; <NEW_LINE> node = CERT_LIST_NEXT ( node ) ) { <NEW_LINE> if ( node -> cert -> slot ) {
<START_VULN> #ifndef CHROME_RENDERER_DEVTOOLS_CLIENT_H_ <NEW_LINE>#define CHROME_RENDERER_DEVTOOLS_CLIENT_H_ <NEW_LINE> <END_VULN> #pragma once <NEW_LINE> #include < string >
<START_VULN> ret = inflate ( & png_ptr -> zstream , Z_SYNC_FLUSH ) ; <NEW_LINE> <END_VULN> if ( ret != Z_OK && ret != Z_STREAM_END )
0 . 9999998698F , 0 . 9999998906F , 0 . 9999999088F , 0 . 9999999246F , <NEW_LINE> 0 . 9999999383F , 0 . 9999999500F , 0 . 9999999600F , 0 . 9999999684F , <NEW_LINE> 0 . 9999999754F , 0 . 9999999811F , 0 . 9999999858F , 0 . 9999999896F , <NEW_LINE> 0 . 9999999925F , 0 . 9999999948F , 0 . 9999999965F , 0 . 9999999978F , <NEW_LINE> 0 . 9999999986F , 0 . 9999999992F , 0 . 9999999996F , 0 . 9999999998F , <NEW_LINE> 0 . 9999999999F , 1 . 0000000000F , 1 . 0000000000F , 1 . 0000000000F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin8192 [ 4096 ] = { <NEW_LINE> <END_VULN> 0 . 0000000578F , 0 . 0000005198F , 0 . 0000014438F , 0 . 0000028299F , <NEW_LINE> 0 . 0000046780F , 0 . 0000069882F , 0 . 0000097604F , 0 . 0000129945F , <NEW_LINE> 0 . 0000166908F , 0 . 0000208490F , 0 . 0000254692F , 0 . 0000305515F , <NEW_LINE> 0 . 0000360958F , 0 . 0000421021F , 0 . 0000485704F , 0 . 0000555006F , <NEW_LINE> 0 . 0000628929F , 0 . 0000707472F , 0 . 0000790635F , 0 . 0000878417F ,
vp8_short_idct4x4llm_c ( input , dest , stride , dest , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( input , 0 , 32 ) ; <NEW_LINE> <END_VULN> }
public: <NEW_LINE> EmptyPlatform ( ) { } <NEW_LINE> ~ EmptyPlatform ( ) override { } <NEW_LINE> <START_VULN> void cryptographicallyRandomValues ( unsigned char * buffer , size_t length ) override { } <NEW_LINE> <END_VULN> } ; <NEW_LINE> TEST ( FontCache , getLastResortFallbackFont )
for ( InlineBox * curr = firstChild ( ) ; curr ; curr = curr -> nextOnLine ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> renderer ( ) -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( curr -> verticalAlign ( ) == TOP || curr -> verticalAlign ( ) == BOTTOM ) { <NEW_LINE> LayoutUnit lineHeight = curr -> lineHeight ( ) ;
} <NEW_LINE> nsRefPtr < nsGlobalWindow > newInnerWindow ; <NEW_LINE> bool createdInnerWindow = false ; <NEW_LINE> bool thisChrome = IsChromeWindow ( ) ; <NEW_LINE> nsCxPusher cxPusher ; <NEW_LINE> <START_VULN> if ( ! cxPusher . Push ( cx ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> XPCAutoRequest ar ( cx ) ; <NEW_LINE> nsCOMPtr < WindowStateHolder > wsh = do_QueryInterface ( aState ) ; <NEW_LINE> NS_ASSERTION ( ! aState || wsh , "What kind of weird state are you giving me here ? " ) ;
unsigned char * t = ( unsigned char * ) book -> dec_table ; <NEW_LINE> for ( i = 0 ; i < read ; i ++ ) { <NEW_LINE> <START_VULN> int bit = ( lok >> i ) & 1 ; <NEW_LINE>int next = t [ chase + bit ] ; <NEW_LINE>if ( next & 0x80 ) { <NEW_LINE>chase = ( next << 8 ) | t [ chase + bit + 1 + ( ! bit || t [ chase ] & 0x80 ) ] ; <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>chase = next ; <NEW_LINE> <END_VULN> } <NEW_LINE> chase &= ~ 0x8000UL ;
ctxt = xmlSchemaNewMemParserCtxt ( ( char * ) base , info . st_size ) ; <NEW_LINE> xmlSchemaSetParserErrors ( ctxt , <NEW_LINE> <START_VULN> ( xmlSchemaValidityErrorFunc ) fprintf , <NEW_LINE> ( xmlSchemaValidityWarningFunc ) fprintf , <NEW_LINE>stderr ) ; <NEW_LINE> <END_VULN> schema = xmlSchemaParse ( ctxt ) ; <NEW_LINE> xmlSchemaFreeParserCtxt ( ctxt ) ; <NEW_LINE> munmap ( ( char * ) base , info . st_size ) ;
const char * file_name ; <NEW_LINE> const char * function_name ; <NEW_LINE> ap_lua_vm_spec * spec ; <NEW_LINE> <START_VULN> apr_array_header_t * args ; <NEW_LINE> <END_VULN> } lua_authz_provider_spec ; <NEW_LINE> apr_hash_t * lua_authz_providers ; <NEW_LINE> typedef struct
} <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> nsCOMPtr < nsIPrincipal > principal = <NEW_LINE> do_CreateInstance ( "@mozilla . org / nullprincipal ; 1" ) ; <NEW_LINE> NS_ENSURE_TRUE ( principal , NS_ERROR_FAILURE ) ; <NEW_LINE> <START_VULN> JSContext * cx = nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE>NS_ENSURE_TRUE ( cx , NS_ERROR_FAILURE ) ; <NEW_LINE><NEW_LINE>nsCxPusher pusher ; <NEW_LINE>if ( ! pusher . Push ( cx ) ) { <NEW_LINE>NS_WARNING ( "Failed to push safe JS context ! " ) ; <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> nsIXPConnect * xpc = nsContentUtils::XPConnect ( ) ; <NEW_LINE> NS_ASSERTION ( xpc , "This should never be null ! " ) ; <NEW_LINE> nsCOMPtr < nsIXPConnectJSObjectHolder > globalHolder ; <NEW_LINE> nsresult rv = xpc -> CreateSandbox ( cx , principal , getter_AddRefs ( globalHolder ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
class nsDataChannel : public nsBaseChannel { <NEW_LINE> public: <NEW_LINE> nsDataChannel ( nsIURI * uri ) { <NEW_LINE> SetURI ( uri ) ; <NEW_LINE> } <NEW_LINE> protected: <NEW_LINE> <START_VULN> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result ) ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> #endif
{ <NEW_LINE> JSAutoEnterCompartment ac ; <NEW_LINE> CHECK ( ac . enter ( cx , compartment2 ) ) ; <NEW_LINE> next = js::Wrapper::New ( cx , compartment2 , compartment2 -> getProto ( ) , compartment2 , <NEW_LINE> & OuterWrapper::singleton ) ; <NEW_LINE> CHECK ( next ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> JS_SetWrapObjectCallbacks ( JS_GetRuntime ( cx ) , Wrap , PreWrap ) ; <NEW_LINE> <END_VULN> CHECK ( JS_TransplantObject ( cx , outerObj , next ) ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> END_TEST ( testBug604087 )
mFirstFrameOffset ( 0 ) , <NEW_LINE> mVersion ( ID3_UNKNOWN ) , <NEW_LINE> mRawSize ( 0 ) { <NEW_LINE> <START_VULN> sp < MemorySource > source = new MemorySource ( data , size ) ; <NEW_LINE> <END_VULN> mIsValid = parseV2 ( source , 0 ) ;
WEBKIT_EXPORT void skewX ( double angle ) ; <NEW_LINE> WEBKIT_EXPORT void skewY ( double angle ) ; <NEW_LINE> WEBKIT_EXPORT void applyPerspective ( double p ) ; <NEW_LINE> <START_VULN> WEBKIT_EXPORT void blend ( const WebTransformationMatrix & from , double progress ) ; <NEW_LINE> <END_VULN> WEBKIT_EXPORT bool hasPerspective ( ) const ; <NEW_LINE> WEBKIT_EXPORT bool isInvertible ( ) const ;
} <NEW_LINE> <START_VULN> static inline void realpath_cache_add ( const char * path , int path_len , const char * realpath , int realpath_len , int is_dir , time_t t ) <NEW_LINE> <END_VULN> { <NEW_LINE> zend_long size = sizeof ( realpath_cache_bucket ) + path_len + 1 ; <NEW_LINE> int same = 1 ;
sid = j_id -> valueint ; <NEW_LINE> bytes_transferred = j_bytes -> valueint ; <NEW_LINE> retransmits = j_retransmits -> valueint ; <NEW_LINE> <START_VULN> jitter = j_jitter -> valuefloat ; <NEW_LINE> <END_VULN> cerror = j_errors -> valueint ; <NEW_LINE> pcount = j_packets -> valueint ; <NEW_LINE> SLIST_FOREACH ( sp , & test -> streams , streams )
SVGSVGElement * rootElement = toSVGDocument ( frame -> document ( ) ) -> rootElement ( ) ; <NEW_LINE> if ( ! rootElement ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> RenderSVGRoot * renderer = toRenderSVGRoot ( rootElement -> renderer ( ) ) ; <NEW_LINE>if ( ! renderer ) <NEW_LINE>return ; <NEW_LINE> <END_VULN> FrameView * view = frameView ( ) ; <NEW_LINE> view -> resize ( this -> containerSize ( ) ) ; <NEW_LINE> renderer -> setContainerSize ( size ) ; <NEW_LINE> }
HTMLInputElement * input = toHTMLInputElement ( getNode ( ) ) ; <NEW_LINE> const AtomicString & type = input -> getAttribute ( typeAttr ) ; <NEW_LINE> <START_VULN> if ( ! equalIgnoringCase ( type , "color" ) ) <NEW_LINE> <END_VULN> return AXObject::colorValue ( ) ;
zend_llist_add_element ( & mh -> easyh , & tmp_val ) ; <NEW_LINE> <START_VULN> RETURN_LONG ( ( zend_long ) curl_multi_add_handle ( mh -> multi , ch -> cp ) ) ; <NEW_LINE> <END_VULN> }
<START_VULN> class FileEnumerator { <NEW_LINE> <END_VULN> public: <NEW_LINE> #if defined ( OS_WIN ) <NEW_LINE> typedef WIN32_FIND_DATA FindInfo ;
LIMIT_ALL ( all , doctype , charset ) ; <NEW_LINE> array_init ( return_value ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> entity_table = determine_entity_table ( all , doctype ) ; <NEW_LINE> if ( all && ! CHARSET_UNICODE_COMPAT ( charset ) ) { <NEW_LINE> to_uni_table = enc_to_uni_index [ charset ] ;
nsCOMPtr < nsIDeviceSensors > ac = do_GetService ( NS_DEVICE_SENSORS_CONTRACTID ) ; <NEW_LINE> if ( ac ) { <NEW_LINE> for ( uint32_t i = 0 ; i < mEnabledSensors . Length ( ) ; i ++ ) <NEW_LINE> ac -> RemoveWindowListener ( mEnabledSensors [ i ] , this ) ; <NEW_LINE> } <NEW_LINE> nsIScriptContext * scx = GetContextInternal ( ) ; <NEW_LINE> <START_VULN> JSContext * cx = scx ? scx -> GetNativeContext ( ) : nullptr ; <NEW_LINE> <END_VULN> mozilla::dom::workers::SuspendWorkersForWindow ( cx , this ) ; <NEW_LINE> TimeStamp now = TimeStamp::Now ( ) ; <NEW_LINE> for ( nsTimeout * t = mTimeouts . getFirst ( ) ; t ; t = t -> getNext ( ) ) { <NEW_LINE> if ( t -> mWhen > now ) <NEW_LINE> t -> mTimeRemaining = t -> mWhen - now ; <NEW_LINE> else
if ( oldlen < 64 ) { <NEW_LINE> <START_VULN> maxlen = 128 ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> maxlen = 2 * oldlen ; <NEW_LINE> if ( maxlen < oldlen ) {
pos += size ; <NEW_LINE> } <NEW_LINE> <START_VULN> assert ( pos == end ) ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
assert ( m_entries_size == 0 ) ; <NEW_LINE> m_entries_size = 1024 ; <NEW_LINE> <START_VULN> m_entries = new BlockEntry * [ m_entries_size ] ; <NEW_LINE> <END_VULN> m_entries_count = 0 ; <NEW_LINE> } else {
nsIFrame * mButtonFrame ; <NEW_LINE> nsIFrame * mDropdownFrame ; <NEW_LINE> nsIListControlFrame * mListControlFrame ; <NEW_LINE> nscoord mDisplayWidth ; <NEW_LINE> <START_VULN> bool mDroppedDown ; <NEW_LINE>bool mInRedisplayText ; <NEW_LINE><NEW_LINE> <END_VULN> nsRevocableEventPtr < RedisplayTextEvent > mRedisplayTextEvent ; <NEW_LINE> PRInt32 mRecentSelectedIndex ; <NEW_LINE> PRInt32 mDisplayedIndex ; <NEW_LINE> nsString mDisplayedOptionText ; <NEW_LINE> nsCOMPtr < nsIDOMEventListener > mButtonListener ; <NEW_LINE> static nsComboboxControlFrame * mFocused ; <NEW_LINE> #ifdef DO_REFLOW_COUNTER <NEW_LINE> PRInt32 mReflowId ; <NEW_LINE> #endif <NEW_LINE> } ;
if ( profile_len < 132 ) <NEW_LINE> png_error ( png_ptr , "ICC profile too short" ) ; <NEW_LINE> <START_VULN> if ( profile_len & 0x03 ) <NEW_LINE> <END_VULN> png_error ( png_ptr , "ICC profile length invalid ( not a multiple of 4 ) " ) ; <NEW_LINE> {
break ; <NEW_LINE> default: <NEW_LINE> assert ( 0 && "Invalid transform size . " ) ; <NEW_LINE> } <NEW_LINE> return combine_entropy_contexts ( above_ec , left_ec ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static const INLINE scan_order * get_scan ( const MACROBLOCKD * xd , TX_SIZE tx_size , <NEW_LINE>PLANE_TYPE type , int block_idx ) { <NEW_LINE>const MODE_INFO * const mi = xd -> mi [ 0 ] ; <NEW_LINE><NEW_LINE>if ( is_inter_block ( & mi -> mbmi ) || type != PLANE_TYPE_Y || xd -> lossless ) { <NEW_LINE>return & vp9_default_scan_orders [ tx_size ] ; <NEW_LINE> } else { <NEW_LINE>const MB_PREDICTION_MODE mode = get_y_mode ( mi , block_idx ) ; <NEW_LINE>return & vp9_scan_orders [ tx_size ] [ intra_mode_to_tx_type_lookup [ mode ] ] ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> } <NEW_LINE> #endif
} <NEW_LINE> png_write_row ( png_ptr , png_voidcast ( png_const_bytep , <NEW_LINE> <START_VULN> display -> local_row ) ) ; <NEW_LINE> <END_VULN> input_row += display -> row_bytes / ( sizeof ( png_uint_16 ) ) ; <NEW_LINE> } <NEW_LINE> }
SPL_METHOD ( SplFileObject , valid ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
<START_VULN> static void oidc_scrub_headers ( request_rec * r ) { <NEW_LINE> <END_VULN> oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , <NEW_LINE> & auth_openidc_module ) ;
} <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) { <NEW_LINE> free ( ext_fb_list -> ext_fb [ i ] . data ) ; <NEW_LINE> <START_VULN> ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ; <NEW_LINE> <END_VULN> if ( ! ext_fb_list -> ext_fb [ i ] . data ) <NEW_LINE> return - 1 ;
ND_PRINT ( ( ndo , " ( length bogus , should be = 4 ) " ) ) ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , ": 0x % 04x" , EXTRACT_16BITS ( p + 2 ) ) ) ; <NEW_LINE> break ; <NEW_LINE> case LCPOPT_CBACK:
NS_IMETHODIMP <NEW_LINE> nsWindow::SetCursor ( imgIContainer * aCursor , <NEW_LINE> PRUint32 aHotspotX , PRUint32 aHotspotY ) <NEW_LINE> { <NEW_LINE> if ( ! mContainer && mDrawingarea ) { <NEW_LINE> <START_VULN> nsWindow * window ; <NEW_LINE>GetContainerWindow ( & window ) ; <NEW_LINE> <END_VULN> return window -> SetCursor ( aCursor , aHotspotX , aHotspotY ) ; <NEW_LINE> } <NEW_LINE> if ( ! sPixbufCursorChecked ) { <NEW_LINE> PRLibrary * lib ; <NEW_LINE> _gdk_cursor_new_from_pixbuf = ( _gdk_cursor_new_from_pixbuf_fn ) <NEW_LINE> PR_FindFunctionSymbolAndLibrary ( "gdk_cursor_new_from_pixbuf" , & lib ) ; <NEW_LINE> if ( lib ) {
return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsHTMLDocument::OpenCommon ( const nsACString & aContentType , PRBool aReplace ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! IsHTML ( ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_DOM_INVALID_ACCESS_ERR ; <NEW_LINE> } <NEW_LINE> PRBool loadAsHtml5 = nsHtml5Module::sEnabled ; <NEW_LINE> nsresult rv = NS_OK ;
build_ids_self_fd = xasprintf ( " / proc / self / fd / % d" , build_ids_fd ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>const char * args [ 11 ] ; <NEW_LINE> <END_VULN> { <NEW_LINE> const char * verbs [ ] = { "" , " - v" , " - vv" , " - vvv" } ; <NEW_LINE> unsigned i = 0 ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> static bool getCoverageFormat4 ( vector < uint32_t > & coverage , const uint8_t * data , size_t size ) { <NEW_LINE> const size_t kSegCountOffset = 6 ; <NEW_LINE> const size_t kEndCountOffset = 14 ;
default: ycs = 0 ; break ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>align = ( 1 << xcs ) - 1 ; <NEW_LINE>w = ( d_w + align ) & ~ align ; <NEW_LINE>align = ( 1 << ycs ) - 1 ; <NEW_LINE>h = ( d_h + align ) & ~ align ; <NEW_LINE> <END_VULN> s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; <NEW_LINE> s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; <NEW_LINE> stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ;
#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED <NEW_LINE> static void <NEW_LINE> <START_VULN> image_transform_png_set_strip_alpha_set ( PNG_CONST image_transform * this , <NEW_LINE> <END_VULN> transform_display * that , png_structp pp , png_infop pi ) <NEW_LINE> { <NEW_LINE> png_set_strip_alpha ( pp ) ;
ALOGV ( "Table of sync samples is empty or has only a single entry ! " ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> uint64_t allocSize = mNumSyncSamples * sizeof ( uint32_t ) ; <NEW_LINE> <END_VULN> if ( allocSize > SIZE_MAX ) { <NEW_LINE> return ERROR_OUT_OF_RANGE ; <NEW_LINE> }
for ( size_t i = 0 ; i < children . size ( ) ; ++ i ) { <NEW_LINE> RenderBox * child = children [ i ] ; <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> child -> layer ( ) -> setStaticBlockPosition ( mainAxisOffset ) ; <NEW_LINE> mainAxisOffset - = justifyContentSpaceBetweenChildren ( availableFreeSpace , style ( ) -> justifyContent ( ) , childSizes . size ( ) ) ; <NEW_LINE> continue ;
{ <NEW_LINE> wchar_t time_buf [ 29 ] ; <NEW_LINE> wsprintf ( time_buf , TEXT ( " % d % S % d % 02d: % 02d: % 02d + 0000" ) , <NEW_LINE> <START_VULN> ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] , <NEW_LINE> <END_VULN> ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , <NEW_LINE> ptime -> second % 61 ) ; <NEW_LINE> WideCharToMultiByte ( CP_ACP , 0 , time_buf , - 1 , png_ptr -> time_buffer ,
goto out ; <NEW_LINE> <START_VULN> skb -> mac . raw = skb -> data ; <NEW_LINE> <END_VULN> skb_reserve ( skb , MAX_HEADER + sizeof ( struct iphdr ) ) ; <NEW_LINE> if ( rta [ RTA_SRC - 1 ] )
if ( NS_FAILED ( rv ) ) { <NEW_LINE> NS_WARNING ( "Failed to dispatch to the IO thread ! " ) ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> case IO: { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> AdvanceState ( ) ; <NEW_LINE> nsCOMPtr < nsIFile > directory ; <NEW_LINE> rv = quotaManager -> GetDirectoryForOrigin ( mOrigin , <NEW_LINE> getter_AddRefs ( directory ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
{ 10 , 7 , 6 } , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static const vp9_prob default_inter_mode_probs [ INTER_MODE_CONTEXTS ] <NEW_LINE> <END_VULN> [ INTER_MODES - 1 ] = { <NEW_LINE> { 2 , 173 , 34 } , <NEW_LINE> { 7 , 145 , 85 } ,
ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , <NEW_LINE> u1_tfr_n_mb , u1_end_of_row ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( u1_tfr_n_mb ) <NEW_LINE> u1_num_mbs = 0 ; <NEW_LINE> u1_mb_idx = u1_num_mbs ;
dstExtents -> bottom = MAX ( rect -> bottom , srcExtents -> bottom ) ; <NEW_LINE> dstExtents -> right = MAX ( rect -> right , srcExtents -> right ) ; <NEW_LINE> newItems -> size = sizeof ( REGION16_DATA ) + ( usedRects * sizeof ( RECTANGLE_16 ) ) ; <NEW_LINE> <START_VULN> dst -> data = realloc ( newItems , newItems -> size ) ; <NEW_LINE> <END_VULN> if ( ! dst -> data ) <NEW_LINE> {
return true ; <NEW_LINE> if ( ( uint64_t ) capacity * elemSize > size_type ( - 1 ) / 2 ) { <NEW_LINE> <START_VULN> NS_ERROR ( "Attempting to allocate excessively large array" ) ; <NEW_LINE> <END_VULN> return false ; <NEW_LINE> } <NEW_LINE> if ( mHdr == EmptyHdr ( ) ) { <NEW_LINE> Header * header = static_cast < Header * > <NEW_LINE> ( Alloc::Malloc ( sizeof ( Header ) + capacity * elemSize ) ) ; <NEW_LINE> if ( ! header )
#endif <NEW_LINE> extern SECStatus ssl3_HandleHelloExtensions ( sslSocket * ss , <NEW_LINE> SSL3Opaque ** b , PRUint32 * length ) ; <NEW_LINE> extern PRBool ssl3_ExtensionNegotiated ( sslSocket * ss , PRUint16 ex_type ) ; <NEW_LINE> <START_VULN> extern SECStatus ssl3_SetSIDSessionTicket ( sslSessionID * sid , <NEW_LINE>NewSessionTicket * session_ticket ) ; <NEW_LINE> <END_VULN> extern SECStatus ssl3_SendNewSessionTicket ( sslSocket * ss ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeys ( unsigned char * keyName , <NEW_LINE> unsigned char * encKey , unsigned char * macKey ) ; <NEW_LINE> extern PRBool ssl_GetSessionTicketKeysPKCS11 ( SECKEYPrivateKey * svrPrivKey , <NEW_LINE> SECKEYPublicKey * svrPubKey , void * pwArg , <NEW_LINE> unsigned char * keyName , PK11SymKey ** aesKey , <NEW_LINE> PK11SymKey ** macKey ) ;
void InitAsProxiedNaCl ( <NEW_LINE> <START_VULN> scoped_ptr < PluginDelegate::OutOfProcessProxy > out_of_process_proxy , <NEW_LINE> <END_VULN> PP_Instance instance ) ; <NEW_LINE> static const PPB_Core * GetCore ( ) ;
{ <NEW_LINE> png_uint_16p hist ; <NEW_LINE> <START_VULN> if ( png_get_hIST ( read_ptr , read_info_ptr , & hist ) ) <NEW_LINE> <END_VULN> png_set_hIST ( write_ptr , write_info_ptr , hist ) ; <NEW_LINE> } <NEW_LINE> #endif
static int <NEW_LINE> image_transform_png_set_strip_alpha_add ( image_transform * this , <NEW_LINE> <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE> <END_VULN> { <NEW_LINE> UNUSED ( bit_depth )
len += tlen ; <NEW_LINE> } <NEW_LINE> if ( IS_NOT_NULL ( Else ) ) { <NEW_LINE> <START_VULN> len += SIZE_OP_JUMP ; <NEW_LINE> <END_VULN> tlen = compile_length_tree ( Else , reg ) ; <NEW_LINE> if ( tlen < 0 ) return tlen ; <NEW_LINE> len += tlen ;
return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> bool WebGLImageConversion::ExtractTextureData ( unsigned width , <NEW_LINE>unsigned height , <NEW_LINE>GLenum format , <NEW_LINE>GLenum type , <NEW_LINE>unsigned unpack_alignment , <NEW_LINE>bool flip_y , <NEW_LINE>bool premultiply_alpha , <NEW_LINE>const void * pixels , <NEW_LINE>Vector < uint8_t > & data ) { <NEW_LINE> <END_VULN> DataFormat source_data_format = GetDataFormat ( format , type ) ; <NEW_LINE> if ( source_data_format == kDataFormatNumFormats )
int re_yyget_column ( yyscan_t yyscanner ) <NEW_LINE> { <NEW_LINE> struct yyguts_t * yyg = ( struct yyguts_t * ) yyscanner ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ! YY_CURRENT_BUFFER ) <NEW_LINE> return 0 ;
} <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> } <NEW_LINE> return result ; <NEW_LINE> }
const nsCString & flatMethod = PromiseFlatCString ( method ) ; <NEW_LINE> <START_VULN> if ( ! IsValidToken ( flatMethod ) ) <NEW_LINE> <END_VULN> return NS_ERROR_INVALID_ARG ; <NEW_LINE> nsHttpAtom atom = nsHttp::ResolveAtom ( flatMethod . get ( ) ) ;
( ( uint64_t ) p -> hq [ 2 ] << 40 ) | ( ( uint64_t ) p -> hq [ 3 ] << 32 ) | <NEW_LINE> ( ( uint64_t ) p -> hq [ 4 ] << 24 ) | ( ( uint64_t ) p -> hq [ 5 ] << 16 ) | <NEW_LINE> ( ( uint64_t ) p -> hq [ 6 ] << 8 ) | ( ( uint64_t ) p -> hq [ 7 ] ) ) ; <NEW_LINE> <START_VULN> cvt_64 ( p , m ) ; <NEW_LINE> <END_VULN> return 1 ; <NEW_LINE> case FILE_LESHORT: <NEW_LINE> p -> h = ( short ) ( ( p -> hs [ 1 ] << 8 ) | ( p -> hs [ 0 ] ) ) ;
#ifndef _FONTCONFIG_SRC_FCSTDINT_H <NEW_LINE> #define _FONTCONFIG_SRC_FCSTDINT_H 1 <NEW_LINE> #ifndef _GENERATED_STDINT_H <NEW_LINE> <START_VULN> #define _GENERATED_STDINT_H "fontconfig 2 . 13 . 0" <NEW_LINE><NEW_LINE> <END_VULN> #define _STDINT_HAVE_STDINT_H 1 <NEW_LINE> #include < stdint . h > <NEW_LINE> #endif
HandleObject singleton , HandleId singletonId ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( singletonId == IdToTypeId ( singletonId ) && ! JSID_IS_VOID ( singletonId ) ) ; <NEW_LINE> Bytecode & code = getCode ( pc ) ; <NEW_LINE> if ( ! code . typeBarriers ) { <NEW_LINE> <START_VULN> RootedScript script ( cx , script_ ) ; <NEW_LINE>AddPendingRecompile ( cx , script ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> InferSpew ( ISpewOps , "singletonTypeBarrier: # % u: % 05u: % sT % p % s % p % s" , <NEW_LINE> script_ -> id ( ) , pc - script_ -> code , <NEW_LINE> InferSpewColor ( target ) , target , InferSpewColorReset ( ) , <NEW_LINE> ( void * ) singleton . get ( ) , TypeIdString ( singletonId ) ) ; <NEW_LINE> TypeBarrier * barrier = cx -> analysisLifoAlloc ( ) . new_ < TypeBarrier > ( target , Type::UndefinedType ( ) ,
return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsGeolocation::ClearWatch ( PRInt32 aWatchId ) <NEW_LINE> { <NEW_LINE> PRUint32 count = mWatchingCallbacks . Length ( ) ; <NEW_LINE> <START_VULN> if ( aWatchId < 0 || count == 0 || PRUint32 ( aWatchId ) > count ) <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> mWatchingCallbacks [ aWatchId ] -> MarkCleared ( ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> PRBool <NEW_LINE> nsGeolocation::WindowOwnerStillExists ( )
} <NEW_LINE> tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( snprintf ( scratch , scratch_len , "Authorization: Basic % s\r\n" , tmp ) > 0 ) { <NEW_LINE> php_stream_write ( stream , scratch , strlen ( scratch ) ) ; <NEW_LINE> php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ;
} <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> <START_VULN> res = xmlBuildURI ( ( xmlChar * ) str , ( xmlChar * ) base ) ; <NEW_LINE> <END_VULN> if ( res != NULL ) { <NEW_LINE> printf ( " % s\n" , ( char * ) res ) ; <NEW_LINE> }
extern void _vp_remove_floor ( vorbis_look_psy * p , <NEW_LINE> float * mdct , <NEW_LINE> int * icodedflr , <NEW_LINE> float * residue , <NEW_LINE> int sliding_lowpass ) ; <NEW_LINE> extern void _vp_noisemask ( vorbis_look_psy * p , <NEW_LINE> <START_VULN> float * logmdct , <NEW_LINE> <END_VULN> float * logmask ) ; <NEW_LINE> extern void _vp_tonemask ( vorbis_look_psy * p , <NEW_LINE> float * logfft , <NEW_LINE> float * logmask , <NEW_LINE> float global_specmax , <NEW_LINE> float local_specmax ) ;
virtual void DidAutoResize ( const WebSize & new_size ) { } <NEW_LINE> <START_VULN> virtual void DidFocus ( ) { } <NEW_LINE> <END_VULN>
virtual ~ DesktopSessionWin ( ) ; <NEW_LINE> <START_VULN> virtual void OnChannelConnected ( ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual bool OnMessageReceived ( const IPC::Message & message ) OVERRIDE ; <NEW_LINE> virtual void OnPermanentError ( ) OVERRIDE ;
public BrowserBubble::Delegate , <NEW_LINE> public views::ViewMenuDelegate , <NEW_LINE> public views::ResizeGripper::ResizeGripperDelegate , <NEW_LINE> <START_VULN> public AnimationDelegate , <NEW_LINE>public ExtensionToolbarModel::Observer { <NEW_LINE> <END_VULN> public: <NEW_LINE> BrowserActionsContainer ( Profile * profile , ToolbarView * toolbar ) ; <NEW_LINE> virtual ~ BrowserActionsContainer ( ) ;
while ( dst != dstEnd ) <NEW_LINE> ( dst ++ ) -> init ( UndefinedValue ( ) ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> static void <NEW_LINE> CopyStackFrameArguments ( const StackFrame * fp , HeapValue * dst ) <NEW_LINE> { <NEW_LINE> <START_VULN> JS_ASSERT ( ! fp -> beginsIonActivation ( ) ) ; <NEW_LINE> <END_VULN> HeapValue * dstBase = dst ; <NEW_LINE> unsigned numActuals = fp -> numActualArgs ( ) ; <NEW_LINE> unsigned numFormals = fp -> callee ( ) . nargs ; <NEW_LINE> Value * src = fp -> formals ( ) ; <NEW_LINE> Value * end = src + numFormals ;
uid = gid = 0 ; <NEW_LINE> mode = 0750 ; <NEW_LINE> if ( schr ( auth , ':' ) ) { <NEW_LINE> <START_VULN> owner = stok ( auth , ":" , & tok ) ; <NEW_LINE> <END_VULN> if ( owner && * owner ) { <NEW_LINE> if ( snumber ( owner ) ) { <NEW_LINE> uid = ( int ) stoi ( owner ) ;
} else { <NEW_LINE> xmlFatalErr ( ctxt , XML_ERR_PI_NOT_STARTED , NULL ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> ctxt -> instate = state ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
nsIContent * aContent1 , <NEW_LINE> nsIContent * aContent2 , <NEW_LINE> PRInt32 aStateMask ) <NEW_LINE> { <NEW_LINE> NS_PRECONDITION ( ! mIsDocumentGone , "Unexpected ContentStatesChanged" ) ; <NEW_LINE> NS_PRECONDITION ( aDocument == mDocument , "Unexpected aDocument" ) ; <NEW_LINE> if ( mDidInitialReflow ) { <NEW_LINE> <START_VULN> nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE> <END_VULN> mFrameConstructor -> ContentStatesChanged ( aContent1 , aContent2 , aStateMask ) ; <NEW_LINE> VERIFY_STYLE_TREE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> PresShell::AttributeChanged ( nsIDocument * aDocument ,
char * sb ; <NEW_LINE> char * req = NULL ; <NEW_LINE> struct printparam pp ; <NEW_LINE> <START_VULN> int contentlen = 0 ; <NEW_LINE> <END_VULN> int isform = 0 ; <NEW_LINE> pp . inbuf = 0 ;
bittok2str_internal ( register const struct tok * lp , register const char * fmt , <NEW_LINE> register u_int v , const char * sep ) <NEW_LINE> { <NEW_LINE> <START_VULN> static char buf [ 256 ] ; <NEW_LINE>int buflen = 0 ; <NEW_LINE> <END_VULN> register u_int rotbit ; <NEW_LINE> register u_int tokval ; <NEW_LINE> const char * sepstr = "" ;
void SetDirectionFromNewTextNode ( nsIContent * aTextNode ) ; <NEW_LINE> <START_VULN> void ResetDirectionSetByTextNode ( nsTextNode * aTextNode ) ; <NEW_LINE> <END_VULN> void SetDirectionalityFromValue ( mozilla::dom::Element * aElement , <NEW_LINE> const nsAString & aValue , <NEW_LINE> bool aNotify ) ;
NS_ConvertUTF8toUTF16 ( mImage . GetURIString ( ) ) , <NEW_LINE> EmptyString ( ) , 0 , 0 , nsIScriptError::errorFlag , <NEW_LINE> "Image" , mImage . InnerWindowID ( ) <NEW_LINE> ) ) ) { <NEW_LINE> consoleService -> LogMessage ( errorObject ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> bool usable = true ; <NEW_LINE> <END_VULN> if ( aShutdownIntent != RasterImage::eShutdownIntent_NotNeeded && ! HasDecoderError ( ) ) { <NEW_LINE> if ( GetCompleteFrameCount ( ) == 0 ) { <NEW_LINE> usable = false ; <NEW_LINE> } <NEW_LINE> }
( * JSGCCallback ) ( JSRuntime * rt , JSGCStatus status ) ; <NEW_LINE> typedef enum JSFinalizeStatus { <NEW_LINE> JSFINALIZE_START , <NEW_LINE> JSFINALIZE_END <NEW_LINE> } JSFinalizeStatus ; <NEW_LINE> typedef void <NEW_LINE> <START_VULN> ( * JSFinalizeCallback ) ( JSFreeOp * fop , JSFinalizeStatus status ) ; <NEW_LINE> <END_VULN> typedef void <NEW_LINE> ( * JSTraceDataOp ) ( JSTracer * trc , void * data ) ;
if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE ) <NEW_LINE> #endif <NEW_LINE> { <NEW_LINE> <START_VULN> png_crc_finish ( png_ptr , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifndef PNG_READ_OPT_PLTE_SUPPORTED <NEW_LINE> else if ( png_crc_error ( png_ptr ) )
nullptr , 0 , true ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsHTMLEditor::PasteNoFormatting ( int32_t aSelectionType ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! FireClipboardEvent ( NS_PASTE ) ) <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> ForceCompositionEnd ( ) ; <NEW_LINE> nsresult rv ; <NEW_LINE> nsCOMPtr < nsIClipboard > clipboard ( do_GetService ( "@mozilla . org / widget / clipboard ; 1" , & rv ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
nsAutoPtr < CacheEntry > & aValue , <NEW_LINE> void * aUserData ) <NEW_LINE> { <NEW_LINE> PRTime * now = static_cast < PRTime * > ( aUserData ) ; <NEW_LINE> aValue -> PurgeExpired ( * now ) ; <NEW_LINE> if ( aValue -> mHeaders . IsEmpty ( ) && <NEW_LINE> <START_VULN> aValue -> mHeaders . IsEmpty ( ) ) { <NEW_LINE> <END_VULN> PR_REMOVE_LINK ( aValue ) ; <NEW_LINE> return PL_DHASH_REMOVE ; <NEW_LINE> } <NEW_LINE> return PL_DHASH_NEXT ; <NEW_LINE> }
void vp9_set_segment_data ( struct segmentation * seg , signed char * feature_data , <NEW_LINE> unsigned char abs_delta ) ; <NEW_LINE> <START_VULN> void vp9_choose_segmap_coding_method ( VP9_COMP * cpi ) ; <NEW_LINE> <END_VULN> void vp9_reset_segment_features ( struct segmentation * seg ) ;
virtual size_t SizeOfIncludingThis ( mozilla::MallocSizeOf mallocSizeOf ) <NEW_LINE> const MOZ_MUST_OVERRIDE MOZ_OVERRIDE ; <NEW_LINE> bool AppendFontFaceRules ( nsPresContext * aPresContext , <NEW_LINE> nsTArray < nsFontFaceRuleContainer > & aArray ) ; <NEW_LINE> <START_VULN> bool AppendKeyframesRules ( nsPresContext * aPresContext , <NEW_LINE>nsTArray < nsCSSKeyframesRule * > & aArray ) ; <NEW_LINE> <END_VULN> bool AppendPageRules ( nsPresContext * aPresContext , <NEW_LINE> nsTArray < nsCSSPageRule * > & aArray ) ; <NEW_LINE> bool AppendFontFeatureValuesRules ( nsPresContext * aPresContext , <NEW_LINE> nsTArray < nsCSSFontFeatureValuesRule * > & aArray ) ;
: cue_entries_capacity_ ( 0 ) , <NEW_LINE> cue_entries_size_ ( 0 ) , <NEW_LINE> cue_entries_ ( NULL ) , <NEW_LINE> <START_VULN> output_block_number_ ( true ) { <NEW_LINE> } <NEW_LINE> <END_VULN> Cues:: ~ Cues ( ) { <NEW_LINE> if ( cue_entries_ ) {
( void ) WriteBlobByte ( image , tga_info . bits_per_pixel ) ; <NEW_LINE> ( void ) WriteBlobByte ( image , tga_info . attributes ) ; <NEW_LINE> if ( tga_info . id_length != 0 ) <NEW_LINE> <START_VULN> ( void ) WriteBlob ( image , tga_info . id_length , ( unsigned char * ) value ) ; <NEW_LINE> <END_VULN> if ( tga_info . colormap_type != 0 ) <NEW_LINE> { <NEW_LINE> unsigned char
* <NEW_LINE> #define NSS_BUILTINS_LIBRARY_VERSION_MAJOR 1 <NEW_LINE> <START_VULN> #define NSS_BUILTINS_LIBRARY_VERSION_MINOR 79 <NEW_LINE>#define NSS_BUILTINS_LIBRARY_VERSION "1 . 79" <NEW_LINE> <END_VULN> #define NSS_BUILTINS_HARDWARE_VERSION_MAJOR 1 <NEW_LINE> #define NSS_BUILTINS_HARDWARE_VERSION_MINOR 0 <NEW_LINE> #define NSS_BUILTINS_FIRMWARE_VERSION_MAJOR 1
return left + right ; <NEW_LINE> } <NEW_LINE> <START_VULN> void vp9_tree_probs_from_distribution ( vp9_tree tree , <NEW_LINE> <END_VULN> unsigned int branch_ct [ ] [ 2 ] , <NEW_LINE> const unsigned int num_events [ ] ) { <NEW_LINE> convert_distribution ( 0 , tree , branch_ct , num_events ) ;
CVE_2013_0799_IsStatusApplying ( LPCWSTR updateDirPath , BOOL & isApplying ) <NEW_LINE> { <NEW_LINE> isApplying = FALSE ; <NEW_LINE> <START_VULN> WCHAR updateStatusFilePath [ MAX_PATH + 1 ] ; <NEW_LINE>wcscpy ( updateStatusFilePath , updateDirPath ) ; <NEW_LINE> <END_VULN> if ( ! PathAppendSafe ( updateStatusFilePath , L"update . status" ) ) { <NEW_LINE> LOG_WARN ( ( "Could not append path for update . status file" ) ) ; <NEW_LINE> return FALSE ;
static image_pixel data ; <NEW_LINE> static void <NEW_LINE> <START_VULN> image_transform_png_set_background_set ( PNG_CONST image_transform * this , <NEW_LINE> <END_VULN> transform_display * that , png_structp pp , png_infop pi ) <NEW_LINE> { <NEW_LINE> png_byte colour_type , bit_depth ;
<START_VULN> png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , mainprog_ptr , <NEW_LINE> <END_VULN> readpng2_error_handler , readpng2_warning_handler ) ; <NEW_LINE> if ( ! png_ptr ) <NEW_LINE> return 4 ;
} else if ( arg_match ( & arg , & error_concealment , argi ) ) { <NEW_LINE> ec_enabled = 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>#endif <NEW_LINE> <END_VULN> else <NEW_LINE> argj ++ ; <NEW_LINE> }
<START_VULN> #include "core / html / forms / BaseClickableWithKeyInputType . h" <NEW_LINE> <END_VULN> #include "core / events / KeyboardEvent . h" <NEW_LINE> #include "core / html / HTMLInputElement . h"
<START_VULN> #define VERSION "2 . 13 . 0" <NEW_LINE> <END_VULN>
v = gamma_16_to_1 [ * ( sp + 5 ) >> gamma_shift ] [ * ( sp + 4 ) ] ; <NEW_LINE> png_composite_16 ( w , v , a , png_ptr -> background_1 . blue ) ; <NEW_LINE> <START_VULN> if ( ! optimize ) <NEW_LINE>w = gamma_16_from_1 [ ( ( w & 0xff ) >> gamma_shift ) ] [ w >> <NEW_LINE> <END_VULN> 8 ] ; <NEW_LINE> * ( sp + 4 ) = ( png_byte ) ( ( w >> 8 ) & 0xff ) ;
cx = nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE> } <NEW_LINE> mAr . construct ( cx ) ; <NEW_LINE> <START_VULN> if ( ! mCxPusher . Push ( cx , false ) ) { <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
size = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> uint8_t * buffer = new ( std::nothrow ) uint8_t [ size + chunk_size ] ; <NEW_LINE> <END_VULN> if ( buffer == NULL ) { <NEW_LINE> return ERROR_MALFORMED ; <NEW_LINE> }
<START_VULN> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ; <NEW_LINE> <END_VULN> if ( best_mode . mbmode . mode == B_PRED ) <NEW_LINE> {
MYSQL_OPT_CONNECT_ATTR_DELETE , <NEW_LINE> MYSQL_SERVER_PUBLIC_KEY , <NEW_LINE> MYSQL_ENABLE_CLEARTEXT_PLUGIN , <NEW_LINE> <START_VULN> MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS <NEW_LINE> <END_VULN> } ;
bool hasStaticBlockPosition ( bool horizontal ) const { return horizontal ? hasAutoTopAndBottom ( ) : hasAutoLeftAndRight ( ) ; } <NEW_LINE> EPosition position ( ) const { return static_cast < EPosition > ( noninherited_flags . _position ) ; } <NEW_LINE> <START_VULN> bool isPositioned ( ) const { return position ( ) == AbsolutePosition || position ( ) == FixedPosition ; } <NEW_LINE> <END_VULN> EFloat floating ( ) const { return static_cast < EFloat > ( noninherited_flags . _floating ) ; } <NEW_LINE> Length width ( ) const { return m_box -> width ( ) ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: * unnormalized * fft transform <NEW_LINE> <START_VULN> last mod: $ Id: smallft . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdio . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h" <NEW_LINE> #include "codec_internal . h" <NEW_LINE> #include "registry . h"
displays [ idx ] = displays_ [ idx ] ; <NEW_LINE> } <NEW_LINE> <START_VULN> delete [ ] displays_ ; <NEW_LINE> <END_VULN> displays_ = displays ; <NEW_LINE> displays_size_ = size ;
Image ( nsIURI * aURI , nsStringBuffer * aString , nsIURI * aReferrer , <NEW_LINE> nsIPrincipal * aOriginPrincipal , nsIDocument * aDocument ) NS_HIDDEN ; <NEW_LINE> ~ Image ( ) NS_HIDDEN ; <NEW_LINE> nsCOMPtr < imgIRequest > mRequest ; <NEW_LINE> <START_VULN> <NEW_LINE>void AddRef ( ) { ++ mRefCnt ; } <NEW_LINE>void Release ( ) { if ( -- mRefCnt == 0 ) delete this ; } <NEW_LINE> <END_VULN> } ; <NEW_LINE> private: <NEW_LINE> static const PRUnichar * GetBufferValue ( nsStringBuffer * aBuffer ) { <NEW_LINE> return static_cast < PRUnichar * > ( aBuffer -> Data ( ) ) ; <NEW_LINE> } <NEW_LINE> protected:
private: <NEW_LINE> WebFileSystem * fileSystem ( ) const ; <NEW_LINE> void requestFileSystemAccessInternal ( ExecutionContext * , const Closure & allowed , const Closure & denied ) ; <NEW_LINE> <START_VULN> void fileSystemNotAvailable ( PassRefPtrWillBeRawPtr < ExecutionContext > , PassRefPtr < CallbackWrapper > ) ; <NEW_LINE>void fileSystemNotAllowedInternal ( PassRefPtrWillBeRawPtr < ExecutionContext > , PassRefPtr < CallbackWrapper > ) ; <NEW_LINE>void fileSystemAllowedInternal ( PassRefPtrWillBeRawPtr < ExecutionContext > , FileSystemType , PassRefPtr < CallbackWrapper > ) ; <NEW_LINE>void resolveURLInternal ( PassRefPtrWillBeRawPtr < ExecutionContext > , const KURL & , PassRefPtr < CallbackWrapper > ) ; <NEW_LINE>void deleteFileSystemInternal ( PassRefPtrWillBeRawPtr < ExecutionContext > , FileSystemType , PassRefPtr < CallbackWrapper > ) ; <NEW_LINE> <END_VULN> OwnPtr < FileSystemClient > m_client ; <NEW_LINE> } ;
( jp2_image -> comps [ 0 ] . dy != jp2_image -> comps [ i ] . dy ) || <NEW_LINE> ( jp2_image -> comps [ 0 ] . prec != jp2_image -> comps [ i ] . prec ) || <NEW_LINE> ( jp2_image -> comps [ 0 ] . sgnd != jp2_image -> comps [ i ] . sgnd ) || <NEW_LINE> <START_VULN> ( jp2_image -> comps [ i ] . data == NULL ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> opj_destroy_codec ( jp2_codec ) ; <NEW_LINE> opj_image_destroy ( jp2_image ) ;
err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , <NEW_LINE> le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) , <NEW_LINE> <START_VULN> USB_DT_OTG , ( void ** ) & desc ) ; <NEW_LINE> <END_VULN> if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) <NEW_LINE> return 0 ;
<START_VULN> if ( ( reader -> node -> type == XML_ELEMENT_NODE ) || <NEW_LINE> ( reader -> node -> type == XML_ATTRIBUTE_NODE ) ) { <NEW_LINE>reader -> state = XML_TEXTREADER_BACKTRACK ; <NEW_LINE><NEW_LINE>xmlTextReaderRead ( reader ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> if ( reader -> node -> next != 0 ) {
#ifdef PNG_READ_sCAL_SUPPORTED <NEW_LINE> else if ( chunk_name == png_sCAL ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_sCAL ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
typedef ogg_int16_t vorbis_fpu_control ; <NEW_LINE> static inline void vorbis_fpu_setround ( vorbis_fpu_control * fpu ) { <NEW_LINE> ogg_int16_t ret ; <NEW_LINE> ogg_int16_t temp ; <NEW_LINE> __asm__ __volatile__ ( "fnstcw % 0\n\t" <NEW_LINE> "movw % 0 , % % dx\n\t" <NEW_LINE> <START_VULN> "orw $ 62463 , % % dx\n\t" <NEW_LINE> <END_VULN> "movw % % dx , % 1\n\t" <NEW_LINE> "fldcw % 1\n\t":" = m" ( ret ) :"m" ( temp ) : "dx" ) ; <NEW_LINE> * fpu = ret ; <NEW_LINE> } <NEW_LINE> static inline void vorbis_fpu_restore ( vorbis_fpu_control fpu ) { <NEW_LINE> __asm__ __volatile__ ( "fldcw % 0":: "m" ( fpu ) ) ; <NEW_LINE> }
RETURN_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> RETVAL_LONG ( ( zend_long ) curl_multi_remove_handle ( mh -> multi , ch -> cp ) ) ; <NEW_LINE> <END_VULN> zend_llist_del_element ( & mh -> easyh , z_ch , ( int ( * ) ( void * , void * ) ) curl_compare_resources ) ; <NEW_LINE> }
Rooted < ArrayBufferObject * > buffer ( cx ) ; <NEW_LINE> buffer = & args [ 0 ] . toObject ( ) . as < ArrayBufferObject > ( ) ; <NEW_LINE> <START_VULN> if ( callee -> opaque ( ) || buffer -> isNeutered ( ) ) { <NEW_LINE> <END_VULN> JS_ReportErrorNumber ( cx , js_GetErrorMessage , <NEW_LINE> nullptr , JSMSG_TYPEDOBJECT_BAD_ARGS ) ; <NEW_LINE> return false ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: LPC low level routines <NEW_LINE> <START_VULN> last mod: $ Id: lpc . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN>
#include "base / macros . h" <NEW_LINE> #include "mojo / public / cpp / bindings / associated_binding . h" <NEW_LINE> <START_VULN> #include "third_party / blink / public / mojom / devtools / devtools_frontend . mojom - blink . h" <NEW_LINE> <END_VULN> #include "third_party / blink / renderer / core / inspector / inspector_frontend_client . h" <NEW_LINE> #include "third_party / blink / renderer / platform / heap / handle . h" <NEW_LINE> #include "third_party / blink / renderer / platform / supplementable . h"
if ( buflen == - 1 ) <NEW_LINE> buflen = 0 ; <NEW_LINE> <START_VULN> buflen = MIN ( buflen , buf_size ) ; <NEW_LINE> <END_VULN> bytes_consumed = buflen + u4_length_of_start_code ; <NEW_LINE> ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ;
void StartFetching ( FetchCallback callback ) override ; <NEW_LINE> <START_VULN> void DeleteSharedWorker ( const GURL & worker , const std::string & name ) override ; <NEW_LINE> <END_VULN> private: <NEW_LINE> ~ MockBrowsingDataSharedWorkerHelper ( ) override ;
NS_ASSERTION ( aScriptObject , "uh - oh , script Object should NOT be null or bad things will happen" ) ; <NEW_LINE> if ( ! aScriptObject ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> JSObject * globalObject = sgo -> GetGlobalJSObject ( ) ; <NEW_LINE> <START_VULN> if ( ( mJSGetterObject || mJSSetterObject ) && aTargetClassObject ) { <NEW_LINE> <END_VULN> JSObject * getter = nullptr ; <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , globalObject ) ; <NEW_LINE> if ( mJSGetterObject ) <NEW_LINE> if ( ! ( getter = ::JS_CloneFunctionObject ( cx , mJSGetterObject , globalObject ) ) ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ;
#endif <NEW_LINE> } else { <NEW_LINE> UnwindForUncatchableException ( cx , regs ) ; <NEW_LINE> interpReturnOK = false ; <NEW_LINE> } <NEW_LINE> forced_return: <NEW_LINE> UnwindScope ( cx , 0 ) ; <NEW_LINE> <START_VULN> regs . sp = regs . fp ( ) -> base ( ) ; <NEW_LINE>regs . pc = script -> code + script -> length - JSOP_STOP_LENGTH ; <NEW_LINE>JS_ASSERT ( * regs . pc == JSOP_STOP ) ; <NEW_LINE> <END_VULN> if ( entryFrame != regs . fp ( ) ) <NEW_LINE> goto inline_return ; <NEW_LINE> exit: <NEW_LINE> if ( cx -> compartment -> debugMode ( ) ) <NEW_LINE> interpReturnOK = ScriptDebugEpilogue ( cx , regs . fp ( ) , interpReturnOK ) ; <NEW_LINE> interpReturnOK = ScriptEpilogueOrGeneratorYield ( cx , regs . fp ( ) , interpReturnOK ) ;
nsIAtom * childListName = nsnull ; <NEW_LINE> PRInt32 childListIndex = 0 ; <NEW_LINE> do { <NEW_LINE> nsIFrame * childFrame = aFrame -> GetFirstChild ( childListName ) ; <NEW_LINE> for ( ; childFrame ; childFrame = childFrame -> GetNextSibling ( ) ) { <NEW_LINE> if ( NS_LIKELY ( nsGkAtoms::placeholderFrame != childFrame -> GetType ( ) ) ) { <NEW_LINE> DoDeletingFrameSubtree ( aFrameManager , aDestroyQueue , <NEW_LINE> aRemovedFrame , childFrame ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> } else { <NEW_LINE> nsIFrame * outOfFlowFrame = <NEW_LINE> nsPlaceholderFrame::GetRealFrameForPlaceholder ( childFrame ) ; <NEW_LINE> aFrameManager -> UnregisterPlaceholderFrame ( ( nsPlaceholderFrame * ) childFrame ) ;
gMediaCache -> NoteBlockUsage ( this , cacheBlock , mCurrentMode , TimeStamp::Now ( ) ) ; <NEW_LINE> PRInt64 offset = cacheBlock * BLOCK_SIZE + offsetInStreamBlock ; <NEW_LINE> <START_VULN> NS_ASSERTION ( size >= 0 && size <= PR_INT32_MAX , "Size out of range . " ) ; <NEW_LINE> <END_VULN> nsresult rv = gMediaCache -> ReadCacheFile ( offset , aBuffer + count , PRInt32 ( size ) , & bytes ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> if ( count == 0 )
NS_ENSURE_TRUE ( result , NS_ERROR_DOM_DATA_CLONE_ERR ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> GetHelper::ReleaseMainThreadObjects ( ) <NEW_LINE> { <NEW_LINE> mKeyRange = nullptr ; <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( mCloneReadInfo . mCloneBuffer ) ; <NEW_LINE> <END_VULN> ObjectStoreHelper::ReleaseMainThreadObjects ( ) ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> GetHelper::PackArgumentsForParentProcess ( ObjectStoreRequestParams & aParams ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( mKeyRange , "This should never be null ! " ) ;
( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) <NEW_LINE> { <NEW_LINE> check_here = ( neighbors [ j ] . row ) * in_what_stride + neighbors [ j ] . col + best_address ; <NEW_LINE> <START_VULN> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <NEW_LINE> <END_VULN> if ( thissad < bestsad ) <NEW_LINE> {
#ifdef PNG_READ_sRGB_SUPPORTED <NEW_LINE> else if ( chunk_name == png_sRGB ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_sRGB ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
return innerWindowID ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsJSUtils::ReportPendingException ( JSContext * aContext ) <NEW_LINE> { <NEW_LINE> if ( JS_IsExceptionPending ( aContext ) ) { <NEW_LINE> bool saved = JS_SaveFrameChain ( aContext ) ; <NEW_LINE> <START_VULN> JS_ReportPendingException ( aContext ) ; <NEW_LINE> <END_VULN> if ( saved ) { <NEW_LINE> JS_RestoreFrameChain ( aContext ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsJSUtils::CompileFunction ( JSContext * aCx ,
nsresult rv ; <NEW_LINE> if ( ! nsCRT::strcmp ( contentType , "text / html" ) ) { <NEW_LINE> nsCOMPtr < nsIDOMDocument > domDocument ; <NEW_LINE> rv = SetUpDocument ( DocumentFlavorHTML , getter_AddRefs ( domDocument ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsCOMPtr < nsIDocument > document = do_QueryInterface ( domDocument ) ; <NEW_LINE> <START_VULN> nsDependentString sourceBuffer ( str ) ; <NEW_LINE>rv = nsContentUtils::ParseDocumentHTML ( sourceBuffer , document , false ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <END_VULN> if ( nsContentUtils::IsSystemPrincipal ( mOriginalPrincipal ) ) { <NEW_LINE> document -> ForceEnableXULXBL ( ) ; <NEW_LINE> } <NEW_LINE> document -> SetBaseURI ( mBaseURI ) ; <NEW_LINE> document -> SetPrincipal ( mPrincipal ) ; <NEW_LINE> domDocument . forget ( aResult ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> NS_ConvertUTF16toUTF8 data ( str ) ; <NEW_LINE> nsCOMPtr < nsIInputStream > stream ;
union YYSTYPE <NEW_LINE> { <NEW_LINE> <START_VULN> #line 73 "re_grammar . y" <NEW_LINE> <END_VULN> int integer ; <NEW_LINE> uint32_t range ;
static const yytype_uint16 yyrline [ ] = <NEW_LINE> { <NEW_LINE> <START_VULN> 0 , 105 , 105 , 114 , 118 , 127 , 189 , 193 , 206 , 210 , <NEW_LINE>219 , 233 , 232 , 245 , 268 , 300 , 322 , 342 , 346 , 360 , <NEW_LINE>368 <NEW_LINE> <END_VULN> } ; <NEW_LINE> #endif
png_charp parameters [ 1 ] ; <NEW_LINE> } chunk_insert ; <NEW_LINE> <START_VULN> static int <NEW_LINE> <END_VULN> channels_of_type ( int color_type ) <NEW_LINE> { <NEW_LINE> if ( color_type & PNG_COLOR_MASK_PALETTE )
<START_VULN> if ( type == v8::ACCESS_GET && childFrame && ! host -> HasRealNamedProperty ( key -> ToString ( ) ) && name != nameOfProtoProperty ) <NEW_LINE> <END_VULN> return true ; <NEW_LINE> }
const struct macroblock_plane * const p = & x -> plane [ plane ] ; <NEW_LINE> const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <NEW_LINE> const scan_order * const scan_order = & vp9_default_scan_orders [ tx_size ] ; <NEW_LINE> <START_VULN> int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; <NEW_LINE>int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <NEW_LINE>int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <NEW_LINE> <END_VULN> uint16_t * const eob = & p -> eobs [ block ] ; <NEW_LINE> const int diff_stride = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ; <NEW_LINE> int i , j ;
gfxSkipCharsIterator iter ( provider . GetStart ( ) ) ; <NEW_LINE> iter . SetOriginalOffset ( offset + limitLength ) ; <NEW_LINE> transformedLength = iter . GetSkippedOffset ( ) - transformedOffset ; <NEW_LINE> } <NEW_LINE> uint32_t transformedLastBreak = 0 ; <NEW_LINE> bool usedHyphenation ; <NEW_LINE> gfxFloat trimmedWidth = 0 ; <NEW_LINE> gfxFloat availWidth = aAvailableWidth ; <NEW_LINE> <START_VULN> bool canTrimTrailingWhitespace = ! textStyle -> WhiteSpaceIsSignificant ( ) ; <NEW_LINE> <END_VULN> int32_t unusedOffset ; <NEW_LINE> gfxBreakPriority breakPriority ; <NEW_LINE> aLineLayout . GetLastOptionalBreakPosition ( & unusedOffset , & breakPriority ) ; <NEW_LINE> uint32_t transformedCharsFit = <NEW_LINE> mTextRun -> BreakAndMeasureText ( transformedOffset , transformedLength , <NEW_LINE> ( GetStateBits ( ) & TEXT_START_OF_LINE ) != 0 , <NEW_LINE> availWidth , <NEW_LINE> & provider , ! aLineLayout . LineIsBreakable ( ) ,
} else { <NEW_LINE> long fl ; <NEW_LINE> <START_VULN> char cmd [ 512 ] ; <NEW_LINE><NEW_LINE> <END_VULN> term_remove ( STI ) ;
const int offset [ ] = { 1 , mode_info_stride - 1 , 1 , - mode_info_stride - 1 } ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> const int shift_32_y [ ] = { 0 , 4 , 32 , 36 } ;
for ( conn_opt = conn_opts ; conn_opt -> keyword != NULL ; conn_opt ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' ) <NEW_LINE> <END_VULN> argcount ++ ; <NEW_LINE> }
} <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> SVGLength & imp = wrapper -> propertyReference ( ) ; <NEW_LINE> ExceptionCode ec = 0 ;
yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != '"' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 698 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ! var_hash ) return 0 ;
return ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( diff != StyleDifferenceLayout ) <NEW_LINE> <END_VULN> return ;
nsAutoString value ; <NEW_LINE> aOverlayNode -> GetAttr ( nameSpaceID , attr , value ) ; <NEW_LINE> if ( attr == nsGkAtoms::removeelement && <NEW_LINE> value . EqualsLiteral ( "true" ) ) { <NEW_LINE> <START_VULN> rv = RemoveElement ( aTargetNode -> GetParent ( ) , aTargetNode ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> rv = aTargetNode -> SetAttr ( nameSpaceID , attr , prefix , value , aNotify ) ; <NEW_LINE> if ( ! NS_FAILED ( rv ) && ! aNotify ) <NEW_LINE> rv = mDocument -> BroadcastAttributeChangeFromOverlay ( aTargetNode ,
class AutoFillQueryXmlParser : public AutoFillXmlParser { <NEW_LINE> public: <NEW_LINE> AutoFillQueryXmlParser ( std::vector < AutoFillFieldType > * field_types , <NEW_LINE> <START_VULN> UploadRequired * upload_required ) ; <NEW_LINE> <END_VULN> private:
static void numtostr ( js_State * J , const char * fmt , int w , double n ) <NEW_LINE> { <NEW_LINE> <START_VULN> char buf [ 32 ] , * e ; <NEW_LINE> <END_VULN> sprintf ( buf , fmt , w , n ) ; <NEW_LINE> e = strchr ( buf , 'e' ) ; <NEW_LINE> if ( e ) {
int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , <NEW_LINE> <START_VULN> const char * name , int rep_quick ) <NEW_LINE> <END_VULN> { <NEW_LINE> int got_error ; <NEW_LINE> uint i ;
char * result ; <NEW_LINE> if ( len <= 0 ) return NULL ; <NEW_LINE> result = ALLOC_N ( char , len ) ; <NEW_LINE> <START_VULN> memccpy ( result , ptr , 0 , len ) ; <NEW_LINE> <END_VULN> return result ; <NEW_LINE> }
return ERR_PTR ( - ENOMEM ) ; <NEW_LINE> if ( inode -> i_state & I_NEW ) { <NEW_LINE> <START_VULN> ret = isofs_read_inode ( inode ) ; <NEW_LINE> <END_VULN> if ( ret < 0 ) { <NEW_LINE> iget_failed ( inode ) ; <NEW_LINE> inode = ERR_PTR ( ret ) ;
toTransplant . infallibleAppend ( * wp -> value . unsafeGet ( ) ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> for ( Value * begin = toTransplant . begin ( ) , * end = toTransplant . end ( ) ; <NEW_LINE> begin != end ; ++ begin ) <NEW_LINE> { <NEW_LINE> if ( ! RemapWrapper ( cx , & begin -> toObject ( ) , newTarget ) ) <NEW_LINE> <START_VULN> return false ; <NEW_LINE> <END_VULN> } <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> JS_FRIEND_API ( bool ) <NEW_LINE> js::RecomputeWrappers ( JSContext * cx , const CompartmentFilter & sourceFilter , <NEW_LINE> const CompartmentFilter & targetFilter )
{ <NEW_LINE> RenderBlock::styleDidChange ( diff , oldStyle ) ; <NEW_LINE> <START_VULN> if ( oldStyle && oldStyle -> alignItems ( ) == ItemPositionStretch && diff == StyleDifferenceLayout ) { <NEW_LINE> <END_VULN> for ( RenderBox * child = firstChildBox ( ) ; child ; child = child -> nextSiblingBox ( ) ) {
int i , n ; <NEW_LINE> for ( i = 0 ; i < num_mixer_volumes ; i ++ ) { <NEW_LINE> <START_VULN> if ( strcmp ( name , mixer_vols [ i ] . name ) == 0 ) { <NEW_LINE> <END_VULN> if ( present ) <NEW_LINE> mixer_vols [ i ] . num = i ; <NEW_LINE> return mixer_vols [ i ] . levels ;
#ifdef AF_INET6 <NEW_LINE> case AF_INET6: <NEW_LINE> #endif <NEW_LINE> <START_VULN> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> default:
return false ; <NEW_LINE> return contentEditableValue . isEmpty ( ) || <NEW_LINE> <START_VULN> equalIgnoringCase ( contentEditableValue , "true" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool AXNodeObject::isTextControl ( ) const {
if ( FAILED ( result ) ) <NEW_LINE> { <NEW_LINE> ERR ( "Out of memory allocating a vertex buffer of size % lu . " , mBufferSize ) ; <NEW_LINE> } <NEW_LINE> mWritePosition = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> else if ( mWritePosition + requiredSpace > mBufferSize ) <NEW_LINE> <END_VULN> { <NEW_LINE> void * dummy ; <NEW_LINE> mIndexBuffer -> Lock ( 0 , 1 , & dummy , D3DLOCK_DISCARD ) ; <NEW_LINE> mIndexBuffer -> Unlock ( ) ; <NEW_LINE> mWritePosition = 0 ; <NEW_LINE> } <NEW_LINE> }
if ( ! IsSameOrAncestor ( window , mFocusedWindow ) ) <NEW_LINE> return NS_OK ; <NEW_LINE> <START_VULN> nsIContent * oldFocusedContent = mFocusedContent ; <NEW_LINE>mFocusedContent = nsnull ; <NEW_LINE> <END_VULN> if ( oldFocusedContent && oldFocusedContent -> IsInDoc ( ) ) { <NEW_LINE> NotifyFocusStateChange ( oldFocusedContent , <NEW_LINE> mFocusedWindow -> ShouldShowFocusRing ( ) , <NEW_LINE> false ) ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIDocShell > focusedDocShell = mFocusedWindow -> GetDocShell ( ) ;
proto_tree * padding_tree = proto_item_add_subtree ( ti , ett_csn1 ) ; <NEW_LINE> while ( remaining_bits_len > 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> guint8 bits_to_handle = remaining_bits_len + ( bit_offset % 8 ) ; <NEW_LINE> <END_VULN> if ( bits_to_handle > 32 ) <NEW_LINE> { <NEW_LINE> bits_to_handle = 32 - ( bit_offset % 8 ) ;
PortInfo * port = editPortInfo ( 1 ) ; <NEW_LINE> OMX_BUFFERHEADERTYPE * outHeader = port -> mBuffers . editItemAt ( 1 ) . mHeader ; <NEW_LINE> PVSetReferenceYUV ( mHandle , outHeader -> pBuffer ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> mFramesConfigured = true ; <NEW_LINE> }
} <NEW_LINE> static NPP <NEW_LINE> LookupNPP ( NPObject * npobj ) <NEW_LINE> { <NEW_LINE> if ( npobj -> _class == & nsJSObjWrapper::sJSObjWrapperNPClass ) { <NEW_LINE> <START_VULN> NS_ERROR ( "NPP requested for NPObject of class " <NEW_LINE>"nsJSObjWrapper::sJSObjWrapperNPClass ! \n" ) ; <NEW_LINE><NEW_LINE>return nsnull ; <NEW_LINE> <END_VULN> } <NEW_LINE> NPObjWrapperHashEntry * entry = static_cast < NPObjWrapperHashEntry * > <NEW_LINE> ( PL_DHashTableOperate ( & sNPObjWrappers , npobj , PL_DHASH_ADD ) ) ; <NEW_LINE> if ( PL_DHASH_ENTRY_IS_FREE ( entry ) ) { <NEW_LINE> return nsnull ; <NEW_LINE> }
file_name = make_file_name ( name , prog , namespace , instance ) ; <NEW_LINE> <START_VULN> log_file = fopen ( file_name , "a" ) ; <NEW_LINE> <END_VULN> if ( log_file ) { <NEW_LINE> int n = fileno ( log_file ) ; <NEW_LINE> fcntl ( n , F_SETFD , FD_CLOEXEC | fcntl ( n , F_GETFD ) ) ;
case FILE_LELDATE: <NEW_LINE> p -> l = ( int32_t ) <NEW_LINE> ( ( p -> hl [ 3 ] << 24 ) | ( p -> hl [ 2 ] << 16 ) | ( p -> hl [ 1 ] << 8 ) | ( p -> hl [ 0 ] ) ) ; <NEW_LINE> <START_VULN> cvt_32 ( p , m ) ; <NEW_LINE> <END_VULN> return 1 ; <NEW_LINE> case FILE_LEQUAD: <NEW_LINE> case FILE_LEQDATE:
<START_VULN> # if defined ( __clang__ ) <NEW_LINE> <END_VULN> # if ! defined ( PNG_USE_RESULT ) && __has_attribute ( __warn_unused_result__ ) <NEW_LINE> # define PNG_USE_RESULT __attribute__ ( ( __warn_unused_result__ ) )
we can write * / <NEW_LINE> vorbis_staticbook_pack ( testlist [ ptr ] , & write ) ; <NEW_LINE> fprintf ( stderr , "Codebook size % ld bytes . . . " , oggpack_bytes ( & write ) ) ; <NEW_LINE> for ( i = 0 ; i < TESTSIZE ; i += c . dim ) { <NEW_LINE> int best = _best ( & c , qv + i , 1 ) ; <NEW_LINE> vorbis_book_encodev ( & c , best , qv + i , & write ) ; <NEW_LINE> } <NEW_LINE> vorbis_book_clear ( & c ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> fprintf ( stderr , "OK . \n" ) ; <NEW_LINE> fprintf ( stderr , "\tunpacking / decoding % ld . . . " , ptr ) ; <NEW_LINE> oggpack_readinit ( & read , oggpack_get_buffer ( & write ) , oggpack_bytes ( & write ) ) ; <NEW_LINE> if ( vorbis_staticbook_unpack ( & read , & s ) ) { <NEW_LINE> fprintf ( stderr , "Error unpacking codebook . \n" ) ; <NEW_LINE> exit ( 1 ) ;
( cm -> interp_filter == best_mbmode . interp_filter ) || <NEW_LINE> ! is_inter_block ( & best_mbmode ) ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( cpi -> sf . adaptive_rd_thresh ) { <NEW_LINE>for ( mode_index = 0 ; mode_index < MAX_MODES ; ++ mode_index ) { <NEW_LINE>int * const fact = & cpi -> rd_thresh_freq_fact [ bsize ] [ mode_index ] ; <NEW_LINE><NEW_LINE>if ( mode_index == best_mode_index ) { <NEW_LINE> * fact - = ( * fact >> 3 ) ; <NEW_LINE> } else { <NEW_LINE> * fact = MIN ( * fact + RD_THRESH_INC , <NEW_LINE>cpi -> sf . adaptive_rd_thresh * RD_THRESH_MAX_FACT ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <END_VULN> * mbmi = best_mbmode ;
{ <NEW_LINE> INC_STATS ( "DOM . TestEventTarget . item" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestEventTarget * imp = V8TestEventTarget::toNative ( args . Holder ( ) ) ; <NEW_LINE> ExceptionCode ec = 0 ; <NEW_LINE> {
if ( aDest . IsPaused ( ) ) { <NEW_LINE> aDest . mPauseStart = now ; <NEW_LINE> } else { <NEW_LINE> aDest . mPauseStart = TimeStamp ( ) ; <NEW_LINE> } <NEW_LINE> aDest . mIterationDuration = TimeDuration::FromMilliseconds ( aSrc . GetDuration ( ) ) ; <NEW_LINE> <START_VULN> nsCSSKeyframesRule * rule = KeyframesRuleFor ( aDest . mName ) ; <NEW_LINE> <END_VULN> if ( ! rule ) { <NEW_LINE> continue ; <NEW_LINE> }
return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeContentView::GetCellText ( PRInt32 aRow , nsITreeColumn * aCol , nsAString & _retval ) <NEW_LINE> { <NEW_LINE> _retval . Truncate ( ) ; <NEW_LINE> <START_VULN> NS_ENSURE_ARG_POINTER ( aCol ) ; <NEW_LINE> <END_VULN> NS_PRECONDITION ( aRow >= 0 && aRow < PRInt32 ( mRows . Length ( ) ) , "bad row" ) ; <NEW_LINE> NS_PRECONDITION ( aCol , "bad column" ) ; <NEW_LINE> if ( aRow < 0 || aRow >= PRInt32 ( mRows . Length ( ) ) || ! aCol ) <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> Row * row = mRows [ aRow ] ;
#undef SVCRDMA_BACKCHANNEL_DEBUG <NEW_LINE> <START_VULN> int svc_rdma_handle_bc_reply ( struct rpc_xprt * xprt , struct rpcrdma_msg * rmsgp , <NEW_LINE> <END_VULN> struct xdr_buf * rcvbuf ) <NEW_LINE> { <NEW_LINE> struct rpcrdma_xprt * r_xprt = rpcx_to_rdmax ( xprt ) ;
nsIFrame * rootFrame = ps -> GetRootFrame ( ) ; <NEW_LINE> if ( ! rootFrame ) { <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> nsIFrame * ptFrame = nsLayoutUtils::GetFrameForPoint ( rootFrame , pt , <NEW_LINE> <START_VULN> nsLayoutUtils::IGNORE_PAINT_SUPPRESSION ) ; <NEW_LINE> <END_VULN> if ( ! ptFrame ) { <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> nsPoint adjustedPoint = pt - ptFrame -> GetOffsetTo ( rootFrame ) ;
if ( yych <= '9' ) goto yy91 ; <NEW_LINE> if ( yych != ' ; ' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 521 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> long id ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File: softmagic . c , v 1 . 188 2014 / 05 / 14 23:15:42 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include "magic . h"
TrapHandler ( JSContext * cx , JSScript * , jsbytecode * pc , jsval * rval , <NEW_LINE> jsval closure ) <NEW_LINE> { <NEW_LINE> JSString * str = JSVAL_TO_STRING ( closure ) ; <NEW_LINE> ScriptFrameIter iter ( cx ) ; <NEW_LINE> JS_ASSERT ( ! iter . done ( ) ) ; <NEW_LINE> <START_VULN> JSStackFrame * caller = Jsvalify ( iter . fp ( ) ) ; <NEW_LINE> <END_VULN> JSScript * script = iter . script ( ) ; <NEW_LINE> size_t length ; <NEW_LINE> const jschar * chars = JS_GetStringCharsAndLength ( cx , str , & length ) ; <NEW_LINE> if ( ! chars ) <NEW_LINE> return JSTRAP_ERROR ; <NEW_LINE> if ( ! JS_EvaluateUCInStackFrame ( cx , caller , chars , length ,
} <NEW_LINE> Symbol * LLVMState::symbol ( const std::string sym ) { <NEW_LINE> <START_VULN> return symbols_ . lookup ( sym ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> std::string LLVMState::symbol_debug_str ( const Symbol * sym ) {
serverTime = tempServerTime / PR_USEC_PER_SEC ; <NEW_LINE> } else { <NEW_LINE> serverTime = PR_Now ( ) / PR_USEC_PER_SEC ; <NEW_LINE> } <NEW_LINE> nsDependentCString cookieHeader ( aCookieHeader ) ; <NEW_LINE> while ( SetCookieInternal ( aHostURI , baseDomain , requireHostMatch , <NEW_LINE> <START_VULN> cookieStatus , cookieHeader , serverTime , aFromHttp ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsCookieService::NotifyRejected ( nsIURI * aHostURI ) <NEW_LINE> { <NEW_LINE> if ( mObserverService ) <NEW_LINE> mObserverService -> NotifyObservers ( aHostURI , "cookie - rejected" , nsnull ) ;
if ( ! code . typeBarriers ) { <NEW_LINE> <START_VULN> RootedScript script ( cx , script_ ) ; <NEW_LINE>AddPendingRecompile ( cx , script ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> size_t barrierCount = 0 ; <NEW_LINE> TypeBarrier * barrier = code . typeBarriers ; <NEW_LINE> while ( barrier ) { <NEW_LINE> if ( barrier -> target == target && ! barrier -> singleton ) { <NEW_LINE> if ( barrier -> type == type )
for ( size_t i = 0 ; i < numBlocks_ ; i ++ ) <NEW_LINE> blocks_ [ i ] . destroy ( ) ; <NEW_LINE> js_free ( blocks_ ) ; <NEW_LINE> js_delete ( previous_ ) ; <NEW_LINE> } <NEW_LINE> bool init ( size_t numBlocks ) { <NEW_LINE> numBlocks_ = numBlocks ; <NEW_LINE> <START_VULN> blocks_ = ( IonBlockCounts * ) js_calloc ( numBlocks * sizeof ( IonBlockCounts ) ) ; <NEW_LINE> <END_VULN> return blocks_ != NULL ; <NEW_LINE> } <NEW_LINE> size_t numBlocks ( ) const { <NEW_LINE> return numBlocks_ ; <NEW_LINE> } <NEW_LINE> IonBlockCounts & block ( size_t i ) {
} <NEW_LINE> NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc ( nedpool * p , size_t no , size_t size ) THROWSPEC <NEW_LINE> { <NEW_LINE> <START_VULN> unsigned flags = NEDMALLOC_FORCERESERVE ( p , 0 , no * size ) ; <END_VULN> <NEW_LINE> <START_VULN> return nedpmalloc2 ( p , size * no , 0 , M2_ZERO_MEMORY | flags ) ; <END_VULN> <NEW_LINE> <NEW_LINE> <NEW_LINE> <NEW_LINE> <NEW_LINE> <NEW_LINE> <NEW_LINE> } <NEW_LINE> NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedprealloc ( nedpool * p , void * mem , size_t size ) THROWSPEC <NEW_LINE> {
m_internalURL = BlobURL::createInternalURL ( ) ; <NEW_LINE> <START_VULN> ThreadableBlobRegistry::registerBlobURL ( m_internalURL , blobData . release ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> Blob::Blob ( PassOwnPtr < BlobData > blobData , long long size )
} ; <NEW_LINE> class nsDocShell final <NEW_LINE> : public nsDocLoader <NEW_LINE> <START_VULN> , public nsIDocShell_ESR38 <NEW_LINE> <END_VULN> , public nsIWebNavigation <NEW_LINE> , public nsIBaseWindow <NEW_LINE> , public nsIScrollable <NEW_LINE> , public nsITextScroll <NEW_LINE> , public nsIDocCharset <NEW_LINE> , public nsIContentViewerContainer <NEW_LINE> , public nsIRefreshURI <NEW_LINE> , public nsIWebProgressListener
efree ( stack ) ; <NEW_LINE> done: <NEW_LINE> <START_VULN> im -> alphaBlendingFlag = alphablending_bak ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void _gdImageFillTiled ( gdImagePtr im , int x , int y , int nc )
src . ShallowCopy ( dst ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> delete [ ] chapters_ ; <NEW_LINE> <END_VULN> chapters_ = chapters ; <NEW_LINE> chapters_size_ = size ;
void vp8_rd_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , <NEW_LINE> int recon_uvoffset , int * returnrate , <NEW_LINE> <START_VULN> int * returndistortion , int * returnintra ) <NEW_LINE> <END_VULN> { <NEW_LINE> BLOCK * b = & x -> block [ 0 ] ; <NEW_LINE> BLOCKD * d = & x -> e_mbd . block [ 0 ] ;
source_rectangle = size_rectangle ; <NEW_LINE> destination_rectangle = size_rectangle ; <NEW_LINE> base_address = 0xff ; <NEW_LINE> <START_VULN> row_bytes = ( unsigned short ) ( image -> columns | 0x8000 ) ; <NEW_LINE> <END_VULN> bounds . top = 0 ; <NEW_LINE> bounds . left = 0 ; <NEW_LINE> bounds . bottom = ( short ) image -> rows ;
{ <NEW_LINE> for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( tmp -> mbmi . mode == ZEROMV ) <NEW_LINE> <END_VULN> cpi -> zeromv_count ++ ; <NEW_LINE> tmp ++ ; <NEW_LINE> }
int colorMap [ gdMaxColors ] ; <NEW_LINE> int * stx , * sty ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( overflow2 ( sizeof ( int ) , srcW ) ) { <NEW_LINE> return ; <NEW_LINE> }
NS_ENSURE_TRUE ( window , NS_ERROR_FAILURE ) ; <NEW_LINE> nsIDocShell * docShell = window -> GetDocShell ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( docShell , NS_ERROR_FAILURE ) ; <NEW_LINE> nsCOMPtr < nsIPresShell > presShell = docShell -> GetPresShell ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( presShell , NS_ERROR_FAILURE ) ; <NEW_LINE> <START_VULN> nsCopySupport::FireClipboardEvent ( NS_COPY , presShell , nullptr ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsClipboardCommand::GetCommandStateParams ( const char * aCommandName , <NEW_LINE> nsICommandParams * aParams , nsISupports * aCommandContext ) <NEW_LINE> { <NEW_LINE> return NS_ERROR_NOT_IMPLEMENTED ;
if ( pv -> context -> extradata == NULL ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( pv -> parser == NULL || pv -> parser == NULL || <NEW_LINE> <END_VULN> pv -> parser -> parser -> split == NULL ) <NEW_LINE> { <NEW_LINE> return 0 ;
} <NEW_LINE> } else { <NEW_LINE> if ( state -> space ) ruby_xfree ( state -> space ) ; <NEW_LINE> <START_VULN> state -> space = strdup ( RSTRING_PTR ( space ) ) ; <NEW_LINE> <END_VULN> state -> space_len = len ; <NEW_LINE> } <NEW_LINE> return Qnil ;
if ( dl > max_dl ) <NEW_LINE> { <NEW_LINE> <START_VULN> png_warning ( png_ptr , "sPLT chunk too long" ) ; <NEW_LINE>return ; <NEW_LINE> <END_VULN> } <NEW_LINE> new_palette . nentries = ( png_int_32 ) ( data_length / entry_size ) ;
} <NEW_LINE> } <NEW_LINE> UnlockArena ( ) ; <NEW_LINE> } <NEW_LINE> { <NEW_LINE> PRUint32 sz = PR_MAX ( pool -> arenasize , nb ) ; <NEW_LINE> <START_VULN> sz += sizeof * a + pool -> mask ; <NEW_LINE>a = ( PLArena * ) PR_MALLOC ( sz ) ; <NEW_LINE> <END_VULN> if ( NULL != a ) { <NEW_LINE> a -> limit = ( PRUword ) a + sz ; <NEW_LINE> a -> base = a -> avail = ( PRUword ) PL_ARENA_ALIGN ( pool , a + 1 ) ; <NEW_LINE> PL_MAKE_MEM_NOACCESS ( ( void * ) a -> avail , a -> limit - a -> avail ) ; <NEW_LINE> rp = ( char * ) a -> avail ; <NEW_LINE> a -> avail += nb ;
if ( ! mHasSize ) { <NEW_LINE> mWantFullDecode = true ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> MutexAutoLock lock ( mDecodingMutex ) ; <NEW_LINE> <END_VULN> if ( mBytesDecoded > mSourceData . Length ( ) ) <NEW_LINE> return NS_OK ;
{ <NEW_LINE> OwnPtr < GIFImageDecoder > decoder = createDecoder ( ) ; <NEW_LINE> <START_VULN> RefPtr < SharedBuffer > data = readFile ( " / Source / web / tests / data / broken . gif" ) ; <NEW_LINE> <END_VULN> ASSERT_TRUE ( data . get ( ) ) ; <NEW_LINE> decoder -> setData ( data . get ( ) , true ) ;
static int nntp_hcache_namer ( const char * path , char * dest , size_t destlen ) <NEW_LINE> { <NEW_LINE> <START_VULN> return snprintf ( dest , destlen , " % s . hcache" , path ) ; <NEW_LINE> <END_VULN> }
#ifndef ColorInputType_h <NEW_LINE> #define ColorInputType_h <NEW_LINE> <START_VULN> #include "core / html / forms / BaseClickableWithKeyInputType . h" <NEW_LINE> <END_VULN> #include "core / html / forms / ColorChooserClient . h" <NEW_LINE> #include "core / html / forms / InputType . h" <NEW_LINE> namespace blink {
<START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 85 ) <NEW_LINE> <END_VULN>
register jpc_fix_t * dstptr ; <NEW_LINE> register int n ; <NEW_LINE> register int m ; <NEW_LINE> <START_VULN> int hstartcol ; <NEW_LINE> <END_VULN> if ( bufsize > QMFB_SPLITBUFSIZE ) {
const net::IPEndPoint & remote_address ) ; <NEW_LINE> void OnAcceptIncomingTcpConnection ( const IPC::Message & msg , <NEW_LINE> int listen_socket_id , <NEW_LINE> <START_VULN> net::IPEndPoint remote_address , <NEW_LINE> <END_VULN> int connected_socket_id ) ; <NEW_LINE> void OnSend ( const IPC::Message & msg , int socket_id , <NEW_LINE> const net::IPEndPoint & socket_address ,
ENTROPY_CONTEXT * tl ; <NEW_LINE> const int * bmode_costs ; <NEW_LINE> <START_VULN> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE> <END_VULN> ta = ( ENTROPY_CONTEXT * ) & t_above ; <NEW_LINE> tl = ( ENTROPY_CONTEXT * ) & t_left ;
const BigInt w = m_group . inverse_mod_order ( s ) ; <NEW_LINE> <START_VULN> const BigInt u1 = m_group . multiply_mod_order ( e , w ) ; <NEW_LINE> <END_VULN> const BigInt u2 = m_group . multiply_mod_order ( r , w ) ; <NEW_LINE> const PointGFp R = m_gy_mul . multi_exp ( u1 , u2 ) ;
DISALLOW_COPY_AND_ASSIGN ( DevToolsAgent ) ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
if ( opt_local_file ) <NEW_LINE> mysql_options ( mysql , MYSQL_OPT_LOCAL_INFILE , <NEW_LINE> ( char * ) & opt_local_file ) ; <NEW_LINE> <START_VULN> #ifdef HAVE_OPENSSL <NEW_LINE>if ( opt_use_ssl ) <NEW_LINE> { <NEW_LINE>mysql_ssl_set ( mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , <NEW_LINE>opt_ssl_capath , opt_ssl_cipher ) ; <NEW_LINE>mysql_options ( mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; <NEW_LINE>mysql_options ( mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; <NEW_LINE> } <NEW_LINE>mysql_options ( mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , <NEW_LINE> ( char * ) & opt_ssl_verify_server_cert ) ; <NEW_LINE>#endif <NEW_LINE> <END_VULN> if ( opt_protocol ) <NEW_LINE> mysql_options ( mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; <NEW_LINE> if ( opt_bind_addr )
<START_VULN> extern const char kIncognitoSwitch [ ] ; <NEW_LINE> <END_VULN>
} <NEW_LINE> emul: <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <NEW_LINE>1 , 0 , xcp , 0 ) ; <NEW_LINE> <END_VULN> MIPS_FPU_EMU_INC_STATS ( emulated ) ; <NEW_LINE> switch ( MIPSInst_OPCODE ( ir ) ) { <NEW_LINE> case ldc1_op: {
nPortIndex = buffer - m_inp_heap_ptr ; <NEW_LINE> DEBUG_PRINT_LOW ( "free_buffer on i / p port - Port idx % d" , nPortIndex ) ; <NEW_LINE> <START_VULN> if ( nPortIndex < drv_ctx . ip_buf . actualcount ) { <NEW_LINE> <END_VULN> BITMASK_CLEAR ( & m_inp_bm_count , nPortIndex ) ; <NEW_LINE> BITMASK_CLEAR ( & m_heap_inp_bm_count , nPortIndex ) ;
case FILE_BEQWDATE: <NEW_LINE> case FILE_LEQWDATE: <NEW_LINE> if ( file_printf ( ms , F ( ms , m , " % s" ) , <NEW_LINE> <START_VULN> file_fmttime ( p -> q , FILE_T_WINDOWS , tbuf ) ) == - 1 ) <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> t = ms -> offset + sizeof ( uint64_t ) ; <NEW_LINE> break ;
{ <NEW_LINE> nsAString::const_iterator fromBegin , fromEnd ; <NEW_LINE> nsAString::iterator toBegin ; <NEW_LINE> <START_VULN> aDest . SetLength ( aSource . Length ( ) ) ; <NEW_LINE> <END_VULN> CopyToUpperCase converter ( aDest . BeginWriting ( toBegin ) ) ; <NEW_LINE> copy_string ( aSource . BeginReading ( fromBegin ) , aSource . EndReading ( fromEnd ) , converter ) ; <NEW_LINE> }
return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 881 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy39: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych == ' + ' ) goto yy40 ;
if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "rs" , & mcryptind , & data , & data_len ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> ZEND_FETCH_RESOURCE ( pm , php_mcrypt * , & mcryptind , - 1 , "MCrypt" , le_mcrypt ) ; <NEW_LINE> PHP_MCRYPT_INIT_CHECK
ImageLoader::ImageLoader ( Element * element ) <NEW_LINE> : m_element ( element ) , <NEW_LINE> <START_VULN> m_derefElementTimer ( this , & ImageLoader::timerFired ) , <NEW_LINE> <END_VULN> m_hasPendingLoadEvent ( false ) , <NEW_LINE> m_hasPendingErrorEvent ( false ) , <NEW_LINE> m_imageComplete ( true ) ,
nsresult rv = aState . mChooseGotoList -> add ( gotoinstr ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsAutoPtr < txInstruction > instr ( gotoinstr . forget ( ) ) ; <NEW_LINE> rv = aState . addInstruction ( instr ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> txConditionalGoto * condGoto = <NEW_LINE> <START_VULN> static_cast < txConditionalGoto * > ( aState . popPtr ( ) ) ; <NEW_LINE> <END_VULN> rv = aState . addGotoTarget ( & condGoto -> mTarget ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> xsl:with - param
break ; <NEW_LINE> case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT: <NEW_LINE> <START_VULN> if ( state & PNG_FP_SAW_DOT ) <NEW_LINE> <END_VULN> png_fp_set ( state , PNG_FP_FRACTION | PNG_FP_SAW_DOT ) ; <NEW_LINE> png_fp_add ( state , type | PNG_FP_WAS_VALID ) ;
#ifdef PNG_READ_gAMA_SUPPORTED <NEW_LINE> else if ( png_ptr -> chunk_name == png_gAMA ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_gAMA ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
else { <NEW_LINE> res = VPX_CODEC_INVALID_PARAM ; <NEW_LINE> <START_VULN> for ( map = iface -> enc . cfg_maps ; map -> usage >= 0 ; map ++ ) { <NEW_LINE> <END_VULN> if ( map -> usage == ( int ) usage ) { <NEW_LINE> * cfg = map -> cfg ; <NEW_LINE> cfg -> g_usage = usage ;
samedtype = true ; <NEW_LINE> dtype = jas_image_cmptdtype ( dec -> image , 0 ) ; <NEW_LINE> <START_VULN> for ( i = 1 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <NEW_LINE> <END_VULN> if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) { <NEW_LINE> samedtype = false ; <NEW_LINE> break ;
top = itr + itr_size ; <NEW_LINE> result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , <NEW_LINE> le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) , <NEW_LINE> <START_VULN> USB_DT_SECURITY , ( void ** ) & secd ) ; <NEW_LINE> <END_VULN> if ( result == - 1 ) { <NEW_LINE> dev_warn ( dev , "BUG ? WUSB host has no security descriptors\n" ) ; <NEW_LINE> return 0 ;
udpdest . sin_addr . s_addr = htonl ( network | addr . station ) ; <NEW_LINE> } <NEW_LINE> ah . port = port ; <NEW_LINE> ah . cb = cb & 0x7f ; <NEW_LINE> ah . code = 2 ; <NEW_LINE> <START_VULN> ah . pad = 0 ; <NEW_LINE> <END_VULN> size = sizeof ( struct aunhdr ) ;
JS::DescribeStack ( JSContext * cx , unsigned maxFrames ) <NEW_LINE> { <NEW_LINE> Vector < FrameDescription > frames ( cx ) ; <NEW_LINE> for ( ScriptFrameIter i ( cx ) ; ! i . done ( ) ; ++ i ) { <NEW_LINE> FrameDescription desc ; <NEW_LINE> desc . script = i . script ( ) ; <NEW_LINE> desc . lineno = PCToLineNumber ( i . script ( ) , i . pc ( ) ) ; <NEW_LINE> <START_VULN> desc . fun = i . fp ( ) -> maybeFun ( ) ; <NEW_LINE> <END_VULN> if ( ! frames . append ( desc ) ) <NEW_LINE> return NULL ; <NEW_LINE> if ( frames . length ( ) == maxFrames ) <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> StackDescription * desc = js_new < StackDescription > ( ) ; <NEW_LINE> if ( ! desc )
if ( m_out_mem_ptr ) { <NEW_LINE> DEBUG_PRINT_LOW ( "Freeing the Output Memory" ) ; <NEW_LINE> for ( i = 0 ; i < drv_ctx . op_buf . actualcount ; i ++ ) { <NEW_LINE> <START_VULN> free_output_buffer ( & m_out_mem_ptr [ i ] ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef _ANDROID_ICS_ <NEW_LINE> memset ( & native_buffer , 0 , ( sizeof ( nativebuffer ) * MAX_NUM_INPUT_OUTPUT_BUFFERS ) ) ;
* result = mNPNIface -> posturlnotify ( mNPP , <NEW_LINE> NullableStringGet ( url ) , <NEW_LINE> NullableStringGet ( target ) , <NEW_LINE> buffer . Length ( ) , <NEW_LINE> NullableStringGet ( buffer ) , <NEW_LINE> file , actor ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! streamDestroyed ) { <NEW_LINE> <END_VULN> static_cast < StreamNotifyParent * > ( actor ) -> ClearDestructionFlag ( ) ; <NEW_LINE> if ( * result != NPERR_NO_ERROR ) <NEW_LINE> return PStreamNotifyParent::Send__delete__ ( actor , <NEW_LINE> NPERR_GENERIC_ERROR ) ; <NEW_LINE> } <NEW_LINE> return true ; <NEW_LINE> }
bool <NEW_LINE> JSRuntime::initSelfHosting ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( ! selfHostingGlobal_ ) ; <NEW_LINE> RootedObject savedGlobal ( cx , js::GetDefaultGlobalForContext ( cx ) ) ; <NEW_LINE> if ( ! ( selfHostingGlobal_ = JS_NewGlobalObject ( cx , & self_hosting_global_class , NULL ) ) ) <NEW_LINE> return false ; <NEW_LINE> JS_SetGlobalObject ( cx , selfHostingGlobal_ ) ; <NEW_LINE> <START_VULN> JSAutoCompartment ac ( cx , cx -> global ( ) ) ; <NEW_LINE> <END_VULN> Rooted < GlobalObject * > shg ( cx , & selfHostingGlobal_ -> as < GlobalObject > ( ) ) ; <NEW_LINE> if ( ! GlobalObject::initStandardClasses ( cx , shg ) ) <NEW_LINE> return false ;
#endif <NEW_LINE> virtual nsresult Close ( ) ; <NEW_LINE> virtual void Suspend ( bool aCloseImmediately ) ; <NEW_LINE> virtual void Resume ( ) ; <NEW_LINE> virtual already_AddRefed < nsIPrincipal > GetCurrentPrincipal ( ) ; <NEW_LINE> bool IsClosed ( ) const { return mCacheStream . IsClosed ( ) ; } <NEW_LINE> virtual bool CanClone ( ) ; <NEW_LINE> <START_VULN> virtual MediaResource * CloneData ( MediaDecoder * aDecoder ) ; <NEW_LINE> <END_VULN> void RecordStatisticsTo ( MediaChannelStatistics * aStatistics ) MOZ_OVERRIDE { <NEW_LINE> NS_ASSERTION ( aStatistics , "Statistics param cannot be null ! " ) ; <NEW_LINE> MutexAutoLock lock ( mLock ) ; <NEW_LINE> if ( ! mChannelStatistics ) { <NEW_LINE> mChannelStatistics = aStatistics ; <NEW_LINE> }
static bool childDoesNotAffectWidthOrFlexing ( RenderObject * child ) <NEW_LINE> { <NEW_LINE> <START_VULN> return child -> isPositioned ( ) || child -> style ( ) -> visibility ( ) == COLLAPSE ; <NEW_LINE> <END_VULN> } <NEW_LINE> void RenderDeprecatedFlexibleBox::styleWillChange ( StyleDifference diff , const RenderStyle * newStyle )
void <NEW_LINE> xmlParseMisc ( xmlParserCtxtPtr ctxt ) { <NEW_LINE> <START_VULN> while ( ( ( RAW == ' < ' ) && ( NXT ( 1 ) == ' ? ' ) ) || <NEW_LINE> ( CMP4 ( CUR_PTR , ' < ' , ' ! ' , ' - ' , ' - ' ) ) || <NEW_LINE>IS_BLANK_CH ( CUR ) ) { <NEW_LINE> <END_VULN> if ( ( RAW == ' < ' ) && ( NXT ( 1 ) == ' ? ' ) ) { <NEW_LINE> xmlParsePI ( ctxt ) ; <NEW_LINE> } else if ( IS_BLANK_CH ( CUR ) ) {
virtual void DidManualLoadFail ( ) ; <NEW_LINE> virtual void InstallMissingPlugin ( ) ; <NEW_LINE> virtual webkit_glue::WebPluginResourceClient * CreateResourceClient ( <NEW_LINE> <START_VULN> unsigned long resource_id , <NEW_LINE>const GURL & url , <NEW_LINE>bool notify_needed , <NEW_LINE>intptr_t notify_data , <NEW_LINE>intptr_t existing_stream ) ; <NEW_LINE> <END_VULN> CommandBufferProxy * CreateCommandBuffer ( ) ;
<START_VULN> if ( ( length > 0 ) || ( png_ptr -> mode & PNG_HAVE_CHUNK_AFTER_IDAT ) ) <NEW_LINE> <END_VULN> png_benign_error ( png_ptr , "Too many IDATs found" ) ; <NEW_LINE> png_crc_finish ( png_ptr , length ) ;
#define PROGNAME "rpng - x" <NEW_LINE> #define LONGNAME "Simple PNG Viewer for X" <NEW_LINE> <START_VULN> #define VERSION "2 . 01 of 16 March 2008" <NEW_LINE> <END_VULN> #define RESNAME "rpng" <NEW_LINE> #define RESCLASS "Rpng"
double * blue_Z ) <NEW_LINE> { <NEW_LINE> if ( png_ptr != NULL && info_ptr != NULL && <NEW_LINE> <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_debug1 ( 1 , "in % s retrieval function" , "cHRM_XYZ ( float ) " ) ;
m_pageMap . set ( pageID , webPage ) ; <NEW_LINE> globalPageMap ( ) . set ( pageID , webPage ) ; <NEW_LINE> #if PLATFORM ( MAC ) <NEW_LINE> <START_VULN> if ( pageIsProcessSuppressible ( webPage ) ) ; <NEW_LINE> <END_VULN> m_processSuppressiblePages . add ( pageID ) ; <NEW_LINE> updateProcessSuppressionState ( ) ; <NEW_LINE> #endif
if ( pc -> refresh_entropy_probs == 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ; <NEW_LINE> <END_VULN> pbi -> independent_partitions = prev_independent_partitions ; <NEW_LINE> }
int pixel_skip ; <NEW_LINE> int pixel_countdown ; <NEW_LINE> unsigned char * pixels ; <NEW_LINE> <START_VULN> int pixel_limit ; <NEW_LINE> <END_VULN> s -> frame . reference = 1 ; <NEW_LINE> s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;
JSSharedWorkerConstructor * jsConstructor = jsCast < JSSharedWorkerConstructor * > ( exec -> callee ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> UString scriptURL = exec -> argument ( 0 ) . toString ( exec ) -> value ( exec ) ; <NEW_LINE> UString name ;
interlace_type < INTERLACE_LAST ; ++ interlace_type ) <NEW_LINE> { <NEW_LINE> standard_test ( & pm -> this , FILEID ( colour_type , DEPTH ( bdlo ) , 0 , <NEW_LINE> <START_VULN> interlace_type , 0 , 0 , 0 ) , 0 , pm -> use_update_info ) ; <NEW_LINE> <END_VULN> if ( fail ( pm ) ) <NEW_LINE> return 0 ;
<START_VULN> if ( transforms & PNG_TRANSFORM_PACKSWAP ) <NEW_LINE> <END_VULN> #ifdef PNG_READ_PACKSWAP_SUPPORTED <NEW_LINE> png_set_packswap ( png_ptr ) ; <NEW_LINE> #else
l = dh -> length ? dh -> length : BN_num_bits ( dh -> p ) - 1 ; <NEW_LINE> <START_VULN> do <NEW_LINE> { <NEW_LINE>if ( ! BN_rand ( priv_key , l , 0 , 0 ) ) goto err ; <NEW_LINE>if ( ! ENGINE_get_DH ( dh -> engine ) -> bn_mod_exp ( dh , pub_key , dh -> g , <NEW_LINE>priv_key , dh -> p , ctx , mont ) ) goto err ; <NEW_LINE> } <NEW_LINE>while ( BN_is_one ( priv_key ) ) ; <NEW_LINE> <END_VULN> dh -> pub_key = pub_key ; <NEW_LINE> dh -> priv_key = priv_key ;
} <NEW_LINE> <START_VULN> static inline realpath_cache_bucket * realpath_cache_find ( const char * path , int path_len , time_t t ) <NEW_LINE> <END_VULN> { <NEW_LINE> zend_ulong key = realpath_cache_key ( path , path_len ) ; <NEW_LINE> zend_ulong n = key % ( sizeof ( CWDG ( realpath_cache ) ) / sizeof ( CWDG ( realpath_cache ) [ 0 ] ) ) ;
shader -> DecrementAttachCount ( ) ; <NEW_LINE> return PR_TRUE ; <NEW_LINE> } <NEW_LINE> return PR_FALSE ; <NEW_LINE> } <NEW_LINE> PRBool HasAttachedShaderOfType ( GLenum shaderType ) { <NEW_LINE> for ( PRUint32 i = 0 ; i < mAttachedShaders . Length ( ) ; ++ i ) { <NEW_LINE> <START_VULN> if ( mAttachedShaders [ i ] -> ShaderType ( ) == shaderType ) { <NEW_LINE> <END_VULN> return PR_TRUE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return PR_FALSE ; <NEW_LINE> } <NEW_LINE> PRBool HasBothShaderTypesAttached ( ) { <NEW_LINE> return
png_debug1 ( 1 , "in % s retrieval function" , "gAMA ( float ) " ) ; <NEW_LINE> if ( png_ptr != NULL && info_ptr != NULL && <NEW_LINE> <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_GAMMA ) && <NEW_LINE> <END_VULN> file_gamma != NULL ) <NEW_LINE> { <NEW_LINE> * file_gamma = png_float ( png_ptr , info_ptr -> colorspace . gamma ,
SkImageInfo info = SkImageInfo::Make ( <NEW_LINE> parsedOptions . cropRect . width ( ) , parsedOptions . cropRect . height ( ) , <NEW_LINE> kN32_SkColorType , kUnpremul_SkAlphaType ) ; <NEW_LINE> <START_VULN> size_t bytesPerPixel = static_cast < size_t > ( info . bytesPerPixel ( ) ) ; <NEW_LINE>size_t srcPixelBytesPerRow = bytesPerPixel * data -> size ( ) . width ( ) ; <NEW_LINE>size_t dstPixelBytesPerRow = bytesPerPixel * parsedOptions . cropRect . width ( ) ; <NEW_LINE> <END_VULN> sk_sp < SkImage > skImage ; <NEW_LINE> if ( parsedOptions . cropRect == IntRect ( IntPoint ( ) , data -> size ( ) ) ) { <NEW_LINE> swizzleImageData ( srcAddr , data -> size ( ) . height ( ) , srcPixelBytesPerRow ,
<START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> typedef uint32_t MojoPlatformSharedBufferHandleFlags ;
int32_t i32 ; <NEW_LINE> uint32_t u32 ; <NEW_LINE> JSWhyMagic why ; <NEW_LINE> } payload ; <NEW_LINE> } s ; <NEW_LINE> double asDouble ; <NEW_LINE> void * asPtr ; <NEW_LINE> size_t asWord ; <NEW_LINE> <START_VULN> } jsval_layout ; <NEW_LINE> <END_VULN> # endif <NEW_LINE> #endif <NEW_LINE> JS_STATIC_ASSERT ( sizeof ( jsval_layout ) == 8 ) ; <NEW_LINE> #if JS_BITS_PER_WORD == 32
cur = elem -> fragment ; <NEW_LINE> elem -> fragment = ( xmlDocPtr ) cur -> next ; <NEW_LINE> <START_VULN> if ( cur -> psvi == XSLT_RVT_VARIABLE ) { <NEW_LINE>xsltReleaseRVT ( ( xsltTransformContextPtr ) elem -> context , <NEW_LINE>cur ) ; <NEW_LINE> } else if ( cur -> psvi != XSLT_RVT_FUNC_RESULT ) { <NEW_LINE> <END_VULN> xmlGenericError ( xmlGenericErrorContext , <NEW_LINE> "xsltFreeStackElem: Unexpected RVT flag % p\n" , <NEW_LINE> cur -> psvi ) ;
GLenum error = gl -> GetAndClearError ( ) ; <NEW_LINE> if ( error != LOCAL_GL_NO_ERROR ) { <NEW_LINE> LogMessage ( "GL error 0x % x occurred during OpenGL context initialization , before WebGL initialization ! " , error ) ; <NEW_LINE> return PR_FALSE ; <NEW_LINE> } <NEW_LINE> mActiveTexture = 0 ; <NEW_LINE> <START_VULN> mSynthesizedGLError = LOCAL_GL_NO_ERROR ; <NEW_LINE> <END_VULN> mAttribBuffers . Clear ( ) ; <NEW_LINE> mUniformTextures . Clear ( ) ; <NEW_LINE> mBound2DTextures . Clear ( ) ; <NEW_LINE> mBoundCubeMapTextures . Clear ( ) ; <NEW_LINE> mBoundArrayBuffer = nsnull ;
} <NEW_LINE> static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx , <NEW_LINE> <START_VULN> int ctr_id , <NEW_LINE>va_list args ) <NEW_LINE> <END_VULN> { <NEW_LINE> int update = va_arg ( args , int ) ; <NEW_LINE> vp8_update_reference ( ctx -> cpi , update ) ;
} <NEW_LINE> nsresult <NEW_LINE> nsJSContext::SetProperty ( JSObject * aTarget , const char * aPropName , nsISupports * aArgs ) <NEW_LINE> { <NEW_LINE> PRUint32 argc ; <NEW_LINE> jsval * argv = nsnull ; <NEW_LINE> <START_VULN> JSAutoRequest ar ( mContext ) ; <NEW_LINE> <END_VULN> Maybe < nsRootedJSValueArray > tempStorage ; <NEW_LINE> nsresult rv = <NEW_LINE> ConvertSupportsTojsvals ( aArgs , GetNativeGlobal ( ) , & argc , & argv , tempStorage ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> jsval vargs ;
auto b = c . read < char > ( ) ; <NEW_LINE> if ( b == '\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE ) { <NEW_LINE> return i ; <NEW_LINE> <START_VULN> } else if ( terminatorType_ != TerminatorType::NEWLINE && <NEW_LINE>b == '\r' && ! c . isAtEnd ( ) && c . read < char > ( ) == '\n' ) { <NEW_LINE> <END_VULN> return i ; <NEW_LINE> } <NEW_LINE> }
DCHECK_EQ ( base_ . GetDocument ( ) , other . GetDocument ( ) ) << * this << ' ' << other ; <NEW_LINE> return base_ == other . base_ && extent_ == other . extent_ && <NEW_LINE> affinity_ == other . affinity_ && <NEW_LINE> <START_VULN> is_directional_ == other . is_directional_ && <NEW_LINE>is_handle_visible_ == other . is_handle_visible_ ; <NEW_LINE> <END_VULN> } <NEW_LINE> template < typename Strategy >
int data ; <NEW_LINE> unsigned int qxdm_data [ 6 ] ; <NEW_LINE> const char * deactData [ 1 ] = { "1" } ; <NEW_LINE> <START_VULN> char * actData [ 1 ] ; <NEW_LINE> <END_VULN> RIL_Dial dialData ; <NEW_LINE> int hangupData [ 1 ] = { 1 } ; <NEW_LINE> int number ; <NEW_LINE> char ** args ; <NEW_LINE> RIL_SOCKET_ID socket_id = RIL_SOCKET_1 ; <NEW_LINE> int sim_id = 0 ; <NEW_LINE> RLOGI ( "debugCallback for socket % s" , rilSocketIdToString ( socket_id ) ) ;
{ <NEW_LINE> struct n_tty_data * ldata = tty -> disc_data ; <NEW_LINE> <START_VULN> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <NEW_LINE> <END_VULN> bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ; <NEW_LINE> ldata -> line_start = ldata -> read_tail ; <NEW_LINE> if ( ! L_ICANON ( tty ) || ! read_cnt ( ldata ) ) {
case ION: <NEW_LINE> #ifdef JS_ION <NEW_LINE> return ionInlineFrames_ . snapshotIterator ( ) . slots ( ) - ionInlineFrames_ . script ( ) -> nfixed ; <NEW_LINE> #else <NEW_LINE> break ; <NEW_LINE> #endif <NEW_LINE> case SCRIPTED: <NEW_LINE> JS_ASSERT ( maybecx_ ) ; <NEW_LINE> <START_VULN> JS_ASSERT ( maybecx_ -> regs ( ) . spForStackDepth ( 0 ) == fp ( ) -> base ( ) ) ; <NEW_LINE>return maybecx_ -> regs ( ) . sp - fp ( ) -> base ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_NOT_REACHED ( "Unexpected state" ) ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> Value <NEW_LINE> StackIter::frameSlotValue ( size_t index ) const <NEW_LINE> {
break ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( pCmdData == NULL || <NEW_LINE>cmdSize != 2 * sizeof ( uint32_t ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Effect_command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_SET_VOLUME: ERROR" ) ; <NEW_LINE> return - EINVAL ;
u_char ar_tha [ ] ; <NEW_LINE> u_char ar_tpa [ ] ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> #define ar_sha ( ap ) ( ( ( const u_char * ) ( ( ap ) + 1 ) ) + 0 ) <NEW_LINE> <END_VULN> #define ar_spa ( ap ) ( ( ( const u_char * ) ( ( ap ) + 1 ) ) + ( ap ) -> ar_hln ) <NEW_LINE> #define ar_tha ( ap ) ( ( ( const u_char * ) ( ( ap ) + 1 ) ) + ( ap ) -> ar_hln + ( ap ) -> ar_pln ) <NEW_LINE> #define ar_tpa ( ap ) ( ( ( const u_char * ) ( ( ap ) + 1 ) ) + 2 * ( ap ) -> ar_hln + ( ap ) -> ar_pln )
spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> zend_class_entry * ce = spl_ce_SplFileInfo ; <NEW_LINE> zend_error_handling error_handling ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ; <NEW_LINE> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , " | C" , & ce ) == SUCCESS ) {
Define SIXEL pixels . <NEW_LINE> output = sixel_output_create ( image ) ; <NEW_LINE> <START_VULN> sixel_pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns * image -> rows , 1 ) ; <NEW_LINE> <END_VULN> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) <NEW_LINE> { <NEW_LINE> ( void ) GetVirtualPixels ( image , 0 , y , image -> columns , 1 , exception ) ;
offset += relativePositionOffset ( ) ; <NEW_LINE> if ( ! isInline ( ) || isReplaced ( ) ) { <NEW_LINE> <START_VULN> if ( ! style ( ) -> isPositioned ( ) && o -> hasColumns ( ) ) { <NEW_LINE> <END_VULN> RenderBlock * block = toRenderBlock ( o ) ; <NEW_LINE> LayoutRect columnRect ( frameRect ( ) ) ; <NEW_LINE> block -> adjustStartEdgeForWritingModeIncludingColumns ( columnRect ) ;
m_pos += 8 ; <NEW_LINE> } while ( op < oe ) ; <NEW_LINE> op = oe ; <NEW_LINE> <START_VULN> if ( HAVE_IP ( 6 ) ) { <NEW_LINE> <END_VULN> state = next ; <NEW_LINE> COPY4 ( op , ip ) ; <NEW_LINE> op += next ;
generatedSpecializedNative . flags = FAIL_STATUS | ( ( mode == JSOP_NEW ) <NEW_LINE> ? JSTN_CONSTRUCTOR <NEW_LINE> : JSTN_UNBOX_AFTER ) ; <NEW_LINE> generatedSpecializedNative . prefix = NULL ; <NEW_LINE> generatedSpecializedNative . argtypes = NULL ; <NEW_LINE> <START_VULN> JSRecordingStatus status ; <NEW_LINE>if ( ( status = emitNativeCall ( & generatedSpecializedNative , argc , args ) ) != JSRS_CONTINUE ) <NEW_LINE>return status ; <NEW_LINE><NEW_LINE><NEW_LINE>lir -> insStorei ( INS_NULL ( ) , cx_ins , offsetof ( JSContext , nativeVp ) ) ; <NEW_LINE>return JSRS_CONTINUE ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_REQUIRES_STACK JSRecordingStatus <NEW_LINE> TraceRecorder::functionCall ( uintN argc , JSOp mode ) <NEW_LINE> { <NEW_LINE> jsval & fval = stackval ( 0 - ( 2 + argc ) ) ; <NEW_LINE> JS_ASSERT ( & fval >= StackBase ( cx -> fp ) ) ;
uint32_t mBufferingWait ; <NEW_LINE> int64_t mLowDataThresholdUsecs ; <NEW_LINE> uint32_t mAmpleVideoFrames ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> bool mAudioCaptured ; <NEW_LINE> bool mTransportSeekable ;
} else if ( originIsChrome && ! targetIsChrome && xrayType == NotXray ) { <NEW_LINE> wrapper = & ChromeObjectWrapper::singleton ; <NEW_LINE> } else if ( IsComponentsObject ( obj ) && ! AccessCheck::isChrome ( target ) ) { <NEW_LINE> wrapper = & FilteringWrapper < CrossCompartmentSecurityWrapper , <NEW_LINE> ComponentsObjectPolicy > ::singleton ; <NEW_LINE> <START_VULN> } else if ( AccessCheck::needsSystemOnlyWrapper ( obj ) && ! AccessCheck::isChrome ( target ) ) { <NEW_LINE><NEW_LINE>if ( ! AccessCheck::subsumes ( target , origin ) ) { <NEW_LINE>JS_ReportError ( cx , "Don't expose cross - origin NAC" ) ; <NEW_LINE>return nullptr ; <NEW_LINE> } <NEW_LINE> <END_VULN> wrapper = & FilteringWrapper < CrossCompartmentSecurityWrapper , <NEW_LINE> OnlyIfSubjectIsSystem > ::singleton ; <NEW_LINE> }
scoped_refptr < base::SingleThreadTaskRunner > control_after_wakeup_task_runner_ ; <NEW_LINE> scoped_refptr < base::SingleThreadTaskRunner > default_task_runner_ ; <NEW_LINE> <START_VULN> scoped_ptr < TimeSource > time_source_ ; <NEW_LINE> <END_VULN> const char * tracing_category_ ; <NEW_LINE> const char * disabled_by_default_tracing_category_ ;
break ; <NEW_LINE> } <NEW_LINE> <START_VULN> assert ( cluster_off >= 0 ) ; <NEW_LINE> <END_VULN> long long pos_ ; <NEW_LINE> long len_ ;
continue ; <NEW_LINE> thissad = vfp -> sdf ( what -> buf , what -> stride , <NEW_LINE> get_buf_from_mv ( in_what , & this_mv ) , <NEW_LINE> <START_VULN> in_what -> stride , bestsad ) ; <NEW_LINE> <END_VULN> CHECK_BETTER <NEW_LINE> } <NEW_LINE> }
JSAutoRequest req ( cx ) ; <NEW_LINE> callingScope = JS_GetGlobalForScopeChain ( cx ) ; <NEW_LINE> if ( ! callingScope ) { <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> bool isChrome ; <NEW_LINE>nsresult rv = XPCWrapper::GetSecurityManager ( ) -> IsSystemPrincipal ( prin , & isChrome ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE>nsRefPtr < ContextHolder > sandcx = new ContextHolder ( cx , sandbox , isChrome ) ; <NEW_LINE> <END_VULN> if ( ! sandcx || ! sandcx -> GetJSContext ( ) ) { <NEW_LINE> JS_ReportError ( cx , "Can't prepare context for evalInSandbox" ) ; <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE> if ( jsVersion != JSVERSION_DEFAULT ) <NEW_LINE> JS_SetVersion ( sandcx -> GetJSContext ( ) , jsVersion ) ;
cfg -> debug_file = ( FILE * ) - 1 ; <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> <START_VULN> struct stat st ; <NEW_LINE>FILE * file ; <NEW_LINE>if ( lstat ( filename , & st ) == 0 ) { <NEW_LINE>if ( S_ISREG ( st . st_mode ) ) { <NEW_LINE>file = fopen ( filename , "a" ) ; <NEW_LINE>if ( file != NULL ) { <NEW_LINE>cfg -> debug_file = file ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
case BODY_CHUNK: <NEW_LINE> case BODY_CHUNK_PART: <NEW_LINE> case BODY_CHUNK_EXT: <NEW_LINE> <START_VULN> case BODY_CHUNK_END: { <NEW_LINE> <END_VULN> rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ;
int retcode = 0 ; <NEW_LINE> unsigned long insn ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <NEW_LINE> <END_VULN> #ifdef DEBUG_MATHEMU <NEW_LINE> printk ( "In do_mathemu ( ) . . . pc is % 08lx\n" , regs -> pc ) ;
} <NEW_LINE> #endif <NEW_LINE> static void <NEW_LINE> script_finalize ( JSContext * cx , JSObject * obj ) <NEW_LINE> { <NEW_LINE> JSScript * script = ( JSScript * ) obj -> getPrivate ( ) ; <NEW_LINE> if ( script ) <NEW_LINE> <START_VULN> js_DestroyScript ( cx , script ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void <NEW_LINE> script_trace ( JSTracer * trc , JSObject * obj ) <NEW_LINE> { <NEW_LINE> JSScript * script = ( JSScript * ) obj -> getPrivate ( ) ; <NEW_LINE> if ( script ) <NEW_LINE> js_TraceScript ( trc , script ) ; <NEW_LINE> }
attrhdrlen = 1 + 1 ; <NEW_LINE> break ; <NEW_LINE> <START_VULN> #if ENABLE_BGP_VNC <NEW_LINE> <END_VULN> case BGP_ATTR_VNC: <NEW_LINE> attrname = "VNC" ; <NEW_LINE> subtlvs = attr -> vnc_subtlvs ;
} <NEW_LINE> } <NEW_LINE> mDecodeThreadIdle = true ; <NEW_LINE> LOG ( PR_LOG_DEBUG , ( " % p Decode thread finished" , mDecoder . get ( ) ) ) ; <NEW_LINE> } <NEW_LINE> void MediaDecoderStateMachine::SendStreamAudio ( AudioData * aAudio , <NEW_LINE> <START_VULN> DecodedStreamData * aStream , <NEW_LINE>AudioSegment * aOutput ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ASSERTION ( OnDecodeThread ( ) , "Should be on decode thread . " ) ; <NEW_LINE> mDecoder -> GetReentrantMonitor ( ) . AssertCurrentThreadIn ( ) ; <NEW_LINE> if ( aAudio -> mTime <= aStream -> mLastAudioPacketTime ) { <NEW_LINE> return ; <NEW_LINE> }
if ( status != CL_SUCCESS ) <NEW_LINE> { <NEW_LINE> hb_log ( "OpenCL: hb_generat_bin_from_kernel_source: clGetProgramInfo for CL_PROGRAM_BINARIES failed" ) ; <NEW_LINE> <START_VULN> return 0 ; <NEW_LINE> <END_VULN> }
if ( row == 0 ) { <NEW_LINE> gd_error ( "gd - jpeg: error: unable to allocate JPEG row structure: gdCalloc returns NULL\n" ) ; <NEW_LINE> jpeg_destroy_compress ( & cinfo ) ; <NEW_LINE> <START_VULN> return ; <NEW_LINE> <END_VULN> } <NEW_LINE> rowptr [ 0 ] = row ;
vpx_decrypt_cb decrypt_cb , <NEW_LINE> void * decrypt_state ) { <NEW_LINE> int intra_only_flag = 0 ; <NEW_LINE> <START_VULN> uint8_t clear_buffer [ 9 ] ; <NEW_LINE> <END_VULN> if ( data + data_sz <= data ) <NEW_LINE> return VPX_CODEC_INVALID_PARAM ;
<START_VULN> explicit ScopedGenericObj ( C p = NULL ) : obj_ ( p ) { } <NEW_LINE> <END_VULN> ~ ScopedGenericObj ( ) {
} <NEW_LINE> pred_exists = 1 ; <NEW_LINE> if ( switchable_filter_index == 0 && <NEW_LINE> <START_VULN> cpi -> sf . use_rd_breakout && <NEW_LINE> <END_VULN> best_rd < INT64_MAX ) { <NEW_LINE> if ( tmp_best_rdu / 2 > best_rd ) {
NULL , <NEW_LINE> NULL , <NEW_LINE> NULL , <NEW_LINE> proxy_TraceObject , <NEW_LINE> { <NEW_LINE> NULL , <NEW_LINE> NULL , <NEW_LINE> proxy_innerObject , <NEW_LINE> <START_VULN> NULL <NEW_LINE> <END_VULN> } , <NEW_LINE> { <NEW_LINE> proxy_LookupGeneric , <NEW_LINE> proxy_LookupProperty , <NEW_LINE> proxy_LookupElement , <NEW_LINE> proxy_LookupSpecial , <NEW_LINE> proxy_DefineGeneric , <NEW_LINE> proxy_DefineProperty ,
case NLPID_CLNP: <NEW_LINE> case NLPID_ESIS: <NEW_LINE> case NLPID_ISIS: <NEW_LINE> <START_VULN> isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case NLPID_SNAP:
} ; <NEW_LINE> <START_VULN> const interp_kernel vp9_filteredinterp_filters625 [ ( 1 << SUBPEL_BITS ) ] = { <NEW_LINE> <END_VULN> { - 1 , - 8 , 33 , 80 , 33 , - 8 , - 1 , 0 } , <NEW_LINE> { - 1 , - 8 , 30 , 80 , 35 , - 8 , - 1 , 1 } , <NEW_LINE> { - 1 , - 8 , 28 , 80 , 37 , - 7 , - 2 , 1 } ,
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - <NEW_LINE> <START_VULN> Copyright ( c ) 1998 - 2007 Greg Roelofs . All rights reserved . <NEW_LINE> <END_VULN> This software is provided "as is , " without warranty of any kind , <NEW_LINE> express or implied . In no event shall the author or contributors
void AuthorizeAllPlugins ( int render_process_id ) ; <NEW_LINE> <START_VULN> virtual bool IsPluginEnabled ( <NEW_LINE> <END_VULN> int render_process_id , <NEW_LINE> int render_view_id , <NEW_LINE> const void * context ,
void addCopy ( const LowerCaseString & key , const std::string & value ) override ; <NEW_LINE> void setReference ( const LowerCaseString & key , const std::string & value ) override ; <NEW_LINE> void setReferenceKey ( const LowerCaseString & key , const std::string & value ) override ; <NEW_LINE> <START_VULN> uint64_t byteSize ( ) const override ; <NEW_LINE> <END_VULN> const HeaderEntry * get ( const LowerCaseString & key ) const override ; <NEW_LINE> HeaderEntry * get ( const LowerCaseString & key ) override ; <NEW_LINE> void iterate ( ConstIterateCb cb , void * context ) const override ;
balloon_stats . schedule_delay = 1 ; <NEW_LINE> balloon_stats . max_schedule_delay = 32 ; <NEW_LINE> balloon_stats . retry_count = 1 ; <NEW_LINE> <START_VULN> balloon_stats . max_retry_count = RETRY_UNLIMITED ; <NEW_LINE> <END_VULN> #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG <NEW_LINE> set_online_page_callback ( & xen_online_page ) ;
fstat ( fd , & sbuf ) ; <NEW_LINE> if ( sbuf . st_size >= pCur -> nAlloc ) { <NEW_LINE> <START_VULN> int nNew = sbuf . st_size * 2 ; <NEW_LINE> <END_VULN> char * zNew ; <NEW_LINE> if ( nNew < 1024 ) nNew = 1024 ;
* <NEW_LINE> <START_VULN> void impeg2d_dec_p_mb_params ( dec_state_t * ps_dec ) <NEW_LINE> <END_VULN> { <NEW_LINE> stream_t * ps_stream = & ps_dec -> s_bit_stream ; <NEW_LINE> UWORD16 u2_mb_addr_incr ;
#endif <NEW_LINE> } <NEW_LINE> nsPluginInstanceOwner:: ~ nsPluginInstanceOwner ( ) <NEW_LINE> { <NEW_LINE> int32_t cnt ; <NEW_LINE> if ( mWaitingForPaint ) { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>nsCOMPtr < nsIRunnable > event = new AsyncPaintWaitEvent ( mContent , true ) ; <NEW_LINE>NS_DispatchToMainThread ( event ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> mObjectFrame = nullptr ; <NEW_LINE> for ( cnt = 0 ; cnt < ( mNumCachedAttrs + 1 + mNumCachedParams ) ; cnt ++ ) { <NEW_LINE> if ( mCachedAttrParamNames && mCachedAttrParamNames [ cnt ] ) { <NEW_LINE> NS_Free ( mCachedAttrParamNames [ cnt ] ) ; <NEW_LINE> mCachedAttrParamNames [ cnt ] = nullptr ;
virtual bool Send ( IPC::Message * msg ) OVERRIDE ; <NEW_LINE> <START_VULN> int peer_pid ( ) { return peer_pid_ ; } <NEW_LINE> <END_VULN> IPC::ChannelHandle channel_handle ( ) const { return channel_handle_ ; }
<START_VULN> while ( next_format ( & colour_type , & bit_depth , & palette_number , 1 ) ) <NEW_LINE>if ( ( colour_type & PNG_COLOR_MASK_ALPHA ) != 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> unsigned int i , j ;
static void btsnoop_write ( const void * data , size_t length ) { <NEW_LINE> if ( logfile_fd != INVALID_FD ) <NEW_LINE> <START_VULN> write ( logfile_fd , data , length ) ; <NEW_LINE> <END_VULN> btsnoop_net_write ( data , length ) ; <NEW_LINE> }
void PostLegacyJsonMessage ( const std::string & method , <NEW_LINE> <START_VULN> scoped_ptr < base::DictionaryValue > data ) ; <NEW_LINE> <END_VULN> void SendTrappedKey ( uint32 usb_keycode , bool pressed ) ;
NS_ENSURE_TRUE ( mRequestor , NS_OK ) ; <NEW_LINE> nsCOMPtr < nsIScriptGlobalObject > scriptGlobal ( do_GetInterface ( mRequestor ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( scriptGlobal , NS_OK ) ; <NEW_LINE> nsIScriptContext * context = scriptGlobal -> GetContext ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( context , NS_OK ) ; <NEW_LINE> <START_VULN> JSContext * cx = context -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( cx , NS_OK ) ; <NEW_LINE> JSObject * global = JS_GetGlobalObject ( cx ) ; <NEW_LINE> NS_ENSURE_TRUE ( global , NS_OK ) ; <NEW_LINE> jsval params [ 2 ] ; <NEW_LINE> nsString unicodeMsg ;
<START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>void RemoveEntryAtIndex ( int index , const GURL & default_url ) ; <NEW_LINE> <END_VULN>
while ( current || current == parent ) { <NEW_LINE> if ( ! oldEndOfInline && <NEW_LINE> ( current == parent || <NEW_LINE> <START_VULN> ( ! current -> isFloating ( ) && ! current -> isReplaced ( ) && ! current -> isPositioned ( ) ) ) ) <NEW_LINE> <END_VULN> result = current -> firstChild ( ) ; <NEW_LINE> if ( ! result ) {
<START_VULN> PUBLIC MprJson * mprLookupJsonObj ( MprJson * obj , cchar * name ) <NEW_LINE> <END_VULN> { <NEW_LINE> MprJson * child ; <NEW_LINE> int i , index ;
virtual PassRefPtr < Scrollbar > createScrollbar ( ScrollableArea * , ScrollbarOrientation , ScrollbarControlSize ) ; <NEW_LINE> virtual void listBoxSelectItem ( int listIndex , bool allowMultiplySelections , bool shift , bool fireOnChangeNow = true ) ; <NEW_LINE> <START_VULN> virtual bool multiple ( ) ; <NEW_LINE> <END_VULN> virtual bool hasLineIfEmpty ( ) const { return true ; }
long count = 0 ; <NEW_LINE> oggpack_write ( opb , 1 , 1 ) ; <NEW_LINE> oggpack_write ( opb , c -> lengthlist [ 0 ] - 1 , 5 ) ; <NEW_LINE> for ( i = 1 ; i < c -> entries ; i ++ ) { <NEW_LINE> long this = c -> lengthlist [ i ] ; <NEW_LINE> long last = c -> lengthlist [ i - 1 ] ; <NEW_LINE> if ( this > last ) { <NEW_LINE> <START_VULN> for ( j = last ; j < this ; j ++ ) { <NEW_LINE>oggpack_write ( opb , i - count , _ilog ( c -> entries - count ) ) ; <NEW_LINE>count = i ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> oggpack_write ( opb , i - count , _ilog ( c -> entries - count ) ) ; <NEW_LINE> } else { <NEW_LINE> oggpack_write ( opb , 0 , 1 ) ;
TypingCommand::insertText ( <NEW_LINE> <START_VULN> * selection . start ( ) . document ( ) , text , selection , <NEW_LINE> <END_VULN> selectInsertedText ? TypingCommand::SelectInsertedText : 0 , <NEW_LINE> triggeringEvent && triggeringEvent -> isComposition ( ) <NEW_LINE> ? TypingCommand::TextCompositionConfirm
headerAddress += size ; <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> if ( startOfGap != headerAddress ) <NEW_LINE> addToFreeList ( startOfGap , headerAddress - startOfGap ) ;
NS_PRECONDITION ( mActionNesting > 0 , "bad action nesting ! " ) ; <NEW_LINE> nsresult res = NS_OK ; <NEW_LINE> if ( ! -- mActionNesting ) <NEW_LINE> { <NEW_LINE> res = AfterEditInner ( action , aDirection ) ; <NEW_LINE> <START_VULN> ( mHTMLEditor -> mRangeUpdater ) . DropRangeItem ( & mRangeItem ) ; <NEW_LINE> <END_VULN> if ( mRestoreContentEditableCount ) { <NEW_LINE> nsCOMPtr < nsIDOMDocument > doc = mHTMLEditor -> GetDOMDocument ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( doc , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE> nsCOMPtr < nsIHTMLDocument > htmlDoc = do_QueryInterface ( doc ) ; <NEW_LINE> NS_ENSURE_TRUE ( htmlDoc , NS_ERROR_FAILURE ) ; <NEW_LINE> if ( htmlDoc -> GetEditingState ( ) == nsIHTMLDocument::eContentEditable ) {
ProxyJNIEnv & proxyEnv = GetProxyEnv ( env ) ; <NEW_LINE> nsISecureEnv * secureEnv = GetSecureEnv ( env ) ; <NEW_LINE> nsISecurityContext * securityContext = proxyEnv . getContext ( ) ; <NEW_LINE> <START_VULN> nsresult result ; <NEW_LINE>result = secureEnv -> CallMethod ( jvoid_type , obj , method -> mMethodID , args , & unusedValue , securityContext ) ; <NEW_LINE> <END_VULN> NS_IF_RELEASE ( securityContext ) ; <NEW_LINE> }
if ( ! stringIsBase64EncodingOf256bitValue ( pin ) ) { <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> } <NEW_LINE> sha256keys . AppendElement ( pin ) ; <NEW_LINE> } <NEW_LINE> SiteHPKPState dynamicEntry ( expireTime , SecurityPropertySet , <NEW_LINE> aIncludeSubdomains , sha256keys ) ; <NEW_LINE> <START_VULN> return SetHPKPState ( aHost , dynamicEntry , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsresult <NEW_LINE> nsSiteSecurityService::SetHPKPState ( const char * aHost , SiteHPKPState & entry , <NEW_LINE> uint32_t aFlags ) <NEW_LINE> { <NEW_LINE> SSSLOG ( ( "Top of SetPKPState" ) ) ; <NEW_LINE> nsAutoCString host ( aHost ) ;
#define VP9_COMMON_VP9_SCALE_H_ <NEW_LINE> #include "vp9 / common / vp9_mv . h" <NEW_LINE> <START_VULN> #include "vp9 / common / vp9_convolve . h" <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> extern "C" {
<START_VULN> #ifndef CONTENT_SHELL_COMMON_WEBKIT_TEST_HELPERS_H_ <NEW_LINE>#define CONTENT_SHELL_COMMON_WEBKIT_TEST_HELPERS_H_ <NEW_LINE> <END_VULN> #include < string > <NEW_LINE> #include < vector >
NS_IMETHODIMP <NEW_LINE> nsTextEditRules::BeforeEdit ( PRInt32 action , nsIEditor::EDirection aDirection ) <NEW_LINE> { <NEW_LINE> if ( mLockRulesSniffing ) return NS_OK ; <NEW_LINE> nsAutoLockRulesSniffing lockIt ( this ) ; <NEW_LINE> mDidExplicitlySetInterline = PR_FALSE ; <NEW_LINE> nsCOMPtr < nsISelection > selection ; <NEW_LINE> nsresult res = mEditor -> GetSelection ( getter_AddRefs ( selection ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( res , res ) ; <NEW_LINE> selection -> GetAnchorNode ( getter_AddRefs ( mCachedSelectionNode ) ) ; <NEW_LINE> selection -> GetAnchorOffset ( & mCachedSelectionOffset ) ; <NEW_LINE> <START_VULN> if ( ! mActionNesting ) <NEW_LINE> { <NEW_LINE><NEW_LINE>mTheAction = action ; <NEW_LINE> } <NEW_LINE>mActionNesting ++ ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTextEditRules::AfterEdit ( PRInt32 action , nsIEditor::EDirection aDirection ) <NEW_LINE> { <NEW_LINE> if ( mLockRulesSniffing ) return NS_OK ;
@description This does a deep copy of a JSON object tree . This copies all properties and their sub - properties . <NEW_LINE> @return A new JSON object that replices the input object . <NEW_LINE> @ingroup MprJson <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC MprJson * mprCloneJson ( MprJson * obj ) ;
} else { <NEW_LINE> if ( isDH ) master_derive = CKM_SSL3_MASTER_KEY_DERIVE_DH ; <NEW_LINE> else master_derive = CKM_SSL3_MASTER_KEY_DERIVE ; <NEW_LINE> key_derive = CKM_SSL3_KEY_AND_MAC_DERIVE ; <NEW_LINE> keyFlags = 0 ; <NEW_LINE> } <NEW_LINE> if ( pms || ! pwSpec -> master_secret ) { <NEW_LINE> <START_VULN> master_params . pVersion = & pms_version ; <NEW_LINE> <END_VULN> master_params . RandomInfo . pClientRandom = cr ; <NEW_LINE> master_params . RandomInfo . ulClientRandomLen = SSL3_RANDOM_LENGTH ; <NEW_LINE> master_params . RandomInfo . pServerRandom = sr ; <NEW_LINE> master_params . RandomInfo . ulServerRandomLen = SSL3_RANDOM_LENGTH ; <NEW_LINE> params . data = ( unsigned char * ) & master_params ; <NEW_LINE> params . len = sizeof master_params ; <NEW_LINE> }
CLOGW ( "findBufferHeader: buffer % u not found" , buffer ) ; <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> return mBufferIDToBufferHeader . valueAt ( index ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> OMX::buffer_id OMXNodeInstance::findBufferID ( OMX_BUFFERHEADERTYPE * bufferHeader ) {
if ( code > 0xFF ) { <NEW_LINE> return FAILURE ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> * res = code ; <NEW_LINE> break ;
return NS_ERROR_FAILURE ; <NEW_LINE> NS_ADDREF ( wrapper ) ; <NEW_LINE> NS_ASSERTION ( ! xpc::WrapperFactory::IsXrayWrapper ( js::GetObjectParent ( existingJSObject ) ) , <NEW_LINE> "Xray wrapper being used to parent XPCWrappedNative ? " ) ; <NEW_LINE> JSAutoEnterCompartment ac ; <NEW_LINE> <START_VULN> if ( ! ac . enter ( ccx , existingJSObject ) || ! wrapper -> Init ( ccx , existingJSObject ) ) { <NEW_LINE> <END_VULN> NS_RELEASE ( wrapper ) ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> nsresult rv ; <NEW_LINE> if ( Interface && ! wrapper -> FindTearOff ( ccx , Interface , false , & rv ) ) { <NEW_LINE> wrapper -> Release ( ) ;
if ( bufsize > QMFB_JOINBUFSIZE ) { <NEW_LINE> <START_VULN> if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) { <NEW_LINE> <END_VULN> abort ( ) ; <NEW_LINE> }
break ; <NEW_LINE> case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: <NEW_LINE> case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD: <NEW_LINE> ND_PRINT ( ( ndo , " % sBandwidth Constraints Model ID: % s ( % u ) " , <NEW_LINE> ident , <NEW_LINE> tok2str ( diffserv_te_bc_values , "unknown" , * tptr ) , <NEW_LINE> * tptr ) ) ; <NEW_LINE> tptr ++ ; <NEW_LINE> for ( te_class = 0 ; te_class < ( subl - 1 ) / 4 ; te_class ++ ) { <NEW_LINE> <START_VULN> ND_TCHECK2 ( * tptr , 4 ) ; <NEW_LINE> <END_VULN> bw . i = EXTRACT_32BITS ( tptr ) ; <NEW_LINE> ND_PRINT ( ( ndo , " % s Bandwidth constraint CT % u: % . 3f Mbps" , <NEW_LINE> ident ,
vpx_codec_err_t res ; <NEW_LINE> <START_VULN> res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , <NEW_LINE> <END_VULN> & stream -> config . cfg , <NEW_LINE> global -> usage ) ; <NEW_LINE> if ( res )
if ( ! newTypeObjects . initialized ( ) && ! newTypeObjects . init ( ) ) <NEW_LINE> return nullptr ; <NEW_LINE> if ( fun ) { <NEW_LINE> if ( fun -> hasScript ( ) ) <NEW_LINE> fun = fun -> nonLazyScript ( ) -> functionNonDelazifying ( ) ; <NEW_LINE> <START_VULN> else if ( fun -> isInterpretedLazy ( ) ) <NEW_LINE> <END_VULN> fun = fun -> lazyScript ( ) -> functionNonDelazifying ( ) ; <NEW_LINE> else <NEW_LINE> fun = nullptr ; <NEW_LINE> } <NEW_LINE> TypeObjectWithNewScriptSet::AddPtr p = <NEW_LINE> newTypeObjects . lookupForAdd ( TypeObjectWithNewScriptSet::Lookup ( clasp , proto , fun ) ) ; <NEW_LINE> if ( p ) {
public nsIDOMEventTarget , <NEW_LINE> public nsIDOM3EventTarget , <NEW_LINE> public nsIDOMNSEventTarget , <NEW_LINE> public nsIScriptObjectPrincipal , <NEW_LINE> public nsIRadioGroupContainer , <NEW_LINE> public nsIDOMNodeSelector , <NEW_LINE> public nsIApplicationCacheContainer , <NEW_LINE> public nsIDOMXPathNSResolver , <NEW_LINE> <START_VULN> public nsStubMutationObserver <NEW_LINE> <END_VULN> { <NEW_LINE> public: <NEW_LINE> NS_DECL_CYCLE_COLLECTING_ISUPPORTS <NEW_LINE> virtual void Reset ( nsIChannel * aChannel , nsILoadGroup * aLoadGroup ) ; <NEW_LINE> virtual void ResetToURI ( nsIURI * aURI , nsILoadGroup * aLoadGroup , <NEW_LINE> nsIPrincipal * aPrincipal ) ;
static const yytype_uint16 yyrline [ ] = <NEW_LINE> { <NEW_LINE> <START_VULN> 0 , 104 , 104 , 109 , 113 , 117 , 128 , 146 , 150 , 161 , <NEW_LINE>175 , 191 , 205 , 221 , 244 , 268 , 290 , 313 , 317 , 323 , <NEW_LINE>329 , 335 , 344 , 348 , 354 , 362 , 368 , 374 , 380 , 386 , <NEW_LINE>392 , 398 <NEW_LINE> <END_VULN> } ; <NEW_LINE> #endif
png_colorspace_sync_info ( png_ptr , info_ptr ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_COLORSPACE_SUPPORTED
return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> MediaManager::GetUserMediaDevices ( nsPIDOMWindow * aWindow , <NEW_LINE> const MediaStreamConstraintsInternal & aConstraints , <NEW_LINE> nsIGetUserMediaDevicesSuccessCallback * aOnSuccess , <NEW_LINE> <START_VULN> nsIDOMGetUserMediaErrorCallback * aOnError ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ASSERTION ( NS_IsMainThread ( ) , "Only call on main thread" ) ; <NEW_LINE> NS_ENSURE_TRUE ( aOnError , NS_ERROR_NULL_POINTER ) ; <NEW_LINE> NS_ENSURE_TRUE ( aOnSuccess , NS_ERROR_NULL_POINTER ) ; <NEW_LINE> nsCOMPtr < nsIGetUserMediaDevicesSuccessCallback > onSuccess ( aOnSuccess ) ; <NEW_LINE> nsCOMPtr < nsIDOMGetUserMediaErrorCallback > onError ( aOnError ) ;
} <NEW_LINE> case CompositableOperation::TOpPaintTextureRegion: { <NEW_LINE> MOZ_LAYERS_LOG ( ( " [ ParentSide ] Paint ThebesLayer" ) ) ; <NEW_LINE> const OpPaintTextureRegion & op = aEdit . get_OpPaintTextureRegion ( ) ; <NEW_LINE> CompositableParent * compositableParent = static_cast < CompositableParent * > ( op . compositableParent ( ) ) ; <NEW_LINE> CompositableHost * compositable = <NEW_LINE> compositableParent -> GetCompositableHost ( ) ; <NEW_LINE> <START_VULN> ThebesLayerComposite * thebes = <NEW_LINE>static_cast < ThebesLayerComposite * > ( compositable -> GetLayer ( ) ) ; <NEW_LINE> <END_VULN> const ThebesBufferData & bufferData = op . bufferData ( ) ; <NEW_LINE> RenderTraceInvalidateStart ( thebes , "FF00FF" , op . updatedRegion ( ) . GetBounds ( ) ) ; <NEW_LINE> nsIntRegion frontUpdatedRegion ; <NEW_LINE> if ( ! compositable -> UpdateThebes ( bufferData , <NEW_LINE> op . updatedRegion ( ) ,
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeContentView::SetCellText ( PRInt32 aRow , nsITreeColumn * aCol , const nsAString & aValue ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ENSURE_ARG_POINTER ( aCol ) ; <NEW_LINE> <END_VULN> NS_PRECONDITION ( aRow >= 0 && aRow < PRInt32 ( mRows . Length ( ) ) , "bad row" ) ; <NEW_LINE> if ( aRow < 0 || aRow >= PRInt32 ( mRows . Length ( ) ) ) <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> Row * row = mRows [ aRow ] ; <NEW_LINE> nsIContent * realRow = <NEW_LINE> nsTreeUtils::GetImmediateChild ( row -> mContent , nsGkAtoms::treerow ) ;
char msg [ fixed_message_ln + PNG_MAX_ERROR_TEXT ] ; <NEW_LINE> memcpy ( msg , fixed_message , fixed_message_ln ) ; <NEW_LINE> iin = 0 ; <NEW_LINE> <START_VULN> if ( name != NULL ) while ( iin < ( PNG_MAX_ERROR_TEXT - 1 ) && name [ iin ] != 0 ) <NEW_LINE> { <NEW_LINE>msg [ fixed_message_ln + iin ] = name [ iin ] ; <NEW_LINE> ++ iin ; <NEW_LINE> } <NEW_LINE> <END_VULN> msg [ fixed_message_ln + iin ] = 0 ; <NEW_LINE> png_error ( png_ptr , msg ) ; <NEW_LINE> }
<START_VULN> static void appendToHeader ( HeaderString & header , absl::string_view data ) ; <NEW_LINE> <END_VULN> HeaderMapImpl ( ) ; <NEW_LINE> explicit HeaderMapImpl (
UniscribeItem * GetItem ( PRUint32 i , gfxWindowsFontGroup * aGroup ) { <NEW_LINE> NS_ASSERTION ( i < ( PRUint32 ) mNumItems , "Trying to get out of bounds item" ) ; <NEW_LINE> UniscribeItem * item = new UniscribeItem ( mContext , mDC , <NEW_LINE> mString + mItems [ i ] . iCharPos , <NEW_LINE> mItems [ i + 1 ] . iCharPos - mItems [ i ] . iCharPos , <NEW_LINE> & mItems [ i ] , <NEW_LINE> aGroup ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return item ; <NEW_LINE> } <NEW_LINE> private: <NEW_LINE> nsRefPtr < gfxContext > mContext ; <NEW_LINE> HDC mDC ; <NEW_LINE> const PRUnichar * mString ; <NEW_LINE> const PRUint32 mLength ;
nsresult ServeStreamAsFile ( nsIRequest * request , nsISupports * ctxt ) ; <NEW_LINE> nsNPAPIPluginInstance * GetPluginInstance ( ) { return mPluginInstance ; } <NEW_LINE> private: <NEW_LINE> nsresult SetUpStreamListener ( nsIRequest * request , nsIURI * aURL ) ; <NEW_LINE> nsresult SetupPluginCacheFile ( nsIChannel * channel ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> nsCOMPtr < nsIURI > mURL ; <NEW_LINE> nsCString mURLSpec ; <NEW_LINE> nsCOMPtr < nsIPluginInstanceOwner > mOwner ; <NEW_LINE> nsCOMPtr < nsIPluginStreamListener > mPStreamListener ; <NEW_LINE> PRPackedBool mRequestFailed ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . methodThatRequiresAllArgsAndThrows" ) ; <NEW_LINE> if ( args . Length ( ) < 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> ExceptionCode ec = 0 ; <NEW_LINE> {
int PreProcessingFx_ProcessReverse ( effect_handle_t self , <NEW_LINE> audio_buffer_t * inBuffer , <NEW_LINE> <START_VULN> audio_buffer_t * outBuffer ) <NEW_LINE> <END_VULN> { <NEW_LINE> preproc_effect_t * effect = ( preproc_effect_t * ) self ; <NEW_LINE> int status = 0 ;
int cg_mkdir ( const char * path , mode_t mode ) <NEW_LINE> { <NEW_LINE> struct fuse_context * fc = fuse_get_context ( ) ; <NEW_LINE> <START_VULN> char * fpath = NULL , * path1 , * cgdir = NULL , * controller ; <NEW_LINE> <END_VULN> const char * cgroup ; <NEW_LINE> int ret ;
#define LIBRAW_MAJOR_VERSION 0 <NEW_LINE> #define LIBRAW_MINOR_VERSION 18 <NEW_LINE> <START_VULN> #define LIBRAW_PATCH_VERSION 7 <NEW_LINE> <END_VULN> #define LIBRAW_VERSION_TAIL Release <NEW_LINE> #define LIBRAW_SHLIB_CURRENT 16
m_packetString . append ( "' > " ) ; <NEW_LINE> } <NEW_LINE> for ( ArrayIter it ( varAsArray ) ; it ; ++ it ) { <NEW_LINE> <START_VULN> Variant key = it . first ( ) ; <NEW_LINE>Variant value = it . second ( ) ; <NEW_LINE>recursiveAddVar ( key . toString ( ) , value , isObject ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( isObject ) { <NEW_LINE> m_packetString . append ( " < / struct > " ) ;
bool IsPaused ( ) ; <NEW_LINE> int GetRate ( ) { return mOutRate ; } <NEW_LINE> int GetChannels ( ) { return mChannels ; } <NEW_LINE> int GetOutChannels ( ) { return mOutChannels ; } <NEW_LINE> <START_VULN> <NEW_LINE>nsresult EnsureTimeStretcherInitialized ( ) ; <NEW_LINE> <END_VULN> nsresult SetPlaybackRate ( double aPlaybackRate ) ; <NEW_LINE> nsresult SetPreservesPitch ( bool aPreservesPitch ) ; <NEW_LINE> size_t SizeOfIncludingThis ( MallocSizeOf aMallocSizeOf ) const ; <NEW_LINE> private: <NEW_LINE> friend class AudioInitTask ; <NEW_LINE> nsresult OpenCubeb ( cubeb_stream_params & aParams , <NEW_LINE> LatencyRequest aLatencyRequest ) ; <NEW_LINE> void CheckForStart ( ) ;
void PopulateJSClass ( JSBool isGlobal ) ; <NEW_LINE> void Mark ( ) { mFlags . Mark ( ) ; } <NEW_LINE> void Unmark ( ) { mFlags . Unmark ( ) ; } <NEW_LINE> JSBool IsMarked ( ) const { return mFlags . IsMarked ( ) ; } <NEW_LINE> private: <NEW_LINE> XPCNativeScriptableFlags mFlags ; <NEW_LINE> <START_VULN> XPCNativeScriptableSharedJSClass mJSClass ; <NEW_LINE> <END_VULN> JSBool mCanBeSlim ; <NEW_LINE> } ; <NEW_LINE> class XPCNativeScriptableInfo
return ( fi . spdist - fp -> down -> script -> nfixed ) + <NEW_LINE> ( ( fun -> nargs > fp -> argc ) ? fun -> nargs - fp -> argc : 0 ) + <NEW_LINE> script -> nfixed + 1 ; <NEW_LINE> } <NEW_LINE> static void <NEW_LINE> <START_VULN> SynthesizeSlowNativeFrame ( JSContext * cx , VMSideExit * exit ) <NEW_LINE> <END_VULN> { <NEW_LINE> VOUCH_DOES_NOT_REQUIRE_STACK ( ) ; <NEW_LINE> void * mark ; <NEW_LINE> JSInlineFrame * ifp ; <NEW_LINE> mark = JS_ARENA_MARK ( & cx -> stackPool ) ;
uint_fast16_t len ; <NEW_LINE> <START_VULN> uchar * data ; <NEW_LINE> <END_VULN> } jpc_com_t ;
if ( root ) { <NEW_LINE> MOZ_TIMER_DEBUGLOG ( ( "Reset and start: Frame Creation: PresShell::InitialReflow ( ) , this = % p\n" , <NEW_LINE> ( void * ) this ) ) ; <NEW_LINE> MOZ_TIMER_RESET ( mFrameCreationWatch ) ; <NEW_LINE> MOZ_TIMER_START ( mFrameCreationWatch ) ; <NEW_LINE> { <NEW_LINE> <START_VULN> nsAutoCauseReflowNotifier reflowNotifier ( this ) ; <NEW_LINE> <END_VULN> mFrameConstructor -> BeginUpdate ( ) ; <NEW_LINE> if ( ! rootFrame ) { <NEW_LINE> mFrameConstructor -> ConstructRootFrame ( root , & rootFrame ) ; <NEW_LINE> FrameManager ( ) -> SetRootFrame ( rootFrame ) ; <NEW_LINE> }
__be32	 times [ 3 ] ; <NEW_LINE> } data ; <NEW_LINE> int head_len ; <NEW_LINE> <START_VULN> struct ip_options replyopts ; <NEW_LINE>unsigned char optbuf [ 40 ] ; <NEW_LINE> <END_VULN> } ;
mDefaultSampleSize ( 0 ) , <NEW_LINE> mNumSampleSizes ( 0 ) , <NEW_LINE> mTimeToSampleCount ( 0 ) , <NEW_LINE> <START_VULN> mTimeToSample ( NULL ) , <NEW_LINE> <END_VULN> mSampleTimeEntries ( NULL ) , <NEW_LINE> mCompositionTimeDeltaEntries ( NULL ) , <NEW_LINE> mNumCompositionTimeDeltaEntries ( 0 ) ,
std::unique_ptr < JSONObject > ToJSON ( ) const ; <NEW_LINE> private: <NEW_LINE> <START_VULN> ScrollPaintPropertyNode ( scoped_refptr < const ScrollPaintPropertyNode > parent , <NEW_LINE>State && state ) <NEW_LINE>: PaintPropertyNode ( std::move ( parent ) ) , state_ ( std::move ( state ) ) { <NEW_LINE> <END_VULN> Validate ( ) ; <NEW_LINE> }
for ( i = 0 ; i < read ; i ++ ) { <NEW_LINE> <START_VULN> chase = ( ( ogg_uint16_t * ) ( book -> dec_table ) ) [ chase * 2 + ( ( lok >> i ) & 1 ) ] ; <NEW_LINE>if ( chase & 0x8000UL ) break ; <NEW_LINE> <END_VULN> } <NEW_LINE> chase &= ~ 0x8000UL ;
AXSparseAttributeClient & attributeMap , <NEW_LINE> const AtomicString & value ) override { <NEW_LINE> attributeMap . addBoolAttribute ( m_attribute , <NEW_LINE> <START_VULN> equalIgnoringCase ( value , "true" ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } ;
static int CVE_2013_2547_crypto_report_one ( struct crypto_alg * alg , <NEW_LINE> struct crypto_user_alg * ualg , struct sk_buff * skb ) <NEW_LINE> { <NEW_LINE> <START_VULN> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <NEW_LINE>memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <NEW_LINE>sizeof ( ualg -> cru_driver_name ) ) ; <NEW_LINE>memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <NEW_LINE>CRYPTO_MAX_ALG_NAME ) ; <NEW_LINE> <END_VULN> ualg -> cru_flags = alg -> cra_flags ; <NEW_LINE> ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ;
ctxt = xmlRelaxNGNewParserCtxt ( filename ) ; <NEW_LINE> <START_VULN> xmlRelaxNGSetParserErrors ( ctxt , <NEW_LINE> ( xmlRelaxNGValidityErrorFunc ) testErrorHandler , <NEW_LINE> ( xmlRelaxNGValidityWarningFunc ) testErrorHandler , <NEW_LINE>ctxt ) ; <NEW_LINE> <END_VULN> schemas = xmlRelaxNGParse ( ctxt ) ; <NEW_LINE> xmlRelaxNGFreeParserCtxt ( ctxt ) ;
IDBRequest * aRequest , <NEW_LINE> IDBIndex * aIndex , <NEW_LINE> IDBKeyRange * aKeyRange ) <NEW_LINE> : GetKeyHelper ( aTransaction , aRequest , aIndex , aKeyRange ) <NEW_LINE> { } <NEW_LINE> ~ GetHelper ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( mCloneReadInfo . mCloneBuffer ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> virtual nsresult DoDatabaseWork ( mozIStorageConnection * aConnection ) <NEW_LINE> MOZ_OVERRIDE ; <NEW_LINE> virtual nsresult GetSuccessResult ( JSContext * aCx , <NEW_LINE> jsval * aVal ) MOZ_OVERRIDE ;
* bry = tmpbry ; <NEW_LINE> } <NEW_LINE> <START_VULN> static inline long decode_twos_comp ( ulong c , int prec ) <NEW_LINE> <END_VULN> { <NEW_LINE> long result ; <NEW_LINE> assert ( prec >= 2 ) ;
assert ( socket != NULL ) ; <NEW_LINE> int size = 0 ; <NEW_LINE> <START_VULN> if ( ioctl ( socket -> fd , FIONREAD , & size ) == - 1 ) <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> return size ; <NEW_LINE> }
JSValue JSDirectoryEntry::getFile ( ExecState * exec ) <NEW_LINE> { <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> DirectoryEntry * imp = static_cast < DirectoryEntry * > ( impl ( ) ) ; <NEW_LINE> const String & path = valueToStringWithUndefinedOrNullCheck ( exec , exec -> argument ( 0 ) ) ;
break ; <NEW_LINE> case EFFECT_CMD_GET_CONFIG: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || <NEW_LINE> * replySize != sizeof ( effect_config_t ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Effect_command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_GET_CONFIG: ERROR" ) ; <NEW_LINE> return - EINVAL ;
png_uint_32 res_x , res_y ; <NEW_LINE> int unit_type ; <NEW_LINE> <START_VULN> if ( png_get_pHYs ( read_ptr , read_info_ptr , & res_x , & res_y , & unit_type ) ) <NEW_LINE> <END_VULN> png_set_pHYs ( write_ptr , write_info_ptr , res_x , res_y , unit_type ) ; <NEW_LINE> } <NEW_LINE> #endif
void <NEW_LINE> PresShell::CharacterDataChanged ( nsIDocument * aDocument , <NEW_LINE> nsIContent * aContent , <NEW_LINE> CharacterDataChangeInfo * aInfo ) <NEW_LINE> { <NEW_LINE> NS_PRECONDITION ( ! mIsDocumentGone , "Unexpected CharacterDataChanged" ) ; <NEW_LINE> NS_PRECONDITION ( aDocument == mDocument , "Unexpected aDocument" ) ; <NEW_LINE> <START_VULN> nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE> <END_VULN> if ( mCaret ) {
} <NEW_LINE> mbmi -> interp_filter = cm -> interp_filter != SWITCHABLE ? <NEW_LINE> <START_VULN> cm -> interp_filter : * best_filter ; <NEW_LINE>rs = cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( x ) : 0 ; <NEW_LINE> <END_VULN> if ( pred_exists ) { <NEW_LINE> if ( best_needs_copy ) {
if ( length < tail -> length ) <NEW_LINE> length = tail -> length ; <NEW_LINE> <START_VULN> <NEW_LINE>next = png_voidcast ( IDAT_list * , malloc ( IDAT_list_size ( NULL , length ) ) ) ; <NEW_LINE> <END_VULN> CLEAR ( * next ) ;
if ( payload_position < 0 ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> if ( ! WriteEbmlElement ( writer , <NEW_LINE>kMkvSamplingFrequency , <NEW_LINE> <END_VULN> static_cast < float > ( sample_rate_ ) ) ) <NEW_LINE> return false ; <NEW_LINE> if ( ! WriteEbmlElement ( writer , kMkvChannels , channels_ ) )
int dst_pitch <NEW_LINE> ) <NEW_LINE> { <NEW_LINE> <START_VULN> DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , FData2 , 16 * 16 ) ; <NEW_LINE> <END_VULN> const short * HFilter , * VFilter ; <NEW_LINE> HFilter = vp8_six_tap_mmx [ xoffset ] ; <NEW_LINE> vp8_filter_block1d_h6_mmx ( src_ptr - ( 2 * src_pixels_per_line ) , FData2 , src_pixels_per_line , 1 , 9 , 8 , HFilter ) ;
} <NEW_LINE> } <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsPluginInstanceOwner::GetDOMElement ( nsIDOMElement * * result ) <NEW_LINE> { <NEW_LINE> <START_VULN> return CallQueryInterface ( mContent , result ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsresult nsPluginInstanceOwner::GetInstance ( nsNPAPIPluginInstance ** aInstance ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_ARG_POINTER ( aInstance ) ; <NEW_LINE> * aInstance = mInstance ; <NEW_LINE> NS_IF_ADDREF ( * aInstance ) ;
length , js::NullPtr ( ) ) ; \ <NEW_LINE> } \ <NEW_LINE> JS_FRIEND_API ( bool ) JS_Is ## Name ## Array ( JSObject * obj ) \ <NEW_LINE> { \ <NEW_LINE> if ( ! ( obj = CheckedUnwrap ( obj ) ) ) \ <NEW_LINE> return false ; \ <NEW_LINE> const Class * clasp = obj -> getClass ( ) ; \ <NEW_LINE> return ( clasp == & TypedArrayObject::classes [ TypedArrayObjectTemplate < NativeType > ::ArrayTypeID ( ) ] ) ; \ <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Int8 , int8_t ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Uint8 , uint8_t ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Uint8Clamped , uint8_clamped ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Int16 , int16_t ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Uint16 , uint16_t ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Int32 , int32_t ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Uint32 , uint32_t )
<START_VULN> #ifndef BASE_BUILD_TIME_ <NEW_LINE>#define BASE_BUILD_TIME_ <NEW_LINE> <END_VULN> #include "base / base_export . h" <NEW_LINE> #include "base / time / time . h"
LIns * priv_ins = w . ldpObjPrivate ( obj_ins ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( ( jsuint ) idx >= tarray -> length ) { <NEW_LINE>CHECK_STATUS_A ( guard ( false , <NEW_LINE>w . ltui ( idx_ins , w . ldiConstTypedArrayLength ( priv_ins ) ) , <NEW_LINE>BRANCH_EXIT , <NEW_LINE>true ) ) ; <NEW_LINE>v_ins = w . immiUndefined ( ) ; <NEW_LINE>return ARECORD_CONTINUE ; <NEW_LINE> } <NEW_LINE> <END_VULN>
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> a * ( toa ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
<START_VULN> bool OutputSlowerPlayback ( uint8 * dest ) ; <NEW_LINE> <END_VULN> void ResetWindow ( ) ;
ci -> _abi = ABI_CDECL ; <NEW_LINE> #ifdef DEBUG <NEW_LINE> ci -> _name = "JSPropertyOp" ; <NEW_LINE> #endif <NEW_LINE> LIns * args [ ] = { vp_ins , INS_CONSTWORD ( SPROP_USERID ( sprop ) ) , obj_ins , cx_ins } ; <NEW_LINE> LIns * ok_ins = lir -> insCall ( ci , args ) ; <NEW_LINE> <START_VULN> lir -> insStorei ( INS_NULL ( ) , cx_ins , offsetof ( JSContext , nativeVp ) ) ; <NEW_LINE> <END_VULN> leaveDeepBailCall ( ) ; <NEW_LINE> LIns * status_ins = lir -> insLoad ( LIR_ld , <NEW_LINE> lirbuf -> state ,
#define EFX_MAX_EVQ_SIZE 16384UL <NEW_LINE> #define EFX_MIN_EVQ_SIZE 512UL <NEW_LINE> <START_VULN> <NEW_LINE>#define EFX_MIN_RING_SIZE ( roundup_pow_of_two ( 2 * 3 * MAX_SKB_FRAGS ) ) <NEW_LINE> <END_VULN> extern int efx_probe_filters ( struct efx_nic * efx ) ;
PHP_FUNCTION ( mcrypt_module_self_test ) <NEW_LINE> { <NEW_LINE> MCRYPT_GET_MODE_DIR_ARGS ( algorithms_dir ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( mcrypt_module_self_test ( module , dir ) == 0 ) { <NEW_LINE> RETURN_TRUE ; <NEW_LINE> } else {
{ <NEW_LINE> char * cpu , * family ; <NEW_LINE> <START_VULN> family = stok ( sclone ( arch ) , ":" , & cpu ) ; <NEW_LINE>if ( ! cpu || * cpu == '\0' ) { <NEW_LINE> <END_VULN> if ( smatch ( family , "i386" ) ) { <NEW_LINE> cpu = "I80386" ; <NEW_LINE> } else if ( smatch ( family , "i486" ) ) {
uint_fast16_t len ; <NEW_LINE> <START_VULN> uchar * data ; <NEW_LINE> <END_VULN> } jpc_ppm_t ;
NS_ENSURE_SUCCESS ( rv , NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> CreateFileHelper::DoDatabaseWork ( mozIStorageConnection * aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "CreateFileHelper::DoDatabaseWork" ) ; <NEW_LINE> if ( IndexedDatabaseManager::InLowDiskSpaceMode ( ) ) { <NEW_LINE> NS_WARNING ( "Refusing to create file because disk space is low ! " ) ; <NEW_LINE> return NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR ; <NEW_LINE> }
chunk = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * chunk ) ) ; <NEW_LINE> if ( chunk == ( unsigned char * ) NULL ) <NEW_LINE> <START_VULN> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <END_VULN> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <NEW_LINE> {
~ VaapiJpegDecoder ( ) override ; <NEW_LINE> <START_VULN> bool Initialize ( const base::RepeatingClosure & error_uma_cb ) override ; <NEW_LINE> <END_VULN> scoped_refptr < VASurface > Decode ( base::span < const uint8_t > encoded_image , <NEW_LINE> VaapiImageDecodeStatus * status ) override ; <NEW_LINE>
progressive_row ( png_structp ppIn , png_bytep new_row , png_uint_32 y , int pass ) <NEW_LINE> { <NEW_LINE> png_const_structp pp = ppIn ; <NEW_LINE> <START_VULN> PNG_CONST standard_display * dp = voidcast ( standard_display * , <NEW_LINE> <END_VULN> png_get_progressive_ptr ( pp ) ) ; <NEW_LINE> y = PNG_ROW_FROM_PASS_ROW ( y , pass ) ; <NEW_LINE> }
unsigned int oom_badness ( struct task_struct * p , struct mem_cgroup * mem , <NEW_LINE> const nodemask_t * nodemask , unsigned long totalpages ) <NEW_LINE> { <NEW_LINE> <START_VULN> int points ; <NEW_LINE> <END_VULN> if ( oom_unkillable_task ( p , mem , nodemask ) ) <NEW_LINE> return 0 ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: basic codebook pack / unpack / code / decode operations <NEW_LINE> <START_VULN> last mod: $ Id: codebook . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
JS_ResolveStub , <NEW_LINE> JS_ConvertStub , <NEW_LINE> proxy_Finalize , <NEW_LINE> NULL , <NEW_LINE> proxy_Call , <NEW_LINE> FunctionClass . hasInstance , <NEW_LINE> proxy_Construct , <NEW_LINE> proxy_TraceFunction , <NEW_LINE> <START_VULN> JS_NULL_CLASS_EXT , <NEW_LINE> <END_VULN> { <NEW_LINE> proxy_LookupGeneric , <NEW_LINE> proxy_LookupProperty , <NEW_LINE> proxy_LookupElement , <NEW_LINE> proxy_LookupSpecial , <NEW_LINE> proxy_DefineGeneric , <NEW_LINE> proxy_DefineProperty , <NEW_LINE> proxy_DefineElement ,
void LocalFileSystem::deleteFileSystemInternal ( <NEW_LINE> PassRefPtrWillBeRawPtr < ExecutionContext > context , <NEW_LINE> FileSystemType type , <NEW_LINE> <START_VULN> PassRefPtr < CallbackWrapper > callbacks ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ! fileSystem ( ) ) { <NEW_LINE> fileSystemNotAvailable ( context , callbacks ) ;
GetNextToken ( q , & q , extent , token ) ; <NEW_LINE> weight = ParseCommandOption ( MagickWeightOptions , MagickFalse , token ) ; <NEW_LINE> if ( weight == - 1 ) <NEW_LINE> <START_VULN> weight = StringToUnsignedLong ( token ) ; <NEW_LINE> <END_VULN> graphic_context [ n ] -> weight = ( size_t ) weight ; <NEW_LINE> break ; <NEW_LINE> }
cstate = 0 ; <NEW_LINE> <START_VULN> if ( JAS_CAST ( uint , jas_stream_write ( out , ( char * ) ppm -> data , ppm -> len ) ) != ppm -> len ) { <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> } <NEW_LINE> return 0 ;
l_int32 <NEW_LINE> gplotGenCommandFile ( GPLOT * gplot ) <NEW_LINE> { <NEW_LINE> <START_VULN> char buf [ L_BUF_SIZE ] ; <NEW_LINE> <END_VULN> char * cmdstr , * plottitle , * dataname ; <NEW_LINE> l_int32 i , plotstyle , nplots ; <NEW_LINE> FILE * fp ;
( ctxt -> sax -> processingInstruction != NULL ) ) <NEW_LINE> ctxt -> sax -> processingInstruction ( ctxt -> userData , <NEW_LINE> target , NULL ) ; <NEW_LINE> <START_VULN> ctxt -> instate = state ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> } <NEW_LINE> buf = ( xmlChar * ) xmlMallocAtomic ( size * sizeof ( xmlChar ) ) ;
#endif <NEW_LINE> if ( ! is_anonymous ) { <NEW_LINE> <START_VULN> if ( s && s > filename ) { <NEW_LINE> <END_VULN> safe_php_register_variable ( lbuf , s + 1 , strlen ( s + 1 ) , NULL , 0 TSRMLS_CC ) ; <NEW_LINE> } else { <NEW_LINE> safe_php_register_variable ( lbuf , filename , strlen ( filename ) , NULL , 0 TSRMLS_CC ) ;
<START_VULN> class LogMessage { <NEW_LINE> <END_VULN> public: <NEW_LINE> LogMessage ( const char * file , int line , LogSeverity severity , int ctr ) ;
nsresult <NEW_LINE> nsHTMLDocument::WriteCommon ( const nsAString & aText , <NEW_LINE> PRBool aNewlineTerminate ) <NEW_LINE> { <NEW_LINE> mTooDeepWriteRecursion = <NEW_LINE> ( mWriteLevel > NS_MAX_DOCUMENT_WRITE_DEPTH || mTooDeepWriteRecursion ) ; <NEW_LINE> NS_ENSURE_STATE ( ! mTooDeepWriteRecursion ) ; <NEW_LINE> <START_VULN> if ( ! IsHTML ( ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_DOM_INVALID_ACCESS_ERR ; <NEW_LINE> } <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> void * key = GenerateParserKey ( ) ;
txStack mResultHandlerStack ; <NEW_LINE> txStack mParamStack ; <NEW_LINE> txInstruction * mNextInstruction ; <NEW_LINE> txVariableMap * mLocalVariables ; <NEW_LINE> txVariableMap mGlobalVariableValues ; <NEW_LINE> nsRefPtr < txAExprResult > mGlobalVarPlaceholderValue ; <NEW_LINE> PRInt32 mRecursionDepth ; <NEW_LINE> <START_VULN> TemplateRule * mTemplateRules ; <NEW_LINE>PRInt32 mTemplateRulesBufferSize ; <NEW_LINE>PRInt32 mTemplateRuleCount ; <NEW_LINE> <END_VULN> txIEvalContext * mEvalContext ; <NEW_LINE> txIEvalContext * mInitialEvalContext ; <NEW_LINE> txOwningExpandedNameMap < txIGlobalParameter > * mGlobalParams ; <NEW_LINE> txLoadedDocumentsHash mLoadedDocuments ; <NEW_LINE> txKeyHash mKeyHash ;
#include < ft2build . h > <NEW_LINE> #include FT_CONFIG_CONFIG_H <NEW_LINE> #include FT_INTERNAL_OBJECTS_H <NEW_LINE> #include FT_INTERNAL_DEBUG_H <NEW_LINE> #include FT_MODULE_H <NEW_LINE> #include "basepic . h" <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #undef FT_COMPONENT <NEW_LINE> #define FT_COMPONENT trace_init
private: <NEW_LINE> <START_VULN> void OnDecode ( base::SharedMemoryHandle handle , int32 id , int32 size ) ; <NEW_LINE> <END_VULN> void OnAssignPictureBuffers ( <NEW_LINE> const std::vector < int32 > & buffer_ids , <NEW_LINE> const std::vector < uint32 > & texture_ids ,
if ( copy_from_user ( & getaddrs , optval , len ) ) <NEW_LINE> return - EFAULT ; <NEW_LINE> <START_VULN> if ( getaddrs . addr_num <= 0 ) return - EINVAL ; <NEW_LINE> <END_VULN> if ( 0 == getaddrs . assoc_id ) { <NEW_LINE> bp = & sctp_sk ( sk ) -> ep -> base . bind_addr ;
b ++ ; <NEW_LINE> } <NEW_LINE> if ( lines ) <NEW_LINE> <START_VULN> last = RCAST ( const char * , s ) + nbytes ; <NEW_LINE> <END_VULN> ms -> search . s = buf ; <NEW_LINE> ms -> search . s_len = last - buf ;
ogg_uint16_t * t = ( ogg_uint16_t * ) book -> dec_table ; <NEW_LINE> for ( i = 0 ; i < read ; i ++ ) { <NEW_LINE> <START_VULN> int bit = ( lok >> i ) & 1 ; <NEW_LINE>int next = t [ chase + bit ] ; <NEW_LINE>if ( next & 0x8000 ) { <NEW_LINE>chase = ( next << 16 ) | t [ chase + bit + 1 + ( ! bit || t [ chase ] & 0x8000 ) ] ; <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>chase = next ; <NEW_LINE> <END_VULN> } <NEW_LINE> chase &= ~ 0x80000000UL ;
} ; <NEW_LINE> <START_VULN> const interp_kernel vp9_filteredinterp_filters875 [ ( 1 << SUBPEL_BITS ) ] = { <NEW_LINE> <END_VULN> { 3 , - 8 , 13 , 112 , 13 , - 8 , 3 , 0 } , <NEW_LINE> { 3 , - 7 , 10 , 112 , 17 , - 9 , 3 , - 1 } , <NEW_LINE> { 2 , - 6 , 7 , 111 , 21 , - 9 , 3 , - 1 } ,
nsresult SharedOutputString ( uint32_t aFlags , bool * aIsCollapsed , nsAString & aResult ) ; <NEW_LINE> bool IsModifiable ( ) ; <NEW_LINE> bool CanCutOrCopy ( ) ; <NEW_LINE> <START_VULN> bool FireClipboardEvent ( int32_t aType ) ; <NEW_LINE> <END_VULN> bool UpdateMetaCharset ( nsIDOMDocument * aDocument , <NEW_LINE> const nsACString & aCharacterSet ) ; <NEW_LINE> protected: <NEW_LINE> nsCOMPtr < nsIEditRules > mRules ;
#ifdef PNG_READ_pCAL_SUPPORTED <NEW_LINE> else if ( chunk_name == png_pCAL ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_pCAL ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
private: <NEW_LINE> already_AddRefed < nsIAtom > GetNameAtom ( nsIContent * aContent ) ; <NEW_LINE> void EnsureChildState ( ) ; <NEW_LINE> <START_VULN> void doRemoveChild ( ) ; <NEW_LINE> <END_VULN> nsString mValue ; <NEW_LINE> nsIContent * mChild ; <NEW_LINE> mozilla::dom::Element * GetContentInternal ( ) const
ND_PRINT ( ( ndo , " ( length bogus , should be = 6 ) " ) ) ; <NEW_LINE> return len ; <NEW_LINE> } <NEW_LINE> <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , ": Magic - Num 0x % 08x" , EXTRACT_32BITS ( p + 2 ) ) ) ; <NEW_LINE> break ; <NEW_LINE> default:
xmlCatalogCleanup ( ) ; <NEW_LINE> ret = B_OK ; <NEW_LINE> for ( i = 0 ; i < num_threads ; i ++ ) <NEW_LINE> <START_VULN> if ( results [ i ] != ( void * ) Okay ) { <NEW_LINE>printf ( "Thread % d handling % s failed\n" , i , testfiles [ i ] ) ; <NEW_LINE> <END_VULN> ret = B_ERROR ; <NEW_LINE> } <NEW_LINE> }
explicit SkAutoTMalloc ( size_t count ) { <NEW_LINE> <START_VULN> fPtr = count ? ( T * ) sk_malloc_flags ( count * sizeof ( T ) , SK_MALLOC_THROW ) : nullptr ; <NEW_LINE> <END_VULN> } <NEW_LINE> SkAutoTMalloc ( SkAutoTMalloc < T > && that ) : fPtr ( that . release ( ) ) { }
status_t NuPlayer::GenericSource::setBuffers ( <NEW_LINE> bool audio , Vector < MediaBuffer * > & buffers ) { <NEW_LINE> <START_VULN> if ( mIsSecure && ! audio ) { <NEW_LINE> <END_VULN> return mVideoTrack . mSource -> setBuffers ( buffers ) ; <NEW_LINE> } <NEW_LINE> return INVALID_OPERATION ;
{ <NEW_LINE> IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; <NEW_LINE> WORD32 value ; <NEW_LINE> <START_VULN> WORD32 i ; <NEW_LINE> <END_VULN> WORD32 sps_id ; <NEW_LINE> pps_t * ps_pps ;
OD ( nsExtEntityLogo , SEC_OID_NS_CERT_EXT_ENTITY_LOGO , <NEW_LINE> "Certificate Entity Logo" , <NEW_LINE> CKM_INVALID_MECHANISM , UNSUPPORTED_CERT_EXTENSION ) , <NEW_LINE> OD ( nsExtUserPicture , SEC_OID_NS_CERT_EXT_USER_PICTURE , <NEW_LINE> "Certificate User Picture" , <NEW_LINE> CKM_INVALID_MECHANISM , UNSUPPORTED_CERT_EXTENSION ) , <NEW_LINE> OD ( nsExtSSLServerName , SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME , <NEW_LINE> "Certificate SSL Server Name" , <NEW_LINE> <START_VULN> CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , <NEW_LINE> <END_VULN> OD ( nsExtComment , SEC_OID_NS_CERT_EXT_COMMENT , <NEW_LINE> "Certificate Comment" , <NEW_LINE> CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , <NEW_LINE> OD ( nsExtLostPasswordURL , SEC_OID_NS_CERT_EXT_LOST_PASSWORD_URL , <NEW_LINE> "Lost Password URL" , <NEW_LINE> CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , <NEW_LINE> OD ( nsExtCertRenewalTime , SEC_OID_NS_CERT_EXT_CERT_RENEWAL_TIME , <NEW_LINE> "Certificate Renewal Time" ,
scoped_ptr < views::FocusSearch > focus_search_ ; <NEW_LINE> #if ! defined ( OS_MACOSX ) <NEW_LINE> <START_VULN> scoped_ptr < views::MenuRunner > overflow_menu_runner_ ; <NEW_LINE><NEW_LINE> <END_VULN> scoped_ptr < views::MenuRunner > launcher_menu_runner_ ; <NEW_LINE> #endif <NEW_LINE> ObserverList < LauncherIconObserver > observers_ ; <NEW_LINE> ShelfAlignment alignment_ ; <NEW_LINE> DISALLOW_COPY_AND_ASSIGN ( LauncherView ) ; <NEW_LINE> } ;
} <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsWindow::SetCursor ( nsCursor aCursor ) <NEW_LINE> { <NEW_LINE> if ( ! mContainer && mDrawingarea ) { <NEW_LINE> <START_VULN> nsWindow * window ; <NEW_LINE>GetContainerWindow ( & window ) ; <NEW_LINE> <END_VULN> return window -> SetCursor ( aCursor ) ; <NEW_LINE> } <NEW_LINE> if ( aCursor != mCursor ) { <NEW_LINE> GdkCursor * newCursor = NULL ; <NEW_LINE> newCursor = get_gtk_cursor ( aCursor ) ;
"CurrentTarget should be null ! " ) ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsresult PostHandleEvent ( nsEventChainPostVisitor & aVisitor ) ; <NEW_LINE> <END_VULN> static PRUint32 MaxEtciCount ( ) { return sMaxEtciCount ; } <NEW_LINE> static void ResetMaxEtciCount ( ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( ! sCurrentEtciCount , "Wrong time to call ResetMaxEtciCount ( ) ! " ) ; <NEW_LINE> sMaxEtciCount = 0 ; <NEW_LINE> }
class RDFXMLDataSourceImpl : public nsIRDFDataSource , <NEW_LINE> public nsIRDFRemoteDataSource , <NEW_LINE> public nsIRDFXMLSink , <NEW_LINE> public nsIRDFXMLSource , <NEW_LINE> public nsIStreamListener , <NEW_LINE> <START_VULN> public rdfIDataSource <NEW_LINE> <END_VULN> { <NEW_LINE> protected: <NEW_LINE> enum LoadState { <NEW_LINE> eLoadState_Unloaded , <NEW_LINE> eLoadState_Pending , <NEW_LINE> eLoadState_Loading , <NEW_LINE> eLoadState_Loaded <NEW_LINE> } ;
void RenderSVGBlock::styleDidChange ( StyleDifference diff , const RenderStyle * oldStyle ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( diff == StyleDifferenceLayout ) <NEW_LINE> <END_VULN> setNeedsBoundariesUpdate ( ) ; <NEW_LINE> RenderBlock::styleDidChange ( diff , oldStyle ) ;
res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; <NEW_LINE> if ( res ) <NEW_LINE> <START_VULN> return res ; <NEW_LINE> <END_VULN> res = register_netdevice ( hsr_dev ) ; <NEW_LINE> if ( res )
IDBIndex * aIndex , <NEW_LINE> IDBKeyRange * aKeyRange , <NEW_LINE> IDBCursor::Direction aDirection ) <NEW_LINE> : OpenKeyCursorHelper ( aTransaction , aRequest , aIndex , aKeyRange , aDirection ) <NEW_LINE> { } <NEW_LINE> ~ OpenCursorHelper ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( mCloneReadInfo . mCloneBuffer ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> virtual nsresult DoDatabaseWork ( mozIStorageConnection * aConnection ) <NEW_LINE> MOZ_OVERRIDE ; <NEW_LINE> virtual void ReleaseMainThreadObjects ( ) MOZ_OVERRIDE ; <NEW_LINE> virtual nsresult
telemetry::category _misc_cat ( face . tele . misc ) ; <NEW_LINE> #endif <NEW_LINE> Face::Table silf ( face , Tag::Silf , 0x00050000 ) ; <NEW_LINE> <START_VULN> if ( silf ) options &= ~ gr_face_dumbRendering ; <NEW_LINE>else if ( ! ( options & gr_face_dumbRendering ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> if ( ! face . readGlyphs ( options ) )
#include "core / platform / mediastream / MediaStreamComponent . h" <NEW_LINE> #include "platform / audio / AudioBus . h" <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "platform / UUID . h" <NEW_LINE> #include "public / platform / WebAudioSourceProvider . h" <NEW_LINE> namespace WebCore {
return false ; <NEW_LINE> if ( ! WriteEbmlElement ( writer , kMkvContentEncAlgo , enc_algo_ ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> if ( ! WriteEbmlElement ( writer , <NEW_LINE>kMkvContentEncKeyID , <NEW_LINE>enc_key_id_ , <NEW_LINE> <END_VULN> enc_key_id_length_ ) ) <NEW_LINE> return false ;
specified via mprCreate will be called to allow global recovery . <NEW_LINE> @remarks Do not mix calls to palloc and malloc . <NEW_LINE> @ingroup MprMem <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC void * palloc ( size_t size ) ;
if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "ss | l" , & arg_pattern , & arg_pattern_len , & string , & string_len , & count ) == FAILURE ) { <NEW_LINE> RETURN_FALSE ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> if ( count > 0 ) { <NEW_LINE> count -- ;
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED <NEW_LINE> else if ( ( keep = png_chunk_unknown_handling ( png_ptr , chunk_name ) ) != 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_unknown ( png_ptr , info_ptr , png_ptr -> push_length , keep ) ; <NEW_LINE> if ( chunk_name == png_PLTE )
rec -> usermode = g_strdup ( src -> usermode ) ; <NEW_LINE> rec -> alternate_nick = g_strdup ( src -> alternate_nick ) ; <NEW_LINE> rec -> sasl_mechanism = src -> sasl_mechanism ; <NEW_LINE> <START_VULN> rec -> sasl_username = src -> sasl_username ; <NEW_LINE>rec -> sasl_password = src -> sasl_password ; <NEW_LINE> <END_VULN> * dest = ( SERVER_CONNECT_REC * ) rec ; <NEW_LINE> }
return true ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> process . start ( QString ( " % 1 - s % 2 - c - q - C - L / tmp / partclone . log" ) . arg ( getPartcloneExecuter ( DDevicePartInfo ( partDevice ) ) ) . arg ( partDevice ) ) ; <NEW_LINE> <END_VULN> process . setStandardOutputFile ( " / dev / null" ) ; <NEW_LINE> process . setReadChannel ( QProcess::StandardError ) ; <NEW_LINE> process . waitForStarted ( ) ;
writer_cues_ = chunk_writer_cues_ ; <NEW_LINE> writer_header_ = chunk_writer_header_ ; <NEW_LINE> <START_VULN> delete [ ] header ; <NEW_LINE> <END_VULN> } <NEW_LINE> chunking_ = chunking ;
<START_VULN> #ifndef BASE_DEBUG_DEBUGGER_H <NEW_LINE>#define BASE_DEBUG_DEBUGGER_H <NEW_LINE> <END_VULN> #include "base / base_export . h"
line_start = mLines . begin ( ) ; <NEW_LINE> line_end = mLines . end ( ) ; <NEW_LINE> line = line_end ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> line = mLines . erase ( line ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> lineBox -> Destroy ( aPresContext -> PresShell ( ) ) ; <NEW_LINE> <END_VULN> if ( line != line_end ) { <NEW_LINE> line -> MarkPreviousMarginDirty ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return NS_OK ;
} <NEW_LINE> jsval result ; <NEW_LINE> nsIScriptContext * sc = GetContextForEventHandlers ( & rv ) ; <NEW_LINE> NS_ENSURE_STATE ( sc ) ; <NEW_LINE> <START_VULN> JSContext * cx = sc -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( cx , "Failed to get a context ! " ) ; <NEW_LINE> JSObject * global = sc -> GetNativeGlobal ( ) ; <NEW_LINE> NS_ASSERTION ( global , "Failed to get global object ! " ) ; <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , global ) ;
{ <NEW_LINE> if ( row_info -> bit_depth == 8 ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( flags & PNG_FLAG_FILLER_AFTER ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_bytep sp = row + ( png_size_t ) row_width * 3 ;
#define HAVE_FTIME 1 <NEW_LINE> <START_VULN> #define HAVE_GCRYPT 1 <NEW_LINE> <END_VULN> #define HAVE_GETTIMEOFDAY 1
<START_VULN> bool SafeToDisplayAsUnicode ( base::StringPiece16 label , bool is_tld_ascii ) ; <NEW_LINE> <END_VULN>
nsXBLProtoImplMethod ( EmptyString ( ) . get ( ) ) <NEW_LINE> { } <NEW_LINE> nsresult Execute ( nsIContent * aBoundElement ) ; <NEW_LINE> <START_VULN> virtual nsresult InstallMember ( nsIScriptContext * aContext , <NEW_LINE>nsIContent * aBoundElement , <NEW_LINE>JSObject * aScriptObject , <NEW_LINE>JSObject * aTargetClassObject , <NEW_LINE>const nsCString & aClassStr ) { <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> using nsXBLProtoImplMethod::Write ; <NEW_LINE> nsresult Write ( nsIScriptContext * aContext , <NEW_LINE> nsIObjectOutputStream * aStream , <NEW_LINE> XBLBindingSerializeDetails aType ) ; <NEW_LINE> } ;
continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> CHECK ( dstOffset + 4 <= mBuffer -> size ( ) ) ; <NEW_LINE> <END_VULN> dstData [ dstOffset ++ ] = 0 ; <NEW_LINE> dstData [ dstOffset ++ ] = 0 ;
MACROBLOCKD * const xd = & x -> e_mbd ; <NEW_LINE> struct macroblock_plane * const p = & x -> plane [ plane ] ; <NEW_LINE> struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <NEW_LINE> <START_VULN> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <NEW_LINE> <END_VULN> int i , j ; <NEW_LINE> uint8_t * dst ; <NEW_LINE> txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ;
Parser < SyntaxParseHandler > * parser = handler . syntaxParser ; <NEW_LINE> if ( ! parser ) <NEW_LINE> break ; <NEW_LINE> { <NEW_LINE> TokenStream::Position position ( keepAtoms ) ; <NEW_LINE> tokenStream . tell ( & position ) ; <NEW_LINE> <START_VULN> parser -> tokenStream . seek ( position , tokenStream ) ; <NEW_LINE> <END_VULN> ParseContext < SyntaxParseHandler > funpc ( parser , outerpc , funbox , <NEW_LINE> outerpc -> staticLevel + 1 , outerpc -> blockidGen ) ; <NEW_LINE> if ( ! funpc . init ( ) ) <NEW_LINE> return false ; <NEW_LINE> if ( ! parser -> functionArgsAndBodyGeneric ( SyntaxParseHandler::NodeGeneric , <NEW_LINE> fun , funName , type , kind , strict , becameStrict ) )
} <NEW_LINE> SKIP_BLANKS ; <NEW_LINE> SHRINK ; <NEW_LINE> <START_VULN> while ( RAW != ' ) ' ) { <NEW_LINE> <END_VULN>
ssize_t pathlen = 0 ; <NEW_LINE> if ( node -> parent && node -> graft_path == NULL ) { <NEW_LINE> <START_VULN> pathlen = get_node_path_locked ( node -> parent , buf , bufsize - namelen - 2 ) ; <NEW_LINE> <END_VULN> if ( pathlen < 0 ) { <NEW_LINE> return - 1 ; <NEW_LINE> }
extern struct jump_label_key perf_swevent_enabled [ PERF_COUNT_SW_MAX ] ; <NEW_LINE> <START_VULN> extern void __perf_sw_event ( u32 , u64 , int , struct pt_regs * , u64 ) ; <NEW_LINE> <END_VULN> #ifndef perf_arch_fetch_caller_regs <NEW_LINE> static inline void perf_arch_fetch_caller_regs ( struct pt_regs * regs , unsigned long ip ) { }
public: <NEW_LINE> PlatformSensorWin ( <NEW_LINE> mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> PlatformSensorProvider * provider , <NEW_LINE> scoped_refptr < base::SingleThreadTaskRunner > sensor_thread_runner , <NEW_LINE> std::unique_ptr < PlatformSensorReaderWin > sensor_reader ) ;
{ <NEW_LINE> int status = - 1 ; <NEW_LINE> BYTE descriptor ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> wStream * stream = Stream_New ( ( BYTE * ) pSrcData , SrcSize ) ; <NEW_LINE> if ( ! stream ) <NEW_LINE> return - 1 ;
@param flags Same flags as for #mprJsonToString: MPR_JSON_PRETTY , MPR_JSON_QUOTES , MPR_JSON_STRINGS . <NEW_LINE> @return Zero if successful , otherwise a negative MPR error code . <NEW_LINE> @ingroup MprJson <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC int mprSaveJson ( MprJson * obj , cchar * path , int flags ) ;
png_colorspace_endpoints_match ( const png_xy * xy1 , const png_xy * xy2 , int delta ) <NEW_LINE> { <NEW_LINE> <START_VULN> return ! ( PNG_OUT_OF_RANGE ( xy1 -> whitex , xy2 -> whitex , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> whitey , xy2 -> whitey , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> redx , xy2 -> redx , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> redy , xy2 -> redy , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> greenx , xy2 -> greenx , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> greeny , xy2 -> greeny , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> bluex , xy2 -> bluex , delta ) || <NEW_LINE>PNG_OUT_OF_RANGE ( xy1 -> bluey , xy2 -> bluey , delta ) ) ; <NEW_LINE> <END_VULN> }
ctx -> priv = NULL ; <NEW_LINE> ctx -> init_flags = flags ; <NEW_LINE> ctx -> config . dec = cfg ; <NEW_LINE> <START_VULN> res = VPX_CODEC_OK ; <NEW_LINE>if ( ! ( flags & VPX_CODEC_USE_XMA ) ) { <NEW_LINE>res = ctx -> iface -> init ( ctx , NULL ) ; <NEW_LINE><NEW_LINE>if ( res ) { <NEW_LINE>ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; <NEW_LINE>vpx_codec_destroy ( ctx ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( ctx -> priv ) <NEW_LINE>ctx -> priv -> iface = ctx -> iface ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
0 , NULL , sizeof ( LGEncryptedDataInfo ) } , <NEW_LINE> { SEC_ASN1_INLINE | SEC_ASN1_XTRN , <NEW_LINE> offsetof ( LGEncryptedDataInfo , algorithm ) , <NEW_LINE> SEC_ASN1_SUB ( SECOID_AlgorithmIDTemplate ) } , <NEW_LINE> { SEC_ASN1_OCTET_STRING , <NEW_LINE> offsetof ( LGEncryptedDataInfo , encryptedData ) } , <NEW_LINE> { 0 } <NEW_LINE> } ; <NEW_LINE> <START_VULN> static const unsigned char def_iter_data [ ] = { SEC_ASN1_INTEGER , 0x01 , 0x01 } ; <NEW_LINE>static const SECItem def_iter = { siBuffer , <NEW_LINE> ( unsigned char * ) def_iter_data , <NEW_LINE>sizeof ( def_iter_data ) } ; <NEW_LINE> <END_VULN> static SECItem * <NEW_LINE> nsslowkey_EncodePW ( SECOidTag alg , const SECItem * salt , SECItem * data ) <NEW_LINE> { <NEW_LINE> NSSLowPasswordDataParam param ; <NEW_LINE> LGEncryptedDataInfo edi ; <NEW_LINE> PLArenaPool * arena ; <NEW_LINE> unsigned char one = 1 ; <NEW_LINE> SECItem * epw = NULL ; <NEW_LINE> SECItem * encParam ; <NEW_LINE> SECStatus rv ; <NEW_LINE> param . salt = * salt ; <NEW_LINE> param . iter . data = & one ; <NEW_LINE> param . iter . len = 1 ; <NEW_LINE> edi . encryptedData = * data ; <NEW_LINE> arena = PORT_NewArena ( DER_DEFAULT_CHUNKSIZE ) ; <NEW_LINE> if ( arena == NULL ) {
else if ( ( out_ct & PNG_COLOR_MASK_ALPHA ) != 0 ) <NEW_LINE> output_alpha = sample ( pRow , out_ct , out_bd , x , <NEW_LINE> <START_VULN> samples_per_pixel ) ; <NEW_LINE> <END_VULN> if ( output_alpha != 65536 ) <NEW_LINE> alpha = gamma_component_validate ( "alpha" , & vi , input_alpha ,
continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( verify_vc_kbmode ( fd_d ) < 0 ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> toggle_utf8 ( ttyname , fd_d , utf8 ) ;
RootedScript tableScript ( cx , script ) ; <NEW_LINE> if ( ! tableScript ) { <NEW_LINE> tableScript = JS_GetFunctionScript ( cx , function ) ; <NEW_LINE> MOZ_ASSERT ( tableScript ) ; <NEW_LINE> } <NEW_LINE> * aTableScript = tableScript ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>mThisObjects . Put ( tableScript , obj ) ; <NEW_LINE> <END_VULN> bool ok = false ; <NEW_LINE> { <NEW_LINE> AutoSaveContextOptions asco ( cx ) ; <NEW_LINE> if ( aPropagateExceptions ) <NEW_LINE> ContextOptionsRef ( cx ) . setDontReportUncaught ( true ) ; <NEW_LINE> if ( script ) { <NEW_LINE> ok = JS_ExecuteScriptVersion ( cx , obj , script , nullptr , JSVERSION_LATEST ) ;
virtual bool IsTransportSeekable ( ) = 0 ; <NEW_LINE> <START_VULN> static MediaResource * Create ( MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <NEW_LINE> <END_VULN> virtual nsresult Open ( nsIStreamListener ** aStreamListener ) = 0 ;
} <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( eval ) { <NEW_LINE> zval v ;
{ <NEW_LINE> } <NEW_LINE> <START_VULN> #define for_each_leaf_cfs_rq_safe ( rq , cfs_rq , pos ) \ <NEW_LINE>for ( cfs_rq = & rq -> cfs , pos = NULL ; cfs_rq ; cfs_rq = pos ) <NEW_LINE> <END_VULN> static inline struct sched_entity * parent_entity ( struct sched_entity * se ) <NEW_LINE> {
ND_PRINT ( ( ndo , " ( length bogus , should be >= 4 ) " ) ) ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <NEW_LINE> <END_VULN> if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) <NEW_LINE> ND_PRINT ( ( ndo , ": LQR" ) ) ; <NEW_LINE> else
if ( eventfd_read ( semaphore -> fd , & value ) == - 1 ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> if ( fcntl ( semaphore -> fd , F_SETFL , flags ) == - 1 ) <NEW_LINE> <END_VULN> LOG_ERROR ( " % s unable to resetore flags for semaphore fd: % s" , __func__ , strerror ( errno ) ) ; <NEW_LINE> return true ; <NEW_LINE> }
if ( mRunsToCompletion ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> GetParser ( ) -> DropStreamParser ( ) ; <NEW_LINE> <START_VULN> DidBuildModelImpl ( aTerminated ) ; <NEW_LINE> <END_VULN> if ( ! mLayoutStarted ) {
len += l ; <NEW_LINE> NEXTL ( l ) ; <NEW_LINE> c = CUR_CHAR ( l ) ; <NEW_LINE> <START_VULN> if ( c == 0 ) { <NEW_LINE>count = 0 ; <NEW_LINE>GROW ; <NEW_LINE>if ( ctxt -> instate == XML_PARSER_EOF ) <NEW_LINE>return ( NULL ) ; <NEW_LINE>c = CUR_CHAR ( l ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> if ( ( len > XML_MAX_NAME_LENGTH ) && <NEW_LINE> ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) { <NEW_LINE> xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "Name" ) ; <NEW_LINE> return ( NULL ) ; <NEW_LINE> } <NEW_LINE> if ( ( * ctxt -> input -> cur == '\n' ) && ( ctxt -> input -> cur [ - 1 ] == '\r' ) ) <NEW_LINE> return ( xmlDictLookup ( ctxt -> dict , ctxt -> input -> cur - ( len + 1 ) , len ) ) ; <NEW_LINE> return ( xmlDictLookup ( ctxt -> dict , ctxt -> input -> cur - len , len ) ) ;
png_ptr -> idat_size = png_ptr -> push_length ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( png_ptr -> idat_size && png_ptr -> save_buffer_size ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_size_t save_size = png_ptr -> save_buffer_size ; <NEW_LINE> png_uint_32 idat_size = png_ptr -> idat_size ;
#include < unicode / locid . h > <NEW_LINE> #include < unicode / uchar . h > <NEW_LINE> #include "core / platform / graphics / chromium / UniscribeHelper . h" <NEW_LINE> <START_VULN> #include "core / platform / win / HWndDC . h" <NEW_LINE> <END_VULN> #include "wtf / HashMap . h" <NEW_LINE> #include "wtf / text / StringHash . h" <NEW_LINE> #include "wtf / text / WTFString . h"
} <NEW_LINE> static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx , <NEW_LINE> <START_VULN> int ctr_id , <NEW_LINE>va_list args ) <NEW_LINE> <END_VULN> { <NEW_LINE> vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ;
c = CUR_CHAR ( l ) ; <NEW_LINE> } <NEW_LINE> if ( ( in_space ) && ( normalize ) ) { <NEW_LINE> <START_VULN> while ( buf [ len - 1 ] == 0x20 ) len -- ; <NEW_LINE> <END_VULN> } <NEW_LINE> buf [ len ] = 0 ; <NEW_LINE> if ( RAW == ' < ' ) {
int8_t bfhBuffer [ BMPFILEHEADERSIZE ] ; <NEW_LINE> if ( ! FillBitmapFileHeaderBuffer ( bfhBuffer ) ) { <NEW_LINE> PostDataError ( ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! WriteToContainedDecoder ( ( const char * ) bfhBuffer , sizeof ( bfhBuffer ) ) ) { <NEW_LINE> <END_VULN> return ; <NEW_LINE> } <NEW_LINE> SetHotSpotIfCursor ( ) ;
SH_TIMING_RESTRICTIONS = 0x0200 , <NEW_LINE> <START_VULN> SH_DEPENDENCY_GRAPH = 0x0400 <NEW_LINE> <END_VULN> } ShCompileOptions ; <NEW_LINE> COMPILER_EXPORT int ShInitialize ( ) ;
const string16 & keyword , <NEW_LINE> const AutocompleteInput & input ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> virtual void Start ( const AutocompleteInput & input , <NEW_LINE> bool minimal_changes ) OVERRIDE ; <NEW_LINE> virtual void Stop ( ) OVERRIDE ;
: . . . . . . . . . . . . . . ___ | | <NEW_LINE> : . ''' | ` / \ | | <NEW_LINE> : . . . . . ''' | / ` . . . . \ | . . . | <NEW_LINE> : . . . . . . . . . . . . . . . . . . . . . . . . . | ___ | ___ | ___ | <NEW_LINE> | Sl | Sr | endW <NEW_LINE> | | | endSr <NEW_LINE> | | beginSr <NEW_LINE> | | endSl <NEW_LINE> <START_VULN> | beginSl <NEW_LINE> | beginW <NEW_LINE> <END_VULN> #ifndef WORD_ALIGN <NEW_LINE> #define WORD_ALIGN 8 <NEW_LINE> #endif
continue ; <NEW_LINE> } else { <NEW_LINE> if ( node == oldnode ) <NEW_LINE> break ; <NEW_LINE> <START_VULN> node = node -> next ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef LIBXML_REGEXP_ENABLED <NEW_LINE> } else if ( node -> type == XML_ELEMENT_NODE ) {
} ; <NEW_LINE> static const uint32_t EUCJPCharLenTable [ ] = { 2 , 2 , 2 , 3 , 1 , 0 } ; <NEW_LINE> const SMModel EUCJPSMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , EUCJP_cls } , <NEW_LINE> 6 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , EUCJP_st } , <NEW_LINE> <START_VULN> EUCJPCharLenTable , <NEW_LINE> <END_VULN> "EUC - JP" , <NEW_LINE> } ; <NEW_LINE> static const uint32_t EUCKR_cls [ 256 / 8 ] = { <NEW_LINE> PCK4BITS ( 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ) , <NEW_LINE> PCK4BITS ( 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 ) , <NEW_LINE> PCK4BITS ( 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ) ,
bool adapter_enable_disable ( ) { <NEW_LINE> int error ; <NEW_LINE> <START_VULN> CALL_AND_WAIT ( error = bt_interface -> enable ( ) , adapter_state_changed ) ; <NEW_LINE> <END_VULN> TASSERT ( error == BT_STATUS_SUCCESS , "Error enabling Bluetooth: % d" , error ) ; <NEW_LINE> TASSERT ( adapter_get_state ( ) == BT_STATE_ON , "Adapter did not turn on . " ) ;
int insn_get_code_seg_params ( struct pt_regs * regs ) <NEW_LINE> { <NEW_LINE> <START_VULN> struct desc_struct * desc ; <NEW_LINE> <END_VULN> short sel ; <NEW_LINE> if ( v8086_mode ( regs ) )
dmaaddr = meta -> dmaaddr ; <NEW_LINE> goto drop_recycle_buffer ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( unlikely ( len > ring -> rx_buffersize ) ) { <NEW_LINE> <END_VULN>
public: <NEW_LINE> <START_VULN> HistoryContentsProvider ( ACProviderListener * listener , <NEW_LINE> <END_VULN> Profile * profile , <NEW_LINE> bool body_only ) ;
RETVAL_BOOL ( phar_open_from_filename ( fname , fname_len , alias , alias_len , REPORT_ERRORS , NULL , & error TSRMLS_CC ) == SUCCESS ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> } <NEW_LINE> }
char delimiter = intern -> u . file . delimiter , enclosure = intern -> u . file . enclosure , escape = intern -> u . file . escape ; <NEW_LINE> char * delim = NULL , * enclo = NULL , * esc = NULL ; <NEW_LINE> int d_len = 0 , e_len = 0 , esc_len = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , " | sss" , & delim , & d_len , & enclo , & e_len , & esc , & esc_len ) == SUCCESS ) { <NEW_LINE> switch ( ZEND_NUM_ARGS ( ) ) <NEW_LINE> {
nsresult Init ( ) ; <NEW_LINE> void LoadDictionaryList ( ) ; <NEW_LINE> nsresult ConvertCharset ( const PRUnichar * aStr , char ** aDst ) ; <NEW_LINE> <START_VULN> static void OnAlloc ( void * ptr ) { sAmount += MallocSizeOfOnAlloc ( ptr ) ; } <NEW_LINE>static void OnFree ( void * ptr ) { sAmount - = MallocSizeOfOnFree ( ptr ) ; } <NEW_LINE><NEW_LINE>int64_t Amount ( ) MOZ_OVERRIDE { return sAmount ; } <NEW_LINE> <END_VULN> protected: <NEW_LINE> nsCOMPtr < mozIPersonalDictionary > mPersonalDictionary ; <NEW_LINE> nsCOMPtr < nsIUnicodeEncoder > mEncoder ; <NEW_LINE> nsCOMPtr < nsIUnicodeDecoder > mDecoder ;
} <NEW_LINE> } <NEW_LINE> else <NEW_LINE> <START_VULN> memcpy ( data , src , CV_ELEM_SIZE1 ( m_type ) * m_width ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else <NEW_LINE> {
namespace o3d { <NEW_LINE> namespace gpu2d { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN>
containerRenderer -> style ( ) -> setWidth ( Length ( ) ) ; <NEW_LINE> } <NEW_LINE> RenderObject * innerTextRenderer = innerTextElement ( ) -> renderer ( ) ; <NEW_LINE> <START_VULN> if ( innerTextRenderer && diff == StyleDifferenceLayout ) <NEW_LINE> <END_VULN> innerTextRenderer -> setNeedsLayout ( ) ; <NEW_LINE> if ( HTMLElement * placeholder = inputElement ( ) -> placeholderElement ( ) ) <NEW_LINE> placeholder -> setInlineStyleProperty ( CSSPropertyTextOverflow , textShouldBeTruncated ( ) ? CSSValueEllipsis : CSSValueClip ) ;
} <NEW_LINE> int res_inverse ( vorbis_dsp_state * vd , vorbis_info_residue * info , <NEW_LINE> <START_VULN> ogg_int32_t ** in , int * nonzero , int ch ) { <NEW_LINE> <END_VULN> int i , j , k , s , used = 0 ; <NEW_LINE> codec_setup_info * ci = ( codec_setup_info * ) vd -> vi -> codec_setup ;
if ( NS_FAILED ( targetBaseURI -> GetScheme ( targetScheme ) ) || <NEW_LINE> NS_FAILED ( sourceBaseURI -> SchemeIs ( targetScheme . get ( ) , & sameScheme ) ) || <NEW_LINE> ! sameScheme ) <NEW_LINE> { <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( targetScheme . EqualsLiteral ( "file" ) ) <NEW_LINE> { <NEW_LINE> if ( ! aStrictFileOriginPolicy ) <NEW_LINE> return true ; <NEW_LINE> nsCOMPtr < nsIFileURL > sourceFileURL ( do_QueryInterface ( sourceBaseURI ) ) ; <NEW_LINE> nsCOMPtr < nsIFileURL > targetFileURL ( do_QueryInterface ( targetBaseURI ) ) ;
nsCOMPtr < nsPIDOMWindow > window = GetWindow ( ) ; <NEW_LINE> if ( window ) { <NEW_LINE> nsCOMPtr < nsPIDOMWindow > focusedWindow ; <NEW_LINE> nsIContent * focusedContent = <NEW_LINE> nsFocusManager::GetFocusedDescendant ( window , false , <NEW_LINE> getter_AddRefs ( focusedWindow ) ) ; <NEW_LINE> if ( focusedContent && focusedContent -> OwnerDoc ( ) == this ) { <NEW_LINE> <START_VULN> if ( focusedContent -> IsInNativeAnonymousSubtree ( ) ) { <NEW_LINE> <END_VULN> focusedContent = focusedContent -> FindFirstNonNativeAnonymous ( ) ; <NEW_LINE> } <NEW_LINE> if ( focusedContent ) { <NEW_LINE> CallQueryInterface ( focusedContent , aElement ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
nscoord charMaxAdvance = 0 ; <NEW_LINE> nsCOMPtr < nsIFontMetrics > fontMet ; <NEW_LINE> nsresult rv = <NEW_LINE> nsLayoutUtils::GetFontMetricsForFrame ( this , getter_AddRefs ( fontMet ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> aRenderingContext -> SetFont ( fontMet ) ; <NEW_LINE> <START_VULN> lineHeight = nsHTMLReflowState::CalcLineHeight ( this ) ; <NEW_LINE> <END_VULN> fontMet -> GetAveCharWidth ( charWidth ) ; <NEW_LINE> fontMet -> GetMaxAdvance ( charMaxAdvance ) ; <NEW_LINE> PRInt32 cols = GetCols ( ) ; <NEW_LINE> aIntrinsicSize . width = cols * charWidth ;
{ <NEW_LINE> png_ptr -> process_mode = PNG_READ_CHUNK_MODE ; <NEW_LINE> <START_VULN> if ( ! ( png_ptr -> flags & PNG_FLAG_ZSTREAM_ENDED ) ) <NEW_LINE> <END_VULN> png_error ( png_ptr , "Not enough compressed data" ) ; <NEW_LINE> return ;
void * SoftMP3::memsetSafe ( OMX_BUFFERHEADERTYPE * outHeader , int c , size_t len ) { <NEW_LINE> if ( len > outHeader -> nAllocLen ) { <NEW_LINE> <START_VULN> ALOGE ( "memset buffer too small: got % lu , expected % zu" , ( unsigned long ) outHeader -> nAllocLen , len ) ; <NEW_LINE> <END_VULN> android_errorWriteLog ( 0x534e4554 , "29422022" ) ; <NEW_LINE> notify ( OMX_EventError , OMX_ErrorUndefined , OUTPUT_BUFFER_TOO_SMALL , NULL ) ; <NEW_LINE> mSignalledError = true ;
float AudioParam::finalValue ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> float value ; <NEW_LINE> <END_VULN> calculateFinalValues ( & value , 1 , false ) ; <NEW_LINE> return value ; <NEW_LINE> }
xmlXPathObjectPtr <NEW_LINE> xmlXPathEval ( const xmlChar * str , xmlXPathContextPtr ctx ) { <NEW_LINE> xmlXPathParserContextPtr ctxt ; <NEW_LINE> <START_VULN> xmlXPathObjectPtr res , tmp , init = NULL ; <NEW_LINE>int stack = 0 ; <NEW_LINE> <END_VULN> CHECK_CTXT ( ctx )
if ( hdr ) * hdr = atom ; <NEW_LINE> if ( val ) * val = p ; <NEW_LINE> <START_VULN> SetHeader ( atom , nsDependentCString ( p , p2 - p ) , PR_TRUE ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsHttpHeaderArray::Flatten ( nsACString & buf , PRBool pruneProxyHeaders ) <NEW_LINE> { <NEW_LINE> PRUint32 i , count = mHeaders . Length ( ) ; <NEW_LINE> for ( i = 0 ; i < count ; ++ i ) { <NEW_LINE> const nsEntry & entry = mHeaders [ i ] ;
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> const String & strArg ( ustringToString ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . isEmpty ( ) ? UString ( ) : MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . toString ( exec ) -> value ( exec ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
<START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> static bool ShouldLockToOrigin ( BrowserContext * browser_context , <NEW_LINE> GURL site_url ) ;
bool used_ = false ; <NEW_LINE> State state_ = CREATED ; <NEW_LINE> bool commit_pending_ = false ; <NEW_LINE> <START_VULN> <NEW_LINE>IndexedDBConnection * connection_ ; <NEW_LINE> <END_VULN> scoped_refptr < IndexedDBDatabaseCallbacks > callbacks_ ; <NEW_LINE> scoped_refptr < IndexedDBDatabase > database_ ;
} <NEW_LINE> ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type , <NEW_LINE> <START_VULN> mntflags , mntdata , optional ) ; <NEW_LINE> <END_VULN> free ( mntdata ) ;
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeContentView::SetCellValue ( PRInt32 aRow , nsITreeColumn * aCol , const nsAString & aValue ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ENSURE_ARG_POINTER ( aCol ) ; <NEW_LINE> <END_VULN> NS_PRECONDITION ( aRow >= 0 && aRow < PRInt32 ( mRows . Length ( ) ) , "bad row" ) ; <NEW_LINE> if ( aRow < 0 || aRow >= PRInt32 ( mRows . Length ( ) ) ) <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> Row * row = mRows [ aRow ] ; <NEW_LINE> nsIContent * realRow = <NEW_LINE> nsTreeUtils::GetImmediateChild ( row -> mContent , nsGkAtoms::treerow ) ;
nsDocAccessible ( nsIDocument * aDocument , nsIContent * aRootContent , <NEW_LINE> nsIWeakReference * aShell ) : <NEW_LINE> nsHyperTextAccessibleWrap ( aRootContent , aShell ) , <NEW_LINE> <START_VULN> mDocument ( aDocument ) , mScrollPositionChangedTicks ( 0 ) , mIsLoaded ( PR_FALSE ) , <NEW_LINE>mCacheRoot ( nsnull ) , mIsPostCacheProcessing ( PR_FALSE ) <NEW_LINE> <END_VULN> { <NEW_LINE> mFlags |= eDocAccessible ;
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> UpgradeSchemaFrom7To8 ( mozIStorageConnection * aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "UpgradeSchemaFrom7To8" ) ; <NEW_LINE> nsresult rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( <NEW_LINE> "CREATE TEMPORARY TABLE temp_upgrade ( " <NEW_LINE> "id , " <NEW_LINE> "object_store_id , "
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . overloadedMethod3" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , strArg , MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ; <NEW_LINE> imp -> overloadedMethod ( strArg ) ;
eindex = handle ; <NEW_LINE> estr -> event_source = 0 ; <NEW_LINE> <START_VULN> if ( eindex >= MAX_EVENTS ) { <NEW_LINE> <END_VULN> spin_unlock_irqrestore ( & ha -> smp_lock , flags ) ; <NEW_LINE> return eindex ; <NEW_LINE> }
HRESULT rv ; <NEW_LINE> Uniscribe us ( aContext , aDC , aString , aLength , isRTL ) ; <NEW_LINE> int numItems = us . Itemize ( ) ; <NEW_LINE> for ( int i = 0 ; i < numItems ; ++ i ) { <NEW_LINE> SaveDC ( aDC ) ; <NEW_LINE> <START_VULN> nsAutoPtr < UniscribeItem > item ( us . GetItem ( i , this ) ) ; <NEW_LINE><NEW_LINE> <END_VULN> mItemLangGroup = nsnull ; <NEW_LINE> const SCRIPT_PROPERTIES * sp = item -> ScriptProperties ( ) ; <NEW_LINE> if ( ! sp -> fAmbiguousCharSet ) { <NEW_LINE> WORD primaryId = PRIMARYLANGID ( sp -> langid ) ; <NEW_LINE> mItemLangGroup = gScriptToText [ primaryId ] . langCode ; <NEW_LINE> }
} <NEW_LINE> fname = Z_STRVAL_P ( value ) ; <NEW_LINE> <START_VULN> fname_len = ( php_stat_len ) Z_STRLEN_P ( value ) ; <NEW_LINE> <END_VULN> phar_spl_fileinfo: <NEW_LINE> if ( base_len ) {
nsWindowRoot:: ~ nsWindowRoot ( ) <NEW_LINE> { <NEW_LINE> if ( mListenerManager ) { <NEW_LINE> mListenerManager -> Disconnect ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_3 ( nsWindowRoot , <NEW_LINE> <END_VULN> mListenerManager , <NEW_LINE> mPopupNode , <NEW_LINE> mParent ) <NEW_LINE> NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION ( nsWindowRoot ) <NEW_LINE> NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY <NEW_LINE> NS_INTERFACE_MAP_ENTRY_AMBIGUOUS ( nsISupports , nsIDOMEventTarget ) <NEW_LINE> NS_INTERFACE_MAP_ENTRY ( nsPIWindowRoot )
virtual bool BypassListIsReversed ( ) = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>virtual bool MatchHostsUsingSuffixMatching ( ) = 0 ; <NEW_LINE> <END_VULN> private: <NEW_LINE> DISALLOW_COPY_AND_ASSIGN ( SettingGetter ) ;
virtual bool OnMakeCurrent ( gfx::GLContext * context ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void OnBufferPresented ( bool presented , <NEW_LINE> <END_VULN> uint32 sync_point ) OVERRIDE ; <NEW_LINE> virtual void OnResizeViewACK ( ) OVERRIDE ; <NEW_LINE> virtual void OnResize ( gfx::Size size ) OVERRIDE ;
} <NEW_LINE> bool <NEW_LINE> GetElementParIC::attachTypedArrayElement ( LockedJSContext & cx , IonScript * ion , <NEW_LINE> TypedArrayObject * tarr , const Value & idval ) <NEW_LINE> { <NEW_LINE> MacroAssembler masm ( cx ) ; <NEW_LINE> DispatchStubPrepender attacher ( * this ) ; <NEW_LINE> <START_VULN> GenerateGetTypedArrayElement ( cx , masm , attacher , tarr , idval , object ( ) , index ( ) , output ( ) ) ; <NEW_LINE> <END_VULN> return linkAndAttachStub ( cx , masm , attacher , ion , "parallel typed array" ) ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> GetElementParIC::update ( ForkJoinSlice * slice , size_t cacheIndex , HandleObject obj , <NEW_LINE> HandleValue idval , MutableHandleValue vp ) <NEW_LINE> { <NEW_LINE> AutoFlushCache afc ( "GetElementParCache" , slice -> runtime ( ) -> jitRuntime ( ) ) ;
#include "core / dom / ScriptExecutionContext . h" <NEW_LINE> #include "core / fileapi / Blob . h" <NEW_LINE> #include "core / fileapi / BlobURL . h" <NEW_LINE> #include "core / fileapi / FileReaderLoaderClient . h" <NEW_LINE> <START_VULN> #include "core / fileapi / ThreadableBlobRegistry . h" <NEW_LINE> <END_VULN> #include "core / loader / TextResourceDecoder . h" <NEW_LINE> #include "core / loader / ThreadableLoader . h" <NEW_LINE> #include "core / platform / network / ResourceRequest . h"
{ <NEW_LINE> if ( isFloating ( ) ) <NEW_LINE> return "RenderGrid ( floating ) " ; <NEW_LINE> <START_VULN> if ( isPositioned ( ) ) <NEW_LINE> <END_VULN> return "RenderGrid ( positioned ) " ; <NEW_LINE> if ( isAnonymous ( ) ) <NEW_LINE> return "RenderGrid ( generated ) " ;
{ "classInitNative" , " ( ) V" , ( void * ) classInitNative } , <NEW_LINE> { "initNative" , " ( ) Z" , ( void * ) initNative } , <NEW_LINE> { "cleanupNative" , " ( ) V" , ( void * ) cleanupNative } , <NEW_LINE> <START_VULN> { "enableNative" , " ( ) Z" , ( void * ) enableNative } , <NEW_LINE> <END_VULN> { "disableNative" , " ( ) Z" , ( void * ) disableNative } , <NEW_LINE> { "setAdapterPropertyNative" , " ( I [ B ) Z" , ( void * ) setAdapterPropertyNative } , <NEW_LINE> { "getAdapterPropertiesNative" , " ( ) Z" , ( void * ) getAdapterPropertiesNative } ,
void SMILTimeContainer::begin ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> ASSERT ( ! m_beginTime ) ; <NEW_LINE> <END_VULN> double now = currentTime ( ) ;
{ <NEW_LINE> nsNSSShutDownPreventionLock locker ; <NEW_LINE> JSPrincipals * principals ; <NEW_LINE> <START_VULN> JSContext * cx = m_args -> m_cx ; <NEW_LINE> <END_VULN> nsresult rv = m_args -> m_principals -> GetJSPrincipals ( cx , & principals ) ; <NEW_LINE> if ( NS_FAILED ( rv ) )
void <NEW_LINE> png_push_save_buffer ( png_structrp png_ptr ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> save_buffer_size ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( png_ptr -> save_buffer_ptr != png_ptr -> save_buffer ) <NEW_LINE> {
unsigned char * dst_buf ; <NEW_LINE> unsigned char * aux_buf ; <NEW_LINE> enum vpx_img_fmt vpx_fmt ; <NEW_LINE> <START_VULN> int vpx_bps ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> int y4m_input_open ( y4m_input * _y4m , FILE * _fin , char * _skip , int _nskip ,
i1_is_end_of_poc = 1 ; <NEW_LINE> ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; <NEW_LINE> <START_VULN> if ( ps_dec -> u4_first_slice_in_pic != 2 ) <NEW_LINE> <END_VULN> { <NEW_LINE> i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , <NEW_LINE> & s_tmp_poc , & ps_dec -> s_cur_pic_poc ,
GLenum read_buffer_of_default_framebuffer_ ; <NEW_LINE> <START_VULN> GLint pack_alignment_ ; <NEW_LINE>GLint unpack_alignment_ ; <NEW_LINE>bool unpack_flip_y_ ; <NEW_LINE>bool unpack_premultiply_alpha_ ; <NEW_LINE>GLenum unpack_colorspace_conversion_ ; <NEW_LINE> <END_VULN> GLfloat clear_color_ [ 4 ] ; <NEW_LINE> bool scissor_enabled_ ;
nsIAtom * aPrefix , <NEW_LINE> txStylesheetAttr * aAttributes , <NEW_LINE> PRInt32 aAttrCount , <NEW_LINE> txStylesheetCompilerState & aState ) <NEW_LINE> { <NEW_LINE> nsAutoPtr < txCopy > copy ( new txCopy ) ; <NEW_LINE> NS_ENSURE_TRUE ( copy , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> <START_VULN> nsresult rv = aState . pushPtr ( copy ) ; <NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsAutoPtr < txInstruction > instr ( copy . forget ( ) ) ; <NEW_LINE> rv = aState . addInstruction ( instr ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> rv = parseUseAttrSets ( aAttributes , aAttrCount , false , aState ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
const char * last ; <NEW_LINE> const char * buf ; <NEW_LINE> const char * end ; <NEW_LINE> <START_VULN> size_t lines , linecnt , bytecnt ; <NEW_LINE> <END_VULN> if ( s == NULL ) { <NEW_LINE> ms -> search . s_len = 0 ;
mPaintDC = 0 ; <NEW_LINE> mPrevWndProc = NULL ; <NEW_LINE> mBackground = ::GetSysColor ( COLOR_BTNFACE ) ; <NEW_LINE> mBrush = ::CreateSolidBrush ( NSRGB_2_COLOREF ( mBackground ) ) ; <NEW_LINE> mForeground = ::GetSysColor ( COLOR_WINDOWTEXT ) ; <NEW_LINE> mIsShiftDown = PR_FALSE ; <NEW_LINE> mIsControlDown = PR_FALSE ; <NEW_LINE> mIsAltDown = PR_FALSE ; <NEW_LINE> <START_VULN> mIsDestroying = PR_FALSE ; <NEW_LINE> <END_VULN> mDeferredPositioner = NULL ; <NEW_LINE> mLastPoint . x = 0 ; <NEW_LINE> mLastPoint . y = 0 ; <NEW_LINE> mPreferredWidth = 0 ; <NEW_LINE> mPreferredHeight = 0 ; <NEW_LINE> mIsVisible = PR_FALSE ; <NEW_LINE> mHas3DBorder = PR_FALSE ; <NEW_LINE> #ifdef MOZ_XUL
void set_ignore_wm_events ( bool ignore ) { ignore_wm_events_ = ignore ; } <NEW_LINE> <START_VULN> void LeaveTabletMode ( wm::WindowState * window_state ) ; <NEW_LINE> <END_VULN> void OnWMEvent ( wm::WindowState * window_state ,
} else { <NEW_LINE> mdecrypt_generic ( td , data_s , data_size ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> RETVAL_STRINGL ( data_s , data_size , 1 ) ;
phar_flush ( phar , 0 , 0 , 1 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> efree ( oldpath ) ; <NEW_LINE> return NULL ;
pmd = pmd_offset ( pud , addr ) ; <NEW_LINE> do { <NEW_LINE> next = pmd_addr_end ( addr , end ) ; <NEW_LINE> <START_VULN> if ( unlikely ( pmd_trans_huge ( * pmd ) ) ) <NEW_LINE>continue ; <NEW_LINE>if ( pmd_none_or_clear_bad ( pmd ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> ret = unuse_pte_range ( vma , pmd , addr , next , entry , page ) ; <NEW_LINE> if ( ret )
} <NEW_LINE> p_dcb -> p_tx_pkt = btif_hl_get_buf ( p_dcb -> mtu ) ; <NEW_LINE> if ( p_dcb ) { <NEW_LINE> <START_VULN> int r = ( int ) recv ( p_scb -> socket_id [ 1 ] , p_dcb -> p_tx_pkt , <NEW_LINE>p_dcb -> mtu , MSG_DONTWAIT ) ; <NEW_LINE> <END_VULN> if ( r > 0 ) { <NEW_LINE> BTIF_TRACE_DEBUG ( "btif_hl_select_monitor_callback send data r = % d" , r ) ; <NEW_LINE> p_dcb -> tx_size = r ;
regs -> loadrs = 0 ; \ <NEW_LINE> regs -> r8 = get_dumpable ( current -> mm ) ; \ <NEW_LINE> regs -> r12 = new_sp - 16 ; \ <NEW_LINE> <START_VULN> if ( unlikely ( ! get_dumpable ( current -> mm ) ) ) { \ <NEW_LINE> <END_VULN> int get_dumpable ( struct mm_struct * mm ) <NEW_LINE> { <NEW_LINE> return __get_dumpable ( mm -> flags ) ;
if ( smatch ( base1 , base2 ) ) { <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> b1 = stok ( base1 , " - " , & p1 ) ; <NEW_LINE>b2 = stok ( base2 , " - " , & p2 ) ; <NEW_LINE> <END_VULN> rc = scmp ( b1 , b2 ) ; <NEW_LINE> if ( rc == 0 ) { <NEW_LINE> if ( ! p1 ) {
mDocumentURIs . AppendObject ( aDocumentURI ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsOfflineCacheUpdate::SetOwner ( nsOfflineCacheUpdateOwner * aOwner ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( ! mOwner , "Tried to set cache update owner twice . " ) ; <NEW_LINE> <START_VULN> mOwner = aOwner ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> nsOfflineCacheUpdate::IsForGroupID ( const nsCSubstring & groupID ) <NEW_LINE> { <NEW_LINE> return mGroupID == groupID ; <NEW_LINE> }
if ( ! key -> Equals ( diskEntry -> Key ( ) ) ) { <NEW_LINE> * collision = true ; <NEW_LINE> return nsnull ; <NEW_LINE> } <NEW_LINE> nsCacheEntry * entry = diskEntry -> CreateCacheEntry ( this ) ; <NEW_LINE> <START_VULN> if ( ! entry ) return nsnull ; <NEW_LINE><NEW_LINE>binding = mBindery . CreateBinding ( entry , & record ) ; <NEW_LINE>if ( ! binding ) { <NEW_LINE>delete entry ; <NEW_LINE>return nsnull ; <NEW_LINE> <END_VULN> } <NEW_LINE> return entry ; <NEW_LINE> }
pidfile_write ( const char * pid_file , int pid ) <NEW_LINE> { <NEW_LINE> FILE * pidfile = NULL ; <NEW_LINE> <START_VULN> int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <NEW_LINE> <END_VULN> if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , "w" ) ;
else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) <NEW_LINE> res = VPX_CODEC_INCAPABLE ; <NEW_LINE> else <NEW_LINE> <START_VULN> res = ctx -> iface -> enc . cfg_set ( ctx -> priv -> alg_priv , cfg ) ; <NEW_LINE> <END_VULN> return SAVE_STATUS ( ctx , res ) ; <NEW_LINE> }
ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; <NEW_LINE> } <NEW_LINE> pixels_length = height * bytes_per_line ; <NEW_LINE> <START_VULN> sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( pixels_length , <NEW_LINE> <END_VULN> sizeof ( * sun_pixels ) ) ; <NEW_LINE> if ( sun_pixels == ( unsigned char * ) NULL ) <NEW_LINE> {
#include "psy . h" <NEW_LINE> #include "os . h" <NEW_LINE> #include "lpc . h" <NEW_LINE> #include "smallft . h" <NEW_LINE> #include "scales . h" <NEW_LINE> #include "misc . h" <NEW_LINE> #define NEGINF - 9999 . f <NEW_LINE> <START_VULN> static double stereo_threshholds [ ] = { 0 . 0 , . 5 , 1 . 0 , 1 . 5 , 2 . 5 , 4 . 5 , 8 . 5 , 16 . 5 , 9e10 } ; <NEW_LINE>static double stereo_threshholds_limited [ ] = { 0 . 0 , . 5 , 1 . 0 , 1 . 5 , 2 . 0 , 2 . 5 , 4 . 5 , 8 . 5 , 9e10 } ; <NEW_LINE> <END_VULN> vorbis_look_psy_global * _vp_global_look ( vorbis_info * vi ) { <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> vorbis_info_psy_global * gi = & ci -> psy_g_param ; <NEW_LINE> vorbis_look_psy_global * look = _ogg_calloc ( 1 , sizeof ( * look ) ) ; <NEW_LINE> look -> channels = vi -> channels ;
return protocol::Page::ResourceTypeEnum::Other ; <NEW_LINE> } <NEW_LINE> <START_VULN> InspectorPageAgent::ResourceType InspectorPageAgent::CachedResourceType ( <NEW_LINE>const Resource & cached_resource ) { <NEW_LINE>switch ( cached_resource . GetType ( ) ) { <NEW_LINE> <END_VULN> case Resource::kImage: <NEW_LINE> return InspectorPageAgent::kImageResource ; <NEW_LINE> case Resource::kFont:
( NC - 1 ) * sizeof ( cat_t ) ) ; <NEW_LINE> if ( g == NULL ) <NEW_LINE> return ( REG_ESPACE ) ; <NEW_LINE> <START_VULN> p -> ssize = len / ( size_t ) 2 * ( size_t ) 3 + ( size_t ) 1 ; <NEW_LINE> <END_VULN> p -> strip = ( sop * ) malloc ( p -> ssize * sizeof ( sop ) ) ; <NEW_LINE> p -> slen = 0 ; <NEW_LINE> if ( p -> strip == NULL ) {
vcpu -> arch . regs [ VCPU_REGS_RSP ] = svm -> vmcb -> save . rsp ; <NEW_LINE> vcpu -> arch . regs [ VCPU_REGS_RIP ] = svm -> vmcb -> save . rip ; <NEW_LINE> <START_VULN> kvm_load_fs ( fs_selector ) ; <NEW_LINE>kvm_load_gs ( gs_selector ) ; <NEW_LINE>kvm_load_ldt ( ldt_selector ) ; <NEW_LINE> <END_VULN> load_host_msrs ( vcpu ) ; <NEW_LINE> reload_tss ( vcpu ) ;
if ( relayoutChildren && box -> needsPreferredWidthsRecalculation ( ) ) <NEW_LINE> o -> setPreferredLogicalWidthsDirty ( true , MarkOnlyThis ) ; <NEW_LINE> <START_VULN> if ( o -> isPositioned ( ) ) <NEW_LINE> <END_VULN> o -> containingBlock ( ) -> insertPositionedObject ( box ) ; <NEW_LINE> else if ( o -> isFloating ( ) ) <NEW_LINE> layoutState . floats ( ) . append ( FloatWithRect ( box ) ) ;
} else { <NEW_LINE> spl_filesystem_info_set_filename ( intern , file_path , file_path_len , use_copy TSRMLS_CC ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> zend_restore_error_handling ( & error_handling TSRMLS_CC ) ; <NEW_LINE> return intern ; <NEW_LINE> }
<START_VULN> if ( ( of -> f_node -> flags & NODE_FLAGS_WRITE_THROUGH ) == 0 ) <NEW_LINE> ( void ) smb_fsop_commit ( sr , of -> f_cr , of -> f_node ) ; <NEW_LINE> <END_VULN>
( * length ) -- ; <NEW_LINE> buffer [ i ] = ( unsigned char ) c ; <NEW_LINE> } <NEW_LINE> <START_VULN> value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ; <NEW_LINE>value |= buffer [ 1 ] ; <NEW_LINE>quantum . unsigned_value = ( value & 0xffff ) ; <NEW_LINE> <END_VULN> return ( quantum . signed_value ) ; <NEW_LINE> }
sigAndHash . hashAlg = SEC_OID_UNKNOWN ; <NEW_LINE> SSL_TRC ( 3 , ( " % d: SSL3 [ % d ] : handle server_key_exchange handshake" , <NEW_LINE> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> <START_VULN> if ( ss -> ssl3 . hs . ws != wait_server_key && <NEW_LINE>ss -> ssl3 . hs . ws != wait_server_cert ) { <NEW_LINE>errCode = SSL_ERROR_RX_UNEXPECTED_SERVER_KEY_EXCH ; <NEW_LINE>desc = unexpected_message ; <NEW_LINE>goto alert_loser ; <NEW_LINE> } <NEW_LINE>if ( ss -> sec . peerCert == NULL ) { <NEW_LINE>errCode = SSL_ERROR_RX_UNEXPECTED_SERVER_KEY_EXCH ; <NEW_LINE>desc = unexpected_message ; <NEW_LINE>goto alert_loser ; <NEW_LINE> <END_VULN> } <NEW_LINE> isTLS = ( PRBool ) ( ss -> ssl3 . prSpec -> version > SSL_LIBRARY_VERSION_3_0 ) ; <NEW_LINE> isTLS12 = ( PRBool ) ( ss -> ssl3 . prSpec -> version >= SSL_LIBRARY_VERSION_TLS_1_2 ) ; <NEW_LINE> switch ( ss -> ssl3 . hs . kea_def -> exchKeyType ) { <NEW_LINE> case kt_rsa: {
<START_VULN> i1_is_end_of_poc = 0 ; <NEW_LINE>if ( ! ps_dec -> u1_first_slice_in_stream ) <NEW_LINE> <END_VULN> { <NEW_LINE> i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , <NEW_LINE> & s_tmp_poc , & ps_dec -> s_cur_pic_poc ,
char block_dev [ PATH_MAX + 1 ] ; <NEW_LINE> size_t size ; <NEW_LINE> unsigned int blksize ; <NEW_LINE> <START_VULN> unsigned int blocks ; <NEW_LINE> <END_VULN> unsigned int range_count ; <NEW_LINE> unsigned int i ;
RATE_CONTROL * const rc = & cpi -> rc ; <NEW_LINE> rc -> frames_since_golden = 0 ; <NEW_LINE> <START_VULN> #if CONFIG_MULTIPLE_ARF <NEW_LINE>if ( ! cpi -> multi_arf_enabled ) <NEW_LINE>#endif <NEW_LINE><NEW_LINE>rc -> source_alt_ref_pending = 0 ; <NEW_LINE> <END_VULN> rc -> source_alt_ref_active = 1 ;
resources = other -> resources ; <NEW_LINE> } <NEW_LINE> <START_VULN> StyleDifference SVGRenderStyle::diff ( const SVGRenderStyle * other ) const <NEW_LINE> <END_VULN> {
nsCycleCollectionParticipant * helper ) <NEW_LINE> { <NEW_LINE> } <NEW_LINE> NS_IMETHOD_ ( void ) NoteNextEdgeName ( const char * name ) <NEW_LINE> { <NEW_LINE> } <NEW_LINE> <START_VULN> NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * val ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> bool mFound ; <NEW_LINE> private: <NEW_LINE> void * mWrapper ; <NEW_LINE> } ;
yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != '"' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 708 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> size_t len , len2 , len3 , maxlen ; <NEW_LINE> long elements ;
int64_t OutputFile::readImpl ( char * , int64_t ) { <NEW_LINE> raise_warning ( "cannot read from a php: <NEW_LINE> <START_VULN> return - 1 ; <NEW_LINE> <END_VULN> } <NEW_LINE> int OutputFile::getc ( ) {
stub = phar_create_default_stub ( index , webindex , & stub_len , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> if ( stub ) { <NEW_LINE> efree ( stub ) ;
run_test ( & test2 , test2_result ) ; <NEW_LINE> fprintf ( stderr , "OK\nDequant test 3 . . . " ) ; <NEW_LINE> run_test ( & test3 , test3_result ) ; <NEW_LINE> fprintf ( stderr , "OK\nDequant test 4 . . . " ) ; <NEW_LINE> run_test ( & test4 , test4_result ) ; <NEW_LINE> fprintf ( stderr , "OK\nDequant test 5 . . . " ) ; <NEW_LINE> run_test ( & test5 , test5_result ) ; <NEW_LINE> fprintf ( stderr , "OK\n\n" ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return ( 0 ) ; <NEW_LINE> } <NEW_LINE> #endif
public: <NEW_LINE> <START_VULN> PlatformSensorAccelerometerMac ( mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> PlatformSensorProvider * provider ) ; <NEW_LINE> mojom::ReportingMode GetReportingMode ( ) override ;
* ( dp ++ ) = save [ 1 ] ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
bool mFinished ; <NEW_LINE> } ; <NEW_LINE> void <NEW_LINE> nsPluginInstanceOwner::NotifyPaintWaiter ( nsDisplayListBuilder * aBuilder ) <NEW_LINE> { <NEW_LINE> if ( ! mWaitingForPaint && ! IsUpToDate ( ) && aBuilder -> ShouldSyncDecodeImages ( ) ) { <NEW_LINE> <START_VULN> nsCOMPtr < nsIRunnable > event = new AsyncPaintWaitEvent ( mContent , false ) ; <NEW_LINE> <END_VULN> mWaitingForPaint = nsContentUtils::AddScriptRunner ( event ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> #if MOZ_WIDGET_ANDROID <NEW_LINE> static void
case 18: <NEW_LINE> case 19: <NEW_LINE> case 20: <NEW_LINE> <START_VULN> <NEW_LINE>uni_to_string ( get_finfo_value_string ( PTREE_FINFO ( tree_pointer ) ) , get_finfo_length ( PTREE_FINFO ( tree_pointer ) ) , buffer ) ; <NEW_LINE> <END_VULN> if ( repeat_lookup > 0 ) { <NEW_LINE> if ( strlen ( temp_buffer ) + strlen ( buffer ) < 250 ) { <NEW_LINE> g_strlcat ( temp_buffer , buffer , 256 ) ;
nsRefPtr < nsDOMDataTransfer > clipboardData ; <NEW_LINE> if ( e -> mEventIsInternal ) { <NEW_LINE> nsClipboardEvent * event = static_cast < nsClipboardEvent * > ( e -> mEvent ) ; <NEW_LINE> if ( event ) { <NEW_LINE> <START_VULN> clipboardData = new nsDOMDataTransfer ( NS_COPY , false ) ; <NEW_LINE> <END_VULN> clipboardData -> SetData ( aParam . mDataType , aParam . mData ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> aRv = e -> InitClipboardEvent ( aType , aParam . mBubbles , aParam . mCancelable , <NEW_LINE> clipboardData ) ; <NEW_LINE> e -> SetTrusted ( trusted ) ; <NEW_LINE> return e . forget ( ) ;
if ( ! isGetter && curObj -> watched ( ) ) <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! CanEffectlesslyCallLookupGenericOnObject ( curObj ) ) <NEW_LINE> <END_VULN> return true ; <NEW_LINE> RootedObject proto ( cx ) ; <NEW_LINE> RootedShape shape ( cx ) ; <NEW_LINE> if ( ! JSObject::lookupGeneric ( cx , curObj , id , & proto , & shape ) ) <NEW_LINE> return false ; <NEW_LINE> if ( ! shape )
void StopHangMonitorTimeout ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE>void StartNewContentRenderingTimeout ( ) ; <NEW_LINE> <END_VULN>
void StartFetching ( FetchCallback callback ) override ; <NEW_LINE> <START_VULN> void DeleteSharedWorker ( const GURL & worker , const std::string & name ) override ; <NEW_LINE> <END_VULN> private: <NEW_LINE> ~ CannedBrowsingDataSharedWorkerHelper ( ) override ;
nsIRunnable * mPendingInstantiateEvent ; <NEW_LINE> nsCString mContentType ; <NEW_LINE> <START_VULN> nsIChannel * mChannel ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIURI > mURI ; <NEW_LINE> ObjectType mType : 16 ;
T * array = reinterpret_cast < T * > ( self ) ; <NEW_LINE> blink::HeapObjectHeader * header = <NEW_LINE> blink::HeapObjectHeader::fromPayload ( self ) ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> size_t length = header -> payloadSize ( ) / sizeof ( T ) ;
XML_PARSE_HUGE = 1 << 19 , <NEW_LINE> XML_PARSE_OLDSAX = 1 << 20 , <NEW_LINE> XML_PARSE_IGNORE_ENC = 1 << 21 , <NEW_LINE> <START_VULN> XML_PARSE_BIG_LINES = 1 << 22 , <NEW_LINE>XML_PARSE_NOXXE = 1 << 23 <NEW_LINE> <END_VULN> } xmlParserOption ; <NEW_LINE> XMLPUBFUN void XMLCALL
if ( aLineLayout . GetInFirstLetter ( ) || aLineLayout . GetInFirstLine ( ) ) { <NEW_LINE> SetLength ( maxContentLength , & aLineLayout ) ; <NEW_LINE> if ( aLineLayout . GetInFirstLetter ( ) ) { <NEW_LINE> <START_VULN> ClearTextRun ( ) ; <NEW_LINE> <END_VULN> gfxSkipCharsIterator iter = <NEW_LINE> EnsureTextRun ( ctx , lineContainer , aLineLayout . GetLine ( ) , & flowEndInTextRun ) ; <NEW_LINE> if ( mTextRun ) { <NEW_LINE> PRInt32 firstLetterLength = length ; <NEW_LINE> if ( aLineLayout . GetFirstLetterStyleOK ( ) ) { <NEW_LINE> completedFirstLetter =
break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( RAW != 0 ) { <NEW_LINE> xmlFatalErr ( ctxt , XML_ERR_EXT_SUBSET_NOT_FINISHED , NULL ) ; <NEW_LINE> }
virtual void DidFinishLoadWithReason ( const GURL & url , NPReason reason , <NEW_LINE> <START_VULN> intptr_t notify_data ) = 0 ; <NEW_LINE> <END_VULN> virtual int GetProcessId ( ) = 0 ;
omxhdr -> nFlags = m_sVenc_msg -> buf . flags ; <NEW_LINE> <START_VULN> if ( omx -> output_use_buffer && ! omx -> m_use_output_pmem ) { <NEW_LINE> <END_VULN> DEBUG_PRINT_LOW ( "memcpy ( ) for o / p Heap UseBuffer" ) ; <NEW_LINE> memcpy ( omxhdr -> pBuffer , <NEW_LINE> ( m_sVenc_msg -> buf . ptrbuffer ) ,
if ( branch ) { <NEW_LINE> branch -> GetCharPref ( "media . audio_loopback_dev" , & loopbackAudioDevice ) ; <NEW_LINE> branch -> GetCharPref ( "media . video_loopback_dev" , & loopbackVideoDevice ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> nsCOMPtr < nsIRunnable > gUMDRunnable = new GetUserMediaDevicesRunnable ( <NEW_LINE> <START_VULN> aConstraints , onSuccess . forget ( ) , onError . forget ( ) , aWindow -> WindowID ( ) , <NEW_LINE>loopbackAudioDevice , loopbackVideoDevice <NEW_LINE> ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIThread > deviceThread ; <NEW_LINE> rv = NS_NewThread ( getter_AddRefs ( deviceThread ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> deviceThread -> Dispatch ( gUMDRunnable , NS_DISPATCH_NORMAL ) ; <NEW_LINE> return NS_OK ;
if ( val ) * val = p ; <NEW_LINE> <START_VULN> SetHeader ( atom , nsDependentCString ( p , p2 - p ) , PR_TRUE ) ; <NEW_LINE> <END_VULN> }
} msgptr ; <NEW_LINE> int msg_len_valid = 0 ; <NEW_LINE> <START_VULN> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( is_ipv6 ) <NEW_LINE> { <NEW_LINE> msgptr . v6 = ( const struct olsr_msg6 * ) tptr ; <NEW_LINE> msg_type = msgptr . v6 -> msg_type ; <NEW_LINE> msg_len = EXTRACT_16BITS ( msgptr . v6 -> msg_len ) ;
{ <NEW_LINE> png_debug ( 1 , "in png_set_interlace handling" ) ; <NEW_LINE> <START_VULN> if ( png_ptr && png_ptr -> interlaced ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_ptr -> transformations |= PNG_INTERLACE ; <NEW_LINE> return ( 7 ) ;
mOffscreenTexture ( 0 ) , <NEW_LINE> mFlipped ( false ) , <NEW_LINE> mBlitProgram ( 0 ) , <NEW_LINE> mBlitFramebuffer ( 0 ) , <NEW_LINE> mOffscreenDrawFBO ( 0 ) , <NEW_LINE> mOffscreenReadFBO ( 0 ) , <NEW_LINE> mOffscreenColorRB ( 0 ) , <NEW_LINE> mOffscreenDepthRB ( 0 ) , <NEW_LINE> <START_VULN> mOffscreenStencilRB ( 0 ) <NEW_LINE> <END_VULN> #ifdef DEBUG <NEW_LINE> , mGLError ( LOCAL_GL_NO_ERROR ) <NEW_LINE> #endif <NEW_LINE> { <NEW_LINE> mUserData . Init ( ) ; <NEW_LINE> } <NEW_LINE> virtual ~ GLContext ( ) {
} else { <NEW_LINE> p = ( char __user * ) iocts . arg ; <NEW_LINE> for ( i = 0 ; i < 10 ; i ++ ) { <NEW_LINE> <START_VULN> sprintf ( bname , " % s % s" , <NEW_LINE> <END_VULN> strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? <NEW_LINE> dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , <NEW_LINE> ( i < 9 ) ? " , " : "\0" ) ;
return NS_ERROR_INVALID_ARG ; <NEW_LINE> nsCOMPtr < nsIContent > content = do_QueryInterface ( mCanvasElement ) ; <NEW_LINE> if ( ! content && ! mDocShell ) { <NEW_LINE> NS_WARNING ( "Canvas element must be an nsIContent and non - null or a docshell must be provided" ) ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsIPresShell * presShell = GetPresShell ( ) ; <NEW_LINE> <END_VULN> if ( ! presShell ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> nsIDocument * document = presShell -> GetDocument ( ) ; <NEW_LINE> nsAutoString textToDraw ( aRawText ) ; <NEW_LINE> TextReplaceWhitespaceCharacters ( textToDraw ) ;
static void set_segmentation_map ( VP8_COMP * cpi , unsigned char * segmentation_map ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <NEW_LINE> <END_VULN> cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ;
DetectEngineCtx * de_ctx , DetectEngineThreadCtx * det_ctx , <NEW_LINE> Packet * p ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE>if ( ( p -> flags & PKT_NOPACKET_INSPECTION ) || <NEW_LINE> ( PACKET_TEST_ACTION ( p , ACTION_DROP ) ) ) <NEW_LINE> { <NEW_LINE> <END_VULN>
q3u8 = vld1q_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; <NEW_LINE> q4u8 = vld1q_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; <NEW_LINE> <START_VULN> d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ; <NEW_LINE>d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ; <NEW_LINE> <END_VULN> q6u16 = vmull_u8 ( vget_low_u8 ( q1u8 ) , d0u8 ) ; <NEW_LINE> q7u16 = vmull_u8 ( vget_low_u8 ( q2u8 ) , d0u8 ) ;
exit ( 1 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <NEW_LINE> <END_VULN> fprintf ( stdout , "BT adapter is up\n" ) ; <NEW_LINE> const btsock_interface_t * sock = bt_interface -> get_profile_interface ( BT_PROFILE_SOCKETS_ID ) ;
else <NEW_LINE> goto end ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) ) <NEW_LINE> <END_VULN> goto loop ; <NEW_LINE> }
source [ nread ] = '\0' ; <NEW_LINE> plen - = nread ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE> <END_VULN>
<START_VULN> if ( isRenderBlock ( ) && isPositioned ( ) && style ( ) -> height ( ) . isAuto ( ) && ! ( style ( ) -> top ( ) . isAuto ( ) || style ( ) -> bottom ( ) . isAuto ( ) ) ) { <NEW_LINE> <END_VULN> RenderBlock * block = const_cast < RenderBlock * > ( toRenderBlock ( this ) ) ; <NEW_LINE> LayoutUnit oldHeight = block -> logicalHeight ( ) ; <NEW_LINE> block -> computeLogicalHeight ( ) ;
local_irq_enable ( ) ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN>
virtual JavaScriptDialogManager * GetJavaScriptDialogManager ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> virtual ColorChooser * OpenColorChooser ( <NEW_LINE> WebContents * web_contents , <NEW_LINE> SkColor color ,
if ( png_ptr == NULL ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( ! ( png_ptr -> mode & PNG_HAVE_IDAT ) ) <NEW_LINE> <END_VULN> png_error ( png_ptr , "No IDATs written into file" ) ; <NEW_LINE> #ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
} <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> else if ( el . tagName ( ) == QLatin1String ( "forwarded" ) && el . attribute ( QLatin1String ( "xmlns" ) ) == QLatin1String ( "urn:xmpp:forward:0" ) ) { <NEW_LINE> <END_VULN> forward = el . firstChildElement ( QLatin1String ( "message" ) ) ; <NEW_LINE> if ( ! forward . isNull ( ) ) {
break ; <NEW_LINE> case REOP_ASSERTNOTTEST: <NEW_LINE> <START_VULN> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> -- curState ; <NEW_LINE> x -> cp = gData -> cpbegin + curState -> index ; <NEW_LINE> gData -> backTrackSP =
} <NEW_LINE> if ( ret & VM_FAULT_MAJOR ) { <NEW_LINE> current -> maj_flt ++ ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <NEW_LINE> <END_VULN> regs , address ) ; <NEW_LINE> #ifdef CONFIG_PPC_SMLPAR <NEW_LINE> if ( firmware_has_feature ( FW_FEATURE_CMO ) ) {
int http_response_code ) ; <NEW_LINE> <START_VULN> void AddDefaultProxyBypassRules ( ) ; <NEW_LINE> <END_VULN>
p_dst = dst_ptr ; <NEW_LINE> for ( col = 0 ; col < cols ; col ++ ) { <NEW_LINE> <START_VULN> int kernel = 4 ; <NEW_LINE>int v = p_src [ col ] ; <NEW_LINE> <END_VULN> for ( i = - 2 ; i <= 2 ; i ++ ) { <NEW_LINE> if ( abs ( v - p_src [ col + i * pitch ] ) > flimit )
MOZ_ASSERT ( cx ) ; <NEW_LINE> nsCOMPtr < nsIScriptGlobalObject > sgo = do_QueryInterface ( GetOwner ( ) ) ; <NEW_LINE> JSObject * ownerObj = sgo -> GetGlobalJSObject ( ) ; <NEW_LINE> NS_ENSURE_TRUE_VOID ( ownerObj ) ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> NS_ENSURE_TRUE_VOID ( pusher . Push ( cx , nsCxPusher::ALWAYS_PUSH ) ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , ownerObj ) ; <NEW_LINE> JSObject * array = JS_NewArrayObject ( cx , aItems . Length ( ) , nullptr ) ; <NEW_LINE> NS_ENSURE_TRUE_VOID ( array ) ; <NEW_LINE> bool ok ;
list_for_each_entry_safe ( tc , _tc , & rds_tcp_conn_list , t_tcp_node ) { <NEW_LINE> struct net * c_net = read_pnet ( & tc -> t_cpath -> cp_conn -> c_net ) ; <NEW_LINE> <START_VULN> if ( net != c_net || ! tc -> t_sock ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( ! list_has_conn ( & tmp_list , tc -> t_cpath -> cp_conn ) ) { <NEW_LINE> list_move_tail ( & tc -> t_tcp_node , & tmp_list ) ;
return ErrorInvalidValue ( "texImage2D: level must be >= 0" ) ; <NEW_LINE> if ( ! ( maxTextureSize >> level ) ) <NEW_LINE> return ErrorInvalidValue ( "texImage2D: 2 ^ level exceeds maximum texture size" ) ; <NEW_LINE> if ( width < 0 || height < 0 ) <NEW_LINE> return ErrorInvalidValue ( "texImage2D: width and height must be >= 0" ) ; <NEW_LINE> <START_VULN> if ( width > maxTextureSize || height > maxTextureSize ) <NEW_LINE>return ErrorInvalidValue ( "texImage2D: width or height exceeds maximum texture size" ) ; <NEW_LINE> <END_VULN> if ( level >= 1 ) { <NEW_LINE> if ( ! ( is_pot_assuming_nonnegative ( width ) && <NEW_LINE> is_pot_assuming_nonnegative ( height ) ) ) <NEW_LINE> return ErrorInvalidValue ( "texImage2D: with level > 0 , width and height must be powers of two" ) ; <NEW_LINE> } <NEW_LINE> if ( border != 0 )
void <NEW_LINE> png_app_warning ( png_const_structrp png_ptr , png_const_charp error_message ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> flags & PNG_FLAG_APP_WARNINGS_WARN ) <NEW_LINE> <END_VULN> png_warning ( png_ptr , error_message ) ; <NEW_LINE> else <NEW_LINE> png_error ( png_ptr , error_message ) ;
if ( ( c = strrchr ( name , ' . ' ) ) ) <NEW_LINE> * c = '\0' ; <NEW_LINE> <START_VULN> dname = malloc ( strlen ( name ) + 16 ) ; <NEW_LINE> <END_VULN> sprintf ( dname , " % s - versions" , name ) ; <NEW_LINE> if ( ! ( dir = opendir ( dname ) ) ) <NEW_LINE> mkdir ( dname , S_IRWXU ) ;
} <NEW_LINE> static vpx_codec_err_t ctrl_set_scale_mode ( vpx_codec_alg_priv_t * ctx , <NEW_LINE> <START_VULN> int ctr_id , va_list args ) { <NEW_LINE> <END_VULN> vpx_scaling_mode_t * const mode = va_arg ( args , vpx_scaling_mode_t * ) ; <NEW_LINE> if ( mode ) {
<START_VULN> #ifndef BASE_SEQUENCED_TASK_RUNNER_TEST_TEMPLATE_H_ <NEW_LINE>#define BASE_SEQUENCED_TASK_RUNNER_TEST_TEMPLATE_H_ <NEW_LINE> <END_VULN> #include < cstddef > <NEW_LINE> #include < iosfwd >
return JS_FALSE ; <NEW_LINE> pobj = JSVAL_TO_OBJECT ( * vp ) ; <NEW_LINE> if ( pobj ) { <NEW_LINE> clasp = OBJ_GET_CLASS ( cx , pobj ) ; <NEW_LINE> if ( clasp == & js_CallClass || clasp == & js_BlockClass ) { <NEW_LINE> * vp = JSVAL_NULL ; <NEW_LINE> <START_VULN> } else if ( clasp -> flags & JSCLASS_IS_EXTENDED ) { <NEW_LINE>xclasp = ( JSExtendedClass * ) clasp ; <NEW_LINE>if ( xclasp -> outerObject ) { <NEW_LINE>pobj = xclasp -> outerObject ( cx , pobj ) ; <NEW_LINE>if ( ! pobj ) <NEW_LINE>return JS_FALSE ; <NEW_LINE> * vp = OBJECT_TO_JSVAL ( pobj ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> return JS_TRUE ; <NEW_LINE> } <NEW_LINE> static JSBool <NEW_LINE> obj_setSlot ( JSContext * cx , JSObject * obj , jsval id , jsval * vp ) <NEW_LINE> {
<START_VULN> bool InternalCloseTabs ( const std::vector < int > & indices , uint32 close_types ) ; <NEW_LINE> <END_VULN>
mExecutor -> WillBuildModel ( eDTDMode_unknown ) ; <NEW_LINE> nsRefPtr < nsHtml5OwningUTF16Buffer > newBuf = <NEW_LINE> nsHtml5OwningUTF16Buffer::FalliblyCreate ( <NEW_LINE> NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE ) ; <NEW_LINE> if ( ! newBuf ) { <NEW_LINE> <START_VULN> mExecutor -> MarkAsBroken ( ) ; <NEW_LINE><NEW_LINE><NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> <END_VULN> } <NEW_LINE> NS_ASSERTION ( ! mFirstBuffer , "How come we have the first buffer set ? " ) ; <NEW_LINE> NS_ASSERTION ( ! mLastBuffer , "How come we have the last buffer set ? " ) ; <NEW_LINE> mFirstBuffer = mLastBuffer = newBuf ; <NEW_LINE> nsresult rv = NS_OK ;
replace_value = & empty_replace ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ( result = php_pcre_replace ( Z_STRVAL_PP ( regex_entry ) ,
<START_VULN> class FilePath { <NEW_LINE> <END_VULN> public: <NEW_LINE> #if defined ( OS_POSIX )
header [ 11 ] = ( rec -> length ) >> 8 ; <NEW_LINE> header [ 12 ] = ( rec -> length ) & 0xff ; <NEW_LINE> <START_VULN> if ( ! send && ! SSL_USE_ETM ( ssl ) && <NEW_LINE> <END_VULN> EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && <NEW_LINE> ssl3_cbc_record_digest_supported ( mac_ctx ) ) { <NEW_LINE> # define SSL_PKEY_RSA_ENC 0
} <NEW_LINE> if ( flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_USE_WIDGET_LAYERS ) { <NEW_LINE> renderDocFlags |= nsIPresShell::RENDER_USE_WIDGET_LAYERS ; <NEW_LINE> } <NEW_LINE> if ( flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_ASYNC_DECODE_IMAGES ) { <NEW_LINE> renderDocFlags |= nsIPresShell::RENDER_ASYNC_DECODE_IMAGES ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsresult rv = presContext -> PresShell ( ) -> <NEW_LINE>RenderDocument ( r , renderDocFlags , bgColor , mThebes ) ; <NEW_LINE> <END_VULN> mThebes -> SetColor ( gfxRGBA ( 1 , 1 , 1 , 1 ) ) ; <NEW_LINE> DirtyAllStyles ( ) ;
OMX_U32 flags , OMX_TICKS timestamp , int fenceFd ) { <NEW_LINE> Mutex::Autolock autoLock ( mLock ) ; <NEW_LINE> <START_VULN> OMX_BUFFERHEADERTYPE * header = findBufferHeader ( buffer ) ; <NEW_LINE> <END_VULN> BufferMeta * buffer_meta = <NEW_LINE> static_cast < BufferMeta * > ( header -> pAppPrivate ) ; <NEW_LINE> sp < ABuffer > backup = buffer_meta -> getBuffer ( header , true , false ) ;
for ( i = 0 ; i < num_part ; i ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memmove ( dp , cpi -> partition_d [ i + 1 ] , cpi -> partition_sz [ i + 1 ] ) ; <NEW_LINE> <END_VULN> cpi -> partition_d [ i + 1 ] = dp ; <NEW_LINE> dp += cpi -> partition_sz [ i + 1 ] ; <NEW_LINE> }
set_acl_from_sec_attr ( card , file ) ; <NEW_LINE> else <NEW_LINE> r = SC_ERROR_UNKNOWN_DATA_RECEIVED ; <NEW_LINE> <START_VULN> if ( r ) <NEW_LINE> <END_VULN> sc_file_free ( file ) ; <NEW_LINE> else <NEW_LINE> {
defaultViewportMinWidth = document -> viewportDefaultMinWidth ( ) ; <NEW_LINE> viewportMetaZeroValuesQuirk = document -> settings ( ) && document -> settings ( ) -> viewportMetaZeroValuesQuirk ( ) ; <NEW_LINE> viewportMetaEnabled = document -> settings ( ) && document -> settings ( ) -> viewportMetaEnabled ( ) ; <NEW_LINE> <START_VULN> referrerPolicy = ReferrerPolicyDefault ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
static bool r_bin_mdmp_init_directory ( struct r_bin_mdmp_obj * obj ) { <NEW_LINE> int i ; <NEW_LINE> <START_VULN> ut8 * directory_base ; <NEW_LINE>struct minidump_directory * entry ; <NEW_LINE><NEW_LINE>directory_base = obj -> b -> buf + obj -> hdr -> stream_directory_rva ; <NEW_LINE> <END_VULN> sdb_num_set ( obj -> kv , "mdmp_directory . offset" , <NEW_LINE> obj -> hdr -> stream_directory_rva , 0 ) ;
#endif <NEW_LINE> #define INT64_F "I64" <NEW_LINE> #else <NEW_LINE> <START_VULN> #ifdef __LP64__ <NEW_LINE>typedef unsigned long uint64 ; <NEW_LINE>typedef long int64 ; <NEW_LINE> <END_VULN> #ifndef INT64_C <NEW_LINE> #define INT64_C ( x ) x ## L <NEW_LINE> #endif
std::cout << "FAILED:" ; <NEW_LINE> else <NEW_LINE> std::cout << "passed:" ; <NEW_LINE> <START_VULN> std::cout << " GenerateWord32 and Crop\n" ; <END_VULN> <NEW_LINE> <NEW_LINE> } <NEW_LINE> #if ! defined ( NO_OS_DEPENDENCE )
UNUSED ( string ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void * H264SwDecMalloc ( u32 size ) { <NEW_LINE>return malloc ( size ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void H264SwDecFree ( void * ptr ) {
BuiltInFunctionEmulator builtInFunctionEmulator ; <NEW_LINE> TInfoSink infoSink ; <NEW_LINE> TVariableInfoList attribs ; <NEW_LINE> TVariableInfoList uniforms ; <NEW_LINE> <START_VULN> TMap < TString , TString > varyingLongNameMap ; <NEW_LINE> <END_VULN> } ;
while ( len != 0 ) { <NEW_LINE> unsigned int amode , tlen = 3 ; <NEW_LINE> <START_VULN> if ( len < 5 && p [ 0 ] != 0x80 && p [ 1 ] != 0x01 ) { <NEW_LINE> <END_VULN> sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , "invalid access mode encoding" ) ; <NEW_LINE> return SC_ERROR_INTERNAL ; <NEW_LINE> }
int type , nparams ; <NEW_LINE> if ( png_get_pCAL ( read_ptr , read_info_ptr , & purpose , & X0 , & X1 , & type , <NEW_LINE> <START_VULN> & nparams , & units , & params ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_set_pCAL ( write_ptr , write_info_ptr , purpose , X0 , X1 , type , <NEW_LINE> nparams , units , params ) ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . methodWithNonOptionalArgAndOptionalArg" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( int , nonOpt , toInt32 ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( args . Length ( ) <= 1 ) {
int vp9_rc_bits_per_mb ( FRAME_TYPE frame_type , int qindex , <NEW_LINE> <START_VULN> double correction_factor ) ; <NEW_LINE> <END_VULN> int vp9_rc_clamp_iframe_target_size ( const struct VP9_COMP * const cpi ,
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 2 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> int nonCallback ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . toInt32 ( exec ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
if ( charset_hint ) { <NEW_LINE> int found = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( i = 0 ; charset_map [ i ] . codeset ; i ++ ) { <NEW_LINE> if ( len == strlen ( charset_map [ i ] . codeset ) && strncasecmp ( charset_hint , charset_map [ i ] . codeset , len ) == 0 ) {
} <NEW_LINE> blk_finish_plug ( & plug ) ; <NEW_LINE> <START_VULN> kiocb_batch_free ( & batch ) ; <NEW_LINE> <END_VULN> put_ioctx ( ctx ) ; <NEW_LINE> return i ? i : ret ; <NEW_LINE> }
PathGetSiblingFilePath ( LPWSTR destinationBuffer , <NEW_LINE> LPCWSTR siblingFilePath , <NEW_LINE> LPCWSTR newFileName ) <NEW_LINE> { <NEW_LINE> if ( wcslen ( siblingFilePath ) >= MAX_PATH ) { <NEW_LINE> return FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> wcscpy ( destinationBuffer , siblingFilePath ) ; <NEW_LINE> <END_VULN> if ( ! PathRemoveFileSpecW ( destinationBuffer ) ) { <NEW_LINE> return FALSE ; <NEW_LINE> } <NEW_LINE> if ( wcslen ( destinationBuffer ) + wcslen ( newFileName ) >= MAX_PATH ) { <NEW_LINE> return FALSE ; <NEW_LINE> }
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . optionsObject" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( Dictionary , oo , MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ; <NEW_LINE> if ( args . Length ( ) > 0 && ! oo . isUndefinedOrNull ( ) && ! oo . isObject ( ) ) {
extern "C" { <NEW_LINE> #endif <NEW_LINE> <START_VULN> void vp9_predict_intra_block ( const MACROBLOCKD * xd , int block_idx , int bwl_in , <NEW_LINE>TX_SIZE tx_size , MB_PREDICTION_MODE mode , <NEW_LINE> <END_VULN> const uint8_t * ref , int ref_stride , <NEW_LINE> uint8_t * dst , int dst_stride , <NEW_LINE> int aoff , int loff , int plane ) ;
NS_WARNING ( "Going to leak ! " ) ; <NEW_LINE> } <NEW_LINE> mLoaderGlobal = nullptr ; <NEW_LINE> } <NEW_LINE> mInProgressImports . Clear ( ) ; <NEW_LINE> mImports . Clear ( ) ; <NEW_LINE> <START_VULN> mThisObjects . Clear ( ) ; <NEW_LINE> <END_VULN> mModules . Enumerate ( ClearModules , nullptr ) ; <NEW_LINE> JS_DestroyContextNoGC ( mContext ) ; <NEW_LINE> mContext = nullptr ; <NEW_LINE> mRuntimeService = nullptr ; <NEW_LINE> }
NS_IMETHODIMP <NEW_LINE> nsHTMLEditor::CollapseAdjacentTextNodes ( nsIDOMRange * aInRange ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_TRUE ( aInRange , NS_ERROR_NULL_POINTER ) ; <NEW_LINE> nsAutoTxnsConserveSelection dontSpazMySelection ( this ) ; <NEW_LINE> <START_VULN> nsTArray < nsIDOMNode * > textNodes ; <NEW_LINE> <END_VULN> nsresult result ; <NEW_LINE> nsCOMPtr < nsIContentIterator > iter =
} <NEW_LINE> } else { <NEW_LINE> if ( state -> indent ) ruby_xfree ( state -> indent ) ; <NEW_LINE> <START_VULN> state -> indent = strdup ( RSTRING_PTR ( indent ) ) ; <NEW_LINE> <END_VULN> state -> indent_len = len ; <NEW_LINE> } <NEW_LINE> return Qnil ;
} <NEW_LINE> if ( sco_listen ) { <NEW_LINE> <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <NEW_LINE> <END_VULN> fprintf ( stdout , "BT adapter is up\n" ) ; <NEW_LINE> bt_property_t * property = property_new_scan_mode ( BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE ) ;
<START_VULN> class BASE_API LockImpl { <NEW_LINE> <END_VULN> public: <NEW_LINE> #if defined ( OS_WIN ) <NEW_LINE> typedef CRITICAL_SECTION OSLockType ;
} <NEW_LINE> addr = compute_effective_address ( regs , insn ) ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <NEW_LINE> <END_VULN> switch ( dir ) { <NEW_LINE> case load: <NEW_LINE> err = do_int_load ( fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) ,
wx2 = im -> sx ; wy2 = im -> sy ; <NEW_LINE> oc = gdImageGetPixel ( im , x , y ) ; <NEW_LINE> if ( oc == nc || x < 0 || x > wx2 || y < 0 || y > wy2 ) { <NEW_LINE> <START_VULN> im -> alphaBlendingFlag = alphablending_bak ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
if ( ! image -> mHasBeenDecoded ) { <NEW_LINE> image -> mInDecoder = PR_TRUE ; <NEW_LINE> image -> mDecoder -> FlushInvalidations ( ) ; <NEW_LINE> image -> mInDecoder = PR_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( image -> IsDecodeFinished ( ) ) { <NEW_LINE> <END_VULN> rv = image -> ShutdownDecoder ( RasterImage::eShutdownIntent_Done ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> image -> DoError ( ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> }
#include "googleurl / src / gurl . h" <NEW_LINE> #include "third_party / npapi / bindings / npapi . h" <NEW_LINE> <START_VULN> class MessageLoop ; <NEW_LINE> <END_VULN> namespace webkit_glue { <NEW_LINE> class WebPlugin ; <NEW_LINE> } <NEW_LINE> namespace NPAPI
} <NEW_LINE> std::string utf8 ; <NEW_LINE> utf8 . resize ( utf8Length ) ; <NEW_LINE> <START_VULN> utf16_to_utf8 ( utf16 . data ( ) , utf16 . length ( ) , & * utf8 . begin ( ) ) ; <NEW_LINE> <END_VULN> return utf8 ; <NEW_LINE> }
<START_VULN> if ( png_ptr -> flags & PNG_FLAG_ZSTREAM_INITIALIZED ) <NEW_LINE> <END_VULN> ret = deflateReset ( & png_ptr -> zstream ) ; <NEW_LINE> else
<START_VULN> if ( equalIgnoringCase ( child -> getAttribute ( aria_hiddenAttr ) , "true" ) ) <NEW_LINE> <END_VULN> continue ;
struct iphdr _iph ; <NEW_LINE> ip: <NEW_LINE> iph = skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , & _iph ) ; <NEW_LINE> <START_VULN> if ( ! iph ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> if ( ip_is_fragment ( iph ) )
{ <NEW_LINE> int i , count = 0 ; <NEW_LINE> int * key_sizes ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> MCRYPT_GET_TD_ARG <NEW_LINE> array_init ( return_value ) ;
#define IPC_MESSAGE_FORWARD ( msg_class , obj , member_func ) \ <NEW_LINE> case msg_class::ID: { \ <NEW_LINE> <START_VULN> TRACK_RUN_IN_IPC_HANDLER ( member_func ) ; \ <NEW_LINE> <END_VULN> if ( ! msg_class::Dispatch ( & ipc_message__ , obj , this , param__ , \ <NEW_LINE> & member_func ) ) \ <NEW_LINE> ipc_message__ . set_dispatch_error ( ) ; \
memcpy ( prefix , base , len ) ; <NEW_LINE> prefix [ len ] = 0 ; <NEW_LINE> <START_VULN> snprintf ( pattern , 499 , " . / test / schemas / % s_ ? . xml" , prefix ) ; <NEW_LINE>pattern [ 499 ] = 0 ; <NEW_LINE> <END_VULN> if ( base [ len ] == '_' ) { <NEW_LINE> len += 2 ;
else <NEW_LINE> MB_FAILURE ( pos , 4 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> this_char = ( ( c & 0x07 ) << 18 ) | ( ( str [ pos + 1 ] & 0x3f ) << 12 ) | ( ( str [ pos + 2 ] & 0x3f ) << 6 ) | ( str [ pos + 3 ] & 0x3f ) ; <NEW_LINE> if ( this_char < 0x10000 || this_char > 0x10FFFF ) { <NEW_LINE> MB_FAILURE ( pos , 4 ) ;
<START_VULN> #ifndef BASE_COCOA_PROTOCOLS_MAC_H_ <NEW_LINE>#define BASE_COCOA_PROTOCOLS_MAC_H_ <NEW_LINE> <END_VULN> #import < Cocoa / Cocoa . h >
} <NEW_LINE> bool ms_verify_authorizer ( Connection * con , int peer_type , <NEW_LINE> int protocol , bufferlist & authorizer_data , bufferlist & authorizer_reply , <NEW_LINE> <START_VULN> bool & isvalid , CryptoKey & session_key ) override { <NEW_LINE> <END_VULN> isvalid = true ; <NEW_LINE> return true ; <NEW_LINE> }
PaintInvalidationReason , <NEW_LINE> const String * debug_name = nullptr ) ; <NEW_LINE> PaintInvalidationReason ChunkPropertiesChanged ( <NEW_LINE> <START_VULN> const RefCountedPropertyTreeState & new_chunk_state , <NEW_LINE> <END_VULN> const PaintChunkInfo & new_chunk , <NEW_LINE> const PaintChunkInfo & old_chunk , <NEW_LINE> const PropertyTreeState & layer_state ) const ;
return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( fields -> Len > 0 ) <NEW_LINE> {
} <NEW_LINE> <START_VULN> mpz_powm ( v , v , key -> d , key -> n ) ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
Cluster ** const j = i + m_clusterCount ; <NEW_LINE> <START_VULN> if ( pTrack -> GetType ( ) == 2 ) <NEW_LINE> { <NEW_LINE> <END_VULN>
namespace dom { <NEW_LINE> class DOMCursor : public DOMRequest <NEW_LINE> , public nsIDOMDOMCursor <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> NS_DECL_ISUPPORTS_INHERITED <NEW_LINE> NS_DECL_NSIDOMDOMCURSOR <NEW_LINE> <START_VULN> NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED ( DOMCursor , <NEW_LINE>DOMRequest ) <NEW_LINE> <END_VULN> DOMCursor ( nsIDOMWindow * aWindow , nsICursorContinueCallback * aCallback ) ; <NEW_LINE> virtual JSObject * WrapObject ( JSContext * aCx , <NEW_LINE> JS::Handle < JSObject * > aScope ) MOZ_OVERRIDE ; <NEW_LINE> bool Done ( ) const <NEW_LINE> {
static const struct { <NEW_LINE> unsigned mChannels ; <NEW_LINE> unsigned mBitsPerSample ; <NEW_LINE> <START_VULN> void ( * mCopy ) ( short * dst , const int * const * src , unsigned nSamples , unsigned nChannels ) ; <NEW_LINE> <END_VULN> } table [ ] = { <NEW_LINE> { 1 , 8 , copyMono8 } , <NEW_LINE> { 2 , 8 , copyStereo8 } ,
req -> work_dir , err_name_ptr ) ; <NEW_LINE> else <NEW_LINE> snprintf ( path_name , MAXPATHLEN , " / % s" , err_name_ptr ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) { <NEW_LINE>error ( "Unable to open % s: % s" , path_name , <NEW_LINE>slurm_strerror ( errno ) ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> } <NEW_LINE> snprintf ( err_name , sizeof ( err_name ) ,
<START_VULN> void CVE_2015_4001_oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc , <NEW_LINE>int length , int offset , int total_size ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct oz_port * port = hport ; <NEW_LINE> struct urb * urb ;
const struct lmp_object_header * lmp_obj_header ; <NEW_LINE> const u_char * tptr , * obj_tptr ; <NEW_LINE> u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; <NEW_LINE> <START_VULN> int hexdump ; <NEW_LINE> <END_VULN> u_int offset ; <NEW_LINE> u_int link_type ;
int php_optind = 1 , use_extended_info = 0 ; <NEW_LINE> char * ini_path_override = NULL ; <NEW_LINE> char * ini_entries = NULL ; <NEW_LINE> <START_VULN> int ini_entries_len = 0 ; <NEW_LINE> <END_VULN> int ini_ignore = 0 ; <NEW_LINE> sapi_module_struct * sapi_module = & cli_sapi_module ;
{ <NEW_LINE> p - = 5 ; <NEW_LINE> <START_VULN> if ( ! memcmp ( chunk_name , p , 4 ) ) <NEW_LINE> <END_VULN> return p [ 4 ] ; <NEW_LINE> } <NEW_LINE> while ( p > p_end ) ;
{ <NEW_LINE> ctxt = xmlSchemaNewParserCtxt ( argv [ i ] ) ; <NEW_LINE> xmlSchemaSetParserErrors ( ctxt , <NEW_LINE> <START_VULN> ( xmlSchemaValidityErrorFunc ) fprintf , <NEW_LINE> ( xmlSchemaValidityWarningFunc ) fprintf , <NEW_LINE>stderr ) ; <NEW_LINE> <END_VULN> schema = xmlSchemaParse ( ctxt ) ; <NEW_LINE> xmlSchemaFreeParserCtxt ( ctxt ) ; <NEW_LINE> }
} <NEW_LINE> yy63: <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 599 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> #if SIZEOF_LONG == 4 <NEW_LINE> use_double:
return ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> for ( ; ; )
const char * vpx_svc_dump_statistics ( SvcContext * svc_ctx ) { <NEW_LINE> <START_VULN> int number_of_frames , number_of_keyframes , encode_frame_count ; <NEW_LINE> <END_VULN> int i , j ; <NEW_LINE> uint32_t bytes_total = 0 ; <NEW_LINE> double scale [ COMPONENTS ] ;
return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> bool WriteEbmlElement ( IMkvWriter * writer , <NEW_LINE>uint64 type , <NEW_LINE>const uint8 * value , <NEW_LINE> <END_VULN> uint64 size ) { <NEW_LINE> if ( ! writer || ! value || size < 1 ) <NEW_LINE> return false ;
void ( * short_fdct8x4 ) ( short * input , short * output , int pitch ) ; <NEW_LINE> void ( * short_walsh4x4 ) ( short * input , short * output , int pitch ) ; <NEW_LINE> void ( * quantize_b ) ( BLOCK * b , BLOCKD * d ) ; <NEW_LINE> <START_VULN> void ( * quantize_b_pair ) ( BLOCK * b1 , BLOCK * b2 , BLOCKD * d0 , BLOCKD * d1 ) ; <NEW_LINE> <END_VULN> } MACROBLOCK ;
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> n = recv ( fd , p_buf + n_read , len - n_read , 0 ) ; <NEW_LINE> <END_VULN>
public: <NEW_LINE> DisplayItemListTest ( ) <NEW_LINE> : m_displayItemList ( DisplayItemList::create ( ) ) <NEW_LINE> <START_VULN> , m_originalSlimmingPaintSubsequenceCachingEnabled ( RuntimeEnabledFeatures::slimmingPaintSubsequenceCachingEnabled ( ) ) { } <NEW_LINE> <END_VULN> protected: <NEW_LINE> DisplayItemList & displayItemList ( ) { return * m_displayItemList ; }
int jpg_validate ( jas_stream_t * in ) <NEW_LINE> { <NEW_LINE> <START_VULN> uchar buf [ JPG_MAGICLEN ] ; <NEW_LINE> <END_VULN> int i ; <NEW_LINE> int n ;
struct AutoLoadSystemDependencies <NEW_LINE> { <NEW_LINE> AutoLoadSystemDependencies ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> static LPCWSTR delayDLLs [ ] = { L"wsock32 . dll" , L"crypt32 . dll" } ; <NEW_LINE> <END_VULN> WCHAR systemDirectory [ MAX_PATH + 1 ] = { L'\0' } ; <NEW_LINE> GetSystemDirectory ( systemDirectory , MAX_PATH + 1 ) ; <NEW_LINE> size_t systemDirLen = wcslen ( systemDirectory ) ; <NEW_LINE> if ( systemDirectory [ systemDirLen - 1 ] != L'\\' && systemDirLen ) {
{ <NEW_LINE> H264_DEC_DEBUG_PRINT ( "\nError in parsing SEI message" ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> u4_bits = ih264d_get_bit_h264 ( ps_bitstrm ) ; <NEW_LINE> if ( u4_bits )
buffer [ uncompressed_length + prefix_length ] = 0 ; <NEW_LINE> <START_VULN> if ( compressed ) <NEW_LINE> <END_VULN> text . compression = PNG_ITXT_COMPRESSION_NONE ; <NEW_LINE> else
<START_VULN> <NEW_LINE> <END_VULN> virtual const extensions::Extension * GetInstalledExtension ( <NEW_LINE> const std::string & id ) const = 0 ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . enabledAtRuntimeMethod2" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( int , intArg , V8int::HasInstance ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ? V8int::toNative ( v8::Handle < v8::Object > ::Cast ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) : 0 ) ; <NEW_LINE> imp -> enabledAtRuntimeMethod2 ( intArg ) ;
avcodec_get_frame_defaults ( & pic -> avframe ) ; <NEW_LINE> <START_VULN> s -> num_refs = parse_code & 0x03 ; <NEW_LINE> <END_VULN> s -> is_arith = ( parse_code & 0x48 ) == 0x08 ; <NEW_LINE> s -> low_delay = ( parse_code & 0x88 ) == 0x88 ; <NEW_LINE> pic -> avframe . reference = ( parse_code & 0x0C ) == 0x0C ;
YYLLOC_DEFAULT ( yyloc , ( yylsp - yylen ) , yylen ) ; <NEW_LINE> YY_REDUCE_PRINT ( yyn ) ; <NEW_LINE> switch ( yyn ) <NEW_LINE> { <NEW_LINE> case 4: <NEW_LINE> { <NEW_LINE> <START_VULN> pp::TokenVector * out = context -> output ; <NEW_LINE> <END_VULN> out -> insert ( out -> end ( ) , ( yyvsp [ ( 1 ) - ( 1 ) ] . tlist ) -> begin ( ) , ( yyvsp [ ( 1 ) - ( 1 ) ] . tlist ) -> end ( ) ) ; <NEW_LINE> delete ( yyvsp [ ( 1 ) - ( 1 ) ] . tlist ) ; <NEW_LINE> ; } <NEW_LINE> break ; <NEW_LINE> case 6: <NEW_LINE> { ( yyval . tlist ) = NULL ; ; }
#define MediaStreamDescriptor_h <NEW_LINE> #include "core / platform / mediastream / MediaStreamComponent . h" <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "wtf / RefCounted . h" <NEW_LINE> #include "wtf / Vector . h"
if ( elem == NULL ) { <NEW_LINE> xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , <NEW_LINE> "xmlParseElementMixedContentDecl : Name expected\n" ) ; <NEW_LINE> <START_VULN> xmlFreeDocElementContent ( ctxt -> myDoc , cur ) ; <NEW_LINE> <END_VULN> return ( NULL ) ; <NEW_LINE> } <NEW_LINE> SKIP_BLANKS ;
# ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED <NEW_LINE> # ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED <NEW_LINE> <START_VULN> keep = png_chunk_unknown_handling ( png_ptr , png_ptr -> chunk_name ) ; <NEW_LINE> <END_VULN> # endif <NEW_LINE> # endif
} <NEW_LINE> if ( mod_loc_name == NULL ) { <NEW_LINE> <START_VULN> mod_loc_name = estrdup ( loc_name ) ; <NEW_LINE> <END_VULN> }
return ret ; <NEW_LINE> free_and_end: <NEW_LINE> <START_VULN> if ( avctx -> codec && <NEW_LINE> <END_VULN> ( codec_init_ok || <NEW_LINE> ( avctx -> codec -> caps_internal & FF_CODEC_CAP_INIT_CLEANUP ) ) ) <NEW_LINE> avctx -> codec -> close ( avctx ) ;
qsort ( sortpointer , n , sizeof ( * sortpointer ) , icomp ) ; <NEW_LINE> for ( i = 0 ; i < n ; i ++ ) look -> forward_index [ i ] = sortpointer [ i ] - info -> postlist ; <NEW_LINE> for ( i = 0 ; i < n ; i ++ ) look -> reverse_index [ look -> forward_index [ i ] ] = i ; <NEW_LINE> for ( i = 0 ; i < n ; i ++ ) look -> sorted_index [ i ] = info -> postlist [ look -> forward_index [ i ] ] ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> switch ( info -> mult ) { <NEW_LINE> case 1: <NEW_LINE> look -> quant_q = 256 ; <NEW_LINE> break ; <NEW_LINE> case 2: <NEW_LINE> look -> quant_q = 128 ; <NEW_LINE> break ;
dev -> flags |= IFF_NOARP ; <NEW_LINE> dev -> flags &= ~ IFF_MULTICAST ; <NEW_LINE> <START_VULN> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <NEW_LINE> <END_VULN> random_ether_addr ( dev -> dev_addr ) ; <NEW_LINE> }
<START_VULN> void AddStatus ( const std::string & pattern ) ; <NEW_LINE> <END_VULN>
int cnt ; <NEW_LINE> <START_VULN> if ( g -> sect <= 0 || <NEW_LINE>g -> head <= 0 || <NEW_LINE> <END_VULN> ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || <NEW_LINE> g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) ||
if ( ! version || ! * version || smatch ( version , "0 . 0 . 0" ) ) { <NEW_LINE> version = " * " ; <NEW_LINE> } <NEW_LINE> <START_VULN> mprSetJson ( route -> config , sfmt ( "dependencies . % s" , name ) , version ) ; <NEW_LINE> <END_VULN> }
mParent = aTarget ; <NEW_LINE> } <NEW_LINE> virtual nsIDOMEventTarget * GetParentTarget ( ) { return mParent ; } <NEW_LINE> NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS ( nsWindowRoot , nsIDOMEventTarget ) <NEW_LINE> protected: <NEW_LINE> <START_VULN> nsPIDOMWindow * mWindow ; <NEW_LINE> <END_VULN> nsRefPtr < nsEventListenerManager > mListenerManager ; <NEW_LINE> nsCOMPtr < nsIDOMNode > mPopupNode ; <NEW_LINE> nsCOMPtr < nsIDOMEventTarget > mParent ; <NEW_LINE> } ;
bool CanUpdateLayout ( ) override ; <NEW_LINE> void DidUpdateMainFrameLayout ( ) override ; <NEW_LINE> blink::WebString AcceptLanguages ( ) override ; <NEW_LINE> <START_VULN> void NavigateBackForwardSoon ( int offset ) override ; <NEW_LINE> <END_VULN> int HistoryBackListCount ( ) override ; <NEW_LINE> int HistoryForwardListCount ( ) override ; <NEW_LINE> void ZoomLimitsChanged ( double minimum_level , double maximum_level ) override ;
bool done_ ; <NEW_LINE> <START_VULN> const char * name_ ; <NEW_LINE> <END_VULN> private: <NEW_LINE> DISALLOW_COPY_AND_ASSIGN ( AutocompleteProvider ) ;
* cp ++ = hex [ * ep ++ & 0xf ] ; <NEW_LINE> } <NEW_LINE> * cp = '\0' ; <NEW_LINE> <START_VULN> return ( tp -> e_name ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> const char *
if ( capacity <= mHdr -> mCapacity ) <NEW_LINE> return PR_TRUE ; <NEW_LINE> <START_VULN> if ( capacity * elemSize > size_type ( - 1 ) / 2 ) { <NEW_LINE> <END_VULN> NS_ERROR ( "Attempting to allocate excessively large array" ) ; <NEW_LINE> return PR_FALSE ; <NEW_LINE> } <NEW_LINE> if ( mHdr == & sEmptyHdr ) { <NEW_LINE> Header * header = static_cast < Header * > <NEW_LINE> ( NS_Alloc ( sizeof ( Header ) + capacity * elemSize ) ) ;
rem_port = GetValueFromNameValueList ( & data , "RemotePort" ) ; <NEW_LINE> protocol = GetValueFromNameValueList ( & data , "Protocol" ) ; <NEW_LINE> <START_VULN> if ( ! int_port || ! ext_port || ! protocol ) <NEW_LINE> <END_VULN> { <NEW_LINE> ClearNameValueList ( & data ) ; <NEW_LINE> SoapError ( h , 402 , "Invalid Args" ) ;
if ( ! path ) { <NEW_LINE> path = mprJoinPath ( httpGetRouteVar ( state -> route , "LOG_DIR" ) , httpExpandRouteVars ( state -> route , option ) ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> option = stok ( option , " = \t , " , & ovalue ) ; <NEW_LINE> <END_VULN> ovalue = strim ( ovalue , "\"'" , MPR_TRIM_BOTH ) ; <NEW_LINE> if ( smatch ( option , "size" ) ) { <NEW_LINE> size = ( ssize ) getnum ( ovalue ) ;
nsCOMPtr < nsIPresShell > sh ; <NEW_LINE> rv = mDocument -> CreateShell ( cx , vm , newSet , getter_AddRefs ( sh ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , PR_FALSE ) ; <NEW_LINE> newSet . forget ( ) ; <NEW_LINE> sh -> SetVerifyReflowEnable ( PR_FALSE ) ; <NEW_LINE> vm -> SetViewObserver ( ( nsIViewObserver * ) ( ( PresShell * ) sh . get ( ) ) ) ; <NEW_LINE> { <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE> <END_VULN> sh -> InitialReflow ( r . width , r . height ) ; <NEW_LINE> } <NEW_LINE> mDocument -> BindingManager ( ) -> ProcessAttachedQueue ( ) ; <NEW_LINE> sh -> FlushPendingNotifications ( Flush_Layout ) ; <NEW_LINE> sh -> SetVerifyReflowEnable ( PR_TRUE ) ; <NEW_LINE> ( ( PresShell * ) sh . get ( ) ) -> mPaintingSuppressed = PR_FALSE ;
if ( v8Context . IsEmpty ( ) ) <NEW_LINE> return ScriptValue ( ) ; <NEW_LINE> <START_VULN> v8::Context::Scope scope ( v8Context ) ; <NEW_LINE> <END_VULN> RefPtr < Frame > protect ( m_frame ) ; <NEW_LINE> v8::Local < v8::Value > object = compileAndRunScript ( sourceCode , corsStatus ) ; <NEW_LINE> m_sourceURL = savedSourceURL ;
break ; <NEW_LINE> case BSD_AFNUM_ISO: <NEW_LINE> <START_VULN> isoclns_print ( ndo , p , length , caplen ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case BSD_AFNUM_APPLETALK:
ufd . fd = fd ; <NEW_LINE> ufd . events = POLLIN ; <NEW_LINE> ufd . revents = 0 ; <NEW_LINE> <START_VULN> if ( poll ( & ufd , 1 , 0 ) <= 0 || IS_EXCEPTION ( ufd . revents ) ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> }
<START_VULN> if ( transforms & PNG_TRANSFORM_INVERT_MONO ) <NEW_LINE> <END_VULN> #ifdef PNG_WRITE_INVERT_SUPPORTED <NEW_LINE> png_set_invert_mono ( png_ptr ) ; <NEW_LINE> #else
<START_VULN> #ifndef BASE_SEQUENCED_TASKRUNNER_H_ <NEW_LINE>#define BASE_SEQUENCED_TASKRUNNER_H_ <NEW_LINE> <END_VULN> #include "base / base_export . h" <NEW_LINE> #include "base / sequenced_task_runner_helpers . h"
if ( currChild -> isInline ( ) && ( ! currChild -> isRenderInline ( ) || curr -> generatesLineBoxesForInlineChild ( currChild ) ) ) <NEW_LINE> return curr ; <NEW_LINE> <START_VULN> if ( currChild -> isFloating ( ) || currChild -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( currChild -> isTable ( ) || ! currChild -> isRenderBlock ( ) || ( currChild -> isBox ( ) && toRenderBox ( currChild ) -> isWritingModeRoot ( ) ) )
case FILE_BEQDATE: <NEW_LINE> case FILE_LEQDATE: <NEW_LINE> if ( file_printf ( ms , F ( ms , m , " % s" ) , <NEW_LINE> <START_VULN> file_fmttime ( p -> q , FILE_T_LOCAL , tbuf ) ) == - 1 ) <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> t = ms -> offset + sizeof ( uint64_t ) ; <NEW_LINE> break ;
#define VTP_DOMAIN_NAME_LEN 32 <NEW_LINE> #define VTP_MD5_DIGEST_LEN 16 <NEW_LINE> #define VTP_UPDATE_TIMESTAMP_LEN 12 <NEW_LINE> <START_VULN> #define VTP_VLAN_INFO_OFFSET 12 <NEW_LINE> <END_VULN> #define VTP_SUMMARY_ADV 0x01 <NEW_LINE> #define VTP_SUBSET_ADV 0x02
compat_cipher_proposal ( options . ciphers ) ; <NEW_LINE> myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = <NEW_LINE> myproposal [ PROPOSAL_COMP_ALGS_STOC ] = options . compression ? <NEW_LINE> <START_VULN> "zlib@openssh . com , zlib , none" : "none , zlib@openssh . com , zlib" ; <NEW_LINE> <END_VULN> myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = <NEW_LINE> myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ; <NEW_LINE> if ( options . hostkeyalgorithms != NULL ) {
namespace content { <NEW_LINE> <START_VULN> class OffscreenCanvasSurfaceImpl : public blink::mojom::OffscreenCanvasSurface , <NEW_LINE>public cc::SurfaceFactoryClient { <NEW_LINE> <END_VULN> public: <NEW_LINE> OffscreenCanvasSurfaceImpl ( ) ; <NEW_LINE> ~ OffscreenCanvasSurfaceImpl ( ) override ;
, 523 , 539 , 553 , <NEW_LINE> 554 , 559 , 560 , 561 , 562 , 567 , 652 , 698 , 756 , 801 , <NEW_LINE> 802 , 806 , 831 , 867 , 913 , 935 , 944 , 953 , 968 , 980 , <NEW_LINE> <START_VULN> 994 , 1007 , 1019 , 1049 , 1018 , 1163 , 1162 , 1241 , 1247 , 1254 , <NEW_LINE>1253 , 1316 , 1315 , 1376 , 1385 , 1394 , 1403 , 1412 , 1421 , 1430 , <NEW_LINE>1434 , 1442 , 1443 , 1448 , 1470 , 1482 , 1498 , 1497 , 1503 , 1514 , <NEW_LINE>1515 , 1520 , 1527 , 1538 , 1539 , 1543 , 1551 , 1555 , 1565 , 1579 , <NEW_LINE>1595 , 1605 , 1614 , 1639 , 1651 , 1663 , 1679 , 1691 , 1707 , 1752 , <NEW_LINE>1771 , 1789 , 1807 , 1825 , 1851 , 1869 , 1879 , 1889 , 1899 , 1909 , <NEW_LINE>1919 , 1929 <NEW_LINE> <END_VULN> } ; <NEW_LINE> #endif
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestInterface::s_info ) ; <NEW_LINE> TestInterface * impl = static_cast < TestInterface * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 2 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> ScriptExecutionContext * scriptContext = jsCast < JSDOMGlobalObject * > ( exec -> lexicalGlobalObject ( ) ) -> scriptExecutionContext ( ) ; <NEW_LINE> if ( ! scriptContext )
dp = ( const struct ip6_frag * ) bp ; <NEW_LINE> ip6 = ( const struct ip6_hdr * ) bp2 ; <NEW_LINE> <START_VULN> ND_TCHECK ( dp -> ip6f_offlg ) ; <NEW_LINE> <END_VULN> if ( ndo -> ndo_vflag ) { <NEW_LINE> ND_PRINT ( ( ndo , "frag ( 0x % 08x: % d | % ld ) " ,
size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; <NEW_LINE> ND_PRINT ( ( ndo , " attrs = ( " ) ) ; <NEW_LINE> while ( cp < ep && cp < ep2 ) { <NEW_LINE> <START_VULN> cp = ikev1_attrmap_print ( ndo , cp , <NEW_LINE> ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> ND_PRINT ( ( ndo , " ) " ) ) ; <NEW_LINE> break ;
static sk_sp < SkImage > newSkImageFromRaster ( const SkImageInfo & info , <NEW_LINE> PassRefPtr < Uint8Array > imagePixels , <NEW_LINE> <START_VULN> size_t imageRowBytes ) { <NEW_LINE> <END_VULN> SkPixmap pixmap ( info , imagePixels -> data ( ) , imageRowBytes ) ; <NEW_LINE> return SkImage::MakeFromRaster ( pixmap , <NEW_LINE> [ ] ( const void * , void * pixels ) {
<START_VULN> int open_debug_log ( void ) { <NEW_LINE> <END_VULN> if ( verify_config || test_scheduling == TRUE )
virtual ~ Camera2ClientBase ( ) ; <NEW_LINE> virtual status_t initialize ( camera_module_t * module ) ; <NEW_LINE> <START_VULN> virtual status_t dump ( int fd , const Vector < String16 > & args ) ; <NEW_LINE> <END_VULN>
<START_VULN> TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , <NEW_LINE> <END_VULN> TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , <NEW_LINE> UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) ;
void <NEW_LINE> StackFrame::epilogue ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( ! isYielding ( ) ) ; <NEW_LINE> JS_ASSERT ( ! hasBlockChain ( ) ) ; <NEW_LINE> RootedScript script ( cx , this -> script ( ) ) ; <NEW_LINE> <START_VULN> probes::ExitScript ( cx , script , script -> function ( ) , this ) ; <NEW_LINE> <END_VULN> if ( isEvalFrame ( ) ) { <NEW_LINE> if ( isStrictEvalFrame ( ) ) { <NEW_LINE> JS_ASSERT_IF ( hasCallObj ( ) , scopeChain ( ) -> as < CallObject > ( ) . isForEval ( ) ) ; <NEW_LINE> if ( JS_UNLIKELY ( cx -> compartment ( ) -> debugMode ( ) ) ) <NEW_LINE> DebugScopes::onPopStrictEvalScope ( this ) ; <NEW_LINE> } else if ( isDirectEvalFrame ( ) ) { <NEW_LINE> if ( isDebuggerFrame ( ) )
} <NEW_LINE> <START_VULN> if ( diff == StyleDifferenceRepaint || diff == StyleDifferenceRepaintLayer ) { <NEW_LINE> <END_VULN> RenderObject * parentToInvalidate = parent ( ) ; <NEW_LINE> for ( unsigned i = 0 ; i < backgroundObscurationTestMaxDepth && parentToInvalidate ; ++ i ) { <NEW_LINE> parentToInvalidate -> invalidateBackgroundObscurationStatus ( ) ;
{ <NEW_LINE> struct crypto_report_comp rpcomp ; <NEW_LINE> <START_VULN> snprintf ( rpcomp . type , CRYPTO_MAX_ALG_NAME , " % s" , "pcomp" ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , <NEW_LINE> sizeof ( struct crypto_report_comp ) , & rpcomp ) ) <NEW_LINE> goto nla_put_failure ;
struct AutoLoadSystemDependencies <NEW_LINE> { <NEW_LINE> AutoLoadSystemDependencies ( ) <NEW_LINE> { <NEW_LINE> SetDllDirectory ( L"" ) ; <NEW_LINE> <START_VULN> static LPCWSTR delayDLLs [ ] = { L"wsock32 . dll" , L"crypt32 . dll" , <NEW_LINE>L"cryptsp . dll" , L"cryptbase . dll" , <NEW_LINE>L"msasn1 . dll" , L"userenv . dll" , <NEW_LINE>L"secur32 . dll" } ; <NEW_LINE> <END_VULN> WCHAR systemDirectory [ MAX_PATH + 1 ] = { L'\0' } ; <NEW_LINE> GetSystemDirectory ( systemDirectory , MAX_PATH + 1 ) ; <NEW_LINE> size_t systemDirLen = wcslen ( systemDirectory ) ;
die_with_error ( "Can't open / proc" ) ; <NEW_LINE> <START_VULN> base_path = xasprintf ( " / run / user / % d / . bubblewrap" , real_uid ) ; <NEW_LINE>if ( ensure_dir ( base_path , 0755 ) ) <NEW_LINE> { <NEW_LINE>free ( base_path ) ; <NEW_LINE>base_path = xasprintf ( " / tmp / . bubblewrap - % d" , real_uid ) ; <NEW_LINE>if ( ensure_dir ( base_path , 0755 ) ) <NEW_LINE>die_with_error ( "Creating root mountpoint failed" ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> __debug__ ( ( "creating new namespace\n" ) ) ;
target_frame -> Navigate ( request ) ; <NEW_LINE> Page * page = target_frame -> GetPage ( ) ; <NEW_LINE> if ( ! was_in_same_page && page ) <NEW_LINE> <START_VULN> page -> GetChromeClient ( ) . Focus ( ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
jsval v = OBJECT_TO_JSVAL ( dot_prototype ) ; <NEW_LINE> <START_VULN> if ( ! ::JS_SetProperty ( cx , class_obj , "prototype" , & v ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_UNEXPECTED ; <NEW_LINE> }
uint64 rowblockbytes ; <NEW_LINE> uint64 stripbytes ; <NEW_LINE> uint32 strip ; <NEW_LINE> <START_VULN> uint64 nstrips64 ; <NEW_LINE>uint32 nstrips32 ; <NEW_LINE> <END_VULN> uint32 rowsperstrip ; <NEW_LINE> uint64 * newcounts ; <NEW_LINE> uint64 * newoffsets ;
% <NEW_LINE> <START_VULN> static unsigned int XBMInteger ( Image * image , short int * hex_digits ) <NEW_LINE> <END_VULN> { <NEW_LINE> int <NEW_LINE> c ;
if ( env -> log . level ) { <NEW_LINE> if ( do_print_state ) <NEW_LINE> <START_VULN> verbose ( env , "\nfrom % d to % d: safe\n" , <NEW_LINE>env -> prev_insn_idx , env -> insn_idx ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> verbose ( env , " % d: safe\n" , env -> insn_idx ) ; <NEW_LINE> }
#define MODULE_MAGIC_COOKIE 0x41503235UL <NEW_LINE> #ifndef MODULE_MAGIC_NUMBER_MAJOR <NEW_LINE> #define MODULE_MAGIC_NUMBER_MAJOR 20150222 <NEW_LINE> #endif <NEW_LINE> <START_VULN> #define MODULE_MAGIC_NUMBER_MINOR 2 <NEW_LINE> <END_VULN>
{ <NEW_LINE> png_uint_32 retval = 0 ; <NEW_LINE> <START_VULN> if ( png_ptr != NULL && info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_pHYs ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_debug1 ( 1 , "in % s retrieval function" , "pHYs" ) ;
} else { <NEW_LINE> bool haveNormalFlowChild = false ; <NEW_LINE> for ( RenderBox * curr = lastChildBox ( ) ; curr ; curr = curr -> previousSiblingBox ( ) ) { <NEW_LINE> <START_VULN> if ( ! curr -> isFloatingOrPositioned ( ) ) { <NEW_LINE> <END_VULN> haveNormalFlowChild = true ; <NEW_LINE> LayoutUnit result = curr -> lastLineBoxBaseline ( ) ; <NEW_LINE> if ( result != - 1 )
ASSERT ( ( & term - term . atom . parenthesesWidth ) -> type == ByteTerm::TypeParenthesesSubpatternOnceBegin ) ; <NEW_LINE> #if 0 <NEW_LINE> ASSERT ( ( & term - term . atom . parenthesesWidth ) -> inputPosition == term . inputPosition ) ; <NEW_LINE> #endif <NEW_LINE> unsigned subpatternId = term . atom . subpatternId ; <NEW_LINE> <START_VULN> output [ subpatternId << 1 ] = input . getPos ( ) + ( & term - term . atom . parenthesesWidth ) -> inputPosition ; <NEW_LINE> <END_VULN> } <NEW_LINE> context -> term - = term . atom . parenthesesWidth ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> case QuantifierFixedCount: <NEW_LINE> break ; <NEW_LINE> }
float secs = ( float ) n / vi -> rate ; <NEW_LINE> amp += secs * gi -> ampmax_att_per_sec ; <NEW_LINE> if ( amp < - 9999 ) amp = - 9999 ; <NEW_LINE> return ( amp ) ; <NEW_LINE> } <NEW_LINE> static void couple_lossless ( float A , float B , <NEW_LINE> <START_VULN> float * qA , float * qB ) { <NEW_LINE> <END_VULN> int test1 = fabs ( * qA ) > fabs ( * qB ) ; <NEW_LINE> test1 - = fabs ( * qA ) < fabs ( * qB ) ; <NEW_LINE> if ( ! test1 ) test1 = ( ( fabs ( A ) > fabs ( B ) ) << 1 ) - 1 ; <NEW_LINE> if ( test1 == 1 ) { <NEW_LINE> * qB = ( * qA > 0 . f ? * qA - * qB: * qB - * qA ) ; <NEW_LINE> } else { <NEW_LINE> float temp = * qB ;
storage_texture_supported_ = <NEW_LINE> <START_VULN> ( web_gl_version_ > kWebGL1 || <NEW_LINE> <END_VULN> extensions_util_ -> SupportsExtension ( "GL_EXT_texture_storage" ) ) && <NEW_LINE> anti_aliasing_mode_ == kScreenSpaceAntialiasing ; <NEW_LINE> sample_count_ = std::min ( 4 , max_sample_count ) ;
( void ) SetImageType ( huffman_image , BilevelType ) ; <NEW_LINE> write_info = CloneImageInfo ( ( ImageInfo * ) NULL ) ; <NEW_LINE> SetImageInfoFile ( write_info , file ) ; <NEW_LINE> <START_VULN> ( void ) SetImageType ( image , BilevelType ) ; <NEW_LINE> <END_VULN> ( void ) SetImageDepth ( image , 1 ) ; <NEW_LINE> write_info -> compression = Group4Compression ; <NEW_LINE> write_info -> type = BilevelType ; <NEW_LINE> ( void ) SetImageOption ( write_info , "quantum:polarity" , "min - is - white" ) ;
} <NEW_LINE> } <NEW_LINE> if ( value -> IsGeneratorObject ( ) ) { <NEW_LINE> <START_VULN> v8::Local < v8::Value > location = generatorObjectLocation ( v8::Local < v8::Object > ::Cast ( value ) ) ; <NEW_LINE> <END_VULN> if ( location -> IsObject ( ) ) { <NEW_LINE> properties -> Set ( properties -> Length ( ) , toV8StringInternalized ( m_isolate , " [ [ GeneratorLocation ] ] " ) ) ; <NEW_LINE> properties -> Set ( properties -> Length ( ) , location ) ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> RasterImage::RequestDiscard ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( CanDiscard ( ) ) { <NEW_LINE> <END_VULN> ForceDiscard ( ) ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult
status_t resetDecoder ( ) ; <NEW_LINE> status_t resetPlugin ( ) ; <NEW_LINE> <START_VULN> void setDecodeArgs ( ivd_video_decode_ip_t * ps_dec_ip , <NEW_LINE> <END_VULN> ivd_video_decode_op_t * ps_dec_op , <NEW_LINE> OMX_BUFFERHEADERTYPE * inHeader , <NEW_LINE> OMX_BUFFERHEADERTYPE * outHeader ,
if ( ( key = stok ( & tok [ 2 ] , " . : } " , & value ) ) == 0 ) { <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> stok ( value , " } " , & cp ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( smatch ( key , "header" ) ) { <NEW_LINE> header = stok ( value , " = " , & defaultValue ) ; <NEW_LINE> if ( ( value = ( char * ) httpGetHeader ( conn , header ) ) == 0 ) {
TraceMonitor * tm = & JS_THREAD_DATA ( cx ) -> traceMonitor ; <NEW_LINE> JS_ASSERT ( tm -> codeAlloc && tm -> dataAlloc && tm -> traceAlloc ) ; <NEW_LINE> if ( bytes > 1 G ) <NEW_LINE> bytes = 1 G ; <NEW_LINE> if ( bytes < 128 K ) <NEW_LINE> bytes = 128 K ; <NEW_LINE> tm -> maxCodeCacheBytes = bytes ; <NEW_LINE> } <NEW_LINE> <START_VULN> void <NEW_LINE> <END_VULN> InitJIT ( TraceMonitor * tm ) <NEW_LINE> { <NEW_LINE> #if defined JS_JIT_SPEW <NEW_LINE> tm -> profAlloc = NULL ; <NEW_LINE> if ( ! did_we_set_up_debug_logging ) { <NEW_LINE> InitJITLogController ( ) ; <NEW_LINE> did_we_set_up_debug_logging = true ; <NEW_LINE> }
if ( newUpper < newLower ) { <NEW_LINE> <START_VULN> * emptyRange = true ; <NEW_LINE> <END_VULN> return nullptr ; <NEW_LINE> } <NEW_LINE> bool newHasInt32LowerBound = lhs -> hasInt32LowerBound_ || rhs -> hasInt32LowerBound_ ; <NEW_LINE> bool newHasInt32UpperBound = lhs -> hasInt32UpperBound_ || rhs -> hasInt32UpperBound_ ; <NEW_LINE> bool newFractional = lhs -> canHaveFractionalPart_ && rhs -> canHaveFractionalPart_ ; <NEW_LINE> uint16_t newExponent = Min ( lhs -> max_exponent_ , rhs -> max_exponent_ ) ;
this , flatHeader . get ( ) , flatValue . get ( ) , merge ) ) ; <NEW_LINE> <START_VULN> if ( ! IsValidToken ( flatHeader ) ) <NEW_LINE> <END_VULN> return NS_ERROR_INVALID_ARG ;
class V4L2VP8Picture ; <NEW_LINE> class VaapiVP8Picture ; <NEW_LINE> <START_VULN> class VP8Picture : public base::RefCounted < VP8Picture > { <NEW_LINE> <END_VULN> public: <NEW_LINE> VP8Picture ( ) ;
for ( PRInt32 i = ac - 1 ; i >= 0 ; i -- ) { <NEW_LINE> rv = NS_OK ; <NEW_LINE> nsContentUtils::ASCIIToLower ( aNode . GetKeyAt ( i ) , k ) ; <NEW_LINE> nsCOMPtr < nsIAtom > keyAtom = do_GetAtom ( k ) ; <NEW_LINE> if ( ! sAllowedAttributes || ! sAllowedAttributes -> GetEntry ( keyAtom ) ) { <NEW_LINE> <START_VULN> continue ; <NEW_LINE> <END_VULN> } <NEW_LINE> static const char * kWhitespace = "\n\r\t\b" ; <NEW_LINE> const nsAString & v = <NEW_LINE> nsContentUtils::TrimCharsInSet ( kWhitespace , aNode . GetValueAt ( i ) ) ;
bool <NEW_LINE> RasterImage::IsDecodeFinished ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> mDecodingMutex . AssertCurrentThreadOwns ( ) ; <NEW_LINE> <END_VULN> NS_ABORT_IF_FALSE ( mDecoder , "Can't call IsDecodeFinished ( ) without decoder ! " ) ; <NEW_LINE> if ( mDecoder -> IsSizeDecode ( ) ) { <NEW_LINE> if ( mDecoder -> HasSize ( ) ) { <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> } else if ( mDecoder -> GetDecodeDone ( ) ) {
return JSValue::encode ( jsUndefined ( ) ) ; <NEW_LINE> TestActiveDOMObject * impl = static_cast < TestActiveDOMObject * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> Node * nextChild ( toNode ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
DISALLOW_COPY_AND_ASSIGN ( DevToolsAgentFilter ) ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
{ <NEW_LINE> png_app_error ( png_ptr , "invalid unknown chunk location" ) ; <NEW_LINE> <START_VULN> if ( ( location & PNG_HAVE_IDAT ) ) <NEW_LINE> <END_VULN> location = PNG_AFTER_IDAT ; <NEW_LINE> else
static inline unsigned int __xfrm4_daddr_saddr_hash ( xfrm_address_t * daddr , xfrm_address_t * saddr ) <NEW_LINE> { <NEW_LINE> <START_VULN> return ntohl ( daddr -> a4 ^ saddr -> a4 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline unsigned int __xfrm6_daddr_saddr_hash ( xfrm_address_t * daddr , xfrm_address_t * saddr )
uhid_set_non_blocking ( p_dev -> fd ) ; <NEW_LINE> while ( p_dev -> hh_keep_polling ) { <NEW_LINE> <START_VULN> ret = poll ( pfds , 1 , 50 ) ; <NEW_LINE> <END_VULN> if ( ret < 0 ) { <NEW_LINE> APPL_TRACE_ERROR ( " % s: Cannot poll for fds: % s\n" , __FUNCTION__ , strerror ( errno ) ) ; <NEW_LINE> break ;
return false ; <NEW_LINE> WeakMap * weakmap = fromJSObject ( obj ) ; <NEW_LINE> if ( weakmap ) { <NEW_LINE> <START_VULN> js::HashMap < JSObject * , Value > ::Ptr ptr = weakmap -> map . lookup ( key ) ; <NEW_LINE> <END_VULN> if ( ptr ) { <NEW_LINE> * vp = ptr -> value ; <NEW_LINE> return true ;
pos = ( OnigUChar * ) string + n ; <NEW_LINE> } else { <NEW_LINE> if ( pos < string_lim ) { <NEW_LINE> <START_VULN> smart_str_appendl ( & out_buf , pos , 1 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> pos ++ ; <NEW_LINE> }
while ( png_ptr -> zstream . avail_in > 0 && <NEW_LINE> <START_VULN> ! ( png_ptr -> flags & PNG_FLAG_ZSTREAM_ENDED ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> int ret ;
readbuf [ i ] = png_get_uint_16 ( buf ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> png_set_hIST ( png_ptr , info_ptr , readbuf ) ;
if ( crc == png_sRGB_checks [ i ] . crc ) <NEW_LINE> # endif <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_sRGB_checks [ i ] . is_broken ) <NEW_LINE> <END_VULN> {
{ <NEW_LINE> INC_STATS ( "DOM . DataView . setUint8" ) ; <NEW_LINE> if ( args . Length ( ) < 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> DataView * imp = V8DataView::toNative ( args . Holder ( ) ) ; <NEW_LINE> ExceptionCode ec = 0 ;
if ( NS_FAILED ( rv ) ) <NEW_LINE> widget -> ResetInputState ( ) ; <NEW_LINE> IMEState newState = GetNewIMEState ( sPresContext , nullptr ) ; <NEW_LINE> InputContextAction action ( InputContextAction::CAUSE_UNKNOWN , <NEW_LINE> InputContextAction::LOST_FOCUS ) ; <NEW_LINE> SetIMEState ( newState , nullptr , widget , action ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> sContent = nullptr ; <NEW_LINE> <END_VULN> sPresContext = nullptr ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsIMEStateManager::OnChangeFocus ( nsPresContext * aPresContext , <NEW_LINE> nsIContent * aContent ,
do { <NEW_LINE> next = pmd_addr_end ( addr , end ) ; <NEW_LINE> split_huge_page_pmd ( vma -> vm_mm , pmd ) ; <NEW_LINE> <START_VULN> if ( pmd_none_or_clear_bad ( pmd ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( check_pte_range ( vma , pmd , addr , next , nodes , <NEW_LINE> flags , private ) )
bool ms_get_authorizer ( int dest_type , AuthAuthorizer ** authorizer , bool force_new ) override ; <NEW_LINE> bool ms_verify_authorizer ( Connection * con , int peer_type , <NEW_LINE> int protocol , bufferlist & authorizer_data , bufferlist & authorizer_reply , <NEW_LINE> <START_VULN> bool & isvalid , CryptoKey & session_key ) override ; <NEW_LINE> <END_VULN> void ms_handle_accept ( Connection * con ) override ; <NEW_LINE> void ms_handle_connect ( Connection * con ) override ; <NEW_LINE> bool ms_handle_reset ( Connection * con ) override ;
mFoundBOM = PR_FALSE ; <NEW_LINE> return nsUTF16ToUnicodeBase::Reset ( ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsUTF16ToUnicode::Convert ( const char * aSrc , PRInt32 * aSrcLength , <NEW_LINE> PRUnichar * aDest , PRInt32 * aDestLength ) <NEW_LINE> { <NEW_LINE> if ( STATE_FIRST_CALL == mState ) <NEW_LINE> { <NEW_LINE> mState = STATE_NORMAL ; <NEW_LINE> <START_VULN> if ( * aSrcLength < 2 ) <NEW_LINE>return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE><NEW_LINE> <END_VULN> if ( 0xFF == PRUint8 ( aSrc [ 0 ] ) && 0xFE == PRUint8 ( aSrc [ 1 ] ) ) { <NEW_LINE> mState = STATE_FOUND_BOM ; <NEW_LINE> mEndian = kLittleEndian ; <NEW_LINE> mFoundBOM = PR_TRUE ; <NEW_LINE> } <NEW_LINE> else if ( 0xFE == PRUint8 ( aSrc [ 0 ] ) && 0xFF == PRUint8 ( aSrc [ 1 ] ) ) {
generic_ret * init_2_svc ( krb5_ui_4 * arg , struct svc_req * rqstp ) <NEW_LINE> { <NEW_LINE> static generic_ret ret ; <NEW_LINE> <START_VULN> gss_buffer_desc client_name , <NEW_LINE>service_name ; <NEW_LINE> <END_VULN> kadm5_server_handle_t handle ; <NEW_LINE> OM_uint32 minor_stat ; <NEW_LINE> const char * errmsg = NULL ;
{ <NEW_LINE> } <NEW_LINE> } ; <NEW_LINE> <START_VULN> TEST_F ( CCLayerTreeHostTestShortlived3 , run ) <NEW_LINE> { <NEW_LINE>runTest ( ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> class CCLayerTreeHostTestCommitingWithContinuousRedraw : public CCLayerTreeHostTest {
nsString lockType ; <NEW_LINE> int32_t retryCount = - 1 ; <NEW_LINE> nsresult rv ; <NEW_LINE> nsIScriptContext * sc = GetContextForEventHandlers ( & rv ) ; <NEW_LINE> NS_ENSURE_STATE ( sc ) ; <NEW_LINE> <START_VULN> JSContext * cx = sc -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( cx , "Failed to get a context ! " ) ; <NEW_LINE> nsCOMPtr < nsIJSON > json ( new nsJSON ( ) ) ; <NEW_LINE> jsval error ; <NEW_LINE> rv = json -> DecodeToJSVal ( errorMsg , cx , & error ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> jsval type ;
<START_VULN> png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , <NEW_LINE> <END_VULN> NULL , NULL , NULL ) ; <NEW_LINE> if ( ! png_ptr ) <NEW_LINE> return FALSE ;
& param_iid , obj , nsnull ) ) <NEW_LINE> goto pre_call_clean_up ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( param . IsOut ( ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> JSObject * out_obj = NewOutObject ( cx ) ; <NEW_LINE> <END_VULN> if ( ! out_obj ) <NEW_LINE> { <NEW_LINE> retval = NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> goto pre_call_clean_up ; <NEW_LINE> } <NEW_LINE> if ( param . IsIn ( ) ) <NEW_LINE> {
DebugOnly < nsresult > rv = newCtx -> InitContext ( ) ; <NEW_LINE> NS_WARN_IF_FALSE ( NS_SUCCEEDED ( rv ) , "Script Language's InitContext failed" ) ; <NEW_LINE> newCtx -> DidInitializeContext ( ) ; <NEW_LINE> mScriptContext = newCtx ; <NEW_LINE> <START_VULN> JSContext * cx = mScriptContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JS_SetErrorReporter ( cx , XBL_ProtoErrorReporter ) ; <NEW_LINE> mJSObject = JS_NewGlobalObject ( cx , & gSharedGlobalClass ,
png_set_gamma_fixed ( png_ptr , convert_gamma_value ( png_ptr , scrn_gamma ) , <NEW_LINE> convert_gamma_value ( png_ptr , file_gamma ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> # endif <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef PNG_READ_EXPAND_SUPPORTED
static void <NEW_LINE> <START_VULN> row_copy ( png_bytep toBuffer , png_const_bytep fromBuffer , unsigned int bitWidth ) <NEW_LINE> <END_VULN> { <NEW_LINE> memcpy ( toBuffer , fromBuffer , bitWidth >> 3 ) ;
SequentialExecution ) ; <NEW_LINE> if ( ! info ) <NEW_LINE> return false ; <NEW_LINE> MIRGraphExits saveExits ; <NEW_LINE> AutoAccumulateExits aae ( graph ( ) , saveExits ) ; <NEW_LINE> IonBuilder inlineBuilder ( cx , & temp ( ) , & graph ( ) , & oracle , <NEW_LINE> <START_VULN> info , inliningDepth + 1 , loopDepth_ ) ; <NEW_LINE> <END_VULN> if ( ! inlineBuilder . buildInline ( this , resumePoint , callInfo ) ) { <NEW_LINE> JS_ASSERT ( calleeScript -> hasAnalysis ( ) ) ; <NEW_LINE> if ( inlineBuilder . abortReason_ == AbortReason_Disable ) <NEW_LINE> calleeScript -> analysis ( ) -> setIonUninlineable ( ) ;
mFrameConstructor -> ProcessPendingRestyles ( ) ; <NEW_LINE> } <NEW_LINE> if ( ! mIsDestroying ) { <NEW_LINE> { <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE> <END_VULN> WillDoReflow ( ) ; <NEW_LINE> AUTO_LAYOUT_PHASE_ENTRY_POINT ( GetPresContext ( ) , Reflow ) ; <NEW_LINE> mIsReflowing = PR_TRUE ; <NEW_LINE> mDirtyRoots . RemoveElement ( rootFrame ) ; <NEW_LINE> DoReflow ( rootFrame ) ;
<START_VULN> vpx_memset ( ( & oci -> post_proc_buffer_int ) -> buffer_alloc , 128 , ( & oci -> post_proc_buffer ) -> frame_size ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
ASH_EXPORT constexpr int kShelfTranslucentOverAppList = 51 ; <NEW_LINE> ASH_EXPORT constexpr int kShelfTranslucentAlpha = 153 ; <NEW_LINE> <START_VULN> ASH_EXPORT constexpr int kShelfTranslucentMaximizedWindow = 255 ; <NEW_LINE> <END_VULN>
typedef struct _dumpOptions <NEW_LINE> { <NEW_LINE> <START_VULN> const char * dbname ; <NEW_LINE> <END_VULN> const char * pghost ; <NEW_LINE> const char * pgport ; <NEW_LINE> const char * username ;
int new_mv_mode_penalty = 256 ; <NEW_LINE> <START_VULN> v_fn_ptr . vf = vp8_mse16x16 ; <NEW_LINE> <END_VULN> xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ;
} <NEW_LINE> LOG_ERROR ( " % s restarting the bluetooth process . " , __func__ ) ; <NEW_LINE> <START_VULN> usleep ( 10000 ) ; <NEW_LINE> <END_VULN> kill ( getpid ( ) , SIGKILL ) ; <NEW_LINE> }
} <NEW_LINE> if ( zr_rsrc -> zf ) { <NEW_LINE> <START_VULN> buffer = zend_string_alloc ( len , 0 ) ; <NEW_LINE> <END_VULN> n = zip_fread ( zr_rsrc -> zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ; <NEW_LINE> if ( n > 0 ) { <NEW_LINE> ZSTR_VAL ( buffer ) [ n ] = '\0' ;
register ssize_t <NEW_LINE> i ; <NEW_LINE> <START_VULN> for ( i = 0 ; i < ( ssize_t ) GetPixelChannels ( Cr_image ) ; i ++ ) <NEW_LINE> <END_VULN> { <NEW_LINE> switch ( op ) <NEW_LINE> {
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . overloadedMethod1" ) ; <NEW_LINE> if ( args . Length ( ) < 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( TestObj * , objArg , V8TestObj::HasInstance ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ? V8TestObj::toNative ( v8::Handle < v8::Object > ::Cast ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) : 0 ) ; <NEW_LINE> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , strArg , MAYBE_MISSING_PARAMETER ( args , 1 , DefaultIsUndefined ) ) ;
static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , <NEW_LINE> unsigned int data_sz , <NEW_LINE> vpx_codec_stream_info_t * si , <NEW_LINE> <START_VULN> vp8_decrypt_cb * decrypt_cb , <NEW_LINE> <END_VULN> void * decrypt_state ) <NEW_LINE> { <NEW_LINE> vpx_codec_err_t res = VPX_CODEC_OK ;
RD_BOOL ber_in_header ( STREAM s , int * tagval , int * length ) ; <NEW_LINE> void ber_out_header ( STREAM s , int tagval , int length ) ; <NEW_LINE> <START_VULN> RD_BOOL ber_parse_header ( STREAM s , int tagval , int * length ) ; <NEW_LINE> <END_VULN> void ber_out_integer ( STREAM s , int value ) ; <NEW_LINE> void ber_out_sequence ( STREAM s , STREAM contents ) ;
} <NEW_LINE> uint64 Chapter::WriteAtom ( IMkvWriter * writer ) const { <NEW_LINE> <START_VULN> uint64 payload_size = <NEW_LINE>EbmlElementSize ( kMkvChapterStringUID , id_ ) + <NEW_LINE>EbmlElementSize ( kMkvChapterUID , uid_ ) + <NEW_LINE>EbmlElementSize ( kMkvChapterTimeStart , start_timecode_ ) + <NEW_LINE>EbmlElementSize ( kMkvChapterTimeEnd , end_timecode_ ) ; <NEW_LINE> <END_VULN> for ( int idx = 0 ; idx < displays_count_ ; ++ idx ) { <NEW_LINE> const Display & d = displays_ [ idx ] ;
pendingScript . stopWatchingForLoad ( this ) ; <NEW_LINE> if ( ! isExecutingScript ( ) ) { <NEW_LINE> <START_VULN> Microtask::performCheckpoint ( ) ; <NEW_LINE> <END_VULN> if ( pendingScriptType == PendingScript::ParsingBlocking ) { <NEW_LINE> m_hasScriptsWaitingForResources = ! m_document -> isScriptExecutionReady ( ) ;
return FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <NEW_LINE> <END_VULN> UINT32 scanline ) <NEW_LINE> { <NEW_LINE> UINT16 x ;
mOverwrite ( aOverwrite ) <NEW_LINE> { <NEW_LINE> mCloneWriteInfo . Swap ( aCloneWriteInfo ) ; <NEW_LINE> mIndexUpdateInfo . SwapElements ( aIndexUpdateInfo ) ; <NEW_LINE> } <NEW_LINE> ~ AddHelper ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( mCloneWriteInfo . mCloneBuffer ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> virtual nsresult DoDatabaseWork ( mozIStorageConnection * aConnection ) <NEW_LINE> MOZ_OVERRIDE ; <NEW_LINE> virtual nsresult GetSuccessResult ( JSContext * aCx , <NEW_LINE> jsval * aVal ) MOZ_OVERRIDE ;
return false ; <NEW_LINE> const AtomicString & ariaSelected = getAttribute ( aria_selectedAttr ) ; <NEW_LINE> <START_VULN> if ( equalIgnoringCase ( ariaSelected , "true" ) ) <NEW_LINE> <END_VULN> return true ; <NEW_LINE> AXObject * focusedObject = axObjectCache ( ) . focusedObject ( ) ;
virtual void Print ( gfx::NativeDrawingContext context ) ; <NEW_LINE> virtual NPObject * GetPluginScriptableObject ( ) ; <NEW_LINE> virtual void DidFinishLoadWithReason ( const GURL & url , NPReason reason , <NEW_LINE> <START_VULN> intptr_t notify_data ) ; <NEW_LINE> <END_VULN> virtual void SetFocus ( ) ; <NEW_LINE> virtual bool HandleInputEvent ( const WebKit::WebInputEvent & event , <NEW_LINE> WebKit::WebCursorInfo * cursor ) ;
else if ( y >= b -> image . colormap_entries ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ( a -> opts & ACCUMULATE ) == 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> char pindex [ 9 ] ; <NEW_LINE> sprintf ( pindex , " % lu [ % lu ] " , ( unsigned long ) y ,
if ( mStyleSheet && aOldDocument ) { <NEW_LINE> aOldDocument -> BeginUpdate ( UPDATE_STYLE ) ; <NEW_LINE> aOldDocument -> RemoveStyleSheet ( mStyleSheet ) ; <NEW_LINE> aOldDocument -> EndUpdate ( UPDATE_STYLE ) ; <NEW_LINE> <START_VULN> mStyleSheet = nsnull ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( mDontLoadStyle || ! mUpdatesEnabled ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIContent > thisContent ; <NEW_LINE> QueryInterface ( NS_GET_IID ( nsIContent ) , getter_AddRefs ( thisContent ) ) ;
visible_selection . Start ( ) ) ; <NEW_LINE> } <NEW_LINE> builder . SetAffinity ( visible_selection . Affinity ( ) ) ; <NEW_LINE> <START_VULN> builder . SetIsHandleVisible ( IsHandleVisible ( ) ) ; <NEW_LINE> <END_VULN> SetSelection ( builder . Build ( ) , SetSelectionData::Builder ( ) <NEW_LINE> . SetShouldCloseTyping ( true ) <NEW_LINE> . SetShouldClearTypingStyle ( true ) <NEW_LINE> . SetGranularity ( granularity ) <NEW_LINE> . Build ( ) ) ; <NEW_LINE> }
MediaTrackConstraints resolver_constraints ; <NEW_LINE> resolver_constraints . setAdvanced ( constraints_vector ) ; <NEW_LINE> <START_VULN> auto resolver_cb = WTF::Bind ( & ImageCapture::ResolveWithMediaTrackConstraints , <NEW_LINE>WrapPersistent ( this ) , resolver_constraints ) ; <NEW_LINE> <END_VULN> service_ -> SetOptions ( <NEW_LINE> stream_track_ -> Component ( ) -> Source ( ) -> Id ( ) , std::move ( settings ) ,
++ entry_start ; <NEW_LINE> <START_VULN> if ( entry_start > buffer + length - 2 ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_warning ( png_ptr , "malformed sPLT chunk" ) ; <NEW_LINE> return ;
chnMem . autoPortaDown = 0 ; <NEW_LINE> chnMem . autoTonePorta = 0 ; <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x06:
this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; <NEW_LINE> } <NEW_LINE> if ( ref_frame == INTRA_FRAME ) { <NEW_LINE> if ( this_rd < best_intra_rd ) { <NEW_LINE> best_intra_rd = this_rd ; <NEW_LINE> best_intra_mode = mbmi -> mode ; <NEW_LINE> } <NEW_LINE> <START_VULN> } else { <NEW_LINE><NEW_LINE>if ( ! comp_pred && ! mode_excluded && this_rd < best_inter_rd ) { <NEW_LINE>best_inter_rd = this_rd ; <NEW_LINE>best_inter_ref_frame = ref_frame ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! disable_skip && ref_frame == INTRA_FRAME ) {
using namespace mozilla ; <NEW_LINE> using namespace js ; <NEW_LINE> bool <NEW_LINE> JSString::isShort ( ) const <NEW_LINE> { <NEW_LINE> bool is_short = ( getAllocKind ( ) == gc::FINALIZE_SHORT_STRING ) ; <NEW_LINE> <START_VULN> JS_ASSERT_IF ( is_short , isFlat ( ) ) ; <NEW_LINE> <END_VULN> return is_short ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> JSString::isFixed ( ) const <NEW_LINE> { <NEW_LINE> return isFlat ( ) && ! isExtensible ( ) ; <NEW_LINE> }
{ 0x0000a7b1 , FC_CASE_FOLD_RANGE , 0x0001 , 23254 } , <NEW_LINE> { 0x0000a7b2 , FC_CASE_FOLD_RANGE , 0x0001 , 23275 } , <NEW_LINE> { 0x0000a7b3 , FC_CASE_FOLD_RANGE , 0x0001 , 928 } , <NEW_LINE> <START_VULN> { 0x0000a7b4 , FC_CASE_FOLD_EVEN_ODD , 0x0005 , 1 } , <NEW_LINE> <END_VULN> { 0x0000ab70 , FC_CASE_FOLD_RANGE , 0x0050 , 26672 } , <NEW_LINE> { 0x0000fb00 , FC_CASE_FOLD_FULL , 0x0002 , 435 } , <NEW_LINE> { 0x0000fb01 , FC_CASE_FOLD_FULL , 0x0002 , 437 } ,
break ; <NEW_LINE> case PNG_FP_EXPONENT + PNG_FP_SAW_SIGN: <NEW_LINE> <START_VULN> if ( state & PNG_FP_SAW_ANY ) <NEW_LINE> <END_VULN> goto PNG_FP_End ; <NEW_LINE> png_fp_add ( state , PNG_FP_SAW_SIGN ) ;
#endif <NEW_LINE> if ( mount ( fsname , target , fstype , <NEW_LINE> <START_VULN> mountflags | MS_REMOUNT , data ) ) { <NEW_LINE> <END_VULN> if ( optional ) { <NEW_LINE> INFO ( "failed to mount ' % s' on ' % s' ( optional ) : % s" , <NEW_LINE> fsname , target , strerror ( errno ) ) ;
( unsigned long ) strip , ( unsigned long ) rows ) ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> bufp += bytes_read ; <NEW_LINE> <END_VULN> } <NEW_LINE> return 1 ;
cJSON_AddItemToArray ( j_streams , j_stream ) ; <NEW_LINE> bytes_transferred = test -> sender ? sp -> result -> bytes_sent : sp -> result -> bytes_received ; <NEW_LINE> retransmits = ( test -> sender && test -> sender_has_retransmits ) ? sp -> result -> stream_retrans : - 1 ; <NEW_LINE> <START_VULN> cJSON_AddIntToObject ( j_stream , "id" , sp -> id ) ; <NEW_LINE>cJSON_AddIntToObject ( j_stream , "bytes" , bytes_transferred ) ; <NEW_LINE>cJSON_AddIntToObject ( j_stream , "retransmits" , retransmits ) ; <NEW_LINE>cJSON_AddFloatToObject ( j_stream , "jitter" , sp -> jitter ) ; <NEW_LINE>cJSON_AddIntToObject ( j_stream , "errors" , sp -> cnt_error ) ; <NEW_LINE>cJSON_AddIntToObject ( j_stream , "packets" , sp -> packet_count ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> if ( r == 0 && test -> debug ) {
if ( tga -> bits == TGA_BPP_24 ) { <NEW_LINE> * tpix = gdTrueColor ( tga -> bitmap [ bitmap_caret + 2 ] , tga -> bitmap [ bitmap_caret + 1 ] , tga -> bitmap [ bitmap_caret ] ) ; <NEW_LINE> bitmap_caret += 3 ; <NEW_LINE> <START_VULN> } else if ( tga -> bits == TGA_BPP_32 || tga -> alphabits ) { <NEW_LINE> <END_VULN> register int a = tga -> bitmap [ bitmap_caret + 3 ] ; <NEW_LINE> * tpix = gdTrueColorAlpha ( tga -> bitmap [ bitmap_caret + 2 ] , tga -> bitmap [ bitmap_caret + 1 ] , tga -> bitmap [ bitmap_caret ] , gdAlphaMax - ( a >> 1 ) ) ;
ref_costs_single [ ALTREF_FRAME ] = 512 ; <NEW_LINE> } <NEW_LINE> if ( cm -> reference_mode != SINGLE_REFERENCE ) { <NEW_LINE> <START_VULN> vp9_prob ref_comp_p = vp9_get_pred_prob_comp_ref_p ( cm , xd ) ; <NEW_LINE> <END_VULN> unsigned int base_cost = vp9_cost_bit ( intra_inter_p , 1 ) ; <NEW_LINE> if ( cm -> reference_mode == REFERENCE_MODE_SELECT )
AtomSet::AddPtr p = atoms . lookupForAdd ( AtomHasher::Lookup ( tbchars , length ) ) ; <NEW_LINE> SkipRoot skipHash ( cx , & p ) ; <NEW_LINE> if ( p ) { <NEW_LINE> JSAtom * atom = p -> asPtr ( ) ; <NEW_LINE> p -> setTagged ( bool ( ib ) ) ; <NEW_LINE> return atom ; <NEW_LINE> } <NEW_LINE> <START_VULN> AutoEnterAtomsCompartment ac ( cx ) ; <NEW_LINE> <END_VULN> JSFlatString * flat = js_NewStringCopyN < allowGC > ( cx , tbchars , length ) ; <NEW_LINE> if ( ! flat ) <NEW_LINE> return NULL ; <NEW_LINE> JSAtom * atom = flat -> morphAtomizedStringIntoAtom ( ) ; <NEW_LINE> if ( ! atoms . relookupOrAdd ( p , AtomHasher::Lookup ( tbchars , length ) ,
return rc ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int fsmVerify ( const char * path , rpmfi fi ) <NEW_LINE> <END_VULN> { <NEW_LINE> int rc ; <NEW_LINE> int saveerrno = errno ;
unsigned int payload ; <NEW_LINE> unsigned int padding = 16 ; <NEW_LINE> <START_VULN> <NEW_LINE>hbtype = * p ++ ; <NEW_LINE>n2s ( p , payload ) ; <NEW_LINE>pl = p ; <NEW_LINE><NEW_LINE> <END_VULN> if ( s -> msg_callback ) <NEW_LINE> s -> msg_callback ( 0 , s -> version , TLS1_RT_HEARTBEAT , <NEW_LINE> & s -> s3 -> rrec . data [ 0 ] , s -> s3 -> rrec . length , <NEW_LINE> s , s -> msg_callback_arg ) ; <NEW_LINE> if ( hbtype == TLS1_HB_REQUEST ) <NEW_LINE> {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: libvorbis backend and mapping structures ; needed for <NEW_LINE> static mode headers <NEW_LINE> <START_VULN> last mod: $ Id: backends . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _vorbis_backend_h_
} <NEW_LINE> } <NEW_LINE> if ( ! buf . append ( ' } ' ) ) <NEW_LINE> return false ; <NEW_LINE> if ( outermost && ! buf . append ( ' ) ' ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> JSString * str = buf . finishString ( ) ; <NEW_LINE> <END_VULN> if ( ! str ) <NEW_LINE> return false ; <NEW_LINE> args . rval ( ) . setString ( str ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> namespace js {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: single - block PCM analysis mode dispatch <NEW_LINE> <START_VULN> last mod: $ Id: analysis . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdio . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
RETURN_FALSE ; <NEW_LINE> <START_VULN> result = append_key_value ( loc_name , hash_arr , LOC_GRANDFATHERED_LANG_TAG ) ; <NEW_LINE> <END_VULN> if ( result == SUCCESS ) { <NEW_LINE> RETURN_SMART_STR ( loc_name ) ; <NEW_LINE> }
} <NEW_LINE> p += p [ 2 ] ; <NEW_LINE> } <NEW_LINE> <START_VULN> return ( ARCHIVE_OK ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int
conn -> current_result = NULL ; <NEW_LINE> } while ( 0 ) ; <NEW_LINE> <START_VULN> conn -> m -> local_tx_end ( conn , this_func , result == NULL ? FAIL:PASS TSRMLS_CC ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> DBG_RETURN ( result ) ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> } <NEW_LINE> nsIFrame * lastFrame = aBpd -> FrameAt ( aLastIndex ) ; <NEW_LINE> <START_VULN> nsIFrame * next = lastFrame -> GetNextInFlow ( ) ; <NEW_LINE>if ( next && IsBidiSplittable ( lastFrame ) ) { <NEW_LINE>lastFrame -> SetNextContinuation ( next ) ; <NEW_LINE>next -> SetPrevContinuation ( lastFrame ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> nsresult <NEW_LINE> nsBidiPresUtils::FormatUnicodeText ( nsPresContext * aPresContext , <NEW_LINE> char16_t * aText , <NEW_LINE> int32_t & aTextLength , <NEW_LINE> nsCharType aCharType , <NEW_LINE> bool aIsOddLevel )
<START_VULN> void perf_event_enable ( struct perf_event * event ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct perf_event_context * ctx = event -> ctx ; <NEW_LINE> struct task_struct * task = ctx -> task ;
break ; <NEW_LINE> case EFFECT_CMD_GET_CONFIG: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || <NEW_LINE> * replySize != sizeof ( effect_config_t ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Reverb_command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_GET_CONFIG: ERROR" ) ; <NEW_LINE> return - EINVAL ;
} <NEW_LINE> NS_IMPL_ISUPPORTS1 ( nsXMLHttpRequest::nsHeaderVisitor , nsIHttpHeaderVisitor ) <NEW_LINE> NS_IMETHODIMP nsXMLHttpRequest:: <NEW_LINE> nsHeaderVisitor::VisitHeader ( const nsACString & header , const nsACString & value ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! nsContentUtils::IsCallerChrome ( ) && <NEW_LINE> <END_VULN> ( header . LowerCaseEqualsASCII ( "set - cookie" ) || <NEW_LINE> header . LowerCaseEqualsASCII ( "set - cookie2" ) ) ) { <NEW_LINE> NS_WARNING ( "blocked access to response header" ) ; <NEW_LINE> } else { <NEW_LINE> mHeaders . Append ( header ) ; <NEW_LINE> mHeaders . Append ( ": " ) ; <NEW_LINE> mHeaders . Append ( value ) ; <NEW_LINE> mHeaders . Append ( "\r\n" ) ;
ScriptPromise::Reject ( <NEW_LINE> script_state , V8ThrowException::CreateTypeError ( <NEW_LINE> script_state -> GetIsolate ( ) , <NEW_LINE> <START_VULN> "An argument must be provided , which must be a" <NEW_LINE> <END_VULN> "Response or Promise < Response > object" ) ) <NEW_LINE> . V8Value ( ) ) ; <NEW_LINE> return ;
if ( op == JSOP_FUNCALL || op == JSOP_FUNAPPLY ) <NEW_LINE> cx -> compartment -> types . monitorBytecode ( cx , script , pc - script_ -> code ) ; <NEW_LINE> <START_VULN> poppedTypes ( pc , argCount + 1 ) -> addCall ( cx , callsite ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> } <NEW_LINE> case JSOP_NEWINIT: <NEW_LINE> case JSOP_NEWARRAY: <NEW_LINE> case JSOP_NEWOBJECT: { <NEW_LINE> StackTypeSet * types = script_ -> analysis ( ) -> bytecodeTypes ( pc ) ; <NEW_LINE> types -> addSubset ( cx , & pushed [ 0 ] ) ;
#define DTK_DATE_M ( DTK_M ( YEAR ) | DTK_M ( MONTH ) | DTK_M ( DAY ) ) <NEW_LINE> #define DTK_TIME_M ( DTK_M ( HOUR ) | DTK_M ( MINUTE ) | DTK_M ( SECOND ) ) <NEW_LINE> <START_VULN> #define MAXDATELEN 63 <NEW_LINE>#define MAXDATEFIELDS 25 <NEW_LINE>#define TOKMAXLEN 10 <NEW_LINE> <END_VULN> typedef struct
int16_t shouldLoad = nsIContentPolicy::ACCEPT ; <NEW_LINE> nsCOMPtr < nsIContentPolicy > cp = do_GetService ( NS_CONTENTPOLICY_CONTRACTID ) ; <NEW_LINE> if ( ! cp ) { <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> rv = cp -> ShouldLoad ( nsIContentPolicy::TYPE_CSP_REPORT , <NEW_LINE> reportURI , <NEW_LINE> <START_VULN> aOriginalURI , <NEW_LINE> <END_VULN> nullptr , <NEW_LINE> EmptyCString ( ) , <NEW_LINE> nullptr , <NEW_LINE> nullptr , <NEW_LINE> & shouldLoad ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
if ( ! coreFrame ) <NEW_LINE> return NULL ; <NEW_LINE> <START_VULN> return toGlobalRef ( coreFrame -> script ( ) -> globalObject ( ) -> globalExec ( ) ) ; <NEW_LINE> <END_VULN> }
png_fixed_error ( png_ptr , text ) ; <NEW_LINE> # ifndef PNG_ERROR_TEXT_SUPPORTED <NEW_LINE> <START_VULN> PNG_UNUSED ( text ) <NEW_LINE> <END_VULN> # endif <NEW_LINE> return ( png_fixed_point ) r ;
#include "hsm_config_client_api . h" <NEW_LINE> <START_VULN> #define HSM_FM_SCK_PREFIX " / tmp / " <END_VULN> <NEW_LINE> <NEW_LINE> #define HSM_FM_SCK_SM "sm_" <NEW_LINE> #define HSM_FM_SCK_PM "pm_" <NEW_LINE> #define HSM_FM_SCK_FE "fe_"
initializeHolderIfNeeded ( scriptState , classObject , holder ) ; <NEW_LINE> v8::TryCatch block ( isolate ) ; <NEW_LINE> v8::Local < v8::Value > result ; <NEW_LINE> <START_VULN> if ( ! V8ScriptRunner::callFunction ( v8::Local < v8::Function > ::Cast ( getter ) , scriptState -> getExecutionContext ( ) , holder , 0 , 0 , isolate ) . ToLocal ( & result ) ) { <NEW_LINE> <END_VULN> rethrowExceptionInPrivateScript ( isolate , block , scriptStateInUserScript , ExceptionState::GetterContext , attributeName , className ) ; <NEW_LINE> block . ReThrow ( ) ; <NEW_LINE> return v8::Local < v8::Value > ( ) ;
if ( j == - 1 ) <NEW_LINE> { <NEW_LINE> <START_VULN> return ERROR_INV_SPS_PPS_T ; <NEW_LINE> <END_VULN> }
} <NEW_LINE> trust_data . cbStruct = sizeof ( trust_data ) ; <NEW_LINE> <START_VULN> trust_data . dwUIChoice = WTD_UI_ALL ; <NEW_LINE> <END_VULN> trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ;
return LayoutSVGContainer::isChildAllowed ( child , style ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> bool LayoutSVGTransformableContainer::calculateLocalTransform ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> SVGGraphicsElement * element = toSVGGraphicsElement ( this -> element ( ) ) ; <NEW_LINE> ASSERT ( element ) ;
} <NEW_LINE> const Property * hashTableEntry = findProperty ( name , length ) ; <NEW_LINE> <START_VULN> return hashTableEntry ? static_cast < CSSPropertyID > ( hashTableEntry -> id ) : CSSPropertyInvalid ; <NEW_LINE> <END_VULN> } <NEW_LINE> CSSPropertyID cssPropertyID ( const String & string )
internalformatForGL = LOCAL_GL_DEPTH24_STENCIL8 ; <NEW_LINE> break ; <NEW_LINE> default: <NEW_LINE> return ErrorInvalidEnumInfo ( "renderbufferStorage: internalformat" , internalformat ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> gl -> fRenderbufferStorage ( target , internalformatForGL , width , height ) ; <NEW_LINE> <END_VULN> mBoundRenderbuffer -> SetInternalFormat ( internalformat ) ; <NEW_LINE> mBoundRenderbuffer -> setDimensions ( width , height ) ; <NEW_LINE> mBoundRenderbuffer -> SetInitialized ( PR_FALSE ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
friend class CanvasRenderingContext2DUserData ; <NEW_LINE> protected: <NEW_LINE> nsresult GetImageDataArray ( JSContext * aCx , int32_t aX , int32_t aY , <NEW_LINE> uint32_t aWidth , uint32_t aHeight , <NEW_LINE> JSObject ** aRetval ) ; <NEW_LINE> nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <NEW_LINE> <START_VULN> unsigned char * aData , uint32_t aDataLen , <NEW_LINE> <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , <NEW_LINE> int32_t dirtyWidth , int32_t dirtyHeight ) ; <NEW_LINE> nsresult Initialize ( int32_t width , int32_t height ) ;
return throwVMError ( exec , createReferenceError ( exec , "DeprecatedPeerConnection constructor associated document is unavailable" ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 2 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> String serverConfiguration = ustringToString ( exec -> argument ( 0 ) . toString ( exec ) -> value ( exec ) ) ; <NEW_LINE> if ( exec -> hadException ( ) )
return PR_TRUE ; <NEW_LINE> } <NEW_LINE> rv = sSecurityManager -> CheckSameOriginPrincipal ( subjectPrincipal , <NEW_LINE> principal ) ; <NEW_LINE> if ( NS_SUCCEEDED ( rv ) ) { <NEW_LINE> <START_VULN> - <NEW_LINE> <END_VULN> 1 . 4 . 1
fseek ( ifp , save , SEEK_SET ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #line 5610 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> void CLASS parse_makernote ( int base , int uptag ) <NEW_LINE> { <NEW_LINE> static const uchar xlat [ 2 ] [ 256 ] = {
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> sample = findSample ( sampleID ) ; <NEW_LINE> <END_VULN> if ( ( sample == 0 ) || ( sample -> state ( ) != Sample::READY ) ) { <NEW_LINE> ALOGW ( " sample % d not READY" , sampleID ) ; <NEW_LINE> return 0 ;
friend class base::RefCountedThreadSafe < SSLErrorHandler > ; <NEW_LINE> <START_VULN> SSLErrorHandler ( base::WeakPtr < Delegate > delegate , <NEW_LINE> <END_VULN> const content::GlobalRequestID & id , <NEW_LINE> ResourceType::Type resource_type , <NEW_LINE> const GURL & url ,
{ <NEW_LINE> offset = SeekBlob ( image , currentOffset + 20 , SEEK_SET ) ; <NEW_LINE> ( void ) WriteBlobByte ( image , 0 ) ; <NEW_LINE> <START_VULN> ( void ) WriteBlobByte ( image , ( unsigned char ) ( ( 31 * transpix . red ) / QuantumRange ) ) ; <NEW_LINE> ( void ) WriteBlobByte ( image , ( unsigned char ) ( ( 63 * transpix . green ) / QuantumRange ) ) ; <NEW_LINE> ( void ) WriteBlobByte ( image , ( unsigned char ) ( ( 31 * transpix . blue ) / QuantumRange ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( flags & PALM_IS_COMPRESSED_FLAG ) <NEW_LINE> {
for ( conn_opt = conn_opts ; conn_opt -> keyword != NULL ; conn_opt ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' ) <NEW_LINE> <END_VULN> { <NEW_LINE> keywords [ i ] = conn_opt -> keyword ; <NEW_LINE> values [ i ] = conn_opt -> val ;
{ <NEW_LINE> png_fixed_point gamma ; <NEW_LINE> <START_VULN> if ( png_get_gAMA_fixed ( read_ptr , read_info_ptr , & gamma ) ) <NEW_LINE> <END_VULN> png_set_gAMA_fixed ( write_ptr , write_info_ptr , gamma ) ; <NEW_LINE> } <NEW_LINE> #endif
{ % endif % } <NEW_LINE> { % if attribute . put_forwards % } <NEW_LINE> { { cpp_class } } * proxyImp = { { v8_class } } ::toNative ( info . Holder ( ) ) ; <NEW_LINE> <START_VULN> { { attribute . idl_type } } * imp = WTF::getPtr ( proxyImp -> { { attribute . name } } ( ) ) ; <NEW_LINE> <END_VULN> if ( ! imp ) <NEW_LINE> return ; <NEW_LINE> { % elif not attribute . is_static % }
} <NEW_LINE> static INLINE void add_token_no_extra ( TOKENEXTRA ** t , <NEW_LINE> <START_VULN> const vp9_prob * context_tree , <NEW_LINE> <END_VULN> uint8_t token , <NEW_LINE> uint8_t skip_eob_node , <NEW_LINE> unsigned int * counts ) {
for ( pass = 0 ; ( ( pass < nb_guids ) && ( r == LIBUSB_SUCCESS ) ) ; pass ++ ) { <NEW_LINE> #ifdef ENUM_DEBUG <NEW_LINE> <START_VULN> const char * passname [ ] = { "HCD" , "HUB" , "GEN" , "DEV" , "HID" , "EXT" } ; <NEW_LINE>usbi_dbg ( "\n#### PROCESSING % ss % s" , passname [ ( pass <= HID_PASS ) ? pass:HID_PASS + 1 ] , <NEW_LINE> <END_VULN> ( pass != GEN_PASS ) ? guid_to_string ( guid [ pass ] ) :"" ) ; <NEW_LINE> #endif <NEW_LINE> for ( i = 0 ; ; i ++ ) {
PRInt32 i , count = mElements . Count ( ) ; <NEW_LINE> for ( i = 0 ; i < count ; i ++ ) { <NEW_LINE> <START_VULN> nsIContent * content = NS_STATIC_CAST ( nsIContent * , <NEW_LINE>mElements . ElementAt ( i ) ) ; <NEW_LINE> <END_VULN> if ( content ) { <NEW_LINE> nsAutoString name ;
} <NEW_LINE> static inline int mount_entry_on_generic ( struct mntent * mntent , <NEW_LINE> <START_VULN> const char * path ) <NEW_LINE> <END_VULN> { <NEW_LINE> unsigned long mntflags ; <NEW_LINE> char * mntdata ;
hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { <NEW_LINE> if ( perf_tp_event_match ( event , & data , regs ) ) <NEW_LINE> <START_VULN> perf_swevent_event ( event , count , 1 , & data , regs ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> perf_swevent_put_recursion_context ( rctx ) ;
void <NEW_LINE> nsListControlFrame::FireMenuItemActiveEvent ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsCOMPtr < nsIDOMEvent > event ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif <NEW_LINE> unchanged:
void * arg ) { <NEW_LINE> int plane ; <NEW_LINE> <START_VULN> for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ ) <NEW_LINE> <END_VULN> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ; <NEW_LINE> }
out_string ( c , "OK" ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> } else if ( strcmp ( tokens [ 1 ] . value , "mode" ) == 0 && ntokens >= 3 && <NEW_LINE> <END_VULN> settings . lru_maintainer_thread ) { <NEW_LINE> if ( strcmp ( tokens [ 2 ] . value , "flat" ) == 0 ) { <NEW_LINE> settings . lru_segmented = false ;
return FISH_SOUND_ERR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE> } else if ( fsv -> packetno == 2 ) { <NEW_LINE> <START_VULN> vorbis_synthesis_init ( & fsv -> vd , & fsv -> vi ) ; <NEW_LINE>vorbis_block_init ( & fsv -> vd , & fsv -> vb ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } else { <NEW_LINE> FishSoundDecoded_FloatIlv df ;
MarFile * CVE_2013_1726_mar_wopen ( const wchar_t * path ) { <NEW_LINE> FILE * fp ; <NEW_LINE> <START_VULN> fp = _wfopen ( path , L"rb" ) ; <NEW_LINE> <END_VULN> if ( ! fp ) <NEW_LINE> return NULL ;
NPEvent npEvent ; <NEW_LINE> NPMouseEvent mouse ; <NEW_LINE> <START_VULN> switch ( point . m_state ) { <NEW_LINE> <END_VULN> case Platform::TouchPoint::TouchPressed: <NEW_LINE> mouse . type = MOUSE_BUTTON_DOWN ; <NEW_LINE> break ;
return bufferNode . forget ( ) ; <NEW_LINE> } <NEW_LINE> already_AddRefed < AudioBuffer > <NEW_LINE> AudioContext::CreateBuffer ( JSContext * aJSContext , uint32_t aNumberOfChannels , <NEW_LINE> uint32_t aLength , float aSampleRate , <NEW_LINE> ErrorResult & aRv ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( aSampleRate < 8000 || aSampleRate > 192000 || ! aLength || ! aNumberOfChannels ) { <NEW_LINE> <END_VULN> aRv . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> if ( aLength > INT32_MAX ) { <NEW_LINE> aRv . Throw ( NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> return nullptr ; <NEW_LINE> }
int vorbis_synthesis_lapout ( vorbis_dsp_state * v , float ** * pcm ) { <NEW_LINE> vorbis_info * vi = v -> vi ; <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> <START_VULN> int hs = ci -> halfrate_flag ; <NEW_LINE><NEW_LINE> <END_VULN> int n = ci -> blocksizes [ v -> W ] >> ( hs + 1 ) ; <NEW_LINE> int n0 = ci -> blocksizes [ 0 ] >> ( hs + 1 ) ; <NEW_LINE> int n1 = ci -> blocksizes [ 1 ] >> ( hs + 1 ) ; <NEW_LINE> int i , j ; <NEW_LINE> if ( v -> pcm_returned < 0 ) return 0 ; <NEW_LINE> if ( ( v -> lW ^ v -> W ) == 1 ) { <NEW_LINE> for ( j = 0 ; j < vi -> channels ; j ++ ) { <NEW_LINE> float * s = v -> pcm [ j ] ; <NEW_LINE> float * d = v -> pcm [ j ] + ( n1 - n0 ) / 2 ; <NEW_LINE> for ( i = ( n1 + n0 ) / 2 - 1 ; i >= 0 ; -- i ) <NEW_LINE>
& lib_dir , & lib_dir_len ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> array_init ( return_value ) ; <NEW_LINE> modules = mcrypt_list_algorithms ( lib_dir , & count ) ;
ExpireChunksAndArenas ( rt , gckind == GC_SHRINK ) ; <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> { <NEW_LINE> gcstats::AutoPhase ap ( rt -> gcStats , gcstats::PHASE_FINALIZE_END ) ; <NEW_LINE> if ( rt -> gcFinalizeCallback ) <NEW_LINE> <START_VULN> rt -> gcFinalizeCallback ( & fop , JSFINALIZE_END ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> for ( CompartmentsIter c ( rt ) ; ! c . done ( ) ; c . next ( ) ) <NEW_LINE> c -> setGCLastBytes ( c -> gcBytes , c -> gcMallocAndFreeBytes , gckind ) ; <NEW_LINE> } <NEW_LINE> static void <NEW_LINE> NonIncrementalMark ( JSRuntime * rt , JSGCInvocationKind gckind )
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . enabledAtRuntimeMethod1" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( int , intArg , V8int::HasInstance ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ? V8int::toNative ( v8::Handle < v8::Object > ::Cast ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) : 0 ) ; <NEW_LINE> imp -> enabledAtRuntimeMethod1 ( intArg ) ;
Cluster * & cluster = cluster_list_ [ cluster_list_size_ ] ; <NEW_LINE> const int64 offset = MaxOffset ( ) ; <NEW_LINE> <START_VULN> cluster = new ( std::nothrow ) Cluster ( cluster_timecode , offset ) ; <NEW_LINE> <END_VULN> if ( ! cluster ) <NEW_LINE> return false ;
#define VP9_ENCODER_VP9_MCOMP_H_ <NEW_LINE> #include "vp9 / encoder / vp9_block . h" <NEW_LINE> <START_VULN> #include "vp9 / encoder / vp9_variance . h" <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> extern "C" {
if ( q [ 8 ] & 0x80 ) <NEW_LINE> { <NEW_LINE> mGIFStruct . local_colormap_size = 1 << depth ; <NEW_LINE> if ( ! mGIFStruct . images_decoded ) { <NEW_LINE> <START_VULN> mColormapSize = sizeof ( PRUint32 ) << realDepth ; <NEW_LINE> <END_VULN> if ( ! mGIFStruct . local_colormap ) { <NEW_LINE> mGIFStruct . local_colormap = ( PRUint32 * ) PR_MALLOC ( mColormapSize ) ; <NEW_LINE> if ( ! mGIFStruct . local_colormap ) { <NEW_LINE> mGIFStruct . state = gif_oom ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> mColormap = mGIFStruct . local_colormap ;
socklen = NGX_SOCKADDRLEN ; <NEW_LINE> #if ( NGX_HAVE_ACCEPT4 ) <NEW_LINE> <START_VULN> s = accept4 ( lc -> fd , ( struct sockaddr * ) sa , & socklen , SOCK_NONBLOCK ) ; <NEW_LINE> <END_VULN> #else <NEW_LINE> s = accept ( lc -> fd , ( struct sockaddr * ) sa , & socklen ) ; <NEW_LINE> #endif
uintptr_t newDataPointer = uintptr_t ( newHeader -> elements ( ) ) ; <NEW_LINE> for ( ArrayBufferViewObject * view = viewListHead ; view ; view = view -> nextView ( ) ) { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> uint8_t * viewDataPointer = static_cast < uint8_t * > ( view -> getPrivate ( ) ) ; <NEW_LINE> if ( viewDataPointer ) { <NEW_LINE> viewDataPointer += newDataPointer - oldDataPointer ;
) <NEW_LINE> { <NEW_LINE> <START_VULN> DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , FData2 , 24 * 24 ) ; <NEW_LINE> <END_VULN> const short * HFilter , * VFilter ;
return ; \ <NEW_LINE> } \ <NEW_LINE> \ <NEW_LINE> <START_VULN> phar_file_stat ( filename , ( php_stat_len ) filename_len , funcnum , PHAR_G ( orig ) , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; \ <NEW_LINE> <END_VULN> } \ <NEW_LINE> }
vA = ( int ) buf [ 1 ] ; <NEW_LINE> vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <NEW_LINE> vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <NEW_LINE> <START_VULN> sprintf ( str , " { v % i . . v % i } , [ % 04x ] " , vC , vC + vA - 1 , vB ) ; <NEW_LINE> <END_VULN> strasm = r_str_concat ( strasm , str ) ; <NEW_LINE> break ; <NEW_LINE> case fmtoptinvokeVS:
! mTextRun -> IsClusterStart ( clusterEnd ) ) { <NEW_LINE> ++ clusterEnd ; <NEW_LINE> } <NEW_LINE> mOffsetFromBlockOriginForTabs += <NEW_LINE> mTextRun -> GetAdvanceWidth ( i , clusterEnd - i , nullptr ) ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> if ( ! mTabWidths ) { <NEW_LINE> <START_VULN> mTabWidths = new TabWidthStore ( ) ; <NEW_LINE> <END_VULN> mFrame -> Properties ( ) . Set ( TabWidthProperty ( ) , mTabWidths ) ; <NEW_LINE> } <NEW_LINE> double nextTab = AdvanceToNextTab ( mOffsetFromBlockOriginForTabs , <NEW_LINE> mFrame , mTextRun , & tabWidth ) ; <NEW_LINE> mTabWidths -> mWidths . AppendElement ( TabWidth ( i - startOffset , <NEW_LINE> NSToIntRound ( nextTab - mOffsetFromBlockOriginForTabs ) ) ) ; <NEW_LINE> mOffsetFromBlockOriginForTabs = nextTab ; <NEW_LINE> }
<START_VULN> else if ( ! png_sRGB_checks [ i ] . have_md5 ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_chunk_report ( png_ptr , <NEW_LINE> "out - of - date sRGB profile with no signature" ,
FLOAT32 * syn_buf = & buffer [ kmax ] ; <NEW_LINE> kmax += synth_size ; <NEW_LINE> <START_VULN> if ( ixheaacd_real_synth_fft != NULL ) <NEW_LINE> ( * ixheaacd_real_synth_fft ) ( synth_buf_r , synth_out , synth_size * 2 ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> return - 1 ;
<START_VULN> if ( isPositioned ( ) ) <NEW_LINE> <END_VULN> availableHeight = containingBlockLogicalHeightForPositioned ( containingBlock ( ) ) ; <NEW_LINE> else <NEW_LINE> availableHeight = containingBlock ( ) -> availableLogicalHeight ( ) ;
top = CG_OFFSET ( cg ) ; <NEW_LINE> #if ! JS_HAS_BLOCK_SCOPE <NEW_LINE> js_PushStatement ( cg , stmtInfo , STMT_SWITCH , top ) ; <NEW_LINE> #else <NEW_LINE> if ( pn2 -> pn_type == TOK_LC ) { <NEW_LINE> js_PushStatement ( cg , stmtInfo , STMT_SWITCH , top ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> cg -> topStmt = cg -> topScopeStmt = stmtInfo ; <NEW_LINE>cg -> blockChainBox = stmtInfo -> blockBox ; <NEW_LINE><NEW_LINE><NEW_LINE>stmtInfo -> update = top ; <NEW_LINE> <END_VULN> pn2 = pn2 -> expr ( ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> caseCount = pn2 -> pn_count ; <NEW_LINE> tableLength = 0 ;
{ <NEW_LINE> int n ; <NEW_LINE> int i ; <NEW_LINE> <START_VULN> uchar buf [ 2 ] ; <NEW_LINE> <END_VULN> assert ( JAS_STREAM_MAXPUTBACK >= 2 ) ;
if ( ! ( current -> personality & ADDR_NO_RANDOMIZE ) && randomize_va_space ) <NEW_LINE> current -> flags |= PF_RANDOMIZE ; <NEW_LINE> <START_VULN> arch_pick_mmap_layout ( current -> mm ) ; <NEW_LINE> <END_VULN> current -> mm -> free_area_cache = current -> mm -> mmap_base ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> if ( len + 15 > dev -> mtu ) { <NEW_LINE>mutex_unlock ( & econet_mutex ) ; <NEW_LINE>return - EMSGSIZE ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> if ( dev -> type == ARPHRD_ECONET ) { <NEW_LINE> #ifdef CONFIG_ECONET_NATIVE <NEW_LINE> unsigned short proto = 0 ; <NEW_LINE> int res ; <NEW_LINE> dev_hold ( dev ) ;
ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( u2_first_mb_in_slice == 0 ) <NEW_LINE> {
dst = dst_ybc -> u_buffer ; <NEW_LINE> for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { <NEW_LINE> <START_VULN> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <NEW_LINE> <END_VULN> src += src_ybc -> uv_stride ; <NEW_LINE> dst += dst_ybc -> uv_stride ; <NEW_LINE> }
APPL_TRACE_ERROR ( " % s: Device not found" , __FUNCTION__ ) <NEW_LINE> return - 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> ret = read ( p_dev -> fd , & ev , sizeof ( ev ) ) ; <NEW_LINE> <END_VULN> if ( ret == 0 ) { <NEW_LINE> APPL_TRACE_ERROR ( " % s: Read HUP on uhid - cdev % s" , __FUNCTION__ , <NEW_LINE> strerror ( errno ) ) ;
<START_VULN> if ( ! ( renderer -> isPositioned ( ) && renderer -> style ( ) -> position ( ) == FixedPosition && layer -> isStackingContext ( ) ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> if ( Settings * settings = m_renderView -> document ( ) -> settings ( ) )
NS_DECLARE_STATIC_IID_ACCESSOR ( XPCVARIANT_IID ) <NEW_LINE> static XPCVariant * newVariant ( XPCCallContext & ccx , jsval aJSVal ) ; <NEW_LINE> jsval GetJSVal ( ) const { return mJSVal ; } <NEW_LINE> <START_VULN> XPCVariant ( jsval aJSVal ) ; <NEW_LINE> <END_VULN>
JSContext * cx = ( JSContext * ) context -> GetNativeContext ( ) ; <NEW_LINE> nsCOMPtr < nsIDocument > ourDocument ; <NEW_LINE> mPrototypeBinding -> XBLDocumentInfo ( ) -> GetDocument ( getter_AddRefs ( ourDocument ) ) ; <NEW_LINE> PRBool canExecute ; <NEW_LINE> nsresult rv = <NEW_LINE> mgr -> CanExecuteScripts ( cx , ourDocument -> NodePrincipal ( ) , & canExecute ) ; <NEW_LINE> <START_VULN> return NS_SUCCEEDED ( rv ) && canExecute ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsXBLBinding::RemoveInsertionParent ( nsIContent * aParent ) <NEW_LINE> { <NEW_LINE> if ( mNextBinding ) { <NEW_LINE> mNextBinding -> RemoveInsertionParent ( aParent ) ; <NEW_LINE> }
value = va_arg ( args , int ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> <START_VULN> fmtint ( sbuffer , buffer , & currlen , maxlen , <NEW_LINE>value , 10 , min , max , flags ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 'X': <NEW_LINE> flags |= DP_F_UP ;
friend struct nsCanvasBidiProcessor ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> NS_IMPL_ADDREF ( nsCanvasRenderingContext2D ) <NEW_LINE>NS_IMPL_RELEASE ( nsCanvasRenderingContext2D ) <NEW_LINE><NEW_LINE>NS_INTERFACE_MAP_BEGIN ( nsCanvasRenderingContext2D ) <NEW_LINE> <END_VULN> NS_INTERFACE_MAP_ENTRY ( nsIDOMCanvasRenderingContext2D ) <NEW_LINE> NS_INTERFACE_MAP_ENTRY ( nsICanvasRenderingContextInternal ) <NEW_LINE> NS_INTERFACE_MAP_ENTRY_AMBIGUOUS ( nsISupports , nsIDOMCanvasRenderingContext2D )
Zone ** write = read ; <NEW_LINE> JS_ASSERT ( rt -> zones . length ( ) >= 1 ) ; <NEW_LINE> JS_ASSERT ( rt -> isAtomsZone ( rt -> zones [ 0 ] ) ) ; <NEW_LINE> while ( read < end ) { <NEW_LINE> Zone * zone = * read ++ ; <NEW_LINE> if ( zone -> wasGCStarted ( ) ) { <NEW_LINE> <START_VULN> if ( zone -> allocator . arenas . arenaListsAreEmpty ( ) || lastGC ) { <NEW_LINE> <END_VULN> zone -> allocator . arenas . checkEmptyFreeLists ( ) ; <NEW_LINE> if ( callback ) <NEW_LINE> callback ( zone ) ; <NEW_LINE> SweepCompartments ( fop , zone , false , lastGC ) ; <NEW_LINE> JS_ASSERT ( zone -> compartments . empty ( ) ) ; <NEW_LINE> fop -> delete_ ( zone ) ; <NEW_LINE> continue ; <NEW_LINE> }
client -> DrawingBufferClientRestoreScissorTest ( ) ; <NEW_LINE> client -> DrawingBufferClientRestoreMaskAndClearValues ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( pixel_pack_alignment_dirty_ ) <NEW_LINE>client -> DrawingBufferClientRestorePixelPackAlignment ( ) ; <NEW_LINE> <END_VULN> if ( texture_binding_dirty_ ) <NEW_LINE> client -> DrawingBufferClientRestoreTexture2DBinding ( ) ; <NEW_LINE> if ( renderbuffer_binding_dirty_ )
if ( ! fp ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> fprintf ( certificate_store -> fp , " % s % s\n" , certificate_data -> hostname , certificate_data -> fingerprint ) ; <NEW_LINE> <END_VULN> fclose ( fp ) ; <NEW_LINE> }
virtual void SetPickledData ( const OSExchangeData::CustomFormat & format , <NEW_LINE> const Pickle & pickle ) OVERRIDE ; <NEW_LINE> virtual bool GetString ( base::string16 * data ) const OVERRIDE ; <NEW_LINE> <START_VULN> virtual bool GetURLAndTitle ( GURL * url , base::string16 * title ) const OVERRIDE ; <NEW_LINE> <END_VULN> virtual bool GetFilename ( base::FilePath * path ) const OVERRIDE ; <NEW_LINE> virtual bool GetFilenames ( <NEW_LINE> std::vector < OSExchangeData::FileInfo > * filenames ) const OVERRIDE ;
const char * objname ) { } <NEW_LINE> NS_IMETHOD_ ( void ) DescribeGCedNode ( bool ismarked , <NEW_LINE> const char * objname ) { } <NEW_LINE> NS_IMETHOD_ ( void ) NoteXPCOMRoot ( nsISupports * root ) { } <NEW_LINE> NS_IMETHOD_ ( void ) NoteJSRoot ( void * root ) { } <NEW_LINE> NS_IMETHOD_ ( void ) NoteNativeRoot ( void * root , <NEW_LINE> nsCycleCollectionParticipant * helper ) { } <NEW_LINE> NS_IMETHOD_ ( void ) NoteNextEdgeName ( const char * name ) { } <NEW_LINE> <START_VULN> NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * val ) { } <NEW_LINE> <END_VULN> bool MayHaveChild ( ) { <NEW_LINE> return mMayHaveChild ; <NEW_LINE> } <NEW_LINE> private: <NEW_LINE> bool mMayHaveChild ; <NEW_LINE> } ; <NEW_LINE> NS_IMETHODIMP_ ( void )
nsFrameMessageManager::Dump ( const nsAString & aStr ) <NEW_LINE> { <NEW_LINE> #ifdef ANDROID <NEW_LINE> <START_VULN> __android_log_print ( ANDROID_LOG_INFO , "Gecko" , NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> fputs ( NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) , stdout ) ; <NEW_LINE> fflush ( stdout ) ;
( aNamespaceID == kNameSpaceID_XSLT && <NEW_LINE> attr . mNamespaceID == kNameSpaceID_None ) ) ) { <NEW_LINE> return NS_ERROR_XSLT_PARSE_FAILURE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> rv = pushPtr ( const_cast < txElementHandler * > ( handler ) ) ; <NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> mElementContext -> mDepth ++ ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult
First: no IPv4 options . <NEW_LINE> <START_VULN> newinet -> opt = NULL ; <NEW_LINE> <END_VULN> newnp -> rxopt . all = np -> rxopt . all ;
( channel == xmlParserValidityError ) || <NEW_LINE> ( channel == xmlParserValidityWarning ) ) <NEW_LINE> xmlReportError ( to , ctxt , str , NULL , NULL ) ; <NEW_LINE> <START_VULN> else if ( ( channel == ( xmlGenericErrorFunc ) fprintf ) || <NEW_LINE> <END_VULN> ( channel == xmlGenericErrorDefaultFunc ) ) <NEW_LINE> xmlReportError ( to , ctxt , str , channel , data ) ; <NEW_LINE> else
static inline bool isIteratorTarget ( RenderObject * object ) <NEW_LINE> { <NEW_LINE> ASSERT ( object ) ; <NEW_LINE> <START_VULN> return object -> isText ( ) || object -> isFloating ( ) || object -> isPositioned ( ) || object -> isReplaced ( ) ; <NEW_LINE> <END_VULN> }
const FloatPoint3D & Origin ( ) const { return state_ . origin ; } <NEW_LINE> <START_VULN> const ScrollPaintPropertyNode * ScrollNode ( ) const { <NEW_LINE>return state_ . scroll . get ( ) ; <NEW_LINE> } <NEW_LINE> <END_VULN>
if ( ( png_uint_16 ) ( ( * sp >> shift ) & 0x0f ) <NEW_LINE> == png_ptr -> trans_color . gray ) <NEW_LINE> { <NEW_LINE> <START_VULN> unsigned int tmp = * sp & ( 0xf0f >> ( 4 - shift ) ) ; <NEW_LINE> <END_VULN> tmp |= png_ptr -> background . gray << shift ; <NEW_LINE> * sp = ( png_byte ) ( tmp & 0xff ) ; <NEW_LINE> }
CoreIPC::Connection * connection ( ) const ; <NEW_LINE> uint64_t destinationID ( ) const { return m_downloadID ; } <NEW_LINE> <START_VULN> void start ( ) ; <NEW_LINE> <END_VULN> void didStart ( ) ; <NEW_LINE> void didReceiveResponse ( const WebCore::ResourceResponse & ) ;
return ; <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " [ | dao - truncated ] " ) ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> tooshort:
PRBool undefined ; <NEW_LINE> nsCOMPtr < nsIScriptContext > context = aContext ; <NEW_LINE> rv = context -> EvaluateStringWithValue ( nsDependentString ( mFieldText , <NEW_LINE> mFieldTextLength ) , <NEW_LINE> aBoundNode , <NEW_LINE> <START_VULN> nsnull , uriSpec . get ( ) , <NEW_LINE> <END_VULN> mLineNumber , JSVERSION_LATEST , <NEW_LINE> ( void * ) & result , & undefined ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) <NEW_LINE> return rv ;
<START_VULN> PHPAPI ulong <NEW_LINE> <END_VULN> mysqlnd_old_escape_string ( char * newstr , const char * escapestr , size_t escapestr_len TSRMLS_DC ) <NEW_LINE> { <NEW_LINE> DBG_ENTER ( "mysqlnd_old_escape_string" ) ;
if ( v . isArray ( ) ) { <NEW_LINE> Array subarr1 = v . toArray ( ) ; <NEW_LINE> const ArrNR & arr_value = value . toArrNR ( ) ; <NEW_LINE> <START_VULN> php_array_replace_recursive ( seen , v . isReferenced ( ) , subarr1 , <NEW_LINE>arr_value ) ; <NEW_LINE> <END_VULN> v = subarr1 ; <NEW_LINE> } else { <NEW_LINE> arr1 . set ( key , value , true ) ;
} <NEW_LINE> <START_VULN> strcpy ( tmpf , argv [ c ] ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else
we're * not * floor1 . This won't happen unless someone has <NEW_LINE> broken the encode setup lib . Guard it anyway . * / <NEW_LINE> if ( ci -> floor_type [ info -> floorsubmap [ submap ] ] != 1 ) return ( - 1 ) ; <NEW_LINE> floor_posts [ i ] [ PACKETBLOBS / 2 ] = <NEW_LINE> floor1_fit ( vb , b -> flr [ info -> floorsubmap [ submap ] ] , <NEW_LINE> logmdct , <NEW_LINE> logmask ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( vorbis_bitrate_managed ( vb ) && floor_posts [ i ] [ PACKETBLOBS / 2 ] ) { <NEW_LINE> _vp_offset_and_mix ( psy_look , <NEW_LINE> noise , <NEW_LINE> tone ,
processed = ctxt -> input -> cur - ctxt -> input -> base ; <NEW_LINE> xmlBufShrink ( ctxt -> input -> buf -> buffer , processed ) ; <NEW_LINE> nbchars = xmlCharEncInput ( ctxt -> input -> buf , 1 ) ; <NEW_LINE> if ( nbchars < 0 ) { <NEW_LINE> htmlParseErr ( ctxt , XML_ERR_INVALID_ENCODING , <NEW_LINE> "htmlCheckEncoding: encoder error\n" , <NEW_LINE> NULL , NULL ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> xmlBufResetInput ( ctxt -> input -> buf -> buffer , ctxt -> input ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
} <NEW_LINE> clone_info = CloneDrawInfo ( ( ImageInfo * ) NULL , draw_info ) ; <NEW_LINE> clone_info -> stroke_width = 0 . 0 ; <NEW_LINE> <START_VULN> clone_info -> stroke . alpha = ( Quantum ) TransparentAlpha ; <NEW_LINE> <END_VULN> status &= DrawPolygonPrimitive ( image , clone_info , primitive_info , <NEW_LINE> exception ) ; <NEW_LINE> clone_info = DestroyDrawInfo ( clone_info ) ;
mHadRedoItems = numRedoItems != 0 ; <NEW_LINE> } <NEW_LINE> mFrame -> SetValueChanged ( PR_TRUE ) ; <NEW_LINE> <START_VULN> mFrame -> FireOnInput ( ) ; <NEW_LINE> <END_VULN> if ( ! mSettingValue ) { <NEW_LINE> mTxtCtrlElement -> OnValueChanged ( PR_TRUE ) ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> }
else <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE <NEW_LINE> #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
void FormAssociatedElement::formRemovedFromTree ( const Node * formRoot ) <NEW_LINE> { <NEW_LINE> ASSERT ( m_form ) ; <NEW_LINE> <START_VULN> if ( toHTMLElement ( this ) -> highestAncestor ( ) != formRoot ) <NEW_LINE>setForm ( 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void FormAssociatedElement::setForm ( HTMLFormElement * newForm )
char sbuf [ 512 ] ; <NEW_LINE> struct NetBSD_elfcore_procinfo pi ; <NEW_LINE> memset ( & pi , 0 , sizeof ( pi ) ) ; <NEW_LINE> <START_VULN> memcpy ( & pi , nbuf + doff , descsz ) ; <NEW_LINE> <END_VULN> if ( file_printf ( ms , " , from ' % . 31s' , pid = % u , uid = % u , " <NEW_LINE> "gid = % u , nlwps = % u , lwp = % u ( signal % u / code % u ) " ,
NS_PRECONDITION ( _retval , "bad param" ) ; <NEW_LINE> RootedObject scope ( ctx , scopeArg ) ; <NEW_LINE> XPCCallContext ccx ( NATIVE_CALLER , ctx ) ; <NEW_LINE> if ( ! ccx . IsValid ( ) ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> XPCLazyCallContext lccx ( ccx ) ; <NEW_LINE> <START_VULN> ccx . SetScopeForNewJSObjects ( scope ) ; <NEW_LINE> <END_VULN> nsresult rv = NS_OK ; <NEW_LINE> if ( ! XPCVariant::VariantDataToJS ( lccx , value , & rv , _retval ) ) { <NEW_LINE> if ( NS_FAILED ( rv ) ) <NEW_LINE> return rv ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> }
fclose ( pathfile ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> ret = mount ( path , destpath , "none" , MS_BIND , NULL ) ; <NEW_LINE> <END_VULN> if ( ret < 0 ) <NEW_LINE> SYSERROR ( "Failed to bind lxc . init . static into container" ) ; <NEW_LINE> INFO ( "lxc . init . static bound into container at % s" , path ) ;
if ( nodeToInsertBefore && nodeToInsertBefore -> GetParent ( ) != this ) { <NEW_LINE> aError . Throw ( NS_ERROR_DOM_HIERARCHY_REQUEST_ERR ) ; <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( newContent -> GetParent ( ) ) { <NEW_LINE> <END_VULN> aError . Throw ( NS_ERROR_DOM_HIERARCHY_REQUEST_ERR ) ; <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> if ( aNewChild == aRefChild ) {
typedef struct { <NEW_LINE> <START_VULN> uchar * buf_ ; <NEW_LINE> <END_VULN> size_t bufsize_ ;
& lua_module ) ; <NEW_LINE> const ap_lua_dir_cfg * cfg = ap_get_module_config ( r -> per_dir_config , <NEW_LINE> & lua_module ) ; <NEW_LINE> <START_VULN> const lua_authz_provider_spec * prov_spec = parsed_require_line ; <NEW_LINE> <END_VULN> int result ; <NEW_LINE> int nargs = 0 ;
AutoMarkingWrappedNativePtr wrapperMarker ( ccx , wrapper ) ; <NEW_LINE> JSAutoEnterCompartment ac ; <NEW_LINE> <START_VULN> if ( ! ac . enter ( ccx , existingJSObject ) || ! wrapper -> Init ( ccx , existingJSObject ) ) <NEW_LINE> <END_VULN> return NS_ERROR_FAILURE ; <NEW_LINE> nsresult rv ; <NEW_LINE> if ( Interface && ! wrapper -> FindTearOff ( ccx , Interface , false , & rv ) ) { <NEW_LINE> NS_ASSERTION ( NS_FAILED ( rv ) , "returning NS_OK on failure" ) ; <NEW_LINE> return rv ; <NEW_LINE> }
static PLDHashOperator ResetNodeDirection ( nsPtrHashKey < Element > * aEntry , void * aData ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( aEntry -> GetKey ( ) -> IsElement ( ) , "Must be an Element" ) ; <NEW_LINE> nsINode * oldTextNode = static_cast < Element * > ( aData ) ; <NEW_LINE> Element * rootNode = aEntry -> GetKey ( ) ; <NEW_LINE> nsINode * newTextNode = nullptr ; <NEW_LINE> <START_VULN> if ( rootNode -> HasDirAuto ( ) ) { <NEW_LINE> <END_VULN> newTextNode = WalkDescendantsSetDirectionFromText ( rootNode , true , <NEW_LINE> oldTextNode ) ; <NEW_LINE> } <NEW_LINE> if ( newTextNode ) { <NEW_LINE> nsTextNodeDirectionalityMap::AddEntryToMap ( newTextNode , rootNode ) ; <NEW_LINE> } else { <NEW_LINE> rootNode -> ClearHasDirAutoSet ( ) ; <NEW_LINE> rootNode -> UnsetProperty ( nsGkAtoms::dirAutoSetBy ) ;
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job - sheets" , <NEW_LINE> 2 , NULL , NULL ) ; <NEW_LINE> <START_VULN> attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ) ; <NEW_LINE>attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> job -> job_sheets = attr ;
ReadIndex = SizeIdx - 1 ; <NEW_LINE> memmove ( & PossibleIdNSize [ 0 ] , & PossibleIdNSize [ 1 ] , ReadIndex ) ; <NEW_LINE> UpperLevel = UpperLevel_original ; <NEW_LINE> <START_VULN> } while ( MaxDataSize > DataStream . getFilePointer ( ) - SizeIdx + PossibleID_Length ) ; <NEW_LINE> <END_VULN> return NULL ; <NEW_LINE> }
static void * operator new ( size_t size ) CPP_THROW_NEW { <NEW_LINE> return sAllocator -> Alloc ( size ) ; <NEW_LINE> } <NEW_LINE> void operator delete ( void * p ) { <NEW_LINE> sAllocator -> Free ( p ) ; <NEW_LINE> DeleteAllocatorIfNeeded ( ) ; <NEW_LINE> } <NEW_LINE> private: <NEW_LINE> <START_VULN> nsTimerEvent ( ) ; <NEW_LINE> <END_VULN> ~ nsTimerEvent ( ) { <NEW_LINE> MOZ_COUNT_DTOR ( nsTimerEvent ) ; <NEW_LINE> MOZ_ASSERT ( ! sCanDeleteAllocator || sAllocatorUsers > 0 , <NEW_LINE> "This will result in us attempting to deallocate the nsTimerEvent allocator twice" ) ; <NEW_LINE> PR_ATOMIC_DECREMENT ( & sAllocatorUsers ) ; <NEW_LINE> }
some printers when `currentfile closefile' is followed by space * / <NEW_LINE> p += sizeof ( "currentfile closefile" ) - 1 ; <NEW_LINE> <START_VULN> for ( q = p ; isspace ( * q ) && * q != '\n' ; q ++ ) <NEW_LINE> <END_VULN> if ( q == p && ! * q ) <NEW_LINE> error ( "warning: `currentfile closefile' line too long" ) ;
static const uint32_t UTF8CharLenTable [ ] = { 0 , 1 , 0 , 0 , 0 , 0 , 2 , 3 , <NEW_LINE> 3 , 3 , 4 , 4 , 5 , 5 , 6 , 6 } ; <NEW_LINE> const SMModel UTF8SMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , UTF8_cls } , <NEW_LINE> 16 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , UTF8_st } , <NEW_LINE> <START_VULN> UTF8CharLenTable , <NEW_LINE> <END_VULN> "UTF - 8" , <NEW_LINE> } ;
} <NEW_LINE> obj = newThis ; <NEW_LINE> } <NEW_LINE> return obj ; <NEW_LINE> } <NEW_LINE> <START_VULN> js::Class XPC_WN_NoHelper_JSClass = { <NEW_LINE> <END_VULN> "XPCWrappedNative_NoHelper" , <NEW_LINE> WRAPPER_SLOTS | <NEW_LINE> JSCLASS_PRIVATE_IS_NSISUPPORTS , <NEW_LINE> XPC_WN_OnlyIWrite_AddPropertyStub , <NEW_LINE> XPC_WN_CannotModifyPropertyStub , <NEW_LINE> JS_PropertyStub ,
return ( inflateReset ( & png_ptr -> zstream ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> png_uint_32 PNGAPI
#include < memory > <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "dbus / dbus_export . h" <NEW_LINE> namespace dbus {
<START_VULN> struct PlatformFileInfo { <NEW_LINE> <END_VULN> PlatformFileInfo ( ) ; <NEW_LINE> ~ PlatformFileInfo ( ) ;
<START_VULN> image -> page . x = ReadBlobLSBShort ( image ) ; <NEW_LINE>image -> page . y = ReadBlobLSBShort ( image ) ; <NEW_LINE> <END_VULN> image -> columns = ReadBlobLSBShort ( image ) ; <NEW_LINE> image -> rows = ReadBlobLSBShort ( image ) ; <NEW_LINE> flags = ( MagickStatusType ) ReadBlobByte ( image ) ;
return updateGraphicBufferInMeta_l ( <NEW_LINE> portIndex , graphicBuffer , buffer , header , <NEW_LINE> <START_VULN> portIndex == kPortIndexOutput ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> status_t OMXNodeInstance::updateNativeHandleInMeta (
* <NEW_LINE> BOOL <NEW_LINE> WriteStatusFailure ( LPCWSTR updateDirPath , int errorCode ) <NEW_LINE> { <NEW_LINE> <START_VULN> WCHAR updateStatusFilePath [ MAX_PATH + 1 ] ; <NEW_LINE>wcscpy ( updateStatusFilePath , updateDirPath ) ; <NEW_LINE> <END_VULN> if ( ! PathAppendSafe ( updateStatusFilePath , L"update . status" ) ) { <NEW_LINE> return FALSE ; <NEW_LINE> } <NEW_LINE> HANDLE statusFile = CreateFileW ( updateStatusFilePath , GENERIC_WRITE , 0 , <NEW_LINE> NULL , CREATE_ALWAYS , 0 , NULL ) ; <NEW_LINE> if ( statusFile == INVALID_HANDLE_VALUE ) { <NEW_LINE> return FALSE ;
threshold_image = CloneImage ( image , 0 , 0 , MagickTrue , exception ) ; <NEW_LINE> if ( threshold_image == ( Image * ) NULL ) <NEW_LINE> return ( ( Image * ) NULL ) ; <NEW_LINE> <START_VULN> if ( width == 0 ) <NEW_LINE> <END_VULN> return ( threshold_image ) ; <NEW_LINE> status = SetImageStorageClass ( threshold_image , DirectClass , exception ) ; <NEW_LINE> if ( status == MagickFalse )
int perf_output_begin ( struct perf_output_handle * handle , <NEW_LINE> struct perf_event * event , unsigned int size , <NEW_LINE> <START_VULN> int nmi , int sample ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct ring_buffer * rb ; <NEW_LINE> unsigned long tail , offset , head ;
void fStencilOpSeparate ( GLenum face , GLenum sfail , GLenum dpfail , GLenum dppass ) { <NEW_LINE> BEFORE_GL_CALL ; <NEW_LINE> mSymbols . fStencilOpSeparate ( face , sfail , dpfail , dppass ) ; <NEW_LINE> AFTER_GL_CALL ; <NEW_LINE> } <NEW_LINE> void fTexImage2D ( GLenum target , GLint level , GLint internalformat , GLsizei width , GLsizei height , GLint border , GLenum format , GLenum type , const GLvoid * pixels ) { <NEW_LINE> BEFORE_GL_CALL ; <NEW_LINE> <START_VULN> mSymbols . fTexImage2D ( target , level , internalformat , width , height , border , format , type , pixels ) ; <NEW_LINE> <END_VULN> AFTER_GL_CALL ; <NEW_LINE> } <NEW_LINE> void fTexSubImage2D ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLsizei width , GLsizei height , GLenum format , GLenum type , const GLvoid * pixels ) { <NEW_LINE> BEFORE_GL_CALL ; <NEW_LINE> mSymbols . fTexSubImage2D ( target , level , xoffset , yoffset , width , height , format , type , pixels ) ; <NEW_LINE> AFTER_GL_CALL ; <NEW_LINE> }
png_byte bit_depth = 0 ; <NEW_LINE> unsigned int palette_number = 0 ; <NEW_LINE> <START_VULN> while ( next_format ( & colour_type , & bit_depth , & palette_number , 0 ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_uint_32 counter = 0 ; <NEW_LINE> size_t base_pos ;
case NLPID_CLNP: <NEW_LINE> if ( ! clnp_print ( ndo , p , length ) ) <NEW_LINE> <START_VULN> print_unknown_data ( ndo , p , "\n\t" , caplen ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case NLPID_ESIS:
if ( aType == imgINotificationObserver::LOAD_COMPLETE ) { <NEW_LINE> NS_ABORT_IF_FALSE ( aRequest , "no request ? " ) ; <NEW_LINE> NS_PRECONDITION ( aRequest == mCurrentRequest || aRequest == mPendingRequest , <NEW_LINE> "Unknown request" ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> LOOP_OVER_OBSERVERS ( Notify ( aRequest , aType , aData ) ) ; <NEW_LINE> <END_VULN> if ( aType == imgINotificationObserver::SIZE_AVAILABLE ) { <NEW_LINE> UpdateImageState ( true ) ; <NEW_LINE> } <NEW_LINE> if ( aType == imgINotificationObserver::LOAD_COMPLETE ) {
computeRegionRangeForBlock ( ) ; <NEW_LINE> <START_VULN> if ( ! isFloatingOrPositioned ( ) && height ( ) == 0 ) { <NEW_LINE> <END_VULN>
p = this ; <NEW_LINE> p -- ; <NEW_LINE> if ( p < 0 ) p += VE_AMP ; <NEW_LINE> postmax = max ( acc , filters [ j ] . ampbuf [ p ] ) ; <NEW_LINE> postmin = min ( acc , filters [ j ] . ampbuf [ p ] ) ; <NEW_LINE> for ( i = 0 ; i < stretch ; i ++ ) { <NEW_LINE> <START_VULN> p -- ; <NEW_LINE>if ( p < 0 ) p += VE_AMP ; <NEW_LINE>premax = max ( premax , filters [ j ] . ampbuf [ p ] ) ; <NEW_LINE>premin = min ( premin , filters [ j ] . ampbuf [ p ] ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> valmin = postmin - premin ; <NEW_LINE> valmax = postmax - premax ; <NEW_LINE> filters [ j ] . ampbuf [ this ] = acc ; <NEW_LINE> filters [ j ] . ampptr ++ ;
int jas_matrix_cmp ( jas_matrix_t * mat0 , jas_matrix_t * mat1 ) <NEW_LINE> { <NEW_LINE> <START_VULN> int i ; <NEW_LINE>int j ; <NEW_LINE> <END_VULN> if ( mat0 -> numrows_ != mat1 -> numrows_ || mat0 -> numcols_ != <NEW_LINE> mat1 -> numcols_ ) {
ND_PRINT ( ( ndo , " ( length bogus , should be >= 3 ) " ) ) ; <NEW_LINE> return len ; <NEW_LINE> } <NEW_LINE> <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , ": Version: % u , Dictionary Bits: % u" , <NEW_LINE> p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ; <NEW_LINE> break ;
#include "components / scheduler / child / prioritizing_task_queue_selector . h" <NEW_LINE> #include "components / scheduler / child / task_queue_manager . h" <NEW_LINE> <START_VULN> #include "components / scheduler / child / time_source . h" <NEW_LINE> <END_VULN> #include "components / scheduler / scheduler_export . h" <NEW_LINE> namespace scheduler { <NEW_LINE> class NestableSingleThreadTaskRunner ;
retval = copy_strings_kernel ( 1 , & i_name , bprm ) ; <NEW_LINE> if ( retval ) return retval ; <NEW_LINE> bprm -> argc ++ ; <NEW_LINE> <START_VULN> bprm -> interp = interp ; <NEW_LINE> <END_VULN> file = open_exec ( interp ) ;
LOG ( LOG_INFO , ( "EOF reading packet len" ) ) ; <NEW_LINE> <START_VULN> return - 1 ; <NEW_LINE> <END_VULN> } <NEW_LINE> len_buf_pos += ret ;
! ( r & ( num_8x8_blocks_high_lookup [ sb_type ] - 1 ) ) : 1 ; <NEW_LINE> const int skip_this_r = skip_this && ! block_edge_above ; <NEW_LINE> const TX_SIZE tx_size = ( plane -> plane_type == PLANE_TYPE_UV ) <NEW_LINE> <START_VULN> ? get_uv_tx_size ( & mi [ 0 ] . mbmi ) <NEW_LINE> <END_VULN> : mi [ 0 ] . mbmi . tx_size ; <NEW_LINE> const int skip_border_4x4_c = ss_x && mi_col + c == cm -> mi_cols - 1 ; <NEW_LINE> const int skip_border_4x4_r = ss_y && mi_row + r == cm -> mi_rows - 1 ;
#include < vector > <NEW_LINE> #include "base / logging . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "base / stl_util . h"
#ifdef DEBUG <NEW_LINE> inline void CHECK_STATE ( int s ) const { NS_ASSERTION ( mState >= s , "bad state" ) ; } <NEW_LINE> #else <NEW_LINE> #define CHECK_STATE ( s ) ( ( void ) 0 ) <NEW_LINE> #endif <NEW_LINE> private: <NEW_LINE> State mState ; <NEW_LINE> nsXPConnect * mXPC ; <NEW_LINE> XPCContext * mXPCContext ; <NEW_LINE> JSContext * mJSContext ; <NEW_LINE> JSBool mContextPopRequired ; <NEW_LINE> <START_VULN> JSBool mDestroyJSContextInDestructor ; <NEW_LINE> <END_VULN> XPCContext::LangType mCallerLanguage ; <NEW_LINE> XPCContext::LangType mPrevCallerLanguage ; <NEW_LINE> XPCCallContext * mPrevCallContext ;
int ret ; <NEW_LINE> do { <NEW_LINE> <START_VULN> ret = epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ; <NEW_LINE> <END_VULN> } while ( ret == - 1 && errno == EINTR ) ; <NEW_LINE> if ( ret == - 1 ) {
float min_page_scale_factor , <NEW_LINE> float max_page_scale_factor ) = 0 ; <NEW_LINE> <START_VULN> virtual void DidOverscroll ( gfx::Vector2dF accumulated_overscroll , <NEW_LINE>gfx::Vector2dF latest_overscroll_delta , <NEW_LINE>gfx::Vector2dF current_fling_velocity ) = 0 ; <NEW_LINE> <END_VULN> virtual void PostInvalidate ( ) = 0 ;
const uint8_t * data ; <NEW_LINE> int ifp_len ; <NEW_LINE> int repaired [ 16 ] ; <NEW_LINE> <START_VULN> const uint8_t * bufs [ 16 ] ; <NEW_LINE>int lengths [ 16 ] ; <NEW_LINE> <END_VULN> int span ; <NEW_LINE> int entries ; <NEW_LINE> int ifp_no ;
mRunLength = 0 ; <NEW_LINE> } else if ( ' ( ' == * src ) { <NEW_LINE> mState = mState_ESC_24_28 ; <NEW_LINE> } else { <NEW_LINE> if ( CHECK_OVERRUN ( dest , destEnd , 3 ) ) <NEW_LINE> goto error1 ; <NEW_LINE> * dest ++ = ( PRUnichar ) 0x1b ; <NEW_LINE> * dest ++ = ( PRUnichar ) ' $ ' ; <NEW_LINE> <START_VULN> if ( 0x80 & * src ) <NEW_LINE>goto error2 ; <NEW_LINE> * dest ++ = ( PRUnichar ) * src ; <NEW_LINE> <END_VULN> mState = mLastLegalState ; <NEW_LINE> } <NEW_LINE> break ; <NEW_LINE> case mState_ESC_24_28: <NEW_LINE> if ( 'C' == * src ) { <NEW_LINE> mState = mState_KSC5601_1987 ; <NEW_LINE> mRunLength = 0 ;
struct TypedArrayObjectStorage : AllTypedArraysBase { <NEW_LINE> protected: <NEW_LINE> JSObject * mObj ; <NEW_LINE> <START_VULN> TypedArrayObjectStorage ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> public: <NEW_LINE> inline void TraceSelf ( JSTracer * trc ) <NEW_LINE> { <NEW_LINE> if ( mObj ) { <NEW_LINE> JS_CallObjectTracer ( trc , & mObj , "TypedArray . mObj" ) ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> intra_pred_var = vp8_get_mb_ss ( x -> src_diff ) ; <NEW_LINE> <END_VULN> return intra_pred_var ; <NEW_LINE> }
for ( size_t n = 0 ; n < argc ; ++ n ) { <NEW_LINE> if ( ! call . destination -> wrap ( cx , & argv [ n ] ) ) <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> if ( ! DirectWrapper::call ( cx , wrapper , argc , vp ) ) <NEW_LINE> return false ; <NEW_LINE> call . leave ( ) ; <NEW_LINE> <START_VULN> return call . origin -> wrap ( cx , vp ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::construct ( JSContext * cx , JSObject * wrapper_ , unsigned argc , Value * argv , <NEW_LINE> Value * rval ) <NEW_LINE> { <NEW_LINE> RootedObject wrapper ( cx , wrapper_ ) ;
#include "core / dom / ActiveDOMObject . h" <NEW_LINE> #include "core / events / EventTarget . h" <NEW_LINE> #include "core / platform / mediastream / MediaStreamDescriptor . h" <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "modules / mediastream / SourceInfo . h" <NEW_LINE> #include "wtf / RefCounted . h" <NEW_LINE> #include "wtf / RefPtr . h" <NEW_LINE> #include "wtf / Vector . h"
int result = - 1 ; <NEW_LINE> int i = 0 ; <NEW_LINE> int len = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( str && ( ( len = strlen ( str ) ) > 0 ) ) { <NEW_LINE> for ( i = 0 ; i < len ; i ++ ) { <NEW_LINE> if ( isIDSeparator ( * ( str + i ) ) ) {
p ++ ; <NEW_LINE> size = ( size_t ) strtol ( p , & q , 10 ) ; <NEW_LINE> <START_VULN> if ( p == q || size < 16 || size > 256 ) <NEW_LINE>return ( ( Image * ) NULL ) ; <NEW_LINE> <END_VULN> p = q ; <NEW_LINE> sizes [ i ++ ] = size ;
JSExtendedClass SJOWClass = { <NEW_LINE> { "XPCSafeJSObjectWrapper" , <NEW_LINE> JSCLASS_NEW_RESOLVE | JSCLASS_IS_EXTENDED | <NEW_LINE> <START_VULN> JSCLASS_HAS_RESERVED_SLOTS ( XPCWrapper::sNumSlots + 1 ) , <NEW_LINE> <END_VULN> XPC_SJOW_AddProperty , XPC_SJOW_DelProperty , <NEW_LINE> XPC_SJOW_GetProperty , XPC_SJOW_SetProperty , <NEW_LINE> XPC_SJOW_Enumerate , ( JSResolveOp ) XPC_SJOW_NewResolve , <NEW_LINE> XPC_SJOW_Convert , XPC_SJOW_Finalize , <NEW_LINE> nsnull , XPC_SJOW_CheckAccess , <NEW_LINE> XPC_SJOW_Call , XPC_SJOW_Create , <NEW_LINE> nsnull , nsnull , <NEW_LINE> nsnull , nsnull
} <NEW_LINE> if ( offset + 1 >= optslen ) { <NEW_LINE> <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> }
nsLayoutUtils::SurfaceFromElementResult SurfaceFromElement ( const dom::NonNull < ElementType > & aElement ) { <NEW_LINE> return SurfaceFromElement ( aElement . get ( ) ) ; <NEW_LINE> } <NEW_LINE> nsresult SurfaceFromElementResultToImageSurface ( nsLayoutUtils::SurfaceFromElementResult & res , <NEW_LINE> gfxImageSurface ** imageOut , <NEW_LINE> WebGLTexelFormat * format ) ; <NEW_LINE> <START_VULN> void CopyTexSubImage2D_base ( WebGLenum target , <NEW_LINE> <END_VULN> WebGLint level , <NEW_LINE> WebGLenum internalformat , <NEW_LINE> WebGLint xoffset , <NEW_LINE> WebGLint yoffset , <NEW_LINE> WebGLint x , <NEW_LINE> WebGLint y , <NEW_LINE> WebGLsizei width , <NEW_LINE> WebGLsizei height ,
PatchFile::Prepare ( ) <NEW_LINE> { <NEW_LINE> LOG ( ( "PREPARE PATCH " LOG_S , mFile ) ) ; <NEW_LINE> mPatchIndex = sPatchIndex ++ ; <NEW_LINE> NS_tsnprintf ( spath , sizeof ( spath ) / sizeof ( spath [ 0 ] ) , <NEW_LINE> <START_VULN> NS_T ( " % s / % d . patch" ) , gSourcePath , mPatchIndex ) ; <NEW_LINE> <END_VULN> NS_tremove ( spath ) ; <NEW_LINE> FILE * fp = NS_tfopen ( spath , NS_T ( "wb" ) ) ; <NEW_LINE> if ( ! fp ) <NEW_LINE> return WRITE_ERROR ; <NEW_LINE> #ifdef XP_WIN
if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) <NEW_LINE> ERROR ( "rc_twopass_stats_in . sz indicates truncated packet . " ) ; <NEW_LINE> <START_VULN> if ( cfg -> ss_number_layers > 1 ) { <NEW_LINE> <END_VULN> int i ; <NEW_LINE> unsigned int n_packets_per_layer [ VPX_SS_MAX_LAYERS ] = { 0 } ;
cipher_set_keycontext ( state -> send_context , keyout ) ; <NEW_LINE> cipher_set_keycontext ( state -> receive_context , keyin ) ; <NEW_LINE> <START_VULN> if ( ( r = ssh_packet_set_compress_state ( ssh , m ) ) != 0 || <NEW_LINE> ( r = ssh_packet_set_postauth ( ssh ) ) != 0 ) <NEW_LINE> <END_VULN> return r ; <NEW_LINE> sshbuf_reset ( state -> input ) ;
if ( ! slot ) <NEW_LINE> goto out ; <NEW_LINE> <START_VULN> int received = recv ( slot -> fd , buf , size , 0 ) ; <NEW_LINE> <END_VULN> if ( received == size ) { <NEW_LINE> ret = true ; <NEW_LINE> } else {
inflateEnd ( & zip -> stream ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> #if HAVA_LZMA_H && HAVE_LIBLZMA <NEW_LINE> <END_VULN> if ( zip -> zipx_lzma_valid ) { <NEW_LINE> lzma_end ( & zip -> zipx_lzma_stream ) ; <NEW_LINE> }
} <NEW_LINE> * vp = UndefinedValue ( ) ; <NEW_LINE> <START_VULN> return table -> map . put ( key , value ) != NULL ; <NEW_LINE> <END_VULN> out_of_memory: <NEW_LINE> JS_ReportOutOfMemory ( cx ) ;
if ( ( success = pb_get_encoded_size ( & encoded_size , MsgHeader_fields , <NEW_LINE> hdr ) ) && encoded_size <= INT32_MAX && commandFd != - 1 ) { <NEW_LINE> buffer_size = encoded_size + sizeof ( uint32_t ) ; <NEW_LINE> <START_VULN> uint8_t buffer [ buffer_size ] ; <NEW_LINE> <END_VULN> written_size = htonl ( ( uint32_t ) encoded_size ) ; <NEW_LINE> ostream = pb_ostream_from_buffer ( buffer , buffer_size ) ; <NEW_LINE> pb_write ( & ostream , ( uint8_t * ) & written_size , sizeof ( written_size ) ) ;
{ <NEW_LINE> RenderBlock * firstChildIgnoringAnonymousWrappers = 0 ; <NEW_LINE> for ( RenderObject * curr = this ; curr ; curr = curr -> parent ( ) ) { <NEW_LINE> <START_VULN> if ( ! curr -> isRenderBlock ( ) || curr -> isFloatingOrPositioned ( ) || curr -> isTableCell ( ) || curr -> isRoot ( ) || curr -> isRenderView ( ) || curr -> hasOverflowClip ( ) <NEW_LINE> <END_VULN> || curr -> isInlineBlockOrInlineTable ( ) ) <NEW_LINE> return 0 ;
if ( u4_curr_bit == 31 ) <NEW_LINE> { <NEW_LINE> ps_stream -> u4_buf = ps_stream -> u4_buf_nxt ; <NEW_LINE> <START_VULN> u4_temp = * ( ps_stream -> pu4_buf_aligned ) ++ ; <NEW_LINE>CONV_LE_TO_BE ( ps_stream -> u4_buf_nxt , u4_temp ) <NEW_LINE> <END_VULN> } <NEW_LINE> ps_stream -> u4_offset = u4_offset ;
IDBKeyRange * aKeyRange , <NEW_LINE> const uint32_t aLimit ) <NEW_LINE> : GetKeyHelper ( aTransaction , aRequest , aIndex , aKeyRange ) , mLimit ( aLimit ) <NEW_LINE> { } <NEW_LINE> ~ GetAllHelper ( ) <NEW_LINE> { <NEW_LINE> for ( uint32_t index = 0 ; index < mCloneReadInfos . Length ( ) ; index ++ ) { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( <NEW_LINE>mCloneReadInfos [ index ] . mCloneBuffer ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> virtual nsresult DoDatabaseWork ( mozIStorageConnection * aConnection ) <NEW_LINE> MOZ_OVERRIDE ; <NEW_LINE> virtual nsresult GetSuccessResult ( JSContext * aCx , <NEW_LINE> jsval * aVal ) MOZ_OVERRIDE ;
ZVAL_STR ( rval , str ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 936 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy46: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych == ' + ' ) goto yy47 ;
@param ptr Pointer to the block <NEW_LINE> @return Size of the allocated block . <NEW_LINE> @ingroup MprMem <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC size_t psize ( void * ptr ) ;
#include "config . h" <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "wtf / PassOwnPtr . h" <NEW_LINE> namespace WebCore {
return ret ; <NEW_LINE> } <NEW_LINE> <START_VULN> void SoftMPEG2::setDecodeArgs ( <NEW_LINE> <END_VULN> ivd_video_decode_ip_t * ps_dec_ip , <NEW_LINE> ivd_video_decode_op_t * ps_dec_op , <NEW_LINE> OMX_BUFFERHEADERTYPE * inHeader ,
new nsPLDOMEvent ( node , NS_LITERAL_STRING ( "select" ) , PR_FALSE ) ; <NEW_LINE> event -> RunDOMEventWhenSafe ( ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsTreeSelection::SelectCallback ( nsITimer * aTimer , void * aClosure ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsTreeSelection * self = static_cast < nsTreeSelection * > ( aClosure ) ; <NEW_LINE> <END_VULN> if ( self ) { <NEW_LINE> self -> FireOnSelectHandler ( ) ; <NEW_LINE> aTimer -> Cancel ( ) ; <NEW_LINE> self -> mSelectTimer = nsnull ; <NEW_LINE> } <NEW_LINE> }
typedef struct TcpSession_ { <NEW_LINE> PoolThreadReserved res ; <NEW_LINE> <START_VULN> uint8_t state ; <NEW_LINE> <END_VULN> uint8_t queue_len ; <NEW_LINE> int8_t data_first_seen_dir ;
ENTROPY_CONTEXT * ta ; <NEW_LINE> ENTROPY_CONTEXT * tl ; <NEW_LINE> <START_VULN> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE> <END_VULN> ta = ( ENTROPY_CONTEXT * ) & t_above ; <NEW_LINE> tl = ( ENTROPY_CONTEXT * ) & t_left ;
ifr . ifr_hwaddr . sa_data [ 0 ] &= ~ 0x01 ; <NEW_LINE> } <NEW_LINE> <START_VULN> err = ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ; <NEW_LINE> <END_VULN> if ( err < 0 ) { <NEW_LINE> BTIF_TRACE_ERROR ( "Could not set bt address for interface: % s , errno: % s" , devname , strerror ( errno ) ) ;
m_textLength = m_positionEndOffset - m_positionStartOffset ; <NEW_LINE> m_textCharacters = text . characters ( ) + ( m_positionStartOffset - offsetInNode ) ; <NEW_LINE> ASSERT ( m_textCharacters >= text . characters ( ) ) ; <NEW_LINE> <START_VULN> ASSERT ( m_textCharacters + m_textLength <= text . characters ( ) + static_cast < int > ( text . length ( ) ) ) ; <NEW_LINE> <END_VULN> m_lastCharacter = text [ m_positionEndOffset - 1 ] ;
specified via mprCreate will be called to allow global recovery . <NEW_LINE> @remarks Do not mix calls to prealloc and malloc . <NEW_LINE> @ingroup MprMem <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC void * prealloc ( void * ptr , size_t size ) ;
{ <NEW_LINE> const char * perm = "add" ; <NEW_LINE> <START_VULN> if ( uid >= AID_APP ) { <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
return err ; <NEW_LINE> } <NEW_LINE> <START_VULN> int check_fragments_for_errors ( VP8D_COMP * pbi ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ! pbi -> ec_active && <NEW_LINE> pbi -> fragments . count <= 1 && pbi -> fragments . sizes [ 0 ] == 0 )
reconstruct_image = RemoveFirstImageFromList ( & _images ) ; <NEW_LINE> if ( reconstruct_image == ( Image * ) NULL ) <NEW_LINE> <START_VULN> break ; <NEW_LINE> <END_VULN> metric = UndefinedErrorMetric ; <NEW_LINE> option = GetImageOption ( _image_info , "metric" ) ; <NEW_LINE> if ( option != ( const char * ) NULL )
#include "compiler / OutputHLSL . h" <NEW_LINE> <START_VULN> #include "compiler / debug . h" <NEW_LINE> <END_VULN> #include "compiler / InfoSink . h" <NEW_LINE> #include "compiler / UnfoldSelect . h" <NEW_LINE> #include "compiler / SearchSymbol . h" <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < algorithm > <NEW_LINE> namespace sh
if ( ( buffer == ( unsigned char * ) NULL ) || <NEW_LINE> ( packed_scanline == ( unsigned char * ) NULL ) || <NEW_LINE> ( scanline == ( unsigned char * ) NULL ) ) <NEW_LINE> <START_VULN> ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <END_VULN> ( void ) ResetMagickMemory ( scanline , 0 , row_bytes ) ; <NEW_LINE> ( void ) ResetMagickMemory ( packed_scanline , 0 , ( size_t ) ( row_bytes + MaxCount ) ) ;
NULL , <NEW_LINE> 0 , <NEW_LINE> 0 , 0 , 0 , 0 , <NEW_LINE> NULL , <NEW_LINE> NULL , NULL , NULL , <NEW_LINE> 0 <NEW_LINE> } ; <NEW_LINE> static float * test1_result = NULL ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> static_codebook test2 = { <NEW_LINE> 4 , 3 , <NEW_LINE> NULL , <NEW_LINE> 2 , <NEW_LINE> - 533200896 , 1611661312 , 4 , 0 , <NEW_LINE> full_quantlist1 , <NEW_LINE> NULL , NULL , NULL ,
#define DESC_BUFFER_SIZE ( 8192 * 16 ) <NEW_LINE> #ifdef _ANDROID_ <NEW_LINE> <START_VULN> #define MAX_NUM_INPUT_OUTPUT_BUFFERS 32 <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef _ION_HEAP_MASK_COMPATIBILITY_WA
XPCWrappedNativeScope * found = nsnull ; <NEW_LINE> { <NEW_LINE> XPCAutoLock lock ( runtime -> GetMapLock ( ) ) ; <NEW_LINE> DEBUG_TrackScopeTraversal ( ) ; <NEW_LINE> for ( XPCWrappedNativeScope * cur = gScopes ; cur ; cur = cur -> mNext ) { <NEW_LINE> <START_VULN> if ( obj == cur -> GetGlobalJSObject ( ) ) { <NEW_LINE> <END_VULN> found = cur ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( found ) {
UWORD16 impeg2d_get_mb_addr_incr ( stream_t * ps_stream ) <NEW_LINE> { <NEW_LINE> UWORD16 u2_mb_addr_incr = 0 ; <NEW_LINE> <START_VULN> while ( impeg2d_bit_stream_nxt ( ps_stream , MB_ESCAPE_CODE_LEN ) == MB_ESCAPE_CODE ) <NEW_LINE> <END_VULN> { <NEW_LINE> impeg2d_bit_stream_flush ( ps_stream , MB_ESCAPE_CODE_LEN ) ; <NEW_LINE> u2_mb_addr_incr += 33 ;
for ( i = 0 , v = 0 ; i < num_palette ; i ++ , v += color_inc ) <NEW_LINE> { <NEW_LINE> <START_VULN> palette [ i ] . red = ( png_byte ) v ; <NEW_LINE>palette [ i ] . green = ( png_byte ) v ; <NEW_LINE>palette [ i ] . blue = ( png_byte ) v ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> #endif
bool isShift ; <NEW_LINE> bool isControl ; <NEW_LINE> #ifdef XP_MACOSX <NEW_LINE> mouseEvent -> GetMetaKey ( & isControl ) ; <NEW_LINE> #else <NEW_LINE> mouseEvent -> GetCtrlKey ( & isControl ) ; <NEW_LINE> #endif <NEW_LINE> mouseEvent -> GetShiftKey ( & isShift ) ; <NEW_LINE> <START_VULN> return PerformSelection ( aClickedIndex , isShift , isControl ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsListControlFrame::CaptureMouseEvents ( bool aGrabMouseEvents ) <NEW_LINE> {
#endif <NEW_LINE> <START_VULN> if ( transforms & PNG_TRANSFORM_EXPAND_16 ) <NEW_LINE> <END_VULN> #ifdef PNG_READ_EXPAND_16_SUPPORTED <NEW_LINE> png_set_expand_16 ( png_ptr ) ; <NEW_LINE> #else
bool handleHandshakeResultNow ; <NEW_LINE> socketInfo -> GetHandshakePending ( & handleHandshakeResultNow ) ; <NEW_LINE> bool wantRetry = false ; <NEW_LINE> if ( 0 > bytesTransfered ) { <NEW_LINE> <START_VULN> int32_t err = PR_GetError ( ) ; <NEW_LINE> <END_VULN> if ( handleHandshakeResultNow ) { <NEW_LINE> if ( PR_WOULD_BLOCK_ERROR == err ) { <NEW_LINE> socketInfo -> SetHandshakeInProgress ( true ) ; <NEW_LINE> return bytesTransfered ; <NEW_LINE> } <NEW_LINE> if ( ! wantRetry <NEW_LINE> && isTLSIntoleranceError ( err , socketInfo -> GetHasCleartextPhase ( ) ) ) <NEW_LINE> { <NEW_LINE> nsSSLIOLayerHelpers & helpers = socketInfo -> SharedState ( ) . IOLayerHelpers ( ) ; <NEW_LINE> wantRetry = helpers . rememberPossibleTLSProblemSite ( socketInfo ) ;
printf ( "DEVNAME = % s\n" , devname ) ; <NEW_LINE> fputs ( name , stdout ) ; <NEW_LINE> fputs ( " = " , stdout ) ; <NEW_LINE> <START_VULN> safe_print ( value , valsz , NULL ) ; <NEW_LINE> <END_VULN> fputs ( "\n" , stdout ) ; <NEW_LINE> } else {
img -> img_data = img_data ; <NEW_LINE> if ( ! img_data ) { <NEW_LINE> <START_VULN> img -> img_data = img_buf_memalign ( buf_align , ( ( fmt & VPX_IMG_FMT_PLANAR ) ? <NEW_LINE>h * s * bps / 8 : h * s ) ) ; <NEW_LINE> <END_VULN> img -> img_data_owner = 1 ; <NEW_LINE> }
js::InitialShapeSet initialShapes ; <NEW_LINE> void sweepInitialShapeTable ( ) ; <NEW_LINE> js::types::TypeObjectSet newTypeObjects ; <NEW_LINE> js::types::TypeObjectSet lazyTypeObjects ; <NEW_LINE> void sweepNewTypeObjectTable ( js::types::TypeObjectSet & table ) ; <NEW_LINE> <START_VULN> js::types::TypeObject * emptyTypeObject ; <NEW_LINE> <END_VULN> inline js::types::TypeObject * getEmptyType ( JSContext * cx ) ; <NEW_LINE> js::types::TypeObject * getLazyType ( JSContext * cx , JSObject * proto ) ;
~ BrowserDevToolsAgentHost ( ) override ; <NEW_LINE> <START_VULN> void AttachSession ( DevToolsSession * session ) override ; <NEW_LINE> <END_VULN> void DetachSession ( DevToolsSession * session ) override ; <NEW_LINE> void DispatchProtocolMessage ( DevToolsSession * session , <NEW_LINE> const std::string & message ) override ;
0xc8 , 0xeb , 0xbb , 0x3c , 0x83 , 0x53 , 0x99 , 0x61 , <NEW_LINE> 0x17 , 0x2b , 0x04 , 0x7e , 0xba , 0x77 , 0xd6 , 0x26 , <NEW_LINE> 0xe1 , 0x69 , 0x14 , 0x63 , 0x55 , 0x21 , 0x0c , 0x7d <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> } ; <NEW_LINE> #define decT dec_tables . T
int errCode = SSL_ERROR_RX_MALFORMED_CERTIFICATE ; <NEW_LINE> SECItem certItem ; <NEW_LINE> SSL_TRC ( 3 , ( " % d: SSL3 [ % d ] : handle certificate handshake" , <NEW_LINE> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> <START_VULN> if ( ( ss -> ssl3 . hs . ws != wait_server_cert ) && <NEW_LINE> ( ss -> ssl3 . hs . ws != wait_client_cert ) ) { <NEW_LINE>desc = unexpected_message ; <NEW_LINE>errCode = SSL_ERROR_RX_UNEXPECTED_CERTIFICATE ; <NEW_LINE>goto alert_loser ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ss -> sec . peerCert != NULL ) { <NEW_LINE> if ( ss -> sec . peerKey ) { <NEW_LINE> SECKEY_DestroyPublicKey ( ss -> sec . peerKey ) ; <NEW_LINE> ss -> sec . peerKey = NULL ; <NEW_LINE> } <NEW_LINE> CERT_DestroyCertificate ( ss -> sec . peerCert ) ;
return GSS_S_DEFECTIVE_TOKEN ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( header -> buffer . length < token_wrapper_len + 14 ) { <NEW_LINE> <END_VULN> * minor_status = 0 ; <NEW_LINE> return GSS_S_DEFECTIVE_TOKEN ; <NEW_LINE> } <NEW_LINE> commit e6ae703ae597d798e310368d52b8f38ee11c6a73 <NEW_LINE> Author: Greg Hudson < ghudson@mit . edu > <NEW_LINE> Date: Thu Jun 19 13:49:16 2014 - 0400 <NEW_LINE> Handle invalid RFC 1964 tokens [ CVE - 2014 - 4341 . . . ] <NEW_LINE> Detect the following cases which would otherwise cause invalid memory <NEW_LINE> accesses and / or integer underflow: <NEW_LINE> [ CVE - 2014 - 4342 ] <NEW_LINE> incomplete checksum [ CVE - 2014 - 4341 CVE - 2014 - 4342 ] <NEW_LINE> If we detect a bad pad byte , continue on to compute the checksum to <NEW_LINE> avoid creating a padding oracle , but treat the checksum as invalid <NEW_LINE> even if it compares equal . <NEW_LINE> CVE - 2014 - 4341: <NEW_LINE> In MIT krb5 , an unauthenticated remote attacker with the ability to <NEW_LINE> inject packets into a legitimately established GSSAPI application <NEW_LINE> session can cause a program crash due to invalid memory references <NEW_LINE> when attempting to read beyond the end of a buffer . <NEW_LINE>
accum = ( accum << 6 ) | value ; <NEW_LINE> if ( ( ( i + 1 ) % 4 ) == 0 ) { <NEW_LINE> <START_VULN> out [ j ++ ] = ( accum >> 16 ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( j < outLen ) { out [ j ++ ] = ( accum >> 8 ) & 0xff ; } <NEW_LINE> if ( j < outLen ) { out [ j ++ ] = accum & 0xff ; }
nsresult SaveSelection ( nsISelection * aSel ) ; <NEW_LINE> nsresult RestoreSelection ( nsISelection * aSel ) ; <NEW_LINE> bool IsCollapsed ( ) ; <NEW_LINE> bool IsEqual ( nsSelectionState * aSelState ) ; <NEW_LINE> void MakeEmpty ( ) ; <NEW_LINE> bool IsEmpty ( ) ; <NEW_LINE> protected: <NEW_LINE> <START_VULN> nsTArray < nsRangeStore > mArray ; <NEW_LINE> <END_VULN> friend class nsRangeUpdater ; <NEW_LINE> } ; <NEW_LINE> class nsRangeUpdater <NEW_LINE> { <NEW_LINE> public:
JSFunctionSpec * fs ; <NEW_LINE> JSObject * tmp ; <NEW_LINE> JSFastNative native ; <NEW_LINE> if ( ! JS_GetReservedSlot ( cx , JSVAL_TO_OBJECT ( * vp ) , 0 , & fsv ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> fs = ( JSFunctionSpec * ) JSVAL_TO_PRIVATE ( fsv ) ; <NEW_LINE> JS_ASSERT ( ( ~ fs -> flags & ( JSFUN_FAST_NATIVE | JSFUN_GENERIC_NATIVE ) ) == 0 ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( JSVAL_IS_PRIMITIVE ( vp [ 2 ] ) ) { <NEW_LINE> if ( ! js_ValueToObject ( cx , vp [ 2 ] , & tmp ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> vp [ 2 ] = OBJECT_TO_JSVAL ( tmp ) ; <NEW_LINE> }
PRINTING_EXPORT extern const char kIsFirstRequest [ ] ; <NEW_LINE> PRINTING_EXPORT extern const char kPreviewRequestID [ ] ; <NEW_LINE> <START_VULN> PRINTING_EXPORT extern const char kPreviewUIAddr [ ] ; <NEW_LINE> <END_VULN> PRINTING_EXPORT extern const char kSettingCloudPrintId [ ] ; <NEW_LINE> PRINTING_EXPORT extern const char kSettingCloudPrintDialog [ ] ; <NEW_LINE> PRINTING_EXPORT extern const char kSettingCollate [ ] ;
} <NEW_LINE> uint64 EbmlElementSize ( uint64 type , int64 value ) { <NEW_LINE> <START_VULN> return EbmlElementSize ( type , static_cast < uint64 > ( value ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> uint64 EbmlElementSize ( uint64 type , uint64 value ) {
~ ServiceWorkerHandler ( ) override ; <NEW_LINE> void Wire ( UberDispatcher * dispatcher ) override ; <NEW_LINE> <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) override ; <NEW_LINE> Response Enable ( ) override ;
{ <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeContentView::IsEditable ( PRInt32 aRow , nsITreeColumn * aCol , PRBool * _retval ) <NEW_LINE> { <NEW_LINE> * _retval = PR_FALSE ; <NEW_LINE> <START_VULN> NS_ENSURE_ARG_POINTER ( aCol ) ; <NEW_LINE> <END_VULN> NS_PRECONDITION ( aRow >= 0 && aRow < PRInt32 ( mRows . Length ( ) ) , "bad row" ) ; <NEW_LINE> if ( aRow < 0 || aRow >= PRInt32 ( mRows . Length ( ) ) ) <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> * _retval = PR_TRUE ; <NEW_LINE> Row * row = mRows [ aRow ] ;
Rect <NEW_LINE> PathCG::GetBounds ( const Matrix & aTransform ) const <NEW_LINE> { <NEW_LINE> Rect bounds = CGRectToRect ( CGPathGetBoundingBox ( mPath ) ) ; <NEW_LINE> <START_VULN> if ( ! bounds . IsFinite ( ) ) { <NEW_LINE>return Rect ( ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> return aTransform . TransformBounds ( bounds ) ; <NEW_LINE> } <NEW_LINE> Rect <NEW_LINE> PathCG::GetStrokedBounds ( const StrokeOptions & aStrokeOptions , <NEW_LINE> const Matrix & aTransform ) const <NEW_LINE> {
if ( option != ( const char * ) NULL ) <NEW_LINE> if ( AcquireImageColormap ( image , StringToUnsignedLong ( option ) ) == MagickFalse ) <NEW_LINE> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <START_VULN> if ( ( jpeg_info . output_components == 1 ) && <NEW_LINE> ( jpeg_info . quantize_colors == 0 ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> size_t <NEW_LINE> colors ;
<START_VULN> Microtask::performCheckpoint ( ) ; <NEW_LINE> <END_VULN> if ( RefPtrWillBeRawPtr < LocalFrame > frame = this -> frame ( ) ) {
break ; <NEW_LINE> case 'w' : <NEW_LINE> <START_VULN> fd = open ( filename , O_WRONLY | O_TRUNC | O_CREAT | O_LARGEFILE | O_BINARY , 0666 ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 's' :
LINKADDR_ETHER , <NEW_LINE> LINKADDR_FRELAY , <NEW_LINE> LINKADDR_IEEE1394 , <NEW_LINE> <START_VULN> LINKADDR_ATM <NEW_LINE> <END_VULN> } ; <NEW_LINE> #define BUFSIZE 128
if ( plugin_data ) { <NEW_LINE> mnd_efree ( plugin_data ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ret == PASS ) { <NEW_LINE> DBG_INF_FMT ( "saving requested_protocol = % s" , requested_protocol ) ; <NEW_LINE> conn -> m -> set_client_option ( conn , MYSQLND_OPT_AUTH_PROTOCOL , requested_protocol TSRMLS_CC ) ;
if ( ! res . mSurface ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> <START_VULN> CanvasUtils::DoDrawImageSecurityCheck ( mCanvasElement , res . mPrincipal , res . mIsWriteOnly ) ; <NEW_LINE> <END_VULN> if ( res . mSurface -> GetType ( ) != gfxASurface::SurfaceTypeImage ) {
random_32 ( void ) <NEW_LINE> { <NEW_LINE> <START_VULN> for ( ; ; ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_byte mark [ 4 ] ; <NEW_LINE> png_uint_32 result ;
payload_size += EbmlElementSize ( kMkvChapCountry , country_ ) ; <NEW_LINE> const uint64 display_size = <NEW_LINE> <START_VULN> EbmlMasterElementSize ( kMkvChapterDisplay , payload_size ) + <NEW_LINE>payload_size ; <NEW_LINE> <END_VULN> if ( writer == NULL ) <NEW_LINE> return display_size ;
} ; <NEW_LINE> DeadResourceStatsRecorder dead_stats_recorder_ ; <NEW_LINE> <START_VULN> std::unique_ptr < HashSet < String >> preloaded_ur_ls_for_test_ ; <NEW_LINE> <END_VULN> bool auto_load_images_ : 1 ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> static void filter_selectively_vert_row2 ( PLANE_TYPE plane_type , <NEW_LINE> <END_VULN> uint8_t * s , int pitch , <NEW_LINE> unsigned int mask_16x16_l , <NEW_LINE> unsigned int mask_8x8_l ,
<START_VULN> static void _php_mb_regex_globals_dtor ( zend_mb_regex_globals * pglobals TSRMLS_DC ) <NEW_LINE> <END_VULN> { <NEW_LINE> zend_hash_destroy ( & pglobals -> ht_rc ) ; <NEW_LINE> }
virtual void TabClosingAt ( TabStripModel * tab_strip_model , <NEW_LINE> content::WebContents * contents , <NEW_LINE> int index ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void TabDetachedAt ( TabContents * contents , int index ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual void TabDeactivated ( TabContents * contents ) OVERRIDE ; <NEW_LINE> virtual void ActiveTabChanged ( TabContents * old_contents , <NEW_LINE> TabContents * new_contents ,
exit ( 1 ) ; <NEW_LINE> } <NEW_LINE> for ( i = 0 ; i < TESTSIZE ; i ++ ) <NEW_LINE> if ( fabs ( qv [ i ] - iv [ i ] ) > . 000001 ) { <NEW_LINE> fprintf ( stderr , "read ( % g ) != written ( % g ) at position ( % ld ) \n" , <NEW_LINE> iv [ i ] , qv [ i ] , i ) ; <NEW_LINE> exit ( 1 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> fprintf ( stderr , "OK\n" ) ; <NEW_LINE> ptr ++ ; <NEW_LINE> } <NEW_LINE> exit ( 0 ) ; <NEW_LINE> }
if ( mPluginFrame && mPluginWindow && <NEW_LINE> mPluginWindow -> type == NPWindowTypeDrawable ) { <NEW_LINE> nsIFocusManager * fm = nsFocusManager::GetFocusManager ( ) ; <NEW_LINE> if ( fm ) { <NEW_LINE> <START_VULN> nsCOMPtr < nsIDOMElement > elem = do_QueryInterface ( mContent ) ; <NEW_LINE> <END_VULN> fm -> SetFocus ( elem , 0 ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> WidgetMouseEvent * mouseEvent = <NEW_LINE> aMouseEvent -> GetInternalNSEvent ( ) -> AsMouseEvent ( ) ; <NEW_LINE> if ( mouseEvent && mouseEvent -> mClass == eMouseEventClass ) { <NEW_LINE> mLastMouseDownButtonType = mouseEvent -> button ;
{ <NEW_LINE> public: <NEW_LINE> static JSBool GetCallingLocation ( JSContext * aContext , const char * * aFilename , <NEW_LINE> <START_VULN> PRUint32 * aLineno ) ; <NEW_LINE> <END_VULN> static jsval ConvertStringToJSVal ( const nsString & aProp , <NEW_LINE> JSContext * aContext ) ;
ArrayBufferViewObject * viewListHead = GetViewList ( this ) ; <NEW_LINE> uintptr_t newDataPointer = uintptr_t ( newHeader -> elements ( ) ) ; <NEW_LINE> for ( ArrayBufferViewObject * view = viewListHead ; view ; view = view -> nextView ( ) ) { <NEW_LINE> <START_VULN> uint8_t * viewDataPointer = static_cast < uint8_t * > ( view -> getPrivate ( ) ) ; <NEW_LINE> <END_VULN> if ( viewDataPointer ) { <NEW_LINE> viewDataPointer += newDataPointer - oldDataPointer ; <NEW_LINE> view -> setPrivate ( viewDataPointer ) ; <NEW_LINE> } <NEW_LINE> MarkObjectStateChange ( cx , view ) ; <NEW_LINE> }
<START_VULN> <NEW_LINE> <END_VULN> #include < stdio . h > <NEW_LINE> #include < r_types . h >
return ( 0 ) ; <NEW_LINE> } <NEW_LINE> if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { <NEW_LINE> <START_VULN> if ( count >= 4 ) { <NEW_LINE> <END_VULN> int retTIFFReadRawTile ; <NEW_LINE> _TIFFmemcpy ( buffer , jpt , count - 2 ) ;
} else { <NEW_LINE> out_string ( c , "ERROR" ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> } else if ( strcmp ( tokens [ 1 ] . value , "temp_ttl" ) == 0 && ntokens >= 3 && <NEW_LINE> <END_VULN> settings . lru_maintainer_thread ) { <NEW_LINE> if ( ! safe_strtol ( tokens [ 2 ] . value , & ttl ) ) { <NEW_LINE> out_string ( c , "ERROR" ) ;
virtual ~ RenderWidgetHostViewAura ( ) ; <NEW_LINE> void UpdateCursorIfOverSelf ( ) ; <NEW_LINE> <START_VULN> bool ShouldFastACK ( uint64 surface_id ) ; <NEW_LINE> <END_VULN> void UpdateExternalTexture ( ) ; <NEW_LINE> ui::InputMethod * GetInputMethod ( ) const ;
* <NEW_LINE> SVGNumberList & InternalList ( ) const ; <NEW_LINE> <START_VULN> void EnsureItemAt ( uint32_t aIndex ) ; <NEW_LINE> <END_VULN> void MaybeInsertNullInAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> void MaybeRemoveItemFromAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> FallibleTArray < DOMSVGNumber * > mItems ;
<START_VULN> if ( mPreviousViewer ) <NEW_LINE>mPreviousViewer -> SetBounds ( aBounds ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> DocumentViewerImpl::Move ( int32_t aX , int32_t aY ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_TRUE ( mDocument , NS_ERROR_NOT_AVAILABLE ) ;
NS_IMETHOD_ ( void ) NoteJSRoot ( void * root ) { } <NEW_LINE> NS_IMETHOD_ ( void ) NoteNativeRoot ( void * root , <NEW_LINE> nsCycleCollectionParticipant * participant ) { } <NEW_LINE> NS_IMETHOD_ ( void ) NoteXPCOMChild ( nsISupports * child ) { } <NEW_LINE> NS_IMETHOD_ ( void ) NoteJSChild ( void * child ) { } <NEW_LINE> NS_IMETHOD_ ( void ) NoteNativeChild ( void * child , <NEW_LINE> nsCycleCollectionParticipant * participant ) { } <NEW_LINE> NS_IMETHOD_ ( void ) NoteNextEdgeName ( const char * name ) { } <NEW_LINE> <START_VULN> NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * val ) { } <NEW_LINE> <END_VULN> } ; <NEW_LINE> char * Suppressor::sSuppressionList = nullptr ; <NEW_LINE> bool Suppressor::sInitialized = false ; <NEW_LINE> static bool <NEW_LINE> nsCycleCollector_shouldSuppress ( nsISupports * s ) <NEW_LINE> {
void WalkRules ( nsIStyleRuleProcessor::EnumFunc aFunc , void * aData ) ; <NEW_LINE> nsINodeList * GetAnonymousNodes ( ) ; <NEW_LINE> static nsresult DoInitJSClass ( JSContext * cx , JSObject * global , JSObject * obj , <NEW_LINE> const nsAFlatCString & aClassName , <NEW_LINE> nsXBLPrototypeBinding * aProtoBinding , <NEW_LINE> <START_VULN> JSObject ** aClassObject ) ; <NEW_LINE> <END_VULN> bool AllowScripts ( ) ; <NEW_LINE> void RemoveInsertionParent ( nsIContent * aParent ) ; <NEW_LINE> bool HasInsertionParent ( nsIContent * aParent ) ; <NEW_LINE> protected:
si -> h = ( clear [ 8 ] | ( clear [ 9 ] << 8 ) ) & 0x3fff ; <NEW_LINE> <START_VULN> if ( ! ( si -> h | si -> w ) ) <NEW_LINE>res = VPX_CODEC_UNSUP_BITSTREAM ; <NEW_LINE> <END_VULN> } <NEW_LINE> else <NEW_LINE> {
ps_dec -> u2_cur_slice_num = 0 ; <NEW_LINE> ps_dec -> cur_dec_mb_num = 0 ; <NEW_LINE> ps_dec -> cur_recon_mb_num = 0 ; <NEW_LINE> <START_VULN> ps_dec -> u4_first_slice_in_pic = 2 ; <NEW_LINE> <END_VULN> ps_dec -> u1_first_pb_nal_in_pic = 1 ; <NEW_LINE> ps_dec -> u1_slice_header_done = 0 ; <NEW_LINE> ps_dec -> u1_dangling_field = 0 ;
struct TypedArrayObjectStorage : AllTypedArraysBase { <NEW_LINE> protected: <NEW_LINE> JSObject * mObj ; <NEW_LINE> <START_VULN> TypedArrayObjectStorage ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> explicit TypedArrayObjectStorage ( TypedArrayObjectStorage && aOther ) <NEW_LINE> : mObj ( aOther . mObj ) <NEW_LINE> { <NEW_LINE> aOther . mObj = nullptr ; <NEW_LINE> }
if ( ConstructorMode::current ( ) == ConstructorMode::WrapExistingObject ) <NEW_LINE> return args . Holder ( ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> if ( args . Length ( ) <= 0 || ! args [ 0 ] -> IsFunction ( ) ) <NEW_LINE> return throwError ( TYPE_MISMATCH_ERR , args . GetIsolate ( ) ) ; <NEW_LINE> RefPtr < TestCallback > testCallback = V8TestCallback::create ( args [ 0 ] , getScriptExecutionContext ( ) ) ;
void RenderSVGModelObject::styleDidChange ( StyleDifference diff , const RenderStyle * oldStyle ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( diff == StyleDifferenceLayout ) { <NEW_LINE> <END_VULN> setNeedsBoundariesUpdate ( ) ; <NEW_LINE> if ( style ( ) -> hasTransform ( ) ) <NEW_LINE> setNeedsTransformUpdate ( ) ;
SPL_METHOD ( SplFileObject , next ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
<START_VULN> if ( allowed ) <NEW_LINE> <END_VULN> png_ptr -> flags |= PNG_FLAG_BENIGN_ERRORS_WARN | <NEW_LINE> PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN ;
EXPECT_TRUE ( this -> SetCanonicalCookie ( <NEW_LINE> cs , <NEW_LINE> <START_VULN> base::MakeUnique < CanonicalCookie > ( <NEW_LINE> <END_VULN> "A" , "B" , foo_foo_host , " / foo" , one_hour_ago , one_hour_from_now , <NEW_LINE> base::Time ( ) , false , false , <NEW_LINE> CookieSameSite::DEFAULT_MODE , COOKIE_PRIORITY_DEFAULT ) ,
break ; <NEW_LINE> } <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int pimv2_addr_len ; <NEW_LINE><NEW_LINE> <END_VULN> enum pimv2_addrtype { <NEW_LINE> pimv2_unicast , pimv2_group , pimv2_source <NEW_LINE> } ;
if ( ! mAppStatusCache . Get ( sourceOrigin , & status ) ) { <NEW_LINE> aRequestPrincipal -> GetAppStatus ( & status ) ; <NEW_LINE> mAppStatusCache . Put ( sourceOrigin , status ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( status == nsIPrincipal::APP_STATUS_CERTIFIED ) { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> switch ( aContentType ) { <NEW_LINE> case nsIContentPolicy::TYPE_SCRIPT:
size_t TreeMemoryUsageInBytes ( ) const ; <NEW_LINE> private: <NEW_LINE> <START_VULN> EffectPaintPropertyNode ( scoped_refptr < const EffectPaintPropertyNode > parent , <NEW_LINE>State && state ) <NEW_LINE>: PaintPropertyNode ( std::move ( parent ) ) , state_ ( std::move ( state ) ) { } <NEW_LINE> <END_VULN> State state_ ; <NEW_LINE> } ;
guint curr_len ; <NEW_LINE> <START_VULN> memset ( str , 0 , MAX_APN_LENGTH ) ; <NEW_LINE> <END_VULN> tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length:MAX_APN_LENGTH ) ; <NEW_LINE> curr_len = 0 ;
<START_VULN> l_tile -> x0 = opj_int_max ( ( OPJ_INT32 ) ( l_cp -> tx0 + p * l_cp -> tdx ) , ( OPJ_INT32 ) l_image -> x0 ) ; <NEW_LINE>l_tile -> y0 = opj_int_max ( ( OPJ_INT32 ) ( l_cp -> ty0 + q * l_cp -> tdy ) , ( OPJ_INT32 ) l_image -> y0 ) ; <NEW_LINE>l_tile -> x1 = opj_int_min ( ( OPJ_INT32 ) ( l_cp -> tx0 + ( p + 1 ) * l_cp -> tdx ) , ( OPJ_INT32 ) l_image -> x1 ) ; <NEW_LINE>l_tile -> y1 = opj_int_min ( ( OPJ_INT32 ) ( l_cp -> ty0 + ( q + 1 ) * l_cp -> tdy ) , ( OPJ_INT32 ) l_image -> y1 ) ; <NEW_LINE> <END_VULN> if ( l_tccp -> numresolutions == 0 ) { <NEW_LINE> fprintf ( stderr , "tiles require at least one resolution\n" ) ;
! ( ctx -> iface -> caps & VPX_CODEC_CAP_EXTERNAL_FRAME_BUFFER ) ) { <NEW_LINE> res = VPX_CODEC_ERROR ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> res = ctx -> iface -> dec . set_fb_fn ( ctx -> priv -> alg_priv , cb_get , cb_release , <NEW_LINE> <END_VULN> cb_priv ) ; <NEW_LINE> }
} <NEW_LINE> } else if ( ( ctxt -> internalized ) && ( target != NULL ) && <NEW_LINE> ( target -> doc != NULL ) && <NEW_LINE> <START_VULN> ( target -> doc -> dict == ctxt -> dict ) ) { <NEW_LINE> <END_VULN> text -> content = ( xmlChar * ) value ; <NEW_LINE> } else { <NEW_LINE> text -> content = xmlStrdup ( value ) ;
if ( data && ( stack = data -> GetJSContextStack ( ) ) ) { <NEW_LINE> if ( ! stack -> Push ( sandcx -> GetJSContext ( ) ) ) { <NEW_LINE> JS_ReportError ( cx , <NEW_LINE> "Unable to initialize XPConnect with the sandbox context" ) ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> rv = NS_OK ; <NEW_LINE> <END_VULN> { <NEW_LINE> JSAutoRequest req ( sandcx -> GetJSContext ( ) ) ; <NEW_LINE> JSAutoEnterCompartment ac ; <NEW_LINE> if ( ! ac . enter ( sandcx -> GetJSContext ( ) , sandbox ) ) { <NEW_LINE> if ( stack ) <NEW_LINE> unused << stack -> Pop ( ) ;
virtual void setTextFromItem ( unsigned listIndex ) = 0 ; <NEW_LINE> virtual void listBoxSelectItem ( int , bool , bool , bool = true ) { ASSERT_NOT_REACHED ( ) ; } <NEW_LINE> <START_VULN> virtual bool multiple ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> ASSERT_NOT_REACHED ( ) ; <NEW_LINE> return false ;
ZVAL_STRINGL ( * rval , str , len , 0 ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 917 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy46: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych == ' + ' ) goto yy47 ;
} ; <NEW_LINE> <START_VULN> const vp9_tree_index vp9_intra_mode_tree [ TREE_SIZE ( INTRA_MODES ) ] = { <NEW_LINE> <END_VULN> - DC_PRED , 2 , <NEW_LINE> - TM_PRED , 4 , <NEW_LINE> - V_PRED , 6 ,
char * delim = NULL , * enclo = NULL , * esc = NULL ; <NEW_LINE> int d_len = 0 , e_len = 0 , esc_len = 0 , ret ; <NEW_LINE> zval * fields = NULL ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "a | sss" , & fields , & delim , & d_len , & enclo , & e_len , & esc , & esc_len ) == SUCCESS ) { <NEW_LINE> switch ( ZEND_NUM_ARGS ( ) ) <NEW_LINE> {
seg -> feature_data [ segment_id ] [ feature_id ] = seg_data ; <NEW_LINE> } <NEW_LINE> <START_VULN> int vp9_get_segdata ( const struct segmentation * seg , int segment_id , <NEW_LINE>SEG_LVL_FEATURES feature_id ) { <NEW_LINE>return seg -> feature_data [ segment_id ] [ feature_id ] ; <NEW_LINE> } <NEW_LINE><NEW_LINE><NEW_LINE>const vp9_tree_index vp9_segment_tree [ TREE_SIZE ( MAX_SEGMENTS ) ] = { <NEW_LINE> <END_VULN> 2 , 4 , 6 , 8 , 10 , 12 , <NEW_LINE> 0 , - 1 , - 2 , - 3 , - 4 , - 5 , - 6 , - 7 <NEW_LINE> } ;
src_weight = gdAlphaTransparent - src_alpha ; <NEW_LINE> dst_weight = ( gdAlphaTransparent - dst_alpha ) * src_alpha / gdAlphaMax ; <NEW_LINE> tot_weight = src_weight + dst_weight ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
inline unsigned blend ( unsigned from , unsigned to , double progress ) <NEW_LINE> { <NEW_LINE> <START_VULN> return static_cast < unsigned > ( lround ( static_cast < double > ( from ) + static_cast < double > ( to - from ) * progress ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> inline double blend ( double from , double to , double progress )
#include "chrome / common / notification_registrar . h" <NEW_LINE> class Extension ; <NEW_LINE> <START_VULN> class FindManager ; <NEW_LINE> <END_VULN> class NavigationController ; <NEW_LINE> class PasswordManager ; <NEW_LINE> class PasswordManagerDelegate ;
<START_VULN> if ( output_format & PNG_FORMAT_FLAG_ALPHA ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_uint_32 r ;
flags &= ~ 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( flags & 2 ) { <NEW_LINE> <END_VULN>
for ( y = 0 ; y < h ; ++ y ) <NEW_LINE> { <NEW_LINE> <START_VULN> png_const_bytep PNG_CONST pRow = store_image_row ( ps , pp , 0 , y ) ; <NEW_LINE> <END_VULN> png_uint_32 x ;
static char * getPreferredTag ( const char * gf_tag ) <NEW_LINE> <START_VULN> { <NEW_LINE> <END_VULN> char * result = NULL ; <NEW_LINE> int grOffset = 0 ;
template < typename PaintPropertyNode > <NEW_LINE> <START_VULN> bool Clear ( scoped_refptr < PaintPropertyNode > & field ) { <NEW_LINE> <END_VULN> if ( field ) { <NEW_LINE> field = nullptr ; <NEW_LINE> return true ;
} else { <NEW_LINE> pn = UnaryNode::create ( tc ) ; <NEW_LINE> if ( pn ) { <NEW_LINE> pn -> pn_kid = assignExpr ( ) ; <NEW_LINE> if ( ! pn -> pn_kid ) { <NEW_LINE> pn = NULL ; <NEW_LINE> } else { <NEW_LINE> if ( tc -> flags & TCF_FUN_IS_GENERATOR ) { <NEW_LINE> <START_VULN> ReportBadReturn ( context , tc , JSREPORT_ERROR , <NEW_LINE> <END_VULN> JSMSG_BAD_GENERATOR_RETURN , <NEW_LINE> JSMSG_BAD_ANON_GENERATOR_RETURN ) ; <NEW_LINE> pn = NULL ; <NEW_LINE> } else { <NEW_LINE> pn -> pn_type = TOK_RETURN ; <NEW_LINE> pn -> pn_op = JSOP_RETURN ; <NEW_LINE> pn -> pn_pos . end = pn -> pn_kid -> pn_pos . end ; <NEW_LINE> }
# endif <NEW_LINE> #else <NEW_LINE> PNG_UNUSED ( output_flush_fn ) <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_READ_SUPPORTED
<START_VULN> { <NEW_LINE> <END_VULN> long bp = _ve_envelope_search ( v ) ; <NEW_LINE> if ( bp == - 1 ) { <NEW_LINE> if ( v -> eofflag == 0 ) return ( 0 ) ; <NEW_LINE> v -> nW = 0 ; <NEW_LINE> } else {
size_t CacheMemoryUsageInBytes ( ) const ; <NEW_LINE> private: <NEW_LINE> <START_VULN> ClipPaintPropertyNode ( scoped_refptr < const ClipPaintPropertyNode > parent , <NEW_LINE>State && state ) <NEW_LINE>: PaintPropertyNode ( std::move ( parent ) ) , state_ ( std::move ( state ) ) { } <NEW_LINE> <END_VULN> friend class GeometryMapper ;
<START_VULN> output . SetLength ( inputLen ) ; <NEW_LINE> <END_VULN> nsAString::iterator out_iter ; <NEW_LINE> output . BeginWriting ( out_iter ) ;
{ <NEW_LINE> if ( ms ) <NEW_LINE> { <NEW_LINE> <START_VULN> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <NEW_LINE> <END_VULN> if ( nestsize == 0 && ms -> nest_level == 0 ) <NEW_LINE> nestsize = ms -> buffer_size_longs ;
{ <NEW_LINE> NS_ABORT_IF_FALSE ( ! IsAnimValList ( ) , "call from baseVal to animVal" ) ; <NEW_LINE> if ( AttrIsAnimating ( ) ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> DOMSVGPathSegList * animVal = <NEW_LINE> <END_VULN> GetDOMWrapperIfExists ( InternalAList ( ) . GetAnimValKey ( ) ) ; <NEW_LINE> if ( ! animVal ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> NS_ABORT_IF_FALSE ( animVal -> mItems . Length ( ) == mItems . Length ( ) , <NEW_LINE> "animVal list not in sync ! " ) ;
* aProxyInfo = ProxyInfo ( ) ; <NEW_LINE> NS_IF_ADDREF ( * aProxyInfo ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> <START_VULN> nsFtpChannel::OpenContentStream ( PRBool async , nsIInputStream ** result ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ! async ) <NEW_LINE> return NS_ERROR_NOT_IMPLEMENTED ; <NEW_LINE> nsFtpState * state = new nsFtpState ( ) ; <NEW_LINE> if ( ! state ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> NS_ADDREF ( state ) ;
mojom::SensorType type ) ; <NEW_LINE> void SensorReaderCreated ( <NEW_LINE> mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> const CreateSensorCallback & callback , <NEW_LINE> std::unique_ptr < PlatformSensorReaderWin > sensor_reader ) ;
nsCanvasPattern * pattern = CurrentState ( ) . patternStyles [ aWhichStyle ] ; <NEW_LINE> if ( pattern ) { <NEW_LINE> if ( mCanvasElement ) <NEW_LINE> <START_VULN> CanvasUtils::DoDrawImageSecurityCheck ( mCanvasElement , <NEW_LINE> <END_VULN> pattern -> Principal ( ) , <NEW_LINE> pattern -> GetForceWriteOnly ( ) ) ;
int max_pending_send_allowed_ ; <NEW_LINE> <START_VULN> base::WeakPtr < URLRequestContext > context_ ; <NEW_LINE> <END_VULN> UserDataMap user_data_ ;
SPL_METHOD ( SplFileObject , rewind ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
TEST ( GIFImageDecoderTest , progressiveDecode ) <NEW_LINE> { <NEW_LINE> <START_VULN> RefPtr < SharedBuffer > fullData = readFile ( " / Source / web / tests / data / radient . gif" ) ; <NEW_LINE> <END_VULN> ASSERT_TRUE ( fullData . get ( ) ) ; <NEW_LINE> const size_t fullLength = fullData -> size ( ) ;
encode_frame ( & codec , & raw , frame_count , writer ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> encode_frame ( & codec , NULL , - 1 , writer ) ; <NEW_LINE> <END_VULN> printf ( "\n" ) ; <NEW_LINE> fclose ( infile ) ; <NEW_LINE> printf ( "Processed % d frames . \n" , frame_count ) ;
} \ <NEW_LINE> <START_VULN> #line 106 "re_grammar . c" <NEW_LINE> <END_VULN> # ifndef YY_NULLPTR <NEW_LINE> # if defined __cplusplus && 201103L <= __cplusplus
png_uint_32 width , height ; <NEW_LINE> int bit_depth , color_type , interlace_type , compression_type , filter_type ; <NEW_LINE> <START_VULN> int channels ; <NEW_LINE> <END_VULN> double aGamma ; <NEW_LINE> png_bytep trans = NULL ;
offset += 3 ; <NEW_LINE> length - = 3 ; <NEW_LINE> <START_VULN> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <NEW_LINE> <END_VULN> offset += tim . length - 3 ; <NEW_LINE> length - = tim . length - 3 ;
break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> SSL_AtomicIncrementLong ( & ssl3stats . hsh_sid_cache_hits ) ; <NEW_LINE> <START_VULN> if ( sid -> version > SSL_LIBRARY_VERSION_3_0 && <NEW_LINE>sid -> u . ssl3 . sessionTicket . ticket . data != NULL ) <NEW_LINE> <END_VULN> SSL_AtomicIncrementLong ( & ssl3stats . hsh_sid_stateless_resumes ) ; <NEW_LINE> if ( ssl3_ExtensionNegotiated ( ss , ssl_session_ticket_xtn ) ) <NEW_LINE> ss -> ssl3 . hs . ws = wait_new_session_ticket ; <NEW_LINE> else <NEW_LINE> ss -> ssl3 . hs . ws = wait_change_cipher ; <NEW_LINE> ss -> ssl3 . hs . isResuming = PR_TRUE ;
<START_VULN> if ( keep ) <NEW_LINE> <END_VULN> { <NEW_LINE> new_list = png_voidcast ( png_bytep , png_malloc ( png_ptr , <NEW_LINE> 5 * ( num_chunks + old_num_chunks ) ) ) ;
1 , 43 , <NEW_LINE> - 1 , 44 , - 1 , 45 , - 1 , 46 , - 1 , 26 , - 1 , 47 , <NEW_LINE> - 1 <NEW_LINE> } ; <NEW_LINE> static const yytype_uint8 yyrline [ ] = <NEW_LINE> { <NEW_LINE> <START_VULN> 0 , 74 , 74 , 76 , 80 , 86 , 90 , 91 , 95 , 96 , <NEW_LINE>99 , 102 , 105 , 108 , 111 , 114 , 116 , 118 , 121 , 122 , <NEW_LINE>123 , 124 , 125 , 129 , 130 , 134 , 138 , 145 , 147 , 149 , <NEW_LINE>153 , 154 , 158 , 165 , 169 , 176 , 179 , 182 , 185 , 188 , <NEW_LINE>194 , 195 , 196 , 197 , 198 , 199 , 200 , 201 , 202 , 203 , <NEW_LINE>204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , <NEW_LINE>214 , 215 , 216 , 217 <NEW_LINE> <END_VULN> } ; <NEW_LINE> #endif <NEW_LINE> #if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE <NEW_LINE> First , the terminals , then , starting at YYNTOKENS ,
#endif <NEW_LINE> <START_VULN> #if __LINE__ != 221437 <NEW_LINE> <END_VULN> #undef SQLITE_SOURCE_ID <NEW_LINE> #define SQLITE_SOURCE_ID "2019 - 02 - 25 16:06:06 bd49a8271d650fa89e446b42e513b595a717b9212c91dd384aab871fc1d0alt2" <NEW_LINE> #endif
outHeader -> nOffset = 0 ; <NEW_LINE> outHeader -> nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof ( int16_t ) ; <NEW_LINE> <START_VULN> memset ( outHeader -> pBuffer , 0 , outHeader -> nFilledLen ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> outHeader -> nFlags = OMX_BUFFERFLAG_EOS ; <NEW_LINE> mSignalledOutputEos = true ;
nsresult Init ( nsIStreamListener * aListener ) ; <NEW_LINE> static nsresult <NEW_LINE> Create ( nsISupports * aOuter , REFNSIID aIID , void ** aResult ) ; <NEW_LINE> protected: <NEW_LINE> void FormatSizeString ( PRInt64 inSize , nsString & outSizeString ) ; <NEW_LINE> <START_VULN> nsresult FormatInputStream ( nsIRequest * aRequest , nsISupports * aContext , const nsAString & aBuffer ) ; <NEW_LINE> <END_VULN> protected: <NEW_LINE> nsCOMPtr < nsIDirIndexParser > mParser ; <NEW_LINE> nsCOMPtr < nsIStreamListener > mListener ; <NEW_LINE> nsCOMPtr < nsIDateTimeFormat > mDateTime ; <NEW_LINE> nsCOMPtr < nsIStringBundle > mBundle ;
<START_VULN> <NEW_LINE> <END_VULN> #include < stdio . h > <NEW_LINE> #include < zlib . h >
if ( cpi -> b_calculate_ssimg ) <NEW_LINE> { <NEW_LINE> double y , u , v , frame_all ; <NEW_LINE> <START_VULN> frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show , <NEW_LINE> <END_VULN> & y , & u , & v ) ; <NEW_LINE> if ( cpi -> oxcf . number_of_layers > 1 )
} <NEW_LINE> return mContext ; <NEW_LINE> } <NEW_LINE> JSObject * <NEW_LINE> nsXULPDGlobalObject::GetGlobalJSObject ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> return mJSObject ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsXULPDGlobalObject::ClearGlobalObjectOwner ( ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( ! mCachedPrincipal , "This shouldn't ever be set until now ! " ) ;
bit , <NEW_LINE> byte , <NEW_LINE> color , <NEW_LINE> <START_VULN> * lastrow , <NEW_LINE> <END_VULN> * one_row , <NEW_LINE> * ptr , <NEW_LINE> version ;
} ; <NEW_LINE> static const uint32_t EUCKRCharLenTable [ ] = { 0 , 1 , 2 , 0 } ; <NEW_LINE> const SMModel EUCKRSMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , EUCKR_cls } , <NEW_LINE> 4 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , EUCKR_st } , <NEW_LINE> <START_VULN> EUCKRCharLenTable , <NEW_LINE> <END_VULN> "EUC - KR" , <NEW_LINE> } ; <NEW_LINE> static const uint32_t EUCTW_cls [ 256 / 8 ] = { <NEW_LINE> PCK4BITS ( 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ) , <NEW_LINE> PCK4BITS ( 2 , 2 , 2 , 2 , 2 , 2 , 0 , 0 ) , <NEW_LINE> PCK4BITS ( 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ) ,
#endif <NEW_LINE> CWD_API void realpath_cache_clean ( void ) ; <NEW_LINE> <START_VULN> CWD_API void realpath_cache_del ( const char * path , int path_len ) ; <NEW_LINE>CWD_API realpath_cache_bucket * realpath_cache_lookup ( const char * path , int path_len , time_t t ) ; <NEW_LINE> <END_VULN> CWD_API zend_long realpath_cache_size ( void ) ; <NEW_LINE> CWD_API zend_long realpath_cache_max_buckets ( void ) ; <NEW_LINE> CWD_API realpath_cache_bucket ** realpath_cache_get_buckets ( void ) ;
active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ; <NEW_LINE> <START_VULN> if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) && <NEW_LINE> ( active_best_quality < cpi -> cq_target_quality ) ) { <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) <NEW_LINE>active_best_quality = oxcf -> cq_level ; <NEW_LINE>else <NEW_LINE>active_best_quality = cpi -> cq_target_quality ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
# define SK_CRASH ( ) __debugbreak ( ) <NEW_LINE> # else <NEW_LINE> # if 1 <NEW_LINE> <START_VULN> # define SK_CRASH ( ) do { SkNO_RETURN_HINT ( ) ; * ( int * ) ( uintptr_t ) 0xbbadbeef = 0 ; } while ( false ) <NEW_LINE> <END_VULN> # else <NEW_LINE> # define SK_CRASH ( ) do { SkNO_RETURN_HINT ( ) ; } while ( true ) <NEW_LINE> # endif
return ; <NEW_LINE> Length h ; <NEW_LINE> <START_VULN> if ( isPositioned ( ) ) <NEW_LINE> <END_VULN> computePositionedLogicalHeight ( ) ; <NEW_LINE> else { <NEW_LINE> RenderBlock * cb = containingBlock ( ) ;
#include "ext / standard / info . h" <NEW_LINE> #include "php_mbregex . h" <NEW_LINE> #include "mbstring . h" <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "php_onig_compat . h" <NEW_LINE> #include < oniguruma . h > <NEW_LINE> #undef UChar
bool AutoplayUmaHelper::shouldRecordUserPausedAutoplayingCrossOriginVideo ( ) <NEW_LINE> const { <NEW_LINE> return m_element -> isInCrossOriginFrame ( ) && m_element -> isHTMLVideoElement ( ) && <NEW_LINE> <START_VULN> m_source != AutoplaySource::NumberOfSources && <NEW_LINE> <END_VULN> ! m_recordedCrossOriginAutoplayResults . count ( <NEW_LINE> CrossOriginAutoplayResult::UserPaused ) ; <NEW_LINE> }
if ( fp < 0 ) <NEW_LINE> <START_VULN> * ascii ++ = 45 , -- size , num = - fp ; <NEW_LINE> <END_VULN> else <NEW_LINE> num = fp ;
} <NEW_LINE> bool deletedGetter = false ; <NEW_LINE> if ( mGetterText && mGetterText -> GetText ( ) ) { <NEW_LINE> nsDependentString getter ( mGetterText -> GetText ( ) ) ; <NEW_LINE> if ( ! getter . IsEmpty ( ) ) { <NEW_LINE> JSObject * getterObject = nullptr ; <NEW_LINE> <START_VULN> JSContext * cx = aContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , aClassObject ) ; <NEW_LINE> JS::CompileOptions options ( cx ) ; <NEW_LINE> options . setFileAndLine ( functionUri . get ( ) , mGetterText -> GetLineNumber ( ) ) <NEW_LINE> . setVersion ( JSVERSION_LATEST ) <NEW_LINE> . setUserBit ( true ) ; <NEW_LINE> nsCString name = NS_LITERAL_CSTRING ( "get_" ) + NS_ConvertUTF16toUTF8 ( mName ) ; <NEW_LINE> js::RootedObject rootedNull ( cx , nullptr ) ;
} <NEW_LINE> mBuffer . AdvanceKnownTracksTime ( GraphTimeToStreamTime ( aTo ) ) ; <NEW_LINE> } <NEW_LINE> protected: <NEW_LINE> struct TrackMapEntry { <NEW_LINE> MediaInputPort * mInputPort ; <NEW_LINE> <START_VULN> StreamBuffer::Track * mInputTrack ; <NEW_LINE>StreamBuffer::Track * mOutputTrack ; <NEW_LINE> <END_VULN> nsAutoPtr < MediaSegment > mSegment ; <NEW_LINE> } ; <NEW_LINE> uint32_t AddTrack ( MediaInputPort * aPort , StreamBuffer::Track * aTrack , <NEW_LINE> GraphTime aFrom ) <NEW_LINE> {
m1 [ i ] = Z_DVAL_PP ( tmp ) ; <NEW_LINE> break ; <NEW_LINE> case IS_STRING: <NEW_LINE> <START_VULN> convert_to_double_ex ( tmp ) ; <NEW_LINE>m1 [ i ] = Z_DVAL_PP ( tmp ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> default: <NEW_LINE> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Invalid type for element % i" , i ) ;
int work_batch_size_ ; <NEW_LINE> <START_VULN> scoped_ptr < TimeSource > time_source_ ; <NEW_LINE> <END_VULN> base::ObserverList < base::MessageLoop::TaskObserver > task_observers_ ;
PRArenaPool * poolp ; <NEW_LINE> poolp = PORT_NewArena ( CRMF_DEFAULT_ARENA_SIZE ) ; <NEW_LINE> if ( poolp == NULL ) { <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> newReqMsg = PORT_ArenaZNew ( poolp , CRMFCertReqMsg ) ; <NEW_LINE> if ( newReqMsg == NULL ) { <NEW_LINE> <START_VULN> goto loser ; <NEW_LINE> <END_VULN> } <NEW_LINE> newReqMsg -> poolp = poolp ; <NEW_LINE> newReqMsg -> certReq = crmf_copy_cert_request ( poolp , srcReqMsg -> certReq ) ; <NEW_LINE> if ( newReqMsg -> certReq == NULL ) { <NEW_LINE> goto loser ; <NEW_LINE> } <NEW_LINE> newReqMsg -> pop = crmf_copy_pop ( poolp , srcReqMsg -> pop ) ;
Permission perm ; <NEW_LINE> if ( ! Policy::check ( cx , wrapper , id , act , perm ) ) { <NEW_LINE> * bp = false ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> * bp = true ; <NEW_LINE> if ( perm == DenyAccess ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> return Base::enter ( cx , wrapper , id , act , bp ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #define SOW FilteringWrapper < CrossCompartmentSecurityWrapper , OnlyIfSubjectIsSystem > <NEW_LINE> #define SCSOW FilteringWrapper < SameCompartmentSecurityWrapper , OnlyIfSubjectIsSystem > <NEW_LINE> #define XOW FilteringWrapper < SecurityXrayXPCWN , CrossOriginAccessiblePropertiesOnly > <NEW_LINE> #define PXOW FilteringWrapper < SecurityXrayProxy , CrossOriginAccessiblePropertiesOnly > <NEW_LINE> #define DXOW FilteringWrapper < SecurityXrayDOM , CrossOriginAccessiblePropertiesOnly > <NEW_LINE> #define NNXOW FilteringWrapper < CrossCompartmentSecurityWrapper , CrossOriginAccessiblePropertiesOnly >
if ( mHasSourceData && mBytesDecoded == mSourceData . Length ( ) ) <NEW_LINE> return NS_OK ; <NEW_LINE> if ( ! mDecoded && ! mInDecoder && mHasSourceData && aDecodeType == SYNCHRONOUS_NOTIFY_AND_SOME_DECODE ) { <NEW_LINE> PROFILER_LABEL_PRINTF ( "RasterImage" , "DecodeABitOf" , " % s" , GetURIString ( ) . get ( ) ) ; <NEW_LINE> <START_VULN> AutoSetSyncDecode syncDecode ( mDecoder ) ; <NEW_LINE>DecodePool::Singleton ( ) -> DecodeABitOf ( this ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> if ( ! mDecoded ) { <NEW_LINE> DecodePool::Singleton ( ) -> RequestDecode ( this ) ;
if ( ! mPlaceHolderBatch ) <NEW_LINE> { <NEW_LINE> BeginUpdateViewBatch ( ) ; <NEW_LINE> mPlaceHolderTxn = nsnull ; <NEW_LINE> mPlaceHolderName = aName ; <NEW_LINE> nsCOMPtr < nsISelection > selection ; <NEW_LINE> nsresult res = GetSelection ( getter_AddRefs ( selection ) ) ; <NEW_LINE> <START_VULN> NS_ENSURE_SUCCESS ( res , res ) ; <NEW_LINE>mSelState = new nsSelectionState ( ) ; <NEW_LINE>NS_ENSURE_TRUE ( mSelState , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE><NEW_LINE>mSelState -> SaveSelection ( selection ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> mPlaceHolderBatch ++ ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsEditor::EndPlaceHolderTransaction ( )
handle_visibility_behavior == kShowSelectionHandle || <NEW_LINE> ( handle_visibility_behavior == kPreserveHandleVisibility && <NEW_LINE> selection . IsHandleVisible ( ) ) ; <NEW_LINE> <START_VULN> selection . SetSelection ( SelectionInDOMTree::Builder ( ) <NEW_LINE> . SetBaseAndExtent ( range ) <NEW_LINE> . SetAffinity ( VP_DEFAULT_AFFINITY ) <NEW_LINE> . SetIsHandleVisible ( show_handles ) <NEW_LINE> . SetIsDirectional ( false ) <NEW_LINE> . Build ( ) , <NEW_LINE>SetSelectionData ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> WebString WebLocalFrameImpl::RangeAsText ( const WebRange & web_range ) {
png_write_info_before_PLTE ( png_ptr , info_ptr ) ; <NEW_LINE> <START_VULN> if ( info_ptr -> valid & PNG_INFO_PLTE ) <NEW_LINE> <END_VULN> png_write_PLTE ( png_ptr , info_ptr -> palette , <NEW_LINE> ( png_uint_32 ) info_ptr -> num_palette ) ;
DestroyQuantumPixels ( quantum_info ) ; <NEW_LINE> quantum = ( quantum_info -> pad + 6 ) * ( quantum_info -> depth + 7 ) / 8 ; <NEW_LINE> extent = image -> columns * quantum ; <NEW_LINE> <START_VULN> if ( quantum != ( extent / image -> columns ) ) <NEW_LINE> <END_VULN> return ( MagickFalse ) ; <NEW_LINE> return ( AcquireQuantumPixels ( quantum_info , extent ) ) ; <NEW_LINE> }
* <NEW_LINE> <START_VULN> if ( do_local_background ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_fixed_point gtest ;
return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> <START_VULN> uint8_t * src = aData ; <NEW_LINE> <END_VULN> uint8_t * dst = imgsurf -> Data ( ) ; <NEW_LINE> for ( uint32_t j = 0 ; j < h ; j ++ ) {
JSClass * clasp = parentProto ? & sMainRuntimeClass : & sClass ; <NEW_LINE> JSObject * proto = JS_InitClass ( aCx , aObj , parentProto , clasp , Construct , 0 , <NEW_LINE> <START_VULN> sProperties , sFunctions , sStaticProperties , <NEW_LINE>NULL ) ; <NEW_LINE>if ( proto && ! JS_DefineProperties ( aCx , proto , sStaticProperties ) ) { <NEW_LINE> <END_VULN> return NULL ; <NEW_LINE> }
void InsertOrReplaceEntry ( NavigationEntry * entry , bool replace ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> void RemoveEntryAtIndexInternal ( int index ) ;
} <NEW_LINE> template < typename Base , typename Traits > <NEW_LINE> bool <NEW_LINE> XrayWrapper < Base , Traits > ::defineProperty ( JSContext * cx , JSObject * wrapper , jsid id , <NEW_LINE> js::PropertyDescriptor * desc ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( XrayUtils::IsTransparent ( cx , wrapper ) ) { <NEW_LINE> <END_VULN> JSObject * obj = Traits::getTargetObject ( wrapper ) ; <NEW_LINE> JSAutoCompartment ac ( cx , obj ) ; <NEW_LINE> if ( ! JS_WrapPropertyDescriptor ( cx , desc ) ) <NEW_LINE> return false ; <NEW_LINE> return JS_DefinePropertyById ( cx , obj , id , desc -> value , desc -> getter , desc -> setter , <NEW_LINE> desc -> attrs ) ; <NEW_LINE> }
NS_ENSURE_TRUE ( mIsInitialized , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE> * aRetValue = JSVAL_VOID ; <NEW_LINE> if ( ! mScriptsEnabled ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> if ( ! pusher . Push ( mContext ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> <END_VULN> xpc_UnmarkGrayObject ( & aScopeObject ) ; <NEW_LINE> nsAutoMicroTask mt ; <NEW_LINE> JSPrincipals * p = JS_GetCompartmentPrincipals ( js::GetObjectCompartment ( & aScopeObject ) ) ; <NEW_LINE> aOptions . setPrincipals ( p ) ; <NEW_LINE> bool ok = false ;
else { <NEW_LINE> int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; <NEW_LINE> <START_VULN> char * buff = malloc ( bytes_to_copy ) ; <NEW_LINE> <END_VULN> if ( debug_logging_mode ) <NEW_LINE> error_line ( "extra unknown chunk \" % c % c % c % c\" of % d bytes" ,
png_ptr -> background . blue , g ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( gs_sig ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_ptr -> background . red = png_gamma_correct ( png_ptr , <NEW_LINE> png_ptr -> background . red , gs ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: lookup based functions <NEW_LINE> <START_VULN> last mod: $ Id: lookup . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_LOOKUP_H_ <NEW_LINE> #ifdef FLOAT_LOOKUP <NEW_LINE> extern float vorbis_coslook ( float a ) ; <NEW_LINE> extern float vorbis_invsqlook ( float a ) ;
png_pass_start [ png_ptr -> pass ] ) / <NEW_LINE> png_pass_inc [ png_ptr -> pass ] ; <NEW_LINE> <START_VULN> if ( png_ptr -> transformations & PNG_INTERLACE ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> png_ptr -> num_rows = ( png_ptr -> height +
} <NEW_LINE> <START_VULN> if ( ! txdb . EraseTxIndex ( * this ) ) <NEW_LINE>return error ( "DisconnectInputs ( ) : EraseTxPos failed" ) ; <NEW_LINE> <END_VULN> return true ; <NEW_LINE> }
Event * , <NEW_LINE> EditorCommandSource , <NEW_LINE> const String & ) { <NEW_LINE> <START_VULN> frame . GetEditor ( ) . Transpose ( ) ; <NEW_LINE> <END_VULN> return true ; <NEW_LINE> }
{ <NEW_LINE> const short * HFilter ; <NEW_LINE> const short * VFilter ; <NEW_LINE> <START_VULN> DECLARE_ALIGNED_ARRAY ( 4 , short , FData , 16 * 8 ) ; <NEW_LINE> <END_VULN> HFilter = vp8_sub_pel_filters [ xoffset ] ; <NEW_LINE> VFilter = vp8_sub_pel_filters [ yoffset ] ;
Try <NEW_LINE> { <NEW_LINE> <START_VULN> make_transform_images ( & pm . this ) ; <NEW_LINE> <END_VULN> if ( pm . test_standard )
if ( halfoc < 0 ) halfoc = 0 ; <NEW_LINE> if ( halfoc >= P_BANDS - 1 ) halfoc = P_BANDS - 1 ; <NEW_LINE> inthalfoc = ( int ) halfoc ; <NEW_LINE> del = halfoc - inthalfoc ; <NEW_LINE> for ( j = 0 ; j < P_NOISECURVES ; j ++ ) <NEW_LINE> p -> noiseoffset [ j ] [ i ] = <NEW_LINE> <START_VULN> p -> vi -> noiseoff [ j ] [ inthalfoc ] * ( 1 . - del ) + <NEW_LINE>p -> vi -> noiseoff [ j ] [ inthalfoc + 1 ] * del ; <NEW_LINE> <END_VULN> } <NEW_LINE> #if 0 <NEW_LINE> { <NEW_LINE> static int ls = 0 ; <NEW_LINE> _analysis_output_always ( "noiseoff0" , ls , p -> noiseoffset [ 0 ] , n , 1 , 0 , 0 ) ; <NEW_LINE> _analysis_output_always ( "noiseoff1" , ls , p -> noiseoffset [ 1 ] , n , 1 , 0 , 0 ) ; <NEW_LINE> _analysis_output_always ( "noiseoff2" , ls ++ , p -> noiseoffset [ 2 ] , n , 1 , 0 , 0 ) ;
json_set_alloc_funcs ( my_malloc , my_free ) ; <NEW_LINE> create_and_free_complex_object ( ) ; <NEW_LINE> <START_VULN> if ( malloc_called != 20 || free_called != 20 ) <NEW_LINE> <END_VULN> fail ( "Custom allocation failed" ) ; <NEW_LINE> }
bitmapH = ( HBITMAP ) GetClipboardData ( CF_BITMAP ) ; <NEW_LINE> hPal = ( HPALETTE ) GetClipboardData ( CF_PALETTE ) ; <NEW_LINE> CloseClipboard ( ) ; <NEW_LINE> <START_VULN> if ( bitmapH == NULL ) <NEW_LINE> <END_VULN> ThrowReaderException ( CoderError , "NoBitmapOnClipboard" ) ; <NEW_LINE> { <NEW_LINE> BITMAPINFO
"RemovedFullScreenElement" ) ; <NEW_LINE> nsIDocument::ExitFullscreen ( OwnerDoc ( ) , false ) ; <NEW_LINE> } <NEW_LINE> if ( HasPointerLock ( ) ) { <NEW_LINE> nsIDocument::UnlockPointer ( ) ; <NEW_LINE> } <NEW_LINE> if ( GetParent ( ) ) { <NEW_LINE> <START_VULN> NS_RELEASE ( mParent ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> mParent = nullptr ; <NEW_LINE> } <NEW_LINE> SetParentIsContent ( false ) ; <NEW_LINE> } <NEW_LINE> ClearInDocument ( ) ;
#define SSL_OP_SINGLE_ECDH_USE 0x00080000L <NEW_LINE> #define SSL_OP_SINGLE_DH_USE 0x00100000L <NEW_LINE> <START_VULN> <NEW_LINE>#define SSL_OP_EPHEMERAL_RSA 0x00200000L <NEW_LINE> <END_VULN> #define SSL_OP_CIPHER_SERVER_PREFERENCE 0x00400000L
mContentArea . height = mBottomEdge = NS_UNCONSTRAINEDSIZE ; <NEW_LINE> } <NEW_LINE> mY = borderPadding . top ; <NEW_LINE> mPrevChild = nsnull ; <NEW_LINE> mCurrentLine = aFrame -> end_lines ( ) ; <NEW_LINE> <START_VULN> mMinLineHeight = nsHTMLReflowState::CalcLineHeight ( aReflowState . frame ) ; <NEW_LINE> <END_VULN> GetAvailableSpace ( ) ; <NEW_LINE> mOutsideBulletX = <NEW_LINE> mReflowState . mStyleVisibility -> mDirection == NS_STYLE_DIRECTION_LTR ? <NEW_LINE> mAvailSpaceRect . x :
if ( code == ( clear_code + 1 ) ) { <NEW_LINE> return ( mGIFStruct . rows_remaining == 0 ) ; <NEW_LINE> } <NEW_LINE> if ( oldcode == - 1 ) { <NEW_LINE> if ( code >= MAX_BITS ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> * rowp ++ = suffix [ code ] ; <NEW_LINE> <END_VULN> if ( rowp == rowend ) <NEW_LINE> OUTPUT_ROW ( ) ; <NEW_LINE> firstchar = oldcode = code ; <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> int incode = code ;
__m128i sign6 = _mm_srai_epi16 ( res [ 6 ] , 15 ) ; <NEW_LINE> __m128i sign7 = _mm_srai_epi16 ( res [ 7 ] , 15 ) ; <NEW_LINE> <START_VULN> if ( bit_m02 >= 0 ) { <NEW_LINE>__m128i k_const_rounding = _mm_slli_epi16 ( kOne , bit_m02 ) ; <NEW_LINE>res [ 0 ] = _mm_add_epi16 ( res [ 0 ] , k_const_rounding ) ; <NEW_LINE>res [ 1 ] = _mm_add_epi16 ( res [ 1 ] , k_const_rounding ) ; <NEW_LINE>res [ 2 ] = _mm_add_epi16 ( res [ 2 ] , k_const_rounding ) ; <NEW_LINE>res [ 3 ] = _mm_add_epi16 ( res [ 3 ] , k_const_rounding ) ; <NEW_LINE>res [ 4 ] = _mm_add_epi16 ( res [ 4 ] , k_const_rounding ) ; <NEW_LINE>res [ 5 ] = _mm_add_epi16 ( res [ 5 ] , k_const_rounding ) ; <NEW_LINE>res [ 6 ] = _mm_add_epi16 ( res [ 6 ] , k_const_rounding ) ; <NEW_LINE>res [ 7 ] = _mm_add_epi16 ( res [ 7 ] , k_const_rounding ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> res [ 0 ] = _mm_sub_epi16 ( res [ 0 ] , sign0 ) ;
{ <NEW_LINE> int b ; <NEW_LINE> <START_VULN> case 16: <NEW_LINE>for ( b = ( bpp >> 4 ) ; b > 0 ; ) <NEW_LINE> <END_VULN> { <NEW_LINE> unsigned int sig = ( unsigned int ) ( 0xffff0000 >> sig_bits [ b ] ) ;
if ( subpats != NULL ) { <NEW_LINE> <START_VULN> if ( pcre_get_substring_list ( subject , offsets , count , & stringlist ) < 0 ) { <NEW_LINE> <END_VULN> efree ( subpat_names ) ; <NEW_LINE> efree ( offsets ) ; <NEW_LINE> if ( match_sets ) efree ( match_sets ) ;
vp8_short_idct4x4llm_dspr2 ( input , dest , stride , dest , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( input , 0 , 32 ) ; <NEW_LINE> <END_VULN> }
int rtype = f -> residue_types [ rn ] ; <NEW_LINE> int c = r -> classbook ; <NEW_LINE> int classwords = f -> codebooks [ c ] . dimensions ; <NEW_LINE> <START_VULN> int n_read = r -> end - r -> begin ; <NEW_LINE> <END_VULN> int part_read = n_read / r -> part_size ; <NEW_LINE> int temp_alloc_point = temp_alloc_save ( f ) ; <NEW_LINE> #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
bool mListenerEnabled ; <NEW_LINE> bool mReturnInEmptyLIKillsList ; <NEW_LINE> bool mDidDeleteSelection ; <NEW_LINE> bool mDidRangedDelete ; <NEW_LINE> bool mRestoreContentEditableCount ; <NEW_LINE> nsCOMPtr < nsIDOMRange > mUtilRange ; <NEW_LINE> PRUint32 mJoinOffset ; <NEW_LINE> nsCOMPtr < nsIDOMNode > mNewBlock ; <NEW_LINE> <START_VULN> nsRangeStore mRangeItem ; <NEW_LINE> <END_VULN> StyleCache mCachedStyles [ SIZE_STYLE_TABLE ] ; <NEW_LINE> } ; <NEW_LINE> #endif
status_t resetPlugin ( ) ; <NEW_LINE> status_t reInitDecoder ( ) ; <NEW_LINE> <START_VULN> void setDecodeArgs ( <NEW_LINE> <END_VULN> ivd_video_decode_ip_t * ps_dec_ip , <NEW_LINE> ivd_video_decode_op_t * ps_dec_op , <NEW_LINE> OMX_BUFFERHEADERTYPE * inHeader ,
ctxt = xmlSchemaNewParserCtxt ( filename ) ; <NEW_LINE> <START_VULN> xmlSchemaSetParserErrors ( ctxt , <NEW_LINE> ( xmlSchemaValidityErrorFunc ) testErrorHandler , <NEW_LINE> ( xmlSchemaValidityWarningFunc ) testErrorHandler , <NEW_LINE>ctxt ) ; <NEW_LINE> <END_VULN> schemas = xmlSchemaParse ( ctxt ) ; <NEW_LINE> xmlSchemaFreeParserCtxt ( ctxt ) ;
struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <NEW_LINE> const MODE_INFO * mi = xd -> mi [ 0 ] ; <NEW_LINE> const int is_compound = has_second_ref ( & mi -> mbmi ) ; <NEW_LINE> <START_VULN> const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ; <NEW_LINE> <END_VULN> int ref ; <NEW_LINE> for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) {
{ <NEW_LINE> char * universal_ip_address = NULL ; <NEW_LINE> char * protocol = NULL ; <NEW_LINE> <START_VULN> guint8 b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8 , b9 , b10 ; <NEW_LINE> <END_VULN> guint16 port ; <NEW_LINE> int addr_offset ;
static void TraceBlackJS ( JSTracer * trc , void * data ) ; <NEW_LINE> static void TraceGrayJS ( JSTracer * trc , void * data ) ; <NEW_LINE> void TraceXPConnectRoots ( JSTracer * trc ) ; <NEW_LINE> void AddXPConnectRoots ( nsCycleCollectionTraversalCallback & cb ) ; <NEW_LINE> void UnmarkSkippableJSHolders ( ) ; <NEW_LINE> static void GCCallback ( JSRuntime * rt , JSGCStatus status ) ; <NEW_LINE> <START_VULN> static void FinalizeCallback ( JSFreeOp * fop , JSFinalizeStatus status ) ; <NEW_LINE> <END_VULN> inline void AddVariantRoot ( XPCTraceableVariant * variant ) ; <NEW_LINE> inline void AddWrappedJSRoot ( nsXPCWrappedJS * wrappedJS ) ; <NEW_LINE> inline void AddObjectHolderRoot ( XPCJSObjectHolder * holder ) ; <NEW_LINE> nsresult AddJSHolder ( void * aHolder , nsScriptObjectTracer * aTracer ) ; <NEW_LINE> nsresult RemoveJSHolder ( void * aHolder ) ;
aItem -> SetInSelection ( true ) ; <NEW_LINE> if ( aOutIndex ) <NEW_LINE> * aOutIndex = 0 ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> PRInt32 startIndex , endIndex ; <NEW_LINE> <START_VULN> GetIndicesForInterval ( aItem -> GetStartParent ( ) , aItem -> StartOffset ( ) , <NEW_LINE>aItem -> GetEndParent ( ) , aItem -> EndOffset ( ) , <NEW_LINE>false , & startIndex , & endIndex ) ; <NEW_LINE> <END_VULN> if ( endIndex == - 1 ) { <NEW_LINE> startIndex = 0 ; <NEW_LINE> endIndex = 0 ; <NEW_LINE> } else if ( startIndex == - 1 ) {
virtual void OpenConfigUI ( ) = 0 ; <NEW_LINE> <START_VULN> void UpdateUIFromInputMethod ( const InputMethodDescriptor & input_method , <NEW_LINE>size_t num_active_input_methods ) ; <NEW_LINE> <END_VULN>
} <NEW_LINE> for ( r = 0 ; r < h ; ++ r ) { <NEW_LINE> <START_VULN> size_t needed = w ; <NEW_LINE> <END_VULN> size_t buf_position = 0 ; <NEW_LINE> const size_t left = detect -> buf_read - detect -> position ; <NEW_LINE> if ( left > 0 ) {
if ( table && ! table -> selfNeedsLayout ( ) && ! table -> normalChildNeedsLayout ( ) && oldStyle && oldStyle -> border ( ) != style ( ) -> border ( ) ) <NEW_LINE> table -> invalidateCollapsedBorders ( ) ; <NEW_LINE> <START_VULN> if ( table && oldStyle && diff == StyleDifferenceLayout && needsLayout ( ) && table -> collapseBorders ( ) && borderWidthChanged ( oldStyle , style ( ) ) ) { <NEW_LINE> <END_VULN>
static void reflectStringAttributeAttributeGetter ( const v8::FunctionCallbackInfo < v8::Value > & info ) <NEW_LINE> { <NEW_LINE> v8::Local < v8::Object > holder = info . Holder ( ) ; <NEW_LINE> <START_VULN> Element * impl = V8Element::toImpl ( holder ) ; <NEW_LINE> <END_VULN> v8SetReturnValueString ( info , impl -> fastGetAttribute ( HTMLNames::reflectstringattributeAttr ) , info . GetIsolate ( ) ) ; <NEW_LINE> }
Platform::current ( ) -> unitTestSupport ( ) -> serveAsynchronousMockedRequests ( ) ; <NEW_LINE> <START_VULN> PageSerializer serializer ( & m_resources , <NEW_LINE>m_rewriteURLs . isEmpty ( ) ? 0: & m_rewriteURLs , m_rewriteFolder ) ; <NEW_LINE> <END_VULN> serializer . serialize ( m_webViewImpl -> mainFrameImpl ( ) -> frame ( ) -> page ( ) ) ; <NEW_LINE> }
const char * extractMetadata ( int keyCode ) ; <NEW_LINE> private: <NEW_LINE> <START_VULN> static const sp < IMediaPlayerService > & getService ( ) ; <NEW_LINE> <END_VULN> class DeathNotifier: public IBinder::DeathRecipient <NEW_LINE> {
return PNG_CHUNK_ANCILLARY ( PNG_U32 ( name [ 0 ] , name [ 1 ] , name [ 2 ] , name [ 3 ] ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED <NEW_LINE> <END_VULN> static int <NEW_LINE> ancillaryb ( const png_byte * name ) <NEW_LINE> {
} <NEW_LINE> <START_VULN> stok ( sclone ( app -> controller ) , " - " , & plural ) ; <NEW_LINE> <END_VULN> if ( plural ) { <NEW_LINE> app -> table = sjoin ( app -> controller , plural , NULL ) ; <NEW_LINE> } else {
function checkServiceLogs ( aOriginalContents ) { <NEW_LINE> let contents = readServiceLogFile ( ) ; <NEW_LINE> logTestInfo ( "the contents of maintenanceservice . log:\n" + contents + "\n" ) ; <NEW_LINE> do_check_neq ( contents , aOriginalContents ) ; <NEW_LINE> do_check_neq ( contents . indexOf ( LOG_SVC_SUCCESSFUL_LAUNCH ) , - 1 ) ; <NEW_LINE> } <NEW_LINE> function readServiceLogFile ( ) { <NEW_LINE> <START_VULN> let file = AUS_Cc [ "@mozilla . org / file / directory_service ; 1" ] . <NEW_LINE>getService ( AUS_Ci . nsIProperties ) . <NEW_LINE>get ( "CmAppData" , AUS_Ci . nsIFile ) ; <NEW_LINE>file . append ( "Mozilla" ) ; <NEW_LINE> <END_VULN> file . append ( "logs" ) ; <NEW_LINE> file . append ( "maintenanceservice . log" ) ; <NEW_LINE> return readFile ( file ) ; <NEW_LINE> } <NEW_LINE> function waitServiceApps ( ) { <NEW_LINE> waitForApplicationStop ( "maintenanceservice_installer . exe" ) ;
PHPDBG_G ( flags ) |= PHPDBG_IS_INITIALIZING ; <NEW_LINE> zend_try { <NEW_LINE> <START_VULN> phpdbg_init ( init_file , init_file_len , init_file_default ) ; <NEW_LINE> <END_VULN> if ( bp_tmp ) { <NEW_LINE> PHPDBG_G ( flags ) |= PHPDBG_DISCARD_OUTPUT ; <NEW_LINE> phpdbg_string_init ( bp_tmp ) ;
} else if ( msg == MOZ_WM_ENSUREVISIBLE ) { <NEW_LINE> EnsureWindowVisible ( GetParent ( hwnd ) ) ; <NEW_LINE> } <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> static UINT_PTR CALLBACK MultiFilePickerHook ( HWND hwnd , UINT msg , <NEW_LINE> WPARAM wParam , LPARAM lParam ) <NEW_LINE> { <NEW_LINE> switch ( msg ) { <NEW_LINE> case WM_INITDIALOG: <NEW_LINE> {
et_listselected , et_listdoubleclick , <NEW_LINE> et_scrollbarchange , <NEW_LINE> et_textchanged , et_textfocuschanged , <NEW_LINE> <START_VULN> et_lastsubtype } ; <NEW_LINE> <END_VULN> enum sb { et_sb_top , et_sb_uppage , et_sb_up , et_sb_left = et_sb_up , <NEW_LINE> et_sb_down , et_sb_right = et_sb_down , et_sb_downpage ,
* <NEW_LINE> MOZ_WARN_UNUSED_RESULT bool ReplacePrep ( index_type aCutStart , <NEW_LINE> size_type aCutLength , <NEW_LINE> <START_VULN> size_type aNewLength ) <NEW_LINE> { <NEW_LINE>aCutLength = XPCOM_MIN ( aCutLength , mLength - aCutStart ) ; <NEW_LINE>uint32_t newTotalLen = mLength - aCutLength + aNewLength ; <NEW_LINE>if ( aCutStart == mLength && Capacity ( ) > newTotalLen ) { <NEW_LINE>mFlags &= ~ F_VOIDED ; <NEW_LINE>mData [ newTotalLen ] = char_type ( 0 ) ; <NEW_LINE>mLength = newTotalLen ; <NEW_LINE>return true ; <NEW_LINE> } <NEW_LINE>return ReplacePrepInternal ( aCutStart , aCutLength , aNewLength , newTotalLen ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> MOZ_WARN_UNUSED_RESULT bool NS_FASTCALL ReplacePrepInternal (
SCREWUP ( "size out of range" ) ; <NEW_LINE> size = ( off_t ) ull ; <NEW_LINE> <START_VULN> if ( ( strchr ( cp , ' / ' ) != NULL ) || ( strcmp ( cp , " . . " ) == 0 ) ) { <NEW_LINE> <END_VULN> run_err ( "error: unexpected filename: % s" , cp ) ; <NEW_LINE> exit ( 1 ) ; <NEW_LINE> }
const long long frame_size = total_size - size ; <NEW_LINE> <START_VULN> if ( frame_size > LONG_MAX ) <NEW_LINE> <END_VULN> return E_FILE_FORMAT_INVALID ; <NEW_LINE> f . len = static_cast < long > ( frame_size ) ;
int single_file ; <NEW_LINE> int use_y4m = 1 ; <NEW_LINE> <START_VULN> vpx_codec_dec_cfg_t cfg = { 0 } ; <NEW_LINE> <END_VULN> #if CONFIG_VP8_DECODER <NEW_LINE> vp8_postproc_cfg_t vp8_pp_cfg = { 0 } ; <NEW_LINE> int vp8_dbg_color_ref_frame = 0 ;
{ <NEW_LINE> int num = SWFInput_readBits ( input , number ) ; <NEW_LINE> <START_VULN> if ( num & ( 1 << ( number - 1 ) ) ) <NEW_LINE> <END_VULN> return num - ( 1 << number ) ; <NEW_LINE> else <NEW_LINE> return num ;
set_freezable ( ) ; <NEW_LINE> <START_VULN> while ( ! kthread_should_stop ( ) ) { <NEW_LINE> <END_VULN>
gfxContext::FLAG_DISABLE_COPY_BACKGROUND ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> already_AddRefed < gfxImageSurface > gfxQuartzSurface::GetAsImageSurface ( ) <NEW_LINE> { <NEW_LINE> cairo_surface_t * surface = cairo_quartz_surface_get_image ( mSurface ) ; <NEW_LINE> <START_VULN> if ( ! surface ) <NEW_LINE> <END_VULN> return nullptr ; <NEW_LINE> nsRefPtr < gfxASurface > img = Wrap ( surface ) ;
static void down2_symeven ( const uint8_t * const input , int length , <NEW_LINE> uint8_t * output ) { <NEW_LINE> <START_VULN> static const int16_t * filter = vp9_down2_symeven_half_filter ; <NEW_LINE> <END_VULN> const int filter_len_half = sizeof ( vp9_down2_symeven_half_filter ) / 2 ; <NEW_LINE> int i , j ; <NEW_LINE> uint8_t * optr = output ;
} <NEW_LINE> extra -> match_limit = PCRE_G ( backtrack_limit ) ; <NEW_LINE> extra -> match_limit_recursion = PCRE_G ( recursion_limit ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> array_init ( return_value ) ;
PepperDeviceEnumerationHostHelper ( ppapi::host::ResourceHost * resource_host , <NEW_LINE> <START_VULN> Delegate * delegate , <NEW_LINE> <END_VULN> PP_DeviceType_Dev device_type , <NEW_LINE> const GURL & document_url ) ; <NEW_LINE> ~ PepperDeviceEnumerationHostHelper ( ) ;
#ifndef imgStatusTracker_h__ <NEW_LINE> #define imgStatusTracker_h__ <NEW_LINE> class imgDecoderObserver ; <NEW_LINE> class imgIContainer ; <NEW_LINE> <START_VULN> class imgRequestProxy ; <NEW_LINE> <END_VULN> class imgStatusNotifyRunnable ; <NEW_LINE> class imgRequestNotifyRunnable ; <NEW_LINE> class imgStatusTrackerObserver ; <NEW_LINE> class nsIRunnable ; <NEW_LINE> #include "mozilla / RefPtr . h" <NEW_LINE> #include "mozilla / WeakPtr . h" <NEW_LINE> #include "nsCOMPtr . h" <NEW_LINE> #include "nsTObserverArray . h" <NEW_LINE> #include "nsThreadUtils . h" <NEW_LINE> #include "nsRect . h" <NEW_LINE> namespace mozilla { <NEW_LINE> namespace image { <NEW_LINE> class Image ; <NEW_LINE> struct ImageStatusDiff <NEW_LINE> {
} <NEW_LINE> const uint64 atom_size = <NEW_LINE> <START_VULN> EbmlMasterElementSize ( kMkvChapterAtom , payload_size ) + <NEW_LINE>payload_size ; <NEW_LINE> <END_VULN> if ( writer == NULL ) <NEW_LINE> return atom_size ;
"tlb_flush_pending % d\n" <NEW_LINE> "def_flags: % #lx ( % pGv ) \n" , <NEW_LINE> <START_VULN> mm , mm -> mmap , mm -> vmacache_seqnum , mm -> task_size , <NEW_LINE> <END_VULN> #ifdef CONFIG_MMU <NEW_LINE> mm -> get_unmapped_area , <NEW_LINE> #endif
{ <NEW_LINE> nsAString::iterator writer ; <NEW_LINE> PRUint32 oldLength = aDest . Length ( ) ; <NEW_LINE> <START_VULN> aDest . SetLength ( oldLength + Distance ( aSrcStart , aSrcEnd ) ) ; <NEW_LINE> <END_VULN> aDest . BeginWriting ( writer ) . advance ( oldLength ) ; <NEW_LINE> nsScannerIterator fromBegin ( aSrcStart ) ;
} else { <NEW_LINE> err = NOT_ENOUGH_DATA ; <NEW_LINE> OMX_U32 declaredSize = * ( OMX_U32 * ) params ; <NEW_LINE> <START_VULN> if ( code != SET_INTERNAL_OPTION && declaredSize > size ) { <NEW_LINE> <END_VULN> ALOGE ( "b / 27207275 ( % u / % zu ) " , declaredSize , size ) ; <NEW_LINE> android_errorWriteLog ( 0x534e4554 , "27207275" ) ;
sgo -> OnFinalize ( nsIProgrammingLanguage::JAVASCRIPT , obj ) ; <NEW_LINE> <START_VULN> return nsEventReceiverSH::Finalize ( wrapper , cx , obj ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> NS_IMETHODIMP
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: window functions <NEW_LINE> <START_VULN> last mod: $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_WINDOW_ <NEW_LINE> #define _V_WINDOW_ <NEW_LINE> extern float * _vorbis_window_get ( int n ) ; <NEW_LINE> extern void _vorbis_apply_window ( float * d , int * winno , long * blocksizes ,
return ERROR ; <NEW_LINE> } <NEW_LINE> <START_VULN> size_t data_size = <NEW_LINE>calculate_camera_metadata_entry_data_size ( entry . type , <NEW_LINE>entry . count ) ; <NEW_LINE> <END_VULN> if ( data_size != 0 ) { <NEW_LINE> camera_metadata_data_t * data =
if ( civ -> request && ( civ -> proc == 1 ) ) { <NEW_LINE> const gchar * host ; <NEW_LINE> unsigned char * name ; <NEW_LINE> <START_VULN> int len ; <NEW_LINE> <END_VULN> unsigned char * ptr ; <NEW_LINE> host = ip_to_str ( pinfo -> dst . data ) ;
#include "md5_utils . h" <NEW_LINE> <START_VULN> void <NEW_LINE> <END_VULN> byteSwap ( UWORD32 * buf , unsigned words ) { <NEW_LINE> md5byte * p ;
} <NEW_LINE> SKIP_BLANKS ; <NEW_LINE> GROW ; <NEW_LINE> <START_VULN> while ( RAW != ' > ' ) { <NEW_LINE> <END_VULN> const xmlChar * check = CUR_PTR ; <NEW_LINE> int type ; <NEW_LINE> int def ;
} <NEW_LINE> JS_PUBLIC_API ( JSStackFrame * ) <NEW_LINE> JS_BrokenFrameIterator ( JSContext * cx , JSStackFrame ** iteratorp ) <NEW_LINE> { <NEW_LINE> StackFrame * fp = Valueify ( * iteratorp ) ; <NEW_LINE> <START_VULN> * iteratorp = Jsvalify ( ( fp == NULL ) ? js_GetTopStackFrame ( cx , FRAME_EXPAND_ALL ) : fp -> prev ( ) ) ; <NEW_LINE> <END_VULN> return * iteratorp ; <NEW_LINE> } <NEW_LINE> JS_PUBLIC_API ( JSScript * ) <NEW_LINE> JS_GetFrameScript ( JSContext * cx , JSStackFrame * fpArg ) <NEW_LINE> { <NEW_LINE> return Valueify ( fpArg ) -> script ( ) ; <NEW_LINE> }
reactor_t * reactor = reactor_new ( ) ; <NEW_LINE> spawn_reactor_thread ( reactor ) ; <NEW_LINE> <START_VULN> usleep ( 50 * 1000 ) ; <NEW_LINE> <END_VULN> EXPECT_TRUE ( thread_running ) ; <NEW_LINE> reactor_stop ( reactor ) ;
typedef CancelableRequest < FaviconDataCallback > GetFaviconRequest ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> Handle GetFavicon ( const GURL & icon_url , <NEW_LINE> history::IconType icon_type , <NEW_LINE> CancelableRequestConsumerBase * consumer ,
ENTROPY_CONTEXT * a_ctx = ( ( ENTROPY_CONTEXT * ) x -> above_context ) ; <NEW_LINE> ENTROPY_CONTEXT * l_ctx = ( ( ENTROPY_CONTEXT * ) x -> left_context ) ; <NEW_LINE> <START_VULN> vpx_memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <NEW_LINE>vpx_memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <NEW_LINE> <END_VULN> if ( ! x -> mode_info_context -> mbmi . is_4x4 )
void LocalFileSystem::requestFileSystem ( ExecutionContext * context , FileSystemType type , long long size , PassOwnPtr < AsyncFileSystemCallbacks > callbacks ) <NEW_LINE> { <NEW_LINE> RefPtrWillBeRawPtr < ExecutionContext > contextPtr ( context ) ; <NEW_LINE> <START_VULN> RefPtr < CallbackWrapper > wrapper = adoptRef ( new CallbackWrapper ( callbacks ) ) ; <NEW_LINE> <END_VULN> requestFileSystemAccessInternal ( context , <NEW_LINE> bind ( & LocalFileSystem::fileSystemAllowedInternal , this , contextPtr , type , wrapper ) , <NEW_LINE> bind ( & LocalFileSystem::fileSystemNotAllowedInternal , this , contextPtr , wrapper ) ) ;
newinet -> inet_daddr = ireq -> rmt_addr ; <NEW_LINE> newinet -> inet_rcv_saddr = ireq -> loc_addr ; <NEW_LINE> newinet -> inet_saddr = ireq -> loc_addr ; <NEW_LINE> <START_VULN> newinet -> opt = ireq -> opt ; <NEW_LINE> <END_VULN> ireq -> opt = NULL ; <NEW_LINE> newinet -> mc_index = inet_iif ( skb ) ; <NEW_LINE> newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ;
eLinkState_Unknown = 0 , <NEW_LINE> eLinkState_Unvisited = 1 , <NEW_LINE> eLinkState_Visited = 2 , <NEW_LINE> eLinkState_NotLink = 3 <NEW_LINE> } ; <NEW_LINE> #define NS_ICONTENT_IID \ <NEW_LINE> <START_VULN> { 0x98fb308d , 0xc6dd , 0x4c6d , \ <NEW_LINE> { 0xb7 , 0x7c , 0x91 , 0x18 , 0x0c , 0xf0 , 0x6f , 0x23 } } <NEW_LINE> <END_VULN> class nsIContent : public nsINode { <NEW_LINE> public: <NEW_LINE> typedef mozilla::widget::IMEState IMEState ;
BTIF_TRACE_ERROR ( "Received H / W Error . " ) ; <NEW_LINE> btif_config_flush ( ) ; <NEW_LINE> <START_VULN> usleep ( 100000 ) ; <NEW_LINE> <END_VULN> kill ( getpid ( ) , SIGKILL ) ; <NEW_LINE> break ;
skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; <NEW_LINE> <START_VULN> if ( srose != NULL ) { <NEW_LINE>memset ( srose , 0 , msg -> msg_namelen ) ; <NEW_LINE> <END_VULN> srose -> srose_family = AF_ROSE ; <NEW_LINE> srose -> srose_addr = rose -> dest_addr ; <NEW_LINE> srose -> srose_call = rose -> dest_call ;
case 217: <NEW_LINE> <START_VULN> #line 1017 "ntp_parser . y" <NEW_LINE> <END_VULN> { <NEW_LINE> enqueue ( cfgt . nic_rules , <NEW_LINE> create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;
CHECK_INTERFACE ( IGraphicBufferConsumer , data , reply ) ; <NEW_LINE> sp < GraphicBuffer > buffer = new GraphicBuffer ( ) ; <NEW_LINE> data . read ( * buffer . get ( ) ) ; <NEW_LINE> <START_VULN> int slot ; <NEW_LINE> <END_VULN> int result = attachBuffer ( & slot , buffer ) ; <NEW_LINE> reply -> writeInt32 ( slot ) ; <NEW_LINE> reply -> writeInt32 ( result ) ;
Player * DocumentTimeline::play ( TimedItem * child ) <NEW_LINE> { <NEW_LINE> Player * player = createPlayer ( child ) ; <NEW_LINE> <START_VULN> player -> setStartTime ( currentTime ( ) ) ; <NEW_LINE> <END_VULN> return player ; <NEW_LINE> }
__error: <NEW_LINE> if ( chip ) { <NEW_LINE> if ( ! chip -> num_interfaces ) <NEW_LINE> snd_card_free ( chip -> card ) ; <NEW_LINE> <START_VULN> atomic_dec ( & chip -> active ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> mutex_unlock ( & register_mutex ) ; <NEW_LINE> return err ;
png_pass_start [ png_ptr -> pass ] ) / <NEW_LINE> png_pass_inc [ png_ptr -> pass ] ; <NEW_LINE> <START_VULN> if ( ! ( png_ptr -> transformations & PNG_INTERLACE ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_ptr -> num_rows = ( png_ptr -> height + <NEW_LINE> png_pass_yinc [ png_ptr -> pass ] - 1 -
any = true ; <NEW_LINE> zone -> setGCState ( Zone::Mark ) ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> rt -> gcIsFull = false ; <NEW_LINE> } <NEW_LINE> zone -> scheduledForDestruction = false ; <NEW_LINE> <START_VULN> zone -> maybeAlive = zone -> hold ; <NEW_LINE> <END_VULN> zone -> setPreservingCode ( false ) ; <NEW_LINE> } <NEW_LINE> for ( CompartmentsIter c ( rt , WithAtoms ) ; ! c . done ( ) ; c . next ( ) ) { <NEW_LINE> JS_ASSERT ( c -> gcLiveArrayBuffers . empty ( ) ) ; <NEW_LINE> c -> marked = false ; <NEW_LINE> if ( ShouldPreserveJITCode ( c , currentTime ) ) <NEW_LINE> c -> zone ( ) -> setPreservingCode ( true ) ;
void SetNetworkConditions ( network::mojom::NetworkConditionsPtr conditions ) ; <NEW_LINE> std::unique_ptr < Network::Frontend > frontend_ ; <NEW_LINE> <START_VULN> RenderProcessHost * process_ ; <NEW_LINE> <END_VULN> RenderFrameHostImpl * host_ ; <NEW_LINE> bool enabled_ ; <NEW_LINE> std::string user_agent_ ;
} <NEW_LINE> IntRect r = enclosingIntRect ( f . selectionRectForText ( TextRun ( characters , len , textObj -> allowTabs ( ) , textPos ( ) , m_toAdd , ! isLeftToRightDirection ( ) , m_dirOverride ) , <NEW_LINE> <START_VULN> IntPoint ( tx + m_x , ty + selTop ) , selHeight , sPos , ePos ) ) ; <NEW_LINE>if ( r . x ( ) > tx + m_x + m_logicalWidth ) <NEW_LINE>r . setWidth ( 0 ) ; <NEW_LINE>else if ( r . right ( ) - 1 > tx + m_x + m_logicalWidth ) <NEW_LINE>r . setWidth ( tx + m_x + m_logicalWidth - r . x ( ) ) ; <NEW_LINE>return r ; <NEW_LINE> <END_VULN> } <NEW_LINE> void InlineTextBox::deleteLine ( RenderArena * arena )
<START_VULN> if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( uint , <NEW_LINE> <END_VULN> jas_image_numcmpts ( dec -> image ) ) ) { <NEW_LINE> jas_eprintf ( "warning: number of components mismatch\n" ) ; <NEW_LINE> }
mContent -> GetCurrentDoc ( ) , base ) ; <NEW_LINE> property = <NEW_LINE> nsSVGEffects::GetTextPathProperty ( targetURI , this , nsSVGEffects::HrefProperty ( ) ) ; <NEW_LINE> if ( ! property ) <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> <START_VULN> return property -> GetReferencedFrame ( nsGkAtoms::svgPathGeometryFrame , nullptr ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> already_AddRefed < gfxFlattenedPath > <NEW_LINE> nsSVGTextPathFrame::GetFlattenedPath ( ) <NEW_LINE> { <NEW_LINE> nsIFrame * path = GetPathFrame ( ) ; <NEW_LINE> if ( path ) {
static int uhid_write ( int fd , const struct uhid_event * ev ) <NEW_LINE> { <NEW_LINE> <START_VULN> ssize_t ret = write ( fd , ev , sizeof ( * ev ) ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( ret < 0 ) { <NEW_LINE> int rtn = - errno ; <NEW_LINE> APPL_TRACE_ERROR ( " % s: Cannot write to uhid: % s" ,
if ( ! doc -> IsResourceDoc ( ) ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> if ( aContentType == nsIContentPolicy::TYPE_OBJECT || <NEW_LINE> aContentType == nsIContentPolicy::TYPE_DOCUMENT || <NEW_LINE> aContentType == nsIContentPolicy::TYPE_SUBDOCUMENT || <NEW_LINE> <START_VULN> aContentType == nsIContentPolicy::TYPE_SCRIPT ) { <NEW_LINE> <END_VULN> * aDecision = nsIContentPolicy::REJECT_TYPE ; <NEW_LINE> } <NEW_LINE> return NS_OK ;
} <NEW_LINE> #define mem_get_s_generic ( end , sz ) \ <NEW_LINE> <START_VULN> static signed MEM_VALUE_T mem_get_s##end##sz ( const void * vmem ) { \ <NEW_LINE> <END_VULN> const MAU_T * mem = ( const MAU_T * ) vmem ; \ <NEW_LINE> signed MEM_VALUE_T val = mem_get_##end##sz ( mem ) ; \ <NEW_LINE> return ( val << ( MEM_VALUE_T_SZ_BITS - sz ) ) >> ( MEM_VALUE_T_SZ_BITS - sz ) ; \
if ( curCapacity != size_type ( - 1 ) ) <NEW_LINE> { <NEW_LINE> if ( capacity <= curCapacity ) { <NEW_LINE> mFlags &= ~ F_VOIDED ; <NEW_LINE> return PR_TRUE ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( curCapacity > 0 ) <NEW_LINE> { <NEW_LINE><NEW_LINE><NEW_LINE>PRUint32 temp = curCapacity ; <NEW_LINE>while ( temp < capacity ) <NEW_LINE>temp <<= 1 ; <NEW_LINE>capacity = temp ; <NEW_LINE> } <NEW_LINE> <END_VULN> }
kernel ; it's the pixel to remove from the accumulator . * / <NEW_LINE> gint * ac ; <NEW_LINE> ac = g_new0 ( gint , bpp ) ; <NEW_LINE> <START_VULN> if ( sx < 10 . 0 && sy < 10 . 0 ) <NEW_LINE>use_box_blur = FALSE ; <NEW_LINE>else <NEW_LINE>use_box_blur = TRUE ; <NEW_LINE><NEW_LINE> <END_VULN> if ( ( sx == 0 . 0 && sy == 0 . 0 ) <NEW_LINE> || sx > 1000 || sy > 1000 ) {
return ; <NEW_LINE> m_frame -> document ( ) -> cancelParsing ( ) ; <NEW_LINE> <START_VULN> if ( m_provisionalDocumentLoader ) { <NEW_LINE>FrameNavigationDisabler navigationDisabler ( * m_frame ) ; <NEW_LINE>detachDocumentLoader ( m_provisionalDocumentLoader ) ; <NEW_LINE> } <NEW_LINE> <END_VULN>
ZVAL_DOUBLE ( * rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1069 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy65: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' , ' ) {
nsresult <NEW_LINE> Selection::GetRangesForIntervalArray ( nsINode * aBeginNode , PRInt32 aBeginOffset , <NEW_LINE> nsINode * aEndNode , PRInt32 aEndOffset , <NEW_LINE> bool aAllowAdjacent , <NEW_LINE> nsTArray < nsRange * > * aRanges ) <NEW_LINE> { <NEW_LINE> aRanges -> Clear ( ) ; <NEW_LINE> PRInt32 startIndex , endIndex ; <NEW_LINE> <START_VULN> GetIndicesForInterval ( aBeginNode , aBeginOffset , aEndNode , aEndOffset , <NEW_LINE>aAllowAdjacent , & startIndex , & endIndex ) ; <NEW_LINE> <END_VULN> if ( startIndex == - 1 || endIndex == - 1 ) <NEW_LINE> return NS_OK ; <NEW_LINE> for ( PRInt32 i = startIndex ; i < endIndex ; i ++ ) { <NEW_LINE> if ( ! aRanges -> AppendElement ( mRanges [ i ] . mRange ) ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> }
#ifdef DEBUG <NEW_LINE> ok = <NEW_LINE> #endif <NEW_LINE> <START_VULN> js_InflateUTF8StringToBuffer ( cx , bytes , nbytes , chars , & nchars , <NEW_LINE>useCESU8 ) ; <NEW_LINE> <END_VULN> JS_ASSERT ( ok ) ; <NEW_LINE> } else { <NEW_LINE> nchars = nbytes ;
} <NEW_LINE> PRBool <NEW_LINE> nsGlobalWindow::DispatchCustomEvent ( const char * aEventName ) <NEW_LINE> { <NEW_LINE> PRBool defaultActionEnabled = PR_TRUE ; <NEW_LINE> nsCOMPtr < nsIDocument > doc ( do_QueryInterface ( mDocument ) ) ; <NEW_LINE> nsContentUtils::DispatchTrustedEvent ( doc , <NEW_LINE> <START_VULN> static_cast < nsIScriptGlobalObject * > ( this ) , <NEW_LINE> <END_VULN> NS_ConvertASCIItoUTF16 ( aEventName ) , <NEW_LINE> PR_TRUE , PR_TRUE , & defaultActionEnabled ) ; <NEW_LINE> return defaultActionEnabled ; <NEW_LINE> } <NEW_LINE> static already_AddRefed < nsIDocShellTreeItem > <NEW_LINE> GetCallerDocShellTreeItem ( )
# endif <NEW_LINE> #endif <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
} <NEW_LINE> static JSBool <NEW_LINE> MirrorWrappedNativeParent ( JSContext * cx , XPCWrappedNative * wrapper , <NEW_LINE> <START_VULN> JSObject ** result ) <NEW_LINE> <END_VULN> { <NEW_LINE> JSObject * wn_parent = STOBJ_GET_PARENT ( wrapper -> GetFlatJSObject ( ) ) ; <NEW_LINE> if ( ! wn_parent ) { <NEW_LINE> * result = nsnull ;
} <NEW_LINE> uint32_t numInstructions ( ) const { <NEW_LINE> return numInstructions_ ; <NEW_LINE> } <NEW_LINE> void setLocalSlotCount ( uint32_t localSlotCount ) { <NEW_LINE> localSlotCount_ = localSlotCount ; <NEW_LINE> } <NEW_LINE> uint32_t localSlotCount ( ) const { <NEW_LINE> <START_VULN> return localSlotCount_ ; <NEW_LINE> <END_VULN> } <NEW_LINE> void setArgumentSlotCount ( uint32_t argumentSlotCount ) { <NEW_LINE> argumentSlotCount_ = argumentSlotCount ; <NEW_LINE> } <NEW_LINE> uint32_t argumentSlotCount ( ) const { <NEW_LINE> return argumentSlotCount_ ; <NEW_LINE> } <NEW_LINE> uint32_t totalSlotCount ( ) const {
<START_VULN> static void <NEW_LINE> <END_VULN> _copy_from_pages ( char * p , struct page ** pages , size_t pgbase , size_t len ) <NEW_LINE> { <NEW_LINE> struct page ** pgfrom ;
ps_bitstrm , <NEW_LINE> ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; <NEW_LINE> if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) <NEW_LINE> <START_VULN> return ERROR_INV_SPS_PPS_T ; <NEW_LINE> <END_VULN> s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; <NEW_LINE> COPYTHECONTEXT ( "SH: pic_order_cnt_lsb" , s_tmp_poc . i4_pic_order_cnt_lsb ) ;
if ( mCaret ) { <NEW_LINE> mCaret -> InvalidateOutsideCaret ( ) ; <NEW_LINE> } <NEW_LINE> mPresContext -> EventStateManager ( ) -> ContentRemoved ( aChild ) ; <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE> <END_VULN> if ( aContainer ) <NEW_LINE> mFrameConstructor -> RestyleForRemove ( aContainer , aChild , aIndexInContainer ) ; <NEW_LINE> PRBool didReconstruct ;
} <NEW_LINE> ctxt = xmlSchemaNewValidCtxt ( schemas ) ; <NEW_LINE> <START_VULN> xmlSchemaSetValidErrors ( ctxt , <NEW_LINE> ( xmlSchemaValidityErrorFunc ) testErrorHandler , <NEW_LINE> ( xmlSchemaValidityWarningFunc ) testErrorHandler , <NEW_LINE>ctxt ) ; <NEW_LINE> <END_VULN> ret = xmlSchemaValidateDoc ( ctxt , doc ) ; <NEW_LINE> if ( xmlStrEqual ( validity , BAD_CAST "valid" ) ) {
load ? "bundle_load" : "bundle" , slaves_size , <NEW_LINE> bundle -> n_slaves * sizeof ( ovs_be16 ) , bundle -> n_slaves ) ; <NEW_LINE> error = OFPERR_OFPBAC_BAD_LEN ; <NEW_LINE> <START_VULN> } <NEW_LINE><NEW_LINE>for ( i = 0 ; i < bundle -> n_slaves ; i ++ ) { <NEW_LINE>ofp_port_t ofp_port = u16_to_ofp ( ntohs ( ( ( ovs_be16 * ) ( nab + 1 ) ) [ i ] ) ) ; <NEW_LINE>ofpbuf_put ( ofpacts , & ofp_port , sizeof ofp_port ) ; <NEW_LINE>bundle = ofpacts -> header ; <NEW_LINE> <END_VULN> } <NEW_LINE> ofpact_finish_BUNDLE ( ofpacts , & bundle ) ;
r = LIBUSB_SUCCESS ; <NEW_LINE> } <NEW_LINE> break ; <NEW_LINE> <START_VULN> default: <NEW_LINE>if ( parent_priv -> apib -> id == USB_API_HID ) { <NEW_LINE>usbi_dbg ( "setting HID interface for [ % lX ] :" , parent_dev -> session_data ) ; <NEW_LINE>r = set_hid_interface ( ctx , parent_dev , dev_interface_path ) ; <NEW_LINE>if ( r != LIBUSB_SUCCESS ) LOOP_BREAK ( r ) ; <NEW_LINE>dev_interface_path = NULL ; <NEW_LINE> } else if ( parent_priv -> apib -> id == USB_API_COMPOSITE ) { <NEW_LINE> <END_VULN> usbi_dbg ( "setting composite interface for [ % lX ] :" , parent_dev -> session_data ) ; <NEW_LINE> switch ( set_composite_interface ( ctx , parent_dev , dev_interface_path , dev_id_path , api , sub_api ) ) { <NEW_LINE> case LIBUSB_SUCCESS:
return counts ; <NEW_LINE> } <NEW_LINE> private: <NEW_LINE> bool addGetPropertyCache ( LInstruction * ins , RegisterSet liveRegs , Register objReg , <NEW_LINE> PropertyName * name , TypedOrValueRegister output , <NEW_LINE> bool allowGetters ) ; <NEW_LINE> bool addGetElementCache ( LInstruction * ins , Register obj , ConstantOrRegister index , <NEW_LINE> <START_VULN> TypedOrValueRegister output , bool monitoredResult ) ; <NEW_LINE> <END_VULN> bool checkForAbortPar ( LInstruction * lir ) ; <NEW_LINE> bool generateBranchV ( const ValueOperand & value , Label * ifTrue , Label * ifFalse , FloatRegister fr ) ; <NEW_LINE> bool emitAllocateGCThingPar ( LInstruction * lir , const Register & objReg , const Register & sliceReg , <NEW_LINE> const Register & tempReg1 , const Register & tempReg2 , <NEW_LINE> JSObject * templateObj ) ;
<START_VULN> #ifndef NATIVE_FRAMEWORK_CHROME_IMPORTANT_FILE_WRITE_ANDROID_H_ <NEW_LINE>#define NATIVE_FRAMEWORK_CHROME_IMPORTANT_FILE_WRITE_ANDROID_H_ <NEW_LINE> <END_VULN> #include < jni . h >
#include < set > <NEW_LINE> #include "base / memory / scoped_ptr . h" <NEW_LINE> <START_VULN> #include "remoting / host / url_fetcher . h" <NEW_LINE> <END_VULN> #include "third_party / libjingle / source / talk / p2p / client / httpportallocator . h" <NEW_LINE> namespace net {
if ( out == NULL ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> gdImageWebpCtx ( im , out , - 1 ) ; <NEW_LINE> <END_VULN> out -> gd_free ( out ) ; <NEW_LINE> }
strcpy ( temp_str , app ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> delete [ ] muxing_app_ ; <NEW_LINE> <END_VULN> muxing_app_ = temp_str ; <NEW_LINE> } <NEW_LINE> }
if ( ! x -> skip ) <NEW_LINE> <START_VULN> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mbmode , <NEW_LINE>sizeof ( MB_MODE_INFO ) ) ; <NEW_LINE> <END_VULN> if ( best_mbmode . mode <= B_PRED ) <NEW_LINE> {
break ; <NEW_LINE> } while ( image_info -> adjoin != MagickFalse ) ; <NEW_LINE> TIFFClose ( tiff ) ; <NEW_LINE> <START_VULN> return ( image -> exception . severity > ErrorException ? MagickFalse : MagickTrue ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif
if ( ps_slice -> u1_nal_ref_idc != 0 ) <NEW_LINE> { <NEW_LINE> if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) <NEW_LINE> <START_VULN> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( <NEW_LINE>ps_dec ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> ps_dec -> ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; <NEW_LINE> }
{ <NEW_LINE> struct sockaddr_un client_address ; <NEW_LINE> socklen_t clen ; <NEW_LINE> <START_VULN> int fd = accept ( s , ( struct sockaddr * ) & client_address , & clen ) ; <NEW_LINE> <END_VULN> APPL_TRACE_DEBUG ( "accepted fd: % d for server fd: % d" , fd , s ) ; <NEW_LINE> return fd ; <NEW_LINE> }
chnMem . autoTonePorta = m . param ; <NEW_LINE> chnMem . tonePortaMem = 0 ; <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x14:
pbi -> ec_enabled = oxcf -> error_concealment ; <NEW_LINE> pbi -> overlaps = NULL ; <NEW_LINE> #else <NEW_LINE> pbi -> ec_enabled = 0 ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> #if HAVE_NEON <NEW_LINE>extern void vp8_push_neon ( int64_t * store ) ; <NEW_LINE>extern void vp8_pop_neon ( int64_t * store ) ; <NEW_LINE>#endif <NEW_LINE><NEW_LINE> <END_VULN> static int get_free_fb ( VP8_COMMON * cm ) <NEW_LINE> { <NEW_LINE> int i ;
"\n" <NEW_LINE> " function setTimer ( ) { \n" <NEW_LINE> " checkSession ( ) ; \n" <NEW_LINE> <START_VULN> " timerID = setInterval ( 'checkSession ( ) ' , % s ) ; \n" <NEW_LINE> <END_VULN> " } \n" <NEW_LINE> "\n" <NEW_LINE> " function receiveMessage ( e ) { \n"
this_offset = base_offset + ( br * ( pre_stride ) ) + bc ; <NEW_LINE> this_mv . as_mv . row = br ; <NEW_LINE> this_mv . as_mv . col = bc ; <NEW_LINE> <START_VULN> bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , UINT_MAX ) <NEW_LINE> <END_VULN> + mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; <NEW_LINE> #if CONFIG_MULTI_RES_ENCODING
case IPSECDOI_ID_IPV6_ADDR_SUBNET: <NEW_LINE> { <NEW_LINE> const u_char * mask ; <NEW_LINE> <START_VULN> if ( len < 20 ) <NEW_LINE>ND_PRINT ( ( ndo , " len = % d [ bad: < 20 ] " , len ) ) ; <NEW_LINE> <END_VULN> else { <NEW_LINE> mask = ( const u_char * ) ( data + sizeof ( struct in6_addr ) ) ;
std::cout << "FAILED:" ; <NEW_LINE> else <NEW_LINE> std::cout << "passed:" ; <NEW_LINE> <START_VULN> std::cout << " GenerateWord32 and Crop\n" ; <NEW_LINE> <END_VULN> std::cout . flush ( ) ; <NEW_LINE> return pass ;
uint64 encoding_size = 0 ; <NEW_LINE> if ( encryption_size > 0 ) { <NEW_LINE> <START_VULN> encoding_size += EbmlMasterElementSize ( kMkvContentEncryption , <NEW_LINE>encryption_size ) + <NEW_LINE>encryption_size ; <NEW_LINE> <END_VULN> } <NEW_LINE> encoding_size += EbmlElementSize ( kMkvContentEncodingType , encoding_type_ ) ; <NEW_LINE> encoding_size += EbmlElementSize ( kMkvContentEncodingScope , encoding_scope_ ) ;
state -> empty = 1 ; <NEW_LINE> alloc = sizeof ( struct posix_ace_state_array ) <NEW_LINE> <START_VULN> + cnt * sizeof ( struct posix_ace_state ) ; <NEW_LINE> <END_VULN> state -> users = kzalloc ( alloc , GFP_KERNEL ) ; <NEW_LINE> if ( ! state -> users ) <NEW_LINE> return - ENOMEM ;
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION ( mozHunspell ) <NEW_LINE> NS_INTERFACE_MAP_END <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_3 ( mozHunspell , <NEW_LINE> mPersonalDictionary , <NEW_LINE> mEncoder , <NEW_LINE> mDecoder ) <NEW_LINE> <START_VULN> int64_t mozHunspell::sAmount = 0 ; <NEW_LINE><NEW_LINE>void HunspellReportMemoryAllocation ( void * ptr ) { <NEW_LINE>mozHunspell::OnAlloc ( ptr ) ; <NEW_LINE> } <NEW_LINE>void HunspellReportMemoryDeallocation ( void * ptr ) { <NEW_LINE>mozHunspell::OnFree ( ptr ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> mozHunspell::mozHunspell ( ) <NEW_LINE> : MemoryUniReporter ( "explicit / spell - check" , KIND_HEAP , UNITS_BYTES , <NEW_LINE> "Memory used by the spell - checking engine's internal data structures . " ) , <NEW_LINE> mHunspell ( nullptr ) <NEW_LINE> { <NEW_LINE> #ifdef DEBUG <NEW_LINE> static bool hasRun = false ; <NEW_LINE> MOZ_ASSERT ( ! hasRun ) ; <NEW_LINE> hasRun = true ; <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> mozHunspell::Init ( )
nsIContent * aContent1 , <NEW_LINE> nsIContent * aContent2 , <NEW_LINE> PRInt32 aStateMask ) <NEW_LINE> { <NEW_LINE> NS_PRECONDITION ( ! mIsDocumentGone , "Unexpected ContentStatesChanged" ) ; <NEW_LINE> NS_PRECONDITION ( aDocument == mDocument , "Unexpected aDocument" ) ; <NEW_LINE> if ( mDidInitialReflow ) { <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE> <END_VULN> mFrameConstructor -> ContentStatesChanged ( aContent1 , aContent2 , aStateMask ) ; <NEW_LINE> VERIFY_STYLE_TREE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> PresShell::AttributeChanged ( nsIDocument * aDocument ,
DOMArrayBufferBase * toTransfer = arrayBuffers [ i ] ; <NEW_LINE> if ( ! isNeuterable ) <NEW_LINE> <START_VULN> toTransfer = DOMArrayBuffer::create ( arrayBuffers [ i ] -> buffer ( ) ) ; <NEW_LINE> <END_VULN> bool result = toTransfer -> transfer ( contents -> at ( i ) ) ; <NEW_LINE> if ( ! result ) { <NEW_LINE> exceptionState . throwDOMException ( DataCloneError , "ArrayBuffer at index " + String::number ( i ) + " could not be transferred . " ) ;
cues [ i ] = cue_entries_ [ i ] ; <NEW_LINE> } <NEW_LINE> <START_VULN> delete [ ] cue_entries_ ; <NEW_LINE> <END_VULN> cue_entries_ = cues ; <NEW_LINE> cue_entries_capacity_ = new_capacity ;
for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { <NEW_LINE> count [ i ] = 0 ; <NEW_LINE> for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j ) <NEW_LINE> <START_VULN> count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ; <NEW_LINE> <END_VULN> c += ( count [ i ] > 0 ) ; <NEW_LINE> } <NEW_LINE> if ( c == 1 ) {
} <NEW_LINE> static void read_coef_probs ( FRAME_CONTEXT * fc , TX_MODE tx_mode , <NEW_LINE> <START_VULN> vp9_reader * r ) { <NEW_LINE> <END_VULN> const TX_SIZE max_tx_size = tx_mode_to_biggest_tx_size [ tx_mode ] ; <NEW_LINE> TX_SIZE tx_size ; <NEW_LINE> for ( tx_size = TX_4X4 ; tx_size <= max_tx_size ; ++ tx_size )
if ( result > 0 ) <NEW_LINE> return result ; <NEW_LINE> <START_VULN> assert ( len > 0 ) ; <NEW_LINE>assert ( len <= 8 ) ; <NEW_LINE> <END_VULN> if ( ( total >= 0 ) && ( ( total - pos ) < len ) ) <NEW_LINE> return E_FILE_FORMAT_INVALID ;
* bp = false ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> JSAutoCompartment ac ( cx , wrapper ) ; <NEW_LINE> * bp = Policy::deny ( cx , id , act ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> * bp = true ; <NEW_LINE> <START_VULN> return Base::enter ( cx , wrapper , id , act , bp ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #define SOW FilteringWrapper < CrossCompartmentSecurityWrapper , OnlyIfSubjectIsSystem > <NEW_LINE> #define SCSOW FilteringWrapper < SameCompartmentSecurityWrapper , OnlyIfSubjectIsSystem > <NEW_LINE> #define XOW FilteringWrapper < SecurityXrayXPCWN , CrossOriginAccessiblePropertiesOnly > <NEW_LINE> #define DXOW FilteringWrapper < SecurityXrayDOM , CrossOriginAccessiblePropertiesOnly > <NEW_LINE> #define NNXOW FilteringWrapper < CrossCompartmentSecurityWrapper , CrossOriginAccessiblePropertiesOnly > <NEW_LINE> #define CW FilteringWrapper < SameCompartmentSecurityWrapper , ComponentsObjectPolicy >
nsRefPtr < nsHtml5OwningUTF16Buffer > heapBuffer ; <NEW_LINE> if ( stackBuffer . hasMore ( ) ) { <NEW_LINE> heapBuffer = stackBuffer . FalliblyCopyAsOwningBuffer ( ) ; <NEW_LINE> if ( ! heapBuffer ) { <NEW_LINE> <START_VULN> mExecutor -> MarkAsBroken ( ) ; <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> if ( heapBuffer ) { <NEW_LINE> if ( aKey ) {
} else { <NEW_LINE> for ( i = 0 ; i < s -> entries ; i ++ ) { <NEW_LINE> long num = oggpack_read ( opb , 5 ) ; <NEW_LINE> if ( num == - 1 ) goto _eofout ; <NEW_LINE> s -> lengthlist [ i ] = num + 1 ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 1: <NEW_LINE> { <NEW_LINE> long length = oggpack_read ( opb , 5 ) + 1 ; <NEW_LINE> s -> lengthlist = _ogg_malloc ( sizeof ( * s -> lengthlist ) * s -> entries ) ; <NEW_LINE> for ( i = 0 ; i < s -> entries ; ) {
{ <NEW_LINE> INC_STATS ( "DOM . TestCustomNamedGetter . anotherFunction" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestCustomNamedGetter * imp = V8TestCustomNamedGetter::toNative ( args . Holder ( ) ) ; <NEW_LINE> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , str , MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ; <NEW_LINE> imp -> anotherFunction ( str ) ;
appendImages ( & appended , imageList . begin ( ) , imageList . end ( ) , true ) ; <NEW_LINE> if ( ( appended . signature ( ) != "d73d25ccd6011936d08b6d0d89183b7a61790544c2195269aff4db2f782ffc08" ) && <NEW_LINE> <START_VULN> ( appended . signature ( ) != "0909f7ffa7c6ea410fb2ebfdbcb19d61b19c4bd271851ce3bd51662519dc2b58" ) && <NEW_LINE> <END_VULN> ( appended . signature ( ) != "11b97ba6ac1664aa1c2faed4c86195472ae9cce2ed75402d975bb4ffcf1de751" ) && <NEW_LINE> ( appended . signature ( ) != "cae4815eeb3cb689e73b94d897a9957d3414d1d4f513e8b5e52579b05d164bfe" ) ) <NEW_LINE> {
} <NEW_LINE> <START_VULN> Convert_art ( & dls , & defaultArt , 0 ) ; <NEW_LINE>dls . artCount = 1 ; <NEW_LINE> <END_VULN> dls . regionCount = dls . instCount = 0 ;
if ( ! aprin || ! bprin ) <NEW_LINE> return true ; <NEW_LINE> bool subsumes ; <NEW_LINE> <START_VULN> nsresult rv = aprin -> SubsumesIgnoringDomain ( bprin , & subsumes ) ; <NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( rv , false ) ; <NEW_LINE> return subsumes ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> AccessCheck::isLocationObjectSameOrigin ( JSContext * cx , JSObject * wrapper ) <NEW_LINE> {
break ; <NEW_LINE> if ( aFrag -> CharAt ( iter . GetOriginalOffset ( ) ) == CH_SHY ) <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> static void <NEW_LINE> <START_VULN> RemoveInFlows ( nsIFrame * aFrame , nsIFrame * aFirstToNotRemove ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_PRECONDITION ( aFrame != aFirstToNotRemove , "This will go very badly" ) ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . methodWithNonCallbackArgAndCallbackArg" ) ; <NEW_LINE> if ( args . Length ( ) < 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( int , nonCallback , toInt32 ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( args . Length ( ) <= 1 || ! args [ 1 ] -> IsFunction ( ) )
std::string GetEnterpriseDomain ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>void DeviceStopAutoRetry ( ) ; <NEW_LINE> <END_VULN> void FetchDevicePolicy ( ) ;
#include < jni . h > <NEW_LINE> #include "base / android / scoped_java_ref . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "ui / gl / gl_export . h" <NEW_LINE> namespace gl {
{ <NEW_LINE> nsCOMPtr < FrameNeededWorker > worker = new FrameNeededWorker ( image ) ; <NEW_LINE> NS_DispatchToMainThread ( worker ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> RasterImage::FrameNeededWorker::Run ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> MutexAutoLock lock ( mImage -> mDecodingMutex ) ; <NEW_LINE> <END_VULN> nsresult rv = NS_OK ; <NEW_LINE> if ( mImage -> mDecoder && mImage -> mDecoder -> NeedsNewFrame ( ) ) { <NEW_LINE> rv = mImage -> mDecoder -> AllocateFrame ( ) ; <NEW_LINE> mImage -> mDecodeRequest -> mAllocatedNewFrame = true ; <NEW_LINE> }
static String HHVM_FUNCTION ( bcsub , const String & left , const String & right , <NEW_LINE> int64_t scale ) { <NEW_LINE> <START_VULN> if ( scale < 0 ) scale = BCG ( bc_precision ) ; <NEW_LINE> <END_VULN> bc_num first , second , result ; <NEW_LINE> bc_init_num ( & first ) ; <NEW_LINE> bc_init_num ( & second ) ;
static void handleMetaReferrer ( const String & attributeValue , CachedDocumentParameters * documentParameters , CSSPreloadScanner * cssScanner ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( attributeValue . isEmpty ( ) || attributeValue . isNull ( ) || ! SecurityPolicy::referrerPolicyFromString ( attributeValue , & documentParameters -> referrerPolicy ) ) { <NEW_LINE>documentParameters -> referrerPolicy = ReferrerPolicyDefault ; <NEW_LINE> <END_VULN> } <NEW_LINE> cssScanner -> setReferrerPolicy ( documentParameters -> referrerPolicy ) ; <NEW_LINE> }
while ( filt_val < max_filter_level ) <NEW_LINE> { <NEW_LINE> <START_VULN> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <NEW_LINE> <END_VULN> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ;
return false ; <NEW_LINE> #ifdef ANDROID <NEW_LINE> <START_VULN> __android_log_print ( ANDROID_LOG_INFO , "Gecko" , bytes . ptr ( ) ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> fputs ( bytes . ptr ( ) , gOutFile ) ; <NEW_LINE> fflush ( gOutFile ) ;
if ( ! isReadTypeValid ) <NEW_LINE> return ErrorInvalidEnum ( "readPixels: Bad type" , type ) ; <NEW_LINE> <START_VULN> int dataType = JS_GetArrayBufferViewType ( pixels . Value ( ) . Obj ( ) ) ; <NEW_LINE> <END_VULN> if ( dataType != requiredDataType )
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> AutoRestore < PRUint32 > loadTypeResetter ( mLoadType ) ; <NEW_LINE> <START_VULN> mLoadType = aLoadType ; <NEW_LINE> <END_VULN> mURIResultedInDocument = true ; <NEW_LINE> SetHistoryEntry ( & mLSHE , aSHEntry ) ;
pixel_size = bit_size ( pp , colour_type , bit_depth ) ; <NEW_LINE> if ( png_get_rowbytes ( pp , pi ) != ( ( w * pixel_size ) + 7 ) / 8 ) <NEW_LINE> <START_VULN> png_error ( pp , "row size incorrect" ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> {
} <NEW_LINE> static vpx_codec_err_t vp8e_get_reference ( vpx_codec_alg_priv_t * ctx , <NEW_LINE> <START_VULN> int ctr_id , <NEW_LINE>va_list args ) <NEW_LINE> <END_VULN> { <NEW_LINE> vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ;
int use_nonrd_pick_mode ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>int encode_breakout_thresh ; <NEW_LINE><NEW_LINE><NEW_LINE>int disable_inter_mode_mask [ BLOCK_SIZES ] ; <NEW_LINE> <END_VULN>
if ( ! wpmap ) { <NEW_LINE> wpmap = cx -> runtime -> new_ < WatchpointMap > ( ) ; <NEW_LINE> if ( ! wpmap || ! wpmap -> init ( ) ) { <NEW_LINE> js_ReportOutOfMemory ( cx ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> cx -> compartment -> watchpointMap = wpmap ; <NEW_LINE> } <NEW_LINE> <START_VULN> return wpmap -> watch ( cx , obj , id , handler , closure ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_PUBLIC_API ( JSBool ) <NEW_LINE> JS_ClearWatchPoint ( JSContext * cx , JSObject * obj , jsid id , <NEW_LINE> JSWatchPointHandler * handlerp , JSObject ** closurep ) <NEW_LINE> { <NEW_LINE> assertSameCompartment ( cx , obj , id ) ;
#include "content / public / browser / web_contents_user_data . h" <NEW_LINE> class PasswordAccessoryController ; <NEW_LINE> class ManualFillingControllerImpl <NEW_LINE> : public ManualFillingController , <NEW_LINE> public content::WebContentsUserData < ManualFillingControllerImpl > { <NEW_LINE> public: <NEW_LINE> <START_VULN> <NEW_LINE>ManualFillingControllerImpl ( <NEW_LINE>content::WebContents * web_contents , <NEW_LINE>base::WeakPtr < PasswordAccessoryController > pwd_controller , <NEW_LINE>std::unique_ptr < ManualFillingViewInterface > view ) ; <NEW_LINE> <END_VULN> ~ ManualFillingControllerImpl ( ) override ;
addr = ( void * ) ( ( ( size_t * ) memblk ) [ - 1 ] ) ; <NEW_LINE> memblk = NULL ; <NEW_LINE> <START_VULN> #if CONFIG_MEM_MANAGER <NEW_LINE>new_addr = vpx_mm_realloc ( addr , size + align + ADDRESS_STORAGE_SIZE ) ; <NEW_LINE>#else <NEW_LINE>new_addr = VPX_REALLOC_L ( addr , size + align + ADDRESS_STORAGE_SIZE ) ; <NEW_LINE>#endif <NEW_LINE> <END_VULN> if ( new_addr ) { <NEW_LINE> addr = new_addr ;
PR_BEGIN_MACRO \ <NEW_LINE> if ( ! mPolicies [ p ] -> allows ( nsIContentPolicy::TYPE_ ## contentPolicyType , \ <NEW_LINE> keyword , nonceOrHash ) ) \ <NEW_LINE> { \ <NEW_LINE> nsAutoString violatedDirective ; \ <NEW_LINE> mPolicies [ p ] -> getDirectiveStringForContentType ( \ <NEW_LINE> nsIContentPolicy::TYPE_ ## contentPolicyType , \ <NEW_LINE> violatedDirective ) ; \ <NEW_LINE> <START_VULN> this -> AsyncReportViolation ( selfISupports , mSelfURI , violatedDirective , p , \ <NEW_LINE> <END_VULN> NS_LITERAL_STRING ( observerTopic ) , \ <NEW_LINE> aSourceFile , aScriptSample , aLineNum ) ; \ <NEW_LINE> } \ <NEW_LINE> PR_END_MACRO ; \ <NEW_LINE> break <NEW_LINE> nsresult <NEW_LINE> nsCSPContext::SendReports ( nsISupports * aBlockedContentSource , <NEW_LINE> nsIURI * aOriginalURI , <NEW_LINE> nsAString & aViolatedDirective , <NEW_LINE> uint32_t aViolatedPolicyIndex , <NEW_LINE> nsAString & aSourceFile , <NEW_LINE> nsAString & aScriptSample , <NEW_LINE> uint32_t aLineNum )
NS_WARNING ( "No context reachable in GetContextAndScopes ( ) ! " ) ; <NEW_LINE> return NS_ERROR_NOT_AVAILABLE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> * aCx = cx ; <NEW_LINE> <START_VULN> * aOldScope = oldScope ; <NEW_LINE> <END_VULN> * aNewScope = newScope ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsContentUtils::ReparentContentWrappersInScope ( nsIScriptGlobalObject * aOldScope , <NEW_LINE> nsIScriptGlobalObject * aNewScope )
void inheritFrom ( const SVGRenderStyle * ) ; <NEW_LINE> void copyNonInheritedFrom ( const SVGRenderStyle * ) ; <NEW_LINE> <START_VULN> StyleDifference diff ( const SVGRenderStyle * ) const ; <NEW_LINE> <END_VULN> bool operator == ( const SVGRenderStyle & ) const ; <NEW_LINE> bool operator != ( const SVGRenderStyle & o ) const { return ! ( * this == o ) ; }
void Track::set_codec_id ( const char * codec_id ) { <NEW_LINE> if ( codec_id ) { <NEW_LINE> <START_VULN> delete [ ] codec_id_ ; <NEW_LINE> <END_VULN> const size_t length = strlen ( codec_id ) + 1 ; <NEW_LINE> codec_id_ = new ( std::nothrow ) char [ length ] ;
if ( ! canAttachReadSlot ( cx , obj , & holder , & shape ) ) <NEW_LINE> return true ; <NEW_LINE> DispatchStubPrepender attacher ( * this ) ; <NEW_LINE> MacroAssembler masm ( cx ) ; <NEW_LINE> GenerateReadSlot ( cx , ion , masm , attacher , obj , name ( ) , holder , shape , object ( ) , output ( ) ) ; <NEW_LINE> <START_VULN> const char * attachKind = "parallel non - idempotent reading" ; <NEW_LINE>if ( idempotent ( ) ) <NEW_LINE>attachKind = "parallel idempotent reading" ; <NEW_LINE><NEW_LINE>if ( ! linkAndAttachStub ( cx , masm , attacher , ion , attachKind ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> * attachedStub = true ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> ParallelResult <NEW_LINE> ParallelGetPropertyIC::update ( ForkJoinSlice * slice , size_t cacheIndex ,
MprJson * result ; <NEW_LINE> if ( key && ! strpbrk ( key , " . [ ] * " ) ) { <NEW_LINE> <START_VULN> return mprLookupJsonObj ( obj , key ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ( result = mprQueryJson ( obj , key , 0 , 0 ) ) != 0 && result -> children ) { <NEW_LINE> return result -> children ;
<START_VULN> if ( r -> m_object -> isPositioned ( ) ) <NEW_LINE> <END_VULN> r -> m_box -> setLogicalTop ( logicalHeight ( ) ) ;
calcBitmask ( mBitFields . blue , begin , length ) ; <NEW_LINE> mBitFields . blueRightShift = begin ; <NEW_LINE> mBitFields . blueLeftShift = 8 - length ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> <START_VULN> nsBMPDecoder::WriteInternal ( const char * aBuffer , uint32_t aCount ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ABORT_IF_FALSE ( ! HasError ( ) , "Shouldn't call WriteInternal after error ! " ) ; <NEW_LINE> if ( ! aCount || ! mCurLine ) <NEW_LINE> return ; <NEW_LINE> if ( mPos < BFH_INTERNAL_LENGTH ) {
int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) <NEW_LINE> { <NEW_LINE> <START_VULN> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <NEW_LINE> <END_VULN> unsigned char * channel_identities = NULL ; <NEW_LINE> unsigned char * channel_reorder = NULL ; <NEW_LINE> int64_t total_samples = 0 , infilesize ;
<START_VULN> bool canPropagateFloatIntoSibling = ! isFloatingOrPositioned ( ) && ! avoidsFloats ( ) ; <NEW_LINE> <END_VULN> if ( diff == StyleDifferenceLayout && s_canPropagateFloatIntoSibling && ! canPropagateFloatIntoSibling && hasOverhangingFloats ( ) ) { <NEW_LINE> RenderBlock * parentBlock = this ; <NEW_LINE> const FloatingObjectSet & floatingObjectSet = m_floatingObjects -> set ( ) ;
case MenuItemRadioRole: <NEW_LINE> case RadioButtonRole: <NEW_LINE> case SwitchRole: <NEW_LINE> <START_VULN> if ( equalIgnoringCase ( <NEW_LINE> <END_VULN> getAOMPropertyOrARIAAttribute ( AOMStringProperty::kChecked ) , <NEW_LINE> "true" ) ) <NEW_LINE> return true ;
ret = 1 ; <NEW_LINE> <START_VULN> cms -> d . envelopedData -> encryptedContentInfo -> key = ek ; <NEW_LINE>cms -> d . envelopedData -> encryptedContentInfo -> keylen = eklen ; <NEW_LINE> <END_VULN> err: <NEW_LINE> if ( pctx )
static uint32_t <NEW_LINE> sanityCheck ( const uint8_t * woffData , uint32_t woffLen ) <NEW_LINE> { <NEW_LINE> const woffHeader * header ; <NEW_LINE> uint16_t numTables , i ; <NEW_LINE> const woffDirEntry * dirEntry ; <NEW_LINE> <START_VULN> uint32_t tableTotal = 0 ; <NEW_LINE> <END_VULN> if ( ! woffData || ! woffLen ) { <NEW_LINE> return eWOFF_bad_parameter ; <NEW_LINE> } <NEW_LINE> if ( woffLen < sizeof ( woffHeader ) ) { <NEW_LINE> return eWOFF_invalid ; <NEW_LINE> }
nsIPrincipal * originPrincipal , <NEW_LINE> nsISupports * context , <NEW_LINE> const nsACString & mimeType , <NEW_LINE> nsISupports * extra , <NEW_LINE> int16_t * decision , <NEW_LINE> nsIContentPolicy * policyService = nullptr , <NEW_LINE> nsIScriptSecurityManager * aSecMan = nullptr ) <NEW_LINE> { <NEW_LINE> <START_VULN> CHECK_PRINCIPAL ; <NEW_LINE> <END_VULN> if ( policyService ) { <NEW_LINE> CHECK_CONTENT_POLICY_WITH_SERVICE ( ShouldLoad , policyService ) ; <NEW_LINE> } <NEW_LINE> CHECK_CONTENT_POLICY ( ShouldLoad ) ; <NEW_LINE> }
PP_Bool ( * HandleInputEvent ) ( PP_Instance instance , PP_Resource input_event ) ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
unsigned int first_corrupt ) <NEW_LINE> { <NEW_LINE> int mb_row , mb_col ; <NEW_LINE> <START_VULN> vpx_memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ; <NEW_LINE> <END_VULN> for ( mb_row = 0 ; mb_row < mb_rows ; ++ mb_row ) <NEW_LINE> {
private: <NEW_LINE> class UserState { <NEW_LINE> public: <NEW_LINE> <START_VULN> explicit UserState ( AccountId account_id ) ; <NEW_LINE> <END_VULN> UserState ( UserState && ) ; <NEW_LINE> ~ UserState ( ) ;
JSObject * tmp ; <NEW_LINE> if ( ! JS_GetReservedSlot ( cx , JSVAL_TO_OBJECT ( argv [ - 2 ] ) , 0 , & fsv ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> fs = ( JSFunctionSpec * ) JSVAL_TO_PRIVATE ( fsv ) ; <NEW_LINE> JS_ASSERT ( ( fs -> flags & ( JSFUN_FAST_NATIVE | JSFUN_GENERIC_NATIVE ) ) == <NEW_LINE> JSFUN_GENERIC_NATIVE ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( JSVAL_IS_PRIMITIVE ( argv [ 0 ] ) ) { <NEW_LINE> if ( ! js_ValueToObject ( cx , argv [ 0 ] , & tmp ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> argv [ 0 ] = OBJECT_TO_JSVAL ( tmp ) ;
return ( H264SWDEC_PARAM_ERR ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) ) ; <NEW_LINE> <END_VULN> if ( pDecCont == NULL ) <NEW_LINE> {
uint32_t * GetImageData ( ) ; <NEW_LINE> int32_t GetCompressedImageSize ( ) const ; <NEW_LINE> bool HasAlphaData ( ) const ; <NEW_LINE> <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> virtual void FinishInternal ( ) ; <NEW_LINE> private: <NEW_LINE> NS_METHOD CalcBitShift ( ) ;
#include "core / platform / graphics / SimpleFontData . h" <NEW_LINE> #include "core / platform / graphics / chromium / FontPlatformDataChromiumWin . h" <NEW_LINE> #include "core / platform / graphics / chromium / FontUtilsChromiumWin . h" <NEW_LINE> <START_VULN> #include "core / platform / win / HWndDC . h" <NEW_LINE> <END_VULN> #include "platform / LayoutTestSupport . h" <NEW_LINE> #include "wtf / HashMap . h" <NEW_LINE> #include "wtf / HashSet . h" <NEW_LINE> #include "wtf / text / StringHash . h"
int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) <NEW_LINE> { <NEW_LINE> <START_VULN> int is_rf64 = ! strncmp ( fourcc , "RF64" , 4 ) , got_ds64 = 0 ; <NEW_LINE> <END_VULN> int64_t total_samples = 0 , infilesize ; <NEW_LINE> RiffChunkHeader riff_chunk_header ; <NEW_LINE> ChunkHeader chunk_header ;
if ( mHasBeenDecoded && mDecoder && <NEW_LINE> mLockCount == 0 && CanForciblyDiscard ( ) ) { <NEW_LINE> PR_LOG ( GetCompressedImageAccountingLog ( ) , PR_LOG_DEBUG , <NEW_LINE> ( "RasterImage [ 0x % p ] canceling decode because image " <NEW_LINE> "is now unlocked . " , this ) ) ; <NEW_LINE> <START_VULN> MutexAutoLock lock ( mDecodingMutex ) ; <NEW_LINE> <END_VULN> FinishedSomeDecoding ( eShutdownIntent_NotNeeded ) ; <NEW_LINE> ForceDiscard ( ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> if ( CanDiscard ( ) ) {
& PluginModuleParent::NotifyPluginCrashed ) ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> case NormalShutdown: <NEW_LINE> mShutdown = true ; <NEW_LINE> break ; <NEW_LINE> default: <NEW_LINE> <START_VULN> NS_ERROR ( "Unexpected shutdown reason for toplevel actor . " ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> PluginModuleParent::NotifyPluginCrashed ( ) <NEW_LINE> { <NEW_LINE> if ( ! OkToCleanup ( ) ) {
kw_value_len = uloc_getKeywordValue ( loc_name , kw_key , kw_value , kw_value_len + 1 , & status ) ; <NEW_LINE> } else if ( ! U_FAILURE ( status ) ) { <NEW_LINE> kw_value = erealloc ( kw_value , kw_value_len + 1 ) ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> if ( U_FAILURE ( status ) ) { <NEW_LINE> intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "locale_get_keywords: Error encountered while getting the keyword value for the keyword" , 0 TSRMLS_CC ) ; <NEW_LINE> if ( kw_value ) {
#include < string . h > <NEW_LINE> #include "allheaders . h" <NEW_LINE> <START_VULN> static const l_int32 L_BUF_SIZE = 512 ; <NEW_LINE> <END_VULN> const char * gplotstylenames [ ] = { "with lines" , <NEW_LINE> "with points" ,
<START_VULN> fread ( image_data , 1L , rowbytes * height , saved_infile ) ; <NEW_LINE><NEW_LINE> <END_VULN> return image_data ; <NEW_LINE> }
info_ptr -> text [ i ] . lang , <NEW_LINE> info_ptr -> text [ i ] . lang_key , <NEW_LINE> info_ptr -> text [ i ] . text ) ; <NEW_LINE> #else <NEW_LINE> png_warning ( png_ptr , "Unable to write international text" ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE>info_ptr -> text [ i ] . compression = PNG_TEXT_COMPRESSION_NONE_WR ; <NEW_LINE> <END_VULN> } <NEW_LINE> else if ( info_ptr -> text [ i ] . compression >= PNG_TEXT_COMPRESSION_zTXt )
} <NEW_LINE> <START_VULN> else if ( ! ( png_ptr -> flags & PNG_FLAG_CRC_ANCILLARY_NOWARN ) ) <NEW_LINE> <END_VULN> png_chunk_warning ( png_ptr , "CRC error" ) ; <NEW_LINE> } <NEW_LINE> #endif
<START_VULN> vpx_memset ( ybf , 0 , sizeof ( YV12_BUFFER_CONFIG ) ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> return - 1 ; <NEW_LINE> }
ret = FAIL ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> new_charset_name = mnd_pestrdup ( value , conn -> persistent ) ; <NEW_LINE> if ( ! new_charset_name ) { <NEW_LINE> goto oom ;
memset ( image , 0xff , sizeof image ) ; <NEW_LINE> <START_VULN> if ( ! do_interlace && npasses != png_set_interlace_handling ( pp ) ) <NEW_LINE> <END_VULN> png_error ( pp , "write: png_set_interlace_handling failed" ) ;
{ <NEW_LINE> ALOGV ( "setDataSource" ) ; <NEW_LINE> status_t err = UNKNOWN_ERROR ; <NEW_LINE> <START_VULN> const sp < IMediaPlayerService > & service ( getMediaPlayerService ( ) ) ; <NEW_LINE> <END_VULN> if ( service != 0 ) { <NEW_LINE> sp < IMediaPlayer > player ( service -> create ( this , mAudioSessionId ) ) ; <NEW_LINE> if ( ( NO_ERROR != doSetRetransmitEndpoint ( player ) ) ||
if ( ret < 0 ) <NEW_LINE> hid_err ( hdev , "error setting GPIO values: % d\n" , ret ) ; <NEW_LINE> <START_VULN> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int cp2112_gpio_get_all ( struct gpio_chip * chip )
nsCOMPtr < nsIPresShell > shell ; <NEW_LINE> nsDocShell::GetPresShell ( getter_AddRefs ( shell ) ) ; <NEW_LINE> nsIViewManager * newVM = shell ? shell -> GetViewManager ( ) : nsnull ; <NEW_LINE> nsIView * newRootView = newVM ? newVM -> GetRootView ( ) : nsnull ; <NEW_LINE> <START_VULN> if ( rootViewParent ) { <NEW_LINE>nsIViewManager * parentVM = rootViewParent -> GetViewManager ( ) ; <NEW_LINE><NEW_LINE>if ( parentVM && newRootView ) { <NEW_LINE> <END_VULN> parentVM -> InsertChild ( rootViewParent , newRootView ,
int from_kernel = ( regs -> tstate & TSTATE_PRIV ) != 0 ; <NEW_LINE> unsigned long * reg ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <NEW_LINE> <END_VULN> maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; <NEW_LINE> reg = fetch_reg_addr ( rd , regs ) ;
return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> JSJavaThreadState * jsj_env = NULL ; <NEW_LINE> JSObjectHandle * handle = ( JSObjectHandle * ) obj ; <NEW_LINE> JSObject * js_obj = handle -> js_obj ; <NEW_LINE> JSContext * cx = NULL ; <NEW_LINE> jsval js_val ; <NEW_LINE> JSErrorReporter saved_state = NULL ; <NEW_LINE> jsj_env = jsj_enter_js ( jEnv , mJavaClient , NULL , & cx , NULL , & saved_state , principalsArray , numPrincipals , securitySupports ) ; <NEW_LINE> if ( ! jsj_env ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> <START_VULN> AutoPushJSContext autopush ( securitySupports , cx ) ; <NEW_LINE>if ( NS_FAILED ( autopush . ResultOfPush ( ) ) ) <NEW_LINE>goto done ; <NEW_LINE><NEW_LINE> <END_VULN> if ( ! name ) { <NEW_LINE> JS_ReportError ( cx , "illegal null member name" ) ; <NEW_LINE> goto done ; <NEW_LINE> } <NEW_LINE> JS_DeleteUCProperty2 ( cx , js_obj , name , length , & js_val ) ; <NEW_LINE> done: <NEW_LINE> jsj_exit_js ( cx , jsj_env , saved_state ) ; <NEW_LINE> return NS_OK ;
{ <NEW_LINE> cchar * value ; <NEW_LINE> <START_VULN> value = mprLookupJson ( httpGetParams ( conn ) , var ) ; <NEW_LINE> <END_VULN> return ( value ) ? ( int ) stoi ( value ) : defaultValue ; <NEW_LINE> }
# define SSL_CLIENT_USE_SIGALGS ( s ) \ <NEW_LINE> SSL_CLIENT_USE_TLS1_2_CIPHERS ( s ) <NEW_LINE> <START_VULN> # define SSL_USE_ETM ( s ) ( s -> s3 -> flags & TLS1_FLAGS_ENCRYPT_THEN_MAC ) <NEW_LINE> <END_VULN> # define SSL_PKEY_RSA_ENC 0
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: libvorbis codec headers <NEW_LINE> <START_VULN> last mod: $ Id: codec_internal . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_CODECI_H_ <NEW_LINE> #define _V_CODECI_H_ <NEW_LINE> #include "envelope . h" <NEW_LINE> #include "codebook . h"
double kf_group_coded_err = 0 . 0 ; <NEW_LINE> double recent_loop_decay [ 8 ] = { 1 . 0 , 1 . 0 , 1 . 0 , 1 . 0 , 1 . 0 , 1 . 0 , 1 . 0 , 1 . 0 } ; <NEW_LINE> <START_VULN> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <NEW_LINE> <END_VULN> vp8_clear_system_state ( ) ; <NEW_LINE> start_position = cpi -> twopass . stats_in ;
JS_STATIC_DLL_CALLBACK ( JSBool ) <NEW_LINE> XPC_NW_Convert ( JSContext * cx , JSObject * obj , JSType type , jsval * vp ) <NEW_LINE> { <NEW_LINE> XPC_NW_BYPASS ( cx , obj , convert , ( cx , obj , type , vp ) ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return JS_TRUE ; <NEW_LINE> }
Node ** array = reinterpret_cast < Node ** > ( self ) ; <NEW_LINE> blink::HeapObjectHeader * header = <NEW_LINE> blink::HeapObjectHeader::fromPayload ( self ) ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> size_t length = header -> payloadSize ( ) / sizeof ( Node * ) ; <NEW_LINE> for ( size_t i = 0 ; i < length ; ++ i ) { <NEW_LINE> if ( ! HashTableHelper < Node * , typename Table::ExtractorType ,
<START_VULN> typedef base::Callback < void ( DecoderStatus , scoped_refptr < VideoFrame > ) > ReadCB ; <NEW_LINE> <END_VULN> virtual void Read ( const ReadCB & read_cb ) = 0 ;
#ifdef PNG_READ_EXPAND_SUPPORTED <NEW_LINE> static void <NEW_LINE> <START_VULN> image_transform_png_set_palette_to_rgb_set ( PNG_CONST image_transform * this , <NEW_LINE> <END_VULN> transform_display * that , png_structp pp , png_infop pi ) <NEW_LINE> { <NEW_LINE> png_set_palette_to_rgb ( pp ) ;
cx = nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE> } <NEW_LINE> mAr . construct ( cx ) ; <NEW_LINE> <START_VULN> if ( ! mCxPusher . Push ( cx ) ) { <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE> <END_VULN> mCtx = ctx ;
return ; <NEW_LINE> #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED <NEW_LINE> <START_VULN> if ( png_ptr -> transformations & PNG_USER_TRANSFORM ) <NEW_LINE> <END_VULN> if ( png_ptr -> write_user_transform_fn != NULL ) <NEW_LINE> ( * ( png_ptr -> write_user_transform_fn ) )
if ( ! mHasSize ) { <NEW_LINE> mWantFullDecode = true ; <NEW_LINE> return NS_ERROR_NOT_AVAILABLE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> MutexAutoLock imgLock ( mDecodingMutex ) ; <NEW_LINE> <END_VULN> NS_ABORT_IF_FALSE ( ! mInDecoder , "Yikes , forcing sync in reentrant call ! " ) ; <NEW_LINE> if ( mDecodeRequest ) {
<START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 85 ) <NEW_LINE> <END_VULN>
} <NEW_LINE> ret = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> free ( tmpstr ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return ret ;
int ji ; <NEW_LINE> for ( ITERATE_CONFIG ( route , prop , child , ji ) ) { <NEW_LINE> <START_VULN> if ( mprGetJson ( route -> config , sfmt ( "app . http . content . minify [ @ = ' % s' ] " , child -> value ) ) ) { <NEW_LINE> <END_VULN> httpAddRouteMapping ( route , child -> value , " $ { 1 } . gz , min . $ { 1 } . gz , min . $ { 1 } " ) ; <NEW_LINE> } else { <NEW_LINE> httpAddRouteMapping ( route , child -> value , " $ { 1 } . gz" ) ;
NS_DispatchToCurrentThread ( new nsAsyncResize ( this ) ) ; <NEW_LINE> return eDropDownPositionPendingResize ; <NEW_LINE> } <NEW_LINE> <START_VULN> bool b = dropdownSize . height <= below || below >= above ; <NEW_LINE> <END_VULN> nsPoint dropdownPosition ( 0 , b ? GetRect ( ) . height : - dropdownSize . height ) ; <NEW_LINE> if ( StyleVisibility ( ) -> mDirection == NS_STYLE_DIRECTION_RTL ) { <NEW_LINE> dropdownPosition . x = GetRect ( ) . width - dropdownSize . width ; <NEW_LINE> }
if ( mDecoder ) { <NEW_LINE> nsresult rv = DecodePool::Singleton ( ) -> DecodeUntilSizeAvailable ( this ) ; <NEW_LINE> CONTAINER_ENSURE_SUCCESS ( rv ) ; <NEW_LINE> } <NEW_LINE> { <NEW_LINE> <START_VULN> MutexAutoLock lock ( mDecodingMutex ) ; <NEW_LINE> <END_VULN> if ( ! StoringSourceData ( ) && mDecoder ) { <NEW_LINE> nsresult rv = ShutdownDecoder ( eShutdownIntent_Done ) ; <NEW_LINE> CONTAINER_ENSURE_SUCCESS ( rv ) ; <NEW_LINE> }
int pnm_validate ( jas_stream_t * in ) <NEW_LINE> { <NEW_LINE> <START_VULN> uchar buf [ 2 ] ; <NEW_LINE> <END_VULN> int i ; <NEW_LINE> int n ;
SVGPathData & InternalList ( ) const ; <NEW_LINE> SVGAnimatedPathSegList & InternalAList ( ) const ; <NEW_LINE> <START_VULN> <NEW_LINE>void EnsureItemAt ( uint32_t aIndex ) ; <NEW_LINE> <END_VULN> void MaybeInsertNullInAnimValListAt ( uint32_t aIndex , <NEW_LINE> uint32_t aInternalIndex , <NEW_LINE> uint32_t aArgCountForItem ) ; <NEW_LINE> void MaybeRemoveItemFromAnimValListAt ( uint32_t aIndex , <NEW_LINE> int32_t aArgCountForItem ) ;
void Track::set_name ( const char * name ) { <NEW_LINE> if ( name ) { <NEW_LINE> <START_VULN> delete [ ] name_ ; <NEW_LINE> <END_VULN> const size_t length = strlen ( name ) + 1 ; <NEW_LINE> name_ = new ( std::nothrow ) char [ length ] ;
NS_DECL_ISUPPORTS_INHERITED <NEW_LINE> NS_DECL_NSIPROXIEDCHANNEL <NEW_LINE> nsIProxyInfo * ProxyInfo ( ) { return mProxyInfo ; } <NEW_LINE> protected: <NEW_LINE> virtual ~ nsGopherChannel ( ) { } <NEW_LINE> <START_VULN> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result ) ; <NEW_LINE> <END_VULN> virtual PRBool GetStatusArg ( nsresult status , nsString & statusArg ) ; <NEW_LINE> private: <NEW_LINE> nsresult SendRequest ( nsIOutputStream * stream ) ; <NEW_LINE> nsCOMPtr < nsIProxyInfo > mProxyInfo ; <NEW_LINE> } ;
PRInt32 GetContentLengthHint ( ) const { return mContentLengthHint ; } <NEW_LINE> PRInt32 GetInFlowContentLength ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>void ClearTextRun ( ) ; <NEW_LINE> <END_VULN> gfxSkipCharsIterator EnsureTextRun ( gfxContext * aReferenceContext = nsnull , <NEW_LINE> nsIFrame * aLineContainer = nsnull , <NEW_LINE> const nsLineList::iterator * aLine = nsnull , <NEW_LINE> PRUint32 * aFlowEndInTextRun = nsnull ) ; <NEW_LINE> gfxTextRun * GetTextRun ( ) { return mTextRun ; } <NEW_LINE> void SetTextRun ( gfxTextRun * aTextRun ) { mTextRun = aTextRun ; } <NEW_LINE> struct TrimmedOffsets { <NEW_LINE> PRInt32 mStart ; <NEW_LINE> PRInt32 mLength ; <NEW_LINE> PRInt32 GetEnd ( ) { return mStart + mLength ; }
<START_VULN> nsINode * startRoot = count == 0 ? mRootNode : <NEW_LINE>NS_STATIC_CAST ( nsIContent * , mElements . ElementAt ( count - 1 ) ) ; <NEW_LINE> <END_VULN> PopulateWithStartingAfter ( startRoot , nsnull , elementsToAppend ) ; <NEW_LINE> NS_ASSERTION ( elementsToAppend + mElements . Count ( ) == invariant ,
nsIWidget * parent = GetParent ( ) ; <NEW_LINE> if ( parent ) { <NEW_LINE> parent -> RemoveChild ( this ) ; <NEW_LINE> } <NEW_LINE> if ( mWnd ) { <NEW_LINE> <START_VULN> ::SetParent ( mWnd , nsnull ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsIWidget * nsWindow::GetParent ( void ) <NEW_LINE> { <NEW_LINE> return GetParentWindow ( PR_FALSE ) ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeContentView::GetCellValue ( PRInt32 aRow , nsITreeColumn * aCol , nsAString & _retval ) <NEW_LINE> { <NEW_LINE> _retval . Truncate ( ) ; <NEW_LINE> <START_VULN> NS_ENSURE_ARG_POINTER ( aCol ) ; <NEW_LINE> <END_VULN> NS_PRECONDITION ( aRow >= 0 && aRow < PRInt32 ( mRows . Length ( ) ) , "bad row" ) ; <NEW_LINE> if ( aRow < 0 || aRow >= PRInt32 ( mRows . Length ( ) ) ) <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> Row * row = mRows [ aRow ] ; <NEW_LINE> nsIContent * realRow = <NEW_LINE> nsTreeUtils::GetImmediateChild ( row -> mContent , nsGkAtoms::treerow ) ;
( void ) ResetMagickMemory ( & dib_info , 0 , sizeof ( dib_info ) ) ; <NEW_LINE> dib_info . size = ReadBlobLSBLong ( image ) ; <NEW_LINE> <START_VULN> if ( dib_info . size != 40 ) <NEW_LINE> <END_VULN> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE> Microsoft Windows 3 . X DIB image file .
if ( m . param & 0xF0 ) <NEW_LINE> { <NEW_LINE> chnMem . autoVolSlide = m . param >> 4 ; <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> } else <NEW_LINE> { <NEW_LINE> m . command = CMD_MODCMDEX ;
if ( args . Length ( ) < 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> XMLHttpRequest * xmlHttpRequest = V8XMLHttpRequest::toNative ( args . Holder ( ) ) ;
socket_t * socket_accept ( const socket_t * socket ) { <NEW_LINE> assert ( socket != NULL ) ; <NEW_LINE> <START_VULN> int fd = accept ( socket -> fd , NULL , NULL ) ; <NEW_LINE> <END_VULN> if ( fd == INVALID_FD ) { <NEW_LINE> LOG_ERROR ( " % s unable to accept socket: % s" , __func__ , strerror ( errno ) ) ; <NEW_LINE> return NULL ;
<START_VULN> * f <NEW_LINE> <END_VULN>
NS_IMETHODIMP <NEW_LINE> nsObjectLoadingContent::AsyncOnChannelRedirect ( nsIChannel * aOldChannel , <NEW_LINE> nsIChannel * aNewChannel , <NEW_LINE> PRUint32 aFlags , <NEW_LINE> nsIAsyncVerifyRedirectCallback * cb ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( aOldChannel != mChannel ) { <NEW_LINE> <END_VULN> return NS_BINDING_ABORTED ; <NEW_LINE> } <NEW_LINE> mChannel = aNewChannel ; <NEW_LINE> cb -> OnRedirectVerifyCallback ( NS_OK ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestEventTarget::s_info ) ; <NEW_LINE> TestEventTarget * impl = static_cast < TestEventTarget * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> Event * evt ( toEvent ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) )
NS_ENSURE_TRUE ( aSelState , false ) ; <NEW_LINE> PRUint32 i , myCount = mArray . Length ( ) , itsCount = aSelState -> mArray . Length ( ) ; <NEW_LINE> if ( myCount != itsCount ) return false ; <NEW_LINE> if ( myCount < 1 ) return false ; <NEW_LINE> for ( i = 0 ; i < myCount ; i ++ ) <NEW_LINE> { <NEW_LINE> nsCOMPtr < nsIDOMRange > myRange , itsRange ; <NEW_LINE> <START_VULN> mArray [ i ] . GetRange ( address_of ( myRange ) ) ; <NEW_LINE>aSelState -> mArray [ i ] . GetRange ( address_of ( itsRange ) ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( myRange && itsRange , false ) ; <NEW_LINE> PRInt16 compResult ; <NEW_LINE> nsresult rv ; <NEW_LINE> rv = myRange -> CompareBoundaryPoints ( nsIDOMRange::START_TO_START , itsRange , & compResult ) ; <NEW_LINE> if ( NS_FAILED ( rv ) || compResult ) return false ; <NEW_LINE> rv = myRange -> CompareBoundaryPoints ( nsIDOMRange::END_TO_END , itsRange , & compResult ) ; <NEW_LINE> if ( NS_FAILED ( rv ) || compResult ) return false ;
bool mSuppressEOF ; <NEW_LINE> bool mReadingFromStage ; <NEW_LINE> nsTArray < nsHtml5TreeOperation > mOpQueue ; <NEW_LINE> nsTArray < nsIContentPtr > mElementsSeenInThisAppendBatch ; <NEW_LINE> nsTArray < nsHtml5PendingNotification > mPendingNotifications ; <NEW_LINE> nsHtml5StreamParser * mStreamParser ; <NEW_LINE> <START_VULN> nsCOMArray < nsIContent > mOwnedElements ; <NEW_LINE> <END_VULN> nsTHashtable < nsCStringHashKey > mPreloadedURLs ; <NEW_LINE> nsCOMPtr < nsIURI > mSpeculationBaseURI ;
@param list List pointer returned from mprCreateList . <NEW_LINE> @param join String to use as the element join string . May be null . <NEW_LINE> @ingroup MprList <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC char * mprListToString ( MprList * list , cchar * join ) ;
LE_reset ( pContext ) ; <NEW_LINE> break ; <NEW_LINE> case EFFECT_CMD_ENABLE: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> } <NEW_LINE> if ( pContext -> mState != LOUDNESS_ENHANCER_STATE_INITIALIZED ) {
sem_t * semaphore = callbacks_get_semaphore ( #callback ) ; \ <NEW_LINE> while ( ! sem_trywait ( semaphore ) ) ; \ <NEW_LINE> expression ; \ <NEW_LINE> <START_VULN> sem_wait ( semaphore ) ; \ <NEW_LINE> <END_VULN> } while ( 0 )
} <NEW_LINE> IonCode * <NEW_LINE> IonRuntime::debugTrapHandler ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> if ( ! debugTrapHandler_ ) { <NEW_LINE> <START_VULN> AutoEnterAtomsCompartment ac ( cx ) ; <NEW_LINE> <END_VULN> debugTrapHandler_ = generateDebugTrapHandler ( cx ) ; <NEW_LINE> } <NEW_LINE> return debugTrapHandler_ ; <NEW_LINE> } <NEW_LINE> uint8_t * <NEW_LINE> IonRuntime::allocateOsrTempData ( size_t size ) <NEW_LINE> {
void * atomic_thread ( void * context ) { <NEW_LINE> struct atomic_test_s32_s * at = ( struct atomic_test_s32_s * ) context ; <NEW_LINE> for ( int i = 0 ; i < at -> max_val ; i ++ ) { <NEW_LINE> <START_VULN> usleep ( 1 ) ; <NEW_LINE> <END_VULN> atomic_inc_prefix_s32 ( & at -> data [ i ] ) ; <NEW_LINE> } <NEW_LINE> return NULL ;
{ <NEW_LINE> nsIWidget * refWidget = aReply . mReferenceWidget ; <NEW_LINE> if ( ! refWidget ) { <NEW_LINE> NS_WARNING ( "mReferenceWidget is null" ) ; <NEW_LINE> refWidget = this ; <NEW_LINE> } <NEW_LINE> nsWindow * refWindow = static_cast < nsWindow * > ( refWidget ) ; <NEW_LINE> <START_VULN> nsWindow * ownerWindow = IM_get_owning_window ( mDrawingarea ) ; <NEW_LINE> <END_VULN> if ( ! ownerWindow ) { <NEW_LINE> NS_ERROR ( "there is no owner" ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> gint refX , refY ; <NEW_LINE> gdk_window_get_origin ( refWindow -> mDrawingarea -> inner_window ,
if ( id == GetRTStringByIndex ( cx , XPCJSRuntime::IDX_WRAPPED_JSOBJECT ) ) { <NEW_LINE> return JS_TRUE ; <NEW_LINE> } <NEW_LINE> if ( id == GetRTStringByIndex ( cx , XPCJSRuntime::IDX_TO_STRING ) ) { <NEW_LINE> * objp = obj ; <NEW_LINE> <START_VULN> return JS_DefineFunction ( cx , obj , "toString" , <NEW_LINE>XPC_NW_toString , 0 , 0 ) != nsnull ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! EnsureLegalActivity ( cx , obj ) ) { <NEW_LINE> return JS_FALSE ; <NEW_LINE> }
v8::Local < v8::Value > argv [ ] = { v8Value } ; <NEW_LINE> v8::TryCatch block ( isolate ) ; <NEW_LINE> v8::Local < v8::Value > result ; <NEW_LINE> <START_VULN> if ( ! V8ScriptRunner::callFunction ( v8::Local < v8::Function > ::Cast ( setter ) , scriptState -> getExecutionContext ( ) , holder , WTF_ARRAY_LENGTH ( argv ) , argv , isolate ) . ToLocal ( & result ) ) { <NEW_LINE> <END_VULN> rethrowExceptionInPrivateScript ( isolate , block , scriptStateInUserScript , ExceptionState::SetterContext , attributeName , className ) ; <NEW_LINE> block . ReThrow ( ) ; <NEW_LINE> return false ;
nsCOMPtr < nsIContentIterator > iter = <NEW_LINE> do_CreateInstance ( "@mozilla . org / content / post - content - iterator ; 1" ) ; <NEW_LINE> NS_ENSURE_TRUE ( iter , NS_ERROR_NULL_POINTER ) ; <NEW_LINE> nsresult res = iter -> Init ( mDocChangeRange ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( res , res ) ; <NEW_LINE> nsCOMArray < nsINode > arrayOfEmptyNodes , arrayOfEmptyCites ; <NEW_LINE> <START_VULN> nsTArray < nsINode * > skipList ; <NEW_LINE> <END_VULN> while ( ! iter -> IsDone ( ) ) { <NEW_LINE> nsINode * node = iter -> GetCurrentNode ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( node , NS_ERROR_FAILURE ) ; <NEW_LINE> nsINode * parent = node -> GetNodeParent ( ) ;
EXPECT_TRUE ( sourceList . matches ( KURL ( base , "http: <NEW_LINE> EXPECT_TRUE ( sourceList . matches ( KURL ( base , "http: <NEW_LINE> EXPECT_TRUE ( sourceList . matches ( KURL ( base , "http: <NEW_LINE> EXPECT_FALSE ( sourceList . matches ( KURL ( base , "http: <NEW_LINE> <START_VULN> EXPECT_FALSE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE> <END_VULN> } <NEW_LINE> }
switch ( pkt -> u . add_sta . status ) { <NEW_LINE> case ADD_STA_SUCCESS_MSK: <NEW_LINE> IWL_DEBUG_INFO ( priv , "REPLY_ADD_STA PASSED\n" ) ; <NEW_LINE> <START_VULN> iwl_sta_ucode_activate ( priv , sta_id ) ; <NEW_LINE>ret = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case ADD_STA_NO_ROOM_IN_TABLE: <NEW_LINE> IWL_ERR ( priv , "Adding station % d failed , no room in table . \n" ,
class EncodedFormData ; <NEW_LINE> class ScriptState ; <NEW_LINE> <START_VULN> class MODULES_EXPORT BodyStreamBuffer final : public UnderlyingSourceBase , public UnderlyingSource , public WebDataConsumerHandle::Client { <NEW_LINE> <END_VULN> WTF_MAKE_NONCOPYABLE ( BodyStreamBuffer ) ; <NEW_LINE> USING_GARBAGE_COLLECTED_MIXIN ( BodyStreamBuffer ) ; <NEW_LINE> public:
} <NEW_LINE> else if ( aNotify && IsInDoc ( ) ) { <NEW_LINE> modification = ! ! mAttrsAndChildren . GetAttr ( nsGkAtoms::style ) ; <NEW_LINE> } <NEW_LINE> nsAttrValue attrValue ( aStyleRule ) ; <NEW_LINE> return SetAttrAndNotify ( kNameSpaceID_None , nsGkAtoms::style , nsnull , oldValueStr , <NEW_LINE> <START_VULN> attrValue , modification , hasListeners , aNotify ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsChangeHint <NEW_LINE> nsXULElement::GetAttributeChangeHint ( const nsIAtom * aAttribute , <NEW_LINE> PRInt32 aModType ) const <NEW_LINE> { <NEW_LINE> nsChangeHint retval ( NS_STYLE_HINT_NONE ) ;
unsigned bytes_per_pixel = components_per_pixel * bytes_per_component ; <NEW_LINE> data . resize ( width * height * bytes_per_pixel ) ; <NEW_LINE> <START_VULN> if ( ! PackPixels ( static_cast < const uint8_t * > ( pixels ) , source_data_format , <NEW_LINE>width , height , IntRect ( 0 , 0 , width , height ) , 1 , <NEW_LINE>unpack_alignment , 0 , format , type , <NEW_LINE> <END_VULN> ( premultiply_alpha ? kAlphaDoPremultiply : kAlphaDoNothing ) , <NEW_LINE> data . data ( ) , flip_y ) ) <NEW_LINE> return false ;
next: <NEW_LINE> if ( p -> key_frame || golden_frame ) { <NEW_LINE> <START_VULN> if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && <NEW_LINE> <END_VULN> s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] ) <NEW_LINE> avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ) ; <NEW_LINE> s -> framep [ VP56_FRAME_GOLDEN ] = p ;
bool RenderBlock::expandsToEncloseOverhangingFloats ( ) const <NEW_LINE> { <NEW_LINE> <START_VULN> return isInlineBlockOrInlineTable ( ) || isFloatingOrPositioned ( ) || hasOverflowClip ( ) || ( parent ( ) && parent ( ) -> isDeprecatedFlexibleBox ( ) ) <NEW_LINE> <END_VULN> || hasColumns ( ) || isTableCell ( ) || isTableCaption ( ) || isFieldset ( ) || isWritingModeRoot ( ) || isRoot ( ) ; <NEW_LINE> }
if ( exception -> severity != UndefinedException ) goto FINISH_UNL ; <NEW_LINE> if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ; <NEW_LINE> <START_VULN> ( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <NEW_LINE> <END_VULN>
if ( ! handler ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> <START_VULN> nsresult rv = handler -> Init ( aContext , aIsInterval , aInterval ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) { <NEW_LINE> delete handler ; <NEW_LINE> return rv ;
void RenderFlexibleBox::prepareChildForPositionedLayout ( RenderBox * child , LayoutUnit mainAxisOffset , LayoutUnit crossAxisOffset , PositionedLayoutMode layoutMode ) <NEW_LINE> { <NEW_LINE> <START_VULN> ASSERT ( child -> isPositioned ( ) ) ; <NEW_LINE> <END_VULN> child -> containingBlock ( ) -> insertPositionedObject ( child ) ; <NEW_LINE> RenderLayer * childLayer = child -> layer ( ) ; <NEW_LINE> LayoutUnit inlinePosition = isColumnFlow ( ) ? crossAxisOffset : mainAxisOffset ;
<START_VULN> <NEW_LINE> <END_VULN> [ uuid ( 8916a320 - d118 - 11d3 - 8f3a - 0010a4e73d9a ) ]
void OnHandleURLRequest ( const PluginHostMsg_URLRequest_Params & params ) ; <NEW_LINE> void OnCancelResource ( int id ) ; <NEW_LINE> void OnInvalidateRect ( const gfx::Rect & rect ) ; <NEW_LINE> <START_VULN> void OnGetWindowScriptNPObject ( int route_id , bool * success , <NEW_LINE>intptr_t * npobject_ptr ) ; <NEW_LINE>void OnGetPluginElement ( int route_id , bool * success , intptr_t * npobject_ptr ) ; <NEW_LINE> <END_VULN> void OnSetCookie ( const GURL & url , <NEW_LINE> const GURL & first_party_for_cookies , <NEW_LINE> const std::string & cookie ) ;
Color lightingColor ( ) const { return svgStyle ( ) -> lightingColor ( ) ; } <NEW_LINE> void appendContent ( PassOwnPtr < ContentData > ) ; <NEW_LINE> <START_VULN> StyleDifference repaintOnlyDiff ( const RenderStyle & other , unsigned & changedContextSensitiveProperties ) const ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> inline int adjustForAbsoluteZoom ( int value , float zoomFactor )
png_ptr -> zlib_text_method = method ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> void PNGAPI
mysql_init ( & mysql_connection ) ; <NEW_LINE> if ( opt_compress ) <NEW_LINE> mysql_options ( & mysql_connection , MYSQL_OPT_COMPRESS , NullS ) ; <NEW_LINE> <START_VULN> #ifdef HAVE_OPENSSL <NEW_LINE>if ( opt_use_ssl ) <NEW_LINE> { <NEW_LINE>mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , <NEW_LINE>opt_ssl_capath , opt_ssl_cipher ) ; <NEW_LINE>mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; <NEW_LINE>mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; <NEW_LINE> } <NEW_LINE>mysql_options ( & mysql_connection , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , <NEW_LINE> ( char * ) & opt_ssl_verify_server_cert ) ; <NEW_LINE>#endif <NEW_LINE> <END_VULN> if ( opt_protocol ) <NEW_LINE> mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; <NEW_LINE> if ( opt_bind_addr )
if ( ( ret == IVD_RES_CHANGED ) <NEW_LINE> || ( ret == IVD_MEM_ALLOC_FAILED ) <NEW_LINE> || ( ret == ERROR_UNAVAIL_PICBUF_T ) <NEW_LINE> <START_VULN> || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) <NEW_LINE> <END_VULN> {
|| s -> width != s1 -> width <NEW_LINE> || s -> height != s1 -> height ) { <NEW_LINE> if ( s != s1 ) <NEW_LINE> <START_VULN> copy_fields ( s , s1 , golden_frame , current_frame ) ; <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> }
ND_PRINT ( ( ndo , " [ | osi ] " ) ) ; <NEW_LINE> return ( 1 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <NEW_LINE> <END_VULN> return ( 1 ) ; <NEW_LINE> case ETHERTYPE_PPPOED:
} ; <NEW_LINE> class AutoCompartment <NEW_LINE> { <NEW_LINE> JSContext * const cx_ ; <NEW_LINE> JSCompartment * const origin_ ; <NEW_LINE> public: <NEW_LINE> <START_VULN> AutoCompartment ( JSContext * cx , JSObject * target ) <NEW_LINE>: cx_ ( cx ) , <NEW_LINE>origin_ ( cx -> compartment ) <NEW_LINE> { <NEW_LINE>cx_ -> enterCompartment ( target -> compartment ( ) ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE> ~ AutoCompartment ( ) { <NEW_LINE>cx_ -> leaveCompartment ( origin_ ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> JSContext * context ( ) const { return cx_ ; } <NEW_LINE> JSCompartment * origin ( ) const { return origin_ ; } <NEW_LINE> private: <NEW_LINE> AutoCompartment ( const AutoCompartment & ) MOZ_DELETE ; <NEW_LINE> AutoCompartment & operator = ( const AutoCompartment & ) MOZ_DELETE ; <NEW_LINE> } ;
mGLMaxVaryingVectors = std::min ( maxVertexOutputComponents , minFragmentInputComponents ) / 4 ; <NEW_LINE> break ; <NEW_LINE> case LOCAL_GL_INVALID_ENUM: <NEW_LINE> mGLMaxVaryingVectors = 16 ; <NEW_LINE> break ; <NEW_LINE> default: <NEW_LINE> GenerateWarning ( "GL error 0x % x occurred during WebGL context initialization ! " , error ) ; <NEW_LINE> return false ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> mMaxFramebufferColorAttachments = 1 ; <NEW_LINE> if ( ! gl -> IsGLES2 ( ) ) {
namespace xpc { <NEW_LINE> class WrapperFactory { <NEW_LINE> public: <NEW_LINE> enum { WAIVE_XRAY_WRAPPER_FLAG = js::Wrapper::LAST_USED_FLAG << 1 , <NEW_LINE> IS_XRAY_WRAPPER_FLAG = WAIVE_XRAY_WRAPPER_FLAG << 1 , <NEW_LINE> SCRIPT_ACCESS_ONLY_FLAG = IS_XRAY_WRAPPER_FLAG << 1 , <NEW_LINE> PARTIALLY_TRANSPARENT = SCRIPT_ACCESS_ONLY_FLAG << 1 , <NEW_LINE> <START_VULN> SOW_FLAG = PARTIALLY_TRANSPARENT << 1 } ; <NEW_LINE> <END_VULN> static bool HasWrapperFlag ( JSObject * wrapper , uintN flag ) { <NEW_LINE> uintN flags = 0 ; <NEW_LINE> js::UnwrapObject ( wrapper , & flags ) ; <NEW_LINE> return ! ! ( flags & flag ) ; <NEW_LINE> }
int err ; <NEW_LINE> do { <NEW_LINE> <START_VULN> err = nanosleep ( & delay , & delay ) ; <NEW_LINE> <END_VULN> } while ( err == - 1 && errno == EINTR ) ; <NEW_LINE> }
} <NEW_LINE> if ( mImg != NULL ) { <NEW_LINE> <START_VULN> CHECK_EQ ( mImg -> fmt , IMG_FMT_I420 ) ; <NEW_LINE> <END_VULN> uint32_t width = mImg -> d_w ; <NEW_LINE> uint32_t height = mImg -> d_h ;
} <NEW_LINE> mNumCompositionTimeDeltaEntries = numEntries ; <NEW_LINE> <START_VULN> uint64_t allocSize = numEntries * 2 * sizeof ( uint32_t ) ; <NEW_LINE> <END_VULN> if ( allocSize > SIZE_MAX ) { <NEW_LINE> return ERROR_OUT_OF_RANGE ; <NEW_LINE> }
static bool IsNestedOnCurrentThread ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> class BASE_EXPORT NestingObserver {
if ( LIST_ISEMPTY ( vrrp_data -> vrrp ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> file = fopen ( " / tmp / keepalived . json" , "w" ) ; <NEW_LINE> <END_VULN> if ( ! file ) { <NEW_LINE> log_message ( LOG_INFO , "Can't open / tmp / keepalived . json ( % d: % s ) " , <NEW_LINE> errno , strerror ( errno ) ) ;
} <NEW_LINE> JS::Zone * <NEW_LINE> js::ZoneOfObjectFromAnyThread ( const JSObject & obj ) <NEW_LINE> { <NEW_LINE> return obj . zoneFromAnyThread ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
if ( ctx -> state == BODY_CHUNK_TRAILER ) { <NEW_LINE> <START_VULN> int merge_trailers = <NEW_LINE>conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ; <NEW_LINE>return read_chunked_trailers ( ctx , f , b , merge_trailers ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> break ;
ref_full . row = ref_mv -> row >> 3 ; <NEW_LINE> <START_VULN> vp9_hex_search ( x , & ref_full , step_param , x -> errorperbit , 0 , & v_fn_ptr , 0 , <NEW_LINE>ref_mv , dst_mv ) ; <NEW_LINE> <END_VULN>
if ( cfg -> bmp ) { <NEW_LINE> if ( get_relfile ( cmdtp , cfg -> bmp , image_load_addr ) ) { <NEW_LINE> <START_VULN> run_command ( "cls" , 0 ) ; <NEW_LINE> <END_VULN> bmp_display ( image_load_addr , <NEW_LINE> BMP_ALIGN_CENTER , BMP_ALIGN_CENTER ) ; <NEW_LINE> } else {
PRBool childInElements = ShouldBeInElements ( aChild ) ; <NEW_LINE> nsTArray < nsIFormControl * > & controls = childInElements ? <NEW_LINE> mControls -> mElements : mControls -> mNotInElements ; <NEW_LINE> PRUint32 index = controls . IndexOf ( aChild ) ; <NEW_LINE> <START_VULN> NS_ASSERTION ( index != controls . NoIndex , "Child not in controls" ) ; <NEW_LINE> <END_VULN> controls . RemoveElementAt ( index ) ; <NEW_LINE> nsIFormControl ** firstSubmitSlot = <NEW_LINE> childInElements ? & mFirstSubmitInElements : & mFirstSubmitNotInElements ; <NEW_LINE> if ( aChild == * firstSubmitSlot ) { <NEW_LINE> * firstSubmitSlot = nsnull ;
return ; <NEW_LINE> } <NEW_LINE> mLastButtonPressTime = aEvent -> time ; <NEW_LINE> mLastButtonReleaseTime = 0 ; <NEW_LINE> <START_VULN> nsWindow * containerWindow ; <NEW_LINE>GetContainerWindow ( & containerWindow ) ; <NEW_LINE><NEW_LINE>if ( ! gFocusWindow ) { <NEW_LINE> <END_VULN> containerWindow -> mActivatePending = PR_FALSE ; <NEW_LINE> DispatchActivateEvent ( ) ; <NEW_LINE> } <NEW_LINE> PRBool rolledUp = check_for_rollup ( aEvent -> window , aEvent -> x_root , <NEW_LINE> aEvent -> y_root , PR_FALSE ) ; <NEW_LINE> if ( gConsumeRollupEvent && rolledUp ) <NEW_LINE> return ;
<START_VULN> MockPrinter * printer ( ) const { return printer_ . get ( ) ; } <NEW_LINE> <END_VULN>
} <NEW_LINE> if ( ! mDecoder ) { <NEW_LINE> rv = InitDecoder ( false ) ; <NEW_LINE> CONTAINER_ENSURE_SUCCESS ( rv ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> { <NEW_LINE>AutoSetSyncDecode syncDecode ( mDecoder ) ; <NEW_LINE><NEW_LINE><NEW_LINE>rv = DecodeSomeData ( mSourceData . Length ( ) - mBytesDecoded ) ; <NEW_LINE>CONTAINER_ENSURE_SUCCESS ( rv ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> nsRefPtr < Decoder > kungFuDeathGrip = mDecoder ; <NEW_LINE> mInDecoder = true ; <NEW_LINE> mDecoder -> FlushInvalidations ( ) ;
#endif <NEW_LINE> #ifdef PNG_WRITE_tIME_SUPPORTED <NEW_LINE> <START_VULN> if ( ( info_ptr -> valid & PNG_INFO_tIME ) && <NEW_LINE> ! ( png_ptr -> mode & PNG_WROTE_tIME ) ) <NEW_LINE> <END_VULN> png_write_tIME ( png_ptr , & ( info_ptr -> mod_time ) ) ; <NEW_LINE> #endif
} <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( context && php_stream_context_get_option ( context , "http" , "protocol_version" , & tmpzval ) == SUCCESS ) { <NEW_LINE> SEPARATE_ZVAL ( tmpzval ) ; <NEW_LINE> convert_to_double_ex ( tmpzval ) ;
} while ( png_ptr -> iwidth == 0 || png_ptr -> num_rows == 0 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> } <NEW_LINE> void
int unit_type ; <NEW_LINE> if ( png_get_oFFs ( read_ptr , read_info_ptr , & offset_x , & offset_y , <NEW_LINE> <START_VULN> & unit_type ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_set_oFFs ( write_ptr , write_info_ptr , offset_x , offset_y , unit_type ) ; <NEW_LINE> }
<START_VULN> PNG_CONST double whiteY = e -> red . Y + e -> green . Y + e -> blue . Y ; <NEW_LINE> <END_VULN> data . red_coefficient = e -> red . Y ; <NEW_LINE> data . green_coefficient = e -> green . Y ;
bool <NEW_LINE> nsContentUtils::IsPatternMatching ( nsAString & aValue , nsAString & aPattern , <NEW_LINE> nsIDocument * aDocument ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( aDocument , "aDocument should be a valid pointer ( not null ) " ) ; <NEW_LINE> NS_ENSURE_TRUE ( aDocument -> GetScriptGlobalObject ( ) , true ) ; <NEW_LINE> <START_VULN> JSContext * cx = aDocument -> GetScriptGlobalObject ( ) -> <NEW_LINE>GetContext ( ) -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( cx , true ) ; <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> aPattern . Insert ( NS_LITERAL_STRING ( " ^ ( ? :" ) , 0 ) ; <NEW_LINE> aPattern . Append ( NS_LITERAL_STRING ( " ) $ " ) ) ;
{ 101 , 21 , 107 , 181 , 192 , 103 , 19 , 67 , 125 } <NEW_LINE> } ; <NEW_LINE> <START_VULN> const vp9_prob vp9_kf_partition_probs [ PARTITION_CONTEXTS ] <NEW_LINE> <END_VULN> [ PARTITION_TYPES - 1 ] = { <NEW_LINE> { 158 , 97 , 94 } ,
#define PACKAGE_URL "" <NEW_LINE> <START_VULN> #define PACKAGE_VERSION "2 . 13 . 0" <NEW_LINE> <END_VULN>
write_webm_file_header ( & stream -> ebml , cfg , <NEW_LINE> & global -> framerate , <NEW_LINE> stream -> config . stereo_fmt , <NEW_LINE> <START_VULN> global -> codec -> fourcc ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif
dummy_page_holder = nullptr ; <NEW_LINE> <START_VULN> fetch_context -> DispatchWillSendRequest ( 1 , request , response , initiator_info ) ; <NEW_LINE> <END_VULN> }
( ctxt -> value -> nodesetval != NULL ) && <NEW_LINE> ( ctxt -> value -> nodesetval -> nodeTab != NULL ) && <NEW_LINE> ( ctxt -> value -> nodesetval -> nodeNr > 1 ) ) { <NEW_LINE> <START_VULN> ctxt -> value -> nodesetval -> nodeTab [ 0 ] = <NEW_LINE>ctxt -> value -> nodesetval -> nodeTab [ ctxt -> <NEW_LINE>value -> <NEW_LINE>nodesetval -> <NEW_LINE>nodeNr - <NEW_LINE>1 ] ; <NEW_LINE>ctxt -> value -> nodesetval -> nodeNr = 1 ; <NEW_LINE> <END_VULN> * first = * ( ctxt -> value -> nodesetval -> nodeTab ) ; <NEW_LINE> } <NEW_LINE> return ( total ) ;
} <NEW_LINE> void MediaDecoderStateMachine::StartPlayback ( ) <NEW_LINE> { <NEW_LINE> LOG ( PR_LOG_DEBUG , ( " % p StartPlayback ( ) " , mDecoder . get ( ) ) ) ; <NEW_LINE> NS_ASSERTION ( ! IsPlaying ( ) , "Shouldn't be playing when StartPlayback ( ) is called" ) ; <NEW_LINE> mDecoder -> GetReentrantMonitor ( ) . AssertCurrentThreadIn ( ) ; <NEW_LINE> <START_VULN> LOG ( PR_LOG_DEBUG , ( " % p StartPlayback" , mDecoder . get ( ) ) ) ; <NEW_LINE> <END_VULN> mDecoder -> NotifyPlaybackStarted ( ) ; <NEW_LINE> mPlayStartTime = TimeStamp::Now ( ) ; <NEW_LINE> NS_ASSERTION ( IsPlaying ( ) , "Should report playing by end of StartPlayback ( ) " ) ; <NEW_LINE> if ( NS_FAILED ( StartAudioThread ( ) ) ) { <NEW_LINE> NS_WARNING ( "Failed to create audio thread" ) ; <NEW_LINE> } <NEW_LINE> mDecoder -> GetReentrantMonitor ( ) . NotifyAll ( ) ;
void SetProgressTime ( const base::string16 & time ) ; <NEW_LINE> void SetDuration ( const base::string16 & duration ) ; <NEW_LINE> <START_VULN> void HandleSeeking ( const gfx::Point & location_in_bar ) ; <NEW_LINE> <END_VULN> views::ProgressBar * progress_bar_ ; <NEW_LINE> views::Label * progress_time_ ;
if ( ! frame ) <NEW_LINE> return false ; <NEW_LINE> FrameLoaderClient * frameLoaderClient = frame -> loader ( ) . client ( ) ; <NEW_LINE> <START_VULN> return frameLoaderClient && frameLoaderClient -> allowAutoplay ( false ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void HTMLMediaElement::setNetworkState ( NetworkState state ) {
ogg_sync_wrote ( & oy , next - buf ) ; <NEW_LINE> while ( 1 ) { <NEW_LINE> int ret = ogg_sync_pageout ( & oy , & og_de ) ; <NEW_LINE> if ( ret == 0 ) break ; <NEW_LINE> if ( ret < 0 ) continue ; <NEW_LINE> <START_VULN> fprintf ( stderr , " ( % ld ) , " , pageout ) ; <NEW_LINE> <END_VULN> check_page ( data + deptr , headers [ pageout ] , & og_de ) ; <NEW_LINE> deptr += og_de . body_len ; <NEW_LINE> pageout ++ ; <NEW_LINE> ogg_stream_pagein ( & os_de , & og_de ) ;
unsigned bufferpos ; <NEW_LINE> const FLAC__Frame * frame ; <NEW_LINE> <START_VULN> FLAC__bool bufferbackup ; <NEW_LINE> <END_VULN> unsigned compression ; <NEW_LINE> } FLAC_PRIVATE ; <NEW_LINE> typedef struct
outHeader -> nTimeStamp = inHeader -> nTimeStamp ; <NEW_LINE> uint8_t * dst = outHeader -> pBuffer ; <NEW_LINE> <START_VULN> const uint8_t * srcY = ( const uint8_t * ) mImg -> planes [ PLANE_Y ] ; <NEW_LINE>const uint8_t * srcU = ( const uint8_t * ) mImg -> planes [ PLANE_U ] ; <NEW_LINE>const uint8_t * srcV = ( const uint8_t * ) mImg -> planes [ PLANE_V ] ; <NEW_LINE>size_t srcYStride = mImg -> stride [ PLANE_Y ] ; <NEW_LINE>size_t srcUStride = mImg -> stride [ PLANE_U ] ; <NEW_LINE>size_t srcVStride = mImg -> stride [ PLANE_V ] ; <NEW_LINE> <END_VULN> copyYV12FrameToOutputBuffer ( dst , srcY , srcU , srcV , srcYStride , srcUStride , srcVStride ) ; <NEW_LINE> mImg = NULL ;
bool isVisible ( ) const { return m_isVisible ; } <NEW_LINE> <START_VULN> bool hasSource ( ) const { return m_source != AutoplaySource::NumberOfSources ; } <NEW_LINE> <END_VULN> DECLARE_VIRTUAL_TRACE ( ) ;
case REOP_REPEAT: <NEW_LINE> -- curState ; <NEW_LINE> do { <NEW_LINE> <START_VULN> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> if ( ! result ) { <NEW_LINE> if ( curState -> u . quantifier . min == 0 )
init_cdrom_command ( & cgc , buf , sizeof ( buf ) , CGC_DATA_READ ) ; <NEW_LINE> cgc . cmd [ 0 ] = GPCMD_READ_DVD_STRUCTURE ; <NEW_LINE> cgc . cmd [ 7 ] = s -> type ; <NEW_LINE> <START_VULN> cgc . cmd [ 9 ] = cgc . buflen = 0xff ; <NEW_LINE> <END_VULN> if ( ( ret = cdo -> generic_packet ( cdi , & cgc ) ) ) <NEW_LINE> return ret ;
if ( xd -> update_mb_segmentation_map ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; <NEW_LINE> <END_VULN> for ( i = 0 ; i < MB_FEATURE_TREE_PROBS ; i ++ )
} <NEW_LINE> fStorageCount = sk_64_asS32 ( count ) ; <NEW_LINE> <START_VULN> int64_t size = sk_64_mul ( fStorageCount , sizeof ( SkRegion::RunType ) ) ; <NEW_LINE>if ( size < 0 || ! sk_64_isS32 ( size ) ) { <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE><NEW_LINE>fStorage = ( SkRegion::RunType * ) sk_malloc_flags ( sk_64_asS32 ( size ) , 0 ) ; <NEW_LINE> <END_VULN> if ( nullptr == fStorage ) { <NEW_LINE> return false ; <NEW_LINE> }
bool isChrome = false ; <NEW_LINE> nsCxPusher cxPusher ; <NEW_LINE> if ( ! cxPusher . Push ( cx ) ) { <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> <END_VULN> nsCOMPtr < WindowStateHolder > wsh = do_QueryInterface ( aState ) ; <NEW_LINE> NS_ASSERTION ( ! aState || wsh , "What kind of weird state are you giving me here ? " ) ; <NEW_LINE> if ( reUseInnerWindow ) { <NEW_LINE> NS_ASSERTION ( ! currentInner -> IsFrozen ( ) , <NEW_LINE> "We should never be reusing a shared inner window" ) ;
class SSLCertErrorHandler : public SSLErrorHandler { <NEW_LINE> public: <NEW_LINE> <START_VULN> SSLCertErrorHandler ( base::WeakPtr < Delegate > delegate , <NEW_LINE> <END_VULN> const content::GlobalRequestID & id , <NEW_LINE> ResourceType::Type resource_type , <NEW_LINE> const GURL & url ,
<START_VULN> PHP_FUNCTION ( locale_get_display_region ) <NEW_LINE> <END_VULN> { <NEW_LINE> get_icu_disp_value_src_php ( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; <NEW_LINE> }
<START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED <NEW_LINE> #ifdef PNG_STDIO_SUPPORTED
else <NEW_LINE> { <NEW_LINE> vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> q += 16 ;
Context ( ) . PrepareRequest ( new_request , <NEW_LINE> FetchContext::RedirectType::kForRedirect ) ; <NEW_LINE> Context ( ) . DispatchWillSendRequest ( resource_ -> Identifier ( ) , new_request , <NEW_LINE> <START_VULN> redirect_response , options . initiator_info ) ; <NEW_LINE> <END_VULN>
js_AtomizeString ( JSContext * cx , JSString * str , uintN flags ) ; <NEW_LINE> extern JSAtom * <NEW_LINE> <START_VULN> js_Atomize ( JSContext * cx , const char * bytes , size_t length , uintN flags , bool useCESU8 = false ) ; <NEW_LINE> <END_VULN> extern JSAtom * <NEW_LINE> js_AtomizeChars ( JSContext * cx , const jschar * chars , size_t length , uintN flags ) ;
if ( data ) { <NEW_LINE> nsAutoString stringdata ; <NEW_LINE> data -> GetAsAString ( stringdata ) ; <NEW_LINE> nsAutoString lowercaseFormat ; <NEW_LINE> <START_VULN> nsContentUtils::ASCIIToLower ( aFormat , lowercaseFormat ) ; <NEW_LINE> <END_VULN> if ( lowercaseFormat . EqualsLiteral ( "url" ) ) { <NEW_LINE> PRInt32 lastidx = 0 , idx ; <NEW_LINE> PRInt32 length = stringdata . Length ( ) ; <NEW_LINE> while ( lastidx < length ) { <NEW_LINE> idx = stringdata . FindChar ( '\n' , lastidx ) ; <NEW_LINE> if ( stringdata [ lastidx ] == '#' ) {
static int <NEW_LINE> image_transform_png_set_scale_16_add ( image_transform * this , <NEW_LINE> <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE> <END_VULN> { <NEW_LINE> UNUSED ( colour_type )
png_alloc_size_t limit = PNG_SIZE_MAX ; <NEW_LINE> <START_VULN> # ifdef PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED <NEW_LINE>if ( png_ptr -> user_chunk_malloc_max > 0 && <NEW_LINE>png_ptr -> user_chunk_malloc_max < limit ) <NEW_LINE>limit = png_ptr -> user_chunk_malloc_max ; <NEW_LINE># elif PNG_USER_CHUNK_MALLOC_MAX > 0 <NEW_LINE>if ( PNG_USER_CHUNK_MALLOC_MAX < limit ) <NEW_LINE>limit = PNG_USER_CHUNK_MALLOC_MAX ; <NEW_LINE># endif <NEW_LINE> <END_VULN> if ( limit >= prefix_size + ( terminate != 0 ) ) <NEW_LINE> {
fflush ( stdout ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void ocall_malloc ( size_t size , uint8_t ** ret ) { <NEW_LINE> <END_VULN> * ret = static_cast < uint8_t * > ( malloc ( size ) ) ; <NEW_LINE> }
#if defined ( CONFIG_POST ) <NEW_LINE> <START_VULN> #define SELFTEST_PORT	GPIO_A <NEW_LINE> <END_VULN> #define SELFTEST_PIN	31 <NEW_LINE> int post_hotkeys_pressed ( void )
} <NEW_LINE> mTimeToSampleCount = U32_AT ( & header [ 4 ] ) ; <NEW_LINE> <START_VULN> uint64_t allocSize = mTimeToSampleCount * 2 * sizeof ( uint32_t ) ; <NEW_LINE> <END_VULN> if ( allocSize > SIZE_MAX ) { <NEW_LINE> return ERROR_OUT_OF_RANGE ; <NEW_LINE> }
return StatusFromOMXError ( err ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> BufferMeta * bufferMeta = new BufferMeta ( graphicBuffer ) ; <NEW_LINE> <END_VULN> OMX_BUFFERHEADERTYPE * header ;
#ifndef imgStatusTracker_h__ <NEW_LINE> #define imgStatusTracker_h__ <NEW_LINE> class imgDecoderObserver ; <NEW_LINE> class imgIContainer ; <NEW_LINE> <START_VULN> class imgRequestProxy ; <NEW_LINE> <END_VULN> class imgStatusNotifyRunnable ; <NEW_LINE> class imgRequestNotifyRunnable ; <NEW_LINE> class imgStatusTrackerObserver ; <NEW_LINE> class imgStatusTrackerNotifyingObserver ; <NEW_LINE> class nsIRunnable ; <NEW_LINE> #include "mozilla / RefPtr . h" <NEW_LINE> #include "mozilla / WeakPtr . h" <NEW_LINE> #include "nsCOMPtr . h" <NEW_LINE> #include "nsTObserverArray . h" <NEW_LINE> #include "nsThreadUtils . h" <NEW_LINE> #include "nsRect . h" <NEW_LINE> namespace mozilla { <NEW_LINE> namespace image { <NEW_LINE> class Image ; <NEW_LINE> struct ImageStatusDiff <NEW_LINE> {
} <NEW_LINE> nsCOMPtr < nsIContent > xblNode = do_QueryInterface ( native ) ; <NEW_LINE> if ( ! xblNode ) { <NEW_LINE> xpc::Throw ( cx , NS_ERROR_UNEXPECTED ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN>
NS_ENSURE_TRUE ( mIsInitialized , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE> * aRetValue = JSVAL_VOID ; <NEW_LINE> if ( ! mScriptsEnabled ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> if ( ! pusher . Push ( mContext , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ) <NEW_LINE> <END_VULN> return NS_ERROR_FAILURE ; <NEW_LINE> xpc_UnmarkGrayObject ( & aScopeObject ) ; <NEW_LINE> nsAutoMicroTask mt ; <NEW_LINE> JSPrincipals * p = JS_GetCompartmentPrincipals ( js::GetObjectCompartment ( & aScopeObject ) ) ; <NEW_LINE> aOptions . setPrincipals ( p ) ;
return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1334 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> } <NEW_LINE> #line 886 "ext / standard / var_unserializer . re"
if ( bcache ) <NEW_LINE> <START_VULN> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> { <NEW_LINE> cache -> index = h -> index ;
} <NEW_LINE> #endif <NEW_LINE> <START_VULN> size_t descLen = StringSize ( & data [ 5 ] , encoding ) ; <NEW_LINE> <END_VULN> * length = size - 5 - descLen ;
static void copyMono24 ( <NEW_LINE> short * dst , <NEW_LINE> <START_VULN> const int * const * src , <NEW_LINE> <END_VULN> unsigned nSamples , <NEW_LINE> unsigned ) { <NEW_LINE> for ( unsigned i = 0 ; i < nSamples ; ++ i ) {
int64_t d ; <NEW_LINE> int64_t sse ; <NEW_LINE> int segment_yrate ; <NEW_LINE> <START_VULN> MB_PREDICTION_MODE modes [ 4 ] ; <NEW_LINE> <END_VULN> SEG_RDSTAT rdstat [ 4 ] [ INTER_MODES ] ; <NEW_LINE> int mvthresh ; <NEW_LINE> } BEST_SEG_INFO ;
} <NEW_LINE> extern void vp8_initialize_rd_consts ( VP8_COMP * cpi , MACROBLOCK * x , int Qvalue ) ; <NEW_LINE> <START_VULN> extern void vp8_rd_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , int recon_uvoffset , int * returnrate , int * returndistortion , int * returnintra ) ; <NEW_LINE> <END_VULN> extern void vp8_rd_pick_intra_mode ( MACROBLOCK * x , int * rate ) ;
void * reghash ; <NEW_LINE> void * userdata ; <NEW_LINE> JSScript * script ; <NEW_LINE> <START_VULN> const char * filename ; <NEW_LINE>XDRAtoms * atoms ; <NEW_LINE>XDRAtomsHashMap * atomsMap ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> extern JS_PUBLIC_API ( void )
static NS_HIDDEN_ ( nsresult ) Startup ( ) ; <NEW_LINE> static NS_HIDDEN_ ( void ) Shutdown ( ) ; <NEW_LINE> friend class TimerThread ; <NEW_LINE> friend struct TimerAdditionComparator ; <NEW_LINE> void Fire ( ) ; <NEW_LINE> <START_VULN> nsresult PostTimerEvent ( ) ; <NEW_LINE> <END_VULN> void SetDelayInternal ( uint32_t aDelay ) ; <NEW_LINE> NS_DECL_ISUPPORTS <NEW_LINE> NS_DECL_NSITIMER <NEW_LINE> int32_t GetGeneration ( ) { return mGeneration ; } <NEW_LINE> private:
depth ++ ; <NEW_LINE> } <NEW_LINE> <START_VULN> size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ; <NEW_LINE> <END_VULN> path = ( PATH * ) palloc ( size ) ; <NEW_LINE> SET_VARSIZE ( path , size ) ;
} <NEW_LINE> static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , <NEW_LINE> <START_VULN> u64 nr , int nmi , <NEW_LINE> <END_VULN> struct perf_sample_data * data , <NEW_LINE> struct pt_regs * regs ) <NEW_LINE> {
return bestsme ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> static void temporal_filter_iterate_c ( VP9_COMP * cpi , <NEW_LINE> int frame_count , <NEW_LINE> int alt_ref_index , <NEW_LINE> int strength ,
gsf_infile_child_by_name ( GSF_INFILE ( dir ) , <NEW_LINE> dirname ) ; <NEW_LINE> if ( subdir ) { <NEW_LINE> g_object_unref ( subdir ) ; <NEW_LINE> <START_VULN> dir = GSF_INFILE_TAR ( subdir ) ; <NEW_LINE> <END_VULN> } else <NEW_LINE> dir = tar_create_dir ( dir , dirname ) ; <NEW_LINE> }
} <NEW_LINE> nsCOMPtr < nsIScriptElement > mElement ; <NEW_LINE> bool mLoading ; <NEW_LINE> bool mIsInline ; <NEW_LINE> nsString mScriptText ; <NEW_LINE> PRUint32 mJSVersion ; <NEW_LINE> nsCOMPtr < nsIURI > mURI ; <NEW_LINE> <START_VULN> nsCOMPtr < nsIURI > mFinalURI ; <NEW_LINE> <END_VULN> PRInt32 mLineNo ; <NEW_LINE> } ; <NEW_LINE> NS_IMPL_THREADSAFE_ISUPPORTS0 ( nsScriptLoadRequest )
static int <NEW_LINE> bgp_attr_print ( netdissect_options * ndo , <NEW_LINE> <START_VULN> u_int atype , const u_char * pptr , u_int len ) <NEW_LINE> <END_VULN> { <NEW_LINE> int i ; <NEW_LINE> uint16_t af ;
} <NEW_LINE> var_push_dtor_no_addref ( & var_hash , & current ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> PS_ADD_VARL ( name , namelen ) ; <NEW_LINE> <END_VULN> skip: <NEW_LINE> efree ( name ) ;
frame_size = total_size - size ; <NEW_LINE> <START_VULN> if ( frame_size > LONG_MAX ) <NEW_LINE> <END_VULN> return E_FILE_FORMAT_INVALID ; <NEW_LINE> curr . len = static_cast < long > ( frame_size ) ;
if ( msg . type == omx_message::FILL_BUFFER_DONE ) { <NEW_LINE> OMX_BUFFERHEADERTYPE * buffer = <NEW_LINE> <START_VULN> findBufferHeader ( msg . u . extended_buffer_data . buffer ) ; <NEW_LINE> <END_VULN> { <NEW_LINE> Mutex::Autolock _l ( mDebugLock ) ;
if ( ! maps ) <NEW_LINE> goto out ; <NEW_LINE> <START_VULN> while ( fscanf ( maps , " % * x - % * x % * s % zx % s % ld % s\n" , & offset , device , & inode , <NEW_LINE>file ) == 4 ) { <NEW_LINE> <END_VULN> if ( inode == 0 || ! strcmp ( device , "00:00" ) ) <NEW_LINE> continue ;
{ <NEW_LINE> INC_STATS ( "DOM . TestMediaQueryListListener . method" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestMediaQueryListListener * imp = V8TestMediaQueryListListener::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( RefPtr < MediaQueryListListener > , listener , MediaQueryListListener::create ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> imp -> method ( listener ) ;
tm -> tm_sec = 0 ; <NEW_LINE> fsec = 0 ; <NEW_LINE> <START_VULN> if ( strlen ( str ) >= sizeof ( lowstr ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> errno = PGTYPES_INTVL_BAD_INTERVAL ; <NEW_LINE> return NULL ;
} <NEW_LINE> for ( ; ; ) { <NEW_LINE> <START_VULN> int client_socket = accept ( listen_socket_ , NULL , NULL ) ; <NEW_LINE> <END_VULN> if ( client_socket == - 1 ) { <NEW_LINE> if ( errno == EINVAL || errno == EBADF ) { <NEW_LINE> break ;
if ( xmlStrEqual ( validity , BAD_CAST "valid" ) ) { <NEW_LINE> nb_schematas ++ ; <NEW_LINE> ctxt = xmlSchemaNewParserCtxt ( ( const char * ) path ) ; <NEW_LINE> <START_VULN> xmlSchemaSetParserErrors ( ctxt , <NEW_LINE> ( xmlSchemaValidityErrorFunc ) testErrorHandler , <NEW_LINE> ( xmlSchemaValidityWarningFunc ) testErrorHandler , <NEW_LINE>ctxt ) ; <NEW_LINE> <END_VULN> schemas = xmlSchemaParse ( ctxt ) ; <NEW_LINE> xmlSchemaFreeParserCtxt ( ctxt ) ; <NEW_LINE> if ( schemas == NULL ) {
} <NEW_LINE> s -> width = AV_RL16 ( & s -> avctx -> extradata [ 6 ] ) ; <NEW_LINE> s -> height = AV_RL16 ( & s -> avctx -> extradata [ 8 ] ) ; <NEW_LINE> <START_VULN> if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) { <NEW_LINE> <END_VULN> s -> width = s -> height = 0 ; <NEW_LINE> return ret ; <NEW_LINE> }
mPresContext -> FlushUserFontSet ( ) ; <NEW_LINE> if ( mDocument -> HasAnimationController ( ) ) { <NEW_LINE> mDocument -> GetAnimationController ( ) -> FlushResampleRequests ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>mFrameConstructor -> CreateNeededFrames ( ) ; <NEW_LINE>mFrameConstructor -> ProcessPendingRestyles ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! mIsDestroying ) { <NEW_LINE> mPresContext -> AnimationManager ( ) -> DispatchEvents ( ) ; <NEW_LINE> }
{ <NEW_LINE> int i ; <NEW_LINE> for ( i = 0 ; i <= 31 ; i ++ ) { <NEW_LINE> <START_VULN> if ( x & ( 1 << i ) ) return i ; <NEW_LINE> <END_VULN> } <NEW_LINE> return 0 ; <NEW_LINE> }
for ( AllFramesIter i ( cx -> stack . space ( ) ) ; ! i . done ( ) ; ++ i ) { <NEW_LINE> <START_VULN> StackFrame * fp = i . fp ( ) ; <NEW_LINE>if ( fp -> isFunctionFrame ( ) && ! fp -> runningInIon ( ) && fp -> script ( ) == script ) { <NEW_LINE> <END_VULN> ArgumentsObject * argsobj = ArgumentsObject::createExpected ( cx , fp ) ; <NEW_LINE> if ( ! argsobj ) { <NEW_LINE> script -> needsArgsObj_ = false ;
COMPUTED_STYLE_MAP_ENTRY ( _moz_background_inline_policy , BackgroundInlinePolicy ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( _moz_background_origin , BackgroundOrigin ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( binding , Binding ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( border_bottom_colors , BorderBottomColors ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( border_image , BorderImage ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( border_left_colors , BorderLeftColors ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( border_right_colors , BorderRightColors ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( border_top_colors , BorderTopColors ) , <NEW_LINE> <START_VULN> COMPUTED_STYLE_MAP_ENTRY ( _moz_border_radius_bottomLeft , BorderRadiusBottomLeft ) , <NEW_LINE>COMPUTED_STYLE_MAP_ENTRY ( _moz_border_radius_bottomRight , BorderRadiusBottomRight ) , <NEW_LINE>COMPUTED_STYLE_MAP_ENTRY ( _moz_border_radius_topLeft , BorderRadiusTopLeft ) , <NEW_LINE>COMPUTED_STYLE_MAP_ENTRY ( _moz_border_radius_topRight , BorderRadiusTopRight ) , <NEW_LINE> <END_VULN> COMPUTED_STYLE_MAP_ENTRY ( box_align , BoxAlign ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( box_direction , BoxDirection ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( box_flex , BoxFlex ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( box_ordinal_group , BoxOrdinalGroup ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( box_orient , BoxOrient ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( box_pack , BoxPack ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( box_shadow , BoxShadow ) , <NEW_LINE> COMPUTED_STYLE_MAP_ENTRY ( box_sizing , BoxSizing ) ,
return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> mouse . x = point . m_screenPos . x ( ) ; <NEW_LINE>mouse . y = point . m_screenPos . y ( ) ; <NEW_LINE> <END_VULN> mouse . button = mouse . type != MOUSE_BUTTON_UP ; <NEW_LINE> mouse . flags = 0 ; <NEW_LINE> npEvent . type = NP_MouseEvent ;
} break ; <NEW_LINE> case EFFECT_CMD_ENABLE: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> ALOGV ( "PreProcessingFx_Command cmdCode Case: EFFECT_CMD_ENABLE: ERROR" ) ; <NEW_LINE> return - EINVAL ; <NEW_LINE> }
return NS_ERROR_UNEXPECTED ; <NEW_LINE> JSObject * scope = global -> GetGlobalJSObject ( ) ; <NEW_LINE> nsIScriptContext * context = global -> GetContext ( ) ; <NEW_LINE> if ( ! context ) <NEW_LINE> return NS_ERROR_UNEXPECTED ; <NEW_LINE> <START_VULN> JSContext * jscontext = context -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( context != nullptr , "no jscontext" ) ; <NEW_LINE> if ( ! jscontext ) <NEW_LINE> return NS_ERROR_UNEXPECTED ; <NEW_LINE> JSAutoRequest ar ( jscontext ) ; <NEW_LINE> jsval v ; <NEW_LINE> nsCOMPtr < nsIXPConnectJSObjectHolder > wrapper ;
static int <NEW_LINE> png_rtran_ok ( png_structrp png_ptr , int need_IHDR ) <NEW_LINE> { <NEW_LINE> if ( png_ptr != NULL ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> flags & PNG_FLAG_ROW_INIT ) <NEW_LINE> <END_VULN> png_app_error ( png_ptr , <NEW_LINE> "invalid after png_start_read_image or png_read_update_info" ) ;
UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; <NEW_LINE> UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; <NEW_LINE> UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <NEW_LINE> <START_VULN> WORD16 i2_level_arr [ 16 ] ; <NEW_LINE> <END_VULN> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; <NEW_LINE> WORD16 * pi2_coeff_data ;
interlace_type = PNG_INTERLACE_NONE ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> png_ptr -> bit_depth = ( png_byte ) bit_depth ; <NEW_LINE> png_ptr -> color_type = ( png_byte ) color_type ; <NEW_LINE> png_ptr -> interlaced = ( png_byte ) interlace_type ;
JSOP_WRAPPER ( its_getter ) , JSOP_WRAPPER ( its_setter ) } , <NEW_LINE> { "customRdOnly" , ITS_CUSTOMRDONLY , JSPROP_ENUMERATE | JSPROP_READONLY , <NEW_LINE> JSOP_WRAPPER ( its_getter ) , JSOP_WRAPPER ( its_setter ) } , <NEW_LINE> <START_VULN> { "customNative" , ITS_CUSTOMNATIVE , <NEW_LINE>JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS , <NEW_LINE>JSOP_WRAPPER ( ( JSPropertyOp ) its_get_customNative ) , <NEW_LINE>JSOP_WRAPPER ( ( JSStrictPropertyOp ) its_set_customNative ) } , <NEW_LINE> { NULL , 0 , 0 , JSOP_NULLWRAPPER , JSOP_NULLWRAPPER } <NEW_LINE> <END_VULN> } ; <NEW_LINE> static JSBool its_noisy ;
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> d * ( tod ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; <NEW_LINE> l = BSON_UINT32_FROM_LE ( l ) ; <NEW_LINE> <START_VULN> if ( l >= ( len - o ) ) { <NEW_LINE> <END_VULN> iter -> err_off = o ; <NEW_LINE> goto mark_invalid ; <NEW_LINE> }
<START_VULN> IPC_MESSAGE_ROUTED1 ( ViewHostMsg_GoToEntryAtOffset , <NEW_LINE>int ) <NEW_LINE> <END_VULN>
const char * filename = nsnull ; <NEW_LINE> PRUint32 lineNo = 0 ; <NEW_LINE> handler -> GetLocation ( & filename , & lineNo ) ; <NEW_LINE> NS_TIME_FUNCTION_MARK ( " ( file: % s , line: % d ) " , filename , lineNo ) ; <NEW_LINE> bool is_undefined ; <NEW_LINE> scx -> EvaluateString ( nsDependentString ( script ) , FastGetGlobalJSObject ( ) , <NEW_LINE> <START_VULN> timeout -> mPrincipal , filename , lineNo , <NEW_LINE> <END_VULN> handler -> GetScriptVersion ( ) , nsnull , <NEW_LINE> & is_undefined ) ; <NEW_LINE> } else { <NEW_LINE> TimeDuration lateness = now - timeout -> mWhen ; <NEW_LINE> handler -> SetLateness ( lateness . ToMilliseconds ( ) ) ;
sync_lapic_to_cr8 ( vcpu ) ; <NEW_LINE> save_host_msrs ( vcpu ) ; <NEW_LINE> <START_VULN> fs_selector = kvm_read_fs ( ) ; <NEW_LINE>gs_selector = kvm_read_gs ( ) ; <NEW_LINE> <END_VULN> ldt_selector = kvm_read_ldt ( ) ; <NEW_LINE> svm -> vmcb -> save . cr2 = vcpu -> arch . cr2 ;
<NEW_LINE> npTouchEvent . points = new NPTouchPoint [ npTouchEvent . size ] ; <NEW_LINE> for ( int i = 0 ; i < npTouchEvent . size ; i ++ ) { <NEW_LINE> <START_VULN> npTouchEvent . points [ i ] . touchId = event . m_points [ i ] . m_id ; <NEW_LINE>npTouchEvent . points [ i ] . clientX = event . m_points [ i ] . m_screenPos . x ( ) ; <NEW_LINE>npTouchEvent . points [ i ] . clientY = event . m_points [ i ] . m_screenPos . y ( ) ; <NEW_LINE>npTouchEvent . points [ i ] . screenX = event . m_points [ i ] . m_screenPos . x ( ) ; <NEW_LINE>npTouchEvent . points [ i ] . screenY = event . m_points [ i ] . m_screenPos . y ( ) ; <NEW_LINE>npTouchEvent . points [ i ] . pageX = event . m_points [ i ] . m_pos . x ( ) ; <NEW_LINE>npTouchEvent . points [ i ] . pageY = event . m_points [ i ] . m_pos . y ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
return put_user ( tty_chars_in_buffer ( tty ) , ( int __user * ) arg ) ; <NEW_LINE> case TIOCINQ: <NEW_LINE> down_write ( & tty -> termios_rwsem ) ; <NEW_LINE> <START_VULN> if ( L_ICANON ( tty ) ) <NEW_LINE> <END_VULN> retval = inq_canon ( ldata ) ; <NEW_LINE> else <NEW_LINE> retval = read_cnt ( ldata ) ;
while ( pos < stop ) { <NEW_LINE> long len ; <NEW_LINE> <START_VULN> const long long id = ReadUInt ( pReader , pos , len ) ; <NEW_LINE>assert ( id >= 0 ) ; <NEW_LINE>assert ( ( pos + len ) <= stop ) ; <NEW_LINE> <END_VULN> pos += len ;
nsCOMPtr < nsISHEntry > origLSHE = mLSHE ; <NEW_LINE> mLoadingURI = nullptr ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> FirePageHideNotification ( ! mSavingOldViewer ) ; <NEW_LINE> if ( mLSHE != origLSHE ) <NEW_LINE> return NS_OK ;
mRequest -> GetCallID ( callID ) ; <NEW_LINE> NotifyPermissionAllow ( callID , mDevices ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> already_AddRefed < nsPIDOMWindow > <NEW_LINE> MediaPermissionRequest::GetOwner ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsCOMPtr < nsPIDOMWindow > window = do_QueryInterface ( mRequest -> GetParentObject ( ) ) ; <NEW_LINE> <END_VULN> return window . forget ( ) ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> MediaPermissionRequest::Recv__delete__ ( const bool & allow ) <NEW_LINE> { <NEW_LINE> if ( allow ) {
"job - originating - user - name" , NULL , job -> username ) ; <NEW_LINE> else <NEW_LINE> { <NEW_LINE> <START_VULN> attr -> group_tag = IPP_TAG_JOB ; <NEW_LINE>_cupsStrFree ( attr -> name ) ; <NEW_LINE>attr -> name = _cupsStrAlloc ( "job - originating - user - name" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( con -> username [ 0 ] || auth_info )
if ( ! is_irq_none ( vdev ) ) <NEW_LINE> return - EINVAL ; <NEW_LINE> <START_VULN> vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <NEW_LINE> <END_VULN> if ( ! vdev -> ctx ) <NEW_LINE> return - ENOMEM ; <NEW_LINE> commit 05692d7005a364add85c6e25a6c4447ce08f913a <NEW_LINE> Author: Vlad Tsyrklevich < vlad@tsyrklevich . net > <NEW_LINE> Date: Wed Oct 12 18:51:24 2016 + 0200 <NEW_LINE> vfio / pci: Fix integer overflows , bitmask check <NEW_LINE> The VFIO_DEVICE_SET_IRQS ioctl did not sufficiently sanitize <NEW_LINE> user - supplied integers , potentially allowing memory corruption . This <NEW_LINE> patch adds appropriate integer overflow checks , checks the range bounds <NEW_LINE> for VFIO_IRQ_SET_DATA_NONE , and also verifies that only single element <NEW_LINE> in the VFIO_IRQ_SET_DATA_TYPE_MASK bitmask is set . <NEW_LINE> VFIO_IRQ_SET_ACTION_TYPE_MASK is already correctly checked later in <NEW_LINE> vfio_pci_set_irqs_ioctl ( ) . <NEW_LINE> Furthermore , a kzalloc is changed to a kcalloc because the use of a <NEW_LINE> kzalloc with an integer multiplication allowed an integer overflow <NEW_LINE> condition to be reached without this patch . kcalloc checks for overflow <NEW_LINE> and should prevent a similar occurrence . <NEW_LINE> Signed - off - by: Vlad Tsyrklevich < vlad@tsyrklevich . net >
{ <NEW_LINE> IonSpew ( IonSpew_Inlining , "Not inlining , callee is not hot" ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( allFunctionsAreSmall ) <NEW_LINE> maxInlineDepth = js_IonOptions . smallFunctionMaxInlineDepth ; <NEW_LINE> <START_VULN> if ( inliningDepth >= maxInlineDepth ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> if ( script ( ) -> getUseCount ( ) < js_IonOptions . usesBeforeInlining ( ) ) { <NEW_LINE> IonSpew ( IonSpew_Inlining , "Not inlining , caller is not hot" ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> RootedScript scriptRoot ( cx , script ( ) ) ;
bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; <NEW_LINE> bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; <NEW_LINE> bmp_info . number_colors = ReadBlobLSBLong ( image ) ; <NEW_LINE> <START_VULN> if ( bmp_info . number_colors > GetBlobSize ( image ) ) <NEW_LINE> <END_VULN> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <NEW_LINE> bmp_info . colors_important = ReadBlobLSBLong ( image ) ; <NEW_LINE> if ( image -> debug != MagickFalse )
static Variant HHVM_FUNCTION ( bcsqrt , const String & operand , <NEW_LINE> int64_t scale ) { <NEW_LINE> <START_VULN> if ( scale < 0 ) scale = BCG ( bc_precision ) ; <NEW_LINE> <END_VULN> bc_num result ; <NEW_LINE> bc_init_num ( & result ) ; <NEW_LINE> SCOPE_EXIT {
status_t initDecoder ( ) ; <NEW_LINE> void drainAllOutputBuffers ( bool eos ) ; <NEW_LINE> <START_VULN> void drainOneOutputBuffer ( int32_t picId , uint8_t * data ) ; <NEW_LINE> <END_VULN> void saveFirstOutputBuffer ( int32_t pidId , uint8_t * data ) ; <NEW_LINE> CropSettingsMode handleCropParams ( const H264SwDecInfo & decInfo ) ;
affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; <NEW_LINE> break ; <NEW_LINE> case IS_STRING: <NEW_LINE> <START_VULN> convert_to_double_ex ( zval_affine_elem ) ; <NEW_LINE>affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> default: <NEW_LINE> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Invalid type for element % i" , i ) ;
aReflowState . availableHeight == NS_UNCONSTRAINEDSIZE ) { <NEW_LINE> aStatus = NS_FRAME_COMPLETE ; <NEW_LINE> } <NEW_LINE> CheckInvalidateSizeChange ( aDesiredSize ) ; <NEW_LINE> <START_VULN> FinishReflowWithAbsoluteFrames ( aPresContext , aDesiredSize , aReflowState , aStatus ) ; <NEW_LINE> <END_VULN> aDesiredSize . mCarriedOutBottomMargin = carriedOutBottomMargin ; <NEW_LINE> NS_FRAME_SET_TRUNCATION ( aStatus , aReflowState , aDesiredSize ) ; <NEW_LINE> NS_ASSERTION ( NS_FRAME_IS_FULLY_COMPLETE ( aStatus ) || <NEW_LINE> aReflowState . availableHeight != NS_UNCONSTRAINEDSIZE , <NEW_LINE> "Column set should be complete if the available height is unconstrained" ) ;
SPL_METHOD ( RecursiveDirectoryIterator , getSubPath ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
} <NEW_LINE> if ( priv -> cac_id_len ) { <NEW_LINE> serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ; <NEW_LINE> <START_VULN> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <NEW_LINE> <END_VULN> SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; <NEW_LINE> } <NEW_LINE> SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ;
MediaMetadataRetriever::MediaMetadataRetriever ( ) <NEW_LINE> { <NEW_LINE> ALOGV ( "constructor" ) ; <NEW_LINE> <START_VULN> const sp < IMediaPlayerService > & service ( getService ( ) ) ; <NEW_LINE> <END_VULN> if ( service == 0 ) { <NEW_LINE> ALOGE ( "failed to obtain MediaMetadataRetrieverService" ) ; <NEW_LINE> return ;
} <NEW_LINE> order = get2 ( ) ; <NEW_LINE> hlen = get4 ( ) ; <NEW_LINE> <START_VULN> if ( get4 ( ) == 0x48454150 ) <NEW_LINE> <END_VULN> { <NEW_LINE> #ifdef LIBRAW_LIBRARY_BUILD <NEW_LINE> imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; <NEW_LINE> commit d7c3d2cb460be10a3ea7b32e9443a83c243b2251 <NEW_LINE> Author: Alex Tutubalin < lexa@lexa . ru > <NEW_LINE> Date: Sat Mar 4 21:27:39 2017 + 0300 <NEW_LINE> Secunia SA75000 advisory: several buffer overruns
int32_t newIndex = frameIndex ; <NEW_LINE> do { <NEW_LINE> } while ( ++ newIndex < frameCount && <NEW_LINE> aBpd -> FrameAt ( newIndex ) == NS_BIDI_CONTROL_FRAME ) ; <NEW_LINE> if ( newIndex < frameCount ) { <NEW_LINE> RemoveBidiContinuation ( aBpd , frame , <NEW_LINE> frameIndex , newIndex , lineOffset ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> } else if ( runLength == fragmentLength ) { <NEW_LINE> <END_VULN> nsIFrame * next = frame -> GetNextInFlow ( ) ; <NEW_LINE> if ( next ) { <NEW_LINE> frame -> SetNextContinuation ( next ) ; <NEW_LINE> next -> SetPrevContinuation ( frame ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> frame -> AdjustOffsetsForBidi ( contentOffset , contentOffset + fragmentLength ) ;
if ( compression_count > 0 ) { <NEW_LINE> compression_entries_ = <NEW_LINE> <START_VULN> new ( std::nothrow ) ContentCompression * [ compression_count ] ; <NEW_LINE> <END_VULN> if ( ! compression_entries_ ) <NEW_LINE> return - 1 ; <NEW_LINE> compression_entries_end_ = compression_entries_ ;
#ifndef EXTENSIONS_BROWSER_GUEST_VIEW_GUEST_VIEW_H_ <NEW_LINE> #define EXTENSIONS_BROWSER_GUEST_VIEW_GUEST_VIEW_H_ <NEW_LINE> <START_VULN> #include "base / bind . h" <NEW_LINE> <END_VULN> #include "content / public / browser / render_frame_host . h" <NEW_LINE> #include "extensions / browser / guest_view / guest_view_base . h" <NEW_LINE> namespace extensions {
virtual RenderBoxModelObject * virtualContinuation ( ) const { return 0 ; } <NEW_LINE> bool isFloating ( ) const { return m_bitfields . floating ( ) ; } <NEW_LINE> <START_VULN> bool isPositioned ( ) const { return m_bitfields . positioned ( ) ; } <NEW_LINE> <END_VULN> bool isRelPositioned ( ) const { return m_bitfields . relPositioned ( ) ; } <NEW_LINE> bool isText ( ) const { return m_bitfields . isText ( ) ; } <NEW_LINE> bool isBox ( ) const { return m_bitfields . isBox ( ) ; }
~ ProxyConfig ( ) ; <NEW_LINE> ProxyConfig & operator = ( const ProxyConfig & config ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> bool Equals ( const ProxyConfig & other ) const ;
{ <NEW_LINE> if ( ! isMainThread ( ) ) <NEW_LINE> <START_VULN> CCMainThread::postTask ( createMainThreadTask ( this , & CCLayerTreeHostTest::endTest ) ) ; <NEW_LINE> <END_VULN> else {
if ( aIsSet && <NEW_LINE> ! JSVAL_IS_PRIMITIVE ( * vp ) && <NEW_LINE> ! RewrapObject ( cx , JS_GetGlobalForObject ( cx , unsafeObj ) , <NEW_LINE> JSVAL_TO_OBJECT ( * vp ) , UNKNOWN , vp ) ) { <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> JSBool ok = aIsSet <NEW_LINE> <START_VULN> ? JS_SetPropertyById ( cx , unsafeObj , interned_id , vp ) <NEW_LINE>: JS_GetPropertyById ( cx , unsafeObj , interned_id , vp ) ; <NEW_LINE> <END_VULN> if ( ! ok ) { <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return WrapJSValue ( cx , obj , * vp , vp ) ; <NEW_LINE> }
bool mWriteRequested ; <NEW_LINE> bool mWriteCompleted ; <NEW_LINE> FLAC__FrameHeader mWriteHeader ; <NEW_LINE> <START_VULN> const FLAC__int32 * const * mWriteBuffer ; <NEW_LINE> <END_VULN> FLAC__StreamDecoderErrorStatus mErrorStatus ;
#define B43_TXRING_SLOTS 256 <NEW_LINE> #define B43_RXRING_SLOTS 64 <NEW_LINE> <START_VULN> #define B43_DMA0_RX_BUFFERSIZE IEEE80211_MAX_FRAME_LEN <NEW_LINE> <END_VULN> #define B43_DMA_PTR_POISON ( ( void * ) ERR_PTR ( - ENOMEM ) )
mOutgoingQ . RemoveElementAt ( 0 ) ; <NEW_LINE> delete data ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> UnixSocketConsumer::GetSocketAddr ( nsAString & aAddrStr ) <NEW_LINE> { <NEW_LINE> if ( ! mImpl || mConnectionStatus != SOCKET_CONNECTED ) { <NEW_LINE> NS_WARNING ( "No socket currently open ! " ) ; <NEW_LINE> <START_VULN> aAddrStr = nsString ( ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> } <NEW_LINE> mImpl -> GetSocketAddr ( aAddrStr ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> UnixSocketConsumer::NotifySuccess ( ) <NEW_LINE> {
} <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
namespace content { <NEW_LINE> class CertStore ; <NEW_LINE> struct SSLStatus ; <NEW_LINE> } <NEW_LINE> class ChromeSSLHostStateDelegate ; <NEW_LINE> <START_VULN> class InfoBarService ; <NEW_LINE> <END_VULN> class HostContentSettingsMap ; <NEW_LINE> class Profile ; <NEW_LINE> class WebsiteSettingsUI ;
if ( PASS == conn -> m -> local_tx_start ( conn , this_func TSRMLS_CC ) ) { <NEW_LINE> ret = conn -> m -> query ( conn , "ROLLBACK" , sizeof ( "ROLLBACK" ) - 1 TSRMLS_CC ) ; <NEW_LINE> <START_VULN> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> DBG_RETURN ( ret ) ;
void RenderBox::removeFloatingOrPositionedChildFromBlockLists ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> ASSERT ( isFloatingOrPositioned ( ) ) ; <NEW_LINE> <END_VULN> if ( documentBeingDestroyed ( ) ) <NEW_LINE> return ;
length = ( size_t ) number_pixels ; <NEW_LINE> pixel_info = AcquireVirtualMemory ( length , sizeof ( * pixels ) ) ; <NEW_LINE> if ( pixel_info == ( MemoryInfo * ) NULL ) <NEW_LINE> <START_VULN> ThrowWriterException ( ResourceLimitError , <NEW_LINE>"MemoryAllocationFailed" ) ; <NEW_LINE> <END_VULN> pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; <NEW_LINE> Dump runlength encoded pixels .
#ifdef PNG_READ_pHYs_SUPPORTED <NEW_LINE> else if ( chunk_name == png_pHYs ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_pHYs ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
JSIdArray * ida ; <NEW_LINE> jschar * chars , * ochars , * vsharp ; <NEW_LINE> const jschar * idstrchars , * vchars ; <NEW_LINE> <START_VULN> size_t nchars , idstrlength , gsoplength , vlength , vsharplength ; <NEW_LINE> <END_VULN> char * comma ; <NEW_LINE> jsint i , j , length , valcnt ; <NEW_LINE> jsid id ;
display_ -> GetVRVSyncProvider ( mojo::MakeRequest ( & vr_v_sync_provider_ ) ) ; <NEW_LINE> vr_v_sync_provider_ . set_connection_error_handler ( ConvertToBaseCallback ( <NEW_LINE> WTF::Bind ( & VRDisplay::OnVSyncConnectionError , WrapWeakPersistent ( this ) ) ) ) ; <NEW_LINE> <START_VULN> if ( pending_raf_ && ! display_blurred_ ) { <NEW_LINE> <END_VULN> pending_vsync_ = true ; <NEW_LINE> vr_v_sync_provider_ -> GetVSync ( ConvertToBaseCallback ( <NEW_LINE> WTF::Bind ( & VRDisplay::OnVSync , WrapWeakPersistent ( this ) ) ) ) ;
replen = revcode ; <NEW_LINE> collen = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> while ( collen > 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> x = CVAL ( in ) ; <NEW_LINE> if ( x & 1 )
int size ; <NEW_LINE> syscall_nr = trace_get_syscall_nr ( current , regs ) ; <NEW_LINE> <START_VULN> if ( syscall_nr < 0 ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> if ( ! test_bit ( syscall_nr , enabled_perf_exit_syscalls ) ) <NEW_LINE> return ; <NEW_LINE> commit 086ba77a6db00ed858ff07451bedee197df868c9 <NEW_LINE> Author: Rabin Vincent < rabin@rab . in > <NEW_LINE> Date: Wed Oct 29 23:06:58 2014 + 0100 <NEW_LINE> tracing / syscalls: Ignore numbers outside NR_syscalls' range <NEW_LINE> ARM has some private syscalls ( for example , set_tls ( 2 ) ) which lie <NEW_LINE> outside the range of NR_syscalls . If any of these are called while <NEW_LINE> syscall tracing is being performed , out - of - bounds array access will <NEW_LINE> occur in the ftrace and perf sys_ { enter , exit } handlers . <NEW_LINE> # trace - cmd record - e raw_syscalls: * true && trace - cmd report <NEW_LINE> . . . <NEW_LINE> true - 653 [ 000 ] 384 . 675777: sys_enter: NR 192 ( 0 , 1000 , 3 , 4000022 , ffffffff , 0 ) <NEW_LINE> true - 653 [ 000 ] 384 . 675812: sys_exit: NR 192 = 1995915264 <NEW_LINE> true - 653 [ 000 ] 384 .
if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && <NEW_LINE> <START_VULN> ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) <NEW_LINE> <END_VULN> ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ;
unsigned short len = data_len ; <NEW_LINE> <START_VULN> if ( packet -> size + 4 + data_len > MT_PACKET_LEN ) { <NEW_LINE> <END_VULN> fprintf ( stderr , _ ( "mndp_add_attribute: ERROR , too large packet . Exceeds % d bytes\n" ) , MT_PACKET_LEN ) ; <NEW_LINE> return - 1 ; <NEW_LINE> }
nsPluginDocument::StartDocumentLoad ( const char * aCommand , <NEW_LINE> nsIChannel * aChannel , <NEW_LINE> nsILoadGroup * aLoadGroup , <NEW_LINE> nsISupports * aContainer , <NEW_LINE> nsIStreamListener ** aDocListener , <NEW_LINE> PRBool aReset , <NEW_LINE> nsIContentSink * aSink ) <NEW_LINE> { <NEW_LINE> nsresult rv = <NEW_LINE> nsMediaDocument::StartDocumentLoad ( aCommand , aChannel , aLoadGroup , <NEW_LINE> aContainer , aDocListener , aReset , <NEW_LINE> aSink ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> rv = aChannel -> GetContentType ( mMimeType ) ; <NEW_LINE> <START_VULN> if ( NS_FAILED ( rv ) ) { <NEW_LINE>return rv ; <NEW_LINE> } <NEW_LINE><NEW_LINE><NEW_LINE>rv = CreateSyntheticPluginDocument ( ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) { <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> mStreamListener = new nsPluginStreamListener ( this ) ; <NEW_LINE> if ( ! mStreamListener ) { <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> }
* y0 = rint ( a + b * x0 ) ; <NEW_LINE> * y1 = rint ( a + b * x1 ) ; <NEW_LINE> if ( * y0 > 1023 ) * y0 = 1023 ; <NEW_LINE> if ( * y1 > 1023 ) * y1 = 1023 ; <NEW_LINE> if ( * y0 < 0 ) * y0 = 0 ; <NEW_LINE> if ( * y1 < 0 ) * y1 = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> } else { <NEW_LINE> * y0 = 0 ; <NEW_LINE> * y1 = 0 ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
if ( oldChild -> isListItem ( ) ) <NEW_LINE> toRenderListItem ( oldChild ) -> updateListMarkerNumbers ( ) ; <NEW_LINE> <START_VULN> if ( oldChild -> isPositioned ( ) && owner -> childrenInline ( ) ) <NEW_LINE> <END_VULN> owner -> dirtyLinesFromChangedChild ( oldChild ) ; <NEW_LINE> if ( oldChild -> isRenderRegion ( ) )
if ( pCmdData == NULL || cmdSize < ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || <NEW_LINE> <START_VULN> pReplyData == NULL || * replySize != sizeof ( int32_t ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Equalizer_command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_SET_PARAM: ERROR" ) ; <NEW_LINE> return - EINVAL ;
uint8_t * from = rowp + mGIFStruct . width ; <NEW_LINE> uint32_t * to = ( ( uint32_t * ) rowp ) + mGIFStruct . width ; <NEW_LINE> uint32_t * cmap = mColormap ; <NEW_LINE> <START_VULN> if ( mColorMask == 0xFF ) { <NEW_LINE>for ( uint32_t c = mGIFStruct . width ; c > 0 ; c -- ) { <NEW_LINE> * -- to = cmap [ * -- from ] ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE><NEW_LINE>uint8_t mask = mColorMask ; <NEW_LINE>for ( uint32_t c = mGIFStruct . width ; c > 0 ; c -- ) { <NEW_LINE> * -- to = cmap [ ( * -- from ) & mask ] ; <NEW_LINE> } <NEW_LINE> <END_VULN> }
for ( r = 0 ; r < 8 ; r ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> #if ! ( CONFIG_FAST_UNALIGNED ) <NEW_LINE>dst [ 0 ] = src [ 0 ] ; <NEW_LINE>dst [ 1 ] = src [ 1 ] ; <NEW_LINE>dst [ 2 ] = src [ 2 ] ; <NEW_LINE>dst [ 3 ] = src [ 3 ] ; <NEW_LINE>dst [ 4 ] = src [ 4 ] ; <NEW_LINE>dst [ 5 ] = src [ 5 ] ; <NEW_LINE>dst [ 6 ] = src [ 6 ] ; <NEW_LINE>dst [ 7 ] = src [ 7 ] ; <NEW_LINE>#else <NEW_LINE> ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ; <NEW_LINE> ( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ; <NEW_LINE>#endif <NEW_LINE> <END_VULN> src += src_stride ; <NEW_LINE> dst += dst_stride ;
ret = x509_crt_verify_top ( crt , parent , ca_crl , profile , <NEW_LINE> pathlen , selfsigned , flags , f_vrfy , p_vrfy ) ; <NEW_LINE> if ( ret != 0 ) <NEW_LINE> <START_VULN> return ( ret ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else <NEW_LINE> {
if ( ! mValid ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> <START_VULN> if ( mCanvasElement && mCanvasElement -> IsWriteOnly ( ) && ! nsContentUtils::IsCallerTrustedForRead ( ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_DOM_SECURITY_ERR ; <NEW_LINE> }
static apr_status_t parse_chunk_size ( http_ctx_t * ctx , const char * buffer , <NEW_LINE> <START_VULN> apr_size_t len , int linelimit ) <NEW_LINE> <END_VULN> { <NEW_LINE> apr_size_t i = 0 ;
#include < CoreFoundation / CoreFoundation . h > <NEW_LINE> <START_VULN> #include "base / callback . h" <NEW_LINE> <END_VULN> #include "base / mac / scoped_cftyperef . h" <NEW_LINE> #include "base / memory / scoped_ptr . h" <NEW_LINE> #include "ui / gfx / rect . h"
LIns * guardRec = createGuardRecord ( exit ) ; <NEW_LINE> lir -> insGuard ( LIR_xbarrier , guardRec , guardRec ) ; <NEW_LINE> } <NEW_LINE> LIns * res_ins = lir -> insCall ( known -> builtin , args ) ; <NEW_LINE> if ( rooted ) <NEW_LINE> <START_VULN> lir -> insStorei ( INS_CONSTPTR ( NULL ) , cx_ins , offsetof ( JSContext , nativeVp ) ) ; <NEW_LINE> <END_VULN> rval_ins = res_ins ; <NEW_LINE> switch ( JSTN_ERRTYPE ( known ) ) { <NEW_LINE> case FAIL_NULL: <NEW_LINE> guard ( false , lir -> ins_eq0 ( res_ins ) , OOM_EXIT ) ; <NEW_LINE> break ; <NEW_LINE> case FAIL_NEG: <NEW_LINE> res_ins = lir -> ins1 ( LIR_i2f , res_ins ) ;
<START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN>
slots = kvm_memslots ( kvm ) ; <NEW_LINE> kvm_for_each_memslot ( memslot , slots ) <NEW_LINE> <START_VULN> kvm_iommu_put_pages ( kvm , memslot -> base_gfn , memslot -> npages ) ; <NEW_LINE> <END_VULN> srcu_read_unlock ( & kvm -> srcu , idx ) ;
static void * <NEW_LINE> CountingRealloc ( FT_Memory memory , long cur_size , long new_size , void * p ) <NEW_LINE> { <NEW_LINE> sFreetypeMemoryUsed - = FreetypeMallocSizeOfOnFree ( p ) ; <NEW_LINE> void * pnew = realloc ( p , new_size ) ; <NEW_LINE> if ( pnew ) { <NEW_LINE> sFreetypeMemoryUsed += FreetypeMallocSizeOfOnAlloc ( pnew ) ; <NEW_LINE> <START_VULN> } else { <NEW_LINE> <END_VULN> sFreetypeMemoryUsed += FreetypeMallocSizeOfOnAlloc ( p ) ; <NEW_LINE> } <NEW_LINE> return pnew ; <NEW_LINE> } <NEW_LINE> gfxAndroidPlatform::gfxAndroidPlatform ( ) <NEW_LINE> {
} <NEW_LINE> if ( c == '"' ) { <NEW_LINE> while ( ( c = GetChar ( ts ) ) != '\n' && <NEW_LINE> <START_VULN> JS_ISSPACE ( c ) ) { <NEW_LINE> <END_VULN> continue ; <NEW_LINE> } <NEW_LINE> }
if ( mType != eType_Null ) { <NEW_LINE> bool allowLoad = true ; <NEW_LINE> if ( nsPluginHost::IsJavaMIMEType ( mContentType . get ( ) ) ) { <NEW_LINE> <START_VULN> nsCOMPtr < nsIScriptSecurityManager > secMan = <NEW_LINE>nsContentUtils::GetSecurityManager ( ) ; <NEW_LINE>rv = secMan -> CheckLoadURIWithPrincipal ( thisContent -> NodePrincipal ( ) , <NEW_LINE>mBaseURI , 0 ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) { <NEW_LINE>LOG ( ( "OBJLC [ % p ] : Java codebase check failed" , this ) ) ; <NEW_LINE>allowLoad = false ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> int16_t contentPolicy = nsIContentPolicy::ACCEPT ; <NEW_LINE> if ( allowLoad && mURI && ! mChannelLoaded ) { <NEW_LINE> allowLoad = CheckLoadPolicy ( & contentPolicy ) ; <NEW_LINE> }
rate_uv = 0 ; <NEW_LINE> this_skip2 = 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> } else if ( mb_skip_allowed ) { <NEW_LINE> <END_VULN> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; <NEW_LINE> }
bool CreateSharedBufferIfNeeded ( ) ; <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping MapSharedBufferForType ( <NEW_LINE> <END_VULN> mojom::SensorType type ) ; <NEW_LINE> THREAD_CHECKER ( thread_checker_ ) ;
ProxyJNIEnv & proxyEnv = GetProxyEnv ( env ) ; <NEW_LINE> nsISecureEnv * secureEnv = GetSecureEnv ( env ) ; <NEW_LINE> nsISecurityContext * securityContext = proxyEnv . getContext ( ) ; <NEW_LINE> <START_VULN> nsresult rv = secureEnv -> CallMethod ( method -> mReturnType , obj , method -> mMethodID , args , & outValue , securityContext ) ; <NEW_LINE> <END_VULN> NS_IF_RELEASE ( securityContext ) ; <NEW_LINE> return NS_SUCCEEDED ( rv ) ? outValue : kErrorValue ; <NEW_LINE> }
<START_VULN> const LayoutUnit cw = isPositioned ( ) ? containingBlockLogicalWidthForPositioned ( toRenderBoxModelObject ( container ( ) ) ) : containingBlockLogicalWidthForContent ( ) ; <NEW_LINE> <END_VULN> if ( cw > 0 ) <NEW_LINE> return computeContentBoxLogicalWidth ( minimumValueForLength ( logicalWidth , cw ) ) ; <NEW_LINE> }
private: <NEW_LINE> nsGfxScrollFrameInner * mInner ; <NEW_LINE> } ; <NEW_LINE> void FinishReflowForScrollbar ( nsIContent * aContent , nscoord aMinXY , <NEW_LINE> nscoord aMaxXY , nscoord aCurPosXY , <NEW_LINE> nscoord aPageIncrement , <NEW_LINE> nscoord aIncrement ) ; <NEW_LINE> <START_VULN> static void SetScrollbarEnabled ( nsIContent * aContent , nscoord aMaxPos ) ; <NEW_LINE> <END_VULN> void SetCoordAttribute ( nsIContent * aContent , nsIAtom * aAtom , nscoord aSize ) ; <NEW_LINE> nscoord GetCoordAttribute ( nsIFrame * aFrame , nsIAtom * aAtom , nscoord aDefaultValue , <NEW_LINE> nscoord * aRangeStart , nscoord * aRangeLength ) ; <NEW_LINE> void UpdateScrollbarPosition ( ) ; <NEW_LINE> nsRect GetScrollPortRect ( ) const { return mScrollPort ; }
TEST_F ( WebFrameTest , EmptyDocument ) <NEW_LINE> { <NEW_LINE> <START_VULN> registerMockedHttpURLLoad ( "pageserializer / svg / green_rectangle . svg" ) ; <NEW_LINE> <END_VULN> TestWillInsertBodyWebFrameClient webFrameClient ; <NEW_LINE> FrameTestHelpers::WebViewHelper webViewHelper ;
IPC_STRUCT_MEMBER ( GURL , opener_url ) <NEW_LINE> <START_VULN> IPC_STRUCT_MEMBER ( std::string , opener_security_origin ) <NEW_LINE> <END_VULN>
RETURN_STRINGL ( fname , flen , 0 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
status = PTR_ERR ( cred ) ; <NEW_LINE> goto out ; <NEW_LINE> } <NEW_LINE> <START_VULN> state = nfs4_do_open ( dir , & path , flags , sattr , cred ) ; <NEW_LINE> <END_VULN> d_drop ( dentry ) ; <NEW_LINE> if ( IS_ERR ( state ) ) { <NEW_LINE> status = PTR_ERR ( state ) ;
JS_STATIC_ASSERT ( sizeof ( JSValueTag ) == 4 ) ; <NEW_LINE> JS_STATIC_ASSERT ( sizeof ( JSBool ) == 4 ) ; <NEW_LINE> JS_STATIC_ASSERT ( sizeof ( JSWhyMagic ) <= 4 ) ; <NEW_LINE> JS_STATIC_ASSERT ( sizeof ( Value ) == 8 ) ; <NEW_LINE> } <NEW_LINE> friend jsval_layout ( ::JSVAL_TO_IMPL ) ( Value ) ; <NEW_LINE> friend Value ( ::IMPL_TO_JSVAL ) ( jsval_layout l ) ; <NEW_LINE> <START_VULN> } JSVAL_ALIGNMENT ; <NEW_LINE> <END_VULN> inline bool <NEW_LINE> IsPoisonedValue ( const Value & v ) <NEW_LINE> { <NEW_LINE> if ( v . isString ( ) ) <NEW_LINE> return IsPoisonedPtr ( v . toString ( ) ) ; <NEW_LINE> if ( v . isObject ( ) ) <NEW_LINE> return IsPoisonedPtr ( & v . toObject ( ) ) ;
DeprecatedAbs ( pt . y - mGestureDownPoint . y ) > pixelThresholdY ) { <NEW_LINE> if ( mClickHoldContextMenu ) { <NEW_LINE> KillClickHoldTimer ( ) ; <NEW_LINE> } <NEW_LINE> nsRefPtr < nsDOMDataTransfer > dataTransfer = <NEW_LINE> <START_VULN> new nsDOMDataTransfer ( NS_DRAGDROP_START , false ) ; <NEW_LINE> <END_VULN> if ( ! dataTransfer ) <NEW_LINE> return ; <NEW_LINE> nsCOMPtr < nsISelection > selection ; <NEW_LINE> nsCOMPtr < nsIContent > eventContent , targetContent ; <NEW_LINE> mCurrentTarget -> GetContentForEvent ( aEvent , getter_AddRefs ( eventContent ) ) ; <NEW_LINE> if ( eventContent ) <NEW_LINE> DetermineDragTarget ( aPresContext , eventContent , dataTransfer ,
{ <NEW_LINE> void * buf ; <NEW_LINE> <START_VULN> buf = g_malloc ( size ) ; <NEW_LINE> <END_VULN> if ( object ) { <NEW_LINE> g_signal_connect ( object , "postclose" ,
args . setCallee ( fval ) ; <NEW_LINE> args . setThis ( thisv ) ; <NEW_LINE> PodCopy ( args . array ( ) , argv , argc ) ; <NEW_LINE> if ( args . thisv ( ) . isObject ( ) ) { <NEW_LINE> <START_VULN> RootedObject thisObj ( cx , & args . thisv ( ) . toObject ( ) ) ; <NEW_LINE>JSObject * thisp = JSObject::thisObject ( cx , thisObj ) ; <NEW_LINE>if ( ! thisp ) <NEW_LINE>return false ; <NEW_LINE>args . setThis ( ObjectValue ( * thisp ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! Invoke ( cx , args ) ) <NEW_LINE> return false ; <NEW_LINE> * rval = args . rval ( ) ; <NEW_LINE> return true ; <NEW_LINE> }
CVE_2013_0797_AutoLoadSystemDependencies ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> static LPCWSTR delayDLLs [ ] = { L"wsock32 . dll" , L"crypt32 . dll" } ; <NEW_LINE> <END_VULN> WCHAR systemDirectory [ MAX_PATH + 1 ] = { L'\0' } ;
typedef int16_t interp_kernel [ INTERP_TAPS ] ; <NEW_LINE> <START_VULN> const interp_kernel vp9_filteredinterp_filters500 [ ( 1 << SUBPEL_BITS ) ] = { <NEW_LINE> <END_VULN> { - 3 , 0 , 35 , 64 , 35 , 0 , - 3 , 0 } , <NEW_LINE> { - 3 , - 1 , 34 , 64 , 36 , 1 , - 3 , 0 } , <NEW_LINE> { - 3 , - 1 , 32 , 64 , 38 , 1 , - 3 , 0 } ,
} <NEW_LINE> } <NEW_LINE> <START_VULN> void vp9_encode_mv ( VP9_COMP * cpi , vp9_writer * w , <NEW_LINE> <END_VULN> const MV * mv , const MV * ref , <NEW_LINE> const nmv_context * mvctx , int usehp ) { <NEW_LINE> const MV diff = { mv -> row - ref -> row ,
toHTMLSelectElement ( node ( ) ) -> listBoxSelectItem ( listIndex , allowMultiplySelections , shift , fireOnChangeNow ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> bool RenderMenuList::multiple ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> return toHTMLSelectElement ( node ( ) ) -> multiple ( ) ; <NEW_LINE> }
~ IOHandler ( ) override ; <NEW_LINE> void Wire ( UberDispatcher * dispatcher ) override ; <NEW_LINE> <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) override ;
nsAutoString data ; <NEW_LINE> if ( mContent -> Tag ( ) == nsGkAtoms::object && <NEW_LINE> ! mContent -> HasAttr ( kNameSpaceID_None , nsGkAtoms::src ) && <NEW_LINE> <START_VULN> mContent -> GetAttr ( kNameSpaceID_None , nsGkAtoms::data , data ) ) { <NEW_LINE> <END_VULN> mNumCachedAttrs ++ ; <NEW_LINE> } <NEW_LINE> nsAdoptingCString wmodeType = nsContentUtils::GetCharPref ( "plugins . force . wmode" ) ; <NEW_LINE> if ( ! wmodeType . IsEmpty ( ) ) { <NEW_LINE> mNumCachedAttrs ++ ;
for ( conn_opt = conn_opts ; conn_opt -> keyword != NULL ; conn_opt ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' ) <NEW_LINE> <END_VULN> { <NEW_LINE> keywords [ i ] = conn_opt -> keyword ; <NEW_LINE> values [ i ] = conn_opt -> val ;
spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> zend_class_entry * ce = spl_ce_SplFileObject ; <NEW_LINE> zend_error_handling error_handling ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ; <NEW_LINE> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , " | C" , & ce ) == SUCCESS ) {
length *= image -> colorspace == CMYKColorspace ? 4UL : 3UL ; <NEW_LINE> pixel_info = AcquireVirtualMemory ( length , sizeof ( * pixels ) ) ; <NEW_LINE> if ( pixel_info == ( MemoryInfo * ) NULL ) <NEW_LINE> <START_VULN> { <NEW_LINE>xref = ( MagickOffsetType * ) RelinquishMagickMemory ( xref ) ; <NEW_LINE>ThrowPDFException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; <NEW_LINE> Dump runoffset encoded pixels .
NS_ASSERTION ( nsnull != prevRect , "no previous rect" ) ; <NEW_LINE> if ( ( prevRect -> mRight == rect -> mLeft ) && ( prevRect -> HasSameFrameList ( rect ) ) ) { <NEW_LINE> rect -> mLeft = prevRect -> mLeft ; <NEW_LINE> prevRect -> Remove ( ) ; <NEW_LINE> if ( prevRect == band ) { <NEW_LINE> band = rect ; <NEW_LINE> <START_VULN> if ( mCachedBandPosition == prevRect ) { <NEW_LINE>SetCachedBandPosition ( band ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> delete prevRect ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> prevRect = rect ; <NEW_LINE> prevIsSharedRect = isSharedRect ;
table -> next = rt -> gcWeakMapList ; <NEW_LINE> rt -> gcWeakMapList = obj ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> for ( js::HashMap < JSObject * , Value > ::Range r = table -> map . all ( ) ; ! r . empty ( ) ; r . popFront ( ) ) { <NEW_LINE> <END_VULN> JSObject * key = r . front ( ) . key ; <NEW_LINE> Value & value = r . front ( ) . value ; <NEW_LINE> js::gc::MarkObject ( trc , * key , "key" ) ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> static void read_frame_reference_mode_probs ( VP9_COMMON * cm , vp9_reader * r ) { <NEW_LINE>FRAME_CONTEXT * const fc = & cm -> fc ; <NEW_LINE> <END_VULN> int i ; <NEW_LINE> if ( cm -> reference_mode == REFERENCE_MODE_SELECT )
if ( move_group ) { <NEW_LINE> <START_VULN> if ( group_leader -> ctx -> type != ctx -> type ) <NEW_LINE> <END_VULN> goto err_context ; <NEW_LINE> } else { <NEW_LINE> if ( group_leader -> ctx != ctx )
if ( ! MorphSlimWrapper ( cx , obj ) ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> nsISupports * identity ; <NEW_LINE> if ( mozilla::dom::binding::instanceIsProxy ( obj ) ) { <NEW_LINE> identity = <NEW_LINE> static_cast < nsISupports * > ( js::GetProxyPrivate ( obj ) . toPrivate ( ) ) ; <NEW_LINE> <START_VULN> } else if ( mozilla::dom::IsDOMClass ( js::GetObjectJSClass ( obj ) ) ) { <NEW_LINE>NS_ASSERTION ( mozilla::dom::DOMJSClass::FromJSClass ( <NEW_LINE>js::GetObjectJSClass ( obj ) ) -> mDOMObjectIsISupports , <NEW_LINE>"This only works on nsISupports classes ! " ) ; <NEW_LINE> <END_VULN> identity = <NEW_LINE> mozilla::dom::UnwrapDOMObject < nsISupports > ( obj ) ; <NEW_LINE> } else { <NEW_LINE> identity = nullptr ; <NEW_LINE> } <NEW_LINE> if ( identity ) { <NEW_LINE> nsCOMPtr < nsIClassInfo > ci = do_QueryInterface ( identity ) ;
for ( ITERATE_KEYS ( abilities , kp ) ) { <NEW_LINE> mprSetJson ( job , " $ " , kp -> key ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> mprSetJsonObj ( route -> config , "app . http . auth . auto . abilities" , job ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
if ( tmp_err < * best_motion_err ) { <NEW_LINE> * best_motion_err = tmp_err ; <NEW_LINE> <START_VULN> best_mv -> row = tmp_mv . row ; <NEW_LINE>best_mv -> col = tmp_mv . col ; <NEW_LINE> <END_VULN> }
<START_VULN> if ( pCmdData == NULL || <NEW_LINE>cmdSize != ( sizeof ( effect_param_t ) + sizeof ( int32_t ) + sizeof ( int16_t ) ) || <NEW_LINE>pReplyData == NULL || <NEW_LINE> * replySize != sizeof ( int32_t ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : BassBoost_command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_SET_PARAM: ERROR" ) ; <NEW_LINE> return - EINVAL ;
scoped_refptr < cc::Layer > ) ; <NEW_LINE> TestPaintArtifact & ScrollHitTest ( <NEW_LINE> DisplayItemClient & , <NEW_LINE> <START_VULN> scoped_refptr < const TransformPaintPropertyNode > scroll_offset ) ; <NEW_LINE> <END_VULN> const PaintArtifact & Build ( ) ;
* ( int * ) pReplyData = android::Reverb_setParameter ( pContext , <NEW_LINE> ( void * ) p -> data , <NEW_LINE> <START_VULN> p -> data + p -> psize ) ; <NEW_LINE> <END_VULN> } break ; <NEW_LINE> case EFFECT_CMD_ENABLE:
unsigned int mask ; <NEW_LINE> for ( mask = mask_16x16_0 | mask_8x8_0 | mask_4x4_0 | mask_4x4_int_0 | <NEW_LINE> <START_VULN> mask_16x16_1 | mask_8x8_1 | mask_4x4_1 | mask_4x4_int_1 ; <NEW_LINE>mask ; mask >> = 1 ) { <NEW_LINE> <END_VULN> const loop_filter_thresh * lfi0 = lfi_n -> lfthr + * lfl ; <NEW_LINE> const loop_filter_thresh * lfi1 = lfi_n -> lfthr + * ( lfl + lfl_forward ) ;
set_freezable ( ) ; <NEW_LINE> <START_VULN> while ( ! kthread_should_stop ( ) ) { <NEW_LINE>if ( try_to_freeze ( ) ) <NEW_LINE>continue ; <NEW_LINE> <END_VULN> prepare_to_wait ( & serv -> sv_cb_waitq , & wq , TASK_INTERRUPTIBLE ) ; <NEW_LINE> spin_lock_bh ( & serv -> sv_cb_lock ) ;
encoded_pixels = decompression_buffer [ buffer_caret ] + 1 ; <NEW_LINE> buffer_caret ++ ; <NEW_LINE> <START_VULN> if ( ( bitmap_caret + ( encoded_pixels * pixel_block_size ) ) > image_block_size ) { <NEW_LINE> <END_VULN> gdFree ( decompression_buffer ) ; <NEW_LINE> gdFree ( conversion_buffer ) ; <NEW_LINE> return - 1 ;
void * rv ; <NEW_LINE> gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <NEW_LINE> if ( out == NULL ) return NULL ; <NEW_LINE> <START_VULN> gdImageWBMPCtx ( im , fg , out ) ; <NEW_LINE>rv = gdDPExtractData ( out , size ) ; <NEW_LINE> <END_VULN> out -> gd_free ( out ) ; <NEW_LINE> return rv ; <NEW_LINE> }
<START_VULN> png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , NULL , NULL , NULL ) ; <NEW_LINE> <END_VULN> if ( ! png_ptr ) <NEW_LINE> return 4 ;
if ( status == MagickFalse ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> Ar = GetCacheViewVirtualPixels ( Ar_view , 0 , y , <NEW_LINE>MagickMax ( Ar_image -> columns , Cr_image -> columns ) , 1 , exception ) ; <NEW_LINE>Ai = GetCacheViewVirtualPixels ( Ai_view , 0 , y , <NEW_LINE>MagickMax ( Ai_image -> columns , Ci_image -> columns ) , 1 , exception ) ; <NEW_LINE>Br = GetCacheViewVirtualPixels ( Br_view , 0 , y , <NEW_LINE>MagickMax ( Br_image -> columns , Cr_image -> columns ) , 1 , exception ) ; <NEW_LINE>Bi = GetCacheViewVirtualPixels ( Bi_view , 0 , y , <NEW_LINE>MagickMax ( Bi_image -> columns , Ci_image -> columns ) , 1 , exception ) ; <NEW_LINE> <END_VULN> Cr = QueueCacheViewAuthenticPixels ( Cr_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE> Ci = QueueCacheViewAuthenticPixels ( Ci_view , 0 , y , Ci_image -> columns , 1 , exception ) ; <NEW_LINE> if ( ( Ar == ( const PixelPacket * ) NULL ) ||
if ( options && ( value = httpGetOption ( options , key , 0 ) ) != 0 ) { <NEW_LINE> mprPutStringToBuf ( buf , value ) ; <NEW_LINE> <START_VULN> } else if ( ( value = mprLookupJson ( rx -> params , key ) ) != 0 ) { <NEW_LINE> <END_VULN> mprPutStringToBuf ( buf , value ) ; <NEW_LINE> } <NEW_LINE> if ( value == 0 ) {
send_cookie = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! PS ( id ) && <NEW_LINE> <END_VULN> zend_hash_find ( & EG ( symbol_table ) , "_POST" , <NEW_LINE> sizeof ( "_POST" ) , ( void ** ) & data ) == SUCCESS && <NEW_LINE> Z_TYPE_PP ( data ) == IS_ARRAY &&
protected: <NEW_LINE> inline void DoInit ( JSObject * obj ) <NEW_LINE> { <NEW_LINE> <START_VULN> mObj = UnboxArray ( obj , & mLength , & mData ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> private:
arch_spin_lock ( & tr -> max_lock ) ; <NEW_LINE> <START_VULN> buf = tr -> trace_buffer . buffer ; <NEW_LINE>tr -> trace_buffer . buffer = tr -> max_buffer . buffer ; <NEW_LINE>tr -> max_buffer . buffer = buf ; <NEW_LINE> <END_VULN> __update_max_tr ( tr , tsk , cpu ) ; <NEW_LINE> arch_spin_unlock ( & tr -> max_lock ) ;
#ifdef PNG_READ_sBIT_SUPPORTED <NEW_LINE> else if ( png_ptr -> chunk_name == png_sBIT ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_sBIT ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
static void unset_active_map ( const vpx_codec_enc_cfg_t * cfg , <NEW_LINE> vpx_codec_ctx_t * codec ) { <NEW_LINE> <START_VULN> vpx_active_map_t map = { 0 } ; <NEW_LINE> <END_VULN> map . rows = ( cfg -> g_h + 15 ) / 16 ; <NEW_LINE> map . cols = ( cfg -> g_w + 15 ) / 16 ;
case DECODE_TUNNEL_ERSPAN: <NEW_LINE> return DecodeERSPAN ( tv , dtv , p , pkt , len , pq ) ; <NEW_LINE> default: <NEW_LINE> <START_VULN> SCLogInfo ( "FIXME: DecodeTunnel: protocol % " PRIu32 " not supported . " , proto ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> } <NEW_LINE> return TM_ECODE_OK ;
} <NEW_LINE> static void build_tree_distribution ( VP9_COMP * cpi , TX_SIZE tx_size , <NEW_LINE> <START_VULN> vp9_coeff_stats * coef_branch_ct ) { <NEW_LINE>vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ; <NEW_LINE>vp9_coeff_count * coef_counts = cpi -> coef_counts [ tx_size ] ; <NEW_LINE> <END_VULN> unsigned int ( * eob_branch_ct ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] = <NEW_LINE> cpi -> common . counts . eob_branch [ tx_size ] ; <NEW_LINE> int i , j , k , l , m ;
char * unescape ( char * dest , const char * src ) <NEW_LINE> { <NEW_LINE> while ( * src ) { <NEW_LINE> <START_VULN> if ( * src == '\\' ) { <NEW_LINE> <END_VULN> ++ src ; <NEW_LINE> switch ( * src ) { <NEW_LINE> case 'n': * dest = '\n' ; break ;
uint64_t nFilledLen = width ; <NEW_LINE> nFilledLen *= height ; <NEW_LINE> if ( nFilledLen > UINT32_MAX / 3 ) { <NEW_LINE> <START_VULN> ALOGE ( "b / 29421675 , nFilledLen overflow % llu w % u h % u" , nFilledLen , width , height ) ; <NEW_LINE> <END_VULN> android_errorWriteLog ( 0x534e4554 , "29421675" ) ; <NEW_LINE> return false ; <NEW_LINE> } else if ( outHeader -> nAllocLen < outHeader -> nFilledLen ) {
MagickExport int LocaleUppercase ( const int c ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( c < 0 ) <NEW_LINE> <END_VULN> return ( c ) ; <NEW_LINE> #if defined ( MAGICKCORE_LOCALE_SUPPORT ) <NEW_LINE> if ( c_locale != ( locale_t ) NULL )
return mar_fpopen ( fp ) ; <NEW_LINE> } <NEW_LINE> #ifdef XP_WIN <NEW_LINE> MarFile * mar_wopen ( const wchar_t * path ) { <NEW_LINE> FILE * fp ; <NEW_LINE> <START_VULN> fp = _wfopen ( path , L"rb" ) ; <NEW_LINE> <END_VULN> if ( ! fp ) <NEW_LINE> return NULL ; <NEW_LINE> return mar_fpopen ( fp ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> void mar_close ( MarFile * mar ) {
} ; <NEW_LINE> enum { <NEW_LINE> <START_VULN> INT64_FIELDS_COUNT = INT64_FIELDS_END - INT64_FIELDS_BEGIN , <NEW_LINE>TIME_FIELDS_BEGIN = INT64_FIELDS_END , <NEW_LINE> } ; <NEW_LINE><NEW_LINE>enum TimeField { <NEW_LINE>MTIME = TIME_FIELDS_BEGIN , <NEW_LINE>SERVER_MTIME , <NEW_LINE>CTIME , <NEW_LINE>SERVER_CTIME , <NEW_LINE>TIME_FIELDS_END , <NEW_LINE> } ; <NEW_LINE><NEW_LINE>enum { <NEW_LINE>TIME_FIELDS_COUNT = TIME_FIELDS_END - TIME_FIELDS_BEGIN , <NEW_LINE>ID_FIELDS_BEGIN = TIME_FIELDS_END , <NEW_LINE> <END_VULN> } ; <NEW_LINE> enum IdField {
OriginRequestSummary ( const OriginRequestSummary & other ) ; <NEW_LINE> ~ OriginRequestSummary ( ) ; <NEW_LINE> <START_VULN> GURL origin ; <NEW_LINE> <END_VULN> bool always_access_network = false ; <NEW_LINE> bool accessed_network = false ; <NEW_LINE> int first_occurrence = 0 ;
assert ( bufsize > JAS_STREAM_MAXPUTBACK ) ; <NEW_LINE> <START_VULN> stream -> bufbase_ = JAS_CAST ( uchar * , buf ) ; <NEW_LINE> <END_VULN> stream -> bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK ; <NEW_LINE> } <NEW_LINE> } else {
} <NEW_LINE> <START_VULN> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ; <NEW_LINE> <END_VULN> if ( BImgBuff == NULL ) <NEW_LINE> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ;
mFrameDecodeFlags ( DECODE_FLAGS_DEFAULT ) , <NEW_LINE> mMultipartDecodedFrame ( nullptr ) , <NEW_LINE> mAnim ( nullptr ) , <NEW_LINE> mLockCount ( 0 ) , <NEW_LINE> mDecodeCount ( 0 ) , <NEW_LINE> #ifdef DEBUG <NEW_LINE> mFramesNotified ( 0 ) , <NEW_LINE> #endif <NEW_LINE> <START_VULN> mDecodingMutex ( "RasterImage" ) , <NEW_LINE> <END_VULN> mDecoder ( nullptr ) , <NEW_LINE> mBytesDecoded ( 0 ) , <NEW_LINE> mInDecoder ( false ) , <NEW_LINE> mStatusDiff ( ImageStatusDiff::NoChange ( ) ) , <NEW_LINE> mNotifying ( false ) , <NEW_LINE> mHasSize ( false ) , <NEW_LINE> mDecodeOnDraw ( false ) , <NEW_LINE> mMultipart ( false ) ,
count ++ ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> loser: <NEW_LINE> if ( nickname ) { <NEW_LINE> PORT_Free ( nickname ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> nickname = "" ; <NEW_LINE> <END_VULN> done: <NEW_LINE> if ( firstname ) { <NEW_LINE> PORT_Free ( firstname ) ; <NEW_LINE> } <NEW_LINE> if ( org ) { <NEW_LINE> PORT_Free ( org ) ; <NEW_LINE> }
outptr = out ; <NEW_LINE> for ( i = 0 ; i < 16 ; ++ i ) { <NEW_LINE> <START_VULN> iadst16 ( outptr , temp_out ) ; <NEW_LINE> <END_VULN> for ( j = 0 ; j < 16 ; ++ j ) <NEW_LINE> dest [ j * pitch + i ] =
void SetFlags ( uint32_t aFlagsToSet ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( ! ( aFlagsToSet & ( NODE_IS_ANONYMOUS | <NEW_LINE> NODE_IS_NATIVE_ANONYMOUS_ROOT | <NEW_LINE> NODE_IS_IN_ANONYMOUS_SUBTREE | <NEW_LINE> NODE_ATTACH_BINDING_ON_POSTCREATE | <NEW_LINE> NODE_DESCENDANTS_NEED_FRAMES | <NEW_LINE> <START_VULN> NODE_NEEDS_FRAME ) ) || <NEW_LINE> <END_VULN> IsNodeOfType ( eCONTENT ) , <NEW_LINE> "Flag only permitted on nsIContent nodes" ) ; <NEW_LINE> mFlags |= aFlagsToSet ; <NEW_LINE> } <NEW_LINE> void UnsetFlags ( uint32_t aFlagsToUnset ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( ! ( aFlagsToUnset &
MOZ_GUARD_OBJECT_NOTIFIER_INIT ; <NEW_LINE> if ( ! aSafe ) { <NEW_LINE> mCx = nsContentUtils::GetCurrentJSContext ( ) ; <NEW_LINE> } <NEW_LINE> if ( ! mCx ) { <NEW_LINE> mCx = nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE> <START_VULN> bool result = mPusher . Push ( mCx ) ; <NEW_LINE> <END_VULN> if ( ! result || ! mCx ) { <NEW_LINE> MOZ_CRASH ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> AutoJSContext::operator JSContext * ( ) <NEW_LINE> {
) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void vp8_pack_tokens_c ( vp8_writer * w , const TOKENEXTRA * p , int xcount ) <NEW_LINE> <END_VULN> { <NEW_LINE> const TOKENEXTRA * stop = p + xcount ; <NEW_LINE> unsigned int split ;
case 16: z2 = z = ReadBlobXXXLong ( image2 ) ; <NEW_LINE> if ( z != 3 && z != 1 ) <NEW_LINE> ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; <NEW_LINE> <START_VULN> Frames = ReadBlobXXXLong ( image2 ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> default: ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; <NEW_LINE> }
( void ) add_linux_shareopt ( plinux_opts , "no_root_squash" , NULL ) ; <NEW_LINE> ( void ) add_linux_shareopt ( plinux_opts , "mountpoint" , NULL ) ; <NEW_LINE> <START_VULN> rc = foreach_nfs_shareopt ( shareopts , get_linux_shareopts_cb , <NEW_LINE> <END_VULN> plinux_opts ) ; <NEW_LINE> if ( rc != SA_OK ) {
if ( strncmp ( MATLAB_HDR . identific , "MATLAB" , 6 ) ) <NEW_LINE> { <NEW_LINE> MATLAB_KO: <NEW_LINE> <START_VULN> clone_info = DestroyImageInfo ( clone_info ) ; <NEW_LINE> <END_VULN> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE> }
* <NEW_LINE> int <NEW_LINE> mar_read_product_info_block ( MarFile * mar , <NEW_LINE> struct ProductInformationBlock * infoBlock ) <NEW_LINE> { <NEW_LINE> <START_VULN> int i , hasAdditionalBlocks , offset , <NEW_LINE> <END_VULN> offsetAdditionalBlocks , numAdditionalBlocks , <NEW_LINE> additionalBlockSize , additionalBlockID ; <NEW_LINE> char buf [ 97 ] = { '\0' } ; <NEW_LINE> int ret = get_mar_file_info_fp ( mar -> fp , NULL , NULL , <NEW_LINE> & hasAdditionalBlocks , <NEW_LINE> & offsetAdditionalBlocks ,
txFnTextError <NEW_LINE> } ; <NEW_LINE> const txHandlerTableData gTxEmbedTableData = { <NEW_LINE> { 0 , 0 , txFnStartEmbed , txFnEndEmbed } , <NEW_LINE> <START_VULN> { 0 , 0 , txFnStartElementIgnore , txFnEndElementIgnore } , <NEW_LINE> <END_VULN> txFnTextIgnore <NEW_LINE> } ; <NEW_LINE> const txElementHandler gTxTopElementHandlers [ ] = { <NEW_LINE> { kNameSpaceID_XSLT , "attribute - set" , txFnStartAttributeSet , txFnEndAttributeSet } , <NEW_LINE> { kNameSpaceID_XSLT , "decimal - format" , txFnStartDecimalFormat , txFnEndDecimalFormat } , <NEW_LINE> { kNameSpaceID_XSLT , "include" , txFnStartInclude , txFnEndInclude } ,
return NULL ; <NEW_LINE> <START_VULN> ascii = malloc ( str_len ) ; <NEW_LINE> <END_VULN> for ( ; idx < str_len ; ++ idx ) <NEW_LINE> { <NEW_LINE> hex_buf [ 0 ] = str [ idx ++ ] ;
} <NEW_LINE> } ; <NEW_LINE> <START_VULN> const vp9_prob vp9_kf_uv_mode_prob [ INTRA_MODES ] [ INTRA_MODES - 1 ] = { <NEW_LINE> <END_VULN> { 144 , 11 , 54 , 157 , 195 , 130 , 46 , 58 , 108 } , <NEW_LINE> { 118 , 15 , 123 , 148 , 131 , 101 , 44 , 93 , 131 } , <NEW_LINE> { 113 , 12 , 23 , 188 , 226 , 142 , 26 , 32 , 125 } ,
} <NEW_LINE> if ( buf != NULL ) <NEW_LINE> xmlFree ( buf ) ; <NEW_LINE> <START_VULN> ctxt -> instate = state ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> } <NEW_LINE> if ( buf != NULL )
start_frame = distance + frames_to_blur_forward ; <NEW_LINE> <START_VULN> vpx_memset ( cpi -> frames , 0 , max_frames * sizeof ( YV12_BUFFER_CONFIG * ) ) ; <NEW_LINE> <END_VULN> for ( frame = 0 ; frame < frames_to_blur ; frame ++ ) <NEW_LINE> { <NEW_LINE> int which_buffer = start_frame - frame ;
oggpack_write ( opb , 1 , 1 ) ; <NEW_LINE> return ( 0 ) ; <NEW_LINE> } <NEW_LINE> static int _vorbis_pack_comment ( oggpack_buffer * opb , vorbis_comment * vc ) { <NEW_LINE> int bytes = strlen ( ENCODE_VENDOR_STRING ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> oggpack_write ( opb , 0x03 , 8 ) ; <NEW_LINE> _v_writestring ( opb , "vorbis" , 6 ) ; <NEW_LINE> oggpack_write ( opb , bytes , 32 ) ; <NEW_LINE> _v_writestring ( opb , ENCODE_VENDOR_STRING , bytes ) ;
Visualizer_reset ( pContext ) ; <NEW_LINE> break ; <NEW_LINE> case EFFECT_CMD_ENABLE: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> } <NEW_LINE> if ( pContext -> mState != VISUALIZER_STATE_INITIALIZED ) {
CVE_2014_6427_is_rtsp_request_or_reply ( const guchar * line , size_t linelen , rtsp_type_t * type ) <NEW_LINE> { <NEW_LINE> guint ii ; <NEW_LINE> <START_VULN> const guchar * next_token ; <NEW_LINE> <END_VULN> int tokenlen ; <NEW_LINE> gchar response_chars [ 4 ] ;
return false ; <NEW_LINE> JS_ToggleOptions ( cx , JSOPTION_UNROOTED_GLOBAL ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSBool <NEW_LINE> <END_VULN> XPCJSRuntime::DeferredRelease ( nsISupports * obj ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( obj , "bad param" ) ; <NEW_LINE> if ( mNativesToReleaseArray . IsEmpty ( ) ) {
ZVAL_NULL ( rval ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1237 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy89: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' , ' ) {
length -- ; <NEW_LINE> if ( obj -> isDenseArray ( ) && ! js_PrototypeHasIndexedProperties ( cx , obj ) && <NEW_LINE> length < obj -> getDenseArrayCapacity ( ) && <NEW_LINE> 0 < obj -> getDenseArrayInitializedLength ( ) ) { <NEW_LINE> args . rval ( ) = obj -> getDenseArrayElement ( 0 ) ; <NEW_LINE> if ( args . rval ( ) . isMagic ( JS_ARRAY_HOLE ) ) <NEW_LINE> args . rval ( ) . setUndefined ( ) ; <NEW_LINE> <START_VULN> obj -> moveDenseArrayElements ( 0 , 1 , length ) ; <NEW_LINE> <END_VULN> obj -> setDenseArrayInitializedLength ( obj -> getDenseArrayInitializedLength ( ) - 1 ) ; <NEW_LINE> obj -> setArrayLength ( cx , length ) ; <NEW_LINE> if ( ! js_SuppressDeletedProperty ( cx , obj , INT_TO_JSID ( length ) ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> return JS_TRUE ; <NEW_LINE> } <NEW_LINE> JSBool hole ;
if ( ! strcmp ( ( char * ) name , EL_BINARY ) ) { <NEW_LINE> zend_string * new_str = NULL ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ZSTR_EMPTY_ALLOC ( ) != Z_STR ( ent1 -> data ) ) { <NEW_LINE> new_str = php_base64_decode ( <NEW_LINE> ( unsigned char * ) Z_STRVAL ( ent1 -> data ) , Z_STRLEN ( ent1 -> data ) ) ;
{ <NEW_LINE> NS_PRECONDITION ( ! mIsDocumentGone , "Unexpected AttributeChanged" ) ; <NEW_LINE> NS_PRECONDITION ( aDocument == mDocument , "Unexpected aDocument" ) ; <NEW_LINE> if ( mDidInitialReflow ) { <NEW_LINE> <START_VULN> nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE> <END_VULN> mFrameConstructor -> AttributeChanged ( aContent , aNameSpaceID , <NEW_LINE> aAttribute , aModType , aStateMask ) ; <NEW_LINE> VERIFY_STYLE_TREE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> PresShell::ContentAppended ( nsIDocument * aDocument ,
void RecordSet ( SetOutcome outcome , <NEW_LINE> base::TimeTicks now , <NEW_LINE> const Entry * old_entry , <NEW_LINE> <START_VULN> const Entry & new_entry ) ; <NEW_LINE> <END_VULN> void RecordUpdateStale ( AddressListDeltaType delta , <NEW_LINE> const EntryStaleness & stale ) ; <NEW_LINE> void RecordLookup ( LookupOutcome outcome ,
vp8_default_coef_probs ( & cpi -> common ) ; <NEW_LINE> <START_VULN> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <NEW_LINE> <END_VULN> { <NEW_LINE> int flag [ 2 ] = { 1 , 1 } ; <NEW_LINE> vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cpi -> common . fc . mvc , flag ) ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . convert5" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( e * , , V8e::HasInstance ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ? V8e::toNative ( v8::Handle < v8::Object > ::Cast ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) : 0 ) ; <NEW_LINE> imp -> convert5 ( ) ;
l_int32 plotstyle , <NEW_LINE> const char * plottitle ) <NEW_LINE> { <NEW_LINE> <START_VULN> char buf [ L_BUF_SIZE ] ; <NEW_LINE> <END_VULN> char emptystring [ ] = "" ; <NEW_LINE> char * datastr , * title ; <NEW_LINE> l_int32 n , i ;
if ( HasProto ( ) && ! HasSharedProto ( ) ) <NEW_LINE> GetProto ( ) -> SetScriptableInfo ( mScriptableInfo ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> XPCNativeScriptableInfo * si = mScriptableInfo ; <NEW_LINE> <START_VULN> JSClass * jsclazz = si ? si -> GetJSClass ( ) : Jsvalify ( & XPC_WN_NoHelper_JSClass ) ; <NEW_LINE> <END_VULN> if ( isGlobal ) { <NEW_LINE> if ( ! ( jsclazz -> flags & JSCLASS_IS_GLOBAL ) ) <NEW_LINE> jsclazz -> flags |= XPCONNECT_GLOBAL_FLAGS ; <NEW_LINE> } else
memcpy ( png_ptr -> prev_row , png_ptr -> row_buf , row_info . rowbytes + 1 ) ; <NEW_LINE> #ifdef PNG_MNG_FEATURES_SUPPORTED <NEW_LINE> <START_VULN> if ( ( png_ptr -> mng_features_permitted & PNG_FLAG_MNG_FILTER_64 ) && <NEW_LINE> <END_VULN> ( png_ptr -> filter_type == PNG_INTRAPIXEL_DIFFERENCING ) ) <NEW_LINE> {
int2store ( buffer , ( unsigned int ) option ) ; <NEW_LINE> ret = conn -> m -> simple_command ( conn , COM_SET_OPTION , buffer , sizeof ( buffer ) , PROT_EOF_PACKET , FALSE , TRUE TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE> } <NEW_LINE> DBG_RETURN ( ret ) ;
void RemovingFromWindow ( ) ; <NEW_LINE> void CopyFromCompositingSurface ( <NEW_LINE> const gfx::Rect & src_subrect , <NEW_LINE> <START_VULN> const gfx::Size & dst_size , <NEW_LINE> <END_VULN> const base::Callback < void ( bool , const SkBitmap & ) > & callback , <NEW_LINE> const SkColorType color_type ) ; <NEW_LINE> void CopyFromCompositingSurfaceToVideoFrame (
const std::string & pref_name ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void TabDetachedAt ( TabContents * contents , int index ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual void ActiveTabChanged ( TabContents * old_contents , <NEW_LINE> TabContents * new_contents , <NEW_LINE> int index ,
else if ( eobs [ 0 ] == 1 ) <NEW_LINE> { <NEW_LINE> vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( eobs [ 1 ] > 1 )
if ( b_copy ) <NEW_LINE> { <NEW_LINE> <START_VULN> dy = ( dy + CDG_SCREEN_HEIGHT ) % CDG_SCREEN_HEIGHT ; <NEW_LINE>dy = ( dy + CDG_SCREEN_WIDTH ) % CDG_SCREEN_WIDTH ; <NEW_LINE> <END_VULN> } <NEW_LINE> else <NEW_LINE> {
return result ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsHTMLStyleElement::SetDisabled ( PRBool aDisabled ) <NEW_LINE> { <NEW_LINE> nsresult result = NS_OK ; <NEW_LINE> <START_VULN> if ( mStyleSheet ) { <NEW_LINE>nsCOMPtr < nsIDOMStyleSheet > ss ( do_QueryInterface ( mStyleSheet ) ) ; <NEW_LINE> <END_VULN> if ( ss ) { <NEW_LINE> result = ss -> SetDisabled ( aDisabled ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return result ; <NEW_LINE> }
#ifndef PPAPI_HOST_DISPATCH_HOST_MESSAGE_H_ <NEW_LINE> #define PPAPI_HOST_DISPATCH_HOST_MESSAGE_H_ <NEW_LINE> <START_VULN> #include "base / profiler / scoped_profile . h" <NEW_LINE> <END_VULN> #include "ipc / ipc_message_macros . h" <NEW_LINE> #include "ppapi / c / pp_errors . h"
if ( chunk -> data [ 0 ] != 0 && chunk -> data [ 0 ] != 1 ) <NEW_LINE> return ( - 1 ) ; <NEW_LINE> <START_VULN> if ( set_location ( png_ptr , my_user_chunk_data , have_sTER ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> my_user_chunk_data -> sTER_mode = chunk -> data [ 0 ] ; <NEW_LINE> return ( 1 ) ;
else <NEW_LINE> day = DateFromTime ( lorutime ) ; <NEW_LINE> day = MakeDay ( year , month , day ) ; <NEW_LINE> result = MakeDate ( day , TimeWithinDay ( lorutime ) ) ; <NEW_LINE> if ( local ) <NEW_LINE> result = UTC ( result ) ; <NEW_LINE> <START_VULN> result = TIMECLIP ( result ) ; <NEW_LINE>if ( ! SetUTCTime ( cx , obj , NULL , result ) ) <NEW_LINE>return JS_FALSE ; <NEW_LINE><NEW_LINE>return js_NewNumberInRootedValue ( cx , result , vp ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static JSBool <NEW_LINE> date_setDate ( JSContext * cx , uintN argc , jsval * vp ) <NEW_LINE> { <NEW_LINE> return date_makeDate ( cx , 1 , JS_TRUE , argc , vp ) ; <NEW_LINE> } <NEW_LINE> static JSBool
NetworkReaderProxy ( <NEW_LINE> <START_VULN> int64 content_length , const base::Closure & job_canceller ) ; <NEW_LINE> <END_VULN> virtual ~ NetworkReaderProxy ( ) ;
else { <NEW_LINE> cur_lang_tag = ecalloc ( 1 , strlen ( lang_tag ) + 1 ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> result = strToMatch ( lang_tag , cur_lang_tag ) ; <NEW_LINE> if ( result == 0 ) { <NEW_LINE> efree ( cur_lang_tag ) ;
<START_VULN> int test_main ( int argc , char ** argv ) ; <NEW_LINE> <END_VULN> #define main ( X , Y ) 	test_main ( X , Y ) <NEW_LINE> \ No newline at end of file
ip6addr_string ( ndo , obj_tptr + 20 ) , <NEW_LINE> EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; <NEW_LINE> <START_VULN> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) <NEW_LINE> <END_VULN> hexdump = TRUE ; <NEW_LINE> break ;
CheckedUint32 checked_plainRowSize = CheckedUint32 ( width ) * bytesPerPixel ; <NEW_LINE> CheckedUint32 checked_alignedRowSize = <NEW_LINE> RoundedToNextMultipleOf ( checked_plainRowSize , mPixelStorePackAlignment ) ; <NEW_LINE> if ( ! checked_neededByteLength . isValid ( ) ) <NEW_LINE> return ErrorInvalidOperation ( "readPixels: integer overflow computing the needed buffer size" ) ; <NEW_LINE> <START_VULN> uint32_t dataByteLen = JS_GetTypedArrayByteLength ( pixels -> Obj ( ) ) ; <NEW_LINE> <END_VULN> if ( checked_neededByteLength . value ( ) > dataByteLen ) <NEW_LINE> return ErrorInvalidOperation ( "readPixels: buffer too small" ) ; <NEW_LINE> void * data = pixels -> Data ( ) ; <NEW_LINE> if ( ! data ) { <NEW_LINE> ErrorOutOfMemory ( "readPixels: buffer storage is null . Did we run out of memory ? " ) ; <NEW_LINE> return rv . Throw ( NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> }
class V4L2VP9Picture ; <NEW_LINE> class VaapiVP9Picture ; <NEW_LINE> <START_VULN> class VP9Picture : public base::RefCounted < VP9Picture > { <NEW_LINE> <END_VULN> public: <NEW_LINE> VP9Picture ( ) ;
<START_VULN> if ( gamma_correction ) <NEW_LINE> <END_VULN> png_ptr -> transformations |= PNG_GAMMA ; <NEW_LINE> else
SetFeaturePolicy ( g_empty_string ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void Document::InitContentSecurityPolicy ( ContentSecurityPolicy * csp ) { <NEW_LINE> <END_VULN> SetContentSecurityPolicy ( csp ? csp : ContentSecurityPolicy::Create ( ) ) ;
l_int32 direction ) <NEW_LINE> { <NEW_LINE> char * selname ; <NEW_LINE> <START_VULN> char combname [ L_BUF_SIZE ] ; <NEW_LINE> <END_VULN> l_int32 i , nsels , sx , sy , found ; <NEW_LINE> SEL * sel ;
e = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; <NEW_LINE> if ( e == NULL || e -> method == SC_AC_NEVER ) <NEW_LINE> return 10 ; <NEW_LINE> <START_VULN> bufsize = file -> size ; <NEW_LINE> <END_VULN> sc_file_free ( file ) ; <NEW_LINE> r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; <NEW_LINE> if ( r < 0 ) {
continue ; <NEW_LINE> nsAutoString id ; <NEW_LINE> <START_VULN> nsXULContentUtils::MakeElementID ( this , NS_ConvertASCIItoUCS2 ( uri ) , id ) ; <NEW_LINE> <END_VULN> GetElementsForID ( id , elements ) ;
const nsCSSValueList * shadow1 = normValue1 . GetCSSValueListValue ( ) ; <NEW_LINE> const nsCSSValueList * shadow2 = normValue2 . GetCSSValueListValue ( ) ; <NEW_LINE> double squareDistance = 0 . 0f ; <NEW_LINE> NS_ABORT_IF_FALSE ( ! shadow1 == ! shadow2 , "lists should be same length" ) ; <NEW_LINE> while ( shadow1 ) { <NEW_LINE> nsCSSValue::Array * array1 = shadow1 -> mValue . GetArrayValue ( ) ; <NEW_LINE> nsCSSValue::Array * array2 = shadow2 -> mValue . GetArrayValue ( ) ; <NEW_LINE> <START_VULN> for ( PRUint32 i = 0 ; i < 4 ; ++ i ) { <NEW_LINE> <END_VULN> NS_ABORT_IF_FALSE ( array1 -> Item ( i ) . GetUnit ( ) == eCSSUnit_Pixel , <NEW_LINE> "unexpected unit" ) ; <NEW_LINE> NS_ABORT_IF_FALSE ( array2 -> Item ( i ) . GetUnit ( ) == eCSSUnit_Pixel , <NEW_LINE> "unexpected unit" ) ; <NEW_LINE> double diff = array1 -> Item ( i ) . GetFloatValue ( ) - <NEW_LINE> array2 -> Item ( i ) . GetFloatValue ( ) ; <NEW_LINE> squareDistance += diff * diff ; <NEW_LINE> }
#include "core / platform / mediastream / MediaStreamComponent . h" <NEW_LINE> #include "core / platform / mediastream / MediaStreamDescriptor . h" <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "platform / UUID . h" <NEW_LINE> #include "public / platform / WebMediaStreamSource . h" <NEW_LINE> #include "public / platform / WebMediaStreamTrack . h" <NEW_LINE> #include "public / platform / WebString . h"
void <NEW_LINE> * memory ; <NEW_LINE> <START_VULN> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <NEW_LINE> <END_VULN> return ( ( void * ) NULL ) ; <NEW_LINE> memory = NULL ; <NEW_LINE> alignment = CACHE_LINE_SIZE ;
if ( ( 0xA1 <= * src ) && ( * src <= 0xDF ) ) { <NEW_LINE> * dest ++ = ( 0xFF61 - 0x00A1 ) + * src ; <NEW_LINE> } else { <NEW_LINE> if ( mErrBehavior == kOnError_Signal ) <NEW_LINE> goto error_invalidchar ; <NEW_LINE> * dest ++ = 0xFFFD ; <NEW_LINE> if ( ( PRUint8 ) * src < ( PRUint8 ) 0x7f ) <NEW_LINE> <START_VULN> * dest ++ = ( PRUnichar ) * src ; <NEW_LINE> <END_VULN> } <NEW_LINE> mState = 0 ; <NEW_LINE> if ( dest >= destEnd ) <NEW_LINE> goto error1 ; <NEW_LINE> } <NEW_LINE> break ; <NEW_LINE> case 3: <NEW_LINE> {
#if DCHECK_IS_ON ( ) <NEW_LINE> void assertObjectHasGCInfo ( const void * payload , size_t gcInfoIndex ) { <NEW_LINE> <START_VULN> ASSERT ( HeapObjectHeader::fromPayload ( payload ) -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> #if ! defined ( COMPONENT_BUILD )
* width = 0 ; <NEW_LINE> * height = 0 ; <NEW_LINE> <START_VULN> char key [ 20 ] ; <NEW_LINE>sprintf ( key , "a = framesize: % lu" , PT ) ; <NEW_LINE> <END_VULN> AString value ; <NEW_LINE> if ( ! findAttribute ( index , key , & value ) ) { <NEW_LINE> return false ;
if ( ! mJSObject ) { <NEW_LINE> mContext -> CreateOuterObject ( this , newInnerWindow ) ; <NEW_LINE> mContext -> DidInitializeContext ( ) ; <NEW_LINE> mJSObject = mContext -> GetNativeGlobal ( ) ; <NEW_LINE> SetWrapper ( mJSObject ) ; <NEW_LINE> } else { <NEW_LINE> JSObject * outerObject = <NEW_LINE> <START_VULN> NS_NewOuterWindowProxy ( cx , newInnerWindow -> mJSObject ) ; <NEW_LINE> <END_VULN> if ( ! outerObject ) { <NEW_LINE> NS_ERROR ( "out of memory" ) ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> js::SetProxyExtra ( mJSObject , 0 , js::PrivateValue ( NULL ) ) ; <NEW_LINE> outerObject = JS_TransplantObject ( cx , mJSObject , outerObject ) ;
protected: <NEW_LINE> nsresult RegUnregAccessKey ( nsIPresContext * aPresContext , <NEW_LINE> PRBool aDoReg ) ; <NEW_LINE> <START_VULN> void FireDOMEvent ( nsIPresContext * aPresContext , const nsAString & aDOMEventName ) ; <NEW_LINE> <END_VULN> virtual nsresult GetFrameForPointChild ( nsIPresContext * aPresContext , <NEW_LINE> const nsPoint & aPoint , <NEW_LINE> nsFramePaintLayer aWhichLayer , <NEW_LINE> unchanged:
static int _make_words ( char * l , long n , ogg_uint32_t * r , long quantvals , <NEW_LINE> <START_VULN> codebook * b , oggpack_buffer * opb , int maptype ) { <NEW_LINE> <END_VULN> long i , j , count = 0 ; <NEW_LINE> long top = 0 ; <NEW_LINE> ogg_uint32_t marker [ MARKER_SIZE ] ;
fit_value [ i ] = val + predicted ; <NEW_LINE> fit_value [ look -> loneighbor [ i - 2 ] ] &= 0x7fff ; <NEW_LINE> fit_value [ look -> hineighbor [ i - 2 ] ] &= 0x7fff ; <NEW_LINE> } else { <NEW_LINE> fit_value [ i ] = predicted | 0x8000 ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> } <NEW_LINE> return ( fit_value ) ; <NEW_LINE> } <NEW_LINE> eop: <NEW_LINE> return ( NULL ) ; <NEW_LINE> }
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> RETURN_FALSE ; <NEW_LINE> } else {
isFirstSubtag = 0 ; <NEW_LINE> <START_VULN> for ( i = 0 ; i < max_value ; i ++ ) { <NEW_LINE>snprintf ( cur_key_name , 30 , " % s % d" , key_name , i ) ; <NEW_LINE> <END_VULN> if ( zend_hash_find ( hash_arr , cur_key_name , strlen ( cur_key_name ) + 1 , ( void ** ) & ele_value ) == SUCCESS ) { <NEW_LINE> if ( Z_TYPE_PP ( ele_value ) != IS_STRING ) {
C ( TOO_MANY_PREDS , "Too many terms in predicate expression" ) , \ <NEW_LINE> C ( INVALID_FILTER , "Meaningless filter expression" ) , \ <NEW_LINE> C ( IP_FIELD_ONLY , "Only 'ip' field is supported for function trace" ) , \ <NEW_LINE> <START_VULN> C ( INVALID_VALUE , "Invalid value ( did you forget quotes ) ? " ) , <NEW_LINE> <END_VULN> #undef C <NEW_LINE> #define C ( a , b ) FILT_ERR_##a
#include "nsNetUtil . h" <NEW_LINE> #include "nsOggDecoder . h" <NEW_LINE> using mozilla::TimeDuration ; <NEW_LINE> using mozilla::TimeStamp ; <NEW_LINE> <START_VULN> #define MAX_VIDEO_WIDTH 2000 <NEW_LINE>#define MAX_VIDEO_HEIGHT 2000 <NEW_LINE> <END_VULN> #define OGGPLAY_BUFFER_SIZE 20 <NEW_LINE> #define OGGPLAY_FRAMES_PER_CALLBACK 2048
} <NEW_LINE> efree ( match_sets ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> efree ( offsets ) ; <NEW_LINE> efree ( subpat_names ) ;
NS_DECL_ISUPPORTS <NEW_LINE> NS_DECL_MOZIJSSUBSCRIPTLOADER <NEW_LINE> private: <NEW_LINE> nsresult ReadScript ( nsIURI * uri , JSContext * cx , JSObject * target_obj , <NEW_LINE> jschar * charset , const char * uriStr , <NEW_LINE> <START_VULN> nsIIOService * serv , JSObject ** scriptObjp ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIPrincipal > mSystemPrincipal ; <NEW_LINE> } ;
#include "addrtoname . h" <NEW_LINE> #include "extract . h" <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> struct aodv_rreq { <NEW_LINE> uint8_t		rreq_type ; <NEW_LINE> uint8_t		rreq_flags ;
} ; <NEW_LINE> static const uint32_t Big5CharLenTable [ ] = { 0 , 1 , 1 , 2 , 0 } ; <NEW_LINE> SMModel const Big5SMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , BIG5_cls } , <NEW_LINE> 5 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , BIG5_st } , <NEW_LINE> <START_VULN> Big5CharLenTable , <NEW_LINE> <END_VULN> "Big5" , <NEW_LINE> } ; <NEW_LINE> static const uint32_t EUCJP_cls [ 256 / 8 ] = { <NEW_LINE> PCK4BITS ( 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 ) , <NEW_LINE> PCK4BITS ( 4 , 4 , 4 , 4 , 4 , 4 , 5 , 5 ) , <NEW_LINE> PCK4BITS ( 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 ) ,
u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; <NEW_LINE> while ( ( u4_start_code == EXTENSION_START_CODE || <NEW_LINE> u4_start_code == USER_DATA_START_CODE ) && <NEW_LINE> <START_VULN> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( u4_start_code == USER_DATA_START_CODE ) <NEW_LINE> {
class nsPNGDecoder : public Decoder <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> nsPNGDecoder ( RasterImage & aImage ) ; <NEW_LINE> virtual ~ nsPNGDecoder ( ) ; <NEW_LINE> virtual void InitInternal ( ) ; <NEW_LINE> <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> virtual Telemetry::ID SpeedHistogram ( ) ; <NEW_LINE> void CreateFrame ( png_uint_32 x_offset , png_uint_32 y_offset , <NEW_LINE> int32_t width , int32_t height , <NEW_LINE> gfxImageFormat format ) ; <NEW_LINE> void EndImageFrame ( ) ;
{ <NEW_LINE> nsresult rv ; <NEW_LINE> if ( ! aCount ) { <NEW_LINE> rv = aInputStream -> Available ( & aCount ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> PRUint32 count = ( aCount + 2 ) / 3 * 4 ; <NEW_LINE> <END_VULN> aDest . SetLength ( count + aOffset ) ; <NEW_LINE> if ( aDest . Length ( ) != count + aOffset ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> EncodeInputStream_State < T > state ; <NEW_LINE> state . charsOnStack = 0 ; <NEW_LINE> state . c [ 2 ] = '\0' ; <NEW_LINE> state . buffer = aOffset + aDest . BeginWriting ( ) ;
mark_page_accessed ( page ) ; <NEW_LINE> out: <NEW_LINE> page_cache_release ( page ) ; <NEW_LINE> <START_VULN> unlock_page ( page ) ; <NEW_LINE> <END_VULN> out_ret: <NEW_LINE> return ret ; <NEW_LINE> }
phar_flush ( entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> }
mContentViewer -> SetSticky ( sticky ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> SetHistoryEntry ( & mOSHE , mLSHE ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> SetLayoutHistoryState ( nsnull ) ;
int main ( int argc , char * argv [ ] ) ; <NEW_LINE> void usage ( ) ; <NEW_LINE> <START_VULN> BOOL pnm2png ( FILE * pnm_file , FILE * png_file , FILE * alpha_file , BOOL interlace , BOOL alpha ) ; <NEW_LINE> <END_VULN> void get_token ( FILE * pnm_file , char * token ) ; <NEW_LINE> png_uint_32 get_data ( FILE * pnm_file , int depth ) ; <NEW_LINE> png_uint_32 get_value ( FILE * pnm_file , int depth ) ;
this_mv . as_mv . row = br + neighbors [ i ] . row ; <NEW_LINE> this_mv . as_mv . col = bc + neighbors [ i ] . col ; <NEW_LINE> this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <NEW_LINE> <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <NEW_LINE> <END_VULN> CHECK_BETTER <NEW_LINE> } <NEW_LINE> } else
XPCWrappedNativeScope * <NEW_LINE> GetScope ( ) const { return mScope ; } <NEW_LINE> XPCJSRuntime * <NEW_LINE> GetRuntime ( ) const { return mScope -> GetRuntime ( ) ; } <NEW_LINE> JSObject * <NEW_LINE> <START_VULN> GetJSProtoObject ( ) const { return mJSProtoObject ; } <NEW_LINE> <END_VULN> nsIClassInfo * <NEW_LINE> GetClassInfo ( ) const { return mClassInfo ; } <NEW_LINE> XPCNativeSet * <NEW_LINE> GetSet ( ) const { return mSet ; } <NEW_LINE> XPCNativeScriptableInfo *
sixel_palet [ n ] = SIXEL_RGB ( 255 , 255 , 255 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> ( void ) ResetMagickMemory ( imbuf , background_color_index , imsx * imsy ) ; <NEW_LINE> <END_VULN> while ( * p != '\0' ) { <NEW_LINE> if ( ( p [ 0 ] == '\033' && p [ 1 ] == 'P' ) || * p == 0x90 ) {
EXPECT_FALSE ( this -> SetCanonicalCookie ( <NEW_LINE> cs , <NEW_LINE> <START_VULN> base::MakeUnique < CanonicalCookie > ( <NEW_LINE> <END_VULN> "E" , "F" , http_foo_host , " / " , base::Time ( ) , base::Time ( ) , <NEW_LINE> base::Time ( ) , true , false , CookieSameSite::DEFAULT_MODE , <NEW_LINE> COOKIE_PRIORITY_DEFAULT ) ,
} <NEW_LINE> <START_VULN> static void show_psnr ( struct stream_state * stream ) { <NEW_LINE> <END_VULN> int i ; <NEW_LINE> double ovpsnr ;
else if ( eobs [ 0 ] == 1 ) <NEW_LINE> { <NEW_LINE> vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( eobs [ 1 ] > 1 )
public: <NEW_LINE> MockDataReductionProxySettings < C > ( ) : C ( ) { <NEW_LINE> } <NEW_LINE> <START_VULN> MOCK_METHOD0 ( GetOriginalProfilePrefs , PrefService * ( ) ) ; <NEW_LINE> <END_VULN> MOCK_METHOD0 ( GetLocalStatePrefs , PrefService * ( ) ) ; <NEW_LINE> MOCK_CONST_METHOD1 ( RecordStartupState , void ( ProxyStartupState state ) ) ; <NEW_LINE> } ;
for ( ; ; ) <NEW_LINE> { <NEW_LINE> prepare_poll_fds ( h , pfds ) ; <NEW_LINE> <START_VULN> int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ; <NEW_LINE> <END_VULN> if ( ret == - 1 ) <NEW_LINE> { <NEW_LINE> APPL_TRACE_ERROR ( "poll ret - 1 , exit the thread , errno: % d , err: % s" , errno , strerror ( errno ) ) ;
#define RUN_LIB_FILE " / run / firejail / mnt / libfiles" <NEW_LINE> #define RUN_DNS_ETC " / run / firejail / mnt / dns - etc" <NEW_LINE> <START_VULN> #define RUN_SECCOMP_LIST " / run / firejail / mnt / seccomp . list" <NEW_LINE>#define RUN_SECCOMP_PROTOCOL " / run / firejail / mnt / seccomp . protocol" <NEW_LINE>#define RUN_SECCOMP_CFG " / run / firejail / mnt / seccomp" <NEW_LINE>#define RUN_SECCOMP_32 " / run / firejail / mnt / seccomp . 32" <NEW_LINE>#define RUN_SECCOMP_MDWX " / run / firejail / mnt / seccomp . mdwx" <NEW_LINE>#define RUN_SECCOMP_BLOCK_SECONDARY " / run / firejail / mnt / seccomp . block_secondary" <NEW_LINE>#define RUN_SECCOMP_POSTEXEC " / run / firejail / mnt / seccomp . postexec" <NEW_LINE> <END_VULN> #define PATH_SECCOMP_DEFAULT ( LIBDIR " / firejail / seccomp" ) <NEW_LINE> #define PATH_SECCOMP_DEFAULT_DEBUG ( LIBDIR " / firejail / seccomp . debug" ) <NEW_LINE> #define PATH_SECCOMP_32 ( LIBDIR " / firejail / seccomp . 32" )
: asRope ( ) . flatten ( cx ) ; <NEW_LINE> } <NEW_LINE> JS_ALWAYS_INLINE JSFixedString * <NEW_LINE> JSString::ensureFixed ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> if ( ! ensureFlat ( cx ) ) <NEW_LINE> return NULL ; <NEW_LINE> <START_VULN> if ( isExtensible ( ) ) { <NEW_LINE>JS_ASSERT ( ( d . lengthAndFlags & FLAT_MASK ) == 0 ) ; <NEW_LINE>JS_STATIC_ASSERT ( EXTENSIBLE_FLAGS == ( JS_BIT ( 2 ) | JS_BIT ( 3 ) ) ) ; <NEW_LINE>JS_STATIC_ASSERT ( FIXED_FLAGS == JS_BIT ( 2 ) ) ; <NEW_LINE>d . lengthAndFlags ^= JS_BIT ( 3 ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> return & asFixed ( ) ; <NEW_LINE> } <NEW_LINE> inline js::PropertyName * <NEW_LINE> JSAtom::asPropertyName ( ) <NEW_LINE> { <NEW_LINE> #ifdef DEBUG <NEW_LINE> uint32_t dummy ;
ZVAL_STRINGL ( * rval , str , len , 1 ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 970 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy53: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' / ' ) {
resultLen += n ; <NEW_LINE> <START_VULN> output . SetLength ( resultLen ) ; <NEW_LINE> <END_VULN> if ( resultLen > 0 ) { <NEW_LINE> nsAString::iterator out_iter ; <NEW_LINE> output . BeginWriting ( out_iter ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: toplevel libogg include <NEW_LINE> <START_VULN> last mod: $ Id: ogg . h 16051 2009 - 05 - 27 05:00:06Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _OGG_H <NEW_LINE> #define _OGG_H <NEW_LINE> #ifdef __cplusplus <NEW_LINE> extern "C" { <NEW_LINE> #endif
bool Scrollbar::mouseMoved ( const PlatformMouseEvent & evt ) <NEW_LINE> { <NEW_LINE> if ( m_pressedPart == ThumbPart ) { <NEW_LINE> <START_VULN> if ( theme ( ) -> shouldSnapBackToDragOrigin ( this , evt ) ) <NEW_LINE>scrollableArea ( ) -> scrollToOffsetWithoutAnimation ( m_orientation , m_dragOrigin ) ; <NEW_LINE>else { <NEW_LINE> <END_VULN> moveThumb ( m_orientation == HorizontalScrollbar ? <NEW_LINE> convertFromContainingWindow ( evt . pos ( ) ) . x ( ) : <NEW_LINE> convertFromContainingWindow ( evt . pos ( ) ) . y ( ) ) ;
if ( mAnim ) { <NEW_LINE> mAnim -> SetLoopCount ( aLoopCount ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> RasterImage::AddSourceData ( const char * aBuffer , uint32_t aCount ) <NEW_LINE> { <NEW_LINE> <START_VULN> MutexAutoLock lock ( mDecodingMutex ) ; <NEW_LINE> <END_VULN> if ( mError ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> NS_ENSURE_ARG_POINTER ( aBuffer ) ; <NEW_LINE> nsresult rv = NS_OK ;
} <NEW_LINE> void StaticVertexBuffer::reserveRequiredSpace ( ) <NEW_LINE> { <NEW_LINE> if ( ! mVertexBuffer && mBufferSize == 0 ) <NEW_LINE> { <NEW_LINE> D3DPOOL pool = getDisplay ( ) -> getBufferPool ( D3DUSAGE_WRITEONLY ) ; <NEW_LINE> HRESULT result = mDevice -> CreateVertexBuffer ( mRequiredSpace , D3DUSAGE_WRITEONLY , 0 , pool , & mVertexBuffer , NULL ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( FAILED ( result ) ) <NEW_LINE> { <NEW_LINE> ERR ( "Out of memory allocating a vertex buffer of size % lu . " , mRequiredSpace ) ; <NEW_LINE> } <NEW_LINE> mBufferSize = mRequiredSpace ; <NEW_LINE> } <NEW_LINE> else if ( mVertexBuffer && mBufferSize >= mRequiredSpace )
gfx::Rect visible_rect ; <NEW_LINE> protected: <NEW_LINE> <START_VULN> friend class base::RefCounted < VP9Picture > ; <NEW_LINE> <END_VULN> virtual ~ VP9Picture ( ) ; <NEW_LINE> DISALLOW_COPY_AND_ASSIGN ( VP9Picture ) ;
if ( ! data ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> delete [ ] additional_ ; <NEW_LINE> <END_VULN> additional_ = data ; <NEW_LINE> additional_length_ = length ; <NEW_LINE> add_id_ = add_id ;
ui4_payload_type = 0 ; <NEW_LINE> u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <NEW_LINE> <START_VULN> while ( 0xff == u4_bits ) <NEW_LINE> <END_VULN> { <NEW_LINE> u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <NEW_LINE> ui4_payload_type += 255 ;
types::StackTypeSet * funTypes = oracle -> getCallArg ( script ( ) , argc , 0 , pc ) ; <NEW_LINE> RootedObject funobj ( cx , ( funTypes ) ? funTypes -> getSingleton ( ) : NULL ) ; <NEW_LINE> RootedFunction target ( cx , ( funobj && funobj -> isFunction ( ) ) ? funobj -> toFunction ( ) : NULL ) ; <NEW_LINE> <START_VULN> if ( inliningDepth == 0 ) { <NEW_LINE> <END_VULN> MPassArg * passVp = current -> pop ( ) -> toPassArg ( ) ; <NEW_LINE> passVp -> replaceAllUsesWith ( passVp -> getArgument ( ) ) ; <NEW_LINE> passVp -> block ( ) -> discard ( passVp ) ; <NEW_LINE> MPassArg * passThis = current -> pop ( ) -> toPassArg ( ) ;
if ( png_ptr == NULL || info_ptr == NULL ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( png_colorspace_set_sRGB ( png_ptr , & info_ptr -> colorspace , srgb_intent ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> info_ptr -> colorspace . flags |=
NS_ENSURE_TRUE ( name , nsnull ) ; <NEW_LINE> for ( i = 0 ; i < count ; i ++ ) { <NEW_LINE> <START_VULN> nsIContent * content = NS_STATIC_CAST ( nsIContent * , <NEW_LINE>mElements . ElementAt ( i ) ) ; <NEW_LINE> <END_VULN> if ( content && <NEW_LINE> ( content -> AttrValueIs ( kNameSpaceID_None , nsHTMLAtoms::name ,
virtual mozilla::dom::EventTarget * GetParentTarget ( ) MOZ_OVERRIDE { return mParent ; } <NEW_LINE> virtual nsIDOMWindow * GetOwnerGlobal ( ) MOZ_OVERRIDE ; <NEW_LINE> NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS ( nsWindowRoot , <NEW_LINE> nsIDOMEventTarget ) <NEW_LINE> protected: <NEW_LINE> <START_VULN> nsPIDOMWindow * mWindow ; <NEW_LINE> <END_VULN> nsRefPtr < nsEventListenerManager > mListenerManager ; <NEW_LINE> nsCOMPtr < nsIDOMNode > mPopupNode ; <NEW_LINE> nsCOMPtr < mozilla::dom::EventTarget > mParent ; <NEW_LINE> } ;
SSL_TRC ( 3 , ( " % d: SSL3 [ % d ] : handle certificate_verify handshake" , <NEW_LINE> SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; <NEW_LINE> PORT_Assert ( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; <NEW_LINE> isTLS = ( PRBool ) ( ss -> ssl3 . prSpec -> version > SSL_LIBRARY_VERSION_3_0 ) ; <NEW_LINE> isTLS12 = ( PRBool ) ( ss -> ssl3 . prSpec -> version >= SSL_LIBRARY_VERSION_TLS_1_2 ) ; <NEW_LINE> <START_VULN> if ( ss -> ssl3 . hs . ws != wait_cert_verify || ss -> sec . peerCert == NULL ) { <NEW_LINE> <END_VULN> desc = unexpected_message ; <NEW_LINE> errCode = SSL_ERROR_RX_UNEXPECTED_CERT_VERIFY ; <NEW_LINE> goto alert_loser ; <NEW_LINE> } <NEW_LINE> if ( isTLS12 ) { <NEW_LINE> rv = ssl3_ConsumeSignatureAndHashAlgorithm ( ss , & b , & length , <NEW_LINE> & sigAndHash ) ;
#include < memory > <NEW_LINE> #include "components / search_provider_logos / logo_common . h" <NEW_LINE> <START_VULN> #include "components / search_provider_logos / logo_service . h" <NEW_LINE> <END_VULN> #include "third_party / skia / include / core / SkBitmap . h"
this_mv . as_mv . row = br + next_chkpts [ k ] [ i ] . row ; <NEW_LINE> this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; <NEW_LINE> this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <NEW_LINE> <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <NEW_LINE> <END_VULN> CHECK_BETTER <NEW_LINE> } <NEW_LINE> } else
<START_VULN> GlyphCache::Loader::Loader ( const Face & face , const bool dumb_font ) <NEW_LINE> <END_VULN> : _head ( face , Tag::head ) , <NEW_LINE> _hhea ( face , Tag::hhea ) , <NEW_LINE> _hmtx ( face , Tag::hmtx ) ,
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: random psychoacoustics ( not including preecho ) <NEW_LINE> <START_VULN> last mod: $ Id: psy . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_PSY_H_ <NEW_LINE> #define _V_PSY_H_ <NEW_LINE> #include "smallft . h" <NEW_LINE> #include "backends . h"
class DummyVideoSource : public VideoSource { <NEW_LINE> public: <NEW_LINE> <START_VULN> DummyVideoSource ( ) : img_ ( NULL ) , limit_ ( 100 ) , width_ ( 0 ) , height_ ( 0 ) { <NEW_LINE>SetSize ( 80 , 64 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> virtual ~ DummyVideoSource ( ) { vpx_img_free ( img_ ) ; }
{ <NEW_LINE> } <NEW_LINE> } ; <NEW_LINE> <START_VULN> TEST_F ( CCLayerTreeHostTestShortlived2 , run ) <NEW_LINE> { <NEW_LINE>runTest ( ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> class CCLayerTreeHostTestShortlived3 : public CCLayerTreeHostTest {
bytes & ( SQUASHFS_METADATA_SIZE - 1 ) ; <NEW_LINE> int length = read_block ( fd , index [ i ] , NULL , expected , <NEW_LINE> ( ( unsigned char * ) xattr_ids ) + <NEW_LINE> <START_VULN> ( i * SQUASHFS_METADATA_SIZE ) ) ; <NEW_LINE> <END_VULN> TRACE ( "Read xattr id table block % d , from 0x % llx , length " <NEW_LINE> " % d\n" , i , index [ i ] , length ) ; <NEW_LINE> if ( length == 0 ) {
<START_VULN> if ( diff == StyleDifferenceLayout ) { <NEW_LINE> <END_VULN> setNeedsLayoutAndPrefWidthsRecalc ( ) ; <NEW_LINE> m_knownToHaveNoOverflowAndNoFallbackFonts = false ; <NEW_LINE> }
return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> void BaseRenderingContext2D::ClearResolvedFilters ( ) { <NEW_LINE> <END_VULN> for ( auto & state : state_stack_ ) <NEW_LINE> state -> ClearResolvedFilter ( ) ; <NEW_LINE> }
const MB_MODE_INFO * mbmi = & mi -> mbmi ; <NEW_LINE> const BLOCK_SIZE block_size = mbmi -> sb_type ; <NEW_LINE> const TX_SIZE tx_size_y = mbmi -> tx_size ; <NEW_LINE> <START_VULN> const TX_SIZE tx_size_uv = get_uv_tx_size ( mbmi ) ; <NEW_LINE> <END_VULN> const int filter_level = get_filter_level ( lfi_n , mbmi ) ; <NEW_LINE> uint64_t * const left_y = & lfm -> left_y [ tx_size_y ] ; <NEW_LINE> uint64_t * const above_y = & lfm -> above_y [ tx_size_y ] ;
void MediaOmxReader::OnDecodeThreadFinish ( ) { <NEW_LINE> if ( mOmxDecoder . get ( ) ) { <NEW_LINE> mOmxDecoder -> Pause ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void MediaOmxReader::OnDecodeThreadStart ( ) { <NEW_LINE> if ( mOmxDecoder . get ( ) ) { <NEW_LINE> <START_VULN> nsresult result = mOmxDecoder -> Play ( ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( result == NS_OK , "OmxDecoder should be in play state to continue decoding" ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
NotifyDOMWindowDestroyed ( this ) ; <NEW_LINE> nsIScriptContext * scx = GetContextInternal ( ) ; <NEW_LINE> <START_VULN> JSContext * cx = scx ? scx -> GetNativeContext ( ) : nullptr ; <NEW_LINE> <END_VULN> mozilla::dom::workers::CancelWorkersForWindow ( cx , this ) ; <NEW_LINE> }
REGISTER_SPL_CLASS_CONST_LONG ( SplFileObject , "READ_AHEAD" , SPL_FILE_OBJECT_READ_AHEAD ) ; <NEW_LINE> REGISTER_SPL_CLASS_CONST_LONG ( SplFileObject , "SKIP_EMPTY" , SPL_FILE_OBJECT_SKIP_EMPTY ) ; <NEW_LINE> REGISTER_SPL_CLASS_CONST_LONG ( SplFileObject , "READ_CSV" , SPL_FILE_OBJECT_READ_CSV ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> REGISTER_SPL_SUB_CLASS_EX ( SplTempFileObject , SplFileObject , spl_filesystem_object_new_check , spl_SplTempFileObject_functions ) ; <NEW_LINE> return SUCCESS ; <NEW_LINE> }
INC_STATS ( "DOM . WebSocket . send ( ) " ) ; <NEW_LINE> if ( ! args . Length ( ) ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> WebSocket * webSocket = V8WebSocket::toNative ( args . Holder ( ) ) ; <NEW_LINE> v8::Handle < v8::Value > message = args [ 0 ] ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> RasterImage::DecodePool::DecodeUntilSizeAvailable ( RasterImage * aImg ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( NS_IsMainThread ( ) ) ; <NEW_LINE> <START_VULN> <NEW_LINE>MutexAutoLock imgLock ( aImg -> mDecodingMutex ) ; <NEW_LINE> <END_VULN> if ( aImg -> mDecodeRequest ) { <NEW_LINE> if ( aImg -> mDecodeRequest -> mRequestStatus == DecodeRequest::REQUEST_WORK_DONE ) { <NEW_LINE> nsresult rv = aImg -> FinishedSomeDecoding ( ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> aImg -> DoError ( ) ; <NEW_LINE> return rv ;
if ( getType ( tarray ) == getType ( self ) ) { <NEW_LINE> memmove ( dest , getDataOffset ( tarray ) , getByteLength ( tarray ) ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> void * srcbuf = cx -> malloc_ ( getLength ( tarray ) ) ; <NEW_LINE> <END_VULN> if ( ! srcbuf ) <NEW_LINE> return false ; <NEW_LINE> js_memcpy ( srcbuf , getDataOffset ( tarray ) , getByteLength ( tarray ) ) ; <NEW_LINE> switch ( getType ( tarray ) ) { <NEW_LINE> case TypedArray::TYPE_INT8: { <NEW_LINE> int8_t * src = ( int8_t * ) srcbuf ; <NEW_LINE> for ( unsigned i = 0 ; i < getLength ( tarray ) ; ++ i )
ionScript -> copySnapshots ( & snapshots_ ) ; <NEW_LINE> if ( graph . numConstants ( ) ) <NEW_LINE> ionScript -> copyConstants ( graph . constantPool ( ) ) ; <NEW_LINE> JS_ASSERT ( graph . mir ( ) . numScripts ( ) > 0 ) ; <NEW_LINE> ionScript -> copyScriptEntries ( graph . mir ( ) . scripts ( ) ) ; <NEW_LINE> if ( callTargets . length ( ) > 0 ) <NEW_LINE> ionScript -> copyCallTargetEntries ( callTargets . begin ( ) ) ; <NEW_LINE> <START_VULN> if ( cx -> zone ( ) -> needsBarrier ( ) ) <NEW_LINE>ionScript -> toggleBarriers ( true ) ; <NEW_LINE> <END_VULN> return true ; <NEW_LINE> } <NEW_LINE> class OutOfLineUnboxDouble : public OutOfLineCodeBase < CodeGenerator > <NEW_LINE> { <NEW_LINE> LUnboxDouble * unboxDouble_ ;
if ( optslen > plen ) { <NEW_LINE> <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <NEW_LINE> <END_VULN> nh = * pkt ;
m_stretchingChildren = ( style ( ) -> boxAlign ( ) == BSTRETCH ) ; <NEW_LINE> for ( RenderBox * child = iterator . first ( ) ; child ; child = iterator . next ( ) ) { <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> child -> containingBlock ( ) -> insertPositionedObject ( child ) ; <NEW_LINE> RenderLayer * childLayer = child -> layer ( ) ; <NEW_LINE> childLayer -> setStaticInlinePosition ( xPos ) ;
if ( useService ) { <NEW_LINE> WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; <NEW_LINE> if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) ) { <NEW_LINE> <START_VULN> HKEY baseKey ; <NEW_LINE> <END_VULN> if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , <NEW_LINE> maintenanceServiceKey , 0 , <NEW_LINE> KEY_READ | KEY_WOW64_64KEY ,
if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) <NEW_LINE> return False ; <NEW_LINE> <START_VULN> token -> end = token -> p = token -> data ; <NEW_LINE> <END_VULN> out_uint8p ( token , s -> p , length ) ; <NEW_LINE> s_mark_end ( token ) ; <NEW_LINE> }
WhichTree GetTree ( ) const override ; <NEW_LINE> bool RequiresHighResToDraw ( ) const override ; <NEW_LINE> <START_VULN> <NEW_LINE>void SyncTiling ( const PictureLayerTiling * tiling ) ; <NEW_LINE> <END_VULN> void GetContentsResourceId ( ResourceProvider::ResourceId * resource_id ,
int main ( int argc , char * argv [ ] ) <NEW_LINE> { <NEW_LINE> <START_VULN> char * p , * q , * r ; <NEW_LINE> <END_VULN> Clp_Parser * clp = <NEW_LINE> Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ;
case EFFECT_CMD_SET_CONFIG: <NEW_LINE> <START_VULN> if ( pCmdData == NULL || <NEW_LINE>cmdSize != sizeof ( effect_config_t ) || <NEW_LINE>pReplyData == NULL || <NEW_LINE> * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Reverb_command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_SET_CONFIG: ERROR" ) ; <NEW_LINE> return - EINVAL ;
} <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> f -> SetTextRun ( aTextRun , mWhichTextRun , aInflation ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> startFrame -> AddStateBits ( TEXT_IN_TEXTRUN_USER_DATA ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> gfxSkipCharsIterator <NEW_LINE> nsTextFrame::EnsureTextRun ( TextRunType aWhichTextRun , <NEW_LINE> gfxContext * aReferenceContext , <NEW_LINE> nsIFrame * aLineContainer , <NEW_LINE> const nsLineList::iterator * aLine ,
} <NEW_LINE> #endif <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #endif <NEW_LINE>
nsresult rv = aState . addVariable ( var -> mName ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsAutoPtr < txInstruction > instr ( var . forget ( ) ) ; <NEW_LINE> rv = aState . addInstruction ( instr ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> txCheckParam * checkParam = static_cast < txCheckParam * > ( aState . popPtr ( ) ) ; <NEW_LINE> <END_VULN> aState . addGotoTarget ( & checkParam -> mBailTarget ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> xsl:processing - instruction
#include < wtf / PassRefPtr . h > <NEW_LINE> namespace WebCore { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> class WebKitCSSMixFunctionValue : public CSSValueList { <NEW_LINE> public: <NEW_LINE> static PassRefPtr < WebKitCSSMixFunctionValue > create ( )
gfx::Rect visible_rect ; <NEW_LINE> protected: <NEW_LINE> <START_VULN> friend class base::RefCounted < VP8Picture > ; <NEW_LINE> <END_VULN> virtual ~ VP8Picture ( ) ; <NEW_LINE> DISALLOW_COPY_AND_ASSIGN ( VP8Picture ) ;
#define PROGRESS_PREPARE_SIZE 20 . 0f <NEW_LINE> #define PROGRESS_EXECUTE_SIZE 75 . 0f <NEW_LINE> #define PROGRESS_FINISH_SIZE 5 . 0f <NEW_LINE> <START_VULN> #define PARENT_WAIT 5000 <NEW_LINE> <END_VULN> #define IMMERSIVE_PARENT_WAIT 15000 <NEW_LINE> #if defined ( XP_MACOSX ) <NEW_LINE> void LaunchChild ( int argc , char ** argv ) ; <NEW_LINE> void LaunchMacPostProcess ( const char * aAppBundle ) ; <NEW_LINE> #endif
{ <NEW_LINE> png_debug1 ( 1 , "in % s retrieval function" , "sRGB" ) ; <NEW_LINE> <START_VULN> if ( png_ptr != NULL && info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_sRGB ) <NEW_LINE> && file_srgb_intent != NULL ) <NEW_LINE> <END_VULN> { <NEW_LINE> * file_srgb_intent = info_ptr -> colorspace . rendering_intent ; <NEW_LINE> return ( PNG_INFO_sRGB ) ;
return args . Holder ( ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , type , args [ 0 ] ) ; <NEW_LINE> TestEventConstructorInit eventInit ;
{ <NEW_LINE> case SEI_USER_DATA_REGISTERED_ITU_T_T35: <NEW_LINE> ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; <NEW_LINE> <START_VULN> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <NEW_LINE>u4_payload_size ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> default:
#include "public / platform / WebMediaStreamTrack . h" <NEW_LINE> #include "core / platform / mediastream / MediaStreamComponent . h" <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "public / platform / WebAudioSourceProvider . h" <NEW_LINE> #include "public / platform / WebMediaStream . h" <NEW_LINE> #include "public / platform / WebMediaStreamSource . h"
#include "wtf / unicode / Unicode . h" <NEW_LINE> #if OS ( WIN ) <NEW_LINE> <START_VULN> #include "core / platform / win / HWndDC . h" <NEW_LINE> <END_VULN> #endif <NEW_LINE> namespace WebCore {
bdrv_delete ( bs1 ) ; <NEW_LINE> <START_VULN> get_tmp_filename ( tmp_filename , sizeof ( tmp_filename ) ) ; <NEW_LINE> <END_VULN> if ( is_protocol )
} <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::enumerate ( JSContext * cx , JSObject * wrapper , AutoIdVector & props ) <NEW_LINE> { <NEW_LINE> PIERCE ( cx , wrapper , GET , <NEW_LINE> NOTHING , <NEW_LINE> DirectWrapper::enumerate ( cx , wrapper , props ) , <NEW_LINE> <START_VULN> call . origin -> wrap ( cx , props ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::has ( JSContext * cx , JSObject * wrapper , jsid id , bool * bp ) <NEW_LINE> { <NEW_LINE> PIERCE ( cx , wrapper , GET , <NEW_LINE> call . destination -> wrapId ( cx , & id ) , <NEW_LINE> DirectWrapper::has ( cx , wrapper , id , bp ) ,
bc + candidates [ s ] [ next_chkpts_indices [ i ] ] . col } ; <NEW_LINE> thissad = vfp -> sdf ( what -> buf , what -> stride , <NEW_LINE> get_buf_from_mv ( in_what , & this_mv ) , <NEW_LINE> <START_VULN> in_what -> stride , bestsad ) ; <NEW_LINE> <END_VULN> CHECK_BETTER <NEW_LINE> } <NEW_LINE> } else {
const std::string & password , <NEW_LINE> StartSyncMode start_mode , <NEW_LINE> bool force_same_tab_navigation , <NEW_LINE> <START_VULN> ConfirmationRequired display_confirmation ) ; <NEW_LINE> <END_VULN> virtual void OnBrowserRemoved ( Browser * browser ) OVERRIDE ;
<START_VULN> #ifndef BASE_CLOCK_H_ <NEW_LINE>#define BASE_CLOCK_H_ <NEW_LINE> <END_VULN> #include "base / base_export . h" <NEW_LINE> #include "base / time / time . h"
{ <NEW_LINE> JS_ASSERT ( tc -> inFunction ( ) ) ; <NEW_LINE> return HasFinalReturn ( pn ) == ENDS_IN_RETURN || <NEW_LINE> <START_VULN> ReportBadReturn ( cx , tc , JSREPORT_WARNING | JSREPORT_STRICT , <NEW_LINE> <END_VULN> JSMSG_NO_RETURN_VALUE , JSMSG_ANON_NO_RETURN_VALUE ) ; <NEW_LINE> }
xd -> mi [ 0 ] -> bmi [ i ] . as_mode = best_bmodes [ i ] . as_mode ; <NEW_LINE> } else { <NEW_LINE> for ( i = 0 ; i < 4 ; ++ i ) <NEW_LINE> <START_VULN> vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ; <NEW_LINE> <END_VULN> mbmi -> mv [ 0 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 0 ] . as_int ; <NEW_LINE> mbmi -> mv [ 1 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 1 ] . as_int ;
return ; <NEW_LINE> m_frame -> document ( ) -> cancelParsing ( ) ; <NEW_LINE> <START_VULN> detachDocumentLoader ( m_provisionalDocumentLoader ) ; <NEW_LINE> <END_VULN>
while ( pinfo != NULL ) <NEW_LINE> { <NEW_LINE> <START_VULN> fprintf ( STDERR , " % lu bytes at % x\n" , <NEW_LINE> ( unsigned long ) pinfo -> size , ( unsigned int ) pinfo -> pointer ) ; <NEW_LINE> <END_VULN> pinfo = pinfo -> next ; <NEW_LINE> } <NEW_LINE> }
<START_VULN> #ifndef BASE_TICK_CLOCK_H_ <NEW_LINE>#define BASE_TICK_CLOCK_H_ <NEW_LINE> <END_VULN> #include "base / base_export . h" <NEW_LINE> #include "base / time / time . h"
static uint32 <NEW_LINE> XDRGetAtomIndex ( JSXDRState * xdr , JSAtom * atom ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( XDRAtomsHashMap::Ptr p = xdr -> atomsMap -> lookup ( atom ) ) <NEW_LINE> <END_VULN> return p -> value ; <NEW_LINE> return uint32 ( - 1 ) ; <NEW_LINE> }
return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsHTMLMediaElement::SetSrc ( JSContext * aCtx , const jsval & aParams ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( JSVAL_IS_OBJECT ( aParams ) ) { <NEW_LINE> <END_VULN> nsCOMPtr < nsIDOMMediaStream > stream ; <NEW_LINE> stream = do_QueryInterface ( nsContentUtils::XPConnect ( ) -> <NEW_LINE> GetNativeOfWrapper ( aCtx , JSVAL_TO_OBJECT ( aParams ) ) ) ; <NEW_LINE> if ( stream ) { <NEW_LINE> mSrcAttrStream = static_cast < nsDOMMediaStream * > ( stream . get ( ) ) ; <NEW_LINE> UnsetAttr ( kNameSpaceID_None , nsGkAtoms::src , true ) ; <NEW_LINE> Load ( ) ; <NEW_LINE> return NS_OK ;
} <NEW_LINE> http_ProtoVer ( hp ) ; <NEW_LINE> <START_VULN> retval = htc_request_check_host_hdr ( hp ) ; <NEW_LINE>if ( retval != 0 ) { <NEW_LINE>WSP ( sp , SLT_Error , "Duplicated Host header" ) ; <NEW_LINE>return ( retval ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> return ( retval ) ; <NEW_LINE> }
#include < assert . h > <NEW_LINE> #include "vpx_config . h" <NEW_LINE> #include "vp8_rtcd . h" <NEW_LINE> <START_VULN> #include "vp8 / common / pragmas . h" <NEW_LINE> <END_VULN> #include "tokenize . h" <NEW_LINE> #include "treewriter . h" <NEW_LINE> #include "onyx_int . h"
nameh2 = stringNew ( "" ) ; <NEW_LINE> namev2 = stringNew ( "" ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> snprintf ( buf , L_BUF_SIZE , <NEW_LINE> <END_VULN> " { % d , % d , % d , \" % s\" , \" % s\" , \" % s\" , \" % s\" } , " , <NEW_LINE> size , size1 , size2 , nameh1 , nameh2 , namev1 , namev2 ) ; <NEW_LINE> sarrayAddString ( sa , buf , L_COPY ) ;
dp += ( len + ( 2 * sizeof ( uint32_t ) + 3 ) ) / sizeof ( uint32_t ) ; <NEW_LINE> <START_VULN> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <NEW_LINE> <END_VULN> astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ; <NEW_LINE> if ( astat != SUNRPC_SUCCESS ) { <NEW_LINE> ND_PRINT ( ( ndo , " % s" , tok2str ( sunrpc_str , "ar_stat % d" , astat ) ) ) ;
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 3 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> const String & str ( ustringToString ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . isEmpty ( ) ? UString ( ) : MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . toString ( exec ) -> value ( exec ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) )
entry . is_persistent = mydata -> is_persistent ; <NEW_LINE> for ( manifest_index = 0 ; manifest_index < manifest_count ; ++ manifest_index ) { <NEW_LINE> <START_VULN> if ( buffer + 4 > endbuffer ) { <NEW_LINE> <END_VULN> MAPPHAR_FAIL ( "internal corruption of phar \" % s\" ( truncated manifest entry ) " ) <NEW_LINE> }
return ; <NEW_LINE> } <NEW_LINE> if ( protocolIsJavaScript ( submission -> action ( ) ) ) { <NEW_LINE> <START_VULN> if ( ! document ( ) . contentSecurityPolicy ( ) -> allowFormAction ( <NEW_LINE>submission -> action ( ) ) ) <NEW_LINE>return ; <NEW_LINE> <END_VULN> document ( ) . frame ( ) -> script ( ) . executeScriptIfJavaScriptURL ( <NEW_LINE> submission -> action ( ) , this ) ; <NEW_LINE> return ;
if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { <NEW_LINE> struct crypto_report_larval rl ; <NEW_LINE> <START_VULN> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , " % s" , "larval" ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , <NEW_LINE> sizeof ( struct crypto_report_larval ) , & rl ) ) <NEW_LINE> goto nla_put_failure ;
static void locationAttributeSetter ( v8::Local < v8::Value > jsValue , const v8::PropertyCallbackInfo < void > & info ) <NEW_LINE> { <NEW_LINE> TestObjectPython * proxyImp = V8TestObjectPython::toNative ( info . Holder ( ) ) ; <NEW_LINE> <START_VULN> TestNode * imp = WTF::getPtr ( proxyImp -> location ( ) ) ; <NEW_LINE> <END_VULN> if ( ! imp ) <NEW_LINE> return ; <NEW_LINE> V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID ( V8StringResource < > , cppValue , jsValue ) ;
void * rv ; <NEW_LINE> gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <NEW_LINE> if ( out == NULL ) return NULL ; <NEW_LINE> <START_VULN> gdImageGifCtx ( im , out ) ; <NEW_LINE>rv = gdDPExtractData ( out , size ) ; <NEW_LINE> <END_VULN> out -> gd_free ( out ) ; <NEW_LINE> return rv ; <NEW_LINE> }
int cipher_len , key_len , data_len , iv_len = 0 ; <NEW_LINE> MCRYPT_GET_CRYPT_ARGS <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> convert_to_string_ex ( mode ) ; <NEW_LINE> php_mcrypt_do_crypt ( cipher , key , key_len , data , data_len , Z_STRVAL_PP ( mode ) , iv , iv_len , ZEND_NUM_ARGS ( ) , MCRYPT_DECRYPT , return_value TSRMLS_CC ) ;
} <NEW_LINE> long vorbis_coslook_i ( long a ) { <NEW_LINE> int i = a >> COS_LOOKUP_I_SHIFT ; <NEW_LINE> int d = a & COS_LOOKUP_I_MASK ; <NEW_LINE> return COS_LOOKUP_I [ i ] - ( ( d * ( COS_LOOKUP_I [ i ] - COS_LOOKUP_I [ i + 1 ] ) ) >> <NEW_LINE> <START_VULN> COS_LOOKUP_I_SHIFT ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif
KEYBOARD_EXPORT extern const char kEnableVirtualKeyboardOverscroll [ ] ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>KEYBOARD_EXPORT extern const char kDisableSmartVirtualKeyboard [ ] ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
bool ms_handle_refused ( Connection * con ) override ; <NEW_LINE> bool ms_get_authorizer ( int dest_type , AuthAuthorizer ** authorizer , <NEW_LINE> bool force_new ) override ; <NEW_LINE> <START_VULN> bool ms_verify_authorizer ( Connection * con , <NEW_LINE>int peer_type , <NEW_LINE>int protocol , <NEW_LINE>ceph::bufferlist & authorizer , <NEW_LINE>ceph::bufferlist & authorizer_reply , <NEW_LINE>bool & isvalid , <NEW_LINE>CryptoKey & session_key ) override ; <NEW_LINE> <END_VULN> bool handle_open ( MMgrOpen * m ) ; <NEW_LINE> bool handle_report ( MMgrReport * m ) ;
mozAutoDocUpdate updateBatch ( aDocument , UPDATE_CONTENT_MODEL , aNotify ) ; <NEW_LINE> nsMutationGuard guard ; <NEW_LINE> mozAutoSubtreeModified subtree ( nsnull , nsnull ) ; <NEW_LINE> if ( aNotify && <NEW_LINE> nsContentUtils::HasMutationListeners ( aKid , <NEW_LINE> NS_EVENT_BITS_MUTATION_NODEREMOVED , container ) ) { <NEW_LINE> <START_VULN> mozAutoRemovableBlockerRemover blockerRemover ; <NEW_LINE> <END_VULN> nsMutationEvent mutation ( PR_TRUE , NS_MUTATION_NODEREMOVED ) ; <NEW_LINE> mutation . mRelatedNode = do_QueryInterface ( container ) ; <NEW_LINE> subtree . UpdateTarget ( container -> GetOwnerDoc ( ) , container ) ; <NEW_LINE> nsEventDispatcher::Dispatch ( aKid , nsnull , & mutation ) ; <NEW_LINE> }
} ; <NEW_LINE> <START_VULN> static void watchdog_overflow_callback ( struct perf_event * event , int nmi , <NEW_LINE> <END_VULN> struct perf_sample_data * data , <NEW_LINE> struct pt_regs * regs ) <NEW_LINE> {
static std::vector < PageHandler * > ForAgentHost ( DevToolsAgentHostImpl * host ) ; <NEW_LINE> void Wire ( UberDispatcher * dispatcher ) override ; <NEW_LINE> <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) override ; <NEW_LINE> void OnSwapCompositorFrame ( viz::CompositorFrameMetadata frame_metadata ) ; <NEW_LINE> void OnSynchronousSwapCompositorFrame (
void nsGfxScrollFrameInner::ScrollVisual ( nsPoint aOldScrolledFramePos ) <NEW_LINE> { <NEW_LINE> nsRootPresContext * rootPresContext = mOuter -> PresContext ( ) -> GetRootPresContext ( ) ; <NEW_LINE> if ( ! rootPresContext ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> rootPresContext -> RequestUpdatePluginGeometry ( mOuter ) ; <NEW_LINE> <END_VULN> AdjustViews ( mScrolledFrame ) ; <NEW_LINE> uint32_t flags = nsIFrame::INVALIDATE_REASON_SCROLL_REPAINT ; <NEW_LINE> bool canScrollWithBlitting = CanScrollWithBlitting ( mOuter ) ; <NEW_LINE> mOuter -> RemoveStateBits ( NS_SCROLLFRAME_INVALIDATE_CONTENTS_ON_SCROLL ) ; <NEW_LINE> if ( IsScrollingActive ( ) ) {
if ( mBoundFramebuffer ) { <NEW_LINE> if ( ! mBoundFramebuffer -> CheckAndInitializeRenderbuffers ( ) ) <NEW_LINE> return ErrorInvalidFramebufferOperation ( "readPixels: incomplete framebuffer" ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( width == 0 || height == 0 ) <NEW_LINE>return DummyFramebufferOperation ( "readPixels" ) ; <NEW_LINE> <END_VULN> if ( CanvasUtils::CheckSaneSubrectSize ( x , y , width , height , framebufferWidth , framebufferHeight ) ) { <NEW_LINE> gl -> fReadPixels ( x , y , width , height , format , type , data ) ; <NEW_LINE> } else {
#include "third_party / blink / renderer / platform / geometry / float_rect . h" <NEW_LINE> #include "third_party / blink / renderer / platform / graphics / paint / display_item . h" <NEW_LINE> #include "third_party / blink / renderer / platform / graphics / paint / hit_test_data . h" <NEW_LINE> #include "third_party / blink / renderer / platform / graphics / paint / raster_invalidation_tracking . h" <NEW_LINE> <START_VULN> #include "third_party / blink / renderer / platform / graphics / paint / ref_counted_property_tree_state . h" <NEW_LINE> <END_VULN> #include "third_party / blink / renderer / platform / platform_export . h" <NEW_LINE> #include "third_party / blink / renderer / platform / wtf / allocator . h" <NEW_LINE> #include "third_party / blink / renderer / platform / wtf / forward . h"
if ( JSDOUBLE_IS_NaN ( local ) ) <NEW_LINE> return ; <NEW_LINE> local = date_msecFromDate ( YearFromTime ( local ) , <NEW_LINE> MonthFromTime ( local ) , <NEW_LINE> DateFromTime ( local ) , <NEW_LINE> HourFromTime ( local ) , <NEW_LINE> MinFromTime ( local ) , <NEW_LINE> seconds , <NEW_LINE> msFromTime ( local ) ) ; <NEW_LINE> <START_VULN> SetUTCTime ( cx , obj , NULL , UTC ( local ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_FRIEND_API ( jsdouble ) <NEW_LINE> js_DateGetMsecSinceEpoch ( JSContext * cx , JSObject * obj ) <NEW_LINE> { <NEW_LINE> jsdouble utctime ; <NEW_LINE> if ( ! GetUTCTime ( cx , obj , NULL , & utctime ) ) <NEW_LINE> return 0 ; <NEW_LINE> return utctime ;
mImageLoad -> GetImage ( getter_AddRefs ( mImage ) ) ; <NEW_LINE> if ( ! mImage ) { <NEW_LINE> mImage = do_CreateInstance ( "@mozilla . org / image / container ; 1" ) ; <NEW_LINE> if ( ! mImage ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> mImageLoad -> SetImage ( mImage ) ; <NEW_LINE> <START_VULN> nsresult result = mImage -> SetDiscardable ( "image / jpeg" ) ; <NEW_LINE>if ( NS_FAILED ( result ) ) { <NEW_LINE>mState = JPEG_ERROR ; <NEW_LINE>PR_LOG ( gJPEGDecoderAccountingLog , PR_LOG_DEBUG , <NEW_LINE> ( " ( could not set image container to discardable ) " ) ) ; <NEW_LINE>return result ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> }
if ( IsFullyDefined < T > ::value && ! IsGarbageCollectedMixin < T > ::value ) <NEW_LINE> <START_VULN> ASSERT ( HeapObjectHeader::fromPayload ( m_raw ) -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> #endif <NEW_LINE> }
event -> InitEvent ( inputBuffer , <NEW_LINE> mInputChannels . Length ( ) , <NEW_LINE> mPlaybackTime ) ; <NEW_LINE> node -> DispatchTrustedEvent ( event ) ; <NEW_LINE> nsRefPtr < ThreadSharedFloatArrayBufferList > output ; <NEW_LINE> if ( event -> HasOutputBuffer ( ) ) { <NEW_LINE> <START_VULN> output = event -> OutputBuffer ( ) -> GetThreadSharedChannelsForRate ( cx ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> node -> GetSharedBuffers ( ) -> FinishProducingOutputBuffer ( output , node -> BufferSize ( ) ) ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> private:
} <NEW_LINE> if ( ! CallJSNative ( cx , native , dstArgs ) ) <NEW_LINE> return false ; <NEW_LINE> srcArgs . rval ( ) = dstArgs . rval ( ) ; <NEW_LINE> dstArgs . pop ( ) ; <NEW_LINE> call . leave ( ) ; <NEW_LINE> <START_VULN> return call . origin -> wrap ( cx , & srcArgs . rval ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::hasInstance ( JSContext * cx , JSObject * wrapper , const Value * vp , bool * bp ) <NEW_LINE> { <NEW_LINE> AutoCompartment call ( cx , wrappedObject ( wrapper ) ) ; <NEW_LINE> if ( ! call . enter ( ) ) <NEW_LINE> return false ;
} <NEW_LINE> nsresult <NEW_LINE> RasterImage::FinishedSomeDecoding ( eShutdownIntent aIntent , <NEW_LINE> DecodeRequest * aRequest ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( NS_IsMainThread ( ) ) ; <NEW_LINE> <START_VULN> mDecodingMutex . AssertCurrentThreadOwns ( ) ; <NEW_LINE> <END_VULN> nsRefPtr < DecodeRequest > request ; <NEW_LINE> if ( aRequest ) { <NEW_LINE> request = aRequest ; <NEW_LINE> } else { <NEW_LINE> request = mDecodeRequest ; <NEW_LINE> }
static void set_segment_data ( VP8_COMP * cpi , signed char * feature_data , unsigned char abs_delta ) <NEW_LINE> { <NEW_LINE> cpi -> mb . e_mbd . mb_segement_abs_delta = abs_delta ; <NEW_LINE> <START_VULN> vpx_memcpy ( cpi -> segment_feature_data , feature_data , sizeof ( cpi -> segment_feature_data ) ) ; <NEW_LINE> <END_VULN> }
JSVAL_FALSE ) || <NEW_LINE> ! JS_SetReservedSlot ( cx , outerObj , XPC_XOW_ScopeSlot , <NEW_LINE> PRIVATE_TO_JSVAL ( parentScope ) ) ) { <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> * vp = OBJECT_TO_JSVAL ( outerObj ) ; <NEW_LINE> <START_VULN> { <NEW_LINE>XPCAutoLock al ( rt -> GetMapLock ( ) ) ; <NEW_LINE>map -> Add ( wn -> GetScope ( ) -> GetWrapperMap ( ) , wrappedObj , outerObj ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> return JS_TRUE ; <NEW_LINE> } <NEW_LINE> static JSBool <NEW_LINE> XPC_XOW_AddProperty ( JSContext * cx , JSObject * obj , jsval id , jsval * vp ) <NEW_LINE> {
ret = add_to_page_cache_lru ( page , mapping , index , <NEW_LINE> GFP_KERNEL ) ; <NEW_LINE> if ( unlikely ( ret ) ) <NEW_LINE> <START_VULN> goto out ; <NEW_LINE> <END_VULN> } <NEW_LINE> ret = mapping -> a_ops -> prepare_write ( file , page , offset , offset + this_len ) ;
continue ; <NEW_LINE> } <NEW_LINE> JSObject * object = nullptr ; <NEW_LINE> wrappedJS -> GetJSObject ( & object ) ; <NEW_LINE> if ( ! object ) { <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> NS_ENSURE_STATE ( pusher . Push ( ctx , false ) ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( ctx ) ; <NEW_LINE> JSAutoCompartment ac ( ctx , object ) ; <NEW_LINE> JSObject * param = JS_NewObject ( ctx , NULL , NULL , NULL ) ; <NEW_LINE> NS_ENSURE_TRUE ( param , NS_ERROR_OUT_OF_MEMORY ) ;
<START_VULN> const vp9_prob vp9_pareto8_full [ COEFF_PROB_MODELS ] [ MODEL_NODES ] = { <NEW_LINE> <END_VULN> { 3 , 86 , 128 , 6 , 86 , 23 , 88 , 29 } , <NEW_LINE> { 6 , 86 , 128 , 11 , 87 , 42 , 91 , 52 } , <NEW_LINE> { 9 , 86 , 129 , 17 , 88 , 61 , 94 , 76 } ,
vpx_codec_priv_cb_pair_t put_slice_cb ; <NEW_LINE> } dec ; <NEW_LINE> struct { <NEW_LINE> <START_VULN> int tbd ; <NEW_LINE>struct vpx_fixed_buf cx_data_dst_buf ; <NEW_LINE> <END_VULN> unsigned int cx_data_pad_before ; <NEW_LINE> unsigned int cx_data_pad_after ; <NEW_LINE> vpx_codec_cx_pkt_t cx_data_pkt ;
PaintPropertyChangeType ComputeChange ( <NEW_LINE> const State & other , <NEW_LINE> const AnimationState & animation_state ) const { <NEW_LINE> <START_VULN> if ( transform_and_origin . Origin ( ) != <NEW_LINE>other . transform_and_origin . Origin ( ) || <NEW_LINE>flattens_inherited_transform != other . flattens_inherited_transform || <NEW_LINE> <END_VULN> affected_by_outer_viewport_bounds_delta != <NEW_LINE> other . affected_by_outer_viewport_bounds_delta || <NEW_LINE> backface_visibility != other . backface_visibility ||
dst -> stride = stride ; <NEW_LINE> } <NEW_LINE> <START_VULN> void vp9_setup_dst_planes ( MACROBLOCKD * xd , const YV12_BUFFER_CONFIG * src , <NEW_LINE> <END_VULN> int mi_row , int mi_col ) ; <NEW_LINE> void vp9_setup_pre_planes ( MACROBLOCKD * xd , int idx ,
void InlineWebstoreInstall ( int install_id , <NEW_LINE> std::string webstore_item_id , <NEW_LINE> <START_VULN> GURL requestor_url ) ; <NEW_LINE> <END_VULN> int browser_window_id ( ) const { return browser_window_id_ ; } <NEW_LINE> content::ViewType view_type ( ) const { return view_type_ ; }
for ( uint32_t index = 0 ; index < storages . Length ( ) ; index ++ ) { <NEW_LINE> storages [ index ] -> Invalidate ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> OriginClearRunnable::DeleteFiles ( QuotaManager * aQuotaManager ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( aQuotaManager , "Don't pass me null ! " ) ; <NEW_LINE> nsresult rv ; <NEW_LINE> nsCOMPtr < nsIFile > directory = <NEW_LINE> do_CreateInstance ( NS_LOCAL_FILE_CONTRACTID , & rv ) ; <NEW_LINE> NS_ENSURE_SUCCESS_VOID ( rv ) ;
memcpy ( packet + sizeof ( tETH_HDR ) , buf , len ) ; <NEW_LINE> <START_VULN> int ret = write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ; <NEW_LINE> <END_VULN> BTIF_TRACE_DEBUG ( "ret: % d" , ret ) ; <NEW_LINE> return ret ; <NEW_LINE> }
fd_install ( fd , filp ) ; <NEW_LINE> goto out_upsem ; <NEW_LINE> out_putfd: <NEW_LINE> <START_VULN> mntput ( mqueue_mnt ) ; <NEW_LINE> <END_VULN> put_unused_fd ( fd ) ; <NEW_LINE> out_err: <NEW_LINE> fd = error ;
ra -> ip6ra_len = ip6_optlen ; <NEW_LINE> if ( ip6_optlen < sizeof ( ra -> ip6ra_value ) ) { <NEW_LINE> <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> }
} <NEW_LINE> void CopyToOMX ( const OMX_BUFFERHEADERTYPE * header ) { <NEW_LINE> <START_VULN> if ( ! mIsBackup ) { <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: LPC low level routines <NEW_LINE> <START_VULN> last mod: $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_LPC_H_ <NEW_LINE> #define _V_LPC_H_ <NEW_LINE> #include "vorbis / codec . h"
" < ! -- This program is part of the Boa Webserver Copyright ( C ) 1991 - 2002 http: <NEW_LINE> " < / body > \n < / html > \n" , now ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
if ( ( quantum != 0 ) && ( length != 0 ) ) <NEW_LINE> { <NEW_LINE> if ( length > GetBlobSize ( image ) ) <NEW_LINE> <START_VULN> ThrowReaderException ( CorruptImageError , <NEW_LINE> <END_VULN> "InsufficientImageDataInFile" ) ; <NEW_LINE> if ( ~ length >= 1 ) <NEW_LINE> data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum *
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: libvorbis codec headers <NEW_LINE> <START_VULN> last mod: $ Id $ <NEW_LINE> <END_VULN> #ifndef _vorbis_codec_h_ <NEW_LINE> #define _vorbis_codec_h_ <NEW_LINE> #ifdef __cplusplus <NEW_LINE> extern "C"
SetHeader ( ) ; <NEW_LINE> buffer = _buffer ; <NEW_LINE> drawbuffers = _drawbuffers ; <NEW_LINE> <START_VULN> memcpy ( ImmediateDataAddress ( this ) , _value , ComputeDataSize ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void * Set ( void * cmd ,
strcat ( header , " . hdr" ) ; <NEW_LINE> #endif <NEW_LINE> if ( ! chunk_writer_header_ -> Open ( header ) ) { <NEW_LINE> <START_VULN> delete [ ] header ; <NEW_LINE> <END_VULN> return false ; <NEW_LINE> }
void SensorDeviceFound ( <NEW_LINE> mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> const PlatformSensorProviderBase::CreateSensorCallback & callback , <NEW_LINE> const SensorInfoLinux * sensor_device ) ;
int ras_validate ( jas_stream_t * in ) <NEW_LINE> { <NEW_LINE> <START_VULN> uchar buf [ RAS_MAGICLEN ] ; <NEW_LINE> <END_VULN> int i ; <NEW_LINE> int n ; <NEW_LINE> uint_fast32_t magic ;
} <NEW_LINE> break ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> default: { <NEW_LINE> DEBUG_PRINT_ERROR ( "get_config: unknown param % d" , configIndex ) ; <NEW_LINE> eRet = OMX_ErrorBadParameter ;
g_variant_new ( " ( bs ) " , FALSE , reason ) ) ; <NEW_LINE> g_free ( reason ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> tcmur_unregister_handler ( handler ) ; <NEW_LINE> <END_VULN> dbus_unexport_handler ( handler ) ; <NEW_LINE> }
if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> if ( * result ) <NEW_LINE> return NS_OK ; <NEW_LINE> if ( JS_IsGlobalFrame ( cx , fp ) ) <NEW_LINE> break ; <NEW_LINE> <START_VULN> } while ( ( fp = JS_FrameIterator ( cx , & fp ) ) != nsnull ) ; <NEW_LINE> <END_VULN> if ( ! previousPrincipal ) <NEW_LINE> { <NEW_LINE> return SubjectPrincipalIsSystem ( result ) ; <NEW_LINE> }
ShouldHaveFirstLineStyle ( containingBlock -> GetContent ( ) , <NEW_LINE> containingBlock -> GetStyleContext ( ) ) ; <NEW_LINE> } <NEW_LINE> if ( haveFirstLetterStyle ) { <NEW_LINE> if ( parentFrame -> GetType ( ) == nsGkAtoms::letterFrame ) { <NEW_LINE> <START_VULN> parentFrame = parentFrame -> GetParent ( ) ; <NEW_LINE> <END_VULN> container = parentFrame -> GetContent ( ) ; <NEW_LINE> } <NEW_LINE> RemoveLetterFrames ( state . mPresContext , mPresShell , <NEW_LINE> state . mFrameManager , <NEW_LINE> state . mFloatedItems . containingBlock ) ;
<START_VULN> <NEW_LINE> <END_VULN> void Quit ( ) ;
DWORD result = ::WaitForSingleObject ( mTaskThread , 5000 ) ; <NEW_LINE> if ( result != WAIT_TIMEOUT ) { <NEW_LINE> ::DeleteCriticalSection ( & mTaskMutex ) ; <NEW_LINE> ::CloseHandle ( mShutdownEvent ) ; <NEW_LINE> ::CloseHandle ( mTaskSemaphore ) ; <NEW_LINE> ::CloseHandle ( mTaskThread ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> NS_WARNING ( "ReadbackManager: Task thread did not shutdown in 5 seconds . Leaking . " ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> ReadbackManagerD3D10::PostTask ( ID3D10Texture2D * aTexture , void * aUpdate , const gfxPoint & aOrigin ) <NEW_LINE> { <NEW_LINE> ReadbackTask * task = new ReadbackTask ; <NEW_LINE> task -> mReadbackTexture = aTexture ;
nsresult rv = nsContentSink::Init ( aDoc , aURI , aContainer , aChannel ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> aDoc -> AddObserver ( this ) ; <NEW_LINE> mIsDocumentObserver = PR_TRUE ; <NEW_LINE> <START_VULN> CallQueryInterface ( aDoc , & mHTMLDocument ) ; <NEW_LINE> <END_VULN> mObservers = nsnull ; <NEW_LINE> nsIParserService * service = nsContentUtils::GetParserService ( ) ; <NEW_LINE> if ( ! service ) { <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE> service -> GetTopicObservers ( NS_LITERAL_STRING ( "text / html" ) ,
int tok <NEW_LINE> = XmlPrologTok ( parser -> m_internalEncoding , textStart , textEnd , & next ) ; <NEW_LINE> result = doProlog ( parser , parser -> m_internalEncoding , textStart , textEnd , <NEW_LINE> <START_VULN> tok , next , & next , XML_FALSE ) ; <NEW_LINE> <END_VULN> } else <NEW_LINE> #endif <NEW_LINE> result = doContent ( parser , parser -> m_tagLevel , parser -> m_internalEncoding ,
if ( ( cm -> frame_type == KEY_FRAME ) || ( cm -> refresh_golden_frame ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <NEW_LINE> <END_VULN> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; <NEW_LINE> } <NEW_LINE> else
Member < Element > element_ ; <NEW_LINE> Member < ContainerNode > parent_node_ ; <NEW_LINE> Member < ContainerNode > layout_parent_ ; <NEW_LINE> <START_VULN> const ComputedStyle * root_element_style_ ; <NEW_LINE> <END_VULN> EInsideLink element_link_state_ ; <NEW_LINE> bool distributed_to_insertion_point_ ; <NEW_LINE> } ;
return - 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> return mount_entry_on_generic ( mntent , path ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int mount_entry_on_relative_rootfs ( struct mntent * mntent ,
using SourcesMapEntry = <NEW_LINE> std::pair < mojom::SensorType , scoped_refptr < PlatformSensor >> ; <NEW_LINE> PlatformSensorFusion ( <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> PlatformSensorProvider * provider , <NEW_LINE> std::unique_ptr < PlatformSensorFusionAlgorithm > fusion_algorithm , <NEW_LINE> SourcesMap sources ) ;
long dim ; <NEW_LINE> long entries ; <NEW_LINE> long used_entries ; <NEW_LINE> const static_codebook * c ; <NEW_LINE> <START_VULN> float * valuelist ; <NEW_LINE> <END_VULN> ogg_uint32_t * codelist ; <NEW_LINE> int * dec_index ; <NEW_LINE> char * dec_codelengths ; <NEW_LINE> ogg_uint32_t * dec_firsttable ; <NEW_LINE> int dec_firsttablen ; <NEW_LINE> int dec_maxlength ;
InjectedScriptManager * injectedScriptManager = m_injectedScriptManager . get ( ) ; <NEW_LINE> InspectorOverlay * overlay = m_overlay . get ( ) ; <NEW_LINE> <START_VULN> OwnPtr < InspectorResourceAgent > resourceAgentPtr ( InspectorResourceAgent::create ( m_pageAgent , m_inspectorClient ) ) ; <NEW_LINE> <END_VULN> InspectorResourceAgent * resourceAgent = resourceAgentPtr . get ( ) ; <NEW_LINE> m_agents . append ( resourceAgentPtr . release ( ) ) ;
double prev_layer_framerate = 0 ; <NEW_LINE> assert ( oxcf -> number_of_layers <= VPX_TS_MAX_LAYERS ) ; <NEW_LINE> <START_VULN> for ( i = 0 ; i < oxcf -> number_of_layers ; i ++ ) <NEW_LINE> <END_VULN> { <NEW_LINE> LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ;
@description This is useful for detached commands . <NEW_LINE> @param cmd MprCmd object created via mprCreateCmd <NEW_LINE> @ingroup MprCmd <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC void mprStartWinPollTimer ( MprCmd * cmd ) ; <NEW_LINE> #endif
const int64 pos = writer -> Position ( ) ; <NEW_LINE> const int64 segment_size = writer -> Position ( ) - payload_pos_ ; <NEW_LINE> if ( writer -> Position ( size_position_ ) || <NEW_LINE> <START_VULN> WriteUIntSize ( writer , segment_size , 8 ) || <NEW_LINE>writer -> Position ( pos ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> return true ; <NEW_LINE> }
int c = ( int ) ( chunk_name >> ishift ) & 0xff ; <NEW_LINE> ishift - = 8 ; <NEW_LINE> <START_VULN> if ( isnonalpha ( c ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> buffer [ iout ++ ] = PNG_LITERAL_LEFT_SQUARE_BRACKET ; <NEW_LINE> buffer [ iout ++ ] = png_digit [ ( c & 0xf0 ) >> 4 ] ;
} <NEW_LINE> <START_VULN> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <NEW_LINE> <END_VULN> vp8_decode_mode_mvs ( pbi ) ;
cpi -> twopass . frames_to_key /= 2 ; <NEW_LINE> <START_VULN> vpx_memcpy ( & tmp_frame , & first_frame , sizeof ( first_frame ) ) ; <NEW_LINE> <END_VULN> reset_fpf_position ( cpi , start_position ) ;
true ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( ! attachedStub && ! cache . hasDenseStub ( ) && obj -> isNative ( ) && idval . isInt32 ( ) ) { <NEW_LINE> if ( ! cache . attachDenseElement ( cx , ion , obj , idval ) ) <NEW_LINE> return false ; <NEW_LINE> attachedStub = true ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! attachedStub && obj -> isTypedArray ( ) ) { <NEW_LINE>if ( ( idval . isInt32 ( ) ) || <NEW_LINE> ( idval . isString ( ) && GetIndexFromString ( idval . toString ( ) ) != UINT32_MAX ) ) <NEW_LINE> { <NEW_LINE>int arrayType = TypedArray::type ( obj ) ; <NEW_LINE>bool floatOutput = arrayType == TypedArray::TYPE_FLOAT32 || <NEW_LINE>arrayType == TypedArray::TYPE_FLOAT64 ; <NEW_LINE>if ( ! floatOutput || cache . output ( ) . hasValue ( ) ) { <NEW_LINE>if ( ! cache . attachTypedArrayElement ( cx , ion , obj , idval ) ) <NEW_LINE>return false ; <NEW_LINE>attachedStub = true ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> if ( ! GetElementOperation ( cx , JSOp ( * pc ) , & lval , idval , res ) ) <NEW_LINE> return false ; <NEW_LINE>
static nsresult <NEW_LINE> GetStructuredCloneReadInfoFromStatement ( mozIStorageStatement * aStatement , <NEW_LINE> uint32_t aDataIndex , <NEW_LINE> uint32_t aFileIdsIndex , <NEW_LINE> IDBDatabase * aDatabase , <NEW_LINE> StructuredCloneReadInfo & aInfo ) ; <NEW_LINE> static void <NEW_LINE> <START_VULN> ClearStructuredCloneBuffer ( JSAutoStructuredCloneBuffer & aBuffer ) ; <NEW_LINE> <END_VULN> static bool <NEW_LINE> DeserializeValue ( JSContext * aCx , <NEW_LINE> StructuredCloneReadInfo & aCloneReadInfo , <NEW_LINE> jsval * aValue ) ; <NEW_LINE> static bool <NEW_LINE> SerializeValue ( JSContext * aCx ,
#include "vpx_scale / yv12config . h" <NEW_LINE> #include "vpx / vpx_integer . h" <NEW_LINE> #ifdef __cplusplus <NEW_LINE> extern "C" { <NEW_LINE> #endif <NEW_LINE> #define MAX_LAG_BUFFERS 25 <NEW_LINE> <START_VULN> <NEW_LINE>#define MAX_PRE_FRAMES 1 <NEW_LINE><NEW_LINE> <END_VULN> struct lookahead_entry { <NEW_LINE> YV12_BUFFER_CONFIG img ; <NEW_LINE> int64_t ts_start ;
strncpy ( ifr . ifr_name , TAP_IF_NAME , IFNAMSIZ ) ; <NEW_LINE> <START_VULN> if ( ( err = ioctl ( fd , TUNSETIFF , ( void * ) & ifr ) ) < 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> BTIF_TRACE_DEBUG ( "ioctl error: % d , errno: % s" , err , strerror ( errno ) ) ; <NEW_LINE> close ( fd ) ;
nsIFrame * rootFrame = ps -> GetRootFrame ( ) ; <NEW_LINE> if ( ! rootFrame ) { <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> nsIFrame * ptFrame = nsLayoutUtils::GetFrameForPoint ( rootFrame , pt , <NEW_LINE> <START_VULN> nsLayoutUtils::IGNORE_PAINT_SUPPRESSION | <NEW_LINE> <END_VULN> ( aIgnoreRootScrollFrame ? nsLayoutUtils::IGNORE_ROOT_SCROLL_FRAME : 0 ) ) ; <NEW_LINE> if ( ! ptFrame ) { <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> nsIContent * elem = GetContentInThisDocument ( ptFrame ) ; <NEW_LINE> if ( elem && ! elem -> IsElement ( ) ) { <NEW_LINE> elem = elem -> GetParent ( ) ;
int lo_fi_consecutive_session_disables_ ; <NEW_LINE> <START_VULN> BooleanPrefMember spdy_proxy_auth_enabled_ ; <NEW_LINE><NEW_LINE> <END_VULN> std::unique_ptr < DataReductionProxyService > data_reduction_proxy_service_ ; <NEW_LINE> PrefService * prefs_ ; <NEW_LINE> DataReductionProxyConfig * config_ ;
} <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> <START_VULN> for ( i = 0 ; i < sec -> size ; i += 8 ) { <NEW_LINE> <END_VULN> ut64 addr64 = r_read_le64 ( buf + i ) ; <NEW_LINE> if ( addr64 ) { <NEW_LINE> RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ;
} <NEW_LINE> <START_VULN> if ( i > ( int ) rec -> length ) <NEW_LINE> <END_VULN> {
if ( yybm [ 0 + yych ] & 128 ) { <NEW_LINE> goto yy20 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( yych != ':' ) goto yy18 ; <NEW_LINE> <END_VULN> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != '"' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ;
static inline int btif_hl_select_close_connected ( void ) { <NEW_LINE> char sig_on = btif_hl_signal_select_close_connected ; <NEW_LINE> BTIF_TRACE_DEBUG ( "btif_hl_select_close_connected" ) ; <NEW_LINE> <START_VULN> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <NEW_LINE> <END_VULN> }
NS_ENSURE_TRUE ( sm , false ) ; <NEW_LINE> nsIScriptGlobalObject * globalObject = GetScriptGlobalObject ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( globalObject , false ) ; <NEW_LINE> nsIScriptContext * scriptContext = globalObject -> GetContext ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( scriptContext , false ) ; <NEW_LINE> <START_VULN> JSContext * cx = scriptContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( cx , false ) ; <NEW_LINE> bool enabled ; <NEW_LINE> nsresult rv = sm -> CanExecuteScripts ( cx , NodePrincipal ( ) , & enabled ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , false ) ; <NEW_LINE> return enabled ; <NEW_LINE> }
retcode = - EFAULT ; <NEW_LINE> goto err_i1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> if ( ioctl -> flags & DRM_UNLOCKED ) <NEW_LINE> retcode = func ( dev , kdata , file_priv ) ; <NEW_LINE> else {
JSObject * object = nullptr ; <NEW_LINE> wrappedJS -> GetJSObject ( & object ) ; <NEW_LINE> if ( ! object ) { <NEW_LINE> return NS_ERROR_UNEXPECTED ; <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> NS_ENSURE_STATE ( pusher . Push ( cx , false ) ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , object ) ; <NEW_LINE> JS::Value thisValue = JSVAL_VOID ; <NEW_LINE> JS::Value funval ; <NEW_LINE> if ( ! JS_GetProperty ( cx , object , "constructor" , & funval ) || ! funval . isObject ( ) ) { <NEW_LINE> return NS_ERROR_UNEXPECTED ;
{ <NEW_LINE> struct crypto_report_cipher rcipher ; <NEW_LINE> <START_VULN> snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , " % s" , "cipher" ) ; <NEW_LINE> <END_VULN> rcipher . blocksize = alg -> cra_blocksize ; <NEW_LINE> rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ;
int fr , j , n , ch , ret ; <NEW_LINE> <START_VULN> s -> frame -> nb_samples = MPA_FRAME_SIZE ; <NEW_LINE> <END_VULN> if ( ( ret = avctx -> get_buffer ( avctx , s -> frame ) ) < 0 ) { <NEW_LINE> av_log ( avctx , AV_LOG_ERROR , "get_buffer ( ) failed\n" ) ; <NEW_LINE> return ret ;
<START_VULN> if ( base_format & PNG_FORMAT_FLAG_ALPHA ) <NEW_LINE> <END_VULN> do_local_background = 1 ; <NEW_LINE> png_set_rgb_to_gray_fixed ( png_ptr , PNG_ERROR_ACTION_NONE ,
enableUniversalAccessFromFileURI , enableFileAccessFromFileURI , <NEW_LINE> enableDOMPaste , tabKeyCyclesThroughElements , enableWebGL , <NEW_LINE> enableSiteSpecificQuirks , usePageCache , enableJavaApplet , <NEW_LINE> <START_VULN> enableHyperlinkAuditing , enableFullscreen , enableDNSPrefetching ; <NEW_LINE> <END_VULN> WebKitEditingBehavior editingBehavior ;
WRITE32 ( NFS4_SHARE_ACCESS_BOTH ) ; <NEW_LINE> break ; <NEW_LINE> default: <NEW_LINE> <START_VULN> BUG ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> WRITE32 ( 0 ) ; <NEW_LINE> }
else <NEW_LINE> { <NEW_LINE> unsigned int size = 1U << ( bit_depth / 2 ) ; <NEW_LINE> <START_VULN> unsigned int x , y , ip ; <NEW_LINE> <END_VULN> for ( x = 0 ; x < size ; ++ x ) for ( y = 0 ; y < size ; ++ y ) <NEW_LINE> {
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> UpgradeSchemaFrom4To5 ( mozIStorageConnection * aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "UpgradeSchemaFrom4To5" ) ; <NEW_LINE> nsresult rv ;
if ( ! ( mGeneration + 1 ) . valid ( ) ) <NEW_LINE> return false ; <NEW_LINE> ++ mGeneration ; <NEW_LINE> mMapUniformLocations . Clear ( ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> already_AddRefed < WebGLUniformLocation > GetUniformLocationObject ( GLint glLocation ) ; <NEW_LINE> <END_VULN> bool UpdateInfo ( gl::GLContext * gl ) ; <NEW_LINE> WebGLint UniformMaxNameLength ( ) const { return mUniformMaxNameLength ; } <NEW_LINE> WebGLint AttribMaxNameLength ( ) const { return mAttribMaxNameLength ; } <NEW_LINE> WebGLint UniformCount ( ) const { return mUniformCount ; }
Variant & v = arr1 . lvalAt ( key , AccessFlags::Key ) ; <NEW_LINE> auto subarr1 = v . toArray ( ) . copy ( ) ; <NEW_LINE> php_array_merge_recursive ( seen , <NEW_LINE> <START_VULN> couldRecur ( v , subarr1 ) , <NEW_LINE> <END_VULN> subarr1 , <NEW_LINE> value . toArray ( ) ) ; <NEW_LINE> v . unset ( ) ;
static int check_best_zero_mv ( <NEW_LINE> const VP9_COMP * cpi , const uint8_t mode_context [ MAX_REF_FRAMES ] , <NEW_LINE> <START_VULN> int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] , <NEW_LINE>int disable_inter_mode_mask , int this_mode , int ref_frame , <NEW_LINE>int second_ref_frame ) { <NEW_LINE>if ( ! ( disable_inter_mode_mask & ( 1 << INTER_OFFSET ( ZEROMV ) ) ) && <NEW_LINE> ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && <NEW_LINE>frame_mv [ this_mode ] [ ref_frame ] . as_int == 0 && <NEW_LINE> ( second_ref_frame == NONE || <NEW_LINE>frame_mv [ this_mode ] [ second_ref_frame ] . as_int == 0 ) ) { <NEW_LINE>int rfc = mode_context [ ref_frame ] ; <NEW_LINE> <END_VULN> int c1 = cost_mv_ref ( cpi , NEARMV , rfc ) ; <NEW_LINE> int c2 = cost_mv_ref ( cpi , NEARESTMV , rfc ) ; <NEW_LINE> int c3 = cost_mv_ref ( cpi , ZEROMV , rfc ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: code raw packets into framed OggSquish stream and <NEW_LINE> decode Ogg streams back into raw packets <NEW_LINE> <START_VULN> last mod: $ Id: framing . c 16051 2009 - 05 - 27 05:00:06Z xiphmont $ <NEW_LINE> <END_VULN> note: The CRC code is directly derived from public domain code by <NEW_LINE> Ross Williams ( ross@guest . adelaide . edu . au ) . See docs / framing . html <NEW_LINE> for details . <NEW_LINE> #include < stdlib . h >
void <NEW_LINE> PresShell::CharacterDataChanged ( nsIDocument * aDocument , <NEW_LINE> nsIContent * aContent , <NEW_LINE> CharacterDataChangeInfo * aInfo ) <NEW_LINE> { <NEW_LINE> NS_PRECONDITION ( ! mIsDocumentGone , "Unexpected CharacterDataChanged" ) ; <NEW_LINE> NS_PRECONDITION ( aDocument == mDocument , "Unexpected aDocument" ) ; <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE> <END_VULN> if ( mCaret ) {
if ( ! this -> enter ( cx , wrapper , id , action , & status ) ) <NEW_LINE> return status ; <NEW_LINE> typename Traits::ResolvingIdImpl resolving ( wrapper , id ) ; <NEW_LINE> <START_VULN> if ( XrayUtils::IsTransparent ( cx , wrapper ) ) { <NEW_LINE> <END_VULN> JSObject * obj = Traits::getTargetObject ( wrapper ) ; <NEW_LINE> { <NEW_LINE> JSAutoCompartment ac ( cx , obj ) ; <NEW_LINE> if ( ! JS_GetPropertyDescriptorById ( cx , obj , id , flags , desc ) ) <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> desc -> obj = ( desc -> obj == obj ) ? wrapper : nullptr ;
AutoValueVector vals ( cx ) ; <NEW_LINE> if ( ! vals . reserve ( props . length ( ) ) ) <NEW_LINE> return false ; <NEW_LINE> for ( size_t i = 0 , len = props . length ( ) ; i < len ; i ++ ) { <NEW_LINE> jsid id = props [ i ] ; <NEW_LINE> if ( JSID_IS_STRING ( id ) ) { <NEW_LINE> vals . infallibleAppend ( StringValue ( JSID_TO_STRING ( id ) ) ) ; <NEW_LINE> } else if ( JSID_IS_INT ( id ) ) { <NEW_LINE> <START_VULN> JSString * str = js_IntToString ( cx , JSID_TO_INT ( id ) ) ; <NEW_LINE> <END_VULN> if ( ! str ) <NEW_LINE> return false ; <NEW_LINE> vals . infallibleAppend ( StringValue ( str ) ) ; <NEW_LINE> } else { <NEW_LINE> JS_ASSERT ( JSID_IS_OBJECT ( id ) ) ; <NEW_LINE> } <NEW_LINE> }
PRInt32 colIndex = 0 ; <NEW_LINE> nsresult res = NS_OK ; <NEW_LINE> nsAutoRules beginRulesSniffing ( this , kOpDeleteNode , nsIEditor::eNext ) ; <NEW_LINE> <START_VULN> nsTArray < nsIDOMElement * > spanCellList ; <NEW_LINE> <END_VULN> nsTArray < PRInt32 > newSpanList ; <NEW_LINE> do { <NEW_LINE> res = GetCellDataAt ( aTable , aRowIndex , colIndex , getter_AddRefs ( cell ) , <NEW_LINE> & startRowIndex , & startColIndex , & rowSpan , & colSpan ,
break ; <NEW_LINE> offset = donote ( ms , nbuf , offset , <NEW_LINE> ( size_t ) bufsize , clazz , swap , align , <NEW_LINE> <START_VULN> flags ) ; <NEW_LINE> <END_VULN> if ( offset == 0 ) <NEW_LINE> break ; <NEW_LINE> }
fwrite ( signature , sizeof signature , 1 , stdout ) ; <NEW_LINE> put_chunk ( IHDR , sizeof IHDR ) ; <NEW_LINE> <START_VULN> for ( ; ; ) <NEW_LINE> <END_VULN> put_chunk ( unknown , sizeof unknown ) ; <NEW_LINE> }
result . append ( '\n' ) ; <NEW_LINE> <START_VULN> MarkupFormatter::appendComment ( result , String::format ( " saved from url = ( % 04d ) % s " , <NEW_LINE>static_cast < int > ( document ( ) . url ( ) . string ( ) . utf8 ( ) . length ( ) ) , <NEW_LINE>document ( ) . url ( ) . string ( ) . utf8 ( ) . data ( ) ) ) ; <NEW_LINE> <END_VULN> result . append ( '\n' ) ; <NEW_LINE> }
case PseudoColor: <NEW_LINE> { <NEW_LINE> if ( ( header . bits_per_pixel < 1 ) || ( header . bits_per_pixel > 15 ) || <NEW_LINE> <START_VULN> ( header . ncolors == 0 ) ) <NEW_LINE> <END_VULN> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE> break ; <NEW_LINE> }
if ( IsAnimValList ( ) ) { <NEW_LINE> Element ( ) -> FlushAnimations ( ) ; <NEW_LINE> } <NEW_LINE> return LengthNoFlush ( ) ; <NEW_LINE> } <NEW_LINE> void Clear ( ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < DOMSVGPathSeg > Initialize ( DOMSVGPathSeg & aNewItem , <NEW_LINE> ErrorResult & aError ) ; <NEW_LINE> <START_VULN> DOMSVGPathSeg * GetItem ( uint32_t aIndex , ErrorResult & aError ) <NEW_LINE> { <NEW_LINE>bool found ; <NEW_LINE>DOMSVGPathSeg * item = IndexedGetter ( aIndex , found , aError ) ; <NEW_LINE>if ( ! found ) { <NEW_LINE>aError . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; <NEW_LINE> } <NEW_LINE>return item ; <NEW_LINE> } <NEW_LINE>DOMSVGPathSeg * IndexedGetter ( uint32_t aIndex , bool & found , <NEW_LINE>ErrorResult & aError ) ; <NEW_LINE> <END_VULN> already_AddRefed < DOMSVGPathSeg > InsertItemBefore ( DOMSVGPathSeg & aNewItem , <NEW_LINE> uint32_t aIndex , <NEW_LINE> ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < DOMSVGPathSeg > ReplaceItem ( DOMSVGPathSeg & aNewItem , <NEW_LINE> uint32_t aIndex , <NEW_LINE> ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < DOMSVGPathSeg > RemoveItem ( uint32_t aIndex , <NEW_LINE> ErrorResult & aError ) ;
* this should be changed to take a callback which retrieves <NEW_LINE> * the password . it may be possible for different safes to <NEW_LINE> * have different passwords . also , the password is already <NEW_LINE> * in unicode . it should probably be converted down below via <NEW_LINE> * a unicode conversion callback . <NEW_LINE> * slot - the slot to import the dataa into should multiple slots <NEW_LINE> * be supported based on key type and cert type ? <NEW_LINE> * dOpen , dClose , dRead , dWrite - digest routines for writing data <NEW_LINE> <START_VULN> * to a file so it could be read back and the hmack recomputed <NEW_LINE> * and verified . doesn't seem to be away for both encoding <NEW_LINE> <END_VULN> * and decoding to be single pass , thus the need for these <NEW_LINE> * routines . <NEW_LINE> * dArg - the argument for dOpen , etc . <NEW_LINE> * <NEW_LINE> * <NEW_LINE> * This function returns the decoder context , if it was successful .
void BnCrypto::readVector ( const Parcel & data , Vector < uint8_t > & vector ) const { <NEW_LINE> uint32_t size = data . readInt32 ( ) ; <NEW_LINE> <START_VULN> vector . insertAt ( ( size_t ) 0 , size ) ; <NEW_LINE>data . read ( vector . editArray ( ) , size ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void BnCrypto::writeVector ( Parcel * reply , Vector < uint8_t > const & vector ) const {
} <NEW_LINE> JSBool <NEW_LINE> TestShellCommandParent::RunCallback ( const nsString & aResponse ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_TRUE ( * mCallback . ToJSValPtr ( ) != JSVAL_NULL && mCx , JS_FALSE ) ; <NEW_LINE> JSAutoRequest ar ( mCx ) ; <NEW_LINE> <START_VULN> <NEW_LINE>JS::Rooted < JSObject * > global ( mCx , JS_GetGlobalForObject ( mCx , mCallback . ToJSObject ( ) ) ) ; <NEW_LINE>NS_ENSURE_TRUE ( global , JS_FALSE ) ; <NEW_LINE><NEW_LINE>JSAutoCompartment ac ( mCx , global ) ; <NEW_LINE> <END_VULN> JSString * str = JS_NewUCStringCopyN ( mCx , aResponse . get ( ) , aResponse . Length ( ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( str , JS_FALSE ) ; <NEW_LINE> JS::Rooted < JS::Value > strVal ( mCx , JS::StringValue ( str ) ) ; <NEW_LINE> JS::Rooted < JS::Value > rval ( mCx ) ; <NEW_LINE> JSBool ok = JS_CallFunctionValue ( mCx , global , mCallback , 1 , strVal . address ( ) ,
if ( classObject -> Get ( scriptState -> context ( ) , v8String ( isolate , "initialize" ) ) . ToLocal ( & initializeFunction ) && initializeFunction -> IsFunction ( ) ) { <NEW_LINE> v8::TryCatch block ( isolate ) ; <NEW_LINE> v8::Local < v8::Value > result ; <NEW_LINE> <START_VULN> if ( ! V8ScriptRunner::callFunction ( v8::Local < v8::Function > ::Cast ( initializeFunction ) , scriptState -> getExecutionContext ( ) , holder , 0 , 0 , isolate ) . ToLocal ( & result ) ) { <NEW_LINE> <END_VULN> fprintf ( stderr , "Private script error: Object constructor threw an exception . \n" ) ; <NEW_LINE> dumpV8Message ( context , block . Message ( ) ) ; <NEW_LINE> RELEASE_NOTREACHED ( ) ;
NS_ASSERTION ( ! mDocument || mState != LIST_DIRTY , <NEW_LINE> "PopulateSelf left the list in a dirty ( useless ) state ! " ) ; <NEW_LINE> <START_VULN> return NS_STATIC_CAST ( nsIContent * , mElements . SafeElementAt ( aIndex ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsIContent *
u4_nz_cols |= 1 << ( u4_pos & 0x7 ) ; <NEW_LINE> u4_nz_rows |= 1 << ( u4_pos >> 0x3 ) ; <NEW_LINE> } <NEW_LINE> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) <NEW_LINE> <START_VULN> if ( u4_numCoeffs > 64 ) <NEW_LINE> { <NEW_LINE>return IMPEG2D_MB_TEX_DECODE_ERR ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> else <NEW_LINE> {
static void reflectUrlStringAttributeAttributeSetter ( v8::Local < v8::Value > v8Value , const v8::FunctionCallbackInfo < v8::Value > & info ) <NEW_LINE> { <NEW_LINE> v8::Local < v8::Object > holder = info . Holder ( ) ; <NEW_LINE> <START_VULN> Element * impl = V8Element::toImpl ( holder ) ; <NEW_LINE> <END_VULN> V8StringResource < > cppValue = v8Value ; <NEW_LINE> if ( ! cppValue . prepare ( ) ) <NEW_LINE> return ;
uint32 colb = 0 ; <NEW_LINE> uint32 col ; <NEW_LINE> <START_VULN> for ( col = 0 ; col < imagewidth ; col += tw ) { <NEW_LINE> <END_VULN>
<START_VULN> void OnAllowBindings ( int enabled_bindings_flags ) ; <NEW_LINE> <END_VULN> void OnAllowScriptToClose ( bool script_can_close ) ; <NEW_LINE> void OnAsyncFileOpened ( base::PlatformFileError error_code , <NEW_LINE> IPC::PlatformFileForTransit file_for_transit ,
} <NEW_LINE> <START_VULN> result = append_key_value ( loc_name , hash_arr , LOC_LANG_TAG ) ; <NEW_LINE> <END_VULN> if ( result == LOC_NOT_FOUND ) { <NEW_LINE> intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , <NEW_LINE> "locale_compose: parameter array does not contain 'language' tag . " , 0 TSRMLS_CC ) ;
<START_VULN> zlib -> file_bits = 16 ; <NEW_LINE> <END_VULN> zlib -> ok_bits = 16 ; <NEW_LINE> zlib -> cksum = 0 ;
fun -> u . i . wrapper = JSPackedBool ( ( firstword >> 1 ) & 1 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! js_XDRScript ( xdr , & fun -> u . i . script ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> if ( xdr -> mode == JSXDR_DECODE ) {
rate0 = tokens [ next ] [ 0 ] . rate ; <NEW_LINE> rate1 = tokens [ next ] [ 1 ] . rate ; <NEW_LINE> <START_VULN> if ( ( abs ( x ) * dequant_ptr [ rc != 0 ] > abs ( coeff [ rc ] ) * mul ) && <NEW_LINE> ( abs ( x ) * dequant_ptr [ rc != 0 ] < abs ( coeff [ rc ] ) * mul + <NEW_LINE>dequant_ptr [ rc != 0 ] ) ) <NEW_LINE> <END_VULN> shortcut = 1 ; <NEW_LINE> else <NEW_LINE> shortcut = 0 ;
<START_VULN> if ( ! logicalHeightLength . isPercent ( ) || replaced -> isPositioned ( ) || replaced -> document ( ) -> inQuirksMode ( ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> for ( RenderBlock * cb = replaced -> containingBlock ( ) ; ! cb -> isRenderView ( ) ; cb = cb -> containingBlock ( ) ) {
virtual void ProcessTextData ( ) ; <NEW_LINE> PRBool SetTextStyle ( ) ; <NEW_LINE> <START_VULN> void SetQuotes ( ) ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> #endif
if ( oldStyle ) { <NEW_LINE> <START_VULN> if ( diff >= StyleDifferenceRepaint && node ( ) && <NEW_LINE> ( isHTMLHtmlElement ( * node ( ) ) || isHTMLBodyElement ( * node ( ) ) ) ) { <NEW_LINE> <END_VULN> view ( ) -> repaint ( ) ; <NEW_LINE> if ( oldStyle -> hasEntirelyFixedBackground ( ) != newStyle . hasEntirelyFixedBackground ( ) )
<START_VULN> if ( png_ptr -> read_buffer ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_bytep buffer = png_ptr -> read_buffer ;
* <NEW_LINE> SVGLengthList & InternalList ( ) const ; <NEW_LINE> <START_VULN> void EnsureItemAt ( uint32_t aIndex ) ; <NEW_LINE> <END_VULN> void MaybeInsertNullInAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> void MaybeRemoveItemFromAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> FallibleTArray < DOMSVGLength * > mItems ;
inline JSBool GetStaticMemberIsLocal ( ) const ; <NEW_LINE> inline unsigned GetArgc ( ) const ; <NEW_LINE> inline jsval * GetArgv ( ) const ; <NEW_LINE> inline jsval * GetRetVal ( ) const ; <NEW_LINE> inline uint16_t GetMethodIndex ( ) const ; <NEW_LINE> inline void SetMethodIndex ( uint16_t index ) ; <NEW_LINE> <START_VULN> inline JSBool GetDestroyJSContextInDestructor ( ) const ; <NEW_LINE>inline void SetDestroyJSContextInDestructor ( JSBool b ) ; <NEW_LINE> <END_VULN> inline jsid GetResolveName ( ) const ; <NEW_LINE> inline jsid SetResolveName ( JS::HandleId name ) ; <NEW_LINE> inline XPCWrappedNative * GetResolvingWrapper ( ) const ; <NEW_LINE> inline XPCWrappedNative * SetResolvingWrapper ( XPCWrappedNative * w ) ; <NEW_LINE> inline void SetRetVal ( jsval val ) ;
} <NEW_LINE> <START_VULN> static INLINE void right_shift_8x8 ( __m128i * res , int const bit ) { <NEW_LINE>const __m128i kOne = _mm_set1_epi16 ( 1 ) ; <NEW_LINE>const int bit_m02 = bit - 2 ; <NEW_LINE> <END_VULN> __m128i sign0 = _mm_srai_epi16 ( res [ 0 ] , 15 ) ; <NEW_LINE> __m128i sign1 = _mm_srai_epi16 ( res [ 1 ] , 15 ) ; <NEW_LINE> __m128i sign2 = _mm_srai_epi16 ( res [ 2 ] , 15 ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: lookup data ; generated by lookups . pl ; edit there <NEW_LINE> <START_VULN> last mod: $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_LOOKUP_DATA_H_ <NEW_LINE> #ifdef FLOAT_LOOKUP <NEW_LINE> #define COS_LOOKUP_SZ 128 <NEW_LINE> static const float COS_LOOKUP [ COS_LOOKUP_SZ + 1 ] = {
qemu_get_be32s ( f , & opp -> spve ) ; <NEW_LINE> qemu_get_be32s ( f , & opp -> tfrr ) ; <NEW_LINE> <START_VULN> qemu_get_be32s ( f , & opp -> nb_cpus ) ; <NEW_LINE> <END_VULN> for ( i = 0 ; i < opp -> nb_cpus ; i ++ ) { <NEW_LINE> qemu_get_sbe32s ( f , & opp -> dst [ i ] . ctpr ) ;
if ( aMaxWidth < 0 ) <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> <START_VULN> nsCOMPtr < nsIContent > content = <NEW_LINE>do_QueryInterface ( static_cast < nsIDOMHTMLCanvasElement * > ( mCanvasElement ) ) ; <NEW_LINE> <END_VULN> if ( ! content && ! mDocShell ) { <NEW_LINE> NS_WARNING ( "Canvas element must be an nsIContent and non - null or a docshell must be provided" ) ; <NEW_LINE> return NS_ERROR_FAILURE ;
return JS_TRUE ; <NEW_LINE> } <NEW_LINE> JSBool <NEW_LINE> js_Stringify ( JSContext * cx , jsval * vp , JSObject * replacer , jsval space , <NEW_LINE> JSCharBuffer & cb ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE>JSObject * stack = JS_NewArrayObject ( cx , 0 , NULL ) ; <NEW_LINE>if ( ! stack ) <NEW_LINE>return JS_FALSE ; <NEW_LINE><NEW_LINE> <END_VULN> StringifyContext scx ( cx , cb , replacer ) ; <NEW_LINE> if ( ! InitializeGap ( cx , space , scx . gap ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> JSObject * obj = NewObject ( cx , & js_ObjectClass , NULL , NULL ) ; <NEW_LINE> if ( ! obj ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> if ( ! obj -> defineProperty ( cx , ATOM_TO_JSID ( cx -> runtime -> atomState . emptyAtom ) , <NEW_LINE> * vp , NULL , NULL , JSPROP_ENUMERATE ) ) { <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> return Str ( cx , ATOM_TO_JSID ( cx -> runtime -> atomState . emptyAtom ) , obj , & scx , vp ) ; <NEW_LINE> }
gpio_dev -> ngroups = ARRAY_SIZE ( kerncz_groups ) ; <NEW_LINE> amd_pinctrl_desc . name = dev_name ( & pdev -> dev ) ; <NEW_LINE> <START_VULN> gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc , <NEW_LINE> & pdev -> dev , gpio_dev ) ; <NEW_LINE> <END_VULN> if ( IS_ERR ( gpio_dev -> pctrl ) ) { <NEW_LINE> dev_err ( & pdev -> dev , "Couldn't register pinctrl driver\n" ) ; <NEW_LINE> return PTR_ERR ( gpio_dev -> pctrl ) ;
} <NEW_LINE> if ( one_row != ( unsigned char * ) NULL ) <NEW_LINE> one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; <NEW_LINE> <START_VULN> if ( lastrow != ( unsigned char * ) NULL ) <NEW_LINE>lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <NEW_LINE> <END_VULN> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) <NEW_LINE> break ;
} <NEW_LINE> void <NEW_LINE> nsXMLContentSink::FlushPendingNotifications ( mozFlushType aType ) <NEW_LINE> { <NEW_LINE> if ( ! mInNotification ) { <NEW_LINE> <START_VULN> if ( aType >= Flush_ContentAndNotify ) { <NEW_LINE>FlushTags ( ) ; <NEW_LINE> } <NEW_LINE>else { <NEW_LINE>FlushText ( PR_FALSE ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( aType >= Flush_Layout ) { <NEW_LINE> MaybeStartLayout ( PR_TRUE ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
if ( tlen ) { <NEW_LINE> oid_len = * tptr ; <NEW_LINE> <START_VULN> if ( tlen < oid_len ) { <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> } <NEW_LINE> if ( oid_len ) {
static void spl_filesystem_dir_it_move_forward ( zend_object_iterator * iter TSRMLS_DC ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * object = spl_filesystem_iterator_to_object ( ( spl_filesystem_iterator * ) iter ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> object -> u . dir . index ++ ; <NEW_LINE> spl_filesystem_dir_read ( object TSRMLS_CC ) ; <NEW_LINE> if ( object -> file_name ) {
for ( i = above_contexts ; i < tx_size_in_blocks ; ++ i ) <NEW_LINE> a [ i ] = 0 ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> vpx_memset ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <NEW_LINE> <END_VULN> }
in [ 0 ] = _mm_add_epi16 ( in [ 0 ] , k__nonzero_bias_b ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static INLINE void write_buffer_4x4 ( int16_t * output , __m128i * res ) { <NEW_LINE> <END_VULN> const __m128i kOne = _mm_set1_epi16 ( 1 ) ; <NEW_LINE> __m128i in01 = _mm_unpacklo_epi64 ( res [ 0 ] , res [ 1 ] ) ; <NEW_LINE> __m128i in23 = _mm_unpacklo_epi64 ( res [ 2 ] , res [ 3 ] ) ;
#define DEBUG_CheckUnwrapSafety ( obj , handler , origin , target ) { } <NEW_LINE> #endif <NEW_LINE> JSObject * <NEW_LINE> WrapperFactory::Rewrap ( JSContext * cx , JSObject * obj , JSObject * wrappedProto , JSObject * parent , <NEW_LINE> unsigned flags ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! IsWrapper ( obj ) || <NEW_LINE>GetProxyHandler ( obj ) == & XrayWaiver || <NEW_LINE>js::GetObjectClass ( obj ) -> ext . innerObject , <NEW_LINE>"wrapped object passed to rewrap" ) ; <NEW_LINE>NS_ASSERTION ( JS_GetClass ( obj ) != & XrayUtils::HolderClass , "trying to wrap a holder" ) ; <NEW_LINE> <END_VULN> JSCompartment * origin = js::GetObjectCompartment ( obj ) ; <NEW_LINE> JSCompartment * target = js::GetContextCompartment ( cx ) ; <NEW_LINE> bool usingXray = false ; <NEW_LINE> JSObject * proxyProto = wrappedProto ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . methodWithSequenceArg" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( sequence < ScriptProfile > * , sequenceArg , toNativeArray < ScriptProfile > ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> imp -> methodWithSequenceArg ( sequenceArg ) ;
const AXObject * AXObject::ariaHiddenRoot ( ) const { <NEW_LINE> for ( const AXObject * object = this ; object ; object = object -> parentObject ( ) ) { <NEW_LINE> <START_VULN> if ( equalIgnoringCase ( object -> getAttribute ( aria_hiddenAttr ) , "true" ) ) <NEW_LINE> <END_VULN> return object ; <NEW_LINE> }
for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { <NEW_LINE> for ( j = 0 ; j < 16 ; j ++ , k ++ ) { <NEW_LINE> unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; <NEW_LINE> <START_VULN> pval *= cpi -> fixed_divide [ count [ k ] ] ; <NEW_LINE> <END_VULN> pval >> = 19 ; <NEW_LINE> dst1 [ byte ] = ( uint8_t ) pval ;
u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; <NEW_LINE> } <NEW_LINE> <START_VULN> else if ( ps_dec -> u4_first_slice_in_pic == 2 ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( u2_first_mb_in_slice > 0 ) <NEW_LINE> {
} <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return result ; <NEW_LINE> }
-- len_left ; <NEW_LINE> * ( p ++ ) = '\0' ; <NEW_LINE> } <NEW_LINE> <START_VULN> ++ len_req ; <NEW_LINE> <END_VULN> if ( len < len_req ) { <NEW_LINE> return len_req ; <NEW_LINE> }
#include "base / files / file_path . h" <NEW_LINE> #include "base / files / file_tracing . h" <NEW_LINE> #include "base / files / scoped_file . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "base / time / time . h" <NEW_LINE> #include "build / build_config . h"
static const int search_param_to_steps [ MAX_MVSEARCH_STEPS ] = { <NEW_LINE> 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 , <NEW_LINE> } ; <NEW_LINE> <START_VULN> int i , j , s , t ; <NEW_LINE> <END_VULN> const struct buf_2d * const what = & x -> plane [ 0 ] . src ; <NEW_LINE> const struct buf_2d * const in_what = & xd -> plane [ 0 ] . pre [ 0 ] ; <NEW_LINE> int br , bc ;
NS_ENSURE_TRUE ( aSelState , false ) ; <NEW_LINE> PRUint32 i , myCount = mArray . Length ( ) , itsCount = aSelState -> mArray . Length ( ) ; <NEW_LINE> if ( myCount != itsCount ) return false ; <NEW_LINE> if ( myCount < 1 ) return false ; <NEW_LINE> for ( i = 0 ; i < myCount ; i ++ ) <NEW_LINE> { <NEW_LINE> nsRefPtr < nsRange > myRange , itsRange ; <NEW_LINE> <START_VULN> mArray [ i ] . GetRange ( getter_AddRefs ( myRange ) ) ; <NEW_LINE>aSelState -> mArray [ i ] . GetRange ( getter_AddRefs ( itsRange ) ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( myRange && itsRange , false ) ; <NEW_LINE> PRInt16 compResult ; <NEW_LINE> nsresult rv ; <NEW_LINE> rv = myRange -> CompareBoundaryPoints ( nsIDOMRange::START_TO_START , itsRange , & compResult ) ; <NEW_LINE> if ( NS_FAILED ( rv ) || compResult ) return false ; <NEW_LINE> rv = myRange -> CompareBoundaryPoints ( nsIDOMRange::END_TO_END , itsRange , & compResult ) ; <NEW_LINE> if ( NS_FAILED ( rv ) || compResult ) return false ;
"Attempting to notify dependents of a new interval but the interval " <NEW_LINE> "is not set" ) ; <NEW_LINE> nsSMILTimeContainer * container = GetTimeContainer ( ) ; <NEW_LINE> if ( container ) { <NEW_LINE> container -> SyncPauseTime ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> NotifyTimeDependentsParams params = { mCurrentInterval , container } ; <NEW_LINE> <END_VULN> mTimeDependents . EnumerateEntries ( NotifyNewIntervalCallback , & params ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsSMILTimedElement::NotifyChangedInterval ( nsSMILInterval * aInterval , <NEW_LINE> bool aBeginObjectChanged , <NEW_LINE> bool aEndObjectChanged ) <NEW_LINE> {
pC = ( png_bytep ) ( png_ptr -> chunkdata + prefix_length ) ; <NEW_LINE> <START_VULN> profile_size = ( ( * ( pC ) ) << 24 ) | <NEW_LINE> ( ( * ( pC + 1 ) ) << 16 ) | <NEW_LINE> ( ( * ( pC + 2 ) ) << 8 ) | <NEW_LINE> ( ( * ( pC + 3 ) ) ) ; <NEW_LINE> <END_VULN> if ( profile_size < profile_length ) <NEW_LINE> profile_length = profile_size ;
mDocument -> BindingManager ( ) -> ProcessAttachedQueue ( ) ; <NEW_LINE> NS_ENSURE_STATE ( ! mHaveShutDown ) ; <NEW_LINE> <START_VULN> mFrameConstructor -> ProcessPendingRestyles ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_STATE ( ! mHaveShutDown ) ; <NEW_LINE> rootFrame = FrameManager ( ) -> GetRootFrame ( ) ;
if ( ! mPolicies [ i ] -> permitsBaseURI ( aURI ) ) { <NEW_LINE> if ( ! mPolicies [ i ] -> getReportOnlyFlag ( ) ) { <NEW_LINE> * outPermitsBaseURI = false ; <NEW_LINE> } <NEW_LINE> nsAutoString violatedDirective ; <NEW_LINE> mPolicies [ i ] -> getDirectiveStringForBaseURI ( violatedDirective ) ; <NEW_LINE> this -> AsyncReportViolation ( aURI , <NEW_LINE> <START_VULN> mSelfURI , <NEW_LINE> <END_VULN> violatedDirective , <NEW_LINE> i , <NEW_LINE> EmptyString ( ) , <NEW_LINE> EmptyString ( ) , <NEW_LINE> EmptyString ( ) , <NEW_LINE> 0 ) ; <NEW_LINE> } <NEW_LINE> }
RevalidationPolicy policy , <NEW_LINE> bool is_static_data ) { <NEW_LINE> if ( policy == kUse && resource -> GetStatus ( ) == ResourceStatus::kCached && <NEW_LINE> <START_VULN> ! validated_ur_ls_ . Contains ( resource -> Url ( ) ) ) { <NEW_LINE> <END_VULN> DidLoadResourceFromMemoryCache ( identifier , resource , <NEW_LINE> request . GetResourceRequest ( ) ) ;
return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>inline bool SafeMultiplyUint32 ( uint32 a , uint32 b , uint32 * dst ) { <NEW_LINE>return SafeMultiply ( a , b , dst ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>template < typename T > <NEW_LINE>inline bool SafeAdd ( T a , T b , T * dst ) { <NEW_LINE> <END_VULN> if ( a + b < a ) { <NEW_LINE> * dst = 0 ; <NEW_LINE> return false ;
return NS_ERROR_DOM_RETVAL_UNDEFINED ; <NEW_LINE> } <NEW_LINE> nsIXPConnect * xpc = nsContentUtils::XPConnect ( ) ; <NEW_LINE> nsCOMPtr < nsIXPConnectJSObjectHolder > sandbox ; <NEW_LINE> <START_VULN> rv = xpc -> CreateSandbox ( cx , principal , getter_AddRefs ( sandbox ) ) ; <NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> JS::Rooted < JSObject * > sandboxObj ( cx , sandbox -> GetJSObject ( ) ) ; <NEW_LINE> NS_ENSURE_STATE ( sandboxObj ) ;
sptr = ( * ( be -> base_src ) + be -> src ) ; <NEW_LINE> dptr = b -> predictor ; <NEW_LINE> <START_VULN> return vp8_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ; <NEW_LINE> <END_VULN> }
ExtensionToolbarModel toolbar_model_ ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> typedef std::map < std::string , FilePath > UnloadedExtensionPathMap ; <NEW_LINE> UnloadedExtensionPathMap unloaded_extension_paths_ ;
v8::Isolate * isolate = scriptState -> isolate ( ) ; <NEW_LINE> v8::TryCatch tryCatch ( isolate ) ; <NEW_LINE> <START_VULN> v8::Local < v8::Object > creationContext ( scriptState -> context ( ) -> Global ( ) ) ; <NEW_LINE> <END_VULN> v8::Local < v8::Function > v8Callback ( callback . v8Value ( ) . As < v8::Function > ( ) ) ; <NEW_LINE> v8::Local < v8::Value > v8ThisArg ( thisArg . v8Value ( ) ) ; <NEW_LINE> v8::Local < v8::Value > args [ 3 ] ;
#endif <NEW_LINE> using namespace js ; <NEW_LINE> #if USE_ZLIB <NEW_LINE> static void * <NEW_LINE> zlib_alloc ( void * cx , uInt items , uInt size ) <NEW_LINE> { <NEW_LINE> <START_VULN> return js_malloc ( items * size ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void <NEW_LINE> zlib_free ( void * cx , void * addr ) <NEW_LINE> { <NEW_LINE> js_free ( addr ) ; <NEW_LINE> }
{ <NEW_LINE> NS_PRECONDITION ( ! mIsDocumentGone , "Unexpected ContentInserted" ) ; <NEW_LINE> NS_PRECONDITION ( aDocument == mDocument , "Unexpected aDocument" ) ; <NEW_LINE> if ( ! mDidInitialReflow ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE> <END_VULN> if ( aContainer ) <NEW_LINE> mFrameConstructor -> RestyleForInsertOrChange ( aContainer , aChild ) ; <NEW_LINE> mFrameConstructor -> ContentInserted ( aContainer , aChild ,
void FrameReady ( VideoDecoder::DecoderStatus status , <NEW_LINE> <START_VULN> scoped_refptr < VideoFrame > frame ) ; <NEW_LINE> <END_VULN>
va_start ( argptr , format ) ; <NEW_LINE> while ( ( c = * format ++ ) ) <NEW_LINE> <START_VULN> { switch ( c ) <NEW_LINE> <END_VULN> { case 'e' : <NEW_LINE> psf -> rwf_endian = SF_ENDIAN_LITTLE ; <NEW_LINE> break ;
_analysis_output ( "mask0" , seq , logmask , n / 2 , 1 , 0 , 0 ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> floor_posts [ i ] [ 0 ] = <NEW_LINE> floor1_fit ( vb , b -> flr [ info -> floorsubmap [ submap ] ] , <NEW_LINE> logmdct , <NEW_LINE> logmask ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( k = 1 ; k < PACKETBLOBS / 2 ; k ++ ) <NEW_LINE> floor_posts [ i ] [ k ] = <NEW_LINE> floor1_interpolate_fit ( vb , b -> flr [ info -> floorsubmap [ submap ] ] , <NEW_LINE> floor_posts [ i ] [ 0 ] , <NEW_LINE> floor_posts [ i ] [ PACKETBLOBS / 2 ] , <NEW_LINE> k * 65536 / ( PACKETBLOBS / 2 ) ) ;
#ifndef VP9_COMMON_VP9_QUANT_COMMON_H_ <NEW_LINE> #define VP9_COMMON_VP9_QUANT_COMMON_H_ <NEW_LINE> <START_VULN> #include "vp9 / common / vp9_blockd . h" <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> extern "C" {
oggpack_write ( opb , 1 , 1 ) ; <NEW_LINE> return ( 0 ) ; <NEW_LINE> err_out: <NEW_LINE> return ( - 1 ) ; <NEW_LINE> } <NEW_LINE> int vorbis_commentheader_out ( vorbis_comment * vc , <NEW_LINE> <START_VULN> ogg_packet * op ) { <NEW_LINE> <END_VULN> oggpack_buffer opb ; <NEW_LINE> oggpack_writeinit ( & opb ) ; <NEW_LINE> if ( _vorbis_pack_comment ( & opb , vc ) ) return OV_EIMPL ; <NEW_LINE> op -> packet = _ogg_malloc ( oggpack_bytes ( & opb ) ) ; <NEW_LINE> memcpy ( op -> packet , opb . buffer , oggpack_bytes ( & opb ) ) ;
errstr = "Out of memory" ; <NEW_LINE> break ; <NEW_LINE> case - EROFS: <NEW_LINE> <START_VULN> if ( ! sb || EXT4_SB ( sb ) -> s_journal -> j_flags & JBD2_ABORT ) <NEW_LINE> <END_VULN> errstr = "Journal has aborted" ; <NEW_LINE> else <NEW_LINE> errstr = "Readonly filesystem" ;
local = date_msecFromDate ( year , <NEW_LINE> MonthFromTime ( local ) , <NEW_LINE> DateFromTime ( local ) , <NEW_LINE> HourFromTime ( local ) , <NEW_LINE> MinFromTime ( local ) , <NEW_LINE> SecFromTime ( local ) , <NEW_LINE> msFromTime ( local ) ) ; <NEW_LINE> <START_VULN> SetUTCTime ( cx , obj , NULL , UTC ( local ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_FRIEND_API ( void ) <NEW_LINE> js_DateSetMonth ( JSContext * cx , JSObject * obj , int month ) <NEW_LINE> { <NEW_LINE> jsdouble local ; <NEW_LINE> JS_ASSERT ( month < 12 ) ;
} <NEW_LINE> hlen = plen - ICMP_EXTD_MINLEN ; <NEW_LINE> <START_VULN> vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; <NEW_LINE>vec [ 0 ] . len = hlen ; <NEW_LINE>ND_PRINT ( ( ndo , " , checksum 0x % 04x ( % scorrect ) , length % u" , <NEW_LINE>EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , <NEW_LINE>in_cksum ( vec , 1 ) ? "in" : "" , <NEW_LINE>hlen ) ) ; <NEW_LINE> <END_VULN> hlen - = 4 ; <NEW_LINE> obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ;
jas_seq2d_t * jas_seq2d_copy ( jas_seq2d_t * x ) <NEW_LINE> { <NEW_LINE> jas_matrix_t * y ; <NEW_LINE> <START_VULN> int i ; <NEW_LINE>int j ; <NEW_LINE> <END_VULN> y = jas_seq2d_create ( jas_seq2d_xstart ( x ) , jas_seq2d_ystart ( x ) , <NEW_LINE> jas_seq2d_xend ( x ) , jas_seq2d_yend ( x ) ) ; <NEW_LINE> assert ( y ) ;
nsresult rv = CheckLoadURIWithPrincipal ( ( * whiteList ) [ i ] , <NEW_LINE> aTargetURI , <NEW_LINE> aFlags ) ; <NEW_LINE> if ( NS_SUCCEEDED ( rv ) ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> return NS_OK ; <NEW_LINE> <END_VULN> } <NEW_LINE> NS_ERROR ( "Non - system principals or expanded principal passed to CheckLoadURIWithPrincipal " <NEW_LINE> "must have a URI ! " ) ; <NEW_LINE> return NS_ERROR_UNEXPECTED ; <NEW_LINE> } <NEW_LINE> if ( aFlags & nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT ) {
( sprintf ) ( work , formatbuf , p -> data . dnum ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( fptr = work ; * fptr ; fptr ++ ) <NEW_LINE> OUTCHAR ( * fptr ) ; <NEW_LINE> }
<START_VULN> if ( element ( ) -> focused ( ) ) <NEW_LINE> <END_VULN> element ( ) -> focus ( ) ; <NEW_LINE> BaseDateAndTimeInputType::destroyShadowSubtree ( ) ;
"wrong unit" ) ; <NEW_LINE> nsCSSValue::Array * array1 = aValue1 . GetArrayValue ( ) ; <NEW_LINE> nsCSSValue::Array * array2 = aValue2 . GetArrayValue ( ) ; <NEW_LINE> nsRefPtr < nsCSSValue::Array > resultArray = nsCSSValue::Array::Create ( 6 ) ; <NEW_LINE> if ( ! resultArray ) { <NEW_LINE> return PR_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> for ( PRUint32 i = 0 ; i < 4 ; ++ i ) { <NEW_LINE> <END_VULN> NS_ABORT_IF_FALSE ( array1 -> Item ( i ) . GetUnit ( ) == eCSSUnit_Pixel , <NEW_LINE> "unexpected unit" ) ; <NEW_LINE> NS_ABORT_IF_FALSE ( array2 -> Item ( i ) . GetUnit ( ) == eCSSUnit_Pixel , <NEW_LINE> "unexpected unit" ) ; <NEW_LINE> double pixel1 = array1 -> Item ( i ) . GetFloatValue ( ) ; <NEW_LINE> double pixel2 = array2 -> Item ( i ) . GetFloatValue ( ) ; <NEW_LINE> resultArray -> Item ( i ) . SetFloatValue ( aCoeff1 * pixel1 + aCoeff2 * pixel2 , <NEW_LINE> eCSSUnit_Pixel ) ;
<START_VULN> #ifndef BASE_MESSAGE_LOOP_MESSAGE_PUMP_DISPATCHER_H <NEW_LINE>#define BASE_MESSAGE_LOOP_MESSAGE_PUMP_DISPATCHER_H <NEW_LINE> <END_VULN> #include < stdint . h >
} <NEW_LINE> static void perf_swevent_overflow ( struct perf_event * event , u64 overflow , <NEW_LINE> <START_VULN> int nmi , struct perf_sample_data * data , <NEW_LINE> <END_VULN> struct pt_regs * regs ) <NEW_LINE> { <NEW_LINE> struct hw_perf_event * hwc = & event -> hw ;
have_shift = 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! have_shift ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
if ( PASS == conn -> m -> local_tx_start ( conn , this_func TSRMLS_CC ) ) { <NEW_LINE> ret = conn -> m -> query ( conn , "COMMIT" , sizeof ( "COMMIT" ) - 1 TSRMLS_CC ) ; <NEW_LINE> <START_VULN> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> DBG_RETURN ( ret ) ;
std::unique_ptr < IO::Frontend > frontend_ ; <NEW_LINE> DevToolsIOContext * io_context_ ; <NEW_LINE> <START_VULN> RenderProcessHost * process_host_ ; <NEW_LINE> <END_VULN> base::WeakPtrFactory < IOHandler > weak_factory_ ; <NEW_LINE> DISALLOW_COPY_AND_ASSIGN ( IOHandler ) ;
return - 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> size = MIN ( count , self -> buffer_size - self -> buffer_offset ) ; <NEW_LINE>memcpy ( buf , self -> buffer + self -> buffer_offset , size ) ; <NEW_LINE> <END_VULN> if ( size < count && chunk_id + 1 < self -> totalChunks ) { <NEW_LINE> int tmp_bytes ;
{ <NEW_LINE> vp8_dc_only_idct_add_mmx ( q [ 32 ] * dq [ 0 ] , dst + 8 , stride , <NEW_LINE> dst + 8 , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( eobs [ 3 ] > 1 )
fprintf ( fp , " % s\n" , history [ j ] ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> fclose ( fp ) ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
} <NEW_LINE> static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env , <NEW_LINE> <START_VULN> int insn_idx , int prev_insn_idx ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct bpf_verifier_state * cur = env -> cur_state ; <NEW_LINE> struct bpf_verifier_stack_elem * elem ;
} ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> class AutofillPopupViewNativeViews : public AutofillPopupBaseView , <NEW_LINE> public AutofillPopupView { <NEW_LINE> public:
Id id ; <NEW_LINE> <START_VULN> RefCountedPropertyTreeState properties ; <NEW_LINE> <END_VULN>
NS_DECL_NSIDOMPARSERJS <NEW_LINE> NS_IMETHOD Initialize ( nsISupports * aOwner , JSContext * cx , JSObject * obj , <NEW_LINE> PRUint32 argc , jsval * argv ) ; <NEW_LINE> private: <NEW_LINE> <START_VULN> nsresult SetUpDocument ( DocumentFlavor aFlavor , nsIDOMDocument ** aResult ) ; <NEW_LINE> <END_VULN> class AttemptedInitMarker { <NEW_LINE> public: <NEW_LINE> AttemptedInitMarker ( bool * aAttemptedInit ) : <NEW_LINE> mAttemptedInit ( aAttemptedInit ) <NEW_LINE> { } <NEW_LINE> ~ AttemptedInitMarker ( ) {
NS_IMETHOD GetThebesSurface ( gfxASurface ** surface ) ; <NEW_LINE> NS_IMETHOD SetIsOpaque ( PRBool isOpaque ) ; <NEW_LINE> <START_VULN> <NEW_LINE>NS_DECL_ISUPPORTS <NEW_LINE> <END_VULN> NS_DECL_NSIDOMCANVASRENDERINGCONTEXT2D
already_AddRefed < AudioBuffer > <NEW_LINE> AudioProcessingEvent::LazilyCreateBuffer ( uint32_t aNumberOfChannels , <NEW_LINE> ErrorResult & aRv ) <NEW_LINE> { <NEW_LINE> AutoPushJSContext cx ( mNode -> Context ( ) -> GetJSContext ( ) ) ; <NEW_LINE> nsRefPtr < AudioBuffer > buffer = <NEW_LINE> <START_VULN> new AudioBuffer ( mNode -> Context ( ) , mNode -> BufferSize ( ) , <NEW_LINE>mNode -> Context ( ) -> SampleRate ( ) ) ; <NEW_LINE>if ( ! buffer -> InitializeBuffers ( aNumberOfChannels , cx ) ) { <NEW_LINE>aRv . Throw ( NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE>return nullptr ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> return buffer . forget ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
nsCOMPtr < nsIDOMEventTarget > target = do_QueryInterface ( aTarget ) ; <NEW_LINE> bool retargeted = false ; <NEW_LINE> if ( aEvent -> flags & NS_EVENT_RETARGET_TO_NON_NATIVE_ANONYMOUS ) { <NEW_LINE> nsCOMPtr < nsIContent > content = do_QueryInterface ( target ) ; <NEW_LINE> if ( content && content -> IsInNativeAnonymousSubtree ( ) ) { <NEW_LINE> nsCOMPtr < nsPIDOMEventTarget > newTarget = <NEW_LINE> <START_VULN> do_QueryInterface ( content -> FindFirstNonNativeAnonymous ( ) ) ; <NEW_LINE> <END_VULN> NS_ENSURE_STATE ( newTarget ) ; <NEW_LINE> aEvent -> originalTarget = target ; <NEW_LINE> target = newTarget ; <NEW_LINE> retargeted = true ; <NEW_LINE> } <NEW_LINE> }
switch ( otype ) { <NEW_LINE> case PIMV2_HELLO_OPTION_HOLDTIME: <NEW_LINE> <START_VULN> unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case PIMV2_HELLO_OPTION_LANPRUNEDELAY:
const PRUnichar kLastChar = mTitle . Last ( ) ; <NEW_LINE> if ( kLastChar == PRUnichar ( 0x2026 ) || kLastChar == PRUnichar ( ':' ) ) <NEW_LINE> offset -- ; <NEW_LINE> } <NEW_LINE> if ( InsertSeparatorBeforeAccessKey ( ) && <NEW_LINE> <START_VULN> ! NS_IS_SPACE ( mTitle [ offset - 1 ] ) ) { <NEW_LINE> <END_VULN> mTitle . Insert ( ' ' , offset ) ; <NEW_LINE> offset ++ ; <NEW_LINE> } <NEW_LINE> mTitle . Insert ( accessKeyLabel , offset ) ; <NEW_LINE> } <NEW_LINE> void
break ; <NEW_LINE> case 6: <NEW_LINE> <START_VULN> if ( ! ( png_ptr -> row_number & 0x01 ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_write_finish_row ( png_ptr ) ; <NEW_LINE> return ;
static inline void perf_event_task_sched_out ( struct task_struct * task , struct task_struct * next ) <NEW_LINE> { <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_CONTEXT_SWITCHES , 1 , 1 , NULL , 0 ) ; <NEW_LINE> <END_VULN> __perf_event_task_sched_out ( task , next ) ; <NEW_LINE> }
zend_uchar * this_field_len_pos = p ; <NEW_LINE> <START_VULN> unsigned long len = php_mysqlnd_net_field_length ( & p ) ; <NEW_LINE> <END_VULN> if ( copy_data == FALSE && current_field > start_field && last_field_was_string ) { <NEW_LINE> Normal queries:
void RenderSVGInline::styleDidChange ( StyleDifference diff , const RenderStyle * oldStyle ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( diff == StyleDifferenceLayout ) <NEW_LINE> <END_VULN> setNeedsBoundariesUpdate ( ) ; <NEW_LINE> RenderInline::styleDidChange ( diff , oldStyle ) ;
return false ; <NEW_LINE> cx = createContext ( ) ; <NEW_LINE> if ( ! cx ) <NEW_LINE> return false ; <NEW_LINE> JS_BeginRequest ( cx ) ; <NEW_LINE> JS::RootedObject global ( cx , createGlobal ( ) ) ; <NEW_LINE> if ( ! global ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> oldCompartment = JS_EnterCompartment ( cx , global ) ; <NEW_LINE>return oldCompartment != NULL ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool JSAPITest::exec ( const char * bytes , const char * filename , int lineno ) <NEW_LINE> { <NEW_LINE> JS::RootedValue v ( cx ) ; <NEW_LINE> JS::HandleObject global = JS::HandleObject::fromMarkedLocation ( & this -> global ) ; <NEW_LINE> return JS_EvaluateScript ( cx , global , bytes , strlen ( bytes ) , filename , lineno , v . address ( ) ) || <NEW_LINE> fail ( bytes , filename , lineno ) ;
#undef mem_put_le16 <NEW_LINE> #define mem_put_le16 mem_ops_wrap_symbol ( mem_put_le16 ) <NEW_LINE> <START_VULN> static void mem_put_le16 ( void * vmem , MEM_VALUE_T val ) { <NEW_LINE> <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; <NEW_LINE> mem [ 0 ] = ( val >> 0 ) & 0xff ;
int haystack_len , needle_len ; <NEW_LINE> unsigned char * found ; <NEW_LINE> long loffset = 0 ; <NEW_LINE> <START_VULN> int32_t offset = 0 ; <NEW_LINE> <END_VULN> int ret_pos ; <NEW_LINE> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "ss | l" , ( char ** ) & haystack , & haystack_len , ( char ** ) & needle , & needle_len , & loffset ) == FAILURE ) {
char * suffix = 0 , * fname ; <NEW_LINE> int slen = 0 ; <NEW_LINE> size_t flen ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , " | s" , & suffix , & slen ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
array_transpose_8x8 ( in , in ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void fadst8_sse2 ( __m128i * in ) { <NEW_LINE> <END_VULN> const __m128i k__cospi_p02_p30 = pair_set_epi16 ( cospi_2_64 , cospi_30_64 ) ; <NEW_LINE> const __m128i k__cospi_p30_m02 = pair_set_epi16 ( cospi_30_64 , - cospi_2_64 ) ;
<START_VULN> <NEW_LINE> <END_VULN> temp = ( struct sackhole * ) <NEW_LINE> pool_get ( & sackhl_pool , PR_NOWAIT ) ; <NEW_LINE> if ( temp == NULL )
HeapObjectHeader * header = reinterpret_cast < HeapObjectHeader * > ( objectAddress ) ; <NEW_LINE> if ( header -> isFree ( ) ) <NEW_LINE> return nullptr ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> return header ; <NEW_LINE> }
virtual void StartFetching ( FetchCallback callback ) ; <NEW_LINE> <START_VULN> virtual void DeleteSharedWorker ( const GURL & worker , const std::string & name ) ; <NEW_LINE> <END_VULN> protected: <NEW_LINE> virtual ~ BrowsingDataSharedWorkerHelper ( ) ;
PRInt16 GetType ( ) { return mType ; } <NEW_LINE> PRInt8 GetCropStyle ( ) { return mCropStyle ; } <NEW_LINE> PRInt32 GetTextAlignment ( ) { return mTextAlignment ; } <NEW_LINE> nsTreeColumn * GetNext ( ) { return mNext ; } <NEW_LINE> nsTreeColumn * GetPrevious ( ) { return mPrevious ; } <NEW_LINE> <START_VULN> void SetNext ( nsTreeColumn * aNext ) { NS_IF_ADDREF ( mNext = aNext ) ; } <NEW_LINE> <END_VULN> void SetPrevious ( nsTreeColumn * aPrevious ) { mPrevious = aPrevious ; } <NEW_LINE> private: <NEW_LINE> nsCOMPtr < nsIContent > mContent ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: PCM data envelope analysis <NEW_LINE> <START_VULN> last mod: $ Id: envelope . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h >
{ <NEW_LINE> ALOGV ( "constructor" ) ; <NEW_LINE> <START_VULN> const sp < IMediaPlayerService > & service ( getMediaPlayerService ( ) ) ; <NEW_LINE> <END_VULN> if ( service != NULL ) { <NEW_LINE> mMediaRecorder = service -> createMediaRecorder ( opPackageName ) ; <NEW_LINE> }
{ <NEW_LINE> <START_VULN> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <NEW_LINE> & ps_codec -> s_parse . s_bitstrm , <NEW_LINE>slice_qp , <NEW_LINE>cabac_init_idc , <NEW_LINE> & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
* result_len = 0 ; <NEW_LINE> start_offset = 0 ; <NEW_LINE> PCRE_G ( error_code ) = PHP_PCRE_NO_ERROR ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> while ( 1 ) { <NEW_LINE> count = pcre_exec ( pce -> re , extra , subject , subject_len , start_offset ,
static int open_unix_listener ( h2o_configurator_command_t * cmd , yoml_t * node , struct sockaddr_un * sa ) <NEW_LINE> { <NEW_LINE> struct stat st ; <NEW_LINE> <START_VULN> int fd ; <NEW_LINE> <END_VULN> struct passwd * owner = NULL , pwbuf ; <NEW_LINE> char pwbuf_buf [ 65536 ] ; <NEW_LINE> unsigned mode = UINT_MAX ;
buf [ ME_MAX_FNAME ] = '\0' ; <NEW_LINE> if ( buf [ 0 ] == '#' && buf [ 1 ] == ' ! ' ) { <NEW_LINE> cp = start = & buf [ 2 ] ; <NEW_LINE> <START_VULN> cmdShell = stok ( & buf [ 2 ] , "\r\n" , & tok ) ; <NEW_LINE> <END_VULN> if ( ! mprIsPathAbs ( cmdShell ) ) { <NEW_LINE> If we cannot access the command shell and the command is not an absolute path ,
<START_VULN> class CoordinatorImpl : public Coordinator , public mojom::Coordinator { <NEW_LINE> <END_VULN> public: <NEW_LINE> static CoordinatorImpl * GetInstance ( ) ;
long n = look -> n ; <NEW_LINE> long posts = look -> posts ; <NEW_LINE> long nonzero = 0 ; <NEW_LINE> lsfit_acc fits [ VIF_POSIT + 1 ] ; <NEW_LINE> int fit_valueA [ VIF_POSIT + 2 ] ; <NEW_LINE> int fit_valueB [ VIF_POSIT + 2 ] ; <NEW_LINE> int loneighbor [ VIF_POSIT + 2 ] ; <NEW_LINE> <START_VULN> int hineighbor [ VIF_POSIT + 2 ] ; <NEW_LINE> <END_VULN> int * output = NULL ; <NEW_LINE> int memo [ VIF_POSIT + 2 ] ; <NEW_LINE> for ( i = 0 ; i < posts ; i ++ ) fit_valueA [ i ] = - 200 ; <NEW_LINE> for ( i = 0 ; i < posts ; i ++ ) fit_valueB [ i ] = - 200 ; <NEW_LINE> for ( i = 0 ; i < posts ; i ++ ) loneighbor [ i ] = 0 ; <NEW_LINE> for ( i = 0 ; i < posts ; i ++ ) hineighbor [ i ] = 1 ; <NEW_LINE> for ( i = 0 ; i < posts ; i ++ ) memo [ i ] = - 1 ;
plainlen = tmsglen ; <NEW_LINE> conflen = kg_confounder_size ( context , ctx -> enc -> keyblock . enctype ) ; <NEW_LINE> <START_VULN> token . length = tmsglen - conflen - plain [ tmsglen - 1 ] ; <NEW_LINE> <END_VULN> if ( token . length ) { <NEW_LINE> if ( ( token . value = ( void * ) gssalloc_malloc ( token . length ) ) == NULL ) {
bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_ENCAP ) ; <NEW_LINE> <START_VULN> #if ENABLE_BGP_VNC <NEW_LINE> <END_VULN> bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ; <NEW_LINE> #endif
#define CONFIG_HOSTNAME "kmcoge5un" <NEW_LINE> #define CONFIG_KM_DISABLE_PCIE <NEW_LINE> <START_VULN> <NEW_LINE>#elif defined ( CONFIG_KM_SUV31 ) <NEW_LINE>#define CONFIG_HOSTNAME "kmsuv31" <NEW_LINE> <END_VULN> #undef CONFIG_SYS_KWD_CONFIG <NEW_LINE> #define CONFIG_SYS_KWD_CONFIG $ ( CONFIG_BOARDDIR ) / kwbimage_128M16_1 . cfg <NEW_LINE> #define CONFIG_KM_UBI_PART_BOOT_OPTS " , 2048"
if ( posts == 0 ) { <NEW_LINE> nonzero += accumulate_fit ( logmask , logmdct , 0 , n , fits , n , info ) ; <NEW_LINE> } else { <NEW_LINE> for ( i = 0 ; i < posts - 1 ; i ++ ) <NEW_LINE> nonzero += accumulate_fit ( logmask , logmdct , look -> sorted_index [ i ] , <NEW_LINE> <START_VULN> look -> sorted_index [ i + 1 ] , fits + i , <NEW_LINE>n , info ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( nonzero ) { <NEW_LINE> int y0 = - 200 ; <NEW_LINE> int y1 = - 200 ; <NEW_LINE> fit_line ( fits , posts - 1 , & y0 , & y1 ) ;
* <NEW_LINE> <START_VULN> int mbedtls_ecdsa_sign_det ( mbedtls_ecp_group * grp , mbedtls_mpi * r , mbedtls_mpi * s , <NEW_LINE>const mbedtls_mpi * d , const unsigned char * buf , size_t blen , <NEW_LINE>mbedtls_md_type_t md_alg ) ; <NEW_LINE> <END_VULN> #endif
cpi -> common . y1dc_delta_q ) ; <NEW_LINE> #if CONFIG_TEMPORAL_DENOISING <NEW_LINE> <START_VULN> unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX , <NEW_LINE>best_rd_sse = INT_MAX ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> mode_mv = mode_mv_sb [ sign_bias ] ;
const long long frame_size = total_size / m_frame_count ; <NEW_LINE> <START_VULN> if ( frame_size > LONG_MAX ) <NEW_LINE> <END_VULN> return E_FILE_FORMAT_INVALID ; <NEW_LINE> Frame * pf = m_frames ;
extern const char kProtectorHistogramStartupSettingsChanged [ ] ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> extern const char kProtectorHistogramStartupSettingsDiscarded [ ] ; <NEW_LINE> extern const char kProtectorHistogramStartupSettingsTimeout [ ] ;
static int <NEW_LINE> tiffcp ( TIFF * in , TIFF * out ) <NEW_LINE> { <NEW_LINE> <START_VULN> uint16 bitspersample , samplesperpixel = 1 ; <NEW_LINE> <END_VULN> uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ; <NEW_LINE> copyFunc cf ; <NEW_LINE> uint32 width , length ;
int render_frame_id , <NEW_LINE> MediaStreamManager * media_stream_manager ) ; <NEW_LINE> ~ MediaStreamDispatcherHost ( ) override ; <NEW_LINE> <START_VULN> <NEW_LINE>void BindRequest ( mojom::MediaStreamDispatcherHostRequest request ) ; <NEW_LINE> <END_VULN> void set_salt_and_origin_callback_for_testing ( <NEW_LINE> MediaDeviceSaltAndOriginCallback callback ) {
SH_DEPENDENCY_GRAPH = 0x0400 , <NEW_LINE> <START_VULN> SH_ENFORCE_PACKING_RESTRICTIONS = 0x0800 <NEW_LINE> <END_VULN> } ShCompileOptions ; <NEW_LINE> COMPILER_EXPORT int ShInitialize ( ) ;
proto_item * rsn_sub_pcs_item , * rsn_sub_akms_item ; <NEW_LINE> proto_tree * rsn_gcs_tree , * rsn_pcs_tree , * rsn_akms_tree , * rsn_cap_tree , * rsn_pmkid_tree , * rsn_gmcs_tree ; <NEW_LINE> proto_tree * rsn_sub_pcs_tree , * rsn_sub_akms_tree ; <NEW_LINE> <START_VULN> guint16 i , pcs_count , akms_count , pmkid_count ; <NEW_LINE> <END_VULN> int tag_end = offset + tag_len ; <NEW_LINE> proto_tree_add_item ( tree , hf_ieee80211_rsn_version , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;
{ <NEW_LINE> NS_ENSURE_ARG_POINTER ( aLoadGroup ) ; <NEW_LINE> * aLoadGroup = nsnull ; <NEW_LINE> if ( mState & XML_HTTP_REQUEST_BACKGROUND ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsCOMPtr < nsIDocument > doc = GetDocumentFromScriptContext ( mScriptContext ) ; <NEW_LINE> <END_VULN> if ( doc ) { <NEW_LINE> * aLoadGroup = doc -> GetDocumentLoadGroup ( ) . get ( ) ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult
for ( OMX_U32 i = 0 ; i < def . nBufferCountActual ; ++ i ) { <NEW_LINE> sp < IMemory > mem = mDealer [ portIndex ] -> allocate ( def . nBufferSize ) ; <NEW_LINE> <START_VULN> CHECK ( mem . get ( ) != NULL ) ; <NEW_LINE> <END_VULN> BufferInfo info ; <NEW_LINE> info . mData = NULL ;
static inline Quantum GetPixelChannel ( const Image * magick_restrict image , <NEW_LINE> const PixelChannel channel , const Quantum * magick_restrict pixel ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( image -> channel_map [ image -> channel_map [ channel ] . offset ] . traits == UndefinedPixelTrait ) <NEW_LINE> <END_VULN> return ( ( Quantum ) 0 ) ; <NEW_LINE> return ( pixel [ image -> channel_map [ channel ] . offset ] ) ; <NEW_LINE> }
} <NEW_LINE> close ( fd ) ; <NEW_LINE> <START_VULN> continue ; <NEW_LINE> <END_VULN> }
#ifndef VP9_COMMON_VP9_SEG_COMMON_H_ <NEW_LINE> #define VP9_COMMON_VP9_SEG_COMMON_H_ <NEW_LINE> <START_VULN> #include "vp9 / common / vp9_prob . h" <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> extern "C" {
VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ; <NEW_LINE> <START_VULN> round = ( vpx_codec_pts_t ) 1000000 <NEW_LINE> <END_VULN> delta = ( dst_end_time_stamp - dst_time_stamp ) ; <NEW_LINE> pkt . kind = VPX_CODEC_CX_FRAME_PKT ;
virtual bool IsRoot ( ) { return true ; } <NEW_LINE> <START_VULN> void RequestUpdatePluginGeometry ( nsIFrame * aFrame ) ; <NEW_LINE><NEW_LINE><NEW_LINE>void RootForgetUpdatePluginGeometryFrame ( nsIFrame * aFrame ) ; <NEW_LINE><NEW_LINE><NEW_LINE>void RootForgetUpdatePluginGeometryFrameForPresContext ( nsPresContext * aPresContext ) ; <NEW_LINE> <END_VULN> void IncrementDOMGeneration ( ) { mDOMGeneration ++ ; }
<START_VULN> const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_width , <NEW_LINE>16 ) ; <NEW_LINE>const int er_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_height , 6 ) - src -> y_height , <NEW_LINE>16 ) ; <NEW_LINE> <END_VULN> const int uv_width_subsampling = ( src -> uv_width != src -> y_width ) ; <NEW_LINE> const int uv_height_subsampling = ( src -> uv_height != src -> y_height ) ; <NEW_LINE> const int et_uv = et_y >> uv_height_subsampling ;
if ( ! value . IsEmpty ( ) ) { <NEW_LINE> PRInt32 error ; <NEW_LINE> colspan = value . ToInteger ( & error ) ; <NEW_LINE> <START_VULN> if ( error || colspan < 0 ) <NEW_LINE> <END_VULN> colspan = 1 ; <NEW_LINE> } <NEW_LINE> }
for ( i = 0 ; i < attribute_count ; i ++ ) { <NEW_LINE> size_t record_len = coolkey_get_attribute_record_len ( attr , object_record_type , buf_len ) ; <NEW_LINE> <START_VULN> if ( buf_len < record_len ) { <NEW_LINE> <END_VULN> return SC_ERROR_CORRUPTED_DATA ; <NEW_LINE> }
if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> <START_VULN> aString . SetLength ( length ) ; <NEW_LINE> <END_VULN> nsAString::iterator start ; <NEW_LINE> aString . BeginWriting ( start ) ;
Zone ** end = rt -> zones . end ( ) ; <NEW_LINE> Zone ** write = read ; <NEW_LINE> JS_ASSERT ( rt -> zones . length ( ) >= 1 ) ; <NEW_LINE> JS_ASSERT ( rt -> isAtomsZone ( rt -> zones [ 0 ] ) ) ; <NEW_LINE> while ( read < end ) { <NEW_LINE> Zone * zone = * read ++ ; <NEW_LINE> <START_VULN> if ( ! zone -> hold && zone -> wasGCStarted ( ) ) { <NEW_LINE> <END_VULN> if ( zone -> allocator . arenas . arenaListsAreEmpty ( ) || lastGC ) { <NEW_LINE> zone -> allocator . arenas . checkEmptyFreeLists ( ) ; <NEW_LINE> if ( callback ) <NEW_LINE> callback ( zone ) ; <NEW_LINE> SweepCompartments ( fop , zone , false , lastGC ) ; <NEW_LINE> JS_ASSERT ( zone -> compartments . empty ( ) ) ; <NEW_LINE> fop -> delete_ ( zone ) ; <NEW_LINE> continue ;
"outer and inner globals should have the same prototype" ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> JSContext * <NEW_LINE> nsJSContext::GetNativeContext ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> return mContext ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsresult <NEW_LINE> nsJSContext::InitContext ( ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_TRUE ( ! mIsInitialized , NS_ERROR_ALREADY_INITIALIZED ) ;
if ( e == text ) { <NEW_LINE> <START_VULN> if ( js_regexec ( re -> prog , text , & m , 0 ) ) { <NEW_LINE> <END_VULN> if ( len == limit ) return ; <NEW_LINE> js_pushliteral ( J , "" ) ; <NEW_LINE> js_setindex ( J , - 2 , 0 ) ;
{ <NEW_LINE> <START_VULN> cupsdSetString ( & attr -> values [ 1 ] . string . text , attr -> values [ 0 ] . string . text ) ; <NEW_LINE> <END_VULN> cupsdLogJob ( job , CUPSD_LOG_NOTICE , "CLASSIFICATION FORCED " <NEW_LINE> "job - sheets = \" % s , % s\" , "
static void <NEW_LINE> allocate ( struct file * file , int allocate_idat ) <NEW_LINE> { <NEW_LINE> <START_VULN> struct control * control = png_voidcast ( struct control * , file -> alloc_ptr ) ; <NEW_LINE> <END_VULN> if ( allocate_idat ) <NEW_LINE> {
break ; <NEW_LINE> } <NEW_LINE> curWnd = ::GetParent ( curWnd ) ; <NEW_LINE> } <NEW_LINE> if ( toplevelWnd ) { <NEW_LINE> nsWindow * win = WinUtils::GetNSWindowPtr ( toplevelWnd ) ; <NEW_LINE> <START_VULN> if ( win ) { <NEW_LINE>if ( aIsActivate ) <NEW_LINE>mWidgetListener -> WindowActivated ( ) ; <NEW_LINE>else <NEW_LINE>mWidgetListener -> WindowDeactivated ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> bool nsWindow::IsTopLevelMouseExit ( HWND aWnd ) <NEW_LINE> { <NEW_LINE> DWORD pos = ::GetMessagePos ( ) ; <NEW_LINE> POINT mp ;
static int <NEW_LINE> image_transform_png_set_palette_to_rgb_add ( image_transform * this , <NEW_LINE> <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE> <END_VULN> { <NEW_LINE> UNUSED ( bit_depth )
<START_VULN> int mbedtls_ecdsa_sign ( mbedtls_ecp_group * grp , mbedtls_mpi * r , mbedtls_mpi * s , <NEW_LINE>const mbedtls_mpi * d , const unsigned char * buf , size_t blen , <NEW_LINE>int ( * f_rng ) ( void * , unsigned char * , size_t ) , void * p_rng ) <NEW_LINE> <END_VULN> { <NEW_LINE> int ret , key_tries , sign_tries , blind_tries ; <NEW_LINE> mbedtls_ecp_point R ;
} <NEW_LINE> yy63: <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 600 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> #if SIZEOF_LONG == 4 <NEW_LINE> use_double:
<START_VULN> # ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED <NEW_LINE> <END_VULN> return discard ; <NEW_LINE> # else <NEW_LINE> return 1 ;
if ( lhs . isInfinite ( ) ) <NEW_LINE> return ; <NEW_LINE> int64_t a = Abs < int64_t > ( rhs . lower ( ) ) ; <NEW_LINE> int64_t b = Abs < int64_t > ( rhs . upper ( ) ) ; <NEW_LINE> if ( a == 0 && b == 0 ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> int64_t bound = Max ( 1 - a , b - 1 ) ; <NEW_LINE> <END_VULN> setRange ( new Range ( - bound , bound , lhs . isDecimal ( ) || rhs . isDecimal ( ) ) ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> MToDouble::computeRange ( ) <NEW_LINE> { <NEW_LINE> setRange ( new Range ( getOperand ( 0 ) ) ) ; <NEW_LINE> }
return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> return ! r -> isInline ( ) && r -> isRenderBlock ( ) && ! r -> isFloatingOrPositioned ( ) && ! r -> isBody ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static bool shouldEmitNewlineAfterNode ( Node * node )
_ogg_free ( e -> mark ) ; <NEW_LINE> memset ( e , 0 , sizeof ( * e ) ) ; <NEW_LINE> } <NEW_LINE> static int _ve_amp ( envelope_lookup * ve , <NEW_LINE> <START_VULN> vorbis_info_psy_global * gi , <NEW_LINE>float * data , <NEW_LINE>envelope_band * bands , <NEW_LINE>envelope_filter_state * filters , <NEW_LINE>long pos ) { <NEW_LINE> <END_VULN> long n = ve -> winlength ; <NEW_LINE> int ret = 0 ; <NEW_LINE> long i , j ; <NEW_LINE> float decay ;
#include < string > <NEW_LINE> #include "base / gtest_prod_util . h" <NEW_LINE> <START_VULN> #include "base / time . h" <NEW_LINE>#include "chrome / browser / autocomplete / autocomplete_match . h" <NEW_LINE>#include "chrome / browser / autocomplete / history_provider . h" <NEW_LINE> <END_VULN> #include "chrome / browser / history / shortcuts_backend . h" <NEW_LINE> class Profile ;
fvalue = va_arg ( args , double ) ; <NEW_LINE> break ; <NEW_LINE> case 'c': <NEW_LINE> <START_VULN> doapr_outch ( sbuffer , buffer , & currlen , maxlen , <NEW_LINE>va_arg ( args , int ) ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 's': <NEW_LINE> strvalue = va_arg ( args , char * ) ;
: 0 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void utf16_to_utf8 ( const char16_t * src , size_t src_len , char * dst ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( src == NULL || src_len == 0 || dst == NULL ) { <NEW_LINE> return ;
} <NEW_LINE> <START_VULN> if ( avoidsFloats ( ) || isRoot ( ) || isRenderView ( ) || isFloatingOrPositioned ( ) || isTableCell ( ) ) { <NEW_LINE> <END_VULN> if ( m_floatingObjects ) { <NEW_LINE> deleteAllValues ( m_floatingObjects -> set ( ) ) ; <NEW_LINE> m_floatingObjects -> clear ( ) ;
NS_ASSERTION ( startTicks == TimeToTicksRoundUp ( rate , outputStart ) , <NEW_LINE> "Samples missing" ) ; <NEW_LINE> TrackTicks endTicks = TimeToTicksRoundUp ( rate , outputEnd ) ; <NEW_LINE> TrackTicks ticks = endTicks - startTicks ; <NEW_LINE> StreamTime inputEnd = source -> GraphTimeToStreamTime ( interval . mEnd ) ; <NEW_LINE> TrackTicks inputTrackEndPoint = TRACK_TICKS_MAX ; <NEW_LINE> <START_VULN> if ( inputTrack -> IsEnded ( ) ) { <NEW_LINE>TrackTicks inputEndTicks = inputTrack -> TimeToTicksRoundDown ( inputEnd ) ; <NEW_LINE>if ( inputTrack -> GetEnd ( ) <= inputEndTicks ) { <NEW_LINE>inputTrackEndPoint = inputTrack -> GetEnd ( ) ; <NEW_LINE> <END_VULN> * aOutputTrackFinished = true ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( interval . mInputIsBlocked ) { <NEW_LINE> segment -> AppendNullData ( ticks ) ; <NEW_LINE> LOG ( PR_LOG_DEBUG , ( "TrackUnionStream % p appending % lld ticks of null data to track % d" ,
#include "StructuredHeadersUtilities . h" <NEW_LINE> <START_VULN> #include < boost / archive / iterators / binary_from_base64 . hpp > <NEW_LINE>#include < boost / archive / iterators / base64_from_binary . hpp > <NEW_LINE>#include < boost / archive / iterators / transform_width . hpp > <NEW_LINE> <END_VULN> #include "StructuredHeadersConstants . h" <NEW_LINE> namespace proxygen { <NEW_LINE> namespace StructuredHeaders {
: public device::BluetoothAdapter , <NEW_LINE> private chromeos::BluetoothAdapterClient::Observer , <NEW_LINE> private chromeos::BluetoothDeviceClient::Observer , <NEW_LINE> <START_VULN> private chromeos::BluetoothInputClient::Observer { <NEW_LINE> <END_VULN> public: <NEW_LINE> virtual void AddObserver (
if ( format == LOCAL_GL_DEPTH_COMPONENT || <NEW_LINE> format == LOCAL_GL_DEPTH_STENCIL ) <NEW_LINE> return ErrorInvalidOperation ( "copyTexSubImage2D: a base internal format of DEPTH_COMPONENT or DEPTH_STENCIL isn't supported" ) ; <NEW_LINE> if ( mBoundFramebuffer ) <NEW_LINE> if ( ! mBoundFramebuffer -> CheckAndInitializeRenderbuffers ( ) ) <NEW_LINE> return ErrorInvalidFramebufferOperation ( "copyTexSubImage2D: incomplete framebuffer" ) ; <NEW_LINE> <START_VULN> return CopyTexSubImage2D_base ( target , level , format , xoffset , yoffset , x , y , width , height , true ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> already_AddRefed < WebGLProgram > <NEW_LINE> WebGLContext::CreateProgram ( ) <NEW_LINE> { <NEW_LINE> if ( ! IsContextStable ( ) ) <NEW_LINE> return nullptr ;
<START_VULN> #ifndef BASE_THREADING_JAVA_THREAD_H_ <NEW_LINE>#define BASE_THREADING_JAVA_THREAD_H_ <NEW_LINE> <END_VULN> #include < jni . h >
"refresh" , <NEW_LINE> "xbl" , <NEW_LINE> "ping" , <NEW_LINE> "xmlhttprequest" , <NEW_LINE> "objectsubrequest" , <NEW_LINE> "dtd" , <NEW_LINE> "font" , <NEW_LINE> "media" , <NEW_LINE> <START_VULN> "websocket" <NEW_LINE>"csp_report" } ; <NEW_LINE> <END_VULN> #define NUMBER_OF_TYPES NS_ARRAY_LENGTH ( kTypeString ) <NEW_LINE> uint8_t nsContentBlocker::mBehaviorPref [ NUMBER_OF_TYPES ] ; <NEW_LINE> NS_IMPL_ISUPPORTS3 ( nsContentBlocker , <NEW_LINE> nsIContentPolicy , <NEW_LINE> nsIObserver , <NEW_LINE> nsSupportsWeakReference )
static int <NEW_LINE> image_transform_png_set_strip_16_add ( image_transform * this , <NEW_LINE> <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <NEW_LINE> <END_VULN> { <NEW_LINE> UNUSED ( colour_type )
tracker . Insert ( nextFrame , kidStatus ) ; <NEW_LINE> NS_MergeReflowStatusInto ( & reflowStatus , kidStatus ) ; <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> if ( nextFrame ) { <NEW_LINE> <START_VULN> tracker . Finish ( kidFrame ) ; <NEW_LINE> <END_VULN> static_cast < nsContainerFrame * > ( nextFrame -> GetParent ( ) ) <NEW_LINE> -> DeleteNextInFlowChild ( aPresContext , nextFrame , true ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> tracker . Skip ( kidFrame , reflowStatus ) ; <NEW_LINE> if ( aOverflowAreas ) {
init_validate_info ( validate_info * vi , gamma_display * dp , png_const_structp pp , <NEW_LINE> int in_depth , int out_depth ) <NEW_LINE> { <NEW_LINE> <START_VULN> PNG_CONST unsigned int outmax = ( 1U << out_depth ) - 1 ; <NEW_LINE> <END_VULN> vi -> pp = pp ; <NEW_LINE> vi -> dp = dp ;
the debug channel , the log handler will be invoked to accept the output message . <NEW_LINE> @param handler Callback handler <NEW_LINE> @return Prior log handler <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC MprLogHandler mprSetLogHandler ( MprLogHandler handler ) ;
if ( IsAnimValList ( ) ) { <NEW_LINE> Element ( ) -> FlushAnimations ( ) ; <NEW_LINE> } <NEW_LINE> return LengthNoFlush ( ) ; <NEW_LINE> } <NEW_LINE> void Clear ( ErrorResult & error ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGNumber > Initialize ( nsIDOMSVGNumber * newItem , <NEW_LINE> ErrorResult & error ) ; <NEW_LINE> <START_VULN> nsIDOMSVGNumber * GetItem ( uint32_t index , ErrorResult & error ) <NEW_LINE> { <NEW_LINE>bool found ; <NEW_LINE>nsIDOMSVGNumber * item = IndexedGetter ( index , found , error ) ; <NEW_LINE>if ( ! found ) { <NEW_LINE>error . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; <NEW_LINE> } <NEW_LINE>return item ; <NEW_LINE> } <NEW_LINE>nsIDOMSVGNumber * IndexedGetter ( uint32_t index , bool & found , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE> <END_VULN> already_AddRefed < nsIDOMSVGNumber > InsertItemBefore ( nsIDOMSVGNumber * newItem , <NEW_LINE> uint32_t index , <NEW_LINE> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGNumber > ReplaceItem ( nsIDOMSVGNumber * newItem , <NEW_LINE> uint32_t index , <NEW_LINE> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGNumber > RemoveItem ( uint32_t index , <NEW_LINE> ErrorResult & error ) ;
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> } <NEW_LINE> break ;
#define VP9_ENCODER_VP9_SEGMENTATION_H_ <NEW_LINE> #include "vp9 / common / vp9_blockd . h" <NEW_LINE> <START_VULN> #include "vp9 / encoder / vp9_onyx_int . h" <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> extern "C" {
void OnAccessTokenRemoved ( <NEW_LINE> const std::string & account_id , <NEW_LINE> const OAuth2TokenService::ScopeSet & scopes ) override ; <NEW_LINE> <START_VULN> void OnRefreshTokenAvailable ( const std::string & account_id ) override ; <NEW_LINE>void OnRefreshTokenRevoked ( const std::string & account_id ) override ; <NEW_LINE> <END_VULN> void OnRefreshTokensLoaded ( ) override ; <NEW_LINE> void OnEndBatchChanges ( ) override ;
bool IsDecodeMentionsDisabled ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE>bool IsNowOnTapBarIntegrationEnabled ( ) ; <NEW_LINE> <END_VULN> void DisableCache ( ) ;
Selection ( ) . SetSelection ( <NEW_LINE> SelectionInDOMTree::Builder ( ) <NEW_LINE> . SetBaseAndExtent ( Position ( text , 0 ) , Position ( text , 5 ) ) <NEW_LINE> <START_VULN> . SetIsHandleVisible ( true ) <NEW_LINE> <END_VULN> . Build ( ) ) ; <NEW_LINE> Selection ( ) . SetSelection ( SelectionInDOMTree::Builder ( )
bool GetString ( base::string16 * data ) const ; <NEW_LINE> <START_VULN> bool GetURLAndTitle ( GURL * url , base::string16 * title ) const ; <NEW_LINE> <END_VULN> bool GetFilename ( base::FilePath * path ) const ; <NEW_LINE> bool GetFilenames (
if ( err == 0 ) <NEW_LINE> err = mp_read_unsigned_bin ( k , ( byte * ) buf , size ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( err == MP_OKAY ) { <NEW_LINE>if ( mp_iszero ( k ) == MP_YES ) <NEW_LINE>err = MP_ZERO_E ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> if ( err == MP_OKAY ) { <NEW_LINE> if ( mp_cmp ( k , order ) != MP_LT ) { <NEW_LINE> err = mp_mod ( k , order , k ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> ForceZero ( buf , ECC_MAXSIZE ) ; <NEW_LINE> #ifdef WOLFSSL_SMALL_STACK <NEW_LINE> XFREE ( buf , NULL , DYNAMIC_TYPE_ECC_BUFFER ) ;
@description Suspend the current thread until the application is shutting down . <NEW_LINE> @param timeout Timeout to wait for shutdown . <NEW_LINE> @ingroup MprDispatcher <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC void mprSuspendThread ( MprTicks timeout ) ;
if ( use_y4m && ! noblit ) { <NEW_LINE> if ( ! single_file ) { <NEW_LINE> fprintf ( stderr , "YUV4MPEG2 not supported with output patterns , " <NEW_LINE> <START_VULN> " try -- i420 or -- yv12 . \n" ) ; <NEW_LINE> <END_VULN> return EXIT_FAILURE ; <NEW_LINE> }
#include "nsITransaction . h" <NEW_LINE> #include "nsITransactionListener . h" <NEW_LINE> #include "nsTransactionItem . h" <NEW_LINE> #include "nsTransactionStack . h" <NEW_LINE> #include "nsVoidArray . h" <NEW_LINE> #include "nsTransactionManager . h" <NEW_LINE> #include "nsTransactionList . h" <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "nsCOMPtr . h" <NEW_LINE> #define LOCK_TX_MANAGER ( mgr ) ( mgr ) -> Lock ( ) <NEW_LINE> #define UNLOCK_TX_MANAGER ( mgr ) ( mgr ) -> Unlock ( ) <NEW_LINE> nsTransactionManager::nsTransactionManager ( PRInt32 aMaxTransactionCount ) <NEW_LINE> : mMaxTransactionCount ( aMaxTransactionCount ) , mListeners ( 0 )
if ( NS_FAILED ( rv ) ) <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> ModuleEntry * mod ; <NEW_LINE> if ( mModules . Get ( spec , & mod ) ) <NEW_LINE> return mod ; <NEW_LINE> <START_VULN> nsAutoPtr < ModuleEntry > entry ( new ModuleEntry ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( mContext ) ; <NEW_LINE> RootedValue dummy ( mContext ) ; <NEW_LINE> rv = ObjectForLocation ( file , uri , & entry -> obj , & entry -> thisObjectKey , <NEW_LINE> & entry -> location , false , & dummy ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> return nullptr ; <NEW_LINE> }
Adjustment = ( cpi -> this_frame_target - min_frame_target ) ; <NEW_LINE> if ( cpi -> frames_since_golden == ( cpi -> current_gf_interval >> 1 ) ) <NEW_LINE> <START_VULN> cpi -> this_frame_target += ( ( cpi -> current_gf_interval - 1 ) * Adjustment ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> cpi -> this_frame_target - = Adjustment ; <NEW_LINE> }
q1u8 = vcombine_u8 ( d2u8 , d3u8 ) ; <NEW_LINE> q2u8 = vcombine_u8 ( d4u8 , d5u8 ) ; <NEW_LINE> <START_VULN> d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ; <NEW_LINE>d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ; <NEW_LINE> <END_VULN> q4u64 = vshrq_n_u64 ( vreinterpretq_u64_u8 ( q1u8 ) , 8 ) ; <NEW_LINE> q5u64 = vshrq_n_u64 ( vreinterpretq_u64_u8 ( q2u8 ) , 8 ) ;
ProxyJNIEnv & proxyEnv = GetProxyEnv ( env ) ; <NEW_LINE> nsISecureEnv * secureEnv = GetSecureEnv ( env ) ; <NEW_LINE> nsISecurityContext * securityContext = proxyEnv . getContext ( ) ; <NEW_LINE> <START_VULN> nsresult rv = secureEnv -> CallStaticMethod ( method -> mReturnType , clazz , method -> mMethodID , args , & outValue , securityContext ) ; <NEW_LINE> <END_VULN> NS_IF_RELEASE ( securityContext ) ; <NEW_LINE> return NS_SUCCEEDED ( rv ) ? outValue : kErrorValue ; <NEW_LINE> }
uint32_t tmp_val ; <NEW_LINE> uint32_t midi_type ; <NEW_LINE> <START_VULN> uint32_t track_size ; <NEW_LINE> <END_VULN> uint8_t ** tracks ; <NEW_LINE> uint32_t end_of_tracks = 0 ; <NEW_LINE> uint32_t no_tracks ; <NEW_LINE> uint32_t i ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsPlaceholderFrame::Destroy ( ) <NEW_LINE> { <NEW_LINE> nsIPresShell * shell = PresContext ( ) -> GetPresShell ( ) ; <NEW_LINE> if ( shell && mOutOfFlowFrame ) { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! shell -> FrameManager ( ) -> GetPlaceholderFrameFor ( mOutOfFlowFrame ) , <NEW_LINE>"Placeholder relationship should have been torn down ; see " <NEW_LINE>"comments in nsPlaceholderFrame . h" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsSplittableFrame::Destroy ( ) ; <NEW_LINE> } <NEW_LINE> nsSplittableType <NEW_LINE> nsPlaceholderFrame::GetSplittableType ( ) const <NEW_LINE> {
return png_ptr -> mem_ptr ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE>#endif <NEW_LINE> <END_VULN>
already_AddRefed < CanvasLayer > GetCanvasLayer ( LayerManager * manager ) ; <NEW_LINE> void MarkContextClean ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE>NS_DECL_ISUPPORTS <NEW_LINE> <END_VULN> NS_DECL_NSIDOMCANVASRENDERINGCONTEXT2D
<START_VULN> <NEW_LINE> <END_VULN> % lld" , st -> st_size ) ;
si -> w = 0 ; <NEW_LINE> si -> h = 0 ; <NEW_LINE> <START_VULN> res = ctx -> iface -> dec . get_si ( ctx -> priv -> alg_priv , si ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return SAVE_STATUS ( ctx , res ) ;
#define yypact_value_is_default ( Yystate ) \ <NEW_LINE> ( ! ! ( ( Yystate ) == ( - 73 ) ) ) <NEW_LINE> <START_VULN> #define YYTABLE_NINF - 94 <NEW_LINE> <END_VULN> #define yytable_value_is_error ( Yytable_value ) \ <NEW_LINE> 0
#undef mem_put_le32 <NEW_LINE> #define mem_put_le32 mem_ops_wrap_symbol ( mem_put_le32 ) <NEW_LINE> <START_VULN> static void mem_put_le32 ( void * vmem , MEM_VALUE_T val ) { <NEW_LINE> <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; <NEW_LINE> mem [ 0 ] = ( val >> 0 ) & 0xff ;
NS_IMETHODIMP <NEW_LINE> WebGLContext::SetCanvasElement ( nsHTMLCanvasElement * aParentCanvas ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( aParentCanvas == nsnull ) { <NEW_LINE><NEW_LINE><NEW_LINE>mCanvasElement = nsnull ; <NEW_LINE>return NS_OK ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( ! SafeToCreateCanvas3DContext ( aParentCanvas ) ) <NEW_LINE> <END_VULN> return NS_ERROR_FAILURE ; <NEW_LINE> mCanvasElement = aParentCanvas ;
htmlParseElementInternal ( htmlParserCtxtPtr ctxt ) { <NEW_LINE> const xmlChar * name ; <NEW_LINE> const htmlElemDesc * info ; <NEW_LINE> <START_VULN> htmlParserNodeInfo node_info = { 0 , } ; <NEW_LINE> <END_VULN> int failed ; <NEW_LINE> if ( ( ctxt == NULL ) || ( ctxt -> input == NULL ) ) {
<START_VULN> mp_err <NEW_LINE> <END_VULN> ec_GFp_pt_dbl_jm ( const mp_int * px , const mp_int * py , const mp_int * pz , <NEW_LINE> const mp_int * paz4 , mp_int * rx , mp_int * ry , mp_int * rz , <NEW_LINE> mp_int * raz4 , mp_int scratch [ ] , const ECGroup * group ) <NEW_LINE> { <NEW_LINE> mp_err res = MP_OKAY ; <NEW_LINE> mp_int * t0 , * t1 , * M , * S ; <NEW_LINE> t0 = & scratch [ 0 ] ;
sctp_v4_pf_init ( ) ; <NEW_LINE> sctp_v6_pf_init ( ) ; <NEW_LINE> <START_VULN> status = sctp_v4_protosw_init ( ) ; <NEW_LINE> <END_VULN> if ( status ) <NEW_LINE> goto err_protosw_init ;
<START_VULN> int Segment::TestFrame ( uint64 track_number , <NEW_LINE>uint64 frame_timestamp_ns , <NEW_LINE> <END_VULN> bool is_key ) const { <NEW_LINE> if ( force_new_cluster_ ) <NEW_LINE> return 1 ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . convert3" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( c * , , V8c::HasInstance ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ? V8c::toNative ( v8::Handle < v8::Object > ::Cast ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) : 0 ) ; <NEW_LINE> imp -> convert3 ( ) ;
int pgx_validate ( jas_stream_t * in ) <NEW_LINE> { <NEW_LINE> <START_VULN> uchar buf [ PGX_MAGICLEN ] ; <NEW_LINE> <END_VULN> uint_fast32_t magic ; <NEW_LINE> int i ; <NEW_LINE> int n ;
} <NEW_LINE> <START_VULN> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <NEW_LINE> <END_VULN> { <NEW_LINE> jas_stream_t * in ; <NEW_LINE> jas_iccprof_t * prof ;
{ <NEW_LINE> DATA_TYPE * oX1 = out + n2 + n4 ; <NEW_LINE> DATA_TYPE * oX2 = out + n2 + n4 ; <NEW_LINE> DATA_TYPE * iX = out ; <NEW_LINE> T = init -> trig + n2 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> do { <NEW_LINE> oX1 - = 4 ; <NEW_LINE> oX1 [ 3 ] = MULT_NORM ( iX [ 0 ] * T [ 1 ] - iX [ 1 ] * T [ 0 ] ) ; <NEW_LINE> oX2 [ 0 ] = - MULT_NORM ( iX [ 0 ] * T [ 0 ] + iX [ 1 ] * T [ 1 ] ) ; <NEW_LINE> oX1 [ 2 ] = MULT_NORM ( iX [ 2 ] * T [ 3 ] - iX [ 3 ] * T [ 2 ] ) ; <NEW_LINE> oX2 [ 1 ] = - MULT_NORM ( iX [ 2 ] * T [ 2 ] + iX [ 3 ] * T [ 3 ] ) ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> if ( tcp_specified && settings . port != 0 && ! udp_specified ) { <NEW_LINE>settings . udpport = settings . port ; <NEW_LINE> } else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) { <NEW_LINE> <END_VULN> settings . port = settings . udpport ; <NEW_LINE> }
OPENMPT_NAMESPACE_BEGIN <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> struct STPFileHeader <NEW_LINE> { <NEW_LINE> char magic [ 4 ] ;
gl -> fGetIntegerv ( LOCAL_GL_MAX_VERTEX_UNIFORM_COMPONENTS , ( GLint * ) & mGLMaxVertexUniformVectors ) ; <NEW_LINE> mGLMaxVertexUniformVectors /= 4 ; <NEW_LINE> <START_VULN> error = gl -> fGetError ( ) ; <NEW_LINE> <END_VULN> if ( error != LOCAL_GL_NO_ERROR ) { <NEW_LINE> LogMessage ( "GL error 0x % x occurred during WebGL context initialization ! " , error ) ; <NEW_LINE> return PR_FALSE ; <NEW_LINE> } <NEW_LINE> GLint maxVertexOutputComponents ,
line_start = mLines . begin ( ) ; <NEW_LINE> line_end = mLines . end ( ) ; <NEW_LINE> line = line_end ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> line = mLines . erase ( line ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> lineBox -> Destroy ( aPresContext -> PresShell ( ) ) ; <NEW_LINE> <END_VULN> if ( line != line_end ) { <NEW_LINE> line -> MarkPreviousMarginDirty ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return NS_OK ;
bool isLayoutSizeChanged ( ) const { return m_isLayoutSizeChanged ; } <NEW_LINE> void determineIfLayoutSizeChanged ( ) override ; <NEW_LINE> <START_VULN> void setNeedsTransformUpdate ( ) override { m_needsTransformUpdate = true ; } <NEW_LINE> <END_VULN> void paint ( const PaintInfo & , const LayoutPoint & ) const override ;
mStringWidth = largestWidth ; <NEW_LINE> return mStringWidth ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsListBoxBodyFrame::ComputeTotalRowCount ( ) <NEW_LINE> { <NEW_LINE> mRowCount = 0 ; <NEW_LINE> <START_VULN> nsIContent * listbox = mContent -> GetBindingParent ( ) ; <NEW_LINE>ENSURE_TRUE ( listbox ) ; <NEW_LINE>PRUint32 childCount = listbox -> GetChildCount ( ) ; <NEW_LINE>for ( PRUint32 i = 0 ; i < childCount ; i ++ ) { <NEW_LINE>if ( listbox -> GetChildAt ( i ) -> Tag ( ) == nsGkAtoms::listitem ) <NEW_LINE> <END_VULN> ++ mRowCount ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsListBoxBodyFrame::PostReflowCallback ( ) <NEW_LINE> { <NEW_LINE> if ( ! mReflowCallbackPosted ) {
if ( ! o ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( isWritingModeRoot ( ) && ! isPositioned ( ) ) <NEW_LINE> <END_VULN> flipForWritingMode ( rect ) ; <NEW_LINE> LayoutPoint topLeft = rect . location ( ) ;
if ( ++ channel >= channels ) <NEW_LINE> channel = 0 ; <NEW_LINE> * bp ++ = ( png_byte ) ( value >> 8 ) ; <NEW_LINE> <START_VULN> * bp ++ = ( png_byte ) ( value & 0xff ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> break ; <NEW_LINE> }
{ <NEW_LINE> JS_ASSERT ( this == & cx -> compartment -> types ) ; <NEW_LINE> JS_ASSERT ( ! cx -> runtime -> gcRunning ) ; <NEW_LINE> InferSpew ( ISpewOps , "pending: % sC % p % s % s" , <NEW_LINE> InferSpewColor ( constraint ) , constraint , InferSpewColorReset ( ) , <NEW_LINE> TypeString ( type ) ) ; <NEW_LINE> <START_VULN> if ( pendingCount == pendingCapacity ) <NEW_LINE>growPendingArray ( cx ) ; <NEW_LINE> <END_VULN> PendingWork & pending = pendingArray [ pendingCount ++ ] ; <NEW_LINE> pending . constraint = constraint ; <NEW_LINE> pending . source = source ; <NEW_LINE> pending . type = type ; <NEW_LINE> } <NEW_LINE> inline void
pthread_mutex_lock ( & client_socket_lock_ ) ; <NEW_LINE> safe_close_ ( & client_socket_ ) ; <NEW_LINE> client_socket_ = client_socket ; <NEW_LINE> <START_VULN> send ( client_socket_ , "btsnoop\0\0\0\0\1\0\0\x3\xea" , 16 , 0 ) ; <NEW_LINE> <END_VULN> pthread_mutex_unlock ( & client_socket_lock_ ) ; <NEW_LINE> }
protected: <NEW_LINE> void CreateSensorInternal ( mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> const CreateSensorCallback & callback ) override ; <NEW_LINE> private:
for ( x = 0 ; x < 6 ; x ++ ) <NEW_LINE> { <NEW_LINE> const int idx = ( p_data [ 4 + y ] >> ( 5 - x ) ) & 0x01 ; <NEW_LINE> <START_VULN> uint8_t * p = & p_cdg -> p_screen [ ( sy + y ) * CDG_SCREEN_PITCH + ( sx + x ) ] ; <NEW_LINE> <END_VULN> if ( doXor ) <NEW_LINE> * p ^= p_color [ idx ] ; <NEW_LINE> else
const nsCSSValue::Array * array = aValue . GetArrayValue ( ) ; <NEW_LINE> NS_ASSERTION ( array -> Count ( ) >= 1 , "Functions must have at least one element for the name . " ) ; <NEW_LINE> AppendCSSValueToString ( aProperty , array -> Item ( 0 ) , aResult ) ; <NEW_LINE> aResult . AppendLiteral ( " ( " ) ; <NEW_LINE> <START_VULN> for ( PRUint16 index = 1 ; index < array -> Count ( ) ; ++ index ) { <NEW_LINE> <END_VULN> AppendCSSValueToString ( aProperty , array -> Item ( index ) , aResult ) ; <NEW_LINE> if ( index + 1 != array -> Count ( ) ) <NEW_LINE> aResult . AppendLiteral ( " , " ) ; <NEW_LINE> }
const RenderBlock * cb = box -> containingBlock ( ) ; <NEW_LINE> <START_VULN> while ( ! cb -> isRenderView ( ) && ! cb -> isBody ( ) && ! cb -> isTableCell ( ) && ! cb -> isPositioned ( ) && cb -> style ( ) -> logicalHeight ( ) . isAuto ( ) ) { <NEW_LINE> <END_VULN> if ( ! box -> document ( ) -> inQuirksMode ( ) && ! cb -> isAnonymousBlock ( ) ) <NEW_LINE> break ; <NEW_LINE> cb = cb -> containingBlock ( ) ;
NS_ENSURE_SUCCESS ( rv , PR_FALSE ) ; <NEW_LINE> nsCOMPtr < nsIPresShell > sh ; <NEW_LINE> rv = mDocument -> CreateShell ( cx , vm , newSet , getter_AddRefs ( sh ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , PR_FALSE ) ; <NEW_LINE> newSet . forget ( ) ; <NEW_LINE> sh -> SetVerifyReflowEnable ( PR_FALSE ) ; <NEW_LINE> vm -> SetViewObserver ( ( nsIViewObserver * ) ( ( PresShell * ) sh . get ( ) ) ) ; <NEW_LINE> <START_VULN> WillCauseReflow ( ) ; <NEW_LINE>sh -> InitialReflow ( r . width , r . height ) ; <NEW_LINE>DidCauseReflow ( ) ; <NEW_LINE> <END_VULN> mDocument -> BindingManager ( ) -> ProcessAttachedQueue ( ) ; <NEW_LINE> sh -> FlushPendingNotifications ( Flush_Layout ) ; <NEW_LINE> sh -> SetVerifyReflowEnable ( PR_TRUE ) ; <NEW_LINE> ( ( PresShell * ) sh . get ( ) ) -> mPaintingSuppressed = PR_FALSE ; <NEW_LINE> if ( VERIFY_REFLOW_NOISY & gVerifyReflowFlags ) { <NEW_LINE> printf ( "Verification Tree built , comparing . . . \n" ) ;
<START_VULN> enum { FIXNUM_WIDTH = ( 8 * sizeof ( native_int ) ) - TAG_SHIFT - 1 } ; <NEW_LINE> <END_VULN> typedef enum
{ <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> mpz_powm ( v , v , key -> e , key -> n ) ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
#ifdef PNG_READ_zTXt_SUPPORTED <NEW_LINE> else if ( chunk_name == png_zTXt ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_zTXt ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
parent = ::GetParent ( mWnd ) ; <NEW_LINE> else <NEW_LINE> parent = ::GetAncestor ( mWnd , GA_PARENT ) ; <NEW_LINE> if ( parent ) { <NEW_LINE> widget = GetNSWindowPtr ( parent ) ; <NEW_LINE> if ( widget ) { <NEW_LINE> <START_VULN> if ( widget -> mIsDestroying ) { <NEW_LINE> <END_VULN> widget = nsnull ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return widget ; <NEW_LINE> }
EdiRec * rec ; <NEW_LINE> cchar * key ; <NEW_LINE> <START_VULN> key = mprLookupJson ( params , "id" ) ; <NEW_LINE> <END_VULN> if ( ( rec = ediSetFields ( ediReadRec ( getDatabase ( ) , tableName , key ) , params ) ) == 0 ) { <NEW_LINE> return 0 ; <NEW_LINE> }
sslSessionID * sid = ss -> sec . ci . sid ; <NEW_LINE> if ( sid -> peerCert == NULL ) { <NEW_LINE> PORT_Memcpy ( sid -> u . ssl2 . sessionID , s , sizeof ( sid -> u . ssl2 . sessionID ) ) ; <NEW_LINE> sid -> peerCert = CERT_DupCertificate ( ss -> sec . peerCert ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! ss -> opt . noCache ) <NEW_LINE> <END_VULN> ( * ss -> sec . cache ) ( sid ) ; <NEW_LINE> } <NEW_LINE> static SECStatus <NEW_LINE> ssl2_TriggerNextMessage ( sslSocket * ss ) <NEW_LINE> { <NEW_LINE> SECStatus rv ;
if ( auditorDelegate ) <NEW_LINE> auditorDelegate -> setReportURL ( xssProtectionReportURL . copy ( ) ) ; <NEW_LINE> <START_VULN> FormData * httpBody = documentLoader -> originalRequest ( ) . httpBody ( ) ; <NEW_LINE> <END_VULN> if ( httpBody && ! httpBody -> isEmpty ( ) ) { <NEW_LINE> httpBodyAsString = httpBody -> flattenToString ( ) ; <NEW_LINE> if ( ! httpBodyAsString . isEmpty ( ) ) {
{ <NEW_LINE> struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <NEW_LINE> <START_VULN> return alg -> cra_rng . rng_make_random ? <NEW_LINE>alg -> cra_rng . seedsize : ralg -> seedsize ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef CONFIG_NET
if ( iris_info . pixel_format != 0 ) <NEW_LINE> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <NEW_LINE> count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; <NEW_LINE> <START_VULN> ( void ) count ; <NEW_LINE> <END_VULN> image -> columns = iris_info . columns ; <NEW_LINE> image -> rows = iris_info . rows ; <NEW_LINE> image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ;
new_images = RemoveFirstImageFromList ( & _images ) ; <NEW_LINE> source_image = RemoveFirstImageFromList ( & _images ) ; <NEW_LINE> if ( source_image == ( Image * ) NULL ) <NEW_LINE> <START_VULN> break ; <NEW_LINE> <END_VULN> if ( source_image -> geometry != ( char * ) NULL )
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSFloat64Array::s_info ) ; <NEW_LINE> Float64Array * impl = static_cast < Float64Array * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> Float32Array * array ( toFloat32Array ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
content::WebContents * web_contents , <NEW_LINE> PaymentRequestDialogView::ObserverForTest * observer , <NEW_LINE> bool is_incognito , <NEW_LINE> <START_VULN> bool is_valid_ssl ) ; <NEW_LINE> <END_VULN> void SetRegionDataLoader ( autofill::RegionDataLoader * region_data_loader ) { <NEW_LINE> region_data_loader_ = region_data_loader ;
LayoutPoint topLeft = rect . location ( ) ; <NEW_LINE> <START_VULN> if ( o -> isBlockFlow ( ) && ! style ( ) -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> RenderBlock * cb = toRenderBlock ( o ) ; <NEW_LINE> if ( cb -> hasColumns ( ) ) { <NEW_LINE> LayoutRect repaintRect ( topLeft , rect . size ( ) ) ;
public: <NEW_LINE> bool Equals ( const nsSMILInstanceTime * aElem1 , <NEW_LINE> const nsSMILInstanceTime * aElem2 ) const ; <NEW_LINE> bool LessThan ( const nsSMILInstanceTime * aElem1 , <NEW_LINE> const nsSMILInstanceTime * aElem2 ) const ; <NEW_LINE> } ; <NEW_LINE> struct NotifyTimeDependentsParams { <NEW_LINE> <START_VULN> nsSMILInterval * mCurrentInterval ; <NEW_LINE> <END_VULN> nsSMILTimeContainer * mTimeContainer ; <NEW_LINE> } ; <NEW_LINE> template < class TestFunctor > <NEW_LINE> void RemoveInstanceTimes ( InstanceTimeList & aArray , TestFunctor & aTest ) ;
if ( stream -> index == 0 ) { <NEW_LINE> fprintf ( stderr , "Codec: % s\n" , <NEW_LINE> <START_VULN> vpx_codec_iface_name ( global -> codec -> interface ( ) ) ) ; <NEW_LINE>fprintf ( stderr , "Source file: % s Format: % s\n" , input -> filename , <NEW_LINE>input -> use_i420 ? "I420" : "YV12" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( stream -> next || stream -> index ) <NEW_LINE> fprintf ( stderr , "\nStream Index: % d\n" , stream -> index ) ;
if ( attr ) <NEW_LINE> { <NEW_LINE> <START_VULN> _cupsStrFree ( attr -> values [ 0 ] . string . text ) ; <NEW_LINE><NEW_LINE>attr -> value_tag = IPP_TAG_KEYWORD ; <NEW_LINE>attr -> values [ 0 ] . string . text = _cupsStrAlloc ( "no - hold" ) ; <NEW_LINE> <END_VULN> cupsdAddEvent ( CUPSD_EVENT_JOB_CONFIG_CHANGED , cupsdFindDest ( job -> dest ) , job , <NEW_LINE> "Job job - hold - until value changed by user . " ) ;
if ( status == MagickFalse ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> Ar = GetCacheViewVirtualPixels ( Ar_view , 0 , y , Ar_image -> columns , 1 , exception ) ; <NEW_LINE>Ai = GetCacheViewVirtualPixels ( Ai_view , 0 , y , Ai_image -> columns , 1 , exception ) ; <NEW_LINE>Br = GetCacheViewVirtualPixels ( Br_view , 0 , y , Br_image -> columns , 1 , exception ) ; <NEW_LINE>Bi = GetCacheViewVirtualPixels ( Bi_view , 0 , y , Bi_image -> columns , 1 , exception ) ; <NEW_LINE> <END_VULN> Cr = QueueCacheViewAuthenticPixels ( Cr_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE> Ci = QueueCacheViewAuthenticPixels ( Ci_view , 0 , y , Ci_image -> columns , 1 , exception ) ; <NEW_LINE> if ( ( Ar == ( const PixelPacket * ) NULL ) ||
js_DestroyScriptsToGC ( JSContext * cx , JSThreadData * data ) <NEW_LINE> { <NEW_LINE> JSScript ** listp , * script ; <NEW_LINE> for ( size_t i = 0 ; i != JS_ARRAY_LENGTH ( data -> scriptsToGC ) ; ++ i ) { <NEW_LINE> listp = & data -> scriptsToGC [ i ] ; <NEW_LINE> while ( ( script = * listp ) != NULL ) { <NEW_LINE> * listp = script -> u . nextToGC ; <NEW_LINE> script -> u . nextToGC = NULL ; <NEW_LINE> <START_VULN> js_DestroyScript ( cx , script ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> intN <NEW_LINE> js_ChangeExternalStringFinalizer ( JSStringFinalizeOp oldop , <NEW_LINE> JSStringFinalizeOp newop ) <NEW_LINE> { <NEW_LINE> for ( uintN i = 0 ; i != JS_ARRAY_LENGTH ( str_finalizers ) ; i ++ ) {
#include "decodemv . h" <NEW_LINE> #include "vpx_mem / vpx_mem . h" <NEW_LINE> #include "vp8 / common / findnearmv . h" <NEW_LINE> <START_VULN> <NEW_LINE>#define MIN ( x , y ) ( ( ( x ) < ( y ) ) ? ( x ) : ( y ) ) <NEW_LINE>#define MAX ( x , y ) ( ( ( x ) > ( y ) ) ? ( x ) : ( y ) ) <NEW_LINE> <END_VULN> #define FLOOR ( x , q ) ( ( x ) & - ( 1 << ( q ) ) )
} <NEW_LINE> void DispatchDidBlockRequest ( const ResourceRequest & , <NEW_LINE> const FetchInitiatorInfo & , <NEW_LINE> <START_VULN> ResourceRequestBlockedReason ) const override { } <NEW_LINE> <END_VULN> bool ShouldBypassMainWorldCSP ( ) const override { return false ; } <NEW_LINE> bool IsSVGImageChromeClient ( ) const override { return false ; } <NEW_LINE> void CountUsage ( WebFeature ) const override { }
virtual ~ AutoFillMetrics ( ) ; <NEW_LINE> virtual void Log ( ServerQueryMetric metric ) const ; <NEW_LINE> <START_VULN> virtual void Log ( QualityMetric metric ) const ; <NEW_LINE> <END_VULN> private: <NEW_LINE> DISALLOW_COPY_AND_ASSIGN ( AutoFillMetrics ) ;
} <NEW_LINE> char * uwsgi_expand_path ( char * dir , int dir_len , char * ptr ) { <NEW_LINE> <START_VULN> char src [ PATH_MAX + 1 ] ; <NEW_LINE>memcpy ( src , dir , dir_len ) ; <NEW_LINE>src [ dir_len ] = 0 ; <NEW_LINE> <END_VULN> char * dst = ptr ; <NEW_LINE> if ( ! dst ) <NEW_LINE> dst = uwsgi_malloc ( PATH_MAX + 1 ) ;
namespace sandbox { <NEW_LINE> class SANDBOX_EXPORT Credentials { <NEW_LINE> public: <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>enum class Capability { <NEW_LINE>SYS_CHROOT , <NEW_LINE>SYS_ADMIN , <NEW_LINE> } ; <NEW_LINE> <END_VULN>
{ <NEW_LINE> struct crypto_report_rng rrng ; <NEW_LINE> <START_VULN> snprintf ( rrng . type , CRYPTO_MAX_ALG_NAME , " % s" , "rng" ) ; <NEW_LINE> <END_VULN> rrng . seedsize = alg -> cra_rng . seedsize ;
if ( threshold < x -> encode_breakout ) <NEW_LINE> threshold = x -> encode_breakout ; <NEW_LINE> <START_VULN> var = vp8_variance16x16 <NEW_LINE> <END_VULN> ( * ( b -> base_src ) , b -> src_stride , <NEW_LINE> x -> e_mbd . predictor , 16 , & sse ) ;
<START_VULN> else if ( Ustrcmp ( argrest , "Mr" ) == 0 ) received_protocol = argv [ ++ i ] ; <NEW_LINE> <END_VULN>
std::cout << "FAILED:" ; <NEW_LINE> else <NEW_LINE> std::cout << "passed:" ; <NEW_LINE> <START_VULN> std::cout << " GenerateWord32 and Crop\n" ; <NEW_LINE> <END_VULN> } <NEW_LINE> #if ! defined ( NO_OS_DEPENDENCE )
entity_table_opt retval = { NULL } ; <NEW_LINE> assert ( ! ( doctype == ENT_HTML_DOC_XML1 && all ) ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( all ) { <NEW_LINE> retval . ms_table = ( doctype == ENT_HTML_DOC_HTML5 ) ? <NEW_LINE> entity_ms_table_html5 : entity_ms_table_html4 ;
namespace blink { <NEW_LINE> <START_VULN> class CSSPaintValue : public CSSImageGeneratorValue { <NEW_LINE> <END_VULN> public: <NEW_LINE> static CSSPaintValue * Create ( CSSCustomIdentValue * name ) { <NEW_LINE> return new CSSPaintValue ( name ) ;
ASSERT ( ! ( reinterpret_cast < uintptr_t > ( result ) & allocationMask ) ) ; <NEW_LINE> LargeObjectPage * largeObject = new ( largeObjectAddress ) <NEW_LINE> LargeObjectPage ( pageMemory , this , allocationSize ) ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> ASAN_POISON_MEMORY_REGION ( header , sizeof ( * header ) ) ;
if ( IsAnimValList ( ) ) { <NEW_LINE> Element ( ) -> FlushAnimations ( ) ; <NEW_LINE> } <NEW_LINE> return LengthNoFlush ( ) ; <NEW_LINE> } <NEW_LINE> void Clear ( ErrorResult & aError ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGLength > Initialize ( nsIDOMSVGLength * newItem , <NEW_LINE> ErrorResult & error ) ; <NEW_LINE> <START_VULN> nsIDOMSVGLength * GetItem ( uint32_t index , ErrorResult & error ) <NEW_LINE> { <NEW_LINE>bool found ; <NEW_LINE>nsIDOMSVGLength * item = IndexedGetter ( index , found , error ) ; <NEW_LINE>if ( ! found ) { <NEW_LINE>error . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; <NEW_LINE> } <NEW_LINE>return item ; <NEW_LINE> } <NEW_LINE>nsIDOMSVGLength * IndexedGetter ( uint32_t index , bool & found , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE> <END_VULN> already_AddRefed < nsIDOMSVGLength > InsertItemBefore ( nsIDOMSVGLength * newItem , <NEW_LINE> uint32_t index , <NEW_LINE> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGLength > ReplaceItem ( nsIDOMSVGLength * newItem , <NEW_LINE> uint32_t index , <NEW_LINE> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < nsIDOMSVGLength > RemoveItem ( uint32_t index , <NEW_LINE> ErrorResult & error ) ;
"We should never be trying to match mRootNode" ) ; <NEW_LINE> if ( Match ( aContent ) ) { <NEW_LINE> <START_VULN> mElements . AppendElement ( aContent ) ; <NEW_LINE> <END_VULN> -- aElementsToAppend ; <NEW_LINE> if ( aElementsToAppend == 0 ) <NEW_LINE> return ;
std::min < int64_t > ( m_mutedVideoAutoplayOffscreenDurationMS , <NEW_LINE> std::numeric_limits < int32_t > ::max ( ) ) ) ; <NEW_LINE> <START_VULN> if ( m_source == AutoplaySource::Method ) { <NEW_LINE>DEFINE_STATIC_LOCAL ( <NEW_LINE>CustomCountHistogram , durationHistogram , <NEW_LINE> ( "Media . Video . Autoplay . Muted . PlayMethod . OffscreenDuration" , 1 , <NEW_LINE>maxOffscreenDurationUmaMS , offscreenDurationUmaBucketCount ) ) ; <NEW_LINE>durationHistogram . count ( boundedTime ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> m_mutedVideoOffscreenDurationVisibilityObserver -> stop ( ) ; <NEW_LINE> m_mutedVideoOffscreenDurationVisibilityObserver = nullptr ; <NEW_LINE> m_mutedVideoAutoplayOffscreenDurationMS = 0 ;
ProxyJNIEnv & proxyEnv = GetProxyEnv ( env ) ; <NEW_LINE> nsISecureEnv * secureEnv = GetSecureEnv ( env ) ; <NEW_LINE> nsISecurityContext * securityContext = proxyEnv . getContext ( ) ; <NEW_LINE> <START_VULN> nsresult result ; <NEW_LINE>result = secureEnv -> SetStaticField ( field -> mFieldType , clazz , field -> mFieldID , value , securityContext ) ; <NEW_LINE> <END_VULN> NS_IF_RELEASE ( securityContext ) ; <NEW_LINE> }
if ( out == NULL ) { <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> gdImageWebpCtx ( im , out , - 1 ) ; <NEW_LINE>rv = gdDPExtractData ( out , size ) ; <NEW_LINE> <END_VULN> out -> gd_free ( out ) ; <NEW_LINE> return rv ;
Z_TYPE_P ( return_value ) = IS_NULL ; <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( spl_filesystem_file_open ( intern , use_include_path , 0 TSRMLS_CC ) == FAILURE ) { <NEW_LINE> zend_restore_error_handling ( & error_handling TSRMLS_CC ) ; <NEW_LINE> zval_dtor ( return_value ) ;
} <NEW_LINE> <START_VULN> <NEW_LINE>if ( must_advance_counter ) { <NEW_LINE> <END_VULN> char counter_str [ 40 ] ; <NEW_LINE> sprintf ( counter_str , " % ld" , hotp_counter + 1 ) ; <NEW_LINE> if ( set_cfg_value ( pamh , "HOTP_COUNTER" , counter_str , & buf ) < 0 ) {
} <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> efree ( offsets ) ; <NEW_LINE> }
png_bytep data = png_ptr -> zbuffer_list -> output ; <NEW_LINE> uInt size = png_ptr -> zbuffer_size - png_ptr -> zstream . avail_out ; <NEW_LINE> <START_VULN> # ifdef PNG_WRITE_OPTIMIZE_CMF_SUPPORTED <NEW_LINE>if ( ! ( png_ptr -> mode & PNG_HAVE_IDAT ) && <NEW_LINE>png_ptr -> compression_type == PNG_COMPRESSION_TYPE_BASE ) <NEW_LINE>optimize_cmf ( data , png_image_size ( png_ptr ) ) ; <NEW_LINE># endif <NEW_LINE> <END_VULN> png_write_complete_chunk ( png_ptr , png_IDAT , data , size ) ; <NEW_LINE> png_ptr -> zstream . avail_out = 0 ;
DISALLOW_COPY_AND_ASSIGN ( FileEnumerator ) ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> class MemoryMappedFile { <NEW_LINE> <END_VULN> public: <NEW_LINE> MemoryMappedFile ( ) ;
SetContentSecurityPolicy ( <NEW_LINE> ImportsController ( ) -> Master ( ) -> GetContentSecurityPolicy ( ) ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> InitContentSecurityPolicy ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( GetSecurityOrigin ( ) -> HasSuborigin ( ) )
#include "vp8 / common / onyxc_int . h" <NEW_LINE> #include "onyx_int . h" <NEW_LINE> #include "vp8 / common / systemdependent . h" <NEW_LINE> <START_VULN> #include "quantize . h" <NEW_LINE> <END_VULN> #include "vp8 / common / alloccommon . h" <NEW_LINE> #include "mcomp . h" <NEW_LINE> #include "firstpass . h"
PRBool useXULCache = nsXULPrototypeCache::GetInstance ( ) -> IsEnabled ( ) ; <NEW_LINE> <START_VULN> if ( useXULCache ) { <NEW_LINE> <END_VULN> PRUint32 fetchedLang = nsIProgrammingLanguage::UNKNOWN ; <NEW_LINE> void * newScriptObject = <NEW_LINE> nsXULPrototypeCache::GetInstance ( ) -> GetScript (
if ( exception -> severity != UndefinedException ) goto FINISH_UNL ; <NEW_LINE> if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ; <NEW_LINE> <START_VULN> ( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <NEW_LINE> <END_VULN>
const std::vector < SkISize > supported_sizes_ ; <NEW_LINE> <START_VULN> Mutex generator_mutex_ ; <NEW_LINE> <END_VULN> bool decode_failed_ = false ; <NEW_LINE> bool yuv_decoding_failed_ = false ;
<START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Reverb_command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_INIT: ERROR" ) ; <NEW_LINE> return - EINVAL ;
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "cert . h" <NEW_LINE> #include "secitem . h" <NEW_LINE> #include "keyhi . h" <NEW_LINE> #include "ssl . h" <NEW_LINE> #include "sslimpl . h" <NEW_LINE> #include "sslproto . h" <NEW_LINE> #include "secoid . h" <NEW_LINE> #include "pk11func . h"
for ( i = 0 ; i < row_width ; i ++ ) <NEW_LINE> { <NEW_LINE> png_uint_16 red , green , blue , w ; <NEW_LINE> <START_VULN> <NEW_LINE>red = ( png_uint_16 ) ( ( ( * ( sp ) ) << 8 ) | * ( sp + 1 ) ) ; sp += 2 ; <NEW_LINE>green = ( png_uint_16 ) ( ( ( * ( sp ) ) << 8 ) | * ( sp + 1 ) ) ; sp += 2 ; <NEW_LINE>blue = ( png_uint_16 ) ( ( ( * ( sp ) ) << 8 ) | * ( sp + 1 ) ) ; sp += 2 ; <NEW_LINE> <END_VULN> if ( red == green && red == blue ) <NEW_LINE> w = red ;
ProxyJNIEnv:: ~ ProxyJNIEnv ( ) <NEW_LINE> { <NEW_LINE> this -> functions = NULL ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( mSecureEnv != NULL ) <NEW_LINE>mSecureEnv -> Release ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JNIEnv * CreateProxyJNI ( nsIJVMPlugin * jvmPlugin , nsISecureEnv * inSecureEnv )
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> void ptrace_triggered ( struct perf_event * bp , int nmi , <NEW_LINE> <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) <NEW_LINE> { <NEW_LINE> struct perf_event_attr attr ;
#endif <NEW_LINE> } <NEW_LINE> #ifdef DEBUG <NEW_LINE> bool <NEW_LINE> StackSpace::containsSlow ( StackFrame * fp ) <NEW_LINE> { <NEW_LINE> for ( AllFramesIter i ( * this ) ; ! i . done ( ) ; ++ i ) { <NEW_LINE> <START_VULN> if ( i . fp ( ) == fp ) <NEW_LINE> <END_VULN> return true ; <NEW_LINE> } <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> #endif
JSObject * tmp ; <NEW_LINE> JSFastNative native ; <NEW_LINE> if ( ! JS_GetReservedSlot ( cx , JSVAL_TO_OBJECT ( * vp ) , 0 , & fsv ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> fs = ( JSFunctionSpec * ) JSVAL_TO_PRIVATE ( fsv ) ; <NEW_LINE> JS_ASSERT ( ( ~ fs -> flags & ( JSFUN_FAST_NATIVE | JSFUN_GENERIC_NATIVE ) ) == 0 ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( JSVAL_IS_PRIMITIVE ( vp [ 2 ] ) ) { <NEW_LINE> if ( ! js_ValueToObject ( cx , vp [ 2 ] , & tmp ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> vp [ 2 ] = OBJECT_TO_JSVAL ( tmp ) ;
NS_NAMED_LITERAL_STRING ( active , "DOMMenuBarActive" ) ; <NEW_LINE> NS_NAMED_LITERAL_STRING ( inactive , "DOMMenuBarInactive" ) ; <NEW_LINE> <START_VULN> FireDOMEvent ( mPresContext , mIsActive ? active : inactive ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> unchanged:
{ <NEW_LINE> INC_STATS ( "DOM . TestEventTarget . dispatchEvent" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestEventTarget * imp = V8TestEventTarget::toNative ( args . Holder ( ) ) ; <NEW_LINE> ExceptionCode ec = 0 ; <NEW_LINE> {
__FUNCTION__ , p_dev -> attr_mask , p_dev -> sub_class , p_dev -> app_id ) ; <NEW_LINE> if ( p_dev -> fd < 0 ) { <NEW_LINE> <START_VULN> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <NEW_LINE> <END_VULN> if ( p_dev -> fd < 0 ) { <NEW_LINE> APPL_TRACE_ERROR ( " % s: Error: failed to open uhid , err: % s" , <NEW_LINE> __FUNCTION__ , strerror ( errno ) ) ;
public: <NEW_LINE> DistillerJavaScriptServiceImpl ( <NEW_LINE> content::RenderFrameHost * render_frame_host , <NEW_LINE> <START_VULN> ExternalFeedbackReporter * external_feedback_reporter , <NEW_LINE> <END_VULN> mojo::InterfaceRequest < DistillerJavaScriptService > request ) ; <NEW_LINE> ~ DistillerJavaScriptServiceImpl ( ) override ;
sub_str_end_pos = ustr_len ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( sub_str_start_pos > sub_str_end_pos ) { <NEW_LINE> intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "grapheme_substr: length is beyond start" , 1 TSRMLS_CC ) ;
if ( m_entries_count >= m_entries_size ) { <NEW_LINE> const long entries_size = 2 * m_entries_size ; <NEW_LINE> <START_VULN> BlockEntry ** const entries = new BlockEntry * [ entries_size ] ; <NEW_LINE>assert ( entries ) ; <NEW_LINE> <END_VULN> BlockEntry ** src = m_entries ; <NEW_LINE> BlockEntry ** const src_end = src + m_entries_count ;
curr_offset = offset ; <NEW_LINE> <START_VULN> memset ( str , 0 , MAX_APN_LENGTH ) ; <NEW_LINE> <END_VULN> tvb_memcpy ( tvb , str , offset , len < MAX_APN_LENGTH ? len:MAX_APN_LENGTH ) ; <NEW_LINE> curr_len = 0 ;
nsCOMPtr < EventTarget > target = aKeyEvent -> InternalDOMEvent ( ) -> GetCurrentTarget ( ) ; <NEW_LINE> bool executed = false ; <NEW_LINE> for ( uint32_t i = 0 ; i < mProtoHandlers . Length ( ) ; ++ i ) { <NEW_LINE> nsXBLPrototypeHandler * handler = mProtoHandlers [ i ] ; <NEW_LINE> bool hasAllowUntrustedAttr = handler -> HasAllowUntrustedAttr ( ) ; <NEW_LINE> if ( ( trustedEvent || <NEW_LINE> ( hasAllowUntrustedAttr && handler -> AllowUntrustedEvents ( ) ) || <NEW_LINE> <START_VULN> ( ! hasAllowUntrustedAttr && ! mIsBoundToChrome ) ) && <NEW_LINE> <END_VULN> handler -> KeyEventMatched ( aKeyEvent , aCharCode , aIgnoreShiftKey ) ) { <NEW_LINE> handler -> ExecuteHandler ( target , aKeyEvent ) ; <NEW_LINE> executed = true ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return executed ; <NEW_LINE> }
"http: <NEW_LINE> "www . google . com" , 0 , "" , 0 , " / foo / blah" , "blah" , "bar = baz" , <NEW_LINE> <START_VULN> "\xce\xb1\xce\xb2" , true } , <NEW_LINE> <END_VULN> { "http: <NEW_LINE> " / foo / bar / " , "bar" , 0 , 0 , false } , <NEW_LINE> { "http:
<START_VULN> if ( ! ArrayBufferObject::neuterViews ( cx , buffer ) ) <NEW_LINE> <END_VULN> return false ;
const std::string & device_node ) override ; <NEW_LINE> void CreateFusionSensor ( mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> const CreateSensorCallback & callback ) ;
virtual ToolbarView * GetToolbarView ( ) const OVERRIDE ; <NEW_LINE> <START_VULN> virtual void TabDetachedAt ( TabContents * contents , int index ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual void TabDeactivated ( TabContents * contents ) OVERRIDE ; <NEW_LINE> virtual void ActiveTabChanged ( TabContents * old_contents , <NEW_LINE> TabContents * new_contents ,
char ptr ; <NEW_LINE> extern void * STACK_BASE ; <NEW_LINE> uint32_t count = ( uint32_t ) ( ( size_t ) STACK_BASE - ( size_t ) & ptr ) ; <NEW_LINE> <START_VULN> return 1000000 - count ; <NEW_LINE> <END_VULN> #else <NEW_LINE> return 1000000 ;
printf ( "get_results\n % s\n" , cJSON_Print ( j ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuefloat ; <NEW_LINE>test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuefloat ; <NEW_LINE>test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuefloat ; <NEW_LINE> <END_VULN> result_has_retransmits = j_sender_has_retransmits -> valueint ; <NEW_LINE> if ( ! test -> sender ) <NEW_LINE> test -> sender_has_retransmits = result_has_retransmits ;
nsJSContext::TerminationFuncHolder holder ( this ) ; <NEW_LINE> if ( ok && ( ( JSVersion ) aVersion ) != JSVERSION_UNKNOWN ) { <NEW_LINE> <START_VULN> JSAutoRequest ar ( mContext ) ; <NEW_LINE> <END_VULN> JSAutoEnterCompartment ac ; <NEW_LINE> if ( ! ac . enter ( mContext , aScopeObject ) ) { <NEW_LINE> stack -> Pop ( nsnull ) ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> ++ mExecuteDepth ;
EncodedJSValue JSC_HOST_CALL JSWebKitMutationObserverConstructor::constructJSWebKitMutationObserver ( ExecState * exec ) <NEW_LINE> { <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> JSObject * object = exec -> argument ( 0 ) . getObject ( ) ; <NEW_LINE> if ( ! object ) {
} ; <NEW_LINE> static const uint32_t EUCTWCharLenTable [ ] = { 0 , 0 , 1 , 2 , 2 , 2 , 3 } ; <NEW_LINE> const SMModel EUCTWSMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , EUCTW_cls } , <NEW_LINE> 7 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , EUCTW_st } , <NEW_LINE> <START_VULN> EUCTWCharLenTable , <NEW_LINE> <END_VULN> "x - euc - tw" , <NEW_LINE> } ; <NEW_LINE> static const uint32_t GB18030_cls [ 256 / 8 ] = { <NEW_LINE> PCK4BITS ( 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ) ,
void ToggleBookmarkBarWhenVisible ( content::BrowserContext * browser_context ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> base::string16 FormatBookmarkURLForDisplay ( const GURL & url ) ;
) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsUTF16LEToUnicode::Convert ( const char * aSrc , PRInt32 * aSrcLength , <NEW_LINE> PRUnichar * aDest , PRInt32 * aDestLength ) <NEW_LINE> { <NEW_LINE> #ifdef IS_BIG_ENDIAN <NEW_LINE> if ( STATE_FIRST_CALL == mState ) <NEW_LINE> { <NEW_LINE> mState = STATE_NORMAL ; <NEW_LINE> <START_VULN> if ( * aSrcLength < 2 ) <NEW_LINE>return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> <END_VULN> if ( 0xFFFE == * ( ( PRUnichar * ) aSrc ) ) { <NEW_LINE> mState = STATE_FOUND_BOM ; <NEW_LINE> } else if ( 0xFEFF == * ( ( PRUnichar * ) aSrc ) ) { <NEW_LINE> * aSrcLength = 0 ; <NEW_LINE> * aDestLength = 0 ; <NEW_LINE> return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> }
break ; <NEW_LINE> case 5: <NEW_LINE> <START_VULN> if ( ( png_ptr -> row_number & 0x01 ) || png_ptr -> width < 2 ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_write_finish_row ( png_ptr ) ; <NEW_LINE> return ;
static void AcknowledgeBufferPresent ( <NEW_LINE> int32 route_id , <NEW_LINE> int gpu_host_id , <NEW_LINE> <START_VULN> bool presented , <NEW_LINE> <END_VULN> uint32 sync_point ) ;
ThrowReaderException ( CoderError , "ImageIsNotTiled" ) ; <NEW_LINE> } <NEW_LINE> ( void ) SetImageStorageClass ( image , DirectClass ) ; <NEW_LINE> <START_VULN> number_pixels = columns * rows ; <NEW_LINE> <END_VULN> tile_pixels = ( uint32 * ) AcquireQuantumMemory ( number_pixels , <NEW_LINE> sizeof ( * tile_pixels ) ) ; <NEW_LINE> if ( tile_pixels == ( uint32 * ) NULL )
<START_VULN> if ( transforms & PNG_TRANSFORM_INVERT_ALPHA ) <NEW_LINE> <END_VULN> #ifdef PNG_READ_INVERT_ALPHA_SUPPORTED <NEW_LINE> png_set_invert_alpha ( png_ptr ) ; <NEW_LINE> #else
return - ENOSYS ; <NEW_LINE> if ( arg != CDSL_CURRENT && arg != CDSL_NONE ) { <NEW_LINE> <START_VULN> if ( ( int ) arg >= cdi -> capacity ) <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> }
{ { - 512 , - 512 } , { 0 , - 1024 } , { 512 , - 512 } , { 1024 , 0 } , { 512 , 512 } , { 0 , 1024 } , <NEW_LINE> { - 512 , 512 } , { - 1024 , 0 } } , <NEW_LINE> } ; <NEW_LINE> <START_VULN> return vp9_pattern_search ( x , ref_mv , search_param , sad_per_bit , <NEW_LINE>do_init_search , 0 , vfp , use_mvcost , <NEW_LINE>center_mv , best_mv , <NEW_LINE>bigdia_num_candidates , bigdia_candidates ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> int vp9_square_search ( const MACROBLOCK * x ,
return ret ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int dev_get_valid_name ( struct net * net , <NEW_LINE>struct net_device * dev , <NEW_LINE>const char * name ) <NEW_LINE> <END_VULN> { <NEW_LINE> BUG_ON ( ! net ) ;
fread ( frame_codestream , sample -> sample_size - 8 , 1 , <NEW_LINE> file ) ; <NEW_LINE> <START_VULN> sprintf ( outfilename , " % s_ % 05d . j2k" , argv [ 2 ] , snum ) ; <NEW_LINE> <END_VULN> outfile = fopen ( outfilename , "wb" ) ; <NEW_LINE> if ( ! outfile ) { <NEW_LINE> fprintf ( stderr , "failed to open % s for writing\n" , outfilename ) ;
void SetUseSecureKeyboardEntryWhenActive ( bool ) ; <NEW_LINE> <START_VULN> bool IsHandleVisible ( ) const ; <NEW_LINE> <END_VULN> void UpdateSecureKeyboardEntryIfActive ( ) ;
InitClass ( JSContext * aCx , JSObject * aObj ) <NEW_LINE> { <NEW_LINE> JSObject * proto = JS_InitClass ( aCx , aObj , NULL , & sClass , Construct , 0 , <NEW_LINE> <START_VULN> sProperties , sFunctions , sStaticProperties , <NEW_LINE>NULL ) ; <NEW_LINE>if ( proto && ! JS_DefineProperties ( aCx , proto , sStaticProperties ) ) { <NEW_LINE> <END_VULN> return NULL ; <NEW_LINE> }
"WebAssembly" , "compile" ) ; <NEW_LINE> ExceptionToRejectPromiseScope reject_promise_scope ( args , exception_state ) ; <NEW_LINE> <START_VULN> ScriptState * script_state = ScriptState::ForRelevantRealm ( args ) ; <NEW_LINE> <END_VULN> if ( ! ExecutionContext::From ( script_state ) ) { <NEW_LINE> V8SetReturnValue ( args , ScriptPromise ( ) . V8Value ( ) ) ; <NEW_LINE> return ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: PCM data envelope analysis and manipulation <NEW_LINE> <START_VULN> last mod: $ Id: envelope . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_ENVELOPE_ <NEW_LINE> #define _V_ENVELOPE_ <NEW_LINE> #include "mdct . h"
GPMF_KEY_UNITS = MAKEID ( 'U' , 'N' , 'I' , 'T' ) , <NEW_LINE> GPMF_KEY_SCALE = MAKEID ( 'S' , 'C' , 'A' , 'L' ) , <NEW_LINE> GPMF_KEY_TYPE = MAKEID ( 'T' , 'Y' , 'P' , 'E' ) , <NEW_LINE> <START_VULN> GPMF_KEY_TOTAL_SAMPLES = MAKEID ( 'T' , 'S' , 'M' , 'P' ) , <NEW_LINE> <END_VULN> GPMF_KEY_TICK = MAKEID ( 'T' , 'I' , 'C' , 'K' ) , <NEW_LINE> GPMF_KEY_TOCK = MAKEID ( 'T' , 'O' , 'C' , 'K' ) , <NEW_LINE> GPMF_KEY_EMPTY_PAYLOADS = MAKEID ( 'E' , 'M' , 'P' , 'T' ) ,
virtual ~ InputMethod ( ) { } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> virtual void SetDelegate ( internal::InputMethodDelegate * delegate ) = 0 ;
{ <NEW_LINE> NS_ABORT_IF_FALSE ( ! IsAnimValList ( ) , "call from baseVal to animVal" ) ; <NEW_LINE> if ( AttrIsAnimating ( ) ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> DOMSVGPointList * animVal = <NEW_LINE> <END_VULN> GetDOMWrapperIfExists ( InternalAList ( ) . GetAnimValKey ( ) ) ; <NEW_LINE> if ( ! animVal ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> NS_ABORT_IF_FALSE ( animVal -> mItems . Length ( ) == mItems . Length ( ) , <NEW_LINE> "animVal list not in sync ! " ) ;
int asi = decode_asi ( insn , regs ) ; <NEW_LINE> int flag = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <NEW_LINE> <END_VULN> save_and_clear_fpu ( ) ; <NEW_LINE> current_thread_info ( ) -> xfsr [ 0 ] &= ~ 0x1c000 ;
less strict that the <NEW_LINE> _ve_envelope_search , <NEW_LINE> the search is not run <NEW_LINE> if we only use one <NEW_LINE> block size * / <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> _vorbis_block_ripcord ( vb ) ; <NEW_LINE> vb -> lW = v -> lW ; <NEW_LINE> vb -> W = v -> W ; <NEW_LINE> vb -> nW = v -> nW ;
if ( node -> hasTagName ( ulTag ) || node -> hasTagName ( olTag ) || node -> hasTagName ( iframeTag ) ) <NEW_LINE> return true ; <NEW_LINE> <START_VULN> if ( renderer -> isPositioned ( ) ) <NEW_LINE> <END_VULN> return true ; <NEW_LINE> if ( renderer -> isRenderBlock ( ) && ! renderer -> isTableCell ( ) ) {
#endif <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE>#if defined ( _WIN32 ) && defined ( __CYGWIN__ ) <NEW_LINE> <END_VULN> #undef XSLTPUBFUN <NEW_LINE> #undef XSLTPUBVAR <NEW_LINE> #undef XSLTCALL
ifr . ifr_flags |= IFF_UP ; <NEW_LINE> ifr . ifr_flags |= IFF_MULTICAST ; <NEW_LINE> <START_VULN> err = ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <NEW_LINE> <END_VULN> if ( err < 0 ) {
ThrowImageException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> pixels_info = AcquireVirtualMemory ( 3 * image -> columns , image -> rows * <NEW_LINE> sizeof ( * pixels ) ) ; <NEW_LINE> <START_VULN> kernel = ( float * ) AcquireQuantumMemory ( MagickMax ( image -> rows , image -> columns ) , <NEW_LINE> <END_VULN> GetOpenMPMaximumThreads ( ) * sizeof ( * kernel ) ) ; <NEW_LINE> if ( ( pixels_info == ( MemoryInfo * ) NULL ) || ( kernel == ( float * ) NULL ) ) <NEW_LINE> {
break ; <NEW_LINE> } <NEW_LINE> printstr ( & pp , " < h3 > Please be careful editing config file remotely < / h3 > " ) ; <NEW_LINE> <START_VULN> printstr ( & pp , " < form method = \"POST\" action = \" / U\" > < textarea cols = \"80\" rows = \"30\" name = \"conffile\" > " ) ; <NEW_LINE> <END_VULN> while ( fgets ( buf , 256 , fp ) ) { <NEW_LINE> printstr ( & pp , buf ) ; <NEW_LINE> }
if ( xdr -> mode == JSXDR_DECODE ) { <NEW_LINE> if ( idx != uint32 ( - 1 ) ) { <NEW_LINE> <START_VULN> JS_ASSERT ( size_t ( idx ) < xdr -> atoms -> length ( ) ) ; <NEW_LINE> * atomp = ( * xdr -> atoms ) [ idx ] ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> uint32 len ; <NEW_LINE> if ( ! JS_XDRUint32 ( xdr , & len ) )
criteria = "x" ; <NEW_LINE> } <NEW_LINE> if ( schr ( name , '#' ) ) { <NEW_LINE> <START_VULN> name = stok ( sclone ( name ) , "#" , ( char ** ) & criteria ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> files = mprGetPathFiles ( mprJoinPath ( app -> paksCacheDir , name ) , MPR_PATH_RELATIVE ) ; <NEW_LINE> mprSortList ( files , ( MprSortProc ) reverseSortFiles , 0 ) ;
int subtype , hexdump = FALSE ; <NEW_LINE> u_int sublen ; <NEW_LINE> u_int tval ; <NEW_LINE> <START_VULN> uint8_t i ; <NEW_LINE> <END_VULN> if ( tlv_len < 4 ) { <NEW_LINE> return hexdump ;
private: <NEW_LINE> friend class base::RefCountedThreadSafe < PlatformSensor > ; <NEW_LINE> <START_VULN> const mojo::ScopedSharedBufferMapping shared_buffer_mapping_ ; <NEW_LINE> <END_VULN> std::unique_ptr < SensorReadingSharedBufferReader > shared_buffer_reader_ ; <NEW_LINE> mojom::SensorType type_ ; <NEW_LINE> ConfigMap config_map_ ;
mItems . Elements ( ) , & mNumItems ) ) == E_OUTOFMEMORY ) { <NEW_LINE> maxItems *= 2 ; <NEW_LINE> if ( ! mItems . SetLength ( maxItems + 1 ) ) { <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> Init ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ESTIMATE_MAX_GLYPHS ( mLength ) > 65535 ) { <NEW_LINE> <END_VULN> nsTArray < SCRIPT_ITEM > items ; <NEW_LINE> for ( int i = 0 ; i < mNumItems ; i ++ ) { <NEW_LINE> nsresult nrs = CopyItemSplitOversize ( i , items ) ; <NEW_LINE> NS_ASSERTION ( NS_SUCCEEDED ( nrs ) , "CopyItemSplitOversize ( ) failed" ) ;
#include < windows . h > <NEW_LINE> #elif defined ( ANGLE_OS_POSIX ) <NEW_LINE> #include < pthread . h > <NEW_LINE> #include < semaphore . h > <NEW_LINE> #include < errno . h > <NEW_LINE> #endif <NEW_LINE> <START_VULN> #include "compiler / debug . h" <NEW_LINE> <END_VULN> #if defined ( ANGLE_USE_NSPR ) <NEW_LINE> typedef PRUintn OS_TLSIndex ; <NEW_LINE> #define OS_INVALID_TLS_INDEX 0xFFFFFFFF <NEW_LINE> #elif defined ( ANGLE_OS_WIN )
img -> img_data = img_data ; <NEW_LINE> if ( ! img_data ) { <NEW_LINE> <START_VULN> const uint64_t alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) <NEW_LINE> ? ( uint64_t ) h * s * bps / 8 <NEW_LINE>: ( uint64_t ) h * s ; <NEW_LINE> <END_VULN> if ( alloc_size != ( size_t ) alloc_size ) goto fail ;
static void <NEW_LINE> cpStripToTile ( uint8 * out , uint8 * in , <NEW_LINE> <START_VULN> uint32 rows , uint32 cols , int outskew , int inskew ) <NEW_LINE> <END_VULN> { <NEW_LINE> while ( rows -- > 0 ) { <NEW_LINE> uint32 j = cols ;
for ( i = 1 ; i < L ; i ++ ) <NEW_LINE> <START_VULN> NLSF_Q15 [ i ] = silk_max_int ( NLSF_Q15 [ i ] , NLSF_Q15 [ i - 1 ] + NDeltaMin_Q15 [ i ] ) ; <NEW_LINE> <END_VULN> NLSF_Q15 [ L - 1 ] = silk_min_int ( NLSF_Q15 [ L - 1 ] , ( 1 << 15 ) - NDeltaMin_Q15 [ L ] ) ;
if ( node && <NEW_LINE> nsContentUtils::ContentIsDescendantOf ( node , adoptedNode ) ) { <NEW_LINE> return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } while ( ( doc = doc -> GetParentDocument ( ) ) ) ; <NEW_LINE> <START_VULN> nsINode * parent = adoptedNode -> GetNodeParent ( ) ; <NEW_LINE> <END_VULN> if ( parent ) { <NEW_LINE> rv = parent -> RemoveChildAt ( parent -> IndexOf ( adoptedNode ) , PR_TRUE ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> } <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> case nsIDOMNode::ENTITY_REFERENCE_NODE:
getter_Copies ( columnText ) ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> AppendNonAsciiToNCR ( columnText , buffer ) ; <NEW_LINE> buffer . AppendLiteral ( " < / th > \n" <NEW_LINE> " < / tr > \n" <NEW_LINE> " < / thead > \n" ) ; <NEW_LINE> buffer . AppendLiteral ( " < tbody > \n" ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>rv = mListener -> OnStartRequest ( request , aContext ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>request -> GetStatus ( & rv ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE><NEW_LINE>rv = FormatInputStream ( request , aContext , buffer ) ; <NEW_LINE> <END_VULN> return rv ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsIndexedToHTML::OnStopRequest ( nsIRequest * request , nsISupports * aContext , <NEW_LINE> nsresult aStatus ) { <NEW_LINE> if ( NS_SUCCEEDED ( aStatus ) ) { <NEW_LINE> nsString buffer ;
static std::vector < TargetHandler * > ForAgentHost ( DevToolsAgentHostImpl * host ) ; <NEW_LINE> void Wire ( UberDispatcher * dispatcher ) override ; <NEW_LINE> <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) override ; <NEW_LINE> Response Disable ( ) override ;
size = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( SIZE_MAX - chunk_size <= size ) { <NEW_LINE> <END_VULN> return ERROR_MALFORMED ; <NEW_LINE> }
png_charp scal_width , scal_height ; <NEW_LINE> if ( png_get_sCAL_s ( read_ptr , read_info_ptr , & unit , & scal_width , <NEW_LINE> <START_VULN> & scal_height ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_set_sCAL_s ( write_ptr , write_info_ptr , unit , scal_width , <NEW_LINE> scal_height ) ;
impeg2d_bit_stream_flush_to_byte_boundary ( ps_stream ) ; <NEW_LINE> while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <NEW_LINE> <START_VULN> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> impeg2d_bit_stream_get ( ps_stream , 8 ) ; <NEW_LINE> }
} <NEW_LINE> <START_VULN> jsval listenerVal = OBJECT_TO_JSVAL ( listeners [ index ] ) ; <NEW_LINE> <END_VULN> JSObject * listenerObj ; <NEW_LINE> if ( ! JS_ValueToObject ( aCx , listenerVal , & listenerObj ) ) { <NEW_LINE> if ( ! JS_ReportPendingException ( aCx ) ) { <NEW_LINE> aRv . Throw ( NS_ERROR_FAILURE ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> continue ;
RD_BOOL <NEW_LINE> <START_VULN> ber_parse_header ( STREAM s , int tagval , int * length ) <NEW_LINE> <END_VULN> { <NEW_LINE> int tag , len ;
if ( options . zoneSpec == JS::SystemZone ) { <NEW_LINE> rt -> systemZone = compartment -> zone ( ) ; <NEW_LINE> rt -> systemZone -> isSystem = true ; <NEW_LINE> } <NEW_LINE> AutoHoldZone hold ( compartment -> zone ( ) ) ; <NEW_LINE> <START_VULN> JSCompartment * saved = cx -> compartment ( ) ; <NEW_LINE>cx -> setCompartment ( compartment ) ; <NEW_LINE>Rooted < GlobalObject * > global ( cx , GlobalObject::create ( cx , Valueify ( clasp ) ) ) ; <NEW_LINE>cx -> setCompartment ( saved ) ; <NEW_LINE> <END_VULN> if ( ! global ) <NEW_LINE> return NULL ; <NEW_LINE> if ( ! Debugger::onNewGlobalObject ( cx , global ) ) <NEW_LINE> return NULL ; <NEW_LINE> return global ; <NEW_LINE> }
case 0x08: <NEW_LINE> globalVolSlide = swapped ; <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x09:
for ( i = 0 , l = 0 ; i < partvals ; l ++ ) { <NEW_LINE> if ( s == 0 ) { <NEW_LINE> for ( j = 0 ; j < ch ; j ++ ) { <NEW_LINE> int temp = vorbis_book_decode ( look -> phrasebook , & vb -> opb ) ; <NEW_LINE> <START_VULN> if ( temp == - 1 ) goto eopbreak ; <NEW_LINE> <END_VULN> partword [ j ] [ l ] = look -> decodemap [ temp ] ; <NEW_LINE> if ( partword [ j ] [ l ] == NULL ) goto errout ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) <NEW_LINE> for ( j = 0 ; j < ch ; j ++ ) {
zval * z_still_running ; <NEW_LINE> php_curlm * mh ; <NEW_LINE> int still_running ; <NEW_LINE> <START_VULN> int result ; <NEW_LINE> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , "rz / " , & z_mh , & z_still_running ) == FAILURE ) { <NEW_LINE> return ;
add_assoc_long ( * subarray , "weight" , n ) ; <NEW_LINE> GETSHORT ( n , cp ) ; <NEW_LINE> add_assoc_long ( * subarray , "port" , n ) ; <NEW_LINE> <START_VULN> n = dn_expand ( answer -> qb2 , answer -> qb2 + 65536 , cp , name , ( sizeof name ) - 2 ) ; <NEW_LINE> <END_VULN> if ( n < 0 ) { <NEW_LINE> return NULL ; <NEW_LINE> }
bool HasSingleOrigin ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE>bool DidPassCORSAccessCheck ( ) const ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>bool DidGetOpaqueResponseViaServiceWorker ( ) const ; <NEW_LINE> <END_VULN>
} <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> if ( win -> mPluginType == nsPluginType_Flash ) { <NEW_LINE> <START_VULN> if ( ProcessFlashMessageDelayed ( win , hWnd , msg , wParam , lParam ) ) <NEW_LINE> <END_VULN> return TRUE ; <NEW_LINE> } <NEW_LINE> LRESULT res = TRUE ; <NEW_LINE> nsCOMPtr < nsIPluginInstanceInternal > instInternal ; <NEW_LINE> if ( enablePopups ) {
MOZ_ASSERT ( ! mParent ) ; <NEW_LINE> MOZ_ASSERT ( GetOwner ( ) ) ; <NEW_LINE> nsresult rv ; <NEW_LINE> nsIScriptContext * sc = GetContextForEventHandlers ( & rv ) ; <NEW_LINE> NS_ENSURE_SUCCESS_VOID ( rv ) ; <NEW_LINE> NS_ENSURE_TRUE_VOID ( sc ) ; <NEW_LINE> <START_VULN> JSContext * cx = sc -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> MOZ_ASSERT ( cx ) ; <NEW_LINE> nsCOMPtr < nsIScriptGlobalObject > sgo = do_QueryInterface ( GetOwner ( ) ) ; <NEW_LINE> JSObject * ownerObj = sgo -> GetGlobalJSObject ( ) ; <NEW_LINE> NS_ENSURE_TRUE_VOID ( ownerObj ) ; <NEW_LINE> nsCxPusher pusher ;
while ( v ) { <NEW_LINE> ret ++ ; <NEW_LINE> v >> = 1 ; <NEW_LINE> } <NEW_LINE> return ( ret ) ; <NEW_LINE> } <NEW_LINE> static void mapping0_pack ( vorbis_info * vi , vorbis_info_mapping * vm , <NEW_LINE> <START_VULN> oggpack_buffer * opb ) { <NEW_LINE> <END_VULN> int i ; <NEW_LINE> vorbis_info_mapping0 * info = ( vorbis_info_mapping0 * ) vm ; <NEW_LINE> if ( info -> submaps > 1 ) { <NEW_LINE> for ( i = 0 ; i < vi -> channels ; i ++ ) {
tabs_to_links ( true ) , <NEW_LINE> user_style_sheet_enabled ( false ) , <NEW_LINE> allow_universal_access_from_file_urls ( false ) , <NEW_LINE> <START_VULN> experimental_webgl_enabled ( false ) , <NEW_LINE>experimental_notifications_enabled ( false ) { <NEW_LINE> <END_VULN> } <NEW_LINE> void Apply ( WebKit::WebView * web_view ) const ;
NS_IMETHODIMP <NEW_LINE> nsWindow::SetCursor ( imgIContainer * aCursor , <NEW_LINE> PRUint32 aHotspotX , PRUint32 aHotspotY ) <NEW_LINE> { <NEW_LINE> if ( ! mContainer && mDrawingarea ) { <NEW_LINE> <START_VULN> GtkWidget * widget = <NEW_LINE>get_gtk_widget_for_gdk_window ( mDrawingarea -> inner_window ) ; <NEW_LINE>nsWindow * window = get_window_for_gtk_widget ( widget ) ; <NEW_LINE> <END_VULN> return window -> SetCursor ( aCursor , aHotspotX , aHotspotY ) ; <NEW_LINE> } <NEW_LINE> if ( ! sPixbufCursorChecked ) { <NEW_LINE> PRLibrary * lib ; <NEW_LINE> _gdk_cursor_new_from_pixbuf = ( _gdk_cursor_new_from_pixbuf_fn ) <NEW_LINE> PR_FindFunctionSymbolAndLibrary ( "gdk_cursor_new_from_pixbuf" , & lib ) ; <NEW_LINE> if ( lib ) {
{ <NEW_LINE> if ( XRE_GetProcessType ( ) != GeckoProcessType_Default ) { <NEW_LINE> return NS_ERROR_NOT_AVAILABLE ; <NEW_LINE> } <NEW_LINE> NS_ASSERTION ( NS_IsMainThread ( ) , "We can only initialize on the main thread" ) ; <NEW_LINE> NS_ASSERTION ( ! mShutdown , "Already shutdown ! " ) ; <NEW_LINE> <START_VULN> JSContext * cx = nsContentUtils::ThreadJSContextStack ( ) -> GetSafeJSContext ( ) ; <NEW_LINE>NS_ENSURE_TRUE ( cx , NS_ERROR_FAILURE ) ; <NEW_LINE><NEW_LINE>nsCxPusher pusher ; <NEW_LINE>if ( ! pusher . Push ( cx , false ) ) { <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> <END_VULN> nsresult rv = InitWifi ( cx ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> NS_WARNING ( "Failed to initialize WiFi Networking ! " ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> #ifdef MOZ_WIDGET_GONK
<START_VULN> long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , <NEW_LINE>unsigned long shmlba ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct shmid_kernel * shp ; <NEW_LINE> unsigned long addr ;
extern "C" { <NEW_LINE> #endif <NEW_LINE> <START_VULN> #include "vp9 / encoder / vp9_onyx_int . h" <NEW_LINE> <END_VULN> struct yv12_buffer_config ; <NEW_LINE> struct VP9_COMP ;
void * pv_buf ; <NEW_LINE> void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; <NEW_LINE> size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; <NEW_LINE> <START_VULN> pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; <NEW_LINE> <END_VULN> RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; <NEW_LINE> ps_dec -> pu1_bits_buf_dynamic = pv_buf ; <NEW_LINE> ps_dec -> u4_dynamic_bits_buf_size = size ;
#if defined ( PNG_READ_USER_TRANSFORM_SUPPORTED ) && \ <NEW_LINE> defined ( PNG_USER_TRANSFORM_PTR_SUPPORTED ) <NEW_LINE> <START_VULN> if ( png_ptr -> transformations & PNG_USER_TRANSFORM ) <NEW_LINE> <END_VULN> { <NEW_LINE> int user_pixel_depth = png_ptr -> user_transform_depth * <NEW_LINE> png_ptr -> user_transform_channels ;
if ( mContextLost ) \ <NEW_LINE> return NS_OK ; \ <NEW_LINE> OBTAIN_UNIFORM_LOCATION ( #name ": location" ) \ <NEW_LINE> if ( ! wa || JS_GetTypedArrayType ( wa ) != js::TypedArray::arrayType ) \ <NEW_LINE> return ErrorInvalidOperation ( #name ": array must be " #arrayType ) ; \ <NEW_LINE> if ( JS_GetTypedArrayLength ( wa ) == 0 || JS_GetTypedArrayLength ( wa ) % cnt != 0 ) \ <NEW_LINE> return ErrorInvalidValue ( #name ": array must be > 0 elements and have a length multiple of % d" , cnt ) ; \ <NEW_LINE> MakeContextCurrent ( ) ; \ <NEW_LINE> <START_VULN> gl -> f##name ( location , JS_GetTypedArrayLength ( wa ) / cnt , ( ptrType * ) JS_GetTypedArrayData ( wa ) ) ; \ <NEW_LINE> <END_VULN> return NS_OK ; \ <NEW_LINE> } <NEW_LINE> #define SIMPLE_MATRIX_METHOD_UNIFORM ( name , dim , arrayType , ptrType ) \ <NEW_LINE> NS_IMETHODIMP \ <NEW_LINE> WebGLContext::name ( PRInt32 ) { \ <NEW_LINE> return NS_ERROR_NOT_IMPLEMENTED ; \ <NEW_LINE> } \
MOZ_GUARD_OBJECT_NOTIFIER_INIT ; <NEW_LINE> if ( ! aSafe ) { <NEW_LINE> mCx = nsContentUtils::GetCurrentJSContext ( ) ; <NEW_LINE> } <NEW_LINE> if ( ! mCx ) { <NEW_LINE> mCx = nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>bool result = mPusher . Push ( mCx , nsCxPusher::REQUIRE_SCRIPT_CONTEXT ) ; <NEW_LINE> <END_VULN> if ( ! result || ! mCx ) { <NEW_LINE> MOZ_CRASH ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> AutoJSContext::operator JSContext * ( ) <NEW_LINE> {
if ( numPoints <= 1 ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> } <NEW_LINE> void GraphicsContext::fillRect ( const FloatRect & rect , const Color & color , ColorSpace colorSpace )
#include "core / platform / graphics / GraphicsContext . h" <NEW_LINE> #include "core / platform / graphics / chromium / FontUtilsChromiumWin . h" <NEW_LINE> #include "core / platform / graphics / chromium / TransparencyWin . h" <NEW_LINE> <START_VULN> #include "core / platform / win / SystemInfo . h" <NEW_LINE> <END_VULN> #include "core / rendering / PaintInfo . h" <NEW_LINE> #include "core / rendering / RenderBox . h" <NEW_LINE> #include "core / rendering / RenderProgress . h" <NEW_LINE> #include "core / rendering / RenderSlider . h" <NEW_LINE> #include "platform / LayoutTestSupport . h" <NEW_LINE> #include "public / platform / Platform . h" <NEW_LINE> #include "public / platform / WebColor . h" <NEW_LINE> #include "public / platform / WebRect . h"
{ <NEW_LINE> size_t res = 0 ; <NEW_LINE> size_t inLeft = ( size_t ) * inputLeft * 2 ; <NEW_LINE> size_t outLeft = ( size_t ) * outputLeft ; <NEW_LINE> if ( gUnicodeToNative != INVALID_ICONV_T ) { <NEW_LINE> res = xp_iconv ( gUnicodeToNative , ( const char ** ) input , & inLeft , output , & outLeft ) ; <NEW_LINE> if ( res != ( size_t ) - 1 ) { <NEW_LINE> <START_VULN> * inputLeft = inLeft / 2 ; <NEW_LINE> * outputLeft = outLeft ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_ERROR ( "iconv failed" ) ; <NEW_LINE> xp_iconv_reset ( gUnicodeToNative ) ; <NEW_LINE> }
delete mLastVideoFrame ; <NEW_LINE> mLastVideoFrame = nullptr ; <NEW_LINE> } <NEW_LINE> mOmxDecoder . clear ( ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> bool MediaOmxReader::DecodeVideoFrame ( bool & aKeyframeSkip , <NEW_LINE> <START_VULN> int64_t aTimeThreshold ) <NEW_LINE> <END_VULN> { <NEW_LINE> uint32_t parsed = 0 , decoded = 0 ; <NEW_LINE> AbstractMediaDecoder::AutoNotifyDecoded autoNotify ( mDecoder , parsed , decoded ) ; <NEW_LINE> if ( mLastVideoFrame && mVideoSeekTimeUs != - 1 ) {
} <NEW_LINE> length ++ ; <NEW_LINE> } <NEW_LINE> <START_VULN> length = length * BezierQuantum / 2 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> } <NEW_LINE> case CirclePrimitive:
mListControlFrame -> GetOptionText ( selectedIndex , selectedOptionText ) ; <NEW_LINE> } <NEW_LINE> if ( mDisplayedOptionText != selectedOptionText ) { <NEW_LINE> RedisplayText ( selectedIndex ) ; <NEW_LINE> } <NEW_LINE> ReflowDropdown ( aPresContext , aReflowState ) ; <NEW_LINE> <START_VULN> nsIReflowCallback * cb = new nsResizeDropdownAtFinalPosition ( this ) ; <NEW_LINE>aPresContext -> PresShell ( ) -> PostReflowCallback ( cb ) ; <NEW_LINE> <END_VULN> nscoord buttonWidth ; <NEW_LINE> const nsStyleDisplay * disp = GetStyleDisplay ( ) ; <NEW_LINE> if ( IsThemed ( disp ) && ! aPresContext -> GetTheme ( ) -> ThemeNeedsComboboxDropmarker ( ) ) { <NEW_LINE> buttonWidth = 0 ; <NEW_LINE> }
if ( op != JSOP_THIS ) <NEW_LINE> continue ; <NEW_LINE> SSAValue thisv = SSAValue::PushedValue ( offset , 0 ) ; <NEW_LINE> SSAUseChain * uses = analysis -> useChain ( thisv ) ; <NEW_LINE> JS_ASSERT ( uses ) ; <NEW_LINE> if ( uses -> next || ! uses -> popped ) { <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>if ( offset < lastThisPopped ) { <NEW_LINE> * pbaseobj = NULL ; <NEW_LINE>return false ; <NEW_LINE> } <NEW_LINE> <END_VULN> lastThisPopped = uses -> offset ; <NEW_LINE> Bytecode * poppedCode = analysis -> maybeCode ( uses -> offset ) ; <NEW_LINE> if ( ! poppedCode || ! poppedCode -> unconditional ) <NEW_LINE> return false ; <NEW_LINE> pc = script -> code + uses -> offset ;
ReadParam ( m , iter , & p -> user_style_sheet_enabled ) && <NEW_LINE> ReadParam ( m , iter , & p -> user_style_sheet_location ) && <NEW_LINE> ReadParam ( m , iter , & p -> allow_universal_access_from_file_urls ) && <NEW_LINE> <START_VULN> ReadParam ( m , iter , & p -> experimental_webgl_enabled ) && <NEW_LINE>ReadParam ( m , iter , & p -> experimental_notifications_enabled ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void Log ( const param_type & p , std::wstring * l ) { <NEW_LINE> l -> append ( L" < WebPreferences > " ) ;
flags |= JSON_PRESERVE_ORDER ; <NEW_LINE> if ( getenv_int ( "JSON_SORT_KEYS" ) ) <NEW_LINE> <START_VULN> flags |= JSON_SORT_KEYS ; <NEW_LINE> <END_VULN> if ( getenv_int ( "STRIP" ) ) {
<START_VULN> if ( isPositioned ( ) && newStyle -> hasStaticBlockPosition ( isHorizontalWritingMode ( ) ) && oldStyle -> marginBefore ( ) != newStyle -> marginBefore ( ) <NEW_LINE> <END_VULN> && parent ( ) && ! parent ( ) -> normalChildNeedsLayout ( ) ) <NEW_LINE> parent ( ) -> setChildNeedsLayout ( true ) ; <NEW_LINE> }
return mUploadStream ; <NEW_LINE> } <NEW_LINE> void GetFTPEventSink ( nsCOMPtr < nsIFTPEventSink > & aResult ) ; <NEW_LINE> protected: <NEW_LINE> virtual ~ nsFtpChannel ( ) { } <NEW_LINE> <START_VULN> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result ) ; <NEW_LINE> <END_VULN> virtual PRBool GetStatusArg ( nsresult status , nsString & statusArg ) ; <NEW_LINE> virtual void OnCallbacksChanged ( ) ; <NEW_LINE> private: <NEW_LINE> nsCOMPtr < nsIProxyInfo > mProxyInfo ; <NEW_LINE> nsCOMPtr < nsIFTPEventSink > mFTPEventSink ; <NEW_LINE> nsCOMPtr < nsIInputStream > mUploadStream ; <NEW_LINE> PRUint64 mStartPos ;
sizeof ( * clone_image -> colormap ) ) ; <NEW_LINE> if ( clone_image -> colormap == ( PixelPacket * ) NULL ) <NEW_LINE> { <NEW_LINE> <START_VULN> clone_image = DestroyImage ( clone_image ) ; <NEW_LINE> <END_VULN> ThrowImageException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> } <NEW_LINE> ( void ) CopyMagickMemory ( clone_image -> colormap , image -> colormap , length *
if ( fp != NULL ) <NEW_LINE> { <NEW_LINE> if ( png_image_write_to_stdio ( image , fp , convert_to_8bit , buffer , <NEW_LINE> <START_VULN> row_stride , colormap ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> int error ;
envpsize = 64 ; <NEW_LINE> envp = walloc ( envpsize * sizeof ( char * ) ) ; <NEW_LINE> for ( n = 0 , s = hashFirst ( wp -> vars ) ; s != NULL ; s = hashNext ( wp -> vars , s ) ) { <NEW_LINE> <START_VULN> if ( s -> content . valid && s -> content . type == string && <NEW_LINE>strcmp ( s -> name . value . string , "REMOTE_HOST" ) != 0 && <NEW_LINE>strcmp ( s -> name . value . string , "HTTP_AUTHORIZATION" ) != 0 ) { <NEW_LINE>envp [ n ++ ] = sfmt ( " % s = % s" , s -> name . value . string , s -> content . value . string ) ; <NEW_LINE> <END_VULN> trace ( 5 , "Env [ % d ] % s" , n , envp [ n - 1 ] ) ; <NEW_LINE> if ( n >= envpsize ) { <NEW_LINE> envpsize *= 2 ;
++ mInputBufferCount ; <NEW_LINE> outHeader -> nOffset = 0 ; <NEW_LINE> <START_VULN> outHeader -> nFilledLen = ( mWidth * mHeight * 3 ) / 2 ; <NEW_LINE> <END_VULN> List < BufferInfo * > ::iterator it = outQueue . begin ( ) ; <NEW_LINE> while ( ( * it ) -> mHeader != outHeader ) {
<START_VULN> if ( pCmdData == NULL || ( cmdSize < ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ) <NEW_LINE> || pReplyData == NULL || * replySize != sizeof ( int32_t ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Reverb_command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_SET_PARAM: ERROR" ) ; <NEW_LINE> return - EINVAL ;
long line_add = ( intern -> u . file . current_line || intern -> u . file . current_zval ) ? 1 : 0 ; <NEW_LINE> spl_filesystem_file_free_line ( intern TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( php_stream_eof ( intern -> u . file . stream ) ) { <NEW_LINE> if ( ! silent ) { <NEW_LINE> zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , "Cannot read from file % s" , intern -> file_name ) ;
thread_specific_data ( void * private_data ) <NEW_LINE> { <NEW_LINE> xmlDocPtr myDoc ; <NEW_LINE> <START_VULN> const char * filename = ( const char * ) private_data ; <NEW_LINE> <END_VULN> int okay = 1 ; <NEW_LINE> if ( ! strcmp ( filename , "test / threads / invalid . xml" ) ) {
<START_VULN> bool CreateShortcutLink ( const wchar_t * source , const wchar_t * destination , <NEW_LINE>const wchar_t * working_dir , const wchar_t * arguments , <NEW_LINE>const wchar_t * description , const wchar_t * icon , <NEW_LINE>int icon_index , const wchar_t * app_id ) ; <NEW_LINE> <END_VULN>
png_color_16p trans_color ; <NEW_LINE> if ( png_get_tRNS ( read_ptr , read_info_ptr , & trans_alpha , & num_trans , <NEW_LINE> <START_VULN> & trans_color ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> int sample_max = ( 1 << bit_depth ) ;
kSqrt = ( 12 << 8 ) + 26 , <NEW_LINE> kDup = ( 12 << 8 ) + 27 , <NEW_LINE> kExch = ( 12 << 8 ) + 28 , <NEW_LINE> kIndex = ( 12 << 8 ) + 29 , <NEW_LINE> kRoll = ( 12 << 8 ) + 30 , <NEW_LINE> kHFlex = ( 12 << 8 ) + 34 , <NEW_LINE> kFlex = ( 12 << 8 ) + 35 , <NEW_LINE> kHFlex1 = ( 12 << 8 ) + 36 , <NEW_LINE> <START_VULN> kFlex1 = ( 12 << 8 ) + 37 , <NEW_LINE> <END_VULN> } ; <NEW_LINE> } <NEW_LINE> #endif
buffer -> length = 0 ; <NEW_LINE> buffer -> offset = 0 ; <NEW_LINE> <START_VULN> int bytes_read = read ( reader -> inbound_fd , buffer -> data , reader -> buffer_size ) ; <NEW_LINE> <END_VULN> if ( bytes_read > 0 ) { <NEW_LINE> buffer -> length = bytes_read ;
INC_STATS ( "DOM . WebGLRenderingContext . getExtensionCallback ( ) " ) ; <NEW_LINE> WebGLRenderingContext * imp = V8WebGLRenderingContext::toNative ( args . Holder ( ) ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , name , args [ 0 ] ) ; <NEW_LINE> WebGLExtension * extension = imp -> getExtension ( name ) ; <NEW_LINE> return toV8Object ( extension , args . Holder ( ) , args . GetIsolate ( ) ) ;
struct crypto_report_aead raead ; <NEW_LINE> struct aead_alg * aead = & alg -> cra_aead ; <NEW_LINE> <START_VULN> snprintf ( raead . type , CRYPTO_MAX_ALG_NAME , " % s" , "aead" ) ; <NEW_LINE>snprintf ( raead . geniv , CRYPTO_MAX_ALG_NAME , " % s" , <NEW_LINE>aead -> geniv ? : " < built - in > " ) ; <NEW_LINE> <END_VULN> raead . blocksize = alg -> cra_blocksize ; <NEW_LINE> raead . maxauthsize = aead -> maxauthsize ;
t_encode += ( t_stop - t_start ) ; <NEW_LINE> t_start = t_stop ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifndef SINGLE_ROWBUF_ALLOC <NEW_LINE> pngtest_debug2 ( "Freeing row buffer ( pass % d , y = % u ) " , pass , y ) ;
code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , <NEW_LINE> opts , krb5_get_as_key_noop , & userid , & use_master , <NEW_LINE> NULL ) ; <NEW_LINE> <START_VULN> if ( code == 0 || code == KRB5_PREAUTH_FAILED ) { <NEW_LINE> <END_VULN> * canon_user = userid . user ; <NEW_LINE> userid . user = NULL ; <NEW_LINE> code = 0 ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <NEW_LINE> <END_VULN> js_newarray ( J ) ; <NEW_LINE> js_pushstring ( J , text ) ; <NEW_LINE> js_setproperty ( J , - 2 , "input" ) ;
0 . 9999979185F , 0 . 9999982507F , 0 . 9999985414F , 0 . 9999987944F , <NEW_LINE> 0 . 9999990129F , 0 . 9999992003F , 0 . 9999993596F , 0 . 9999994939F , <NEW_LINE> 0 . 9999996059F , 0 . 9999996981F , 0 . 9999997732F , 0 . 9999998333F , <NEW_LINE> 0 . 9999998805F , 0 . 9999999170F , 0 . 9999999444F , 0 . 9999999643F , <NEW_LINE> 0 . 9999999784F , 0 . 9999999878F , 0 . 9999999937F , 0 . 9999999972F , <NEW_LINE> 0 . 9999999990F , 0 . 9999999997F , 1 . 0000000000F , 1 . 0000000000F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin4096 [ 2048 ] = { <NEW_LINE> <END_VULN> 0 . 0000002310F , 0 . 0000020791F , 0 . 0000057754F , 0 . 0000113197F , <NEW_LINE> 0 . 0000187121F , 0 . 0000279526F , 0 . 0000390412F , 0 . 0000519777F , <NEW_LINE> 0 . 0000667623F , 0 . 0000833949F , 0 . 0001018753F , 0 . 0001222036F , <NEW_LINE> 0 . 0001443798F , 0 . 0001684037F , 0 . 0001942754F , 0 . 0002219947F , <NEW_LINE> 0 . 0002515616F , 0 . 0002829761F , 0 . 0003162380F , 0 . 0003513472F ,
} <NEW_LINE> } <NEW_LINE> <START_VULN> static void perf_event_output ( struct perf_event * event , int nmi , <NEW_LINE> <END_VULN> struct perf_sample_data * data , <NEW_LINE> struct pt_regs * regs ) <NEW_LINE> {
vpx_release_frame_buffer_cb_fn_t cb_release , void * cb_priv ) { <NEW_LINE> if ( cb_get == NULL || cb_release == NULL ) { <NEW_LINE> return VPX_CODEC_INVALID_PARAM ; <NEW_LINE> <START_VULN> } else if ( ctx -> pbi == NULL ) { <NEW_LINE> <END_VULN> ctx -> get_ext_fb_cb = cb_get ;
encryption -> signature_len = buflen ; <NEW_LINE> } else if ( id == 0x7E4 ) { <NEW_LINE> <START_VULN> delete [ ] encryption -> sig_key_id ; <NEW_LINE> <END_VULN> encryption -> sig_key_id = NULL ; <NEW_LINE> encryption -> sig_key_id_len = 0 ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: psychoacoustics not including preecho <NEW_LINE> <START_VULN> last mod: $ Id: psy . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include "vorbis / codec . h" <NEW_LINE> #include "codec_internal . h"
} <NEW_LINE> for ( Value * begin = toRecompute . begin ( ) , * end = toRecompute . end ( ) ; begin != end ; ++ begin ) <NEW_LINE> { <NEW_LINE> JSObject * wrapper = & begin -> toObject ( ) ; <NEW_LINE> JSObject * wrapped = Wrapper::wrappedObject ( wrapper ) ; <NEW_LINE> if ( ! RemapWrapper ( cx , wrapper , wrapped ) ) <NEW_LINE> <START_VULN> return false ; <NEW_LINE> <END_VULN> } <NEW_LINE> return true ; <NEW_LINE> }
#include "base / macros . h" <NEW_LINE> #include "content / public / browser / devtools_frontend_host . h" <NEW_LINE> #include "mojo / public / cpp / bindings / associated_binding . h" <NEW_LINE> <START_VULN> #include "third_party / blink / public / mojom / devtools / devtools_frontend . mojom . h" <NEW_LINE> <END_VULN> namespace content {
mDownstreamZlib . opaque = Z_NULL ; <NEW_LINE> inflateInit ( & mDownstreamZlib ) ; <NEW_LINE> mUpstreamZlib . zalloc = SpdyStream2::zlib_allocator ; <NEW_LINE> mUpstreamZlib . zfree = SpdyStream2::zlib_destructor ; <NEW_LINE> mUpstreamZlib . opaque = Z_NULL ; <NEW_LINE> <START_VULN> deflateInit ( & mUpstreamZlib , Z_DEFAULT_COMPRESSION ) ; <NEW_LINE> <END_VULN> deflateSetDictionary ( & mUpstreamZlib , <NEW_LINE> reinterpret_cast < const unsigned char * > <NEW_LINE> ( SpdyStream2::kDictionary ) , <NEW_LINE> strlen ( SpdyStream2::kDictionary ) + 1 ) ; <NEW_LINE> } <NEW_LINE> nsresult
#define UINT64_C ( x ) x ## UL <NEW_LINE> #endif <NEW_LINE> #define INT64_F "l" <NEW_LINE> <START_VULN> #else <NEW_LINE>typedef unsigned long long uint64 ; <NEW_LINE>typedef long long int64 ; <NEW_LINE> <END_VULN> #ifndef INT64_C <NEW_LINE> #define INT64_C ( x ) x ## LL <NEW_LINE> #endif
blendJson ( app -> config , "directories" , spec , "directories" ) ; <NEW_LINE> } <NEW_LINE> if ( mprLookupKey ( app -> topDeps , name ) ) { <NEW_LINE> <START_VULN> major = stok ( sclone ( version ) , " . " , & minor ) ; <NEW_LINE>minor = stok ( minor , " . " , & patch ) ; <NEW_LINE> <END_VULN> key = sfmt ( "dependencies . % s" , name ) ; <NEW_LINE> if ( ! mprGetJson ( app -> config , key ) ) { <NEW_LINE> mprSetJson ( app -> config , key , sfmt ( " ~ % s . % s" , major , minor ) ) ;
memset ( data , 0 , checked_neededByteLength . value ( ) ) ; <NEW_LINE> if ( x >= framebufferWidth <NEW_LINE> || x + width <= 0 <NEW_LINE> || y >= framebufferHeight <NEW_LINE> || y + height <= 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> return DummyFramebufferOperation ( "readPixels" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> GLint subrect_x = std::max ( x , 0 ) ; <NEW_LINE> GLint subrect_end_x = std::min ( x + width , framebufferWidth ) ; <NEW_LINE> GLsizei subrect_width = subrect_end_x - subrect_x ; <NEW_LINE> GLint subrect_y = std::max ( y , 0 ) ;
void ForciblyCloseChannel ( ) ; <NEW_LINE> GpuChannelHostFactory * factory ( ) const { return factory_ ; } <NEW_LINE> <START_VULN> int gpu_process_id ( ) const { return gpu_process_id_ ; } <NEW_LINE> <END_VULN> int client_id ( ) const { return client_id_ ; } <NEW_LINE> private:
if ( ! sparc_perf_event_set_period ( event , hwc , idx ) ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> if ( perf_event_overflow ( event , 1 , & data , regs ) ) <NEW_LINE> <END_VULN> sparc_pmu_stop ( event , 0 ) ; <NEW_LINE> }
return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsUTF16BEToUnicode::Convert ( const char * aSrc , PRInt32 * aSrcLength , <NEW_LINE> PRUnichar * aDest , PRInt32 * aDestLength ) <NEW_LINE> { <NEW_LINE> #ifdef IS_LITTLE_ENDIAN <NEW_LINE> if ( STATE_FIRST_CALL == mState ) <NEW_LINE> { <NEW_LINE> mState = STATE_NORMAL ; <NEW_LINE> <START_VULN> if ( * aSrcLength < 2 ) <NEW_LINE>return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> <END_VULN> if ( 0xFFFE == * ( ( PRUnichar * ) aSrc ) ) { <NEW_LINE> mState = STATE_FOUND_BOM ; <NEW_LINE> } else if ( 0xFEFF == * ( ( PRUnichar * ) aSrc ) ) { <NEW_LINE> * aSrcLength = 0 ; <NEW_LINE> * aDestLength = 0 ; <NEW_LINE> return NS_ERROR_ILLEGAL_INPUT ; <NEW_LINE> }
struct optimize_ctx * const ctx = args -> ctx ; <NEW_LINE> struct macroblock_plane * const p = & x -> plane [ plane ] ; <NEW_LINE> struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <NEW_LINE> <START_VULN> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <NEW_LINE> <END_VULN> int i , j ; <NEW_LINE> uint8_t * dst ; <NEW_LINE> ENTROPY_CONTEXT * a , * l ;
nsresult <NEW_LINE> RasterImage::ShutdownDecoder ( eShutdownIntent aIntent ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( NS_IsMainThread ( ) ) ; <NEW_LINE> <START_VULN> mDecodingMutex . AssertCurrentThreadOwns ( ) ; <NEW_LINE> <END_VULN> NS_ABORT_IF_FALSE ( ( aIntent >= 0 ) && ( aIntent < eShutdownIntent_AllCount ) , <NEW_LINE> "Invalid shutdown intent" ) ; <NEW_LINE> NS_ABORT_IF_FALSE ( mDecoder , "Calling ShutdownDecoder ( ) with no active decoder ! " ) ;
ThreadSafeMatch ( tag_name , SVGNames::svgTag ) ) || <NEW_LINE> ( namespace_stack_ . back ( ) == kMathML && <NEW_LINE> ThreadSafeMatch ( tag_name , MathMLNames::mathTag ) ) || <NEW_LINE> <START_VULN> ( namespace_stack_ . Contains ( SVG ) && namespace_stack_ . back ( ) == HTML && <NEW_LINE>TokenExitsSVG ( token ) ) || <NEW_LINE> <END_VULN> ( namespace_stack_ . Contains ( kMathML ) && <NEW_LINE> namespace_stack_ . back ( ) == HTML && TokenExitsMath ( token ) ) ) { <NEW_LINE> namespace_stack_ . pop_back ( ) ;
toV8 ( document , args . GetIsolate ( ) ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , str1 , MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ;
<START_VULN> void SetRegisteredIds ( const ObjectIdSet & ids ) ; <NEW_LINE> <END_VULN>
encryption -> key_id_len = buflen ; <NEW_LINE> } else if ( id == 0x7E3 ) { <NEW_LINE> <START_VULN> delete [ ] encryption -> signature ; <NEW_LINE> <END_VULN> encryption -> signature = NULL ; <NEW_LINE> encryption -> signature_len = 0 ;
class GPU_EXPORT TextureDefinition { <NEW_LINE> public: <NEW_LINE> <START_VULN> struct LevelInfo { <NEW_LINE> <END_VULN> LevelInfo ( GLenum target , <NEW_LINE> GLenum internal_format , <NEW_LINE> GLsizei width ,
if ( tstate & TSTATE_PRIV ) <NEW_LINE> die_if_kernel ( "lddfmna from kernel" , regs ) ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , sfar ) ; <NEW_LINE> <END_VULN> if ( test_thread_flag ( TIF_32BIT ) ) <NEW_LINE> pc = ( u32 ) pc ; <NEW_LINE> if ( get_user ( insn , ( u32 __user * ) pc ) != - EFAULT ) {
IMkvWriter * writer ) { <NEW_LINE> if ( ! writer -> Seekable ( ) || chunking_ ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> const int64 cluster_offset = cluster_list_ [ 0 ] -> size_position ( ) - <NEW_LINE>GetUIntSize ( kMkvCluster ) ; <NEW_LINE> <END_VULN> if ( ! ChunkedCopy ( reader , writer , 0 , cluster_offset ) )
} <NEW_LINE> if ( ! container -> HasSameOwnerDoc ( newContent ) && <NEW_LINE> ( nodeType != nsIDOMNode::DOCUMENT_TYPE_NODE || <NEW_LINE> newContent -> GetOwnerDoc ( ) ) ) { <NEW_LINE> <START_VULN> nsCOMPtr < nsIDOM3Document > domDoc = do_QueryInterface ( aDocument ) ; <NEW_LINE><NEW_LINE>if ( domDoc ) { <NEW_LINE>nsCOMPtr < nsIDOMNode > adoptedKid ; <NEW_LINE>nsresult rv = domDoc -> AdoptNode ( aNewChild , getter_AddRefs ( adoptedKid ) ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE><NEW_LINE>NS_ASSERTION ( adoptedKid == aNewChild , "Uh , adopt node changed nodes ? " ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> if ( aReplace ) { <NEW_LINE> refContent = container -> GetChildAt ( insPos + 1 ) ;
num_trans = 0 ; <NEW_LINE> output_processing = PNG_CMAP_NONE ; <NEW_LINE> <START_VULN> data_encoding = P_FILE ; <NEW_LINE> <END_VULN> cmap_entries = png_ptr -> num_palette ; <NEW_LINE> if ( cmap_entries > 256 ) <NEW_LINE> cmap_entries = 256 ;
return - 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ; <NEW_LINE> <END_VULN> if ( str == ( unsigned char * ) NULL ) <NEW_LINE> { <NEW_LINE> PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ;
encryption_entries_ = <NEW_LINE> new ( std::nothrow ) ContentEncryption * [ encryption_count ] ; <NEW_LINE> if ( ! encryption_entries_ ) { <NEW_LINE> <START_VULN> delete [ ] compression_entries_ ; <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> } <NEW_LINE> encryption_entries_end_ = encryption_entries_ ;
v8::Local < v8::Context > context = scriptState -> context ( ) ; <NEW_LINE> v8::Local < v8::Object > global = context -> Global ( ) ; <NEW_LINE> <START_VULN> v8::Local < v8::Value > privateScriptController = <NEW_LINE>global -> Get ( context , v8String ( isolate , "privateScriptController" ) ) <NEW_LINE> . ToLocalChecked ( ) ; <NEW_LINE>RELEASE_ASSERT ( privateScriptController -> IsUndefined ( ) || <NEW_LINE>privateScriptController -> IsObject ( ) ) ; <NEW_LINE>if ( privateScriptController -> IsObject ( ) ) { <NEW_LINE> <END_VULN> v8::Local < v8::Object > privateScriptControllerObject = <NEW_LINE> privateScriptController . As < v8::Object > ( ) ; <NEW_LINE> v8::Local < v8::Value > importFunctionValue =
r = sc_read_record ( card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; <NEW_LINE> SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , "read document number failed" ) ; <NEW_LINE> <START_VULN> buff [ r ] = '\0' ; <NEW_LINE> <END_VULN> set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ; <NEW_LINE> p15card -> tokeninfo -> flags = SC_PKCS15_TOKEN_PRN_GENERATION
if ( GetFrame ( ) -> IsMainFrame ( ) && allow_focus ) <NEW_LINE> <START_VULN> page -> GetChromeClient ( ) . Focus ( ) ; <NEW_LINE> <END_VULN> page -> GetFocusController ( ) . FocusDocumentView ( GetFrame ( ) , <NEW_LINE> true ) ;
switch ( intern -> type ) { <NEW_LINE> case SPL_FS_DIR: <NEW_LINE> test = spl_filesystem_object_get_path ( intern , NULL ) ; <NEW_LINE> <START_VULN> fname_len = ( php_stat_len ) spprintf ( & fname , 0 , " % s % c % s" , test , DEFAULT_SLASH , intern -> u . dir . entry . d_name ) ; <NEW_LINE> <END_VULN> php_stat ( fname , fname_len , FS_IS_DIR , & dummy ) ; <NEW_LINE> if ( Z_TYPE ( dummy ) == IS_TRUE ) {
class GlyphCache::Loader <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> <START_VULN> Loader ( const Face & face , const bool dumb_font ) ; <NEW_LINE> <END_VULN> operator bool ( ) const throw ( ) ; <NEW_LINE> unsigned short int units_per_em ( ) const throw ( ) ;
user_password = user -> pw_passwd ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> if ( strcmp ( user_password , ( char * ) crypt ( password , user_password ) ) != 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication failed: user name or password incorrect" ) ; <NEW_LINE> return - 1 ;
#endif <NEW_LINE> case PTRACE_GET_THREAD_AREA: <NEW_LINE> <START_VULN> ret = put_user ( task_thread_info ( child ) -> tp_value , <NEW_LINE> <END_VULN> datap ) ; <NEW_LINE> break ;
JSString::writeBarrierPre ( d . u1 . left ) ; <NEW_LINE> JSString::writeBarrierPre ( d . s . u2 . right ) ; <NEW_LINE> } <NEW_LINE> wholeCapacity = capacity ; <NEW_LINE> wholeChars = const_cast < jschar * > ( left . chars ( ) ) ; <NEW_LINE> size_t bits = left . d . lengthAndFlags ; <NEW_LINE> pos = wholeChars + ( bits >> LENGTH_SHIFT ) ; <NEW_LINE> <START_VULN> left . d . lengthAndFlags = bits ^ ( EXTENSIBLE_FLAGS | DEPENDENT_BIT ) ; <NEW_LINE> <END_VULN> left . d . s . u2 . base = ( JSLinearString * ) this ; <NEW_LINE> JSString::writeBarrierPost ( left . d . s . u2 . base , & left . d . s . u2 . base ) ; <NEW_LINE> goto visit_right_child ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( ! AllocChars ( maybecx , wholeLength , & wholeChars , & wholeCapacity ) ) <NEW_LINE> return NULL ;
Value v = arg ; <NEW_LINE> if ( ! ToPrimitive ( cx , JSTYPE_STRING , & v ) ) <NEW_LINE> return NULL ; <NEW_LINE> JSString * str ; <NEW_LINE> if ( v . isString ( ) ) { <NEW_LINE> str = v . toString ( ) ; <NEW_LINE> } else if ( v . isInt32 ( ) ) { <NEW_LINE> <START_VULN> str = js_IntToString ( cx , v . toInt32 ( ) ) ; <NEW_LINE> <END_VULN> } else if ( v . isDouble ( ) ) { <NEW_LINE> str = js_NumberToString ( cx , v . toDouble ( ) ) ; <NEW_LINE> } else if ( v . isBoolean ( ) ) { <NEW_LINE> str = js_BooleanToString ( cx , v . toBoolean ( ) ) ; <NEW_LINE> } else if ( v . isNull ( ) ) { <NEW_LINE> str = cx -> runtime -> atomState . nullAtom ; <NEW_LINE> } else { <NEW_LINE> str = cx -> runtime -> atomState . typeAtoms [ JSTYPE_VOID ] ;
nsresult InitClass ( const nsCString & aClassName , JSContext * aContext , <NEW_LINE> JSObject * aGlobal , JSObject * aScriptObject , <NEW_LINE> JSObject ** aClassObject ) ; <NEW_LINE> nsresult ConstructInterfaceTable ( const nsAString & aImpls ) ; <NEW_LINE> void SetImplementation ( nsXBLProtoImpl * aImpl ) { mImplementation = aImpl ; } <NEW_LINE> <START_VULN> nsresult InstallImplementation ( nsIContent * aBoundElement ) ; <NEW_LINE> <END_VULN> bool HasImplementation ( ) const { return mImplementation != nullptr ; } <NEW_LINE> void AttributeChanged ( nsIAtom * aAttribute , int32_t aNameSpaceID , <NEW_LINE> bool aRemoveFlag , nsIContent * aChangedElement , <NEW_LINE> nsIContent * aAnonymousContent , bool aNotify ) ; <NEW_LINE> void SetBasePrototype ( nsXBLPrototypeBinding * aBinding ) ; <NEW_LINE> nsXBLPrototypeBinding * GetBasePrototype ( ) { return mBaseBinding ; }
* <NEW_LINE> <START_VULN> void impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) <NEW_LINE> <END_VULN> { <NEW_LINE> stream_t * ps_stream = & ps_dec -> s_bit_stream ; <NEW_LINE> UWORD16 u2_mb_addr_incr ;
if ( skb -> tstamp . tv64 ) <NEW_LINE> sk -> sk_stamp = skb -> tstamp ; <NEW_LINE> <START_VULN> msg -> msg_namelen = sizeof ( * sipx ) ; <NEW_LINE><NEW_LINE> <END_VULN> if ( sipx ) { <NEW_LINE> sipx -> sipx_family = AF_IPX ; <NEW_LINE> sipx -> sipx_port = ipx -> ipx_source . sock ; <NEW_LINE> memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; <NEW_LINE> sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; <NEW_LINE> sipx -> sipx_type = ipx -> ipx_type ; <NEW_LINE> sipx -> sipx_zero = 0 ; <NEW_LINE> } <NEW_LINE> rc = copied ;
if ( r -> upper_ < r -> lower_ ) { <NEW_LINE> <START_VULN> * emptyRange = true ; <NEW_LINE> <END_VULN> r -> makeRangeInfinite ( ) ; <NEW_LINE> } <NEW_LINE> return r ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> Range::unionWith ( const Range * other )
( void ) flags ; <NEW_LINE> stream = get_stream ( session , frame -> hd . stream_id ) ; <NEW_LINE> if ( ! stream ) { <NEW_LINE> <START_VULN> ap_log_cerror ( APLOG_MARK , APLOG_ERR , 0 , session -> c , <NEW_LINE> <END_VULN> APLOGNO ( 02920 ) <NEW_LINE> "h2_session: stream ( % ld - % d ) : on_header unknown stream" , <NEW_LINE> session -> id , ( int ) frame -> hd . stream_id ) ;
void Destroy ( JNIEnv * env , const base::android::JavaParamRef < jobject > & obj ) ; <NEW_LINE> <START_VULN> void SetMostVisitedURLsObserver ( <NEW_LINE>JNIEnv * env , <NEW_LINE>const base::android::JavaParamRef < jobject > & obj , <NEW_LINE>const base::android::JavaParamRef < jobject > & j_observer , <NEW_LINE>jint num_sites ) ; <NEW_LINE> <END_VULN> void AddOrRemoveBlacklistedUrl ( <NEW_LINE> JNIEnv * env ,
return RootWindowRect ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void ChromeClientImpl::Focus ( ) { <NEW_LINE>if ( web_view_ -> Client ( ) ) <NEW_LINE>web_view_ -> Client ( ) -> DidFocus ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool ChromeClientImpl::CanTakeFocus ( WebFocusType ) {
base::Lock audio_thread_lock_ ; <NEW_LINE> <START_VULN> scoped_ptr < AudioDeviceThread > audio_thread_ ; <NEW_LINE> <END_VULN> scoped_ptr < AudioOutputDevice::AudioThreadCallback > audio_callback_ ; <NEW_LINE> DISALLOW_COPY_AND_ASSIGN ( AudioOutputDevice ) ;
protected: <NEW_LINE> virtual void InitInternal ( ) ; <NEW_LINE> <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> virtual void FinishInternal ( ) ;
{ <NEW_LINE> terminate ( ) ; <NEW_LINE> if ( ! m_urlForReading . isEmpty ( ) ) <NEW_LINE> <START_VULN> ThreadableBlobRegistry::unregisterBlobURL ( m_urlForReading ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void FileReaderLoader::start ( ScriptExecutionContext * scriptExecutionContext , Blob * blob )
bool PropagatesSilence ( ) const override { return false ; } <NEW_LINE> <START_VULN> <NEW_LINE>bool PassesCORSAccessCheck ( ) ; <NEW_LINE><NEW_LINE><NEW_LINE>bool PassesCurrentSrcCORSAccessCheck ( const KURL & current_src ) ; <NEW_LINE> <END_VULN>
size_t <NEW_LINE> extent ; <NEW_LINE> <START_VULN> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <NEW_LINE> <END_VULN> return ( ( void * ) NULL ) ; <NEW_LINE> extent = count * quantum ; <NEW_LINE> return ( AcquireMagickMemory ( extent ) ) ;
} <NEW_LINE> } <NEW_LINE> if ( native == js::array_concat && argType == JSVAL_TYPE_OBJECT && <NEW_LINE> thisType == JSVAL_TYPE_OBJECT && type == JSVAL_TYPE_OBJECT && <NEW_LINE> ! thisTypes -> hasObjectFlags ( cx , types::OBJECT_FLAG_NON_DENSE_ARRAY ) && <NEW_LINE> ! argTypes -> hasObjectFlags ( cx , types::OBJECT_FLAG_NON_DENSE_ARRAY ) && <NEW_LINE> ! types::ArrayPrototypeHasIndexedProperty ( cx , outerScript ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> return compileArrayConcat ( thisTypes , argTypes , thisValue , arg ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } else if ( argc == 2 ) { <NEW_LINE> FrameEntry * arg1 = frame . peek ( - 2 ) ; <NEW_LINE> FrameEntry * arg2 = frame . peek ( - 1 ) ; <NEW_LINE> JSValueType arg1Type = arg1 -> isTypeKnown ( ) ? arg1 -> getKnownType ( ) : JSVAL_TYPE_UNKNOWN ; <NEW_LINE> JSValueType arg2Type = arg2 -> isTypeKnown ( ) ? arg2 -> getKnownType ( ) : JSVAL_TYPE_UNKNOWN ;
{ <NEW_LINE> INC_STATS ( "DOM . TestSerializedScriptValueInterface . acceptTransferList" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestSerializedScriptValueInterface * imp = V8TestSerializedScriptValueInterface::toNative ( args . Holder ( ) ) ; <NEW_LINE> MessagePortArray messagePortArrayTransferList ; <NEW_LINE> ArrayBufferArray arrayBufferArrayTransferList ;
void <NEW_LINE> JSContext::wrapPendingException ( ) <NEW_LINE> { <NEW_LINE> RootedValue value ( this , getPendingException ( ) ) ; <NEW_LINE> clearPendingException ( ) ; <NEW_LINE> <START_VULN> if ( compartment ( ) -> wrap ( this , & value ) ) <NEW_LINE> <END_VULN> setPendingException ( value ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> JSContext::enterGenerator ( JSGenerator * gen ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( ! gen -> prevGenerator ) ;
{ <NEW_LINE> JSTestNamedConstructorNamedConstructor * castedThis = jsCast < JSTestNamedConstructorNamedConstructor * > ( exec -> callee ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> const String & str1 ( ustringToString ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . isEmpty ( ) ? UString ( ) : MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . toString ( exec ) -> value ( exec ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) )
nsLayoutStatics::AddRef ( ) ; <NEW_LINE> SetDOMStringToNull ( mResult ) ; <NEW_LINE> SetIsDOMBinding ( ) ; <NEW_LINE> } <NEW_LINE> nsDOMFileReader:: ~ nsDOMFileReader ( ) <NEW_LINE> { <NEW_LINE> FreeFileData ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> nsLayoutStatics::Release ( ) ; <NEW_LINE> } <NEW_LINE> nsresult
#if DCHECK_IS_ON ( ) <NEW_LINE> <START_VULN> scoped_refptr < EffectPaintPropertyNode > Clone ( ) const { <NEW_LINE>return base::AdoptRef ( new EffectPaintPropertyNode ( Parent ( ) , State ( state_ ) ) ) ; <NEW_LINE> <END_VULN> }
#include "base / optional . h" <NEW_LINE> #include "third_party / blink / renderer / core / paint / object_paint_properties . h" <NEW_LINE> <START_VULN> #include "third_party / blink / renderer / platform / graphics / paint / ref_counted_property_tree_state . h" <NEW_LINE> <END_VULN> namespace blink {
if ( mState != ERRORED && r == CUBEB_OK ) { <NEW_LINE> mState = STARTED ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> int64_t <NEW_LINE> AudioStream::GetPosition ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> return mAudioClock . GetPosition ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef _MSC_VER <NEW_LINE> #pragma optimize ( "" , off ) <NEW_LINE> #endif <NEW_LINE> int64_t <NEW_LINE> AudioStream::GetPositionInFrames ( )
void RenderBlock::addOverflowFromBlockChildren ( ) <NEW_LINE> { <NEW_LINE> for ( RenderBox * child = firstChildBox ( ) ; child ; child = child -> nextSiblingBox ( ) ) { <NEW_LINE> <START_VULN> if ( ! child -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> addOverflowFromChild ( child ) ; <NEW_LINE> } <NEW_LINE> }
if ( latencyMs < 0 ) { <NEW_LINE> latencyMs = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> const uint32_t deltaSmpl = <NEW_LINE>pContext -> mConfig . inputCfg . samplingRate * latencyMs / 1000 ; <NEW_LINE>int32_t capturePoint = pContext -> mCaptureIdx - captureSize - deltaSmpl ; <NEW_LINE> <END_VULN> if ( capturePoint < 0 ) { <NEW_LINE> uint32_t size = - capturePoint ; <NEW_LINE> if ( size > captureSize ) {
static void locationWithPerWorldBindingsAttributeSetterForMainWorld ( v8::Local < v8::Value > jsValue , const v8::PropertyCallbackInfo < void > & info ) <NEW_LINE> { <NEW_LINE> TestObjectPython * proxyImp = V8TestObjectPython::toNative ( info . Holder ( ) ) ; <NEW_LINE> <START_VULN> TestNode * imp = WTF::getPtr ( proxyImp -> locationWithPerWorldBindings ( ) ) ; <NEW_LINE> <END_VULN> if ( ! imp ) <NEW_LINE> return ; <NEW_LINE> V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID ( V8StringResource < > , cppValue , jsValue ) ;
mImageFrame -> SetTimeout ( mGIFStruct . delay_time ) ; <NEW_LINE> if ( mGIFStruct . images_decoded ) <NEW_LINE> mImageContainer -> AppendFrame ( mImageFrame ) ; <NEW_LINE> mImageContainer -> EndFrameDecode ( mGIFStruct . images_decoded , mGIFStruct . delay_time ) ; <NEW_LINE> <START_VULN> mGIFStruct . images_decoded ++ ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( mObserver ) <NEW_LINE> mObserver -> OnStopFrame ( nsnull , mImageFrame ) ; <NEW_LINE> mImageFrame = nsnull ; <NEW_LINE> if ( mOldColor ) {
if ( info -> type > 2 || info -> type < 0 ) goto errout ; <NEW_LINE> info -> begin = oggpack_read ( opb , 24 ) ; <NEW_LINE> info -> end = oggpack_read ( opb , 24 ) ; <NEW_LINE> <START_VULN> info -> grouping = oggpack_read ( opb , 24 ) + 1 ; <NEW_LINE>info -> partitions = ( char ) ( oggpack_read ( opb , 6 ) + 1 ) ; <NEW_LINE>info -> groupbook = ( unsigned char ) oggpack_read ( opb , 8 ) ; <NEW_LINE> <END_VULN> if ( info -> groupbook >= ci -> books ) goto errout ; <NEW_LINE> info -> stagemasks = _ogg_malloc ( info -> partitions * sizeof ( * info -> stagemasks ) ) ;
if ( const RenderBoxModelObject * offsetParent = this -> offsetParent ( ) ) { <NEW_LINE> if ( offsetParent -> isBox ( ) && ! offsetParent -> isBody ( ) ) <NEW_LINE> referencePoint . move ( - toRenderBox ( offsetParent ) -> borderLeft ( ) , - toRenderBox ( offsetParent ) -> borderTop ( ) ) ; <NEW_LINE> <START_VULN> if ( ! isPositioned ( ) ) { <NEW_LINE> <END_VULN> if ( isRelPositioned ( ) ) <NEW_LINE> referencePoint . move ( relativePositionOffset ( ) ) ; <NEW_LINE> const RenderObject * curr = parent ( ) ;
bool mFullScreen ; <NEW_LINE> void * mJavaView ; <NEW_LINE> #endif <NEW_LINE> nsPluginNativeWindow * mPluginWindow ; <NEW_LINE> nsRefPtr < nsNPAPIPluginInstance > mInstance ; <NEW_LINE> nsPluginFrame * mPluginFrame ; <NEW_LINE> <START_VULN> nsIContent * mContent ; <NEW_LINE> <END_VULN> nsCString mDocumentBase ; <NEW_LINE> bool mWidgetCreationComplete ; <NEW_LINE> nsCOMPtr < nsIWidget > mWidget ; <NEW_LINE> nsRefPtr < nsPluginHost > mPluginHost ; <NEW_LINE> #ifdef XP_MACOSX <NEW_LINE> NP_CGContext mCGPluginPortCopy ; <NEW_LINE> int32_t mInCGPaintLevel ;
yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != '"' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 642 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> size_t len , maxlen ; <NEW_LINE> char * str ;
: ObjectStoreHelper ( aTransaction , aRequest , aObjectStore ) , <NEW_LINE> mKeyRange ( aKeyRange ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( aKeyRange , "Null key range ! " ) ; <NEW_LINE> } <NEW_LINE> ~ GetHelper ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( mCloneReadInfo . mCloneBuffer ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> virtual nsresult DoDatabaseWork ( mozIStorageConnection * aConnection ) <NEW_LINE> MOZ_OVERRIDE ; <NEW_LINE> virtual nsresult GetSuccessResult ( JSContext * aCx , <NEW_LINE> jsval * aVal ) MOZ_OVERRIDE ;
{ <NEW_LINE> HttpConn * conn ; <NEW_LINE> MprBuf * buf ; <NEW_LINE> <START_VULN> char * endHeaders , * headers , * key , * value , * junk ; <NEW_LINE> <END_VULN> ssize blen ; <NEW_LINE> int len ;
void PageImportanceSignalsChanged ( ) override ; <NEW_LINE> void DidAutoResize ( const blink::WebSize & newSize ) override ; <NEW_LINE> blink::WebRect RootWindowRect ( ) override ; <NEW_LINE> <START_VULN> void DidFocus ( ) override ; <NEW_LINE> <END_VULN> #if defined ( OS_ANDROID )
nsCOMPtr < nsIPrincipal > mSystemPrincipal ; <NEW_LINE> nsCOMPtr < nsIXPConnectJSObjectHolder > mLoaderGlobal ; <NEW_LINE> JSRuntime * mRuntime ; <NEW_LINE> JSContext * mContext ; <NEW_LINE> class ModuleEntry : public mozilla::Module <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> <START_VULN> ModuleEntry ( ) : mozilla::Module ( ) { <NEW_LINE> <END_VULN> mVersion = mozilla::Module::kVersion ; <NEW_LINE> mCIDs = nullptr ; <NEW_LINE> mContractIDs = nullptr ; <NEW_LINE> mCategoryEntries = nullptr ; <NEW_LINE> getFactoryProc = GetFactory ; <NEW_LINE> loadProc = nullptr ; <NEW_LINE> unloadProc = nullptr ;
nscoord min = borderPadding . TopBottom ( ) + mLegendRect . height ; <NEW_LINE> aDesiredSize . height = <NEW_LINE> aReflowState . ComputedHeight ( ) + borderPadding . TopBottom ( ) ; <NEW_LINE> if ( aDesiredSize . height < min ) <NEW_LINE> aDesiredSize . height = min ; <NEW_LINE> } <NEW_LINE> aDesiredSize . width = contentRect . width + borderPadding . LeftRight ( ) ; <NEW_LINE> aDesiredSize . SetOverflowAreasToDesiredBounds ( ) ; <NEW_LINE> <START_VULN> if ( mLegendFrame ) <NEW_LINE>ConsiderChildOverflow ( aDesiredSize . mOverflowAreas , mLegendFrame ) ; <NEW_LINE>if ( mContentFrame ) <NEW_LINE>ConsiderChildOverflow ( aDesiredSize . mOverflowAreas , mContentFrame ) ; <NEW_LINE> <END_VULN> aDesiredSize . mOverflowAreas . UnionWith ( ocBounds ) ; <NEW_LINE> NS_MergeReflowStatusInto ( & aStatus , ocStatus ) ; <NEW_LINE> FinishReflowWithAbsoluteFrames ( aPresContext , aDesiredSize , aReflowState , aStatus ) ; <NEW_LINE> InvalidateFrame ( ) ;
if ( ! FindReplaceLength ( cx , res , rdata , & replen ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> size_t growth = leftlen + replen ; <NEW_LINE>if ( ! rdata . sb . reserve ( rdata . sb . length ( ) + growth ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> rdata . sb . infallibleAppend ( left , leftlen ) ; <NEW_LINE> DoReplace ( cx , res , rdata ) ;
ok = js_XDRScript ( xdr , & script , & hasMagic ) ; <NEW_LINE> if ( ! ok ) <NEW_LINE> goto out ; <NEW_LINE> if ( ! hasMagic ) { <NEW_LINE> * vp = JSVAL_FALSE ; <NEW_LINE> goto out ; <NEW_LINE> } <NEW_LINE> JS_LOCK_OBJ ( cx , obj ) ; <NEW_LINE> <START_VULN> execDepth = GetScriptExecDepth ( cx , obj ) ; <NEW_LINE> <END_VULN> if ( execDepth > 0 ) { <NEW_LINE> JS_UNLOCK_OBJ ( cx , obj ) ; <NEW_LINE> JS_ReportErrorNumber ( cx , js_GetErrorMessage , NULL , <NEW_LINE> JSMSG_COMPILE_EXECED_SCRIPT ) ;
unsigned int nBufferIndex ; <NEW_LINE> DEBUG_PRINT_LOW ( "ETB: buffer = % p , buffer -> pBuffer [ % p ] " , buffer , buffer -> pBuffer ) ; <NEW_LINE> <START_VULN> if ( m_state == OMX_StateInvalid ) { <NEW_LINE> <END_VULN> DEBUG_PRINT_ERROR ( "ERROR: Empty this buffer in Invalid State" ) ; <NEW_LINE> return OMX_ErrorInvalidState ; <NEW_LINE> }
end: <NEW_LINE> if ( TRUE == local_tx_started ) { <NEW_LINE> <START_VULN> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> DBG_INF ( ret == PASS ? "PASS":"FAIL" ) ; <NEW_LINE> DBG_RETURN ( ret ) ;
if ( stack -> elements ) { <NEW_LINE> for ( i = 0 ; i < stack -> top ; i ++ ) { <NEW_LINE> <START_VULN> if ( ( ( st_entry * ) stack -> elements [ i ] ) -> data ) { <NEW_LINE> <END_VULN> zval_ptr_dtor ( & ( ( st_entry * ) stack -> elements [ i ] ) -> data ) ; <NEW_LINE> } <NEW_LINE> if ( ( ( st_entry * ) stack -> elements [ i ] ) -> varname ) {
return ( png_uint_16 ) val ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> void
int enabled_val = atoi ( env_val ) ; <NEW_LINE> if ( ! enabled_val ) <NEW_LINE> return false ; <NEW_LINE> for ( size_t i = 0 ; i < testEVInfos -> Length ( ) ; ++ i ) { <NEW_LINE> nsMyTrustedEVInfoClass * ev = testEVInfos -> ElementAt ( i ) ; <NEW_LINE> if ( ! ev ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> if ( policyOIDTag == ev -> oid_tag ) <NEW_LINE>CERT_AddCertToListTail ( certList , CERT_DupCertificate ( ev -> cert ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> static bool <NEW_LINE> isEVPolicy ( SECOidTag policyOIDTag )
xmlErrMemory ( ctxt , "dictionary allocation failure" ) ; <NEW_LINE> if ( ( attvalue != NULL ) && ( alloc != 0 ) ) <NEW_LINE> xmlFree ( attvalue ) ; <NEW_LINE> <START_VULN> return ( NULL ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( * URL != 0 ) { <NEW_LINE> uri = xmlParseURI ( ( const char * ) URL ) ;
#ifdef PNG_READ_tEXt_SUPPORTED <NEW_LINE> else if ( chunk_name == png_tEXt ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_tEXt ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
int ji ; <NEW_LINE> for ( ITERATE_CONFIG ( route , prop , child , ji ) ) { <NEW_LINE> <START_VULN> password = mprGetJson ( child , "password" ) ; <NEW_LINE>roles = getList ( mprGetJsonObj ( child , "roles" ) ) ; <NEW_LINE> <END_VULN> if ( httpAddUser ( route -> auth , child -> name , password , roles ) < 0 ) { <NEW_LINE> httpParseError ( route , "Cannot add user % s" , child -> name ) ; <NEW_LINE> break ;
} <NEW_LINE> } else if ( ! strncmp ( argv [ i ] , " - protos" , 7 ) ) { <NEW_LINE> nflags ++ ; <NEW_LINE> <START_VULN> ret = sscanf ( argv [ i ] + 1 , "protos = % s" , buf ) ; <NEW_LINE> <END_VULN> if ( ret != 1 ) { <NEW_LINE> fprintf ( stderr , "parse failure for protos\n" ) ; <NEW_LINE> return 1 ;
next ( NULL ) , <NEW_LINE> peer ( NULL ) , <NEW_LINE> globalObj ( _globalObj ) , <NEW_LINE> globalShape ( _globalShape ) , <NEW_LINE> argc ( _argc ) , <NEW_LINE> dependentTrees ( alloc ) , <NEW_LINE> linkedTrees ( alloc ) , <NEW_LINE> sideExits ( alloc ) , <NEW_LINE> gcthings ( alloc ) , <NEW_LINE> <START_VULN> shapes ( alloc ) <NEW_LINE> <END_VULN> { } <NEW_LINE> TreeFragment * first ; <NEW_LINE> TreeFragment * next ; <NEW_LINE> TreeFragment * peer ; <NEW_LINE> JSObject * globalObj ; <NEW_LINE> uint32 globalShape ; <NEW_LINE> uint32 argc ;
return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1142 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy76: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych == 'N' ) goto yy73 ;
* <NEW_LINE> BOOL <NEW_LINE> WriteStatusPending ( LPCWSTR updateDirPath ) <NEW_LINE> { <NEW_LINE> <START_VULN> WCHAR updateStatusFilePath [ MAX_PATH + 1 ] ; <NEW_LINE>wcscpy ( updateStatusFilePath , updateDirPath ) ; <NEW_LINE> <END_VULN> if ( ! PathAppendSafe ( updateStatusFilePath , L"update . status" ) ) { <NEW_LINE> return FALSE ; <NEW_LINE> } <NEW_LINE> const char pending [ ] = "pending" ; <NEW_LINE> HANDLE statusFile = CreateFileW ( updateStatusFilePath , GENERIC_WRITE , 0 , <NEW_LINE> NULL , CREATE_ALWAYS , 0 , NULL ) ; <NEW_LINE> if ( statusFile == INVALID_HANDLE_VALUE ) {
FinishRuntimeScriptState ( rt ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static const char * <NEW_LINE> <END_VULN> SaveScriptFilename ( JSContext * cx , const char * filename ) <NEW_LINE> { <NEW_LINE> JSRuntime * rt = cx -> runtime ;
} <NEW_LINE> err = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , copied ) ; <NEW_LINE> <START_VULN> if ( ! err ) { <NEW_LINE>if ( sat ) { <NEW_LINE>sat -> sat_family = AF_APPLETALK ; <NEW_LINE>sat -> sat_port = ddp -> deh_sport ; <NEW_LINE>sat -> sat_addr . s_node = ddp -> deh_snode ; <NEW_LINE>sat -> sat_addr . s_net = ddp -> deh_snet ; <NEW_LINE> } <NEW_LINE>msg -> msg_namelen = sizeof ( * sat ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> skb_free_datagram ( sk , skb ) ;
{ <NEW_LINE> png_debug ( 1 , "in png_set_background_fixed" ) ; <NEW_LINE> <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) || background_color == NULL ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> if ( background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN )
( void ) png_colorspace_set_sRGB ( png_ptr , & png_ptr -> colorspace , intent ) ; <NEW_LINE> png_colorspace_sync ( png_ptr , info_ptr ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_READ_iCCP_SUPPORTED <NEW_LINE> void
assert ( image -> signature == MagickSignature ) ; <NEW_LINE> if ( image -> debug != MagickFalse ) <NEW_LINE> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , " % s" , image -> filename ) ; <NEW_LINE> <START_VULN> assert ( exception != ( ExceptionInfo * ) NULL ) ; <NEW_LINE>assert ( exception -> signature == MagickSignature ) ; <NEW_LINE>status = OpenBlob ( image_info , image , WriteBinaryBlobMode , exception ) ; <NEW_LINE> <END_VULN> if ( status == MagickFalse ) <NEW_LINE> return ( status ) ; <NEW_LINE> ( void ) TransformImageColorspace ( image , sRGBColorspace ) ;
INTERFRAME = 1 , <NEW_LINE> } ; <NEW_LINE> <START_VULN> bool IsKeyframe ( ) const ; <NEW_LINE>bool RefreshFlag ( size_t i ) const { return ! ! ( refresh_flags & ( 1u << i ) ) ; } <NEW_LINE> <END_VULN> uint8_t profile ;
switch ( * mode ) <NEW_LINE> { <NEW_LINE> case 'a' : <NEW_LINE> <START_VULN> fd = open ( filename , O_RDWR | O_CREAT | O_APPEND | O_LARGEFILE | O_BINARY , 0666 ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 'r' :
JS_ASSERT ( tracecx -> bailExit ) ; <NEW_LINE> tm -> tracecx = NULL ; <NEW_LINE> tm -> prohibitFlush ++ ; <NEW_LINE> debug_only_v ( printf ( "Deep bail . \n" ) ; ) <NEW_LINE> LeaveTree ( * tracecx -> interpState , tracecx -> bailExit ) ; <NEW_LINE> tracecx -> bailExit = NULL ; <NEW_LINE> <START_VULN> tracecx -> interpState -> builtinStatus |= JSBUILTIN_BAILED ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_REQUIRES_STACK jsval & <NEW_LINE> TraceRecorder::argval ( unsigned n ) const <NEW_LINE> { <NEW_LINE> JS_ASSERT ( n < cx -> fp -> fun -> nargs ) ; <NEW_LINE> return cx -> fp -> argv [ n ] ; <NEW_LINE> }
if ( ! slot ) <NEW_LINE> goto out ; <NEW_LINE> <START_VULN> if ( ioctl ( slot -> fd , FIONREAD , size ) == 0 ) { <NEW_LINE> <END_VULN> ret = true ; <NEW_LINE> } else { <NEW_LINE> LOG_ERROR ( " % s unable to determine bytes remaining to be read on fd % d: % s" , __func__ , slot -> fd , strerror ( errno ) ) ;
switch ( unit ) { <NEW_LINE> case eCSSUnit_Counter: aResult . AppendLiteral ( "counter ( " ) ; break ; <NEW_LINE> case eCSSUnit_Counters: aResult . AppendLiteral ( "counters ( " ) ; break ; <NEW_LINE> default: break ; <NEW_LINE> } <NEW_LINE> nsCSSValue::Array * array = aValue . GetArrayValue ( ) ; <NEW_LINE> PRBool mark = PR_FALSE ; <NEW_LINE> <START_VULN> for ( PRUint16 i = 0 , i_end = array -> Count ( ) ; i < i_end ; ++ i ) { <NEW_LINE> <END_VULN> if ( aProperty == eCSSProperty_border_image && i >= 5 ) { <NEW_LINE> if ( array -> Item ( i ) . GetUnit ( ) == eCSSUnit_Null ) { <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> if ( i == 5 ) { <NEW_LINE> aResult . AppendLiteral ( " / " ) ; <NEW_LINE> } <NEW_LINE> }
if ( ! WriteEbmlElement ( writer , kMkvTrackType , type_ ) ) <NEW_LINE> return false ; <NEW_LINE> if ( max_block_additional_id_ ) { <NEW_LINE> <START_VULN> if ( ! WriteEbmlElement ( writer , <NEW_LINE>kMkvMaxBlockAdditionID , <NEW_LINE> <END_VULN> max_block_additional_id_ ) ) { <NEW_LINE> return false ; <NEW_LINE> }
void <NEW_LINE> xsltGenerateIdFunction ( xmlXPathParserContextPtr ctxt , int nargs ) { <NEW_LINE> xmlNodePtr cur = NULL ; <NEW_LINE> long val ; <NEW_LINE> xmlChar str [ 30 ] ; <NEW_LINE> xmlDocPtr doc ; <NEW_LINE> if ( nargs == 0 ) { <NEW_LINE> cur = ctxt -> context -> node ; <NEW_LINE> } else if ( nargs == 1 ) { <NEW_LINE> <START_VULN> xmlXPathObjectPtr obj ; <NEW_LINE> <END_VULN> xmlNodeSetPtr nodelist ; <NEW_LINE> int i , ret ;
png_ptr -> background_gamma_type = PNG_BACKGROUND_GAMMA_FILE ; <NEW_LINE> png_ptr -> transformations &= ~ PNG_BACKGROUND_EXPAND ; <NEW_LINE> <START_VULN> if ( png_ptr -> transformations & PNG_COMPOSE ) <NEW_LINE> <END_VULN> png_error ( png_ptr , <NEW_LINE> "conflicting calls to set alpha mode and background" ) ;
masm . loadPtr ( Address ( object ( ) , TypedArray::dataOffset ( ) ) , elementReg ) ; <NEW_LINE> int width = TypedArray::slotWidth ( arrayType ) ; <NEW_LINE> BaseIndex source ( elementReg , indexReg , ScaleFromElemWidth ( width ) ) ; <NEW_LINE> if ( output ( ) . hasValue ( ) ) <NEW_LINE> <START_VULN> masm . loadFromTypedArray ( arrayType , source , output ( ) . valueReg ( ) , true , <NEW_LINE> <END_VULN> elementReg , & popAndFail ) ; <NEW_LINE> else <NEW_LINE> masm . loadFromTypedArray ( arrayType , source , output ( ) . typedReg ( ) , <NEW_LINE> elementReg , & popAndFail ) ; <NEW_LINE> masm . pop ( object ( ) ) ; <NEW_LINE> attacher . jumpRejoin ( masm ) ;
jsval rval = JSVAL_VOID ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> if ( ! pusher . Push ( mContext , true ) ) <NEW_LINE> <END_VULN> return NS_ERROR_FAILURE ; <NEW_LINE> rv = sSecurityManager -> CheckFunctionAccess ( mContext , aHandler , target ) ; <NEW_LINE> nsJSContext::TerminationFuncHolder holder ( this ) ; <NEW_LINE> if ( NS_SUCCEEDED ( rv ) ) {
#endif <NEW_LINE> <START_VULN> typedef png_libpng_version_1_6_10 Your_png_h_is_not_version_1_6_10 ; <NEW_LINE> <END_VULN>
break ; <NEW_LINE> case GF_EVENT_NAVIGATE: <NEW_LINE> if ( gf_term_is_supported_url ( term , evt -> navigate . to_url , 1 , no_mime_check ) ) { <NEW_LINE> <START_VULN> strcpy ( the_url , evt -> navigate . to_url ) ; <NEW_LINE> <END_VULN> fprintf ( stderr , "Navigating to URL % s\n" , the_url ) ; <NEW_LINE> gf_term_navigate_to ( term , evt -> navigate . to_url ) ; <NEW_LINE> return 1 ;
nsCOMPtr < nsIPrincipal > ownerPrincipal ( do_QueryInterface ( aOwner ) ) ; <NEW_LINE> if ( URIIsLocalFile ( aURI ) && ownerPrincipal && <NEW_LINE> NS_SUCCEEDED ( ownerPrincipal -> CheckMayLoad ( aURI , PR_FALSE ) ) ) { <NEW_LINE> <START_VULN> channel -> SetOwner ( aOwner ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsCOMPtr < nsIScriptChannel > scriptChannel = do_QueryInterface ( channel ) ; <NEW_LINE> if ( scriptChannel ) { <NEW_LINE> scriptChannel -> <NEW_LINE> SetExecutionPolicy ( nsIScriptChannel::EXECUTE_NORMAL ) ; <NEW_LINE> }
bool isWritingModeRoot ( ) const { return ! parent ( ) || parent ( ) -> style ( ) -> writingMode ( ) != style ( ) -> writingMode ( ) ; } <NEW_LINE> <START_VULN> bool isDeprecatedFlexItem ( ) const { return ! isInline ( ) && ! isFloatingOrPositioned ( ) && parent ( ) && parent ( ) -> isDeprecatedFlexibleBox ( ) ; } <NEW_LINE> <END_VULN> virtual LayoutUnit lineHeight ( bool firstLine , LineDirectionMode , LinePositionMode = PositionOnContainingLine ) const ; <NEW_LINE> virtual LayoutUnit baselinePosition ( FontBaseline , bool firstLine , LineDirectionMode , LinePositionMode = PositionOnContainingLine ) const ;
if ( ! beforeChild ) <NEW_LINE> beforeChild = afterPseudoElementRenderer ( ) ; <NEW_LINE> <START_VULN> bool wrapInAnonymousSection = ! child -> isPositioned ( ) ; <NEW_LINE> <END_VULN> if ( child -> isTableCaption ( ) ) { <NEW_LINE> m_captions . append ( toRenderTableCaption ( child ) ) ;
<START_VULN> if ( ( fd = accept ( sfd , ( struct sockaddr * ) & remote , & len ) ) == - 1 ) <NEW_LINE> <END_VULN> { <NEW_LINE> BTIF_TRACE_ERROR ( "sock accept failed ( % s ) " , strerror ( errno ) ) ; <NEW_LINE> return - 1 ;
best_address = in_what ; <NEW_LINE> <START_VULN> bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , 0x7fffffff ) <NEW_LINE> + mvsad_err_cost ( best_mv , & fcenter_mv , <NEW_LINE>mvjsadcost , mvsadcost , sad_per_bit ) ; <NEW_LINE> <END_VULN> i = 1 ;
} <NEW_LINE> mFailedChannel = nullptr ; <NEW_LINE> mFailedURI = nullptr ; <NEW_LINE> } <NEW_LINE> if ( nsIWebNavigation::STOP_CONTENT & aStopFlags ) { <NEW_LINE> <START_VULN> if ( mContentViewer ) <NEW_LINE>mContentViewer -> Stop ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( nsIWebNavigation::STOP_NETWORK & aStopFlags ) { <NEW_LINE> if ( mRefreshURIList ) { <NEW_LINE> SuspendRefreshURIs ( ) ; <NEW_LINE> mSavedRefreshURIList . swap ( mRefreshURIList ) ;
} <NEW_LINE> return ; <NEW_LINE> <START_VULN> trunc: <NEW_LINE>ND_PRINT ( ( ndo , " [ ndp opt ] " ) ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> #undef ECHECK <NEW_LINE> }
break ; <NEW_LINE> case EFFECT_CMD_DISABLE: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> } <NEW_LINE> if ( pDownmixer -> state != DOWNMIX_STATE_ACTIVE ) {
goto err ; <NEW_LINE> <START_VULN> <NEW_LINE>goto decryption_failed_or_bad_record_mac ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef TLS_DEBUG
nsJSContext::BindCompiledEventHandler ( nsISupports * aTarget , JSObject * aScope , <NEW_LINE> JSObject * aHandler , <NEW_LINE> nsScriptObjectHolder < JSObject > & aBoundHandler ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_ARG ( aHandler ) ; <NEW_LINE> NS_ENSURE_TRUE ( mIsInitialized , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE> NS_PRECONDITION ( ! aBoundHandler , "Shouldn't already have a bound handler ! " ) ; <NEW_LINE> <START_VULN> JSAutoRequest ar ( mContext ) ; <NEW_LINE> <END_VULN> xpc_UnmarkGrayObject ( aScope ) ; <NEW_LINE> xpc_UnmarkGrayObject ( aHandler ) ; <NEW_LINE> JSObject * target = nsnull ; <NEW_LINE> nsresult rv = JSObjectFromInterface ( aTarget , aScope , & target ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> #ifdef DEBUG <NEW_LINE> {
NS_IMETHODIMP <NEW_LINE> nsCanvasRenderingContext2D::GetCanvas ( nsIDOMHTMLCanvasElement ** canvas ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( mCanvasElement == nsnull ) { <NEW_LINE> * canvas = nsnull ; <NEW_LINE>return NS_OK ; <NEW_LINE> } <NEW_LINE><NEW_LINE>NS_ADDREF ( * canvas = static_cast < nsIDOMHTMLCanvasElement * > ( mCanvasElement ) ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> }
mpls_print ( ndo , p , l2info . length ) ; <NEW_LINE> return l2info . header_len ; <NEW_LINE> case JUNIPER_LSQ_L3_PROTO_ISO: <NEW_LINE> <START_VULN> isoclns_print ( ndo , p , l2info . length , l2info . caplen ) ; <NEW_LINE> <END_VULN> return l2info . header_len ; <NEW_LINE> default: <NEW_LINE> break ;
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> session -> payload = new_payload ; <NEW_LINE>memcpy ( ( session -> payload + session -> payload_len ) , ( * payload ) , ( * payload_len ) ) ; <NEW_LINE>session -> payload_len += * payload_len ; <NEW_LINE> <END_VULN> if ( ! fin && session -> reconstruct && ( session -> payload_len < session -> reconstruct ) ) {
TaskRunnerHelper::Get ( TaskType::kMediaElementEvent , <NEW_LINE> Context ( ) -> GetExecutionContext ( ) ) <NEW_LINE> <START_VULN> -> PostTask ( BLINK_FROM_HERE , <NEW_LINE>CrossThreadBind ( <NEW_LINE> & ScriptProcessorHandler::FireProcessEvent , <NEW_LINE>CrossThreadUnretained ( this ) , double_buffer_index_ ) ) ; <NEW_LINE> <END_VULN> } else {
pc = pc + 1 ; <NEW_LINE> break ; <NEW_LINE> default: <NEW_LINE> <START_VULN> return 0 ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
if ( ! ( cipher = EVP_get_cipherbyname ( name ) ) ) { <NEW_LINE> ossl_raise ( rb_eRuntimeError , "unsupported cipher algorithm ( % "PRIsVALUE" ) " , str ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 ) <NEW_LINE> <END_VULN> ossl_raise ( eCipherError , NULL ) ; <NEW_LINE> return self ;
lzx -> intel_started = 1 ; <NEW_LINE> <START_VULN> ENSURE_BITS ( 16 ) ; <NEW_LINE>if ( bits_left > 16 ) i_ptr - = 2 ; <NEW_LINE> <END_VULN> bits_left = 0 ; bit_buffer = 0 ;
png_set_filter ( png_ptr , PNG_FILTER_TYPE_BASE , filters ) ; <NEW_LINE> { <NEW_LINE> <START_VULN> int passes = png_set_interlace_handling ( png_ptr ) ; <NEW_LINE> <END_VULN> int pass ; <NEW_LINE> png_size_t rowbytes = png_get_rowbytes ( png_ptr , info_ptr ) ;
#ifdef PNG_READ_sPLT_SUPPORTED <NEW_LINE> PNG_INTERNAL_FUNCTION ( void , png_handle_sPLT , ( png_structrp png_ptr , <NEW_LINE> png_inforp info_ptr , png_uint_32 length ) , PNG_EMPTY ) ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_READ_sRGB_SUPPORTED <NEW_LINE> PNG_INTERNAL_FUNCTION ( void , png_handle_sRGB , ( png_structrp png_ptr ,
mMessageManager -> SetCallback ( mRemoteBrowserShown ? this : nullptr ) ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsIScriptContext * sctx = mOwnerContent -> GetContextForEventHandlers ( & rv ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> NS_ENSURE_STATE ( sctx ) ; <NEW_LINE> <START_VULN> JSContext * cx = sctx -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_STATE ( cx ) ; <NEW_LINE> nsCOMPtr < nsIDOMChromeWindow > chromeWindow = <NEW_LINE> do_QueryInterface ( GetOwnerDoc ( ) -> GetWindow ( ) ) ; <NEW_LINE> nsCOMPtr < nsIMessageBroadcaster > parentManager ; <NEW_LINE> if ( chromeWindow ) { <NEW_LINE> chromeWindow -> GetMessageManager ( getter_AddRefs ( parentManager ) ) ; <NEW_LINE> }
for ( i = left_contexts ; i < tx_size_in_blocks ; ++ i ) <NEW_LINE> l [ i ] = 0 ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> vpx_memset ( l , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
} <NEW_LINE> JSObject * global = GetParentObject ( ) ; <NEW_LINE> NS_ASSERTION ( global , "This should never be null ! " ) ; <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoEnterCompartment ac ; <NEW_LINE> if ( ac . enter ( cx , global ) ) { <NEW_LINE> <START_VULN> RootResultVal ( ) ; <NEW_LINE> <END_VULN> rv = aHelper -> GetSuccessResult ( cx , & mResultVal ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> NS_WARNING ( "GetSuccessResult failed ! " ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> NS_WARNING ( "Failed to enter correct compartment ! " ) ;
} <NEW_LINE> static vpx_codec_err_t ctrl_set_postproc ( vpx_codec_alg_priv_t * ctx , <NEW_LINE> <START_VULN> int ctr_id , va_list args ) { <NEW_LINE> <END_VULN> #if CONFIG_VP9_POSTPROC <NEW_LINE> vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: basic shared codebook operations <NEW_LINE> <START_VULN> last mod: $ Id: codebook . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_CODEBOOK_H_ <NEW_LINE> #define _V_CODEBOOK_H_ <NEW_LINE> #include < ogg / ogg . h >
text . lang = NULL ; <NEW_LINE> text . lang_key = NULL ; <NEW_LINE> <START_VULN> if ( png_set_text_2 ( png_ptr , info_ptr , & text , 1 ) ) <NEW_LINE> <END_VULN> errmsg = "insufficient memory" ; <NEW_LINE> }
if ( pCmdData == NULL || <NEW_LINE> <START_VULN> <NEW_LINE>cmdSize > ( sizeof ( effect_param_t ) + sizeof ( int32_t ) + sizeof ( int32_t ) ) || <NEW_LINE>cmdSize < ( sizeof ( effect_param_t ) + sizeof ( int32_t ) + sizeof ( int16_t ) ) || <NEW_LINE>pReplyData == NULL || <NEW_LINE> * replySize != sizeof ( int32_t ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Virtualizer_command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_SET_PARAM: ERROR" ) ; <NEW_LINE> return - EINVAL ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: #ifdef jail to whip a few platforms into the UNIX ideal . <NEW_LINE> <START_VULN> last mod: $ Id: os_types . h 16649 2009 - 10 - 25 00:49:58Z ds $ <NEW_LINE> <END_VULN> #ifndef _OS_TYPES_H <NEW_LINE> #define _OS_TYPES_H <NEW_LINE> different malloc than stdlib * / <NEW_LINE> #define _ogg_malloc malloc
const bool isIncrementalInsertion = false ) ; <NEW_LINE> static void insertText ( Document & , <NEW_LINE> const String & , <NEW_LINE> <START_VULN> const VisibleSelection & , <NEW_LINE> <END_VULN> Options , <NEW_LINE> TextCompositionType = TextCompositionNone , <NEW_LINE> const bool isIncrementalInsertion = false ) ;
if ( ! strncmp ( prop_chunk , "SND " , 4 ) ) { <NEW_LINE> char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; <NEW_LINE> uint16_t numChannels = 0 , chansSpecified , chanMask = 0 ; <NEW_LINE> <START_VULN> uint32_t sampleRate ; <NEW_LINE> <END_VULN> while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { <NEW_LINE> memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> void vp9_choose_segmap_coding_method ( VP9_COMP * cpi ) { <NEW_LINE>VP9_COMMON * const cm = & cpi -> common ; <NEW_LINE> <END_VULN> struct segmentation * seg = & cm -> seg ; <NEW_LINE> int no_pred_cost ;
<START_VULN> #ifndef CHROME_RENDERER_DEVTOOLS_AGENT_FILTER_H_ <NEW_LINE>#define CHROME_RENDERER_DEVTOOLS_AGENT_FILTER_H_ <NEW_LINE> <END_VULN> #pragma once <NEW_LINE> #include < string >
} else if ( style . IsCanvasPattern ( ) ) { <NEW_LINE> CanvasPattern * canvas_pattern = style . GetAsCanvasPattern ( ) ; <NEW_LINE> <START_VULN> if ( OriginClean ( ) && ! canvas_pattern -> OriginClean ( ) ) { <NEW_LINE>SetOriginTainted ( ) ; <NEW_LINE>ClearResolvedFilters ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( canvas_pattern -> GetPattern ( ) -> IsTextureBacked ( ) ) <NEW_LINE> DisableDeferral ( kDisableDeferralReasonUsingTextureBackedPattern ) ;
event . code = code ; <NEW_LINE> event . value = value ; <NEW_LINE> <START_VULN> return write ( fd , & event , sizeof ( event ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void send_key ( int fd , uint16_t key , int pressed )
ZVAL_STRINGL ( * rval , str , len , 1 ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 971 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy53: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' / ' ) {
_y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h <NEW_LINE> + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * <NEW_LINE> ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ; <NEW_LINE> <START_VULN> _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ; <NEW_LINE>_y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
size = 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( color_type & PNG_COLOR_MASK_ALPHA ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( sbit -> alpha == 0 || sbit -> alpha > png_ptr -> usr_bit_depth ) <NEW_LINE> {
for ( zend_hash_internal_pointer_reset ( hash_arr ) ; <NEW_LINE> zend_hash_has_more_elements ( hash_arr ) == SUCCESS ; <NEW_LINE> zend_hash_move_forward ( hash_arr ) ) { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_hash_get_current_data ( hash_arr , ( void ** ) & ele_value ) == FAILURE ) { <NEW_LINE> continue ;
{ <NEW_LINE> BTIF_TRACE_DEBUG ( "app_idx = % d mcl_idx = 0x % x mdl_idx = 0x % x data_size = % d" , <NEW_LINE> app_idx , mcl_idx , mdl_idx , data_size ) ; <NEW_LINE> <START_VULN> r = send ( p_dcb -> p_scb -> socket_id [ 1 ] , p_dcb -> p_rx_pkt , data_size , 0 ) ; <NEW_LINE> <END_VULN> if ( r == data_size ) <NEW_LINE> {
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File: readelf . c , v 1 . 156 2018 / 10 / 19 00:33:04 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef BUILTIN_ELF
} <NEW_LINE> else { <NEW_LINE> for ( RenderBox * curr = firstChildBox ( ) ; curr ; curr = curr -> nextSiblingBox ( ) ) { <NEW_LINE> <START_VULN> if ( ! curr -> isFloatingOrPositioned ( ) ) { <NEW_LINE> <END_VULN> LayoutUnit result = curr -> firstLineBoxBaseline ( ) ; <NEW_LINE> if ( result != - 1 ) <NEW_LINE> return curr -> logicalTop ( ) + result ;
#undef mem_put_be16 <NEW_LINE> #define mem_put_be16 mem_ops_wrap_symbol ( mem_put_be16 ) <NEW_LINE> <START_VULN> static void mem_put_be16 ( void * vmem , MEM_VALUE_T val ) { <NEW_LINE> <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; <NEW_LINE> mem [ 0 ] = ( val >> 8 ) & 0xff ;
d -> m_lastUserEventTimestamp = currentTime ( ) ; <NEW_LINE> <START_VULN> Platform::TouchPoint tPoint = point ; <NEW_LINE>tPoint . m_pos = d -> mapFromTransformed ( tPoint . m_pos ) ; <NEW_LINE><NEW_LINE>d -> m_touchEventHandler -> handleTouchPoint ( tPoint , modifiers ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void WebPage::playSoundIfAnchorIsTarget ( ) const
{ <NEW_LINE> FT_ASSERT ( cur [ 0 ] -> clazz ) ; <NEW_LINE> <START_VULN> if ( cur [ 0 ] -> clazz -> get_interface ) <NEW_LINE> <END_VULN> { <NEW_LINE> result = cur [ 0 ] -> clazz -> get_interface ( cur [ 0 ] , service_id ) ; <NEW_LINE> if ( result != NULL )
T * reset ( size_t count = 0 ) { <NEW_LINE> sk_free ( fPtr ) ; <NEW_LINE> <START_VULN> fPtr = count ? ( T * ) sk_malloc_flags ( count * sizeof ( T ) , SK_MALLOC_THROW ) : nullptr ; <NEW_LINE> <END_VULN> return fPtr ; <NEW_LINE> }
#include "WrapperFactory . h" <NEW_LINE> class nsIPrincipal ; <NEW_LINE> namespace xpc { <NEW_LINE> class AccessCheck { <NEW_LINE> public: <NEW_LINE> <START_VULN> static bool isSameOrigin ( JSCompartment * a , JSCompartment * b ) ; <NEW_LINE> <END_VULN> static bool isChrome ( JSCompartment * compartment ) ; <NEW_LINE> static bool callerIsChrome ( ) ; <NEW_LINE> static nsIPrincipal * getPrincipal ( JSCompartment * compartment ) ; <NEW_LINE> static bool isCrossOriginAccessPermitted ( JSContext * cx , JSObject * obj , jsid id , <NEW_LINE> js::Wrapper::Action act ) ; <NEW_LINE> static bool isSystemOnlyAccessPermitted ( JSContext * cx ) ; <NEW_LINE> static bool isLocationObjectSameOrigin ( JSContext * cx , JSObject * wrapper ) ; <NEW_LINE> static bool documentDomainMakesSameOrigin ( JSContext * cx , JSObject * obj ) ;
if ( ! js_ComputeThis ( cx , argv ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> js_GetTopStackFrame ( cx ) -> thisv = argv [ - 1 ] ; <NEW_LINE> JS_ASSERT ( cx -> fp -> argv == argv ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( argc != 0 ) { <NEW_LINE><NEW_LINE>argv [ -- argc ] = JSVAL_VOID ; <NEW_LINE> } <NEW_LINE> <END_VULN> return fs -> call ( cx , JSVAL_TO_OBJECT ( argv [ - 1 ] ) , argc , argv , rval ) ; <NEW_LINE> } <NEW_LINE> JS_END_EXTERN_C <NEW_LINE> JS_PUBLIC_API ( JSBool ) <NEW_LINE> JS_DefineFunctions ( JSContext * cx , JSObject * obj , JSFunctionSpec * fs ) <NEW_LINE> {
# endif <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> void <NEW_LINE> png_chunk_report ( png_const_structrp png_ptr , png_const_charp message , int error )
#define _NGINX_H_INCLUDED_ <NEW_LINE> <START_VULN> #define nginx_version 9001 <NEW_LINE>#define NGINX_VERSION "0 . 9 . 1" <NEW_LINE> <END_VULN> #define NGINX_VER "nginx / " NGINX_VERSION <NEW_LINE> #define NGINX_VAR "NGINX"
} <NEW_LINE> n = num_mixer_volumes ++ ; <NEW_LINE> <START_VULN> strcpy ( mixer_vols [ n ] . name , name ) ; <NEW_LINE> <END_VULN> if ( present ) <NEW_LINE> mixer_vols [ n ] . num = n ;
unsigned int mask_4x4_int_l , <NEW_LINE> const loop_filter_info_n * lfi_n , <NEW_LINE> const uint8_t * lfl ) { <NEW_LINE> <START_VULN> const int mask_shift = plane_type ? 4 : 8 ; <NEW_LINE>const int mask_cutoff = plane_type ? 0xf : 0xff ; <NEW_LINE>const int lfl_forward = plane_type ? 4 : 8 ; <NEW_LINE> <END_VULN> unsigned int mask_16x16_0 = mask_16x16_l & mask_cutoff ; <NEW_LINE> unsigned int mask_8x8_0 = mask_8x8_l & mask_cutoff ;
const PRUint32 bpr = sizeof ( PRUint32 ) * mGIFStruct . width ; <NEW_LINE> PRUint8 * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; <NEW_LINE> PRUint8 * from = rowp + mGIFStruct . width ; <NEW_LINE> PRUint32 * to = ( ( PRUint32 * ) rowp ) + mGIFStruct . width ; <NEW_LINE> PRUint32 * cmap = mColormap ; <NEW_LINE> <START_VULN> for ( PRUint32 c = mGIFStruct . width ; c > 0 ; c -- ) { <NEW_LINE> * -- to = cmap [ * -- from ] ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( mGIFStruct . is_transparent && ! mSawTransparency ) { <NEW_LINE> const PRUint32 * rgb = ( PRUint32 * ) rowp ; <NEW_LINE> for ( PRUint32 i = mGIFStruct . width ; i > 0 ; i -- ) { <NEW_LINE> if ( * rgb ++ == 0 ) { <NEW_LINE> mSawTransparency = PR_TRUE ;
#define VP8_ENCODER_MCOMP_H_ <NEW_LINE> #include "block . h" <NEW_LINE> <START_VULN> #include "vp8 / common / variance . h" <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> extern "C" {
screen -> columns = ( size_t ) GetDeviceCaps ( hDC , HORZRES ) ; <NEW_LINE> screen -> rows = ( size_t ) GetDeviceCaps ( hDC , VERTRES ) ; <NEW_LINE> screen -> storage_class = DirectClass ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( image == ( Image * ) NULL ) <NEW_LINE> image = screen ; <NEW_LINE> else
ENTROPY_CONTEXT * ta_s ; <NEW_LINE> ENTROPY_CONTEXT * tl_s ; <NEW_LINE> <START_VULN> vpx_memcpy ( & t_above_s , & t_above , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE>vpx_memcpy ( & t_left_s , & t_left , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <NEW_LINE> <END_VULN> ta_s = ( ENTROPY_CONTEXT * ) & t_above_s ; <NEW_LINE> tl_s = ( ENTROPY_CONTEXT * ) & t_left_s ;
int result = getHeightForLineCount ( toRenderBlock ( obj ) , l , false , count ) ; <NEW_LINE> if ( result != - 1 ) <NEW_LINE> return result + obj -> y ( ) + ( includeBottom ? ( block -> borderBottom ( ) + block -> paddingBottom ( ) ) : ZERO_LAYOUT_UNIT ) ; <NEW_LINE> <START_VULN> } <NEW_LINE>else if ( ! obj -> isFloatingOrPositioned ( ) && ! obj -> isRunIn ( ) ) <NEW_LINE> <END_VULN> normalFlowChildWithoutLines = obj ; <NEW_LINE> } <NEW_LINE> if ( normalFlowChildWithoutLines && l == 0 )
return CHANNEL_RC_NO_MEMORY ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! Stream_EnsureRemainingCapacity ( data_in , ( int ) dataLength ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> WLog_Print ( drdynvc -> log , WLOG_ERROR , "Stream_EnsureRemainingCapacity failed ! " ) ; <NEW_LINE> Stream_Free ( drdynvc -> data_in , TRUE ) ;
struct OpenManifestEntryResource { <NEW_LINE> public: <NEW_LINE> <START_VULN> OpenManifestEntryResource ( std::string target_url , <NEW_LINE> <END_VULN> int32_t * descp , <NEW_LINE> ErrorInfo * infop , <NEW_LINE> bool * portablep ,
gplot -> nplots ++ ; <NEW_LINE> <START_VULN> snprintf ( buf , L_BUF_SIZE , " % s . data . % d" , gplot -> rootname , gplot -> nplots ) ; <NEW_LINE> <END_VULN> sarrayAddString ( gplot -> datanames , buf , L_COPY ) ;
vert_band_scale ( temp_area + dest_pitch , dest_pitch , dest , dest_pitch , dest_width ) ; <NEW_LINE> if ( interpolation ) <NEW_LINE> <START_VULN> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ; <NEW_LINE> <END_VULN> source += ( unsigned long ) source_band_height * source_pitch ;
* dst_mv = best_mv ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return bestsme ; <NEW_LINE> } <NEW_LINE> int vp9_full_search_sad_c ( const MACROBLOCK * x , const MV * ref_mv , <NEW_LINE> int sad_per_bit , int distance , <NEW_LINE> const vp9_variance_fn_ptr_t * fn_ptr , <NEW_LINE> <START_VULN> int * mvjcost , int * mvcost [ 2 ] , <NEW_LINE> <END_VULN> const MV * center_mv , MV * best_mv ) { <NEW_LINE> int r , c ; <NEW_LINE> const MACROBLOCKD * const xd = & x -> e_mbd ;
if ( owner == png_IDAT ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> flags & PNG_FLAG_ZLIB_CUSTOM_STRATEGY ) <NEW_LINE> <END_VULN> strategy = png_ptr -> zlib_strategy ; <NEW_LINE> else if ( png_ptr -> do_filter != PNG_FILTER_NONE )
z . sender = 0 ; <NEW_LINE> z . recipient = 0 ; <NEW_LINE> <START_VULN> #define PARSE_STRING \ <NEW_LINE>s = parse_field ( ndo , & parse , & parselen ) ; \ <NEW_LINE> <END_VULN> if ( ! s ) lose = 1 ; <NEW_LINE> #define PARSE_FIELD_INT ( field ) \
return ret ; <NEW_LINE> } <NEW_LINE> <START_VULN> void utf32_to_utf8 ( const char32_t * src , size_t src_len , char * dst ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( src == NULL || src_len == 0 || dst == NULL ) { <NEW_LINE> return ;
{ 149 , 144 , } , <NEW_LINE> } ; <NEW_LINE> <START_VULN> void vp9_init_mode_probs ( FRAME_CONTEXT * fc ) { <NEW_LINE> <END_VULN> vp9_copy ( fc -> uv_mode_prob , default_if_uv_probs ) ; <NEW_LINE> vp9_copy ( fc -> y_mode_prob , default_if_y_probs ) ; <NEW_LINE> vp9_copy ( fc -> switchable_interp_prob , default_switchable_interp_prob ) ;
char * pair , * tok ; <NEW_LINE> pair = stok ( sclone ( buf ) , " & " , & tok ) ; <NEW_LINE> <START_VULN> while ( pair != 0 ) { <NEW_LINE> <END_VULN> mprAddItem ( app -> formData , sclone ( pair ) ) ; <NEW_LINE> pair = stok ( 0 , " & " , & tok ) ; <NEW_LINE> }
for ( i = 0 ; i < vi -> channels ; i ++ ) { <NEW_LINE> int submap = info -> chmuxlist [ i ] ; <NEW_LINE> float * mdct = gmdct [ i ] ; <NEW_LINE> float * res = vb -> pcm [ i ] ; <NEW_LINE> int * ilogmask = ilogmaskch [ i ] = <NEW_LINE> _vorbis_block_alloc ( vb , n / 2 * sizeof ( ** gmdct ) ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> nonzero [ i ] = floor1_encode ( opb , vb , b -> flr [ info -> floorsubmap [ submap ] ] , <NEW_LINE> floor_posts [ i ] [ k ] , <NEW_LINE> ilogmask ) ; <NEW_LINE> #if 0 <NEW_LINE> { <NEW_LINE> char buf [ 80 ] ; <NEW_LINE> sprintf ( buf , "maskI % c % d" , i ? 'R':'L' , k ) ; <NEW_LINE> float work [ n / 2 ] ;
cx = nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE> } <NEW_LINE> mAr . construct ( cx ) ; <NEW_LINE> <START_VULN> if ( ! mCxPusher . Push ( cx , nsCxPusher::ALWAYS_PUSH ) ) { <NEW_LINE> <END_VULN> return ; <NEW_LINE> }
NS_IMETHODIMP <NEW_LINE> nsGlobalChromeWindow::GetMessageManager ( nsIMessageBroadcaster ** aManager ) <NEW_LINE> { <NEW_LINE> FORWARD_TO_INNER_CHROME ( GetMessageManager , ( aManager ) , NS_ERROR_FAILURE ) ; <NEW_LINE> if ( ! mMessageManager ) { <NEW_LINE> nsIScriptContext * scx = GetContextInternal ( ) ; <NEW_LINE> NS_ENSURE_STATE ( scx ) ; <NEW_LINE> <START_VULN> JSContext * cx = scx -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_STATE ( cx ) ; <NEW_LINE> nsCOMPtr < nsIMessageBroadcaster > globalMM = <NEW_LINE> do_GetService ( "@mozilla . org / globalmessagemanager ; 1" ) ; <NEW_LINE> mMessageManager = <NEW_LINE> new nsFrameMessageManager ( nullptr , <NEW_LINE> static_cast < nsFrameMessageManager * > ( globalMM . get ( ) ) , <NEW_LINE> cx , <NEW_LINE> MM_CHROME | MM_BROADCASTER ) ;
txLoadedDocumentEntry * entry = GetEntry ( baseURI ) ; <NEW_LINE> if ( entry ) { <NEW_LINE> delete entry -> mDocument . forget ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> txExecutionState::txExecutionState ( txStylesheet * aStylesheet , <NEW_LINE> PRBool aDisableLoads ) <NEW_LINE> <START_VULN> : mStylesheet ( aStylesheet ) , <NEW_LINE> <END_VULN> mNextInstruction ( nsnull ) , <NEW_LINE> mLocalVariables ( nsnull ) , <NEW_LINE> mRecursionDepth ( 0 ) , <NEW_LINE> mEvalContext ( nsnull ) , <NEW_LINE> mInitialEvalContext ( nsnull ) , <NEW_LINE> mGlobalParams ( nsnull ) , <NEW_LINE> mKeyHash ( aStylesheet -> getKeyMap ( ) ) , <NEW_LINE> mDisableLoads ( aDisableLoads )
bond_dev -> tx_queue_len = 0 ; <NEW_LINE> bond_dev -> flags |= IFF_MASTER | IFF_MULTICAST ; <NEW_LINE> bond_dev -> priv_flags |= IFF_BONDING ; <NEW_LINE> <START_VULN> bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <NEW_LINE> <END_VULN>
} else { <NEW_LINE> use_key_length = max_key_length ; <NEW_LINE> for ( i = 0 ; i < count ; i ++ ) { <NEW_LINE> <START_VULN> if ( key_length_sizes [ i ] >= key_len && <NEW_LINE> <END_VULN> key_length_sizes [ i ] < use_key_length ) <NEW_LINE> { <NEW_LINE> use_key_length = key_length_sizes [ i ] ;
#include "public / platform / WebMediaStreamSource . h" <NEW_LINE> #include "platform / audio / AudioBus . h" <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "platform / mediastream / MediaConstraints . h" <NEW_LINE> #include "public / platform / WebAudioDestinationConsumer . h" <NEW_LINE> #include "public / platform / WebMediaConstraints . h" <NEW_LINE> #include "public / platform / WebString . h"
unsigned char * data = packet -> data + packet -> size ; <NEW_LINE> unsigned int act_size = data_len + ( cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( packet -> size + act_size > MT_PACKET_LEN ) { <NEW_LINE> <END_VULN> fprintf ( stderr , _ ( "add_control_packet: ERROR , too large packet . Exceeds % d bytes\n" ) , MT_PACKET_LEN ) ; <NEW_LINE> return - 1 ;
JSObject * argv5 = JSVAL_TO_OBJECT ( argv [ 5 ] ) ; <NEW_LINE> jsval js_width , js_height , js_data ; <NEW_LINE> JS_GetProperty ( cx , argv5 , "width" , & js_width ) ; <NEW_LINE> JS_GetProperty ( cx , argv5 , "height" , & js_height ) ; <NEW_LINE> JS_GetProperty ( cx , argv5 , "data" , & js_data ) ; <NEW_LINE> if ( js_width == JSVAL_VOID || <NEW_LINE> js_height == JSVAL_VOID || <NEW_LINE> <START_VULN> js_data == JSVAL_VOID ) <NEW_LINE> <END_VULN> { <NEW_LINE> xpc_qsThrowBadArg ( cx , NS_ERROR_FAILURE , vp , 5 ) ; <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> int32_t int_width , int_height ; <NEW_LINE> JSObject * obj_data = JSVAL_TO_OBJECT ( js_data ) ; <NEW_LINE> if ( ! JS_ValueToECMAInt32 ( cx , js_width , & int_width ) || <NEW_LINE> ! JS_ValueToECMAInt32 ( cx , js_height , & int_height ) )
wddx_stack_top ( stack , ( void ** ) & ent2 ) ; <NEW_LINE> <START_VULN> if ( ent2 -> type == ST_FIELD && ent2 -> data == NULL ) { <NEW_LINE> <END_VULN> zval_ptr_dtor ( & ent1 -> data ) ; <NEW_LINE> efree ( ent1 ) ; <NEW_LINE> return ;
beforeChildParent = flow ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( newChild -> isFloatingOrPositioned ( ) ) { <NEW_LINE> <END_VULN> beforeChildParent -> addChildIgnoringContinuation ( newChild , beforeChild ) ; <NEW_LINE> return ; <NEW_LINE> }
void OnReadAsciiText ( ui::Clipboard::Buffer buffer , std::string * result ) ; <NEW_LINE> void OnReadHTML ( ui::Clipboard::Buffer buffer , string16 * markup , GURL * url ) ; <NEW_LINE> void OnReadImage ( ui::Clipboard::Buffer buffer , IPC::Message * reply_msg ) ; <NEW_LINE> <START_VULN> void OnReadImageReply ( SkBitmap bitmap , IPC::Message * reply_msg ) ; <NEW_LINE> <END_VULN> #if defined ( OS_MACOSX ) <NEW_LINE> void OnFindPboardWriteString ( const string16 & text ) ; <NEW_LINE> #endif
nsAutoCString key ; <NEW_LINE> rv = resolvedURI -> GetSpec ( key ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> ModuleEntry * mod ; <NEW_LINE> nsAutoPtr < ModuleEntry > newEntry ; <NEW_LINE> if ( ! mImports . Get ( key , & mod ) && ! mInProgressImports . Get ( key , & mod ) ) { <NEW_LINE> <START_VULN> newEntry = new ModuleEntry ; <NEW_LINE> <END_VULN> if ( ! newEntry ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> mInProgressImports . Put ( key , newEntry ) ; <NEW_LINE> RootedValue exception ( callercx ) ; <NEW_LINE> rv = ObjectForLocation ( sourceLocalFile , resURI , & newEntry -> obj , <NEW_LINE> & newEntry -> thisObjectKey , <NEW_LINE> & newEntry -> location , true , & exception ) ;
btif_hh_cb . device_num ++ ; <NEW_LINE> <START_VULN> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <NEW_LINE> <END_VULN> if ( p_dev -> fd < 0 ) { <NEW_LINE> APPL_TRACE_ERROR ( " % s: Error: failed to open uhid , err: % s" , <NEW_LINE> __FUNCTION__ , strerror ( errno ) ) ;
<START_VULN> #ifndef BASE_SAFE_MATH_H_ <NEW_LINE>#define BASE_SAFE_MATH_H_ <NEW_LINE> <END_VULN> #include "base / numerics / safe_math_impl . h"
if ( isTableCell ( ) && ( h . isAuto ( ) || h . isPercent ( ) ) ) <NEW_LINE> return overrideHeight ( ) - borderAndPaddingLogicalWidth ( ) ; <NEW_LINE> <START_VULN> if ( h . isPercent ( ) ) <NEW_LINE>return computeContentBoxLogicalHeight ( h . calcValue ( containingBlock ( ) -> availableLogicalHeight ( ) ) ) ; <NEW_LINE> <END_VULN>
int ret = - 1 ; <NEW_LINE> while ( r ) <NEW_LINE> { <NEW_LINE> <START_VULN> do ret = recv ( sock_fd , buf , r , MSG_WAITALL ) ; <NEW_LINE> <END_VULN> while ( ret < 0 && errno == EINTR ) ; <NEW_LINE> if ( ret <= 0 ) <NEW_LINE> {
aIndexInContainer , & didReconstruct ) ; <NEW_LINE> VERIFY_STYLE_TREE ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> PresShell::ReconstructFrames ( void ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE> <END_VULN> mFrameConstructor -> BeginUpdate ( ) ; <NEW_LINE> nsresult rv = mFrameConstructor -> ReconstructDocElementHierarchy ( ) ; <NEW_LINE> VERIFY_STYLE_TREE ; <NEW_LINE> mFrameConstructor -> EndUpdate ( ) ; <NEW_LINE> return rv ; <NEW_LINE> }
if ( ! aFrame ) { <NEW_LINE> return nsnull ; <NEW_LINE> } <NEW_LINE> return nsHTMLReflowState::GetContainingBlockFor ( aFrame ) ; <NEW_LINE> } <NEW_LINE> nsComputedDOMStyle::nsComputedDOMStyle ( ) <NEW_LINE> : mInner ( this ) , mDocumentWeak ( nsnull ) , mOuterFrame ( nsnull ) , <NEW_LINE> <START_VULN> mInnerFrame ( nsnull ) , mPresShell ( nsnull ) , mAppUnitsPerInch ( 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> nsComputedDOMStyle:: ~ nsComputedDOMStyle ( ) <NEW_LINE> { <NEW_LINE> }
{ <NEW_LINE> LayoutUnit maxX = std::max ( rect . maxX ( ) , m_layoutOverflow . maxX ( ) ) ; <NEW_LINE> LayoutUnit maxY = std::max ( rect . maxY ( ) , m_layoutOverflow . maxY ( ) ) ; <NEW_LINE> <START_VULN> m_layoutOverflow . setX ( std::min ( rect . x ( ) , m_layoutOverflow . x ( ) ) ) ; <NEW_LINE>m_layoutOverflow . setY ( std::min ( rect . y ( ) , m_layoutOverflow . y ( ) ) ) ; <NEW_LINE>m_layoutOverflow . setWidth ( maxX - m_layoutOverflow . x ( ) ) ; <NEW_LINE>m_layoutOverflow . setHeight ( maxY - m_layoutOverflow . y ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> inline void RenderOverflow::addVisualOverflow ( const LayoutRect & rect )
) <NEW_LINE> { <NEW_LINE> <START_VULN> DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , FData2 , 24 * 24 ) ; <NEW_LINE> <END_VULN> const short * HFilter , * VFilter ;
} else { <NEW_LINE> PRBool isValid ; <NEW_LINE> nsBlockInFlowLineIterator iter ( this , aChild , & isValid ) ; <NEW_LINE> if ( isValid ) { <NEW_LINE> <START_VULN> MarkLineDirty ( iter . GetLine ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> nsBlockFrameSuper::ChildIsDirty ( aChild ) ; <NEW_LINE> }
public: <NEW_LINE> TraceWrapperMember ( void * parent , T * raw ) : Member < T > ( raw ) , m_parent ( parent ) { <NEW_LINE> #if DCHECK_IS_ON ( ) <NEW_LINE> <START_VULN> DCHECK ( ! m_parent || HeapObjectHeader::fromPayload ( m_parent ) -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> #endif
bool should_send_resource_timing_info_to_parent ( ) const { <NEW_LINE> return should_send_resource_timing_info_to_parent_ ; <NEW_LINE> } <NEW_LINE> <START_VULN> void DidSendResourceTimingInfoToParent ( ) { <NEW_LINE>should_send_resource_timing_info_to_parent_ = false ; <NEW_LINE> <END_VULN> }
static JSValueRef touchEndCallback ( JSContextRef context , JSObjectRef function , JSObjectRef thisObject , size_t argumentCount , const JSValueRef arguments [ ] , JSValueRef * exception ) <NEW_LINE> { <NEW_LINE> for ( unsigned i = 0 ; i < touches . size ( ) ; ++ i ) <NEW_LINE> <START_VULN> if ( touches [ i ] . m_state != BlackBerry::Platform::TouchPoint::TouchReleased ) { <NEW_LINE> <END_VULN> sendTouchEvent ( BlackBerry::Platform::TouchEvent::TouchMove ) ; <NEW_LINE> return JSValueMakeUndefined ( context ) ; <NEW_LINE> }
if ( mem_get_le32 ( buf ) < 256 * 1024 * 1024 ) { <NEW_LINE> for ( i = 0 ; i < get_vpx_decoder_count ( ) ; ++ i ) { <NEW_LINE> const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ; <NEW_LINE> <START_VULN> if ( ! vpx_codec_peek_stream_info ( decoder -> interface ( ) , <NEW_LINE> <END_VULN> buf + 4 , 32 - 4 , & si ) ) { <NEW_LINE> is_raw = 1 ; <NEW_LINE> input -> fourcc = decoder -> fourcc ;
if ( ! dev ) <NEW_LINE> return - ENOMEM ; <NEW_LINE> err = dev_get_valid_name ( net , dev , name ) ; <NEW_LINE> <START_VULN> if ( err ) <NEW_LINE> <END_VULN> goto err_free_dev ; <NEW_LINE> dev_net_set ( dev , net ) ;
UNALIGNED_MEMCPY ( & rxent -> client , & ip -> ip_src , sizeof ( uint32_t ) ) ; <NEW_LINE> UNALIGNED_MEMCPY ( & rxent -> server , & ip -> ip_dst , sizeof ( uint32_t ) ) ; <NEW_LINE> rxent -> dport = dport ; <NEW_LINE> <START_VULN> rxent -> serviceId = EXTRACT_32BITS ( & rxh -> serviceId ) ; <NEW_LINE> <END_VULN> rxent -> opcode = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; <NEW_LINE> }
inline <NEW_LINE> CompilerOutput::CompilerOutput ( ) <NEW_LINE> : script ( NULL ) , <NEW_LINE> <START_VULN> kindInt ( Ion ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> inline ion::IonScript * <NEW_LINE> CompilerOutput::ion ( ) const <NEW_LINE> { <NEW_LINE> #ifdef JS_ION <NEW_LINE> JS_ASSERT ( isValid ( ) ) ;
status = MagickTrue ; <NEW_LINE> maximum_length = 0 . 0 ; <NEW_LINE> total_length = 0 . 0 ; <NEW_LINE> <START_VULN> for ( i = 1 ; ( i < number_vertices ) && ( length >= 0 . 0 ) ; i ++ ) <NEW_LINE> <END_VULN> { <NEW_LINE> dx = primitive_info [ i ] . point . x - primitive_info [ i - 1 ] . point . x ; <NEW_LINE> dy = primitive_info [ i ] . point . y - primitive_info [ i - 1 ] . point . y ;
#ifndef VP9_ENCODER_VP9_COST_H_ <NEW_LINE> #define VP9_ENCODER_VP9_COST_H_ <NEW_LINE> <START_VULN> #include "vp9 / common / vp9_prob . h" <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> extern "C" {
<START_VULN> extern struct json_object * json_object_object_get ( struct json_object * obj , <NEW_LINE>const char * key ) ; <NEW_LINE> <END_VULN> *
op -> e_o_s = 0 ; <NEW_LINE> op -> granulepos = 0 ; <NEW_LINE> op -> packetno = 1 ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> int vorbis_analysis_headerout ( vorbis_dsp_state * v , <NEW_LINE> <START_VULN> vorbis_comment * vc , <NEW_LINE>ogg_packet * op , <NEW_LINE>ogg_packet * op_comm , <NEW_LINE>ogg_packet * op_code ) { <NEW_LINE> <END_VULN> int ret = OV_EIMPL ; <NEW_LINE> vorbis_info * vi = v -> vi ; <NEW_LINE> oggpack_buffer opb ; <NEW_LINE> private_state * b = v -> backend_state ; <NEW_LINE> if ( ! b ) { <NEW_LINE> ret = OV_EFAULT ; <NEW_LINE> goto err_out ;
{ <NEW_LINE> OwnPtr < GIFImageDecoder > decoder = createDecoder ( ) ; <NEW_LINE> <START_VULN> RefPtr < SharedBuffer > fullData = readFile ( " / LayoutTests / fast / images / resources / animated - 10color . gif" ) ; <NEW_LINE> <END_VULN> ASSERT_TRUE ( fullData . get ( ) ) ;
yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != ' { ' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 678 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> long elements = parse_iv ( start + 2 ) ;
virtual bool SetImeConfig ( const std::string & section , <NEW_LINE> const std::string & config_name , <NEW_LINE> <START_VULN> const ImeConfigValue & value ) = 0 ; <NEW_LINE> <END_VULN>
<START_VULN> #ifndef CONTENT_SHELL_BROWSER_SHELL_LAYOUT_TESTS_ANDROID_H_ <NEW_LINE>#define CONTENT_SHELL_BROWSER_SHELL_LAYOUT_TESTS_ANDROID_H_ <NEW_LINE> <END_VULN> #include < string >
#define PROGRESS_PREPARE_SIZE 20 . 0f <NEW_LINE> #define PROGRESS_EXECUTE_SIZE 75 . 0f <NEW_LINE> #define PROGRESS_FINISH_SIZE 5 . 0f <NEW_LINE> <START_VULN> #define PARENT_WAIT 5000 <NEW_LINE> <END_VULN> #if defined ( XP_MACOSX ) <NEW_LINE> void LaunchChild ( int argc , char ** argv ) ; <NEW_LINE> void LaunchMacPostProcess ( const char * aAppBundle ) ; <NEW_LINE> #endif <NEW_LINE> #ifndef _O_BINARY
vma = find_vma_prev ( mm , addr , & prev ) ; <NEW_LINE> if ( vma && ( vma -> vm_start <= addr ) ) <NEW_LINE> return vma ; <NEW_LINE> <START_VULN> if ( ! prev || expand_stack ( prev , addr ) ) <NEW_LINE> <END_VULN> return NULL ; <NEW_LINE> if ( prev -> vm_flags & VM_LOCKED ) <NEW_LINE> populate_vma_page_range ( prev , addr , prev -> vm_end , NULL ) ;
<START_VULN> Copyright ( c ) 2010 - 2015 , Linux Foundation . All rights reserved . <NEW_LINE> <END_VULN> Redistribution and use in source and binary forms , with or without <NEW_LINE> modification , are permitted provided that the following conditions are met:
if ( NS_SUCCEEDED ( rv ) ) <NEW_LINE> ScrollSelectionIntoView ( false ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsPlaintextEditor::Paste ( int32_t aSelectionType ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! FireClipboardEvent ( NS_PASTE ) ) <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> nsresult rv ; <NEW_LINE> nsCOMPtr < nsIClipboard > clipboard ( do_GetService ( "@mozilla . org / widget / clipboard ; 1" , & rv ) ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) <NEW_LINE> return rv ;
<START_VULN> #ifndef BASE_SIMPLE_TEST_CLOCK_H_ <NEW_LINE>#define BASE_SIMPLE_TEST_CLOCK_H_ <NEW_LINE> <END_VULN> #include "base / compiler_specific . h" <NEW_LINE> #include "base / synchronization / lock . h"
#elif ULONG_MAX > 4294967294 <NEW_LINE> typedef unsigned long int png_uint_32 ; <NEW_LINE> #else <NEW_LINE> <START_VULN> # error "libpng requires an unsigned 32 bit ( or more ) type" <NEW_LINE> <END_VULN> #endif
enum its_tinyid { <NEW_LINE> ITS_COLOR , ITS_HEIGHT , ITS_WIDTH , ITS_FUNNY , ITS_ARRAY , ITS_RDONLY , <NEW_LINE> <START_VULN> ITS_CUSTOM , ITS_CUSTOMRDONLY , ITS_CUSTOMNATIVE <NEW_LINE> <END_VULN> } ; <NEW_LINE> static JSBool
mTree -> InvalidateCell ( mCurrentIndex , mCurrentColumn ) ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> #define ADD_NEW_RANGE ( macro_range , macro_selection , macro_start , macro_end ) \ <NEW_LINE> { \ <NEW_LINE> <START_VULN> nsTreeRange * macro_new_range = new nsTreeRange ( macro_selection , ( macro_start ) , ( macro_end ) ) ; \ <NEW_LINE> <END_VULN> if ( macro_range ) \ <NEW_LINE> macro_range -> Insert ( macro_new_range ) ; \ <NEW_LINE> else \ <NEW_LINE> macro_range = macro_new_range ; \ <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeSelection::AdjustSelection ( PRInt32 aIndex , PRInt32 aCount )
if ( * p == LLC_UI ) { <NEW_LINE> if ( ndo -> ndo_eflag ) <NEW_LINE> ND_PRINT ( ( ndo , "CNLPID " ) ) ; <NEW_LINE> <START_VULN> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <NEW_LINE> <END_VULN> return hdrlen ; <NEW_LINE> }
} <NEW_LINE> bool AXObject::isHiddenForTextAlternativeCalculation ( ) const { <NEW_LINE> <START_VULN> if ( equalIgnoringCase ( getAttribute ( aria_hiddenAttr ) , "false" ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> if ( getLayoutObject ( ) )
nsCOMPtr < nsIVariant > stateObj ; <NEW_LINE> if ( ! mStateObjectCached && mStateObjectContainer ) { <NEW_LINE> <START_VULN> JSContext * cx = nsContentUtils::GetContextFromDocument ( this ) ; <NEW_LINE> <END_VULN> mStateObjectContainer -> <NEW_LINE> DeserializeToVariant ( cx , getter_AddRefs ( mStateObjectCached ) ) ; <NEW_LINE> } <NEW_LINE> NS_IF_ADDREF ( * aState = mStateObjectCached ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
} <NEW_LINE> #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED <NEW_LINE> <START_VULN> { <NEW_LINE>int i ; <NEW_LINE><NEW_LINE>for ( i = 0 ; i < 256 ; i ++ ) <NEW_LINE>filters_used [ i ] = 0 ; <NEW_LINE><NEW_LINE>png_set_read_user_transform_fn ( read_ptr , count_filters ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED <NEW_LINE> zero_samples = 0 ;
ShouldHaveFirstLineStyle ( containingBlock -> GetContent ( ) , <NEW_LINE> containingBlock -> GetStyleContext ( ) ) ; <NEW_LINE> } <NEW_LINE> if ( haveFirstLetterStyle ) { <NEW_LINE> if ( parentFrame -> GetType ( ) == nsGkAtoms::letterFrame ) { <NEW_LINE> <START_VULN> parentFrame = parentFrame -> GetParent ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> RemoveLetterFrames ( state . mPresContext , mPresShell , <NEW_LINE> state . mFrameManager , <NEW_LINE> state . mFloatedItems . containingBlock ) ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> if ( context && <NEW_LINE> <END_VULN> php_stream_context_get_option ( context , "http" , "user_agent" , & ua_zval ) == SUCCESS && <NEW_LINE> Z_TYPE_PP ( ua_zval ) == IS_STRING ) { <NEW_LINE> ua_str = Z_STRVAL_PP ( ua_zval ) ;
this_mv . as_mv . col = bc + hex [ i ] . col ; <NEW_LINE> CHECK_POINT <NEW_LINE> this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <NEW_LINE> <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <NEW_LINE> <END_VULN> CHECK_BETTER <NEW_LINE> } <NEW_LINE> }
const long long idpos = pos ; <NEW_LINE> <START_VULN> const long long id = ReadUInt ( m_pReader , idpos , len ) ; <NEW_LINE> <END_VULN> if ( id != 0x0C53BB6B ) <NEW_LINE> return E_FILE_FORMAT_INVALID ;
return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1267 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy95: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' , ' ) {
if ( blob -> hasBeenClosed ( ) ) <NEW_LINE> return handleError ( DataCloneError , "A Blob object has been closed , and could therefore not be cloned . " , next ) ; <NEW_LINE> int blobIndex = - 1 ; <NEW_LINE> <START_VULN> m_blobDataHandles . add ( blob -> uuid ( ) , blob -> blobDataHandle ( ) ) ; <NEW_LINE> <END_VULN> if ( appendBlobInfo ( blob -> uuid ( ) , blob -> type ( ) , blob -> size ( ) , & blobIndex ) ) <NEW_LINE> m_writer . writeBlobIndex ( blobIndex ) ; <NEW_LINE> else
int show_existing_frame ; <NEW_LINE> <START_VULN> int intra_only ; <NEW_LINE> <END_VULN> int allow_high_precision_mv ;
nsIWidget * parent = GetParent ( ) ; <NEW_LINE> if ( parent ) { <NEW_LINE> parent -> RemoveChild ( this ) ; <NEW_LINE> } <NEW_LINE> if ( mWnd ) { <NEW_LINE> <START_VULN> ::SetParent ( mWnd , nsnull ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return NS_OK ; <NEW_LINE> }
void TextTrack::addCue ( TextTrackCue * cue ) { <NEW_LINE> DCHECK ( cue ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( std::isnan ( cue -> startTime ( ) ) || std::isnan ( cue -> endTime ( ) ) || <NEW_LINE>cue -> startTime ( ) < 0 || cue -> endTime ( ) < 0 ) <NEW_LINE> <END_VULN> return ;
virtual void OnIncomingNotification ( <NEW_LINE> const notifier::Notification & notification ) OVERRIDE ; <NEW_LINE> <START_VULN> private: <NEW_LINE>friend class ChromeInvalidationClientTest ; <NEW_LINE> <END_VULN> void Stop ( ) ; <NEW_LINE> NotificationsDisabledReason GetState ( ) const ;
if ( ( jformat = ippFindAttribute ( job -> attrs , "document - format" , <NEW_LINE> IPP_TAG_MIMETYPE ) ) != NULL ) <NEW_LINE> <START_VULN> { <NEW_LINE>_cupsStrFree ( jformat -> values [ 0 ] . string . text ) ; <NEW_LINE><NEW_LINE>jformat -> values [ 0 ] . string . text = _cupsStrAlloc ( mimetype ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> else <NEW_LINE> ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_MIMETYPE , <NEW_LINE> "document - format" , NULL , mimetype ) ;
method = ReadTileMethod ; <NEW_LINE> quantum_info -> endian = LSBEndian ; <NEW_LINE> quantum_type = RGBQuantum ; <NEW_LINE> <START_VULN> tiff_pixels = ( unsigned char * ) AcquireMagickMemory ( TIFFScanlineSize ( tiff ) + <NEW_LINE>sizeof ( uint32 ) ) ; <NEW_LINE> <END_VULN> if ( tiff_pixels == ( unsigned char * ) NULL ) <NEW_LINE> { <NEW_LINE> TIFFClose ( tiff ) ;
NS_PRECONDITION ( value , "bad param" ) ; <NEW_LINE> NS_PRECONDITION ( _retval , "bad param" ) ; <NEW_LINE> XPCCallContext ccx ( NATIVE_CALLER , ctx ) ; <NEW_LINE> if ( ! ccx . IsValid ( ) ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> XPCLazyCallContext lccx ( ccx ) ; <NEW_LINE> <START_VULN> ccx . SetScopeForNewJSObjects ( scope ) ; <NEW_LINE> <END_VULN> nsresult rv = NS_OK ; <NEW_LINE> if ( ! XPCVariant::VariantDataToJS ( lccx , value , & rv , _retval ) ) { <NEW_LINE> if ( NS_FAILED ( rv ) ) <NEW_LINE> return rv ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> }
pixel . black = ( ( aggregate . black + total_weight / 2 . 0 ) / total_weight ) ; <NEW_LINE> pixel . alpha = ( ( aggregate . alpha + total_weight / 2 . 0 ) / total_weight ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> SetPixelViaPixelInfo ( image , & pixel , q ) ; <NEW_LINE> <END_VULN> p += GetPixelChannels ( image ) ; <NEW_LINE> q += GetPixelChannels ( enhance_image ) ; <NEW_LINE> }
if ( task_cpu ( p ) != new_cpu ) { <NEW_LINE> p -> se . nr_migrations ++ ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_CPU_MIGRATIONS , 1 , 1 , NULL , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> __set_task_cpu ( p , new_cpu ) ;
INC_STATS ( "DOM . WebGLRenderingContext . getShaderParameter ( ) " ) ; <NEW_LINE> if ( args . Length ( ) != 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> WebGLRenderingContext * context = V8WebGLRenderingContext::toNative ( args . Holder ( ) ) ;
if ( doInterrupt ) { <NEW_LINE> UNLOCK_TX_MANAGER ( this ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> result = tx -> RedoTransaction ( this ) ; <NEW_LINE> if ( NS_SUCCEEDED ( result ) ) { <NEW_LINE> <START_VULN> result = mRedoStack . Pop ( & tx ) ; <NEW_LINE> <END_VULN> if ( NS_SUCCEEDED ( result ) ) <NEW_LINE> result = mUndoStack . Push ( tx ) ; <NEW_LINE> } <NEW_LINE> nsresult result2 = DidRedoNotify ( t , result ) ; <NEW_LINE> if ( NS_SUCCEEDED ( result ) )
float * floatptr ; <NEW_LINE> double * doubleptr ; <NEW_LINE> char c ; <NEW_LINE> <START_VULN> int byte_count = 0 , count ; <NEW_LINE> <END_VULN> if ( ! format ) <NEW_LINE> return psf_ftell ( psf ) ;
#if ! defined ( LIBEXSLT_STATIC ) <NEW_LINE> #define EXSLTPUBVAR __declspec ( dllimport ) extern <NEW_LINE> #else <NEW_LINE> <START_VULN> #define EXSLTPUBVAR <NEW_LINE> <END_VULN> #endif <NEW_LINE> #endif <NEW_LINE> #define EXSLTCALL __cdecl
buffer [ nbchars ++ ] = ' & ' ; <NEW_LINE> if ( nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE ) { <NEW_LINE> <START_VULN> growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> for ( ; i > 0 ; i -- ) <NEW_LINE> buffer [ nbchars ++ ] = * cur ++ ;
#include "vpx / vpx_codec . h" <NEW_LINE> <START_VULN> static const char * const cfg = " -- force - target = armv8 - linux - gcc -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
kMacDeckLinkUnsupportedPixelFormat = 112 , <NEW_LINE> kMacAvFoundationReceivedAVCaptureSessionRuntimeErrorNotification = 113 , <NEW_LINE> kAndroidApi2ErrorConfiguringCamera = 114 , <NEW_LINE> <START_VULN> kCrosHalV3DeviceDelegateFailedToFlush = 115 , <NEW_LINE>kMaxValue = 115 <NEW_LINE> <END_VULN> } ;
if ( IS_ERR ( ctrl -> regs ) ) <NEW_LINE> return PTR_ERR ( ctrl -> regs ) ; <NEW_LINE> <START_VULN> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <NEW_LINE> <END_VULN> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; <NEW_LINE> if ( ret ) <NEW_LINE> return ret ;
PRBool HasLoadFlag ( PRUint32 flag ) { <NEW_LINE> return ( mLoadFlags & flag ) != 0 ; <NEW_LINE> } <NEW_LINE> PRBool IsPending ( ) const { <NEW_LINE> <START_VULN> return ( mPump != nsnull ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void SetContentLength64 ( PRInt64 len ) ; <NEW_LINE> PRInt64 ContentLength64 ( ) ;
frame_size += delta_size ; <NEW_LINE> <START_VULN> if ( frame_size < 0 ) <NEW_LINE> <END_VULN> return E_FILE_FORMAT_INVALID ; <NEW_LINE> if ( frame_size > LONG_MAX )
if ( err < 0 ) <NEW_LINE> return err ; <NEW_LINE> } <NEW_LINE> <START_VULN> m -> msg_name = address ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> m -> msg_name = NULL ; <NEW_LINE> }
{ <NEW_LINE> if ( mUpdateCount == 1 ) { <NEW_LINE> RecalcQuotesAndCounters ( ) ; <NEW_LINE> NS_ASSERTION ( mUpdateCount == 1 , "Odd update count" ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> -- mUpdateCount ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsCSSFrameConstructor::RecalcQuotesAndCounters ( ) <NEW_LINE> { <NEW_LINE> if ( mQuotesDirty ) { <NEW_LINE> mQuotesDirty = PR_FALSE ; <NEW_LINE> mQuoteList . RecalcAll ( ) ;
} <NEW_LINE> const nsCString & ClassName ( ) const { <NEW_LINE> return mImplementation ? mImplementation -> mClassName : EmptyCString ( ) ; <NEW_LINE> } <NEW_LINE> nsresult InitClass ( const nsCString & aClassName , JSContext * aContext , <NEW_LINE> JSObject * aGlobal , JSObject * aScriptObject , <NEW_LINE> <START_VULN> JSObject ** aClassObject ) ; <NEW_LINE> <END_VULN> nsresult ConstructInterfaceTable ( const nsAString & aImpls ) ; <NEW_LINE> void SetImplementation ( nsXBLProtoImpl * aImpl ) { mImplementation = aImpl ; } <NEW_LINE> nsresult InstallImplementation ( nsXBLBinding * aBinding ) ; <NEW_LINE> bool HasImplementation ( ) const { return mImplementation != nullptr ; } <NEW_LINE> void AttributeChanged ( nsIAtom * aAttribute , int32_t aNameSpaceID ,
#if defined ( PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED ) || \ <NEW_LINE> defined ( PNG_USER_CHUNK_MALLOC_MAX ) <NEW_LINE> else <NEW_LINE> #endif <NEW_LINE> if ( expanded_size > 0 ) <NEW_LINE> { <NEW_LINE> png_size_t new_size = 0 ; <NEW_LINE> <START_VULN> png_charp text = png_malloc_warn ( png_ptr , <NEW_LINE>prefix_size + expanded_size + 1 ) ; <NEW_LINE> <END_VULN> if ( text != NULL ) <NEW_LINE> { <NEW_LINE> png_memcpy ( text , png_ptr -> chunkdata , prefix_size ) ; <NEW_LINE> new_size = png_inflate ( png_ptr , <NEW_LINE> ( png_bytep ) ( png_ptr -> chunkdata + prefix_size ) , <NEW_LINE> chunklength - prefix_size , <NEW_LINE> ( png_bytep ) ( text + prefix_size ) , expanded_size ) ;
getter_AddRefs ( wrapper ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> rv = aBinding -> InitClass ( mClassName , jscontext , global , JSVAL_TO_OBJECT ( v ) , <NEW_LINE> <START_VULN> aTargetClassObject ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) { <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> nsContentUtils::PreserveWrapper ( aBoundElement , aBoundElement ) ; <NEW_LINE> wrapper . swap ( * aScriptObjectHolder ) ;
switch ( cmdCode ) { <NEW_LINE> case EFFECT_CMD_INIT: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> } <NEW_LINE> * ( int * ) pReplyData = Downmix_Init ( pDwmModule ) ;
} <NEW_LINE> escaped = malloc ( 4 * strlen ( inp ) + 1 ) ; <NEW_LINE> if ( ! escaped ) { <NEW_LINE> <START_VULN> perror ( "malloc" ) ; <NEW_LINE>return NULL ; <NEW_LINE> <END_VULN> } <NEW_LINE> for ( d = escaped , s = ( const unsigned char * ) inp ; * s ; s ++ ) { <NEW_LINE> if ( needs_escape ( * s ) ) {
<START_VULN> if ( endptr <= buf + 12 ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_chunk_benign_error ( png_ptr , "invalid" ) ; <NEW_LINE> return ;
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE>#endif <NEW_LINE> <END_VULN>
if ( ( aFlags & DECODE_FLAGS_MASK ) != DECODE_FLAGS_DEFAULT ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> NS_ENSURE_ARG_POINTER ( aContext ) ; <NEW_LINE> if ( mFrameDecodeFlags != DECODE_FLAGS_DEFAULT ) { <NEW_LINE> <START_VULN> if ( ! CanForciblyDiscard ( ) ) <NEW_LINE> <END_VULN> return NS_ERROR_NOT_AVAILABLE ; <NEW_LINE> ForceDiscard ( ) ; <NEW_LINE> mFrameDecodeFlags = DECODE_FLAGS_DEFAULT ; <NEW_LINE> }
if ( ! aBuffer ) <NEW_LINE> return NPERR_INVALID_PARAM ; <NEW_LINE> nsCString url = NullableString ( aRelativeURL ) ; <NEW_LINE> StreamNotifyChild * sn = new StreamNotifyChild ( url ) ; <NEW_LINE> NPError err ; <NEW_LINE> <START_VULN> InstCast ( aNPP ) -> CallPStreamNotifyConstructor ( <NEW_LINE>sn , url , NullableString ( aTarget ) , true , <NEW_LINE>nsCString ( aBuffer , aLength ) , aIsFile , & err ) ; <NEW_LINE> <END_VULN> if ( NPERR_NO_ERROR == err ) { <NEW_LINE> sn -> SetValid ( aNotifyData ) ; <NEW_LINE> } <NEW_LINE> return err ;
static int jas_iccgetuint16 ( jas_stream_t * in , jas_iccuint16_t * val ) <NEW_LINE> { <NEW_LINE> <START_VULN> ulonglong tmp ; <NEW_LINE> <END_VULN> if ( jas_iccgetuint ( in , 2 , & tmp ) ) <NEW_LINE> return - 1 ; <NEW_LINE> * val = tmp ;
case RSVP_OBJ_FASTREROUTE: <NEW_LINE> obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; <NEW_LINE> <START_VULN> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; <NEW_LINE> <END_VULN> switch ( rsvp_obj_ctype ) { <NEW_LINE> case RSVP_CTYPE_1: <NEW_LINE> if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) <NEW_LINE> return - 1 ; <NEW_LINE> ND_PRINT ( ( ndo , " % s Setup Priority: % u , Holding Priority: % u , Hop - limit: % u , Bandwidth: % . 10g Mbps" , <NEW_LINE> ident , <NEW_LINE> ( int ) obj_ptr . rsvp_obj_frr -> setup_prio ,
else <NEW_LINE> then_len = 0 ; <NEW_LINE> <START_VULN> jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ; <NEW_LINE>if ( IS_NOT_NULL ( Else ) ) jump_len += SIZE_OP_JUMP ; <NEW_LINE> <END_VULN> r = add_op ( reg , OP_PUSH ) ; <NEW_LINE> if ( r != 0 ) return r ;
#include "CSSValueKeywords . h" <NEW_LINE> #include "core / platform / graphics / FontDescription . h" <NEW_LINE> <START_VULN> #include "core / platform / win / HWndDC . h" <NEW_LINE>#include "core / platform / win / SystemInfo . h" <NEW_LINE> <END_VULN> #include "wtf / text / WTFString . h" <NEW_LINE> #define SIZEOF_STRUCT_WITH_SPECIFIED_LAST_MEMBER ( structName , member ) \
} <NEW_LINE> const uint64 edition_size = <NEW_LINE> <START_VULN> EbmlMasterElementSize ( kMkvEditionEntry , payload_size ) + <NEW_LINE>payload_size ; <NEW_LINE> <END_VULN> if ( writer == NULL ) <NEW_LINE> return edition_size ;
static std::vector < InputHandler * > ForAgentHost ( DevToolsAgentHostImpl * host ) ; <NEW_LINE> void Wire ( UberDispatcher * dispatcher ) override ; <NEW_LINE> <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) override ; <NEW_LINE> void OnSwapCompositorFrame (
to = child -> value ; <NEW_LINE> status = "302" ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> from = mprGetJson ( child , "from" ) ; <NEW_LINE>to = mprGetJson ( child , "to" ) ; <NEW_LINE>status = mprGetJson ( child , "status" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( smatch ( child -> value , "secure" ) ) { <NEW_LINE> httpAddRouteCondition ( route , "secure" , "https:
float tempo_f = 0 . 0 ; <NEW_LINE> uint16_t mus_freq = 0 ; <NEW_LINE> float samples_per_tick_f = 0 . 0 ; <NEW_LINE> <START_VULN> uint8_t mus_event [ ] = { 0 , 0 , 0 , 0 } ; <NEW_LINE> <END_VULN> uint8_t mus_event_size = 0 ; <NEW_LINE> uint8_t mus_prev_vol [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; <NEW_LINE> uint32_t setup_ret = 0 ;
JS_ASSERT ( js::GetObjectClass ( obj ) -> ext . innerObject ) ; <NEW_LINE> } <NEW_LINE> obj = JS_ObjectToInnerObject ( cx , obj ) ; <NEW_LINE> return obj && <NEW_LINE> <START_VULN> ( isSameOrigin ( js::GetObjectCompartment ( wrapper ) , <NEW_LINE>js::GetObjectCompartment ( obj ) ) || <NEW_LINE> <END_VULN> documentDomainMakesSameOrigin ( cx , obj ) ) ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> AccessCheck::isChrome ( JSCompartment * compartment ) <NEW_LINE> { <NEW_LINE> nsIScriptSecurityManager * ssm = XPCWrapper::GetSecurityManager ( ) ; <NEW_LINE> if ( ! ssm ) {
<START_VULN> static void <NEW_LINE> <END_VULN> ip_printroute ( netdissect_options * ndo , <NEW_LINE> register const u_char * cp , u_int length ) <NEW_LINE> {
int gpu_host_id ) OVERRIDE ; <NEW_LINE> virtual void AcceleratedSurfaceSuspend ( ) OVERRIDE ; <NEW_LINE> virtual bool HasAcceleratedSurface ( const gfx::Size & desired_size ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void AcceleratedSurfaceNew ( <NEW_LINE>int32 width_in_pixel , <NEW_LINE>int32 height_in_pixel , <NEW_LINE>uint64 surface_id ) OVERRIDE ; <NEW_LINE>virtual void AcceleratedSurfaceRelease ( uint64 surface_id ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual void GetScreenInfo ( WebKit::WebScreenInfo * results ) OVERRIDE ; <NEW_LINE> virtual gfx::Rect GetBoundsInRootWindow ( ) OVERRIDE ; <NEW_LINE> virtual void ProcessAckedTouchEvent (
size_t * encryptedbytes ) { <NEW_LINE> <START_VULN> size_t cryptosize = sizeof ( AMediaCodecCryptoInfo ) + sizeof ( size_t ) * numsubsamples * 2 ; <NEW_LINE> <END_VULN> AMediaCodecCryptoInfo * ret = ( AMediaCodecCryptoInfo * ) malloc ( cryptosize ) ; <NEW_LINE> if ( ! ret ) { <NEW_LINE> ALOGE ( "couldn't allocate % zu bytes" , cryptosize ) ;
{ <NEW_LINE> if ( row_info -> bit_depth == 8 ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( at_start ) <NEW_LINE> <END_VULN> ++ sp ; <NEW_LINE> else <NEW_LINE> sp += 2 , ++ dp ;
for ( i = 0 ; i < 16 ; i ++ ) <NEW_LINE> xd -> mode_info_context -> bmi [ i ] . mv . as_int = best_mode . bmodes [ i ] . mv . as_int ; <NEW_LINE> <START_VULN> vpx_memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ; <NEW_LINE> <END_VULN> x -> e_mbd . mode_info_context -> mbmi . mv . as_int = <NEW_LINE> x -> partition_info -> bmi [ 15 ] . mv . as_int ;
<START_VULN> snprintf ( buf , sizeof ( buf ) , filename , dec_ctx -> frame_number ) ; <NEW_LINE> <END_VULN> pgm_save ( frame -> data [ 0 ] , frame -> linesize [ 0 ] , <NEW_LINE> frame -> width , frame -> height , buf ) ; <NEW_LINE> }
return true ; <NEW_LINE> } <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> int <NEW_LINE> nsPresContext::PrefChangedCallback ( const char * aPrefName , void * instance_data ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsPresContext * presContext = ( nsPresContext * ) instance_data ; <NEW_LINE> <END_VULN> NS_ASSERTION ( nullptr != presContext , "bad instance data" ) ; <NEW_LINE> if ( nullptr != presContext ) { <NEW_LINE> presContext -> PreferenceChanged ( aPrefName ) ; <NEW_LINE> } <NEW_LINE> return 0 ; <NEW_LINE> }
if ( binaries [ i ] == NULL ) <NEW_LINE> { <NEW_LINE> hb_log ( "OpenCL: hb_generat_bin_from_kernel_source: malloc for binaries [ % d ] failed" , i ) ; <NEW_LINE> <START_VULN> return 0 ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> else
else <NEW_LINE> * ( dp ++ ) = red ; <NEW_LINE> <START_VULN> if ( have_alpha ) <NEW_LINE> <END_VULN> * ( dp ++ ) = * ( sp ++ ) ; <NEW_LINE> } <NEW_LINE> }
{ <NEW_LINE> png_debug ( 1 , "in png_do_write_intrapixel" ) ; <NEW_LINE> <START_VULN> if ( ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> int bytes_per_pixel ; <NEW_LINE> png_uint_32 row_width = row_info -> width ;
if ( m_pCues == NULL ) { <NEW_LINE> const long long element_size = ( pos - idpos ) + size ; <NEW_LINE> <START_VULN> m_pCues = new Cues ( this , pos , size , idpos , element_size ) ; <NEW_LINE>assert ( m_pCues ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> m_pos = pos + size ;
clearObjects ( ) ; <NEW_LINE> objectCount = 0 ; <NEW_LINE> for ( unsigned i = 0 ; i < oldCapacity ; i ++ ) { <NEW_LINE> TypeObjectKey * object = oldArray [ i ] ; <NEW_LINE> if ( object && ! IsAboutToBeFinalized ( object ) ) { <NEW_LINE> TypeObjectKey ** pentry = <NEW_LINE> HashSetInsert < TypeObjectKey * , TypeObjectKey , TypeObjectKey > <NEW_LINE> ( zone -> types . typeLifoAlloc , objectSet , objectCount , object ) ; <NEW_LINE> <START_VULN> if ( pentry ) <NEW_LINE> * pentry = object ; <NEW_LINE>else <NEW_LINE>zone -> types . setPendingNukeTypes ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> setBaseObjectCount ( objectCount ) ; <NEW_LINE> } else if ( objectCount == 1 ) { <NEW_LINE> TypeObjectKey * object = ( TypeObjectKey * ) objectSet ; <NEW_LINE> if ( IsAboutToBeFinalized ( object ) ) { <NEW_LINE> objectSet = nullptr ; <NEW_LINE> setBaseObjectCount ( 0 ) ;
static void <NEW_LINE> <START_VULN> standard_test ( png_store * PNG_CONST psIn , png_uint_32 PNG_CONST id , <NEW_LINE> <END_VULN> int do_interlace , int use_update_info ) <NEW_LINE> { <NEW_LINE> standard_display d ;
IntSize m_scrollAmount ; <NEW_LINE> int m_scrolls ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> TEST_F ( CCLayerTreeHostTestScrollSimple , run ) <NEW_LINE> <END_VULN> { <NEW_LINE> runTest ( ) ; <NEW_LINE> }
ND_PRINT ( ( ndo , " status = % u" , mh -> ip6m_data8 [ 0 ] ) ) ; <NEW_LINE> hlen = IP6M_MINLEN ; <NEW_LINE> <START_VULN> ND_TCHECK2 ( * mh , hlen + 16 ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , " homeaddr % s" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; <NEW_LINE> hlen += 16 ; <NEW_LINE> break ;
"Begin cell for known stream . Dropping . " ) ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { <NEW_LINE> <END_VULN>
{ <NEW_LINE> <START_VULN> _cupsStrFree ( username -> values [ 0 ] . string . text ) ; <NEW_LINE>username -> values [ 0 ] . string . text = _cupsStrAlloc ( RemoteRoot ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
bool InspectorOverlay::isEmpty ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> bool hasAlwaysVisibleElements = m_highlightNode || m_eventTargetNode || m_highlightQuad || m_overrides || ! m_size . isEmpty ( ) || m_drawViewSize ; <NEW_LINE> <END_VULN> bool hasInvisibleInInspectModeElements = ! m_pausedInDebuggerMessage . isNull ( ) ; <NEW_LINE> return ! ( hasAlwaysVisibleElements || ( hasInvisibleInInspectModeElements && ! m_inspectModeEnabled ) ) ; <NEW_LINE> }
void * <NEW_LINE> BumpChunk::tryAllocUnaligned ( size_t n ) <NEW_LINE> { <NEW_LINE> char * oldBump = bump ; <NEW_LINE> char * newBump = bump + n ; <NEW_LINE> if ( newBump > limit ) <NEW_LINE> return NULL ; <NEW_LINE> <START_VULN> JS_ASSERT ( canAllocUnaligned ( n ) ) ; <NEW_LINE> <END_VULN> setBump ( newBump ) ; <NEW_LINE> return oldBump ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void
hashtable_do_clear ( hashtable ) ; <NEW_LINE> <START_VULN> for ( i = 0 ; i < num_buckets ( hashtable ) ; i ++ ) <NEW_LINE> <END_VULN> { <NEW_LINE> hashtable -> buckets [ i ] . first = hashtable -> buckets [ i ] . last = <NEW_LINE> & hashtable -> list ;
} <NEW_LINE> void MediaDecoderStateMachine::ScheduleStateMachineWithLockAndWakeDecoder ( ) { <NEW_LINE> ReentrantMonitorAutoEnter mon ( mDecoder -> GetReentrantMonitor ( ) ) ; <NEW_LINE> mon . NotifyAll ( ) ; <NEW_LINE> <START_VULN> ScheduleStateMachine ( 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsresult MediaDecoderStateMachine::ScheduleStateMachine ( int64_t aUsecs ) { <NEW_LINE> mDecoder -> GetReentrantMonitor ( ) . AssertCurrentThreadIn ( ) ; <NEW_LINE> NS_ABORT_IF_FALSE ( GetStateMachineThread ( ) , <NEW_LINE> "Must have a state machine thread to schedule" ) ; <NEW_LINE> if ( mState == DECODER_STATE_SHUTDOWN ) {
class FakePlatformSensor : public PlatformSensor { <NEW_LINE> public: <NEW_LINE> FakePlatformSensor ( mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> PlatformSensorProvider * provider ) ;
return ( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> ret = x509parse_crt ( ssl -> session_negotiate -> peer_cert , ssl -> in_msg + i , <NEW_LINE>n ) ; <NEW_LINE> <END_VULN> if ( ret != 0 ) <NEW_LINE> { <NEW_LINE> SSL_DEBUG_RET ( 1 , " x509parse_crt" , ret ) ;
temp = png_get_uint_32 ( profile + 20 ) ; <NEW_LINE> switch ( temp ) <NEW_LINE> { <NEW_LINE> <START_VULN> case 0x58595A20: <NEW_LINE>case 0x4C616220: <NEW_LINE> <END_VULN> break ; <NEW_LINE> default:
} <NEW_LINE> } <NEW_LINE> NS_IMPL_ISUPPORTS1 ( WindowStateHolder , WindowStateHolder ) <NEW_LINE> nsresult <NEW_LINE> nsGlobalWindow::CreateOuterObject ( nsGlobalWindow * aNewInner ) <NEW_LINE> { <NEW_LINE> <START_VULN> JSContext * cx = mContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSObject * outer = NewOuterWindowProxy ( cx , aNewInner -> FastGetGlobalJSObject ( ) , <NEW_LINE> IsChromeWindow ( ) ) ; <NEW_LINE> if ( ! outer ) { <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> js::SetProxyExtra ( outer , 0 , js::PrivateValue ( ToSupports ( this ) ) ) ;
efree ( variant ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> }
"png_start_read_image / png_read_update_info: duplicate call" ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_SEQUENTIAL_READ_SUPPORTED <NEW_LINE> #ifdef PNG_MNG_FEATURES_SUPPORTED
} else { <NEW_LINE> snprintf ( lbuf , llen , " % s [ name ] " , param ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( s && s > filename ) { <NEW_LINE> <END_VULN> register_http_post_files_variable ( lbuf , s + 1 , http_post_files , 0 TSRMLS_CC ) ; <NEW_LINE> } else { <NEW_LINE> register_http_post_files_variable ( lbuf , filename , http_post_files , 0 TSRMLS_CC ) ;
<START_VULN> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) <NEW_LINE> <END_VULN> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> if ( image -> colors != 0 ) <NEW_LINE> {
layoutCaption ( m_captions [ i ] ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( isPositioned ( ) ) <NEW_LINE> <END_VULN> computeLogicalHeight ( ) ;
<START_VULN> #ifndef CHROME_BROWSER_CHROMEOS_AUDIO_MIXER_ALSA_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_AUDIO_MIXER_ALSA_H_ <NEW_LINE> <END_VULN> #pragma once <NEW_LINE> #include < string >
uint32_t GetListBaseExpandoSlot ( ) ; <NEW_LINE> extern JS_FRIEND_API ( bool ) <NEW_LINE> IsReadOnlyDateMethod ( JS::IsAcceptableThis test , JS::NativeImpl method ) ; <NEW_LINE> extern JS_FRIEND_API ( bool ) <NEW_LINE> IsTypedArrayThisCheck ( JS::IsAcceptableThis test ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE>extern JSBool <NEW_LINE>DefaultValue ( JSContext * cx , HandleObject obj , JSType hint , MutableHandleValue vp ) ; <NEW_LINE><NEW_LINE> <END_VULN> extern Class ArrayClass ; <NEW_LINE> extern Class ArrayBufferClass ; <NEW_LINE> extern Class BlockClass ; <NEW_LINE> extern Class BooleanClass ; <NEW_LINE> extern Class CallableObjectClass ; <NEW_LINE> extern Class DataViewClass ; <NEW_LINE> extern Class DateClass ; <NEW_LINE> extern Class ErrorClass ;
if ( ! mode_excluded ) { <NEW_LINE> int max_plane = MAX_MB_PLANE ; <NEW_LINE> <START_VULN> best_mode_index = mode_index ; <NEW_LINE> <END_VULN> if ( ref_frame == INTRA_FRAME ) {
NS_ConvertUTF16toUTF8 cname ( mName ) ; <NEW_LINE> nsAutoCString functionUri ( aClassStr ) ; <NEW_LINE> int32_t hash = functionUri . RFindChar ( '#' ) ; <NEW_LINE> if ( hash != kNotFound ) { <NEW_LINE> functionUri . Truncate ( hash ) ; <NEW_LINE> } <NEW_LINE> JSObject * methodObject = nullptr ; <NEW_LINE> <START_VULN> JSContext * cx = aContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , aClassObject ) ; <NEW_LINE> JS::CompileOptions options ( cx ) ; <NEW_LINE> options . setFileAndLine ( functionUri . get ( ) , <NEW_LINE> uncompiledMethod -> mBodyText . GetLineNumber ( ) ) <NEW_LINE> . setVersion ( JSVERSION_LATEST ) <NEW_LINE> . setUserBit ( true ) ; <NEW_LINE> js::RootedObject rootedNull ( cx , nullptr ) ;
PNG_EXPORT ( 235 , int , png_image_begin_read_from_stdio , ( png_imagep image , <NEW_LINE> FILE * file ) ) ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> PNG_EXPORT ( 236 , int , png_image_begin_read_from_memory , ( png_imagep image , <NEW_LINE> png_const_voidp memory , png_size_t size ) ) ;
IPC::Message * reply_msg ) ; <NEW_LINE> <START_VULN> void OnCheckForCancel ( const std::string & preview_ui_addr , <NEW_LINE> <END_VULN> int preview_request_id , <NEW_LINE> bool * cancel ) ;
int ignored ; <NEW_LINE> dynbuf = NULL ; <NEW_LINE> <START_VULN> _dopr ( & hugebufp , & dynbuf , & hugebufsize , & retlen , & ignored , format , args ) ; <NEW_LINE> <END_VULN> if ( dynbuf ) { <NEW_LINE> ret = BIO_write ( bio , dynbuf , ( int ) retlen ) ; <NEW_LINE> OPENSSL_free ( dynbuf ) ;
for ( j = 0 ; j < 3 ; j ++ ) { <NEW_LINE> if ( zend_hash_index_find ( Z_ARRVAL_PP ( var ) , ( j ) , ( void ** ) & var2 ) == SUCCESS ) { <NEW_LINE> <START_VULN> SEPARATE_ZVAL ( var2 ) ; <NEW_LINE>convert_to_double ( * var2 ) ; <NEW_LINE>matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You must have a 3x3 matrix" ) ; <NEW_LINE> RETURN_FALSE ;
# define mp_uintmax_t unsigned long <NEW_LINE> #endif <NEW_LINE> <START_VULN> #define BUFFSIZE 256 <NEW_LINE> <END_VULN> #define MAX_PARAMETERS 128 <NEW_LINE> #ifdef __AMIGA__
if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && <NEW_LINE> rxent -> client . s_addr == clip && <NEW_LINE> rxent -> server . s_addr == sip && <NEW_LINE> <START_VULN> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <NEW_LINE> <END_VULN> rxent -> dport == sport ) {
memmove ( vp + 1 , vp + 2 , argc * sizeof ( jsval ) ) ; <NEW_LINE> if ( ! js_ComputeThis ( cx , JS_FALSE , vp + 2 ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( argc != 0 ) { <NEW_LINE><NEW_LINE>vp [ 2 + -- argc ] = JSVAL_VOID ; <NEW_LINE> } <NEW_LINE> <END_VULN> native = <NEW_LINE> #ifdef JS_TRACER <NEW_LINE> ( fs -> flags & JSFUN_TRCINFO ) <NEW_LINE> ? JS_FUNC_TO_DATA_PTR ( JSNativeTraceInfo * , fs -> call ) -> native <NEW_LINE> : <NEW_LINE> #endif <NEW_LINE> ( JSFastNative ) fs -> call ; <NEW_LINE> return native ( cx , argc , vp ) ;
ZVAL_STRINGL ( rval , str , len ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 989 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy53: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' / ' ) {
void GetSettings ( bool ask_user_for_settings , <NEW_LINE> <START_VULN> gfx::NativeWindow parent_window , <NEW_LINE> <END_VULN> int document_page_count , <NEW_LINE> bool has_selection , <NEW_LINE> bool use_overlays ) ;
Error: <NEW_LINE> <START_VULN> cmsPipelineFree ( Lut ) ; <NEW_LINE> <END_VULN> if ( Result != NULL ) cmsPipelineFree ( Result ) ; <NEW_LINE> return NULL ;
const std::string & resource , <NEW_LINE> ContentSetting * setting , <NEW_LINE> bool * is_default ) const ; <NEW_LINE> <START_VULN> void GrantAccess ( const ChromeViewHostMsg_GetPluginInfo_Status & status , <NEW_LINE>const FilePath & path ) const ; <NEW_LINE> <END_VULN> private: <NEW_LINE> int render_process_id_ ;
return FAILURE ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( strcmp ( key_name , LOC_LANG_TAG ) != 0 && <NEW_LINE> <END_VULN> strcmp ( key_name , LOC_GRANDFATHERED_LANG_TAG ) != 0 ) { <NEW_LINE> smart_str_appendl ( loc_name , SEPARATOR , sizeof ( SEPARATOR ) - 1 ) ;
<START_VULN> #ifndef CHROME_BROWSER_UI_FIND_BAR_FIND_MANAGER_H_ <NEW_LINE>#define CHROME_BROWSER_UI_FIND_BAR_FIND_MANAGER_H_ <NEW_LINE> <END_VULN> #pragma once <NEW_LINE> #include "chrome / browser / tab_contents / tab_contents_observer . h"
transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( strpbrk ( mode , "awx + " ) ) { <NEW_LINE> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP wrapper does not support writeable connections" ) ; <NEW_LINE> php_url_free ( resource ) ;
} while ( init_l ) ; <NEW_LINE> <START_VULN> qrio_set_gpio ( GPIO_A , FPGA_PROG_L , 1 ) ; <NEW_LINE> <END_VULN> return ret ; <NEW_LINE> }
<START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>std::string GetKeyboardOverlayId ( const std::string & input_method_name ) ; <NEW_LINE> <END_VULN>
slice_header_t * ps_slice_hdr_prev = ps_codec -> s_parse . ps_slice_hdr_base ; <NEW_LINE> ihevcd_copy_slice_hdr ( ps_codec , 0 , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; <NEW_LINE> <START_VULN> ps_codec -> i4_slice_error = 1 ; <NEW_LINE> <END_VULN> ps_slice_hdr_prev -> i2_ctb_x = 0 ; <NEW_LINE> ps_slice_hdr_prev -> i2_ctb_y = 0 ;
chnMem . autoPortaDown = 0 ; <NEW_LINE> chnMem . autoTonePorta = 0 ; <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x04:
buf = ( char * ) mLineBuf . get ( ) ; <NEW_LINE> } <NEW_LINE> if ( mWaitEOF ) { <NEW_LINE> if ( * buf ) { <NEW_LINE> LOG ( ( "got trailer: % s\n" , buf ) ) ; <NEW_LINE> if ( ! mTrailers ) { <NEW_LINE> <START_VULN> mTrailers = new nsHttpHeaderArray <NEW_LINE> ( nsHttpHeaderArray::HTTP_RESPONSE_HEADERS ) ; <NEW_LINE>if ( ! mTrailers ) <NEW_LINE>return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> <END_VULN> } <NEW_LINE> mTrailers -> ParseHeaderLine ( buf ) ; <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> mWaitEOF = PR_FALSE ; <NEW_LINE> mReachedEOF = PR_TRUE ; <NEW_LINE> LOG ( ( "reached end of chunked - body\n" ) ) ; <NEW_LINE> }
bool RenderBlock::handlePositionedChild ( RenderBox * child , const MarginInfo & marginInfo ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> child -> containingBlock ( ) -> insertPositionedObject ( child ) ; <NEW_LINE> adjustPositionedBlock ( child , marginInfo ) ; <NEW_LINE> return true ;
string16 GetDialogTitle ( const Extension * extension ) const ; <NEW_LINE> <START_VULN> string16 GetHeading ( std::string extension_name ) const ; <NEW_LINE> <END_VULN> string16 GetAcceptButtonLabel ( ) const ; <NEW_LINE> bool HasAbortButtonLabel ( ) const ; <NEW_LINE> string16 GetAbortButtonLabel ( ) const ;
} <NEW_LINE> static void gamma_transform_test ( png_modifier * pm , <NEW_LINE> <START_VULN> PNG_CONST png_byte colour_type , PNG_CONST png_byte bit_depth , <NEW_LINE>PNG_CONST int palette_number , <NEW_LINE>PNG_CONST int interlace_type , PNG_CONST double file_gamma , <NEW_LINE>PNG_CONST double screen_gamma , PNG_CONST png_byte sbit , <NEW_LINE>PNG_CONST int use_input_precision , PNG_CONST int scale16 ) <NEW_LINE> <END_VULN> { <NEW_LINE> size_t pos = 0 ; <NEW_LINE> char name [ 64 ] ;
{ <NEW_LINE> zval		 * retval_ptr ; <NEW_LINE> zval	 ** args [ 1 ] ; <NEW_LINE> <START_VULN> zval		 * subpats ; <NEW_LINE> <END_VULN> int			 result_len ; <NEW_LINE> int			 i ;
kUCTextBreakLineMask , <NEW_LINE> position == 0 ? kUCTextBreakLeadingEdgeMask : <NEW_LINE> ( kUCTextBreakLeadingEdgeMask | <NEW_LINE> kUCTextBreakIterateMask ) , <NEW_LINE> aText , <NEW_LINE> aLength , <NEW_LINE> position , <NEW_LINE> & offset ) ; <NEW_LINE> <START_VULN> if ( status != noErr ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> aBreakBefore [ offset ] = true ; <NEW_LINE> position = offset ; <NEW_LINE> } <NEW_LINE> UCDisposeTextBreakLocator ( & breakLocator ) ; <NEW_LINE> }
SPL_METHOD ( DirectoryIterator , isDot ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
} <NEW_LINE> <START_VULN> dlen = ceph_x_decrypt ( secret , p , end , dbuf , <NEW_LINE>TEMP_TICKET_BUF_LEN ) ; <NEW_LINE> <END_VULN> if ( dlen <= 0 ) { <NEW_LINE> ret = dlen ; <NEW_LINE> goto out ;
LIns * guardRec = createGuardRecord ( exit ) ; <NEW_LINE> lir -> insGuard ( LIR_xbarrier , NULL , guardRec ) ; <NEW_LINE> } <NEW_LINE> LIns * res_ins = lir -> insCall ( sn -> builtin , args ) ; <NEW_LINE> if ( rooted ) <NEW_LINE> <START_VULN> lir -> insStorei ( INS_NULL ( ) , cx_ins , offsetof ( JSContext , nativeVp ) ) ; <NEW_LINE> <END_VULN> rval_ins = res_ins ; <NEW_LINE> switch ( JSTN_ERRTYPE ( sn ) ) { <NEW_LINE> case FAIL_NULL: <NEW_LINE> guard ( false , lir -> ins_eq0 ( res_ins ) , OOM_EXIT ) ; <NEW_LINE> break ; <NEW_LINE> case FAIL_NEG: <NEW_LINE> res_ins = lir -> ins1 ( LIR_i2f , res_ins ) ;
if ( regs && ! perf_exclude_event ( event , regs ) ) { <NEW_LINE> if ( ! ( event -> attr . exclude_idle && current -> pid == 0 ) ) <NEW_LINE> <START_VULN> if ( perf_event_overflow ( event , 0 , & data , regs ) ) <NEW_LINE> <END_VULN> ret = HRTIMER_NORESTART ; <NEW_LINE> }
vp9_iht4x4_16_add ( input , dest , stride , tx_type ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <NEW_LINE> <END_VULN> int stride , int eob ) { <NEW_LINE> if ( tx_type == DCT_DCT ) { <NEW_LINE> vp9_idct8x8_add ( input , dest , stride , eob ) ;
const png_structrp png_ptr = image -> opaque -> png_ptr ; <NEW_LINE> const png_uint_32 output_format = image -> format ; <NEW_LINE> <START_VULN> const int output_encoding = ( output_format & PNG_FORMAT_FLAG_LINEAR ) ? <NEW_LINE> <END_VULN> P_LINEAR : P_sRGB ; <NEW_LINE> unsigned int cmap_entries ;
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> RefPtr < DocumentFragment > fragment = createDocumentFragmentForElement ( markup , toElement ( element ) , AllowScriptingContentAndDoNotMarkAlreadyStarted ) ; <NEW_LINE> <END_VULN> if ( ! fragment ) { <NEW_LINE> ec = NOT_SUPPORTED_ERR ;
virtual bool OnMessageReceived ( const IPC::Message & message ) OVERRIDE ; <NEW_LINE> void OnFindReply ( int request_id , <NEW_LINE> int number_of_matches , <NEW_LINE> const gfx::Rect & selection_rect , <NEW_LINE> int active_match_ordinal , <NEW_LINE> bool final_update ) ; <NEW_LINE> <START_VULN> private: <NEW_LINE> <END_VULN> TabContentsWrapper * tab_contents_ ;
if ( ! btpan_cb . congest_packet_size ) { <NEW_LINE> <START_VULN> ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ; <NEW_LINE> <END_VULN> switch ( ret ) { <NEW_LINE> case - 1: <NEW_LINE> BTIF_TRACE_ERROR ( " % s unable to read from driver: % s" , __func__ , strerror ( errno ) ) ;
bool isHandlingUserInput = false ; <NEW_LINE> if ( aEvent -> mFlags . mIsTrusted ) { <NEW_LINE> switch ( aEvent -> message ) { <NEW_LINE> case NS_KEY_PRESS: <NEW_LINE> case NS_KEY_DOWN: <NEW_LINE> case NS_KEY_UP: { <NEW_LINE> <START_VULN> nsIDocument * doc = mCurrentEventContent ? <NEW_LINE> <END_VULN> mCurrentEventContent -> OwnerDoc ( ) : nullptr ; <NEW_LINE> nsIDocument * root = nullptr ; <NEW_LINE> if ( static_cast < const nsKeyEvent * > ( aEvent ) -> keyCode == NS_VK_ESCAPE && <NEW_LINE> ( root = nsContentUtils::GetRootDocument ( doc ) ) && <NEW_LINE> root -> IsFullScreenDoc ( ) ) {
len = strlen ( locale_name ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> zend_alter_ini_entry ( LOCALE_INI_NAME , sizeof ( LOCALE_INI_NAME ) , locale_name , len , PHP_INI_USER , PHP_INI_STAGE_RUNTIME ) ; <NEW_LINE> <END_VULN> RETURN_TRUE ; <NEW_LINE> }
NS_ERROR ( "Null NPObject passed to nsNPObjWrapper::GetNewOrUsed ( ) ! " ) ; <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> if ( npobj -> _class == & nsJSObjWrapper::sJSObjWrapperNPClass ) { <NEW_LINE> <START_VULN> return ( ( nsJSObjWrapper * ) npobj ) -> mJSObj ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! npp ) { <NEW_LINE> NS_ERROR ( "No npp passed to nsNPObjWrapper::GetNewOrUsed ( ) ! " ) ; <NEW_LINE> return nullptr ; <NEW_LINE> }
} <NEW_LINE> SoftAACEncoder:: ~ SoftAACEncoder ( ) { <NEW_LINE> <START_VULN> delete [ ] mInputFrame ; <NEW_LINE>mInputFrame = NULL ; <NEW_LINE> <END_VULN> if ( mEncoderHandle ) { <NEW_LINE> CHECK_EQ ( VO_ERR_NONE , mApiHandle -> Uninit ( mEncoderHandle ) ) ;
int words = bits >> 5 ; <NEW_LINE> int remainder = bits & 0x1F ; <NEW_LINE> <START_VULN> ld -> bytes_left = ld -> buffer_size - words * 4 ; <NEW_LINE> <END_VULN> if ( ld -> bytes_left >= 4 ) <NEW_LINE> {
} <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
httpChannel -> GetResponseHeader ( NS_LITERAL_CSTRING ( "Content - Type" ) , <NEW_LINE> header ) ; <NEW_LINE> nsCAutoString contentType ; <NEW_LINE> nsCAutoString charset ; <NEW_LINE> NS_ParseContentType ( header , contentType , charset ) ; <NEW_LINE> <START_VULN> mIsUnsafe = ! contentType . EqualsLiteral ( "application / java - archive" ) && <NEW_LINE> ! contentType . EqualsLiteral ( "application / x - jar" ) ; <NEW_LINE> <END_VULN> rv = httpChannel -> GetResponseHeader ( NS_LITERAL_CSTRING ( "Content - Disposition" ) , <NEW_LINE> header ) ; <NEW_LINE> if ( NS_SUCCEEDED ( rv ) ) <NEW_LINE> SetPropertyAsACString ( NS_CHANNEL_PROP_CONTENT_DISPOSITION , header ) ; <NEW_LINE> } else { <NEW_LINE> nsCOMPtr < nsIJARChannel > innerJARChannel ( do_QueryInterface ( channel ) ) ; <NEW_LINE> if ( innerJARChannel ) { <NEW_LINE> PRBool unsafe ;
#elif LONG_MIN < - 2147483646 && LONG_MAX > 2147483646 <NEW_LINE> typedef long int png_int_32 ; <NEW_LINE> #else <NEW_LINE> <START_VULN> # error "libpng requires a signed 32 bit ( or more ) type" <NEW_LINE> <END_VULN> #endif <NEW_LINE> #if UINT_MAX > 4294967294
0 , <NEW_LINE> 128 , <NEW_LINE> <START_VULN> #if VPX_ENCODER_ABI_VERSION == ( 1 + VPX_CODEC_ABI_VERSION ) <NEW_LINE>"vp8 . fpf" <NEW_LINE>#endif <NEW_LINE> <END_VULN> VPX_SS_DEFAULT_LAYERS , <NEW_LINE> { 0 } , <NEW_LINE> 1 , <NEW_LINE> { 0 } ,
unsigned int sse ; <NEW_LINE> cpi -> find_fractional_mv_step ( <NEW_LINE> x , dst_mv , ref_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , <NEW_LINE> <START_VULN> & v_fn_ptr , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion , <NEW_LINE> & sse ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> xd -> mi [ 0 ] -> mbmi . mode = NEWMV ;
png_free ( png_ptr , row ) ; <NEW_LINE> <START_VULN> if ( ! result ) <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
parentBlockFlow -> markSiblingsWithFloatsForLayout ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( diff == StyleDifferenceLayout || ! oldStyle ) <NEW_LINE> <END_VULN> createOrDestroyMultiColumnFlowThreadIfNeeded ( ) ; <NEW_LINE> }
ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; <NEW_LINE> if ( ret == 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <NEW_LINE> <END_VULN> #ifdef USE_HCACHE <NEW_LINE> mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; <NEW_LINE> #endif <NEW_LINE> commit 9bfab35522301794483f8f9ed60820bdec9be59e <NEW_LINE> Author: Richard Russon < rich@flatcap . org > <NEW_LINE> Date: Thu Jul 5 13:32:17 2018 + 0100 <NEW_LINE> sanitise cache paths <NEW_LINE> Co - authored - by: JerikoOne < jeriko . one@gmx . us >
SPL_METHOD ( SplFileObject , fgets ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
case IP6M_CAREOF_TEST_INIT: <NEW_LINE> hlen = IP6M_MINLEN ; <NEW_LINE> if ( ndo -> ndo_vflag ) { <NEW_LINE> <START_VULN> ND_TCHECK2 ( * mh , hlen + 8 ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , " % s Init Cookie = % 08x: % 08x" , <NEW_LINE> type == IP6M_HOME_TEST_INIT ? "Home" : "Care - of" , <NEW_LINE> EXTRACT_32BITS ( & bp [ hlen ] ) ,
settings . use_cas = true ; <NEW_LINE> settings . access = 0700 ; <NEW_LINE> settings . port = 11211 ; <NEW_LINE> <START_VULN> settings . udpport = 11211 ; <NEW_LINE> <END_VULN> settings . inter = NULL ; <NEW_LINE> settings . maxbytes = 64 * 1024 * 1024 ;
<START_VULN> <NEW_LINE> <END_VULN> goto no_match ; <NEW_LINE> } else if ( found == NULL && ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { <NEW_LINE> goto match ;
#if JS_HAS_XML_SUPPORT <NEW_LINE> <START_VULN> if ( pn && onlyXML && ( tcflags & TCF_NO_SCRIPT_RVAL ) ) { <NEW_LINE> <END_VULN> parser . reportErrorNumber ( NULL , JSREPORT_ERROR , JSMSG_XML_WHOLE_PROGRAM ) ; <NEW_LINE> goto out ; <NEW_LINE> } <NEW_LINE> #endif
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . overloadedMethod6" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( RefPtr < DOMStringList > , listArg , v8ValueToWebCoreDOMStringList ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> imp -> overloadedMethod ( listArg ) ;
ifr . ifr_flags &= ~ IFF_UP ; <NEW_LINE> <START_VULN> ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <NEW_LINE> <END_VULN> close ( sk ) ;
if ( fDecimalQuantity -> isZero ( ) ) { <NEW_LINE> fDecimalStr -> append ( "0" , - 1 , status ) ; <NEW_LINE> <START_VULN> } else if ( std::abs ( fDecimalQuantity -> getMagnitude ( ) ) < 5 ) { <NEW_LINE> <END_VULN> fDecimalStr -> appendInvariantChars ( fDecimalQuantity -> toPlainString ( ) , status ) ; <NEW_LINE> } else { <NEW_LINE> fDecimalStr -> appendInvariantChars ( fDecimalQuantity -> toScientificString ( ) , status ) ;
<START_VULN> nsIFrame * framesToRemove = nsnull ; <NEW_LINE> <END_VULN> while ( f && f -> mContentOffset < end ) { <NEW_LINE> f -> mContentOffset = end ; <NEW_LINE> if ( f -> GetTextRun ( nsTextFrame::eInflated ) != mTextRun ) { <NEW_LINE> ClearTextRuns ( ) ; <NEW_LINE> f -> ClearTextRuns ( ) ; <NEW_LINE> } <NEW_LINE> nsTextFrame * next = static_cast < nsTextFrame * > ( f -> GetNextInFlow ( ) ) ;
{ <NEW_LINE> c = ReadBlobByte ( image ) ; <NEW_LINE> if ( c == EOF ) <NEW_LINE> <START_VULN> return ( 0 ) ; <NEW_LINE> <END_VULN> } while ( ( c == ' ' ) || ( c == '\t' ) || ( c == '\n' ) || ( c == '\r' ) ) ; <NEW_LINE> Evaluate number .
case eCSSUnit_Counter: aResult . AppendLiteral ( "counter ( " ) ; break ; <NEW_LINE> case eCSSUnit_Counters: aResult . AppendLiteral ( "counters ( " ) ; break ; <NEW_LINE> case eCSSUnit_Cubic_Bezier: aResult . AppendLiteral ( "cubic - bezier ( " ) ; break ; <NEW_LINE> default: break ; <NEW_LINE> } <NEW_LINE> nsCSSValue::Array * array = aValue . GetArrayValue ( ) ; <NEW_LINE> PRBool mark = PR_FALSE ; <NEW_LINE> <START_VULN> for ( PRUint16 i = 0 , i_end = array -> Count ( ) ; i < i_end ; ++ i ) { <NEW_LINE> <END_VULN> if ( aProperty == eCSSProperty_border_image && i >= 5 ) { <NEW_LINE> if ( array -> Item ( i ) . GetUnit ( ) == eCSSUnit_Null ) { <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> if ( i == 5 ) { <NEW_LINE> aResult . AppendLiteral ( " / " ) ; <NEW_LINE> } <NEW_LINE> }
conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> DBG_RETURN ( ret ) ; <NEW_LINE> <END_VULN> }
} <NEW_LINE> } <NEW_LINE> jsval v ; <NEW_LINE> if ( ! RewrapObject ( cx , scope , callThisObj , NONE , & v ) ) { <NEW_LINE> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! JS_CallFunctionValue ( cx , JSVAL_TO_OBJECT ( v ) , OBJECT_TO_JSVAL ( funToCall ) , <NEW_LINE>argc , argv , rval ) ) { <NEW_LINE> <END_VULN> return JS_FALSE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return WrapJSValue ( cx , safeObj , * rval , rval ) ; <NEW_LINE> } <NEW_LINE> static JSBool
nsresult <NEW_LINE> nsDOMAttribute::RemoveChildAt ( PRUint32 aIndex , bool aNotify ) <NEW_LINE> { <NEW_LINE> if ( aIndex != 0 || ! mChild ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> { <NEW_LINE>nsCOMPtr < nsIContent > child = mChild ; <NEW_LINE>nsMutationGuard::DidMutate ( ) ; <NEW_LINE>mozAutoDocUpdate updateBatch ( OwnerDoc ( ) , UPDATE_CONTENT_MODEL , aNotify ) ; <NEW_LINE><NEW_LINE>doRemoveChild ( aNotify ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> nsString nullString ; <NEW_LINE> SetDOMStringToNull ( nullString ) ; <NEW_LINE> SetValue ( nullString ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult
{ <NEW_LINE> char * p1 , * p2 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( intern -> file_name ) { <NEW_LINE> efree ( intern -> file_name ) ; <NEW_LINE> }
return FAILURE ; <NEW_LINE> } <NEW_LINE> break ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> case cs_8859_15: <NEW_LINE> if ( code < 0xA4 || ( code > 0xBE && code <= 0xFF ) ) { <NEW_LINE> * res = code ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> FileManager::GetUsage ( nsIFile * aDirectory , uint64_t * aUsage ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> bool exists ; <NEW_LINE> nsresult rv = aDirectory -> Exists ( & exists ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> if ( ! exists ) { <NEW_LINE> * aUsage = 0 ; <NEW_LINE> return NS_OK ;
RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ; <NEW_LINE> RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ; <NEW_LINE> RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ; <NEW_LINE> <START_VULN> RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ; <NEW_LINE> <END_VULN> RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; <NEW_LINE> RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; <NEW_LINE> RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ;
list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { <NEW_LINE> if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && <NEW_LINE> cmd -> device -> lun == my_cmd -> device -> lun ) <NEW_LINE> <START_VULN> sas_eh_defer_cmd ( cmd ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
int i ; <NEW_LINE> for ( i = 0 ; i < header_line_len ; i ++ ) { <NEW_LINE> <START_VULN> <NEW_LINE>int illegal_break = <NEW_LINE> ( header_line [ i + 1 ] != ' ' && header_line [ i + 1 ] != '\t' ) <NEW_LINE> && ( <NEW_LINE>header_line [ i ] == '\n' <NEW_LINE> || ( header_line [ i ] == '\r' && header_line [ i + 1 ] != '\n' ) ) ; <NEW_LINE>if ( illegal_break ) { <NEW_LINE> <END_VULN> efree ( header_line ) ; <NEW_LINE> sapi_module . sapi_error ( E_WARNING , "Header may not contain " <NEW_LINE> "more than a single header , new line detected" ) ;
if ( ! js_ComputeThis ( cx , JS_TRUE , argv ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> js_GetTopStackFrame ( cx ) -> thisp = JSVAL_TO_OBJECT ( argv [ - 1 ] ) ; <NEW_LINE> JS_ASSERT ( cx -> fp -> argv == argv ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( argc != 0 ) { <NEW_LINE><NEW_LINE>argv [ -- argc ] = JSVAL_VOID ; <NEW_LINE> } <NEW_LINE> <END_VULN> return fs -> call ( cx , JSVAL_TO_OBJECT ( argv [ - 1 ] ) , argc , argv , rval ) ; <NEW_LINE> } <NEW_LINE> JS_END_EXTERN_C <NEW_LINE> JS_PUBLIC_API ( JSBool ) <NEW_LINE> JS_DefineFunctions ( JSContext * cx , JSObject * obj , JSFunctionSpec * fs ) <NEW_LINE> { <NEW_LINE> uintN flags ;
Value referent = wrapper -> private_ ( ) ; <NEW_LINE> MarkValueRoot ( trc , & referent , "cross - compartment wrapper" ) ; <NEW_LINE> JS_ASSERT ( referent == wrapper -> private_ ( ) ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> <START_VULN> JSCompartment::mark ( JSTracer * trc ) <NEW_LINE> <END_VULN> { <NEW_LINE> JS_ASSERT ( ! trc -> runtime -> isHeapMinorCollecting ( ) ) ; <NEW_LINE> #ifdef JS_ION <NEW_LINE> if ( jitCompartment_ ) <NEW_LINE> jitCompartment_ -> mark ( trc , this ) ; <NEW_LINE> #endif
} <NEW_LINE> ~ nsTextShadowArray ( ) { <NEW_LINE> MOZ_COUNT_DTOR ( nsTextShadowArray ) ; <NEW_LINE> for ( PRUint32 i = 1 ; i < mLength ; ++ i ) { <NEW_LINE> mArray [ i ] . ~ nsTextShadowItem ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> nsrefcnt AddRef ( ) { return ++ mRefCnt ; } <NEW_LINE> <END_VULN> nsrefcnt Release ( ) ; <NEW_LINE> PRUint32 Length ( ) const { return mLength ; } <NEW_LINE> nsTextShadowItem * ShadowAt ( PRUint32 i ) { <NEW_LINE> NS_ABORT_IF_FALSE ( i < mLength , "Accessing too high an index in the text shadow array ! " ) ; <NEW_LINE> return & mArray [ i ] ; <NEW_LINE> } <NEW_LINE> const nsTextShadowItem * ShadowAt ( PRUint32 i ) const {
if ( ! ( obj -> type & MPR_JSON_ARRAY ) ) { <NEW_LINE> return result ; <NEW_LINE> } <NEW_LINE> <START_VULN> s = stok ( property , ": \t" , & e ) ; <NEW_LINE> <END_VULN> start = ( ssize ) stoi ( s ) ; <NEW_LINE> end = ( ssize ) stoi ( e ) ; <NEW_LINE> if ( start < 0 ) {
int rd = ( opcode & RD ) >> 11 ; <NEW_LINE> int rt = ( opcode & RT ) >> 16 ; <NEW_LINE> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <NEW_LINE> <START_VULN> 1 , 0 , regs , 0 ) ; <NEW_LINE> <END_VULN> switch ( rd ) { <NEW_LINE> case 0: <NEW_LINE> regs -> regs [ rt ] = smp_processor_id ( ) ;
#include < stdlib . h > <NEW_LINE> #include < errno . h > <NEW_LINE> <START_VULN> #define OK 0 <NEW_LINE>#define ERROR 1 <NEW_LINE>#define NOT_FOUND - ENOENT <NEW_LINE> <END_VULN> #define ALIGN_TO ( val , alignment ) \ <NEW_LINE> ( ( ( uintptr_t ) ( val ) + ( ( alignment ) - 1 ) ) & ~ ( ( alignment ) - 1 ) )
ListHashSet < RootInlineBox * > lineBoxes ; <NEW_LINE> for ( InlineWalker walker ( this ) ; ! walker . atEnd ( ) ; walker . advance ( ) ) { <NEW_LINE> RenderObject * o = walker . current ( ) ; <NEW_LINE> <START_VULN> if ( ! o -> isPositioned ( ) && ( o -> isReplaced ( ) || o -> isFloating ( ) ) ) { <NEW_LINE> <END_VULN> o -> layoutIfNeeded ( ) ; <NEW_LINE> if ( toRenderBox ( o ) -> inlineBoxWrapper ( ) ) { <NEW_LINE> RootInlineBox * box = toRenderBox ( o ) -> inlineBoxWrapper ( ) -> root ( ) ;
} <NEW_LINE> NS_ADDREF ( * aStyle = mDOMDeclaration ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsCSSKeyframeRule::ChangeDeclaration ( css::Declaration * aDeclaration ) <NEW_LINE> { <NEW_LINE> <START_VULN> mDeclaration = aDeclaration ; <NEW_LINE> <END_VULN> if ( mSheet ) { <NEW_LINE> mSheet -> SetModifiedByChildRule ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> size_t <NEW_LINE> nsCSSKeyframeRule::SizeOfIncludingThis ( nsMallocSizeOfFun aMallocSizeOf ) const
if ( urisEqual ) { <NEW_LINE> sourceURI = docCurrentURI ; <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> sourceURI = principalURI ; <NEW_LINE> } <NEW_LINE> <START_VULN> owner = do_QueryInterface ( secMan -> GetCxSubjectPrincipal ( cx ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsCOMPtr < nsIDocShellLoadInfo > loadInfo ; <NEW_LINE> docShell -> CreateLoadInfo ( getter_AddRefs ( loadInfo ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( loadInfo , NS_ERROR_FAILURE ) ; <NEW_LINE> loadInfo -> SetOwner ( owner ) ;
udpmsg . msg_name = ( void * ) & udpdest ; <NEW_LINE> udpmsg . msg_namelen = sizeof ( udpdest ) ; <NEW_LINE> udpmsg . msg_iov = & iov [ 0 ] ; <NEW_LINE> <START_VULN> udpmsg . msg_iovlen = msg -> msg_iovlen + 1 ; <NEW_LINE> <END_VULN> udpmsg . msg_control = NULL ; <NEW_LINE> udpmsg . msg_controllen = 0 ; <NEW_LINE> udpmsg . msg_flags = 0 ;
#ifdef PNG_READ_sPLT_SUPPORTED <NEW_LINE> else if ( chunk_name == png_sPLT ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_sPLT ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
fputs ( " " , stdout ) ; <NEW_LINE> fputs ( name , stdout ) ; <NEW_LINE> fputs ( " = \"" , stdout ) ; <NEW_LINE> <START_VULN> safe_print ( value , valsz , "\"" ) ; <NEW_LINE> <END_VULN> fputs ( "\"" , stdout ) ; <NEW_LINE> } <NEW_LINE> }
} <NEW_LINE> } else { <NEW_LINE> <START_VULN> syslog ( LOG_WARNING , _ ( " ( % d ) Unhandeled control packet type: % d" ) , curconn -> seskey , cpkt . cptype ) ; <NEW_LINE> <END_VULN> }
protected: <NEW_LINE> explicit EncoderTest ( const CodecFactory * codec ) <NEW_LINE> : codec_ ( codec ) , abort_ ( false ) , init_flags_ ( 0 ) , frame_flags_ ( 0 ) , <NEW_LINE> <START_VULN> last_pts_ ( 0 ) { } <NEW_LINE> <END_VULN> virtual ~ EncoderTest ( ) { }
return ZEND_HASH_APPLY_STOP ; <NEW_LINE> } <NEW_LINE> <START_VULN> fname_len = ( php_stat_len ) strlen ( fname ) ; <NEW_LINE> <END_VULN> save = fname ; <NEW_LINE> goto phar_spl_fileinfo ; <NEW_LINE> }
} <NEW_LINE> } else { <NEW_LINE> byte_run = - byte_run ; <NEW_LINE> <START_VULN> CHECK_PIXEL_PTR ( byte_run ) ; <NEW_LINE> <END_VULN> for ( j = 0 ; j < byte_run ; j ++ ) { <NEW_LINE> * ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ) ; <NEW_LINE> stream_ptr += 2 ;
if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <NEW_LINE> goto out ; <NEW_LINE> <START_VULN> ret = sort_idmaps ( & new_map ) ; <NEW_LINE>if ( ret < 0 ) <NEW_LINE>goto out ; <NEW_LINE><NEW_LINE> <END_VULN> ret = - EPERM ; <NEW_LINE> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <NEW_LINE> memcpy ( map -> extent , new_map . extent ,
for ( i = 0 ; object_prototype_names [ i ] . init ; i ++ ) { <NEW_LINE> atom = StdNameToAtom ( cx , & object_prototype_names [ i ] ) ; <NEW_LINE> if ( ! atom ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> if ( idstr == ATOM_TO_STRING ( atom ) ) { <NEW_LINE> <START_VULN> stdnm = & standard_class_names [ i ] ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( stdnm ) {
blue_y ; <NEW_LINE> if ( png_get_cHRM_fixed ( read_ptr , read_info_ptr , & white_x , & white_y , <NEW_LINE> <START_VULN> & red_x , & red_y , & green_x , & green_y , & blue_x , & blue_y ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_set_cHRM_fixed ( write_ptr , write_info_ptr , white_x , white_y , red_x , <NEW_LINE> red_y , green_x , green_y , blue_x , blue_y ) ;
Delegate * delegate ( ) const { return delegate_ ; } <NEW_LINE> int max_pending_send_allowed ( ) const { return max_pending_send_allowed_ ; } <NEW_LINE> <START_VULN> URLRequestContext * context ( ) { return context_ . get ( ) ; } <NEW_LINE> <END_VULN> void set_context ( URLRequestContext * context ) ;
xdr -> reghash = NULL ; <NEW_LINE> xdr -> userdata = NULL ; <NEW_LINE> xdr -> script = NULL ; <NEW_LINE> <START_VULN> xdr -> filename = NULL ; <NEW_LINE>xdr -> atoms = NULL ; <NEW_LINE>xdr -> atomsMap = NULL ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_PUBLIC_API ( JSXDRState * )
if ( mScriptOwner ) { <NEW_LINE> NS_DROP_JS_OBJECTS ( this , IDBWrapperCache ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> IDBWrapperCache::SetScriptOwner ( JSObject * aScriptOwner ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! aScriptOwner ) { <NEW_LINE>NS_ASSERTION ( ! mScriptOwner , <NEW_LINE>"Don't null out existing owner , we need to call " <NEW_LINE>"DropJSObjects ! " ) ; <NEW_LINE><NEW_LINE>return true ; <NEW_LINE> } <NEW_LINE> <END_VULN> mScriptOwner = aScriptOwner ; <NEW_LINE> nsISupports * thisSupports = NS_CYCLE_COLLECTION_UPCAST ( this , IDBWrapperCache ) ; <NEW_LINE> nsXPCOMCycleCollectionParticipant * participant ; <NEW_LINE> CallQueryInterface ( this , & participant ) ; <NEW_LINE> nsresult rv = nsContentUtils::HoldJSObjects ( thisSupports , participant ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) {
else if ( chunk_name == png_PLTE ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE> <END_VULN> png_handle_PLTE ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
static const char * exec_name ; <NEW_LINE> <START_VULN> void usage_exit ( ) { <NEW_LINE> <END_VULN> fprintf ( stderr , "Usage: % s < infile > < outfile > \n" , exec_name ) ; <NEW_LINE> exit ( EXIT_FAILURE ) ; <NEW_LINE> }
<START_VULN> #if defined ( __cplusplus ) && ! defined ( __STDC_FORMAT_MACROS ) <NEW_LINE>#define __STDC_FORMAT_MACROS <NEW_LINE>#endif <NEW_LINE> <END_VULN> #include < stdint . h > <NEW_LINE> #endif
png_uint_32 crc ; <NEW_LINE> int need_crc = 1 ; <NEW_LINE> <START_VULN> if ( PNG_CHUNK_ANCILLARY ( png_ptr -> chunk_name ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ( png_ptr -> flags & PNG_FLAG_CRC_ANCILLARY_MASK ) == <NEW_LINE> ( PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN ) )
mThebesSurface = nsnull ; <NEW_LINE> if ( mDragMotionTimerID ) { <NEW_LINE> gtk_timeout_remove ( mDragMotionTimerID ) ; <NEW_LINE> mDragMotionTimerID = 0 ; <NEW_LINE> } <NEW_LINE> if ( mShell ) { <NEW_LINE> gtk_widget_destroy ( mShell ) ; <NEW_LINE> mShell = nsnull ; <NEW_LINE> mContainer = nsnull ; <NEW_LINE> } <NEW_LINE> else if ( mContainer ) { <NEW_LINE> gtk_widget_destroy ( GTK_WIDGET ( mContainer ) ) ; <NEW_LINE> mContainer = nsnull ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( mDrawingarea ) { <NEW_LINE>g_object_unref ( mDrawingarea ) ; <NEW_LINE>mDrawingarea = nsnull ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> OnDestroy ( ) ; <NEW_LINE> #ifdef ACCESSIBILITY <NEW_LINE> if ( mRootAccessible ) { <NEW_LINE> mRootAccessible = nsnull ; <NEW_LINE> } <NEW_LINE> #endif
{ <NEW_LINE> - 1 , 1 , 5 , 6 , 17 , 33 , 25 , 28 , 40 , 7 , <NEW_LINE> 15 , 19 , 21 , 30 , 31 , 37 , 38 , 52 , 53 , 121 , <NEW_LINE> <START_VULN> 166 , 75 , 136 , 137 , 76 , 94 , 78 , 180 , 202 , 191 , <NEW_LINE>140 , 139 , 189 , 125 , 195 , 143 , 178 , 185 , 186 , 79 , <NEW_LINE> <END_VULN> 80 <NEW_LINE> } ;
<START_VULN> nsresult nsIDNService::stringPrep ( const nsAString & in , nsAString & out ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ! mNamePrepHandle || ! mNormalizer ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> PRUint32 ucs4Buf [ kMaxDNSNodeLen + 1 ] ; <NEW_LINE> PRUint32 ucs4Len ; <NEW_LINE> utf16ToUcs4 ( in , ucs4Buf , kMaxDNSNodeLen , & ucs4Len ) ;
nsAutoString domain ( someData ) ; <NEW_LINE> <START_VULN> if ( mIsFrozen ) { <NEW_LINE> <END_VULN>
PolicySubsystemState state ( ) ; <NEW_LINE> ErrorDetails error_details ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>void StopAutoRetry ( ) ; <NEW_LINE> <END_VULN> static void RegisterPrefs ( PrefService * pref_service ) ;
start , end + 1 , GFP_KERNEL ) ; <NEW_LINE> if ( family -> id < 0 ) { <NEW_LINE> err = family -> id ; <NEW_LINE> <START_VULN> goto errout_locked ; <NEW_LINE> <END_VULN> } <NEW_LINE> err = genl_validate_assign_mc_groups ( family ) ;
if ( version != s -> version ) <NEW_LINE> { <NEW_LINE> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ; <NEW_LINE> <START_VULN> <NEW_LINE>s -> version = version ; <NEW_LINE> <END_VULN> al = SSL_AD_PROTOCOL_VERSION ; <NEW_LINE> goto f_err ; <NEW_LINE> }
MprKey * kp ; <NEW_LINE> MprFile * file ; <NEW_LINE> cchar * actionProgram , * ext , * cmdShell , * cp , * start , * path ; <NEW_LINE> <START_VULN> char * tok , buf [ ME_MAX_FNAME + 1 ] ; <NEW_LINE> <END_VULN> rx = conn -> rx ; <NEW_LINE> tx = conn -> tx ;
if ( IsAnimValList ( ) ) { <NEW_LINE> Element ( ) -> FlushAnimations ( ) ; <NEW_LINE> } <NEW_LINE> return LengthNoFlush ( ) ; <NEW_LINE> } <NEW_LINE> void Clear ( ErrorResult & error ) ; <NEW_LINE> already_AddRefed < dom::SVGTransform > Initialize ( dom::SVGTransform & newItem , <NEW_LINE> ErrorResult & error ) ; <NEW_LINE> <START_VULN> dom::SVGTransform * GetItem ( uint32_t index , ErrorResult & error ) <NEW_LINE> { <NEW_LINE>bool found ; <NEW_LINE>dom::SVGTransform * item = IndexedGetter ( index , found , error ) ; <NEW_LINE>if ( ! found ) { <NEW_LINE>error . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; <NEW_LINE> } <NEW_LINE>return item ; <NEW_LINE> } <NEW_LINE>dom::SVGTransform * IndexedGetter ( uint32_t index , bool & found , <NEW_LINE>ErrorResult & error ) ; <NEW_LINE> <END_VULN> already_AddRefed < dom::SVGTransform > InsertItemBefore ( dom::SVGTransform & newItem , <NEW_LINE> uint32_t index , <NEW_LINE> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < dom::SVGTransform > ReplaceItem ( dom::SVGTransform & newItem , <NEW_LINE> uint32_t index , <NEW_LINE> ErrorResult & error ) ; <NEW_LINE> already_AddRefed < dom::SVGTransform > RemoveItem ( uint32_t index , <NEW_LINE> ErrorResult & error ) ;
NS_TIMELINE_MARK_TIMER ( "rdf blocking parse" ) ; <NEW_LINE> mListener = nsnull ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> <START_VULN> rv = NS_OpenURI ( this , nsnull , mURL , nsnull ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> mLoadState = eLoadState_Pending ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> FCLOSE ( fpin ) ; <NEW_LINE> FCLOSE ( fpout ) ;
static void setAppDefaults ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> app -> company = stok ( slower ( ME_COMPANY ) , " " , NULL ) ; <NEW_LINE> <END_VULN> app -> serviceProgram = sclone ( SERVICE_PROGRAM ) ; <NEW_LINE> app -> serviceName = sclone ( SERVICE_NAME ) ; <NEW_LINE> app -> serviceHome = mprGetNativePath ( SERVICE_HOME ) ;
{ <NEW_LINE> char * tok , * delim , * host , * path , * port , * scheme , * reference , * query , * ext , * buf , * buf2 ; <NEW_LINE> ssize buflen , ulen , len ; <NEW_LINE> <START_VULN> int rc ; <NEW_LINE> <END_VULN> assert ( pbuf ) ; <NEW_LINE> if ( url == 0 ) {
switch ( result ) { <NEW_LINE> case WebDataConsumerHandle::Ok: { <NEW_LINE> DOMUint8Array * array = DOMUint8Array::create ( static_cast < const unsigned char * > ( buffer ) , available ) ; <NEW_LINE> <START_VULN> if ( RuntimeEnabledFeatures::responseBodyWithV8ExtraStreamEnabled ( ) ) { <NEW_LINE>controller ( ) -> enqueue ( array ) ; <NEW_LINE>m_streamNeedsMore = controller ( ) -> desiredSize ( ) > 0 ; <NEW_LINE> } else { <NEW_LINE>m_streamNeedsMore = m_stream -> enqueue ( array ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> m_reader -> endRead ( available ) ; <NEW_LINE> break ; <NEW_LINE> }
result = ejsCreatePot ( ejs , ESV ( Object ) , 0 ) ; <NEW_LINE> for ( ep = environ ; ep && * ep ; ep ++ ) { <NEW_LINE> pair = sclone ( * ep ) ; <NEW_LINE> <START_VULN> key = stok ( pair , " = " , & value ) ; <NEW_LINE> <END_VULN> ejsSetPropertyByName ( ejs , result , EN ( key ) , ejsCreateStringFromAsc ( ejs , value ) ) ; <NEW_LINE> } <NEW_LINE> return result ;
double dr = ( double ) cpi -> bytes_in_layer [ i ] * <NEW_LINE> 8 . 0 / 1000 . 0 / time_encoded ; <NEW_LINE> double samples = 3 . 0 / 2 * cpi -> frames_in_layer [ i ] * <NEW_LINE> <START_VULN> lst_yv12 -> y_width * lst_yv12 -> y_height ; <NEW_LINE> <END_VULN> double total_psnr = <NEW_LINE> vpx_sse_to_psnr ( samples , 255 . 0 , <NEW_LINE> cpi -> total_error2 [ i ] ) ;
icu::UnicodeSet cyrillic_letters_ ; <NEW_LINE> icu::UnicodeSet cyrillic_letters_latin_alike_ ; <NEW_LINE> icu::UnicodeSet lgc_letters_n_ascii_ ; <NEW_LINE> <START_VULN> std::unique_ptr < icu::Transliterator > transliterator_ ; <NEW_LINE> <END_VULN> IDNSpoofChecker ( const IDNSpoofChecker & ) = delete ; <NEW_LINE> void operator = ( const IDNSpoofChecker & ) = delete ;
bool isHorizontal = style ( ) -> isHorizontalWritingMode ( ) ; <NEW_LINE> for ( RenderObject * curr = firstChild ( ) ; curr ; curr = curr -> nextSibling ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> continue ;
path -> lineTo ( WebCoreFloatToSkScalar ( points [ i ] . x ( ) ) , <NEW_LINE> WebCoreFloatToSkScalar ( points [ i ] . y ( ) ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> path -> setIsConvex ( true ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void GraphicsContext::drawConvexPolygon ( size_t numPoints ,
m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = 0 ; <NEW_LINE> for ( RenderBox * child = firstChildBox ( ) ; child ; child = child -> nextSiblingBox ( ) ) { <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> LayoutUnit margin = marginLogicalWidthForChild ( child , style ( ) ) ;
const std::string & test_user , <NEW_LINE> bool synchronous_backend_initialization , <NEW_LINE> Task * initial_condition_setup_task ) <NEW_LINE> <START_VULN> : ProfileSyncService ( factory , profile , <NEW_LINE> ! test_user . empty ( ) ? <NEW_LINE>test_user : "" ) , <NEW_LINE> <END_VULN> synchronous_backend_initialization_ ( <NEW_LINE> synchronous_backend_initialization ) , <NEW_LINE> synchronous_sync_configuration_ ( false ) ,
break ; <NEW_LINE> case SKFP_CLR_STATS: <NEW_LINE> if ( ! capable ( CAP_NET_ADMIN ) ) { <NEW_LINE> memset ( & lp -> MacStat , 0 , sizeof ( lp -> MacStat ) ) ; <NEW_LINE> <START_VULN> } else { <NEW_LINE>status = - EPERM ; <NEW_LINE> <END_VULN> } <NEW_LINE> break ; <NEW_LINE> default:
nsAutoTArray < PtrInfo * , 4000 > whiteNodes ; <NEW_LINE> if ( ! PrepareForCollection ( aResults , & whiteNodes ) ) <NEW_LINE> return ; <NEW_LINE> uint32_t totalCollections = 0 ; <NEW_LINE> while ( aTryCollections > totalCollections ) { <NEW_LINE> <START_VULN> GCIfNeeded ( true ) ; <NEW_LINE> <END_VULN> if ( aListener && NS_FAILED ( aListener -> Begin ( ) ) ) <NEW_LINE> aListener = nullptr ; <NEW_LINE> if ( ! ( BeginCollection ( aMergeCompartments , aListener ) && <NEW_LINE> FinishCollection ( aListener ) ) ) <NEW_LINE> break ; <NEW_LINE> ++ totalCollections ; <NEW_LINE> }
y ; <NEW_LINE> unsigned char <NEW_LINE> <START_VULN> * lastrow , <NEW_LINE> <END_VULN> * one_row , <NEW_LINE> * ptr ;
#define PPAPI_DISPATCH_HOST_RESOURCE_CALL_0 ( msg_class , member_func ) \ <NEW_LINE> case msg_class::ID: { \ <NEW_LINE> <START_VULN> TRACK_RUN_IN_IPC_HANDLER ( member_func ) ; \ <NEW_LINE> <END_VULN> return member_func ( context ) ; \ <NEW_LINE> }
#include "third_party / blink / public / common / user_agent / user_agent_metadata . h" <NEW_LINE> #include "third_party / blink / public / mojom / renderer_preference_watcher . mojom - forward . h" <NEW_LINE> #include "third_party / blink / public / mojom / web_feature / web_feature . mojom - forward . h" <NEW_LINE> <START_VULN> #include "third_party / blink / public / mojom / window_features / window_features . mojom - forward . h" <NEW_LINE> <END_VULN> #include "ui / accessibility / ax_mode . h" <NEW_LINE> #include "ui / base / page_transition_types . h" <NEW_LINE> #include "ui / base / window_open_disposition . h"
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: fft transform <NEW_LINE> <START_VULN> last mod: $ Id $ <NEW_LINE> <END_VULN> #ifndef _V_SMFT_H_ <NEW_LINE> #define _V_SMFT_H_ <NEW_LINE> #include "vorbis / codec . h"
virtual IntRect PageRect ( ) = 0 ; <NEW_LINE> <START_VULN> virtual void Focus ( ) = 0 ; <NEW_LINE> <END_VULN> virtual bool CanTakeFocus ( WebFocusType ) = 0 ; <NEW_LINE> virtual void TakeFocus ( WebFocusType ) = 0 ;
<START_VULN> class FidlInterfaceRequest { <NEW_LINE> <END_VULN> public: <NEW_LINE> template < typename Interface > <NEW_LINE> explicit FidlInterfaceRequest ( fidl::InterfaceRequest < Interface > request )
const nsAString & key = aNode . GetKeyAt ( i ) ; <NEW_LINE> CopyUTF16toUTF8 ( key , k ) ; <NEW_LINE> ToLowerCase ( k ) ; <NEW_LINE> nsCOMPtr < nsIAtom > keyAtom = do_GetAtom ( k ) ; <NEW_LINE> if ( ! sAllowedAttributes || ! sAllowedAttributes -> GetEntry ( keyAtom ) ) { <NEW_LINE> <START_VULN> continue ; <NEW_LINE> <END_VULN> } <NEW_LINE> static const char * kWhitespace = "\n\r\t\b" ; <NEW_LINE> const nsAString & v = <NEW_LINE> nsContentUtils::TrimCharsInSet ( kWhitespace , aNode . GetValueAt ( i ) ) ;
<START_VULN> prior = mprLookupJsonObj ( params , keyword ) ; <NEW_LINE> <END_VULN> if ( prior && prior -> type == MPR_JSON_VALUE ) { <NEW_LINE> if ( * value ) { <NEW_LINE> newValue = sjoin ( prior -> value , " " , value , NULL ) ;
{ <NEW_LINE> struct chunk * chunk = zlib -> chunk ; <NEW_LINE> int rc ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> assert ( zlib -> rewrite_offset < chunk -> chunk_length ) ; <NEW_LINE> rc = zlib_advance ( zlib , chunk -> chunk_length - zlib -> rewrite_offset ) ;
yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != '"' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 707 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> size_t len , len2 , len3 , maxlen ; <NEW_LINE> long elements ;
for ( x = 0 ; x < MAX_UINPUT_PATHS ; x ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> fd = open ( uinput_dev_path [ x ] , O_RDWR ) ; <NEW_LINE> <END_VULN> if ( fd < 0 ) <NEW_LINE> continue ; <NEW_LINE> break ;
printf ( "Creating new JSObject\n" ) ; <NEW_LINE> #endif <NEW_LINE> wrapperObj = ::JS_NewObject ( cx , XPCNativeWrapper::GetJSClass ( ) , nsnull , <NEW_LINE> <START_VULN> wrappedNative -> GetScope ( ) -> GetGlobalJSObject ( ) ) ; <NEW_LINE><NEW_LINE>if ( ! wrapperObj || ! ::JS_SetPrototype ( cx , wrapperObj , nsnull ) ) { <NEW_LINE> <END_VULN> return JS_FALSE ; <NEW_LINE> }
} <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsWindow::SetCursor ( nsCursor aCursor ) <NEW_LINE> { <NEW_LINE> if ( ! mContainer && mDrawingarea ) { <NEW_LINE> <START_VULN> GtkWidget * widget = <NEW_LINE>get_gtk_widget_for_gdk_window ( mDrawingarea -> inner_window ) ; <NEW_LINE>nsWindow * window = get_window_for_gtk_widget ( widget ) ; <NEW_LINE> <END_VULN> return window -> SetCursor ( aCursor ) ; <NEW_LINE> } <NEW_LINE> if ( aCursor != mCursor ) { <NEW_LINE> GdkCursor * newCursor = NULL ; <NEW_LINE> newCursor = get_gtk_cursor ( aCursor ) ;
void WasmCompileStreamingImpl ( const v8::FunctionCallbackInfo < v8::Value > & args ) { <NEW_LINE> v8::Isolate * isolate = args . GetIsolate ( ) ; <NEW_LINE> <START_VULN> ScriptState * script_state = ScriptState::ForRelevantRealm ( args ) ; <NEW_LINE> <END_VULN> v8::Local < v8::Function > compile_callback = <NEW_LINE> v8::Function::New ( isolate , CompileFromResponseCallback ) ;
if ( ( memcmp ( p_bda , btm_cb . pairing_bda , BD_ADDR_LEN ) == 0 ) && <NEW_LINE> ( btm_cb . pairing_state == BTM_PAIR_STATE_WAIT_AUTH_COMPLETE ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>if ( ! btm_cb . pin_code_len_saved ) <NEW_LINE> { <NEW_LINE>btsnd_hcic_pin_code_neg_reply ( p_bda ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>else <NEW_LINE> { <NEW_LINE>btsnd_hcic_pin_code_req_reply ( p_bda , btm_cb . pin_code_len_saved , p_cb -> pin_code ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> else if ( ( btm_cb . pairing_state != BTM_PAIR_STATE_WAIT_PIN_REQ ) <NEW_LINE> || memcmp ( p_bda , btm_cb . pairing_bda , BD_ADDR_LEN ) != 0 )
rv = NS_NewStorageStream ( 4096 , UINT32_MAX , getter_AddRefs ( storStream ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsCOMPtr < nsIOutputStream > output ; <NEW_LINE> rv = storStream -> GetOutputStream ( 0 , getter_AddRefs ( output ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> rv = serializer -> SerializeToStream ( aDoc , output , aCharset ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <END_VULN> output -> Close ( ) ; <NEW_LINE> uint32_t length ; <NEW_LINE> rv = storStream -> GetLength ( & length ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> * aContentLength = length ;
default: <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> return cocoaEvent ; <NEW_LINE> } <NEW_LINE> void nsPluginInstanceOwner::PerformDelayedBlurs ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsCOMPtr < EventTarget > windowRoot = mContent -> OwnerDoc ( ) -> GetWindow ( ) -> GetTopWindowRoot ( ) ; <NEW_LINE>nsContentUtils::DispatchTrustedEvent ( mContent -> OwnerDoc ( ) , <NEW_LINE> <END_VULN> windowRoot , <NEW_LINE> NS_LITERAL_STRING ( "MozPerformDelayedBlur" ) , <NEW_LINE> false , false , nullptr ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> nsEventStatus nsPluginInstanceOwner::ProcessEvent ( const WidgetGUIEvent & anEvent )
if ( tokval == ( v & rotbit ) ) { <NEW_LINE> <START_VULN> buflen += snprintf ( buf + buflen , sizeof ( buf ) - buflen , " % s % s" , <NEW_LINE>sepstr , lp -> s ) ; <NEW_LINE> <END_VULN> sepstr = sep ; <NEW_LINE> break ; <NEW_LINE> }
inode -> i_ino , ( unsigned long ) ce -> e_block ) ; <NEW_LINE> } else { <NEW_LINE> lock_buffer ( bh ) ; <NEW_LINE> <START_VULN> if ( le32_to_cpu ( HDR ( bh ) -> h_refcount ) > <NEW_LINE> <END_VULN> EXT2_XATTR_REFCOUNT_MAX ) { <NEW_LINE> ea_idebug ( inode , "block % ld refcount % d > % d" , <NEW_LINE> ( unsigned long ) ce -> e_block ,
virtual void TabInsertedAt ( content::WebContents * contents , <NEW_LINE> int index , <NEW_LINE> bool foreground ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void TabDetachedAt ( TabContents * contents , int index ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual void TabReplacedAt ( TabStripModel * tab_strip_model , <NEW_LINE> TabContents * old_contents , <NEW_LINE> TabContents * new_contents ,
PLDHashOperator <NEW_LINE> nsFormFillController::RemoveForDocumentEnumerator ( const nsINode * aKey , <NEW_LINE> bool & aEntry , <NEW_LINE> void * aUserData ) <NEW_LINE> { <NEW_LINE> PwmgrInputsEnumData * ed = static_cast < PwmgrInputsEnumData * > ( aUserData ) ; <NEW_LINE> if ( aKey && ( ! ed -> mDoc || aKey -> OwnerDoc ( ) == ed -> mDoc ) ) { <NEW_LINE> <START_VULN> const_cast < nsINode * > ( aKey ) -> RemoveMutationObserver ( ed -> mMutationObserver ) ; <NEW_LINE> <END_VULN> return PL_DHASH_REMOVE ; <NEW_LINE> } <NEW_LINE> return PL_DHASH_NEXT ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsFormFillController::Focus ( nsIDOMEvent * aEvent ) <NEW_LINE> {
} <NEW_LINE> static void <NEW_LINE> <START_VULN> make_size ( png_store * PNG_CONST ps , png_byte PNG_CONST colour_type , int bdlo , <NEW_LINE>int PNG_CONST bdhi ) <NEW_LINE> <END_VULN> { <NEW_LINE> for ( ; bdlo <= bdhi ; ++ bdlo ) <NEW_LINE> {
void AccumulateContentLength ( <NEW_LINE> int64 received_payload_byte_count , int64 original_payload_byte_count , <NEW_LINE> <START_VULN> bool data_reduction_proxy_was_used ) ; <NEW_LINE> <END_VULN> scoped_refptr < extensions::EventRouterForwarder > event_router_ ; <NEW_LINE> void * profile_ ;
{ <NEW_LINE> if ( m_loader ) <NEW_LINE> return true ; <NEW_LINE> <START_VULN> if ( RuntimeEnabledFeatures::responseBodyWithV8ExtraStreamEnabled ( ) ) <NEW_LINE>return UnderlyingSourceBase::hasPendingActivity ( ) ; <NEW_LINE><NEW_LINE>return m_stream -> stateInternal ( ) == ReadableStream::Readable && m_stream -> isLocked ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void BodyStreamBuffer::stop ( )
class Decoder { <NEW_LINE> public: <NEW_LINE> Decoder ( vpx_codec_dec_cfg_t cfg , unsigned long deadline ) <NEW_LINE> <START_VULN> : cfg_ ( cfg ) , deadline_ ( deadline ) , init_done_ ( false ) { <NEW_LINE> <END_VULN> memset ( & decoder_ , 0 , sizeof ( decoder_ ) ) ; <NEW_LINE> }
char * realptr ; <NEW_LINE> char ** ptr = ( endptr != NULL ) ? endptr : & realptr ; <NEW_LINE> <START_VULN> if ( strlen ( str ) >= sizeof ( lowstr ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> errno = PGTYPES_TS_BAD_TIMESTAMP ; <NEW_LINE> return ( noresult ) ;
return rv ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> #ifndef HACKED_EXPORT_SERVER <NEW_LINE> PORT_SetError ( SSL_ERROR_PUB_KEY_SIZE_LIMIT_EXCEEDED ) ; <NEW_LINE> return rv ; <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> <START_VULN> #ifndef NSS_DISABLE_ECC <NEW_LINE> } else if ( ( kea_def -> kea == kea_ecdhe_rsa ) || <NEW_LINE> ( kea_def -> kea == kea_ecdhe_ecdsa ) ) { <NEW_LINE>rv = ssl3_SendServerKeyExchange ( ss ) ; <NEW_LINE>if ( rv != SECSuccess ) { <NEW_LINE>return rv ; <NEW_LINE> } <NEW_LINE>#endif <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ss -> opt . requestCertificate ) { <NEW_LINE> rv = ssl3_SendCertificateRequest ( ss ) ; <NEW_LINE> if ( rv != SECSuccess ) { <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> }
walk ++ ; <NEW_LINE> } else <NEW_LINE> return 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( * walk && * walk >= '0' && * walk <= '9' ) { <NEW_LINE> * backref = * backref * 10 + * walk - '0' ; <NEW_LINE> walk ++ ;
if ( sortInfo . db && sortInfo . naturalOrderSort ) { <NEW_LINE> <START_VULN> nsCOMPtr < nsIContent > parent = do_QueryInterface ( container , & rv ) ; <NEW_LINE>nsCOMPtr < nsIContent > aContent ; <NEW_LINE><NEW_LINE>nsCOMPtr < nsIDocument > doc ; <NEW_LINE>if ( NS_SUCCEEDED ( rv ) && parent ) { <NEW_LINE>doc = parent -> GetDocument ( ) ; <NEW_LINE>if ( ! doc ) <NEW_LINE>parent = nsnull ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( parent ) { <NEW_LINE> <END_VULN> nsAutoString id ; <NEW_LINE> rv = trueParent -> GetAttr ( kNameSpaceID_None , nsXULAtoms::ref , id ) ;
file -> path = * in_path ; <NEW_LINE> for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <NEW_LINE> <START_VULN> int j , len = apdu . resp [ i + 1 ] ; <NEW_LINE> <END_VULN> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; <NEW_LINE> switch ( type ) {
{ <NEW_LINE> UWORD8 i ; <NEW_LINE> dec_seq_params_t * ps_seq = NULL ; <NEW_LINE> <START_VULN> UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ; <NEW_LINE> <END_VULN> UWORD16 i2_max_frm_num ; <NEW_LINE> UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; <NEW_LINE> UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ;
static String HHVM_FUNCTION ( bcpow , const String & left , const String & right , <NEW_LINE> int64_t scale ) { <NEW_LINE> <START_VULN> if ( scale < 0 ) scale = BCG ( bc_precision ) ; <NEW_LINE> <END_VULN> bc_num first , second , result ; <NEW_LINE> bc_init_num ( & first ) ; <NEW_LINE> bc_init_num ( & second ) ;
IPC_MESSAGE_CONTROL2 ( ChromeUtilityMsg_AnalyzeZipFileForDownloadProtection , <NEW_LINE> IPC::PlatformFileForTransit , <NEW_LINE> IPC::PlatformFileForTransit ) <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #if defined ( OS_WIN )
if ( NXT ( 1 ) == '#' ) { <NEW_LINE> int i = 0 ; <NEW_LINE> <START_VULN> xmlChar out [ 10 ] ; <NEW_LINE> <END_VULN> int hex = NXT ( 2 ) ; <NEW_LINE> int value = xmlParseCharRef ( ctxt ) ;
void <NEW_LINE> png_reset_crc ( png_structrp png_ptr ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> png_ptr -> crc = ( png_uint_32 ) crc32 ( 0 , Z_NULL , 0 ) ; <NEW_LINE> }
v = gamma_to_1 [ * sp ] ; <NEW_LINE> png_composite ( w , v , a , png_ptr -> background_1 . gray ) ; <NEW_LINE> <START_VULN> if ( ! optimize ) <NEW_LINE> <END_VULN> w = gamma_from_1 [ w ] ; <NEW_LINE> * sp = w ; <NEW_LINE> }
break ; <NEW_LINE> case EFFECT_CMD_ENABLE: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> } <NEW_LINE> if ( pDownmixer -> state != DOWNMIX_STATE_INITIALIZED ) {
png_byte vpag_chunk_data [ 9 ] ; <NEW_LINE> <START_VULN> if ( verbose ) <NEW_LINE> <END_VULN> fprintf ( STDERR , " vpAg = % lu x % lu , units = % d\n" , <NEW_LINE> ( unsigned long ) user_chunk_data . vpAg_width , <NEW_LINE> ( unsigned long ) user_chunk_data . vpAg_height ,
" < a href = \"http: <NEW_LINE> " < / body > \n" <NEW_LINE> " < / html > \n" , errname , code , errname , <NEW_LINE> <START_VULN> ( url ? " ( " : "" ) , ( url ? url : "" ) , ( url ? " ) " : "" ) ) ; <NEW_LINE> <END_VULN> if ( res == - 1 ) <NEW_LINE> {
verbose_only ( branches = NULL ; ) <NEW_LINE> PodArrayZero ( vmfragments ) ; <NEW_LINE> tracedScripts . clear ( ) ; <NEW_LINE> needFlush = JS_FALSE ; <NEW_LINE> } <NEW_LINE> static bool <NEW_LINE> <START_VULN> HasUnreachableGCThingsImpl ( JSContext * cx , TreeFragment * f ) <NEW_LINE> { <NEW_LINE>if ( f -> visiting ) <NEW_LINE>return false ; <NEW_LINE>f -> visiting = true ; <NEW_LINE><NEW_LINE>if ( ! f -> code ( ) ) <NEW_LINE>return false ; <NEW_LINE><NEW_LINE> <END_VULN> if ( IsAboutToBeFinalized ( cx , f -> globalObj ) ) <NEW_LINE> return true ; <NEW_LINE> Value * vp = f -> gcthings . data ( ) ; <NEW_LINE> for ( unsigned len = f -> gcthings . length ( ) ; len ; -- len ) {
eWOFF_warn_checksum_mismatch = 0x0200 , <NEW_LINE> eWOFF_warn_misaligned_table = 0x0400 , <NEW_LINE> eWOFF_warn_trailing_data = 0x0800 , <NEW_LINE> eWOFF_warn_unpadded_table = 0x1000 , <NEW_LINE> <START_VULN> eWOFF_warn_removed_DSIG = 0x2000 <NEW_LINE> <END_VULN> } ; <NEW_LINE> #define WOFF_SUCCESS ( status ) ( ( ( uint32_t ) ( status ) & 0xff ) == eWOFF_ok ) <NEW_LINE> #define WOFF_FAILURE ( status ) ( ! WOFF_SUCCESS ( status ) )
( * length ) -- ; <NEW_LINE> buffer [ i ] = ( unsigned char ) c ; <NEW_LINE> } <NEW_LINE> <START_VULN> value = ( size_t ) ( buffer [ 0 ] << 24 ) ; <NEW_LINE>value |= buffer [ 1 ] << 16 ; <NEW_LINE>value |= buffer [ 2 ] << 8 ; <NEW_LINE>value |= buffer [ 3 ] ; <NEW_LINE>quantum . unsigned_value = ( value & 0xffffffff ) ; <NEW_LINE> <END_VULN> return ( quantum . signed_value ) ; <NEW_LINE> }
return rv ; <NEW_LINE> } <NEW_LINE> NS_IMPL_ISUPPORTS_INHERITED0 ( DeleteDatabaseHelper , AsyncConnectionHelper ) ; <NEW_LINE> nsresult <NEW_LINE> DeleteDatabaseHelper::DoDatabaseWork ( mozIStorageConnection * aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> NS_ASSERTION ( ! aConnection , "How did we get a connection here ? " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "DeleteDatabaseHelper::DoDatabaseWork" ) ; <NEW_LINE> const StoragePrivilege & privilege = mOpenHelper -> Privilege ( ) ; <NEW_LINE> QuotaManager * quotaManager = QuotaManager::Get ( ) ;
pos += size ; <NEW_LINE> <START_VULN> assert ( ( segment_stop < 0 ) || ( pos <= segment_stop ) ) ; <NEW_LINE> <END_VULN>
class CORE_EXPORT Microtask { <NEW_LINE> public: <NEW_LINE> <START_VULN> static void performCheckpoint ( ) ; <NEW_LINE> <END_VULN> static bool performingCheckpoint ( v8::Isolate * ) ;
static void php_mcrypt_module_dtor ( zend_rsrc_list_entry * rsrc TSRMLS_DC ) <NEW_LINE> { <NEW_LINE> php_mcrypt * pm = ( php_mcrypt * ) rsrc -> ptr ; <NEW_LINE> <START_VULN> if ( pm ) { <NEW_LINE> <END_VULN> mcrypt_generic_deinit ( pm -> td ) ; <NEW_LINE> mcrypt_module_close ( pm -> td ) ; <NEW_LINE> efree ( pm ) ;
_y4m -> convert = y4m_convert_422_420jpeg ; <NEW_LINE> } else { <NEW_LINE> _y4m -> vpx_fmt = VPX_IMG_FMT_I422 ; <NEW_LINE> <START_VULN> _y4m -> vpx_bps = 16 ; <NEW_LINE> <END_VULN> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; <NEW_LINE> _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; <NEW_LINE> _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h
if ( OwnerIsBrowserFrame ( ) ) { <NEW_LINE> flags = nsIWebNavigation::LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP | <NEW_LINE> nsIWebNavigation::LOAD_FLAGS_DISALLOW_INHERIT_OWNER ; <NEW_LINE> } <NEW_LINE> bool tmpState = mNeedsAsyncDestroy ; <NEW_LINE> mNeedsAsyncDestroy = true ; <NEW_LINE> <START_VULN> rv = mDocShell -> LoadURI ( mURIToLoad , loadInfo , flags , false ) ; <NEW_LINE> <END_VULN> mNeedsAsyncDestroy = tmpState ; <NEW_LINE> mURIToLoad = nullptr ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult
#endif <NEW_LINE> <START_VULN> if ( transforms & PNG_TRANSFORM_SWAP_ALPHA ) <NEW_LINE> <END_VULN> #ifdef PNG_READ_SWAP_ALPHA_SUPPORTED <NEW_LINE> png_set_swap_alpha ( png_ptr ) ; <NEW_LINE> #else
#include < string > <NEW_LINE> #include "base / atomic_sequence_num . h" <NEW_LINE> <START_VULN> #include "base / callback . h" <NEW_LINE> <END_VULN> #include "base / time . h" <NEW_LINE> #include "content / browser / cancelable_request . h" <NEW_LINE> #include "content / common / notification_observer . h"
if ( ps_slice -> u1_nal_ref_idc != 0 ) <NEW_LINE> { <NEW_LINE> if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) <NEW_LINE> <START_VULN> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; <NEW_LINE> }
{ <NEW_LINE> vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dst + 4 , stride , <NEW_LINE> dst + 4 , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( eobs [ 2 ] > 1 )
bool windowless = false ; <NEW_LINE> mInstance -> IsWindowless ( & windowless ) ; <NEW_LINE> if ( ! windowless ) { <NEW_LINE> nsCOMPtr < nsIWidget > parentWidget ; <NEW_LINE> nsIDocument * doc = nullptr ; <NEW_LINE> <START_VULN> if ( mContent ) { <NEW_LINE>doc = mContent -> OwnerDoc ( ) ; <NEW_LINE> <END_VULN> parentWidget = nsContentUtils::WidgetForDocument ( doc ) ; <NEW_LINE> #ifndef XP_MACOSX <NEW_LINE> if ( XRE_GetProcessType ( ) == GeckoProcessType_Content ) { <NEW_LINE> nsCOMPtr < nsIDOMWindow > window = doc -> GetWindow ( ) ; <NEW_LINE> if ( window ) { <NEW_LINE> nsCOMPtr < nsIDOMWindow > topWindow ; <NEW_LINE> window -> GetTop ( getter_AddRefs ( topWindow ) ) ;
if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) { <NEW_LINE> <START_VULN> if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || <NEW_LINE> <END_VULN> ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) { <NEW_LINE> if ( snprintf ( scratch , scratch_len , "Host: % s: % i\r\n" , resource -> host , resource -> port ) > 0 ) <NEW_LINE> php_stream_write ( stream , scratch , strlen ( scratch ) ) ;
{ <NEW_LINE> } <NEW_LINE> nsIconDecoder:: ~ nsIconDecoder ( ) <NEW_LINE> { } <NEW_LINE> void <NEW_LINE> <START_VULN> nsIconDecoder::WriteInternal ( const char * aBuffer , uint32_t aCount ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ABORT_IF_FALSE ( ! HasError ( ) , "Shouldn't call WriteInternal after error ! " ) ; <NEW_LINE> uint32_t bytesToRead = 0 ;
nsCycleCollectionParticipant * helper ) = 0 ; <NEW_LINE> NS_IMETHOD_ ( void ) NoteNextEdgeName ( const char * name ) = 0 ; <NEW_LINE> <START_VULN> NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * val ) = 0 ; <NEW_LINE> <END_VULN> enum { <NEW_LINE> WANT_DEBUG_INFO = ( 1 << 0 ) ,
png_free ( png_ptr , distance ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_READ_GAMMA_SUPPORTED <NEW_LINE> void PNGFAPI
createHandlerWith ( mStylesheet -> getOutputFormat ( ) , & handler ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> mOutputHandler = handler ; <NEW_LINE> mResultHandler = handler ; <NEW_LINE> mOutputHandler -> startDocument ( ) ; <NEW_LINE> <START_VULN> nsAutoPtr < txXPathNode > document ( txXPathNodeUtils::getOwnerDocument ( aNode ) ) ; <NEW_LINE>NS_ENSURE_TRUE ( document , NS_ERROR_FAILURE ) ; <NEW_LINE><NEW_LINE>rv = mLoadedDocuments . init ( document ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE><NEW_LINE><NEW_LINE>document . forget ( ) ; <NEW_LINE> <END_VULN> rv = mKeyHash . init ( ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> mRecycler = new txResultRecycler ; <NEW_LINE> NS_ENSURE_TRUE ( mRecycler , NS_ERROR_OUT_OF_MEMORY ) ;
else <NEW_LINE> mb_ppl = ( unsigned char ) ppl ; <NEW_LINE> <START_VULN> vpx_memset ( ylptr , mb_ppl , 16 ) ; <NEW_LINE>vpx_memset ( uvlptr , mb_ppl , 8 ) ; <NEW_LINE> <END_VULN> ylptr += 16 ; <NEW_LINE> uvlptr += 8 ;
void InitPrefMembers ( ) ; <NEW_LINE> <START_VULN> virtual PrefService * GetOriginalProfilePrefs ( ) ; <NEW_LINE> <END_VULN>
std::cout << "FAILED:" ; <NEW_LINE> else <NEW_LINE> std::cout << "passed:" ; <NEW_LINE> <START_VULN> std::cout << " GenerateWord32 and Crop\n" ; <END_VULN> <NEW_LINE> <NEW_LINE> std::cout . flush ( ) ; <NEW_LINE> return pass ;
Value * array = reinterpret_cast < Value * > ( self ) ; <NEW_LINE> blink::HeapObjectHeader * header = <NEW_LINE> blink::HeapObjectHeader::fromPayload ( self ) ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> size_t length = header -> payloadSize ( ) / sizeof ( Value ) ;
if ( ! NS_ProcessNextEvent ( thread ) ) { <NEW_LINE> NS_ERROR ( "Failed to process next event ! " ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>if ( NS_FAILED ( mIOThread -> Shutdown ( ) ) ) { <NEW_LINE>NS_WARNING ( "Failed to shutdown IO thread ! " ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> if ( NS_FAILED ( mShutdownTimer -> Init ( this , DEFAULT_SHUTDOWN_TIMER_MS , <NEW_LINE> nsITimer::TYPE_ONE_SHOT ) ) ) { <NEW_LINE> NS_WARNING ( "Failed to initialize shutdown timer ! " ) ; <NEW_LINE> } <NEW_LINE> TransactionThreadPool::Shutdown ( ) ; <NEW_LINE> if ( NS_FAILED ( mShutdownTimer -> Cancel ( ) ) ) { <NEW_LINE> NS_WARNING ( "Failed to cancel shutdown timer ! " ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> mFileManagers . Enumerate ( InvalidateAndRemoveFileManagers , nullptr ) ; <NEW_LINE> if ( PR_ATOMIC_SET ( & gClosed , 1 ) ) { <NEW_LINE> NS_ERROR ( "Close more than once ? ! " ) ; <NEW_LINE> }
if ( args . Length ( ) != 3 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> WebGLRenderingContext * context = V8WebGLRenderingContext::toNative ( args . Holder ( ) ) ;
void set_range_supported ( ) ; <NEW_LINE> void set_last_modified ( base::Time last_modified ) ; <NEW_LINE> void set_etag ( const std::string & etag ) ; <NEW_LINE> <START_VULN> void set_has_opaque_data ( bool has_opaque_data ) ; <NEW_LINE> <END_VULN>
if ( JSP_SHOULD_EXECUTE && lhs ) { <NEW_LINE> if ( op == ' = ' ) { <NEW_LINE> <START_VULN> <NEW_LINE>if ( ! jsvGetRefs ( lhs ) && jsvIsName ( lhs ) ) { <NEW_LINE>if ( ! jsvIsArrayBufferName ( lhs ) && ! jsvIsNewChild ( lhs ) ) <NEW_LINE>jsvAddName ( execInfo . root , lhs ) ; <NEW_LINE> } <NEW_LINE>jspReplaceWith ( lhs , rhs ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> if ( op == LEX_PLUSEQUAL ) op = ' + ' ; <NEW_LINE> else if ( op == LEX_MINUSEQUAL ) op = ' - ' ;
if ( spotLight ) { <NEW_LINE> float S [ 3 ] ; <NEW_LINE> S [ 0 ] = pointsAt [ 0 ] - lightPos [ 0 ] ; <NEW_LINE> S [ 1 ] = pointsAt [ 1 ] - lightPos [ 1 ] ; <NEW_LINE> S [ 2 ] = pointsAt [ 2 ] - lightPos [ 2 ] ; <NEW_LINE> NORMALIZE ( S ) ; <NEW_LINE> float dot = - DOT ( L , S ) ; <NEW_LINE> <START_VULN> if ( dot < cosConeAngle ) { <NEW_LINE>color = NS_RGB ( 0 , 0 , 0 ) ; <NEW_LINE> } else { <NEW_LINE>float tmp = pow ( dot , specularExponent ) ; <NEW_LINE>color = NS_RGB ( PRUint8 ( NS_GET_R ( lightColor ) * tmp ) , <NEW_LINE>PRUint8 ( NS_GET_G ( lightColor ) * tmp ) , <NEW_LINE>PRUint8 ( NS_GET_B ( lightColor ) * tmp ) ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } else { <NEW_LINE> color = lightColor ; <NEW_LINE> } <NEW_LINE> LightPixel ( N , L , color , targetData + index ) ; <NEW_LINE> } <NEW_LINE> }
{ <NEW_LINE> size_t i ; <NEW_LINE> size_t j ; <NEW_LINE> <START_VULN> uchar * dp ; <NEW_LINE> <END_VULN> dp = data ; <NEW_LINE> for ( i = 0 ; i < len ; i += 16 ) { <NEW_LINE> fprintf ( out , " % 04zx:" , i ) ;
xmlBufCreateStatic ( void * mem , size_t size ) { <NEW_LINE> xmlBufPtr ret ; <NEW_LINE> <START_VULN> if ( ( mem == NULL ) || ( size == 0 ) ) <NEW_LINE> <END_VULN> return ( NULL ) ; <NEW_LINE> ret = ( xmlBufPtr ) xmlMalloc ( sizeof ( xmlBuf ) ) ;
virtual void OnReadMetadataCompleted ( ) MOZ_FINAL MOZ_OVERRIDE ; <NEW_LINE> private: <NEW_LINE> ReentrantMonitor mReentrantMonitor ; <NEW_LINE> nsCOMPtr < nsIThread > mDecodeThread ; <NEW_LINE> <START_VULN> nsAutoPtr < MediaResource > mResource ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> NS_IMPL_THREADSAFE_ISUPPORTS0 ( BufferDecoder ) <NEW_LINE> BufferDecoder::BufferDecoder ( MediaResource * aResource ) <NEW_LINE> : mReentrantMonitor ( "BufferDecoder" ) <NEW_LINE> , mResource ( aResource ) <NEW_LINE> {
if ( yych <= '9' ) goto yy97 ; <NEW_LINE> if ( yych != ' ; ' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 500 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> long id ;
"Entering INCLUDE Conditional Section\n" ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> while ( ( RAW != 0 ) && ( ( RAW != ' ] ' ) || ( NXT ( 1 ) != ' ] ' ) || <NEW_LINE> ( NXT ( 2 ) != ' > ' ) ) ) { <NEW_LINE> <END_VULN> const xmlChar * check = CUR_PTR ; <NEW_LINE> unsigned int cons = ctxt -> input -> consumed ;
set_task_ioprio ( sbi -> s_journal -> j_task , journal_ioprio ) ; <NEW_LINE> no_journal: <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( test_opt ( sb , NOBH ) ) { <NEW_LINE> if ( ! ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_WRITEBACK_DATA ) ) { <NEW_LINE> ext4_msg ( sb , KERN_WARNING , "Ignoring nobh option - " <NEW_LINE> "its supported only with writeback mode" ) ; <NEW_LINE> clear_opt ( sbi -> s_mount_opt , NOBH ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> EXT4_SB ( sb ) -> dio_unwritten_wq = create_workqueue ( "ext4 - dio - unwritten" ) ; <NEW_LINE> if ( ! EXT4_SB ( sb ) -> dio_unwritten_wq ) {
SAFE_E ( fread ( buf , 1 , 21 , fp ) , 21 , "Failed to load entry Size string . \n" ) ; <NEW_LINE> xref -> n_entries = atoi ( buf + strlen ( "ize " ) ) ; <NEW_LINE> <START_VULN> xref -> entries = calloc ( 1 , xref -> n_entries * sizeof ( struct _xref_entry ) ) ; <NEW_LINE> <END_VULN> obj_id = 0 ;
* rv = NS_ERROR_XPC_BAD_CONVERT_JS ; <NEW_LINE> if ( ! native ) <NEW_LINE> return nsnull ; <NEW_LINE> NS_ASSERTION ( IS_WRAPPER_CLASS ( js::GetObjectClass ( cur ) ) , "Not a wrapper ? " ) ; <NEW_LINE> <START_VULN> XPCNativeScriptableSharedJSClass * clasp = <NEW_LINE> ( XPCNativeScriptableSharedJSClass * ) js::GetObjectClass ( cur ) ; <NEW_LINE> <END_VULN> if ( ! ( clasp -> interfacesBitmap & ( 1 << interfaceBit ) ) ) <NEW_LINE> return nsnull ; <NEW_LINE> * pRef = nsnull ; <NEW_LINE> * pVal = OBJECT_TO_JSVAL ( cur ) ; <NEW_LINE> if ( lccx ) { <NEW_LINE> if ( wrapper )
<START_VULN> if ( childrenInline ( ) && ! newChild -> isInline ( ) && ! newChild -> isFloatingOrPositioned ( ) ) { <NEW_LINE> <END_VULN> makeChildrenNonInline ( beforeChild ) ; <NEW_LINE> madeBoxesNonInline = true ;
if ( onError ) { <NEW_LINE> JSDebugErrorHook hook = cx -> debugHooks -> debugErrorHook ; <NEW_LINE> if ( hook && <NEW_LINE> ! hook ( cx , msg , & report , cx -> debugHooks -> debugErrorHookData ) ) { <NEW_LINE> onError = NULL ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( onError ) { <NEW_LINE> <START_VULN> AutoScopedAssign < bool > ss ( & cx -> runtime -> inOOMReport , true ) ; <NEW_LINE> <END_VULN> onError ( cx , msg , & report ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> js_ReportOutOfScriptQuota ( JSContext * maybecx ) <NEW_LINE> { <NEW_LINE> if ( maybecx ) <NEW_LINE> JS_ReportErrorNumber ( maybecx , js_GetErrorMessage , NULL , JSMSG_SCRIPT_STACK_QUOTA ) ;
{ <NEW_LINE> return static_cast < nsXBLJSClass * > ( nsXBLService::gClassTable -> Get ( k ) ) ; <NEW_LINE> } <NEW_LINE> nsXBLBinding::nsXBLBinding ( nsXBLPrototypeBinding * aBinding ) <NEW_LINE> <START_VULN> : mMarkedForDeath ( false ) , <NEW_LINE>mPrototypeBinding ( aBinding ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ASSERTION ( mPrototypeBinding , "Must have a prototype binding ! " ) ; <NEW_LINE> NS_ADDREF ( mPrototypeBinding -> XBLDocumentInfo ( ) ) ; <NEW_LINE> } <NEW_LINE> nsXBLBinding:: ~ nsXBLBinding ( void )
, eItsMe , eItsMe , eItsMe , eError , eError ) , <NEW_LINE> PCK4BITS ( eError , 5 , eError , eError , eError , 4 , eError , eError ) , <NEW_LINE> PCK4BITS ( eError , eError , eError , 6 , eItsMe , eError , eItsMe , eError ) , <NEW_LINE> PCK4BITS ( eError , eError , eError , eError , eError , eError , eItsMe , eItsMe ) , <NEW_LINE> PCK4BITS ( eError , eError , eError , eItsMe , eError , eError , eError , eError ) , <NEW_LINE> PCK4BITS ( eError , eError , eError , eError , eItsMe , eError , eStart , eStart ) <NEW_LINE> } ; <NEW_LINE> <START_VULN> static const uint32_t ISO2022JPCharLenTable [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; <NEW_LINE> <END_VULN> const SMModel ISO2022JPSMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , ISO2022JP_cls } , <NEW_LINE> 10 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , ISO2022JP_st } , <NEW_LINE> CHAR_LEN_TABLE ( ISO2022JPCharLenTable ) , <NEW_LINE> "ISO - 2022 - JP" , <NEW_LINE> } ;
status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; <NEW_LINE> if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0 . 5 ) ; <NEW_LINE> <END_VULN> image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0 . 5 ) ; <NEW_LINE> } <NEW_LINE> else
RenderObject * container = object -> container ( ) ; <NEW_LINE> if ( ! container && ! object -> isRenderView ( ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( ! last -> isText ( ) && last -> style ( ) -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> bool willSkipRelativelyPositionedInlines = ! object -> isRenderBlock ( ) || object -> isAnonymousBlock ( ) ; <NEW_LINE> while ( object && ( ! object -> isRenderBlock ( ) || object -> isAnonymousBlock ( ) ) )
if ( nentries > 0 ) <NEW_LINE> png_chunk_report ( png_ptr , "sPLT out of memory" , PNG_CHUNK_WRITE_ERROR ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED <NEW_LINE> static png_byte
#if 0 <NEW_LINE> <START_VULN> if ( png_image_begin_read_from_file ( & image , argv [ 1 ] ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_bytep buffer ;
{ <NEW_LINE> FeatureMap testFeatureMap ; <NEW_LINE> dummyFace . replace_table ( TtfUtil::Tag::Feat , & table , sizeof ( T ) ) ; <NEW_LINE> <START_VULN> gr_face * face = gr_make_face_with_ops ( & dummyFace , & face_handle::ops , gr_face_dumbRendering ) ; <NEW_LINE> <END_VULN> if ( ! face ) throw std::runtime_error ( "failed to load font" ) ; <NEW_LINE> bool readStatus = testFeatureMap . readFeats ( * face ) ; <NEW_LINE> testAssert ( "readFeats" , readStatus ) ;
struct sk_buff * skb , * tmp ; <NEW_LINE> struct sctp_ulpevent * event ; <NEW_LINE> struct sctp_bind_hashbucket * head ; <NEW_LINE> <START_VULN> struct list_head tmplist ; <NEW_LINE>if ( oldsp -> do_auto_asconf ) { <NEW_LINE>memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ; <NEW_LINE>inet_sk_copy_descendant ( newsk , oldsk ) ; <NEW_LINE>memcpy ( & newsp -> auto_asconf_list , & tmplist , sizeof ( tmplist ) ) ; <NEW_LINE> } else <NEW_LINE>inet_sk_copy_descendant ( newsk , oldsk ) ; <NEW_LINE> <END_VULN>
being short or long * / <NEW_LINE> if ( v -> pcm_returned == - 1 ) { <NEW_LINE> v -> pcm_returned = thisCenter ; <NEW_LINE> v -> pcm_current = thisCenter ; <NEW_LINE> } else { <NEW_LINE> v -> pcm_returned = prevCenter ; <NEW_LINE> v -> pcm_current = prevCenter + <NEW_LINE> <START_VULN> ( ( ci -> blocksizes [ v -> lW ] / 4 + <NEW_LINE>ci -> blocksizes [ v -> W ] / 4 ) >> hs ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> making sure our last packet doesn't end with added padding . If <NEW_LINE> the last packet is partial , the number of samples we'll have to <NEW_LINE> return will be past the vb -> granulepos .
that -> alphaf = 1 ; <NEW_LINE> that -> alphae = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( that -> colour_type == PNG_COLOR_TYPE_RGB_ALPHA ) <NEW_LINE>that -> colour_type = PNG_COLOR_TYPE_RGB ; <NEW_LINE>else if ( that -> colour_type == PNG_COLOR_TYPE_GRAY_ALPHA ) <NEW_LINE>that -> colour_type = PNG_COLOR_TYPE_GRAY ; <NEW_LINE><NEW_LINE> <END_VULN> } <NEW_LINE> this -> next -> mod ( this -> next , that , pp , display ) ; <NEW_LINE> }
bool skippedAutoHeightContainingBlock = false ; <NEW_LINE> RenderBlock * cb = containingBlock ( ) ; <NEW_LINE> <START_VULN> while ( ! cb -> isRenderView ( ) && ! cb -> isBody ( ) && ! cb -> isTableCell ( ) && ! cb -> isPositioned ( ) && cb -> style ( ) -> logicalHeight ( ) . isAuto ( ) ) { <NEW_LINE> <END_VULN> if ( ! document ( ) -> inQuirksMode ( ) && ! cb -> isAnonymousBlock ( ) ) <NEW_LINE> break ; <NEW_LINE> skippedAutoHeightContainingBlock = true ;
#define STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED 0x0200 <NEW_LINE> #define STREAMTCP_STREAM_FLAG_DISABLE_RAW 0x400 <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN>
ACPI_PARSE_OBJECT * Op , <NEW_LINE> ACPI_STATUS Status ) <NEW_LINE> { <NEW_LINE> <START_VULN> ACPI_STATUS Status2 ; <NEW_LINE> <END_VULN> ACPI_FUNCTION_TRACE_PTR ( PsCompleteFinalOp , WalkState ) ;
SPL_METHOD ( SplFileObject , eof ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
return FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> WCHAR installDir [ MAX_PATH ] = { L'\0' } ; <NEW_LINE> <END_VULN> if ( ! GetInstallationDir ( argc , argv , installDir ) ) { <NEW_LINE> LOG_WARN ( ( "Could not get the installation directory" ) ) ; <NEW_LINE> if ( ! WriteStatusFailure ( argv [ 1 ] ,
rect -> Remove ( ) ; <NEW_LINE> if ( rect == band ) { <NEW_LINE> if ( topOfBand == next -> mTop ) { <NEW_LINE> band = next ; <NEW_LINE> } else { <NEW_LINE> band = nsnull ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( mCachedBandPosition == rect ) { <NEW_LINE>SetCachedBandPosition ( band ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> delete rect ; <NEW_LINE> rect = next ; <NEW_LINE> prevRect = nsnull ; <NEW_LINE> prevIsSharedRect = PR_FALSE ; <NEW_LINE> continue ; <NEW_LINE> }
IPC_MESSAGE_ROUTED0 ( PluginMsg_InstallMissingPlugin ) <NEW_LINE> <START_VULN> IPC_SYNC_MESSAGE_ROUTED1_0 ( PluginMsg_HandleURLRequestReply , <NEW_LINE>PluginMsg_URLRequestReply_Params ) <NEW_LINE> <END_VULN> IPC_SYNC_MESSAGE_ROUTED0_1 ( PluginMsg_CreateCommandBuffer , <NEW_LINE> int )
void vp9_frame_init_quantizer ( struct VP9_COMP * cpi ) ; <NEW_LINE> <START_VULN> void vp9_update_zbin_extra ( struct VP9_COMP * cpi , MACROBLOCK * x ) ; <NEW_LINE><NEW_LINE> <END_VULN> void vp9_init_plane_quantizers ( struct VP9_COMP * cpi , MACROBLOCK * x ) ; <NEW_LINE> void vp9_init_quantizer ( struct VP9_COMP * cpi ) ; <NEW_LINE> void vp9_set_quantizer ( struct VP9Common * cm , int q ) ; <NEW_LINE> #ifdef __cplusplus <NEW_LINE> } <NEW_LINE> #endif
} <NEW_LINE> } <NEW_LINE> <START_VULN> SeekHead:: ~ SeekHead ( ) { <NEW_LINE> } <NEW_LINE> <END_VULN> bool SeekHead::Finalize ( IMkvWriter * writer ) const { <NEW_LINE> if ( writer -> Seekable ( ) ) {
#endif <NEW_LINE> #ifdef HAVE_GNUTLS_GNUTLS_H <NEW_LINE> <START_VULN> const int tls_kx_order [ ] = { <NEW_LINE> <END_VULN> GNUTLS_KX_ANON_DH , <NEW_LINE> GNUTLS_KX_DHE_RSA , <NEW_LINE> GNUTLS_KX_DHE_DSS ,
#include < utility > <NEW_LINE> #include "base / logging . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "mojo / public / cpp / bindings / array . h" <NEW_LINE> #include "mojo / public / cpp / bindings / lib / map_data_internal . h" <NEW_LINE> #include "mojo / public / cpp / bindings / lib / template_util . h"
void PrintPage ( blink::WebLocalFrame * frame ) override ; <NEW_LINE> blink::WebSpeechRecognizer * SpeechRecognizer ( ) override ; <NEW_LINE> blink::WebString AcceptLanguages ( ) override ; <NEW_LINE> <START_VULN> void DidFocus ( ) override ; <NEW_LINE> <END_VULN> bool CanHandleGestureEvent ( ) override ; <NEW_LINE> bool CanUpdateLayout ( ) override ;
MockSpeechSynthesisLibrary * mock_speech_synthesis_library_ ; <NEW_LINE> MockTouchpadLibrary * mock_touchpad_library_ ; <NEW_LINE> <START_VULN> ImePropertyList ime_properties_ ; <NEW_LINE>InputMethodDescriptor current_input_method_ ; <NEW_LINE>InputMethodDescriptor previous_input_method_ ; <NEW_LINE> <END_VULN> WifiNetworkVector wifi_networks_ ; <NEW_LINE> CellularNetworkVector cellular_networks_ ; <NEW_LINE> VirtualNetworkVector virtual_networks_ ;
#if ! defined ( LIBXSLT_STATIC ) <NEW_LINE> #define XSLTPUBVAR __declspec ( dllimport ) extern <NEW_LINE> #else <NEW_LINE> <START_VULN> #define XSLTPUBVAR <NEW_LINE> <END_VULN> #endif <NEW_LINE> #endif <NEW_LINE> #define XSLTCALL __cdecl
#define IRQ_STACK_ORDER 2 <NEW_LINE> #define IRQ_STACK_SIZE ( PAGE_SIZE << IRQ_STACK_ORDER ) <NEW_LINE> <START_VULN> #define STACKFAULT_STACK 1 <NEW_LINE>#define DOUBLEFAULT_STACK 2 <NEW_LINE>#define NMI_STACK 3 <NEW_LINE>#define DEBUG_STACK 4 <NEW_LINE>#define MCE_STACK 5 <NEW_LINE>#define N_EXCEPTION_STACKS 5 <NEW_LINE> <END_VULN> #define PUD_PAGE_SIZE ( _AC ( 1 , UL ) << PUD_SHIFT ) <NEW_LINE> #define PUD_PAGE_MASK ( ~ ( PUD_PAGE_SIZE - 1 ) )
STATE_UNINITIALIZED , <NEW_LINE> STATE_INITIALIZED , <NEW_LINE> STATE_CHECKING , <NEW_LINE> STATE_DOWNLOADING , <NEW_LINE> STATE_CANCELLED , <NEW_LINE> STATE_FINISHED <NEW_LINE> } mState ; <NEW_LINE> <START_VULN> nsOfflineCacheUpdateOwner * mOwner ; <NEW_LINE> <END_VULN> bool mAddedItems ; <NEW_LINE> bool mPartialUpdate ; <NEW_LINE> bool mOnlyCheckUpdate ; <NEW_LINE> bool mSucceeded ; <NEW_LINE> bool mObsolete ; <NEW_LINE> nsCString mUpdateDomain ;
int badop = 0 , bugs = 0 ; <NEW_LINE> int ret = 1 ; <NEW_LINE> int off = 0 ; <NEW_LINE> <START_VULN> int no_tmp_rsa = 0 , nocert = 0 ; <NEW_LINE> <END_VULN> int state = 0 ; <NEW_LINE> SSL_METHOD * meth = NULL ; <NEW_LINE> #ifndef NO_DH
AutoContextPusher ( JSContext * cx <NEW_LINE> MOZ_GUARD_OBJECT_NOTIFIER_PARAM ) <NEW_LINE> : mRequest ( cx ) <NEW_LINE> , mContext ( cx ) <NEW_LINE> , mSavedOptions ( JS_SetOptions ( cx , ( JS_GetOptions ( cx ) | <NEW_LINE> JSOPTION_DONT_REPORT_UNCAUGHT ) ) ) <NEW_LINE> { <NEW_LINE> MOZ_GUARD_OBJECT_NOTIFIER_INIT ; <NEW_LINE> <START_VULN> mStack . Push ( cx , false ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> ~ AutoContextPusher ( ) { <NEW_LINE> mStack . Pop ( ) ; <NEW_LINE> JS_SetOptions ( mContext , mSavedOptions ) ; <NEW_LINE> } <NEW_LINE> } ;
} <NEW_LINE> static vpx_codec_err_t vp8e_set_reference ( vpx_codec_alg_priv_t * ctx , <NEW_LINE> <START_VULN> int ctr_id , <NEW_LINE>va_list args ) <NEW_LINE> <END_VULN> { <NEW_LINE> vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ;
static const uint64_t EPSILON_MS = 5 ; <NEW_LINE> static void msleep ( uint64_t ms ) { <NEW_LINE> <START_VULN> usleep ( ms * 1000 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> class AlarmTest : public AlarmTestHarness {
} <NEW_LINE> static int <NEW_LINE> <START_VULN> make_errors ( png_modifier * PNG_CONST pm , png_byte PNG_CONST colour_type , <NEW_LINE>int bdlo , int PNG_CONST bdhi ) <NEW_LINE> <END_VULN> { <NEW_LINE> for ( ; bdlo <= bdhi ; ++ bdlo ) <NEW_LINE> {
key_tries = 0 ; <NEW_LINE> do <NEW_LINE> { <NEW_LINE> <START_VULN> MBEDTLS_MPI_CHK ( mbedtls_ecp_gen_keypair ( grp , & k , & R , f_rng , p_rng ) ) ; <NEW_LINE> <END_VULN> MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( r , & R . X , & grp -> N ) ) ; <NEW_LINE> if ( key_tries ++ > 10 )
} <NEW_LINE> { <NEW_LINE> <START_VULN> const QStringList & tmp_paths = QStandardPaths::standardLocations ( QStandardPaths::TempLocation ) ; <NEW_LINE>const QString tmp_dir = ( tmp_paths . isEmpty ( ) ? " / tmp" : tmp_paths . first ( ) ) + " / . deepin - clone" ; <NEW_LINE> <END_VULN> if ( ! QDir::current ( ) . mkpath ( tmp_dir ) ) { <NEW_LINE> dCError ( "mkpath \" % s\" failed" , qPrintable ( tmp_dir ) ) ;
extern loopfilter_y_neon vp8_loop_filter_horizontal_edge_y_neon ; <NEW_LINE> extern loopfilter_y_neon vp8_loop_filter_vertical_edge_y_neon ; <NEW_LINE> <START_VULN> extern loopfilter_y_neon vp8_mbloop_filter_horizontal_edge_y_neon ; <NEW_LINE>extern loopfilter_y_neon vp8_mbloop_filter_vertical_edge_y_neon ; <NEW_LINE><NEW_LINE> <END_VULN> extern loopfilter_uv_neon vp8_loop_filter_horizontal_edge_uv_neon ; <NEW_LINE> extern loopfilter_uv_neon vp8_loop_filter_vertical_edge_uv_neon ; <NEW_LINE> extern loopfilter_uv_neon vp8_mbloop_filter_horizontal_edge_uv_neon ; <NEW_LINE> extern loopfilter_uv_neon vp8_mbloop_filter_vertical_edge_uv_neon ; <NEW_LINE> #endif
if ( res != TEE_SUCCESS ) <NEW_LINE> return res ; <NEW_LINE> <START_VULN> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <NEW_LINE> <END_VULN> if ( ! params ) <NEW_LINE> return TEE_ERROR_OUT_OF_MEMORY ; <NEW_LINE> res = copy_in_attrs ( utc , usr_params , param_count , params ) ;
return png_icc_profile_error ( png_ptr , colorspace , name , temp , <NEW_LINE> "unexpected DeviceLink ICC profile class" ) ; <NEW_LINE> <START_VULN> case 0x6E6D636C: <NEW_LINE> <END_VULN> ( void ) png_icc_profile_error ( png_ptr , NULL , name , temp ,
plugin_window = gdk_window_lookup ( xevent -> xcreatewindow . window ) ; <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> if ( xevent -> xreparent . event != xevent -> xreparent . parent ) <NEW_LINE> break ; <NEW_LINE> plugin_window = gdk_window_lookup ( xevent -> xreparent . window ) ; <NEW_LINE> } <NEW_LINE> if ( plugin_window ) { <NEW_LINE> <START_VULN> user_data = nsnull ; <NEW_LINE>gdk_window_get_user_data ( plugin_window , & user_data ) ; <NEW_LINE>widget = GTK_WIDGET ( user_data ) ; <NEW_LINE> <END_VULN> if ( GTK_IS_XTBIN ( widget ) ) { <NEW_LINE> nswindow -> SetPluginType ( nsWindow::PluginType_NONXEMBED ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> else if ( GTK_IS_SOCKET ( widget ) ) { <NEW_LINE> nswindow -> SetPluginType ( nsWindow::PluginType_XEMBED ) ; <NEW_LINE> break ;
size_t result_len = 0 ; <NEW_LINE> const char * data = _data , * end , * opt ; <NEW_LINE> <START_VULN> kenter ( " % % % d , % s , ' % s' , % zu" , <NEW_LINE>key -> serial , key -> description , data , datalen ) ; <NEW_LINE> <END_VULN> if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' ) <NEW_LINE> return - EINVAL ;
if ( event ) { <NEW_LINE> found = 1 ; <NEW_LINE> <START_VULN> record_and_restart ( event , val , regs , nmi ) ; <NEW_LINE> <END_VULN> } else {
Parser < SyntaxParseHandler > * parser = handler . syntaxParser ; <NEW_LINE> if ( ! parser ) <NEW_LINE> break ; <NEW_LINE> { <NEW_LINE> TokenStream::Position position ( keepAtoms ) ; <NEW_LINE> tokenStream . tell ( & position ) ; <NEW_LINE> <START_VULN> parser -> tokenStream . seek ( position , tokenStream ) ; <NEW_LINE> <END_VULN> ParseContext < SyntaxParseHandler > funpc ( parser , outerpc , SyntaxParseHandler::null ( ) , funbox , <NEW_LINE> newDirectives , outerpc -> staticLevel + 1 , <NEW_LINE> outerpc -> blockidGen , <NEW_LINE> 0 ) ; <NEW_LINE> if ( ! funpc . init ( tokenStream ) ) <NEW_LINE> return false ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> SkipDXTMipmaps ( image , dds_info , 16 ) ; <NEW_LINE><NEW_LINE>return MagickTrue ; <NEW_LINE> <END_VULN> } <NEW_LINE> static MagickBooleanType ReadDXT5 ( Image * image , DDSInfo * dds_info ,
} <NEW_LINE> sc_log_hex ( ctx , "ACL data" , file -> sec_attr , file -> sec_attr_len ) ; <NEW_LINE> <START_VULN> for ( ii = 0 ; ii < file -> sec_attr_len / 2 ; ii ++ ) { <NEW_LINE> <END_VULN> unsigned char op = file -> type == SC_FILE_TYPE_DF ? ops_DF [ ii ] : ops_EF [ ii ] ; <NEW_LINE> unsigned char acl = * ( file -> sec_attr + ii * 2 ) ; <NEW_LINE> unsigned char cred_id = * ( file -> sec_attr + ii * 2 + 1 ) ;
if ( file -> hasBeenClosed ( ) ) <NEW_LINE> return handleError ( DataCloneError , "A File object has been closed , and could therefore not be cloned . " , next ) ; <NEW_LINE> int blobIndex = - 1 ; <NEW_LINE> <START_VULN> m_blobDataHandles . add ( file -> uuid ( ) , file -> blobDataHandle ( ) ) ; <NEW_LINE> <END_VULN> if ( appendFileInfo ( file , & blobIndex ) ) { <NEW_LINE> ASSERT ( blobIndex >= 0 ) ; <NEW_LINE> m_writer . writeFileIndex ( blobIndex ) ;
rec_hdr . hdr . incl_len = phdr -> caplen + phdrsize ; <NEW_LINE> rec_hdr . hdr . orig_len = phdr -> len + phdrsize ; <NEW_LINE> <START_VULN> if ( rec_hdr . hdr . incl_len > WTAP_MAX_PACKET_SIZE || rec_hdr . hdr . orig_len > WTAP_MAX_PACKET_SIZE ) { <NEW_LINE> <END_VULN> * err = WTAP_ERR_BAD_FILE ; <NEW_LINE> return FALSE ; <NEW_LINE> }
gfxContext::FLAG_DISABLE_COPY_BACKGROUND ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> already_AddRefed < gfxImageSurface > gfxQuartzSurface::GetAsImageSurface ( ) <NEW_LINE> { <NEW_LINE> cairo_surface_t * surface = cairo_quartz_surface_get_image ( mSurface ) ; <NEW_LINE> <START_VULN> if ( ! surface ) <NEW_LINE> <END_VULN> return nsnull ; <NEW_LINE> nsRefPtr < gfxASurface > img = Wrap ( surface ) ;
phar_obj -> arc . archive -> alias = oldalias ; <NEW_LINE> phar_obj -> arc . archive -> alias_len = oldalias_len ; <NEW_LINE> phar_obj -> arc . archive -> is_temporary_alias = old_temp ; <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> if ( readd ) { <NEW_LINE> zend_hash_add ( & ( PHAR_GLOBALS -> phar_alias_map ) , oldalias , oldalias_len , ( void * ) & ( phar_obj -> arc . archive ) , sizeof ( phar_archive_data * ) , NULL ) ; <NEW_LINE> }
nsIPresShell * <NEW_LINE> nsBoxObject::GetPresShell ( bool aFlushLayout ) <NEW_LINE> { <NEW_LINE> if ( ! mContent ) { <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsIDocument * doc = mContent -> GetCurrentDoc ( ) ; <NEW_LINE> <END_VULN> if ( ! doc ) { <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> if ( aFlushLayout ) { <NEW_LINE> doc -> FlushPendingNotifications ( Flush_Layout ) ; <NEW_LINE> }
NS_DEFINE_CLASSINFO_DATA ( DOMImplementation , nsDOMGenericSH , <NEW_LINE> DOM_DEFAULT_SCRIPTABLE_FLAGS ) <NEW_LINE> NS_DEFINE_CLASSINFO_DATA ( DOMException , nsDOMGenericSH , <NEW_LINE> DOM_DEFAULT_SCRIPTABLE_FLAGS ) <NEW_LINE> NS_DEFINE_CLASSINFO_DATA ( DOMTokenList , nsDOMTokenListSH , <NEW_LINE> ARRAY_SCRIPTABLE_FLAGS ) <NEW_LINE> NS_DEFINE_CLASSINFO_DATA ( DOMSettableTokenList , nsDOMTokenListSH , <NEW_LINE> ARRAY_SCRIPTABLE_FLAGS ) <NEW_LINE> <START_VULN> NS_DEFINE_CLASSINFO_DATA ( DocumentFragment , nsDOMGenericSH , <NEW_LINE>DOM_DEFAULT_SCRIPTABLE_FLAGS ) <NEW_LINE> <END_VULN> NS_DEFINE_CLASSINFO_DATA ( Element , nsElementSH , <NEW_LINE> ELEMENT_SCRIPTABLE_FLAGS ) <NEW_LINE> NS_DEFINE_CLASSINFO_DATA ( Attr , nsAttributeSH , <NEW_LINE> NODE_SCRIPTABLE_FLAGS ) <NEW_LINE> NS_DEFINE_CLASSINFO_DATA ( Text , nsNodeSH , <NEW_LINE> NODE_SCRIPTABLE_FLAGS ) <NEW_LINE> NS_DEFINE_CLASSINFO_DATA ( Comment , nsNodeSH , <NEW_LINE> NODE_SCRIPTABLE_FLAGS )
} <NEW_LINE> int add_packetdata ( struct mt_packet * packet , unsigned char * data , unsigned short length ) { <NEW_LINE> <START_VULN> if ( packet -> size + length > MT_PACKET_LEN ) { <NEW_LINE> <END_VULN> fprintf ( stderr , _ ( "add_control_packet: ERROR , too large packet . Exceeds % d bytes\n" ) , MT_PACKET_LEN ) ; <NEW_LINE> return - 1 ; <NEW_LINE> }
jas_image_t * image ; <NEW_LINE> int ret ; <NEW_LINE> jpg_dec_importopts_t opts ; <NEW_LINE> <START_VULN> size_t size ; <NEW_LINE> <END_VULN> if ( jpg_dec_parseopts ( optstr , & opts ) ) { <NEW_LINE> goto error ;
#ifndef _V_LSP_H_ <NEW_LINE> #define _V_LSP_H_ <NEW_LINE> extern int vorbis_lpc_to_lsp ( float * lpc , float * lsp , int m ) ; <NEW_LINE> extern void vorbis_lsp_to_curve ( float * curve , int * map , int n , int ln , <NEW_LINE> float * lsp , int m , <NEW_LINE> float amp , float ampoffset ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #endif
<START_VULN> int npasses = png_set_interlace_handling ( pp ) ; <NEW_LINE> <END_VULN> int pass ; <NEW_LINE> if ( npasses != npasses_from_interlace_type ( pp , interlace_type ) )
} <NEW_LINE> static int <NEW_LINE> <START_VULN> test_standard ( png_modifier * PNG_CONST pm , png_byte PNG_CONST colour_type , <NEW_LINE>int bdlo , int PNG_CONST bdhi ) <NEW_LINE> <END_VULN> { <NEW_LINE> for ( ; bdlo <= bdhi ; ++ bdlo ) <NEW_LINE> {
break ; <NEW_LINE> case 1: <NEW_LINE> <START_VULN> if ( ( png_ptr -> row_number & 0x07 ) || png_ptr -> width < 5 ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_write_finish_row ( png_ptr ) ; <NEW_LINE> return ;
case EFFECT_CMD_DISABLE: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_DISABLE: ERROR" ) ; <NEW_LINE> return - EINVAL ; <NEW_LINE> }
perf_sample_data_init ( & sample , bp -> attr . bp_addr ) ; <NEW_LINE> if ( ! bp -> hw . state && ! perf_exclude_event ( bp , regs ) ) <NEW_LINE> <START_VULN> perf_swevent_event ( bp , 1 , 1 , & sample , regs ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif
static_assert ( ! NeedsAdjustAndMark < T > ::value , <NEW_LINE> "wrapper tracing is not supported within mixins" ) ; <NEW_LINE> #if DCHECK_IS_ON ( ) <NEW_LINE> <START_VULN> DCHECK ( HeapObjectHeader::fromPayload ( t ) -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> return reinterpret_cast < const T * > ( t ) ; <NEW_LINE> }
png_colorspace_sync_info ( png_ptr , info_ptr ) ; <NEW_LINE> <START_VULN> if ( ! result ) <NEW_LINE> <END_VULN> return ;
IPC::Message * reply_msg , <NEW_LINE> bool * did_suppress_message ) OVERRIDE ; <NEW_LINE> virtual void Close ( RenderViewHost * render_view_host ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void DidStopLoading ( ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual RendererPreferences GetRendererPrefs ( Profile * profile ) const OVERRIDE ; <NEW_LINE> virtual void CreateNewWindow ( <NEW_LINE> int route_id ,
break ; <NEW_LINE> } <NEW_LINE> <START_VULN> for ( i = 0 ; * data && i < length ; i ++ , data ++ ) <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , " % c" , ( * data < 32 || * data > 126 ) ? ' . ' : * data ) ) ; <NEW_LINE> return ;
getter_AddRefs ( storStream ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsCOMPtr < nsIOutputStream > output ; <NEW_LINE> rv = storStream -> GetOutputStream ( 0 , getter_AddRefs ( output ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> rv = serializer -> SerializeToStream ( doc , output , aCharset ) ; <NEW_LINE>NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <END_VULN> output -> Close ( ) ; <NEW_LINE> return storStream -> NewInputStream ( 0 , aResult ) ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsISupportsString > wstr = do_QueryInterface ( supports ) ;
if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "r" , & mcryptind ) == FAILURE ) { \ <NEW_LINE> return ; \ <NEW_LINE> } \ <NEW_LINE> <START_VULN> ZEND_FETCH_RESOURCE ( pm , php_mcrypt * , & mcryptind , - 1 , "MCrypt" , le_mcrypt ) ; <NEW_LINE> <END_VULN> #define MCRYPT_GET_MODE_DIR_ARGS ( DIRECTORY ) \ <NEW_LINE> char * dir = NULL ; \
<START_VULN> static inline int <NEW_LINE> <END_VULN> addrs_in_same_network_family ( const tor_addr_t * a1 , <NEW_LINE> const tor_addr_t * a2 ) <NEW_LINE> {
\ ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** / <NEW_LINE> #include < stdio . h > <NEW_LINE> <START_VULN> #include < jasper / jas_config . h > <NEW_LINE> <END_VULN> #include < jasper / jas_types . h > <NEW_LINE> #include < jasper / jas_debug . h >
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> b * ( tob ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
#include "chrome / browser / chromeos / cros / cros_library . h" <NEW_LINE> #include "chrome / browser / chromeos / cros / network_library . h" <NEW_LINE> #include "chrome / test / in_process_browser_test . h" <NEW_LINE> <START_VULN> #include "third_party / cros / chromeos_input_method . h" <NEW_LINE> <END_VULN> namespace chromeos {
setReplaced ( newStyle . isDisplayInlineType ( ) ) ; <NEW_LINE> <START_VULN> if ( oldStyle && parent ( ) && diff == StyleDifferenceLayout && oldStyle -> position ( ) != newStyle . position ( ) ) { <NEW_LINE> <END_VULN> if ( newStyle . position ( ) == StaticPosition )
return false ; <NEW_LINE> <START_VULN> if ( prevBlock -> isPositioned ( ) ) <NEW_LINE> <END_VULN> return false ;
<START_VULN> <NEW_LINE><NEW_LINE>WebKit::WebFrame * GetFrameByMappedID ( int frame_id ) ; <NEW_LINE> <END_VULN> void EnsureMediaStreamImpl ( ) ;
yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != ' ; ' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 585 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> * p = YYCURSOR ; <NEW_LINE> INIT_PZVAL ( * rval ) ;
nsCOMPtr < nsIScriptContext > mCtx ; <NEW_LINE> nsAutoMicroTask mMt ; <NEW_LINE> Maybe < JS::Rooted < JSObject * > > mRootedCallable ; <NEW_LINE> <START_VULN> nsCxPusher mCxPusher ; <NEW_LINE><NEW_LINE> <END_VULN> Maybe < JSAutoCompartment > mAc ;
static uint32 <NEW_LINE> XDRGetAtomIndex ( JSXDRState * xdr , JSAtom * atom ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( XDRAtomsHashMap::Ptr p = xdr -> state -> atomsMap . lookup ( atom ) ) <NEW_LINE> <END_VULN> return p -> value ; <NEW_LINE> return uint32 ( - 1 ) ; <NEW_LINE> }
return 0 ; <NEW_LINE> } <NEW_LINE> for ( option = maGetNextArg ( options , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { <NEW_LINE> <START_VULN> option = stok ( option , " = \t , " , & ovalue ) ; <NEW_LINE> <END_VULN> ovalue = strim ( ovalue , "\"'" , MPR_TRIM_BOTH ) ; <NEW_LINE> if ( ! ovalue || * ovalue == '\0' ) continue ; <NEW_LINE> if ( smatch ( option , "visible" ) ) {
if ( palette != 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> PNG_CONST unsigned int i = this -> palette_index ; <NEW_LINE> <END_VULN> this -> red = palette [ i ] . red ; <NEW_LINE> this -> green = palette [ i ] . green ;
#include < ngx_http . h > <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> static ngx_int_t ngx_http_not_modified_filter_init ( ngx_conf_t * cf ) ;
state = reserve_additional_memory ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( credit < 0 ) <NEW_LINE>state = decrease_reservation ( - credit , GFP_BALLOON ) ; <NEW_LINE> <END_VULN> state = update_schedule ( state ) ;
gint crc_length = 0 ; <NEW_LINE> <START_VULN> src_addr = ep_alloc ( ADDR_MAX_LEN ) ; <NEW_LINE>dst_addr = ep_alloc ( ADDR_MAX_LEN ) ; <NEW_LINE> <END_VULN> pinfo -> srcport = pinfo -> destport = 0xffffffff ;
mysql_init ( & mysql ) ; <NEW_LINE> if ( opt_compress ) <NEW_LINE> mysql_options ( & mysql , MYSQL_OPT_COMPRESS , NullS ) ; <NEW_LINE> <START_VULN> #ifdef HAVE_OPENSSL <NEW_LINE>if ( opt_use_ssl ) <NEW_LINE> { <NEW_LINE>mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , <NEW_LINE>opt_ssl_capath , opt_ssl_cipher ) ; <NEW_LINE>mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; <NEW_LINE>mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; <NEW_LINE> } <NEW_LINE>mysql_options ( & mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , <NEW_LINE> ( char * ) & opt_ssl_verify_server_cert ) ; <NEW_LINE>#endif <NEW_LINE> <END_VULN> if ( opt_protocol ) <NEW_LINE> mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; <NEW_LINE> if ( opt_bind_addr )
getprivs_ret * get_privs_2_svc ( krb5_ui_4 * arg , struct svc_req * rqstp ) <NEW_LINE> { <NEW_LINE> static getprivs_ret ret ; <NEW_LINE> <START_VULN> gss_buffer_desc client_name , service_name ; <NEW_LINE> <END_VULN> OM_uint32 minor_stat ; <NEW_LINE> kadm5_server_handle_t handle ; <NEW_LINE> const char * errmsg = NULL ;
nsGopherChannel::GetProxyInfo ( nsIProxyInfo ** aProxyInfo ) <NEW_LINE> { <NEW_LINE> * aProxyInfo = ProxyInfo ( ) ; <NEW_LINE> NS_IF_ADDREF ( * aProxyInfo ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> <START_VULN> nsGopherChannel::OpenContentStream ( PRBool async , nsIInputStream ** result ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ! async ) <NEW_LINE> return NS_ERROR_NOT_IMPLEMENTED ; <NEW_LINE> nsRefPtr < nsIInputStream > stream = new nsGopherContentStream ( this ) ; <NEW_LINE> if ( ! stream ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ;
} <NEW_LINE> if ( ! suffix ) { <NEW_LINE> <START_VULN> rc = fsmVerify ( fpath , fi ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> rc = ( action == FA_TOUCH ) ? 0 : RPMERR_ENOENT ; <NEW_LINE> }
weight = ParseCommandOption ( MagickWeightOptions , MagickFalse , option ) ; <NEW_LINE> if ( weight == - 1 ) <NEW_LINE> <START_VULN> weight = StringToUnsignedLong ( option ) ; <NEW_LINE> <END_VULN> draw_info -> weight = ( size_t ) weight ; <NEW_LINE> } <NEW_LINE> exception = DestroyExceptionInfo ( exception ) ;
# endif <NEW_LINE> } <NEW_LINE> <START_VULN> return ( png_byte ) value ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef PNG_16BIT_SUPPORTED
efree ( result ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> zend_hash_move_forward ( Z_ARRVAL_PP ( subject ) ) ; <NEW_LINE> } <NEW_LINE> } else {
nsIContent * aPreviousSibling ) <NEW_LINE> { <NEW_LINE> if ( mRoot && nsContentUtils::ContentIsDescendantOf ( mRoot , aChild ) ) { <NEW_LINE> nsRefPtr < nsXULTemplateBuilder > kungFuDeathGrip ( this ) ; <NEW_LINE> if ( mQueryProcessor ) <NEW_LINE> mQueryProcessor -> Done ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE>Uninit ( PR_FALSE ) ; <NEW_LINE> <END_VULN> aDocument -> RemoveObserver ( this ) ; <NEW_LINE> nsCOMPtr < nsIXULDocument > xuldoc = do_QueryInterface ( aDocument ) ; <NEW_LINE> if ( xuldoc ) <NEW_LINE> xuldoc -> SetTemplateBuilderFor ( mRoot , nsnull ) ;
if ( paginationStrut ) { <NEW_LINE> <START_VULN> if ( atBeforeSideOfBlock && logicalTop == newLogicalTop && ! isOutOfFlowPositioned ( ) && ! isTableCell ( ) ) { <NEW_LINE> <END_VULN>
void Wire ( UberDispatcher * dispatcher ) override ; <NEW_LINE> <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) override ;
XPCWrappedNativeTearOffChunk * chunk ; <NEW_LINE> for ( chunk = & mFirstChunk ; chunk ; chunk = chunk -> mNextChunk ) { <NEW_LINE> XPCWrappedNativeTearOff * to = chunk -> mTearOffs ; <NEW_LINE> for ( int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK - 1 ; i >= 0 ; i -- , to ++ ) { <NEW_LINE> <START_VULN> JSObject * jso = to -> GetJSObject ( ) ; <NEW_LINE> <END_VULN> if ( ! jso ) { <NEW_LINE> NS_CYCLE_COLLECTION_NOTE_EDGE_NAME ( cb , "tearoff's mNative" ) ; <NEW_LINE> cb . NoteXPCOMChild ( to -> GetNative ( ) ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
<START_VULN> long long mkvparser::UnserializeUInt ( IMkvReader * pReader , long long pos , <NEW_LINE>long long size ) { <NEW_LINE>assert ( pReader ) ; <NEW_LINE>assert ( pos >= 0 ) ; <NEW_LINE><NEW_LINE>if ( ( size <= 0 ) || ( size > 8 ) ) <NEW_LINE> <END_VULN> return E_FILE_FORMAT_INVALID ; <NEW_LINE> long long result = 0 ;
if ( handler == NULL ) <NEW_LINE> htmlSaveErr ( XML_SAVE_UNKNOWN_ENCODING , NULL , encoding ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>if ( handler == NULL ) <NEW_LINE>handler = xmlFindCharEncodingHandler ( "HTML" ) ; <NEW_LINE>if ( handler == NULL ) <NEW_LINE>handler = xmlFindCharEncodingHandler ( "ascii" ) ; <NEW_LINE> <END_VULN>
<START_VULN> static int CVE_2014_5471_isofs_read_inode ( struct inode * inode ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct super_block * sb = inode -> i_sb ; <NEW_LINE> struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ;
if ( m_layoutObject -> style ( ) -> visibility ( ) != EVisibility::kVisible ) { <NEW_LINE> <START_VULN> if ( equalIgnoringCase ( getAttribute ( aria_hiddenAttr ) , "false" ) ) <NEW_LINE> <END_VULN> return DefaultBehavior ; <NEW_LINE> if ( ignoredReasons )
} <NEW_LINE> nsresult MediaOmxReader::Init ( MediaDecoderReader * aCloneDonor ) <NEW_LINE> { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult MediaOmxReader::ReadMetadata ( VideoInfo * aInfo , <NEW_LINE> <START_VULN> MetadataTags ** aTags ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ASSERTION ( mDecoder -> OnDecodeThread ( ) , "Should be on decode thread . " ) ; <NEW_LINE> * aTags = nullptr ; <NEW_LINE> if ( ! mOmxDecoder . get ( ) ) { <NEW_LINE> mOmxDecoder = new OmxDecoder ( mDecoder -> GetResource ( ) , mDecoder ) ; <NEW_LINE> if ( ! mOmxDecoder -> Init ( ) ) {
if ( EOFBlob ( image ) ) break ; <NEW_LINE> MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; <NEW_LINE> if ( EOFBlob ( image ) ) break ; <NEW_LINE> <START_VULN> if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) <NEW_LINE> <END_VULN> goto MATLAB_KO ; <NEW_LINE> filepos += ( MagickOffsetType ) MATLAB_HDR . ObjectSize + 4 + 4 ;
set1 -> nodeTab = temp ; <NEW_LINE> set1 -> nodeMax *= 2 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( n2 -> type == XML_NAMESPACE_DECL ) { <NEW_LINE>xmlNsPtr ns = ( xmlNsPtr ) n2 ; <NEW_LINE><NEW_LINE>set1 -> nodeTab [ set1 -> nodeNr ++ ] = <NEW_LINE>xmlXPathNodeSetDupNs ( ( xmlNodePtr ) ns -> next , ns ) ; <NEW_LINE> } else <NEW_LINE>set1 -> nodeTab [ set1 -> nodeNr ++ ] = n2 ; <NEW_LINE> <END_VULN> skip_node: <NEW_LINE> { } <NEW_LINE> }
nsIScriptGlobalObject * global = doc -> GetScriptGlobalObject ( ) ; <NEW_LINE> if ( ! global ) <NEW_LINE> return NS_NOINTERFACE ; <NEW_LINE> nsIScriptContext * context = global -> GetContext ( ) ; <NEW_LINE> if ( ! context ) <NEW_LINE> return NS_NOINTERFACE ; <NEW_LINE> <START_VULN> JSContext * jscontext = context -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> if ( ! jscontext ) <NEW_LINE> return NS_NOINTERFACE ; <NEW_LINE> nsIXPConnect * xpConnect = nsContentUtils::XPConnect ( ) ; <NEW_LINE> JSObject * jsobj = aContent -> GetWrapper ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( jsobj , NS_NOINTERFACE ) ;
} <NEW_LINE> NS_IMPL_ISUPPORTS1 ( nsXMLHttpRequest::nsHeaderVisitor , nsIHttpHeaderVisitor ) <NEW_LINE> NS_IMETHODIMP nsXMLHttpRequest:: <NEW_LINE> nsHeaderVisitor::VisitHeader ( const nsACString & header , const nsACString & value ) <NEW_LINE> { <NEW_LINE> <START_VULN> bool chrome = false ; <NEW_LINE>IsCapabilityEnabled ( "UniversalXPConnect" , & chrome ) ; <NEW_LINE>if ( ! chrome && <NEW_LINE> <END_VULN> ( header . LowerCaseEqualsASCII ( "set - cookie" ) || <NEW_LINE> header . LowerCaseEqualsASCII ( "set - cookie2" ) ) ) { <NEW_LINE> NS_WARNING ( "blocked access to response header" ) ; <NEW_LINE> } else { <NEW_LINE> mHeaders . Append ( header ) ; <NEW_LINE> mHeaders . Append ( ": " ) ; <NEW_LINE> mHeaders . Append ( value ) ; <NEW_LINE> mHeaders . Append ( "\r\n" ) ;
char sig_recv = 0 ; <NEW_LINE> BTIF_TRACE_DEBUG ( "btif_hl_select_wake_reset" ) ; <NEW_LINE> <START_VULN> recv ( signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <NEW_LINE> <END_VULN> return ( int ) sig_recv ; <NEW_LINE> }
{ <NEW_LINE> NS_WARNING ( "Moving XPConnect wrappedNative to new scope , " <NEW_LINE> "but can't fixup __proto__" ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! JS_SetParent ( ccx , wrapper -> GetFlatJSObject ( ) , aNewParent ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_RELEASE ( wrapper ) ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> * aWrapper = wrapper ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
} <NEW_LINE> #endif <NEW_LINE> <START_VULN> vpx_memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ; <NEW_LINE> <END_VULN> pbi -> frame_corrupt_residual = 0 ; <NEW_LINE> #if CONFIG_MULTITHREAD
{ <NEW_LINE> unsigned int sse ; <NEW_LINE> <START_VULN> vp8_mse16x16 ( orig + col , orig_stride , <NEW_LINE> <END_VULN> recon + col , recon_stride , <NEW_LINE> & sse ) ; <NEW_LINE> total_sse += sse ;
curind = optind ; <NEW_LINE> <START_VULN> while ( longindex = - 1 , ( c = getopt_long ( argc , argv , ":vhlndDRS:f:p:i:mM::g::Gt::" <NEW_LINE> <END_VULN> #if defined _WITH_VRRP_ && defined _WITH_LVS_ <NEW_LINE> "PC" <NEW_LINE> #endif
<START_VULN> std::ostream & operator << ( std::ostream & out , const wchar_t * wstr ) ; <NEW_LINE> <END_VULN> inline std::ostream & operator << ( std::ostream & out , const std::wstring & wstr ) { <NEW_LINE> return out << wstr . c_str ( ) ; <NEW_LINE> }
public nsSupportsWeakReference , <NEW_LINE> public nsIDOMEventTarget , <NEW_LINE> public nsIDOM3EventTarget , <NEW_LINE> public nsIDOMNSEventTarget , <NEW_LINE> public nsIScriptObjectPrincipal , <NEW_LINE> public nsIRadioGroupContainer , <NEW_LINE> public nsIDOMNodeSelector , <NEW_LINE> public nsIApplicationCacheContainer , <NEW_LINE> <START_VULN> public nsStubMutationObserver <NEW_LINE> <END_VULN> { <NEW_LINE> public: <NEW_LINE> NS_DECL_CYCLE_COLLECTING_ISUPPORTS <NEW_LINE> virtual void Reset ( nsIChannel * aChannel , nsILoadGroup * aLoadGroup ) ; <NEW_LINE> virtual void ResetToURI ( nsIURI * aURI , nsILoadGroup * aLoadGroup , <NEW_LINE> nsIPrincipal * aPrincipal ) ;
jas_stream_t * in ; <NEW_LINE> <START_VULN> uchar inbuffer ; <NEW_LINE> <END_VULN> int eof ;
case EFFECT_CMD_SET_PARAM: { <NEW_LINE> if ( pCmdData == NULL || <NEW_LINE> <START_VULN> cmdSize < ( int ) sizeof ( effect_param_t ) || <NEW_LINE>pReplyData == NULL || <NEW_LINE> <END_VULN> * replySize != sizeof ( int32_t ) ) { <NEW_LINE> ALOGV ( "PreProcessingFx_Command cmdCode Case: " <NEW_LINE> "EFFECT_CMD_SET_PARAM: ERROR" ) ;
if ( offset >= ( size_t ) bufsize ) <NEW_LINE> break ; <NEW_LINE> offset = donote ( ms , nbuf , offset , ( size_t ) bufsize , <NEW_LINE> <START_VULN> clazz , swap , 4 , flags ) ; <NEW_LINE> <END_VULN> if ( offset == 0 ) <NEW_LINE> break ;
{ 0 , NULL } <NEW_LINE> } ; <NEW_LINE> <START_VULN> static int dccp_print_option ( netdissect_options * ndo , const u_char * option , u_int hlen ) <NEW_LINE> <END_VULN> { <NEW_LINE> uint8_t optlen , i ;
} <NEW_LINE> <START_VULN> if ( transforms & PNG_TRANSFORM_BGR ) <NEW_LINE> <END_VULN> #ifdef PNG_WRITE_BGR_SUPPORTED <NEW_LINE> png_set_bgr ( png_ptr ) ; <NEW_LINE> #else
xd -> dst . y_stride , <NEW_LINE> xd -> predictor , <NEW_LINE> 16 ) ; <NEW_LINE> <START_VULN> distortion = vp8_variance16x16 <NEW_LINE> <END_VULN> ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ; <NEW_LINE> rate = x -> mbmode_cost [ xd -> frame_type ] [ mode ] ; <NEW_LINE> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ;
if ( newmap ) <NEW_LINE> atable -> amap = newmap ; <NEW_LINE> if ( newrev ) <NEW_LINE> <START_VULN> atable -> amap = newrev ; <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> } <NEW_LINE> memset ( & newmap [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ) ;
#include "config . h" <NEW_LINE> #include "core / fileapi / Blob . h" <NEW_LINE> #include "core / fileapi / BlobURL . h" <NEW_LINE> #include "core / fileapi / File . h" <NEW_LINE> <START_VULN> #include "core / fileapi / ThreadableBlobRegistry . h" <NEW_LINE> <END_VULN> namespace WebCore {
if ( bufsize > QMFB_SPLITBUFSIZE ) { <NEW_LINE> <START_VULN> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <NEW_LINE> <END_VULN> abort ( ) ; <NEW_LINE> }
nsJSContext::TerminationFuncHolder holder ( this ) ; <NEW_LINE> ++ mExecuteDepth ; <NEW_LINE> if ( ok && JSVersion ( aVersion ) != JSVERSION_UNKNOWN ) { <NEW_LINE> <START_VULN> JSAutoRequest ar ( mContext ) ; <NEW_LINE> <END_VULN> JSAutoEnterCompartment ac ; <NEW_LINE> if ( ! ac . enter ( mContext , aScopeObject ) ) { <NEW_LINE> stack -> Pop ( nsnull ) ; <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> ok = JS_EvaluateUCScriptForPrincipalsVersionOrigin ( <NEW_LINE> mContext , aScopeObject ,
conn -> current_result = NULL ; <NEW_LINE> } while ( 0 ) ; <NEW_LINE> <START_VULN> conn -> m -> local_tx_end ( conn , this_func , result == NULL ? FAIL:PASS TSRMLS_CC ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> DBG_RETURN ( result ) ;
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeContentView::GetCellProperties ( PRInt32 aRow , nsITreeColumn * aCol , nsISupportsArray * aProperties ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ENSURE_ARG_POINTER ( aCol ) ; <NEW_LINE> <END_VULN> NS_ENSURE_ARG_POINTER ( aProperties ) ; <NEW_LINE> NS_PRECONDITION ( aRow >= 0 && aRow < PRInt32 ( mRows . Length ( ) ) , "bad row" ) ; <NEW_LINE> if ( aRow < 0 || aRow >= PRInt32 ( mRows . Length ( ) ) ) <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> Row * row = mRows [ aRow ] ; <NEW_LINE> nsIContent * realRow = <NEW_LINE> nsTreeUtils::GetImmediateChild ( row -> mContent , nsGkAtoms::treerow ) ;
if ( iKeyLen ) { <NEW_LINE> <START_VULN> int iSC = buf [ iOffset + iACLen ] ; <NEW_LINE> <END_VULN> switch ( ( iSC >> 5 ) & 0x03 ) { <NEW_LINE> case 0:
if ( intern -> file_name ) { <NEW_LINE> pnstr = spl_gen_private_prop_name ( spl_ce_SplFileInfo , "fileName" , sizeof ( "fileName" ) - 1 , & pnlen TSRMLS_CC ) ; <NEW_LINE> spl_filesystem_object_get_path ( intern , & path_len TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( path_len && path_len < intern -> file_name_len ) { <NEW_LINE> add_assoc_stringl_ex ( & zrv , pnstr , pnlen + 1 , intern -> file_name + path_len + 1 , intern -> file_name_len - ( path_len + 1 ) , 1 ) ; <NEW_LINE> } else {
if ( ! node || ! node -> isElementNode ( ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> return equalIgnoringCase ( toElement ( node ) -> getAttribute ( roleAttr ) , role ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> AXObject * AXObjectCacheImpl::createFromRenderer ( LayoutObject * layoutObject ) {
) <NEW_LINE> { <NEW_LINE> <START_VULN> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , FData2 , 24 * 24 ) ; <NEW_LINE> <END_VULN> if ( xoffset ) <NEW_LINE> {
case ' & ': <NEW_LINE> ds += 4 ; <NEW_LINE> <START_VULN> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <NEW_LINE> <END_VULN> if ( NULL == tmp ) <NEW_LINE> {
loopIndexVar ; <NEW_LINE> if ( indexValue ) { <NEW_LINE> assert ( ! jsvIsName ( indexValue ) && jsvGetRefs ( indexValue ) == 0 ) ; <NEW_LINE> <START_VULN> jsvSetValueOfName ( forStatement , indexValue ) ; <NEW_LINE> <END_VULN> if ( indexValue != loopIndexVar ) jsvUnLock ( indexValue ) ; <NEW_LINE> jsvIteratorNext ( & it ) ;
} <NEW_LINE> bool dstBufferSizeHasOverflow ( ParsedOptions options ) { <NEW_LINE> <START_VULN> CheckedNumeric < size_t > totalBytes = options . cropRect . width ( ) ; <NEW_LINE> <END_VULN> totalBytes *= options . cropRect . height ( ) ; <NEW_LINE> totalBytes *= options . bytesPerPixel ; <NEW_LINE> if ( ! totalBytes . IsValid ( ) )
private int <NEW_LINE> doshn ( struct magic_set * ms , int clazz , int swap , int fd , off_t off , int num , <NEW_LINE> <START_VULN> size_t size , off_t fsize , int * flags , int mach , int strtab ) <NEW_LINE> <END_VULN> { <NEW_LINE> Elf32_Shdr sh32 ; <NEW_LINE> Elf64_Shdr sh64 ;
#endif <NEW_LINE> if ( val == XSLT_RVT_LOCAL ) { <NEW_LINE> <START_VULN> if ( doc -> psvi != XSLT_RVT_FUNC_RESULT ) { <NEW_LINE>xmlGenericError ( xmlGenericErrorContext , <NEW_LINE>"xsltFlagRVTs: Invalid transition % p = > LOCAL\n" , <NEW_LINE>doc -> psvi ) ; <NEW_LINE>return ( - 1 ) ; <NEW_LINE> } <NEW_LINE><NEW_LINE>xsltRegisterLocalRVT ( ctxt , doc ) ; <NEW_LINE> <END_VULN> } else if ( val == XSLT_RVT_GLOBAL ) { <NEW_LINE> if ( doc -> psvi != XSLT_RVT_LOCAL ) { <NEW_LINE> xmlGenericError ( xmlGenericErrorContext ,
set_intr_gate ( X86_TRAP_OLD_MF , coprocessor_segment_overrun ) ; <NEW_LINE> set_intr_gate ( X86_TRAP_TS , invalid_TSS ) ; <NEW_LINE> set_intr_gate ( X86_TRAP_NP , segment_not_present ) ; <NEW_LINE> <START_VULN> set_intr_gate_ist ( X86_TRAP_SS , & stack_segment , STACKFAULT_STACK ) ; <NEW_LINE> <END_VULN> set_intr_gate ( X86_TRAP_GP , general_protection ) ; <NEW_LINE> set_intr_gate ( X86_TRAP_SPURIOUS , spurious_interrupt_bug ) ; <NEW_LINE> set_intr_gate ( X86_TRAP_MF , coprocessor_error ) ;
return - 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( header -> bDescriptorType == type ) { <NEW_LINE> <END_VULN> * ptr = header ; <NEW_LINE> return 0 ; <NEW_LINE> }
ps_dec -> u4_deblk_mb_x = 0 ; <NEW_LINE> ps_dec -> u4_deblk_mb_y = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; <NEW_LINE> return OK ;
: HTMLElement ( tag_name , document ) , <NEW_LINE> content_frame_ ( nullptr ) , <NEW_LINE> embedded_content_view_ ( nullptr ) , <NEW_LINE> <START_VULN> sandbox_flags_ ( kSandboxNone ) { } <NEW_LINE> <END_VULN> LayoutEmbeddedContent * HTMLFrameOwnerElement::GetLayoutEmbeddedContent ( ) const {
state = Colon ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> state = SkipLine ;
extern int vp8_calc_ss_err ( YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * dest ) ; <NEW_LINE> <START_VULN> void vp8_yv12_copy_partial_frame_c ( YV12_BUFFER_CONFIG * src_ybc , <NEW_LINE>YV12_BUFFER_CONFIG * dst_ybc ) <NEW_LINE> <END_VULN> { <NEW_LINE> unsigned char * src_y , * dst_y ; <NEW_LINE> int yheight ;
op . textureInfo ( ) , <NEW_LINE> op . bufferRect ( ) ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> case CompositableOperation::TOpDestroyThebesBuffer: { <NEW_LINE> MOZ_LAYERS_LOG ( ( " [ ParentSide ] Created double buffer" ) ) ; <NEW_LINE> const OpDestroyThebesBuffer & op = aEdit . get_OpDestroyThebesBuffer ( ) ; <NEW_LINE> CompositableParent * compositableParent = static_cast < CompositableParent * > ( op . compositableParent ( ) ) ; <NEW_LINE> <START_VULN> DeprecatedContentHostBase * content = static_cast < DeprecatedContentHostBase * > ( compositableParent -> GetCompositableHost ( ) ) ; <NEW_LINE> <END_VULN> content -> DestroyTextures ( ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> case CompositableOperation::TOpPaintTexture: { <NEW_LINE> MOZ_LAYERS_LOG ( ( " [ ParentSide ] Paint Texture X" ) ) ; <NEW_LINE> const OpPaintTexture & op = aEdit . get_OpPaintTexture ( ) ;
ASSERT ( scriptLoader -> isParserInserted ( ) ) ; <NEW_LINE> if ( ! isExecutingScript ( ) ) <NEW_LINE> <START_VULN> Microtask::performCheckpoint ( ) ; <NEW_LINE> <END_VULN> InsertionPointRecord insertionPointRecord ( m_host -> inputStream ( ) ) ; <NEW_LINE> NestingLevelIncrementer nestingLevelIncrementer ( m_scriptNestingLevel ) ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsXBLProtoImpl::InitTargetObjects ( nsXBLPrototypeBinding * aBinding , <NEW_LINE> nsIScriptContext * aContext , <NEW_LINE> nsIContent * aBoundElement , <NEW_LINE> nsIXPConnectJSObjectHolder ** aScriptObjectHolder , <NEW_LINE> <START_VULN> JSObject ** aTargetClassObject ) <NEW_LINE> <END_VULN> { <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> * aScriptObjectHolder = nullptr ; <NEW_LINE> if ( ! mClassObject ) { <NEW_LINE> rv = CompilePrototypeMembers ( aBinding ) ;
with static tables , but Vorbis allows a number of possible <NEW_LINE> combinations , so it's best to do it computationally . <NEW_LINE> The below is authoritative in terms of defining scale mapping . <NEW_LINE> Note that the scale depends on the sampling rate as well as the <NEW_LINE> linear block and mapping sizes * / <NEW_LINE> static void floor0_map_lazy_init ( vorbis_block * vb , <NEW_LINE> <START_VULN> vorbis_info_floor * infoX , <NEW_LINE>vorbis_look_floor0 * look ) { <NEW_LINE> <END_VULN> if ( ! look -> linearmap [ vb -> W ] ) { <NEW_LINE> vorbis_dsp_state * vd = vb -> vd ; <NEW_LINE> vorbis_info * vi = vd -> vi ; <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> vorbis_info_floor0 * info = ( vorbis_info_floor0 * ) infoX ; <NEW_LINE> int W = vb -> W ; <NEW_LINE> int n = ci -> blocksizes [ W ] / 2 , j ;
NS_ConvertASCIItoUTF16 ( nsCSSKeywords::GetStringValue ( functionId ) ) , <NEW_LINE> aResult ) ; <NEW_LINE> } else { <NEW_LINE> AppendCSSValueToString ( aProperty , functionName , aResult ) ; <NEW_LINE> } <NEW_LINE> aResult . AppendLiteral ( " ( " ) ; <NEW_LINE> <START_VULN> for ( PRUint16 index = 1 ; index < array -> Count ( ) ; ++ index ) { <NEW_LINE> <END_VULN> AppendCSSValueToString ( aProperty , array -> Item ( index ) , aResult ) ; <NEW_LINE> if ( index + 1 != array -> Count ( ) ) <NEW_LINE> aResult . AppendLiteral ( " , " ) ; <NEW_LINE> }
if ( ! result ) <NEW_LINE> break ; <NEW_LINE> <START_VULN> if ( ! result -> isPositioned ( ) && ( result -> isText ( ) || result -> isFloating ( ) || result -> isReplaced ( ) || result -> isRenderInline ( ) ) ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> current = result ;
DeclareSetting ( QString , WorkingDir ) ; <NEW_LINE> inline void cForceWorkingDir ( const QString & newDir ) { <NEW_LINE> cSetWorkingDir ( newDir ) ; <NEW_LINE> <START_VULN> if ( ! gWorkingDir . isEmpty ( ) ) QDir ( ) . mkpath ( gWorkingDir ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> DeclareReadSetting ( QString , ExeName ) ; <NEW_LINE> DeclareReadSetting ( QString , ExeDir ) ;
bucket_t * bucket ; <NEW_LINE> size_t index ; <NEW_LINE> <START_VULN> index = hash % num_buckets ( hashtable ) ; <NEW_LINE> <END_VULN> bucket = & hashtable -> buckets [ index ] ; <NEW_LINE> pair = hashtable_find_pair ( hashtable , bucket , key , hash ) ;
MOZ_GUARD_OBJECT_NOTIFIER_INIT ; <NEW_LINE> if ( ! aSafe ) { <NEW_LINE> mCx = nsContentUtils::GetCurrentJSContext ( ) ; <NEW_LINE> } <NEW_LINE> if ( ! mCx ) { <NEW_LINE> mCx = nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE> <START_VULN> bool result = mPusher . Push ( mCx , nsCxPusher::ALWAYS_PUSH ) ; <NEW_LINE> <END_VULN> if ( ! result || ! mCx ) { <NEW_LINE> MOZ_CRASH ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> AutoJSContext::operator JSContext * ( ) <NEW_LINE> {
void GetAppController ( mojom::AppControllerRequest request ) override ; <NEW_LINE> private: <NEW_LINE> mojo::BindingSet < mojom::KioskNextHomeInterfaceBroker > bindings_ ; <NEW_LINE> std::unique_ptr < service_manager::Connector > connector_ ; <NEW_LINE> <START_VULN> std::unique_ptr < AppControllerImpl > app_controller_ ; <NEW_LINE> <END_VULN> DISALLOW_COPY_AND_ASSIGN ( KioskNextHomeInterfaceBrokerImpl ) ; <NEW_LINE> } ;
png_fixed_point * int_blue_Z ) <NEW_LINE> { <NEW_LINE> if ( png_ptr != NULL && info_ptr != NULL && <NEW_LINE> <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_debug1 ( 1 , "in % s retrieval function" , "cHRM_XYZ" ) ;
int x , y ; <NEW_LINE> float x_ratio , y_ratio ; <NEW_LINE> long ignore_warning ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "pplll" , & f_org , & f_org_len , & f_dest , & f_dest_len , & height , & width , & threshold ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
<START_VULN> class HistoryModelWorker : public browser_sync::ModelSafeWorker , <NEW_LINE>public CancelableRequestConsumerBase { <NEW_LINE> <END_VULN> public: <NEW_LINE> explicit HistoryModelWorker ( HistoryService * history_service ) ; <NEW_LINE> virtual ~ HistoryModelWorker ( ) ;
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestCustomNamedGetter::s_info ) ; <NEW_LINE> TestCustomNamedGetter * impl = static_cast < TestCustomNamedGetter * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> const String & str ( ustringToString ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . isEmpty ( ) ? UString ( ) : MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . toString ( exec ) -> value ( exec ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
int32_t i32 ; <NEW_LINE> uint32_t u32 ; <NEW_LINE> JSWhyMagic why ; <NEW_LINE> } payload ; <NEW_LINE> } s ; <NEW_LINE> double asDouble ; <NEW_LINE> void * asPtr ; <NEW_LINE> size_t asWord ; <NEW_LINE> <START_VULN> } jsval_layout ; <NEW_LINE> <END_VULN> # endif <NEW_LINE> #else <NEW_LINE> # if JS_BITS_PER_WORD == 32 <NEW_LINE> typedef union jsval_layout <NEW_LINE> { <NEW_LINE> uint64_t asBits ; <NEW_LINE> struct { <NEW_LINE> JSValueTag tag ;
<START_VULN> if ( compose ) <NEW_LINE> <END_VULN> { <NEW_LINE> memset ( & png_ptr -> background , 0 , ( sizeof png_ptr -> background ) ) ;
} <NEW_LINE> void <NEW_LINE> WebGLContext::SampleCoverage ( GLclampf value , WebGLboolean invert ) { <NEW_LINE> if ( IsContextLost ( ) ) <NEW_LINE> return ; <NEW_LINE> MakeContextCurrent ( ) ; <NEW_LINE> gl -> fSampleCoverage ( value , invert ) ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> \ No newline at end of file <NEW_LINE>
static void locationReplaceableAttributeSetter ( v8::Local < v8::Value > jsValue , const v8::PropertyCallbackInfo < void > & info ) <NEW_LINE> { <NEW_LINE> TestObjectPython * proxyImp = V8TestObjectPython::toNative ( info . Holder ( ) ) ; <NEW_LINE> <START_VULN> TestNode * imp = WTF::getPtr ( proxyImp -> locationReplaceable ( ) ) ; <NEW_LINE> <END_VULN> if ( ! imp ) <NEW_LINE> return ; <NEW_LINE> V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID ( V8StringResource < > , cppValue , jsValue ) ;
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeContentView::CycleHeader ( nsITreeColumn * aCol ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ENSURE_ARG_POINTER ( aCol ) ; <NEW_LINE> <END_VULN> if ( ! mRoot ) <NEW_LINE> return NS_OK ; <NEW_LINE> nsCOMPtr < nsIDOMElement > element ; <NEW_LINE> aCol -> GetElement ( getter_AddRefs ( element ) ) ; <NEW_LINE> if ( element ) { <NEW_LINE> nsCOMPtr < nsIContent > column = do_QueryInterface ( element ) ;
} <NEW_LINE> #ifdef CONFIG_HAVE_HW_BREAKPOINT <NEW_LINE> <START_VULN> void ptrace_triggered ( struct perf_event * bp , int nmi , <NEW_LINE> <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) <NEW_LINE> { <NEW_LINE> struct perf_event_attr attr ;
int vp9_get_pred_context_comp_ref_p ( const VP9_COMMON * cm , <NEW_LINE> const MACROBLOCKD * xd ) { <NEW_LINE> int pred_context ; <NEW_LINE> <START_VULN> const MB_MODE_INFO * const above_mbmi = get_mbmi ( get_above_mi ( xd ) ) ; <NEW_LINE>const MB_MODE_INFO * const left_mbmi = get_mbmi ( get_left_mi ( xd ) ) ; <NEW_LINE>const int above_in_image = above_mbmi != NULL ; <NEW_LINE>const int left_in_image = left_mbmi != NULL ; <NEW_LINE> <END_VULN>
EXPECT_TRUE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE> EXPECT_TRUE ( sourceList . matches ( KURL ( base , "http: <NEW_LINE> EXPECT_TRUE ( sourceList . matches ( KURL ( base , "http: <NEW_LINE> EXPECT_FALSE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE> EXPECT_FALSE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE> EXPECT_FALSE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE> EXPECT_FALSE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE> <START_VULN> EXPECT_FALSE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE> <END_VULN> EXPECT_FALSE ( sourceList . matches ( KURL ( base , "http: <NEW_LINE> EXPECT_FALSE ( sourceList . matches ( KURL ( base , "https: <NEW_LINE> EXPECT_FALSE ( sourceList . matches ( KURL ( base , "http:
void AssignFrom ( const ProxyBypassRules & other ) ; <NEW_LINE> <START_VULN> private: <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>void ParseFromStringInternal ( const std::string & raw , <NEW_LINE>bool use_hostname_suffix_matching ) ; <NEW_LINE>bool AddRuleFromStringInternal ( const std::string & raw , <NEW_LINE>bool use_hostname_suffix_matching ) ; <NEW_LINE>bool AddRuleFromStringInternalWithLogging ( const std::string & raw , <NEW_LINE>bool use_hostname_suffix_matching ) ; <NEW_LINE> <END_VULN> RuleList rules_ ; <NEW_LINE> } ;
if ( root ) { <NEW_LINE> MOZ_TIMER_DEBUGLOG ( ( "Reset and start: Frame Creation: PresShell::InitialReflow ( ) , this = % p\n" , <NEW_LINE> ( void * ) this ) ) ; <NEW_LINE> MOZ_TIMER_RESET ( mFrameCreationWatch ) ; <NEW_LINE> MOZ_TIMER_START ( mFrameCreationWatch ) ; <NEW_LINE> { <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE> <END_VULN> mFrameConstructor -> BeginUpdate ( ) ; <NEW_LINE> if ( ! rootFrame ) { <NEW_LINE> mFrameConstructor -> ConstructRootFrame ( root , & rootFrame ) ; <NEW_LINE> FrameManager ( ) -> SetRootFrame ( rootFrame ) ; <NEW_LINE> }
bool isSelectionBorder ( ) const ; <NEW_LINE> <START_VULN> bool hasClip ( ) const { return isPositioned ( ) && style ( ) -> hasClip ( ) ; } <NEW_LINE> <END_VULN> bool hasOverflowClip ( ) const { return m_bitfields . hasOverflowClip ( ) ; } <NEW_LINE> bool hasTransform ( ) const { return m_bitfields . hasTransform ( ) ; }
return false ; <NEW_LINE> <START_VULN> uint64 void_entry_size = size - 1 - GetCodedUIntSize ( size - 1 ) ; <NEW_LINE>uint64 void_size = EbmlMasterElementSize ( kMkvVoid , void_entry_size ) + <NEW_LINE>void_entry_size ; <NEW_LINE> <END_VULN> if ( void_size != size ) <NEW_LINE> return 0 ;
<START_VULN> #ifndef BASE_DEFERRED_SEQUENCED_TASKRUNNER_H_ <NEW_LINE>#define BASE_DEFERRED_SEQUENCED_TASKRUNNER_H_ <NEW_LINE> <END_VULN> #include < vector >
continue ; <NEW_LINE> } <NEW_LINE> JSObject * object = nullptr ; <NEW_LINE> wrappedJS -> GetJSObject ( & object ) ; <NEW_LINE> if ( ! object ) { <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> NS_ENSURE_STATE ( pusher . Push ( ctx , nsCxPusher::ALWAYS_PUSH ) ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( ctx ) ; <NEW_LINE> JSAutoCompartment ac ( ctx , object ) ; <NEW_LINE> JSObject * param = JS_NewObject ( ctx , NULL , NULL , NULL ) ; <NEW_LINE> NS_ENSURE_TRUE ( param , NS_ERROR_OUT_OF_MEMORY ) ;
{ <NEW_LINE> RefPtr < ScriptPromiseResolver > resolver = ScriptPromiseResolver::create ( context ) ; <NEW_LINE> ScriptPromise promise = resolver -> promise ( ) ; <NEW_LINE> <START_VULN> resolver -> resolve ( imageBitmap ) ; <NEW_LINE> <END_VULN> return promise ; <NEW_LINE> }
if ( ! alwaysCreateLineBoxes ( ) ) { <NEW_LINE> for ( RenderObject * curr = firstChild ( ) ; curr ; curr = curr -> nextSibling ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( curr -> isBox ( ) && ! curr -> needsLayout ( ) ) { <NEW_LINE> RenderBox * currBox = toRenderBox ( curr ) ;
temp = png_get_uint_32 ( profile + 12 ) ; <NEW_LINE> switch ( temp ) <NEW_LINE> { <NEW_LINE> <START_VULN> case 0x73636E72: <NEW_LINE>case 0x6D6E7472: <NEW_LINE> <END_VULN> case 0x70727472: <NEW_LINE> case 0x73706163:
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return xpc_EvalInSandbox ( cx , obj , source , <NEW_LINE> <START_VULN> NS_ConvertUTF16toUTF8 ( source ) . get ( ) , 1 , rval ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> }
++ str ; <NEW_LINE> valueStart = str ; <NEW_LINE> <START_VULN> for ( valueEnd = str ; * valueEnd ; ++ valueEnd ) <NEW_LINE> { <NEW_LINE>if ( * valueEnd == '\\' ) <NEW_LINE> <END_VULN> ++ valueEnd ; <NEW_LINE> else if ( * valueEnd == '"' ) <NEW_LINE> break ;
mContentViewer -> SetSticky ( sticky ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> SetHistoryEntry ( & mOSHE , mLSHE ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> SetLayoutHistoryState ( nullptr ) ;
} else if ( style . IsCanvasPattern ( ) ) { <NEW_LINE> CanvasPattern * canvas_pattern = style . GetAsCanvasPattern ( ) ; <NEW_LINE> <START_VULN> if ( OriginClean ( ) && ! canvas_pattern -> OriginClean ( ) ) { <NEW_LINE>SetOriginTainted ( ) ; <NEW_LINE>ClearResolvedFilters ( ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> canvas_style = CanvasStyle::CreateFromPattern ( canvas_pattern ) ; <NEW_LINE> }
if ( mQueryProcessor ) <NEW_LINE> mQueryProcessor -> Done ( ) ; <NEW_LINE> mDataSource = nsnull ; <NEW_LINE> mDB = nsnull ; <NEW_LINE> mCompDB = nsnull ; <NEW_LINE> mRoot = nsnull ; <NEW_LINE> <START_VULN> Uninit ( PR_TRUE ) ; <NEW_LINE> <END_VULN> }
if ( Speed >= 15 ) <NEW_LINE> sf -> half_pixel_search = 0 ; <NEW_LINE> <START_VULN> vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ; <NEW_LINE> <END_VULN> } ;
mbd -> subpixel_predict16x16 = xd -> subpixel_predict16x16 ; <NEW_LINE> mb -> gf_active_ptr = x -> gf_active_ptr ; <NEW_LINE> <START_VULN> vpx_memset ( mbr_ei [ i ] . segment_counts , 0 , sizeof ( mbr_ei [ i ] . segment_counts ) ) ; <NEW_LINE> <END_VULN> mbr_ei [ i ] . totalrate = 0 ; <NEW_LINE> mb -> partition_info = x -> pi + x -> e_mbd . mode_info_stride * ( i + 1 ) ;
bool IsPaused ( ) ; <NEW_LINE> int GetRate ( ) { return mOutRate ; } <NEW_LINE> int GetChannels ( ) { return mChannels ; } <NEW_LINE> int GetOutChannels ( ) { return mOutChannels ; } <NEW_LINE> <START_VULN> <NEW_LINE>nsresult EnsureTimeStretcherInitialized ( ) ; <NEW_LINE> <END_VULN> nsresult SetPlaybackRate ( double aPlaybackRate ) ; <NEW_LINE> nsresult SetPreservesPitch ( bool aPreservesPitch ) ; <NEW_LINE> private: <NEW_LINE> static void PrefChanged ( const char * aPref , void * aClosure ) ; <NEW_LINE> static double GetVolumeScale ( ) ; <NEW_LINE> static cubeb * GetCubebContext ( ) ; <NEW_LINE> static cubeb * GetCubebContextUnlocked ( ) ; <NEW_LINE> static uint32_t GetCubebLatency ( ) ; <NEW_LINE> static bool CubebLatencyPrefSet ( ) ;
inet -> inet_saddr , inet -> inet_dport , <NEW_LINE> inet -> inet_sport , sk -> sk_protocol , <NEW_LINE> RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; <NEW_LINE> <START_VULN> if ( ! IS_ERR ( rt ) ) <NEW_LINE>__sk_dst_set ( sk , & rt -> dst ) ; <NEW_LINE> <END_VULN> rcu_read_unlock ( ) ; <NEW_LINE> } <NEW_LINE> EXPORT_SYMBOL_GPL ( ip4_datagram_release_cb ) ;
{ <NEW_LINE> png_debug ( 1 , "in png_do_bgr" ) ; <NEW_LINE> <START_VULN> if ( ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_uint_32 row_width = row_info -> width ; <NEW_LINE> if ( row_info -> bit_depth == 8 )
char * path_name ( struct strbuf * path , const char * name ) ; <NEW_LINE> <START_VULN> extern void show_object_with_name ( FILE * , struct object * , <NEW_LINE>struct strbuf * , const char * ) ; <NEW_LINE> <END_VULN> extern void add_pending_object ( struct rev_info * revs , <NEW_LINE> struct object * obj , const char * name ) ; <NEW_LINE> commit de1e67d0703894cb6ea782e36abb63976ab07e60 <NEW_LINE> Author: Jeff King < peff@peff . net > <NEW_LINE> Date: Thu Feb 11 17:28:36 2016 - 0500 <NEW_LINE> list - objects: pass full pathname to callbacks <NEW_LINE> When we find a blob at "a / b / c" , we currently pass this to <NEW_LINE> our show_object_fn callbacks as two components: "a / b / " and <NEW_LINE> "c" . Callbacks which want the full value then call <NEW_LINE> path_name ( ) , which concatenates the two . But this is an <NEW_LINE> inefficient interface ; the path is a strbuf , and we could <NEW_LINE> simply append "c" to it temporarily , then roll back the <NEW_LINE> length , without creating a new copy . <NEW_LINE> So we could improve this by teaching the callsites of <NEW_LINE> path_name ( ) this trick ( and there
#define MBREX ( g ) ( MBSTRG ( mb_regex_globals ) -> g ) <NEW_LINE> <START_VULN> static void php_mb_regex_free_cache ( php_mb_regex_t ** pre ) <NEW_LINE> <END_VULN> { <NEW_LINE> onig_free ( * pre ) ; <NEW_LINE> }
nscoord above , below ; <NEW_LINE> combobox -> GetAvailableDropdownSpace ( & above , & below , & translation ) ; <NEW_LINE> if ( above <= 0 && below <= 0 ) { <NEW_LINE> state . SetComputedHeight ( heightOfARow ) ; <NEW_LINE> mNumDisplayRows = 1 ; <NEW_LINE> } else { <NEW_LINE> nscoord bp = aReflowState . mComputedBorderPadding . TopBottom ( ) ; <NEW_LINE> nscoord availableHeight = NS_MAX ( above , below ) - bp ; <NEW_LINE> <START_VULN> nscoord height = NS_MIN ( visibleHeight , availableHeight ) ; <NEW_LINE>PRInt32 rows = height / heightOfARow ; <NEW_LINE>mNumDisplayRows = clamped ( rows , 1 , kMaxDropDownRows ) ; <NEW_LINE>nscoord newHeight = mNumDisplayRows * heightOfARow ; <NEW_LINE> <END_VULN> state . SetComputedHeight ( newHeight ) ; <NEW_LINE> mDropdownCanGrow = visibleHeight - newHeight >= heightOfARow && <NEW_LINE> mNumDisplayRows != kMaxDropDownRows ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> mLastDropdownComputedHeight = state . ComputedHeight ( ) ;
return - 1 ; <NEW_LINE> } <NEW_LINE> * delim = '\0' ; <NEW_LINE> <START_VULN> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <NEW_LINE> <END_VULN> mutt_buffer_addstr ( buf , term ) ; <NEW_LINE> mutt_buffer_addch ( buf , ' ' ) ;
static Variant HHVM_FUNCTION ( bcpowmod , const String & left , const String & right , <NEW_LINE> const String & modulus , int64_t scale ) { <NEW_LINE> <START_VULN> if ( scale < 0 ) scale = BCG ( bc_precision ) ; <NEW_LINE> <END_VULN> bc_num first , second , mod , result ; <NEW_LINE> bc_init_num ( & first ) ; <NEW_LINE> bc_init_num ( & second ) ;
ZVAL_DOUBLE ( rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1086 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy65: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' , ' ) {
, tool_broker_ ( new tooling::ToolBroker ) <NEW_LINE> , ruby_critical_set_ ( false ) <NEW_LINE> , check_gc_ ( false ) <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> , om ( 0 ) <NEW_LINE> , global_cache ( new GlobalCache ) <NEW_LINE> , config ( config ) <NEW_LINE> , user_variables ( cp )
int ret , i , rd = ( ( insn >> 25 ) & 0x1f ) ; <NEW_LINE> int from_kernel = ( regs -> tstate & TSTATE_PRIV ) != 0 ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <NEW_LINE> <END_VULN> if ( insn & 0x2000 ) { <NEW_LINE> maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; <NEW_LINE> value = sign_extend_imm13 ( insn ) ;
@description The supported format is: [ ( + | - ) ] [ 0 ] [ ( x | X ) ] [ HEX_DIGITS ] <NEW_LINE> @return true if all characters are digits or 'x' or 'X' <NEW_LINE> @ingroup MprString <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC bool shnumber ( cchar * s ) ;
return png_ptr -> io_ptr ; <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
if ( ! path ) <NEW_LINE> return false ; <NEW_LINE> snprintf ( path , bufsz , " % s / sys / fs / cgroup" , root ) ; <NEW_LINE> <START_VULN> r = mount ( "cgroup_root" , path , "tmpfs" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , "size = 10240k , mode = 755" ) ; <NEW_LINE> <END_VULN> if ( r < 0 ) { <NEW_LINE> SYSERROR ( "could not mount tmpfs to / sys / fs / cgroup in the container" ) ; <NEW_LINE> return false ;
principal = globalData -> GetPrincipal ( ) ; <NEW_LINE> if ( ! principal ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> JSObject * target = aTarget ; <NEW_LINE> <START_VULN> JSAutoRequest ar ( mContext ) ; <NEW_LINE> <END_VULN> JSFunction * fun = <NEW_LINE> ::JS_CompileUCFunctionForPrincipalsVersion ( mContext , <NEW_LINE> aShared ? nsnull : target , <NEW_LINE> nsJSPrincipals::get ( principal ) , <NEW_LINE> PromiseFlatCString ( aName ) . get ( ) , <NEW_LINE> aArgCount , aArgArray , <NEW_LINE> static_cast < const jschar * > ( PromiseFlatString ( aBody ) . get ( ) ) ,
if ( ! ( * cursor < oldlen ) ) <NEW_LINE> goto no_suitable_2nd ; <NEW_LINE> <START_VULN> next_char = get_next_char ( charset , old , oldlen , cursor , & status ) ; <NEW_LINE> <END_VULN> if ( status == FAILURE ) <NEW_LINE> goto no_suitable_2nd ;
* <NEW_LINE> * <NEW_LINE> static bool SplitLastSquareBracket ( nsACString & string , nsCString & bracketPart ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ABORT_IF_FALSE ( bracketPart . Length ( ) == 0 , "SplitLastSquareBracket must be called with empty bracketPart string" ) ; <NEW_LINE> <END_VULN> char * string_start = string . BeginWriting ( ) ; <NEW_LINE> char * s = string_start + string . Length ( ) - 1 ; <NEW_LINE> if ( * s != ' ] ' ) <NEW_LINE> return false ; <NEW_LINE> while ( * s != ' [ ' && s != string_start ) <NEW_LINE> s -- ;
#ifdef DEBUG <NEW_LINE> if ( ! mWillReparent ) { <NEW_LINE> JSObject * obj = GetWrapperPreserveColor ( ) ; <NEW_LINE> if ( obj ) { <NEW_LINE> JSObject * newScope = aScriptGlobalObject -> GetGlobalJSObject ( ) ; <NEW_LINE> <START_VULN> nsIScriptContext * scx = aScriptGlobalObject -> GetContext ( ) ; <NEW_LINE>JSContext * cx = scx ? scx -> GetNativeContext ( ) : nullptr ; <NEW_LINE>if ( ! cx ) { <NEW_LINE>nsContentUtils::ThreadJSContextStack ( ) -> Peek ( & cx ) ; <NEW_LINE>if ( ! cx ) { <NEW_LINE>cx = nsContentUtils::ThreadJSContextStack ( ) -> GetSafeJSContext ( ) ; <NEW_LINE>NS_ASSERTION ( cx , "Uhoh , no context , this is bad ! " ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE>if ( cx ) { <NEW_LINE>NS_ASSERTION ( JS_GetGlobalForObject ( cx , obj ) == newScope , <NEW_LINE>"Wrong scope , this is really bad ! " ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> if ( mAllowDNSPrefetch ) { <NEW_LINE> nsCOMPtr < nsIDocShell > docShell = do_QueryReferent ( mDocumentContainer ) ; <NEW_LINE> if ( docShell ) { <NEW_LINE> #ifdef DEBUG
TEST ( GIFImageDecoderTest , badCode ) <NEW_LINE> { <NEW_LINE> <START_VULN> RefPtr < SharedBuffer > testData = readFile ( " / Source / platform / image - decoders / testing / bad - code . gif" ) ; <NEW_LINE> <END_VULN> ASSERT_TRUE ( testData . get ( ) ) ; <NEW_LINE> OwnPtr < GIFImageDecoder > testDecoder ( createDecoder ( ) ) ;
#include "base / message_loop . h" <NEW_LINE> #include "base / shared_memory . h" <NEW_LINE> #include "media / base / media_export . h" <NEW_LINE> #include "media / audio / audio_output_ipc . h" <NEW_LINE> #include "media / audio / audio_parameters . h" <NEW_LINE> #include "media / audio / scoped_loop_observer . h" <NEW_LINE> #include "media / base / audio_renderer_sink . h" <NEW_LINE> namespace media { <NEW_LINE> <START_VULN> class AudioDeviceThread ; <NEW_LINE><NEW_LINE> <END_VULN> class MEDIA_EXPORT AudioOutputDevice <NEW_LINE> : NON_EXPORTED_BASE ( public AudioRendererSink ) , <NEW_LINE> public AudioOutputIPCDelegate ,
linenr_T line_lnum ; <NEW_LINE> colnr_T line_colnr ; <NEW_LINE> linenr_T line_count ; <NEW_LINE> <START_VULN> int num_head = 0 ; <NEW_LINE> <END_VULN> long old_header_seq , new_header_seq , cur_header_seq ; <NEW_LINE> long seq_last , seq_cur ; <NEW_LINE> long last_save_nr = 0 ;
return ; <NEW_LINE> for ( ; overflow ; overflow -- ) { <NEW_LINE> <START_VULN> if ( __perf_event_overflow ( event , nmi , throttle , <NEW_LINE> <END_VULN> data , regs ) ) {
DISALLOW_COPY_AND_ASSIGN ( DevToolsClient ) ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
namespace WebCore { <NEW_LINE> SecurityContext::SecurityContext ( ) <NEW_LINE> <START_VULN> : m_mayDisplaySeamlesslyWithParent ( false ) <NEW_LINE> , m_haveInitializedSecurityOrigin ( false ) <NEW_LINE> <END_VULN> , m_sandboxFlags ( SandboxNone ) <NEW_LINE> { <NEW_LINE> }
if ( nsINode::GetFirstChild ( ) == content ) { <NEW_LINE> mFirstChild = content -> GetNextSibling ( ) ; <NEW_LINE> } <NEW_LINE> mChildren . RemoveChildAt ( i ) ; <NEW_LINE> nsNodeUtils::ContentRemoved ( this , content , i , previousSibling ) ; <NEW_LINE> content -> UnbindFromTree ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> mInUnlinkOrDeletion = oldVal ; <NEW_LINE> <START_VULN> mCachedRootElement = nullptr ; <NEW_LINE> <END_VULN> mCustomPrototypes . Clear ( ) ; <NEW_LINE> ResetStylesheetsToURI ( aURI ) ; <NEW_LINE> if ( mListenerManager ) {
long vorbis_book_decodevs_add ( codebook * book , ogg_int32_t * a , <NEW_LINE> <START_VULN> oggpack_buffer * b , int n , int point ) { <NEW_LINE> <END_VULN> if ( book -> used_entries > 0 ) { <NEW_LINE> int step = n / book -> dim ; <NEW_LINE> ogg_int32_t * v = book -> dec_buf ;
int pixel_countdown ; <NEW_LINE> unsigned char * pixels ; <NEW_LINE> int pixel ; <NEW_LINE> <START_VULN> int pixel_limit ; <NEW_LINE> <END_VULN> s -> frame . reference = 1 ; <NEW_LINE> s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;
resultLen += n ; <NEW_LINE> <START_VULN> output . SetLength ( resultLen ) ; <NEW_LINE> <END_VULN> if ( resultLen > 0 ) { <NEW_LINE> nsACString::iterator out_iter ; <NEW_LINE> output . BeginWriting ( out_iter ) ;
JS_AbortIfWrongThread ( rt ) ; <NEW_LINE> JSContext * cx = OffTheBooks::new_ < JSContext > ( rt ) ; <NEW_LINE> if ( ! cx ) <NEW_LINE> return NULL ; <NEW_LINE> JS_ASSERT ( cx -> findVersion ( ) == JSVERSION_DEFAULT ) ; <NEW_LINE> <START_VULN> if ( ! cx -> busyArrays . init ( ) ) { <NEW_LINE> <END_VULN> Foreground::delete_ ( cx ) ; <NEW_LINE> return NULL ; <NEW_LINE> }
return ( tlv_len + 4 ) ; <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , "\n\t\t packet exceeded snapshot" ) ) ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> badtlv:
return ( 1 ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #ifdef PNG_WRITE_SUPPORTED <NEW_LINE>if ( interlace_preserved ) <NEW_LINE> <END_VULN> { <NEW_LINE> for ( ; ; ) <NEW_LINE> {
( * buffer ) [ ( * currlen ) ++ ] = ( char ) c ; <NEW_LINE> } <NEW_LINE> <START_VULN> return ; <NEW_LINE> <END_VULN> }
png_write_complete_chunk ( png_ptr , png_IHDR , buf , ( png_size_t ) 13 ) ; <NEW_LINE> <START_VULN> if ( ! ( png_ptr -> do_filter ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE || <NEW_LINE> png_ptr -> bit_depth < 8 )
<START_VULN> bool OutputFasterPlayback ( uint8 * dest ) ; <NEW_LINE> <END_VULN>
memset ( data_s , 0 , data_size ) ; <NEW_LINE> memcpy ( data_s , data , data_len ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> mcrypt_generic ( pm -> td , data_s , data_size ) ; <NEW_LINE> data_s [ data_size ] = '\0' ;
file = ( XkbFile * ) file -> common . next ) { <NEW_LINE> if ( file -> file_type < FIRST_KEYMAP_FILE_TYPE || <NEW_LINE> file -> file_type > LAST_KEYMAP_FILE_TYPE ) { <NEW_LINE> <START_VULN> log_err ( ctx , "Cannot define % s in a keymap file\n" , <NEW_LINE>xkb_file_type_to_string ( file -> file_type ) ) ; <NEW_LINE> <END_VULN> continue ; <NEW_LINE> }
if ( ! aImg -> mDecoder || aImg -> mDecoded ) <NEW_LINE> return NS_OK ; <NEW_LINE> <START_VULN> if ( aImg -> mDecoder -> IsSynchronous ( ) && aImg -> mDecoder -> NeedsNewFrame ( ) ) { <NEW_LINE> <END_VULN> MOZ_ASSERT ( NS_IsMainThread ( ) ) ; <NEW_LINE> aImg -> mDecoder -> AllocateFrame ( ) ; <NEW_LINE> aImg -> mDecodeRequest -> mAllocatedNewFrame = true ; <NEW_LINE> } <NEW_LINE> else if ( aImg -> mDecoder -> NeedsNewFrame ( ) ) {
if ( ! FindReplaceLength ( cx , res , rdata , & replen ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> size_t growth = leftlen + replen ; <NEW_LINE>if ( ! rdata . sb . reserve ( rdata . sb . length ( ) + growth ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> JSLinearString & str = rdata . str -> asLinear ( ) ;
PHP_FUNCTION ( mcrypt_module_is_block_algorithm ) <NEW_LINE> { <NEW_LINE> MCRYPT_GET_MODE_DIR_ARGS ( algorithms_dir ) <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( mcrypt_module_is_block_algorithm ( module , dir ) == 1 ) { <NEW_LINE> RETURN_TRUE ; <NEW_LINE> } else {
return ret ; <NEW_LINE> out_err: <NEW_LINE> <START_VULN> svc_rdma_send_error ( rdma_xprt , rmsgp , ret ) ; <NEW_LINE> <END_VULN> svc_rdma_put_context ( ctxt , 0 ) ; <NEW_LINE> return 0 ;
png_byte bit_depth = 0 ; <NEW_LINE> unsigned int palette_number = 0 ; <NEW_LINE> <START_VULN> while ( next_format ( & colour_type , & bit_depth , & palette_number , 1 ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> unsigned int i , j ;
nsTreeColumns::nsTreeColumns ( nsITreeBoxObject * aTree ) <NEW_LINE> : mTree ( aTree ) , <NEW_LINE> mFirstColumn ( nsnull ) <NEW_LINE> { <NEW_LINE> } <NEW_LINE> nsTreeColumns:: ~ nsTreeColumns ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> for ( nsTreeColumn * currCol = mFirstColumn ; currCol ; currCol = currCol -> GetNext ( ) ) { <NEW_LINE>currCol -> SetColumns ( nsnull ) ; <NEW_LINE> } <NEW_LINE>NS_IF_RELEASE ( mFirstColumn ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> NS_INTERFACE_MAP_BEGIN ( nsTreeColumns ) <NEW_LINE> NS_INTERFACE_MAP_ENTRY ( nsITreeColumns ) <NEW_LINE> NS_INTERFACE_MAP_ENTRY ( nsISupports ) <NEW_LINE> NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO ( TreeColumns ) <NEW_LINE> NS_INTERFACE_MAP_END
#include "base / callback_forward . h" <NEW_LINE> #include "base / files / file_path . h" <NEW_LINE> #include "base / memory / ref_counted . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "storage / browser / storage_browser_export . h" <NEW_LINE> namespace base {
return false ; <NEW_LINE> WeakMap * weakmap = fromJSObject ( obj ) ; <NEW_LINE> if ( weakmap ) { <NEW_LINE> <START_VULN> js::HashMap < JSObject * , Value > ::Ptr ptr = weakmap -> map . lookup ( key ) ; <NEW_LINE> <END_VULN> if ( ptr ) { <NEW_LINE> weakmap -> map . remove ( ptr ) ; <NEW_LINE> * vp = BooleanValue ( true ) ;
} <NEW_LINE> <START_VULN> static int cost_segmap ( int * segcounts , vp9_prob * probs ) { <NEW_LINE> <END_VULN> const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ; <NEW_LINE> const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ; <NEW_LINE> const int c45 = segcounts [ 4 ] + segcounts [ 5 ] ;
{ <NEW_LINE> if ( file != NULL ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_image_write_init ( image ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_image_write_control display ; <NEW_LINE> int result ;
class BrightnessLibrary ; <NEW_LINE> class BurnLibrary ; <NEW_LINE> class CryptohomeLibrary ; <NEW_LINE> <START_VULN> class KeyboardLibrary ; <NEW_LINE> <END_VULN> class InputMethodLibrary ; <NEW_LINE> class LibraryLoader ; <NEW_LINE> class LoginLibrary ; <NEW_LINE> class MountLibrary ;
png_read_data ( png_ptr , & ( info_ptr -> signature [ num_checked ] ) , num_to_check ) ; <NEW_LINE> png_ptr -> sig_bytes = 8 ; <NEW_LINE> <START_VULN> if ( png_sig_cmp ( info_ptr -> signature , num_checked , num_to_check ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( num_checked < 4 && <NEW_LINE> png_sig_cmp ( info_ptr -> signature , num_checked , num_to_check - 4 ) )
url = m_serializer -> urlForBlankFrame ( frame ) ; <NEW_LINE> <START_VULN> appendAttribute ( result , element , Attribute ( frameOwnerURLAttributeName ( * frameOwner ) , url . string ( ) ) , namespaces ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void SerializerMarkupAccumulator::appendEndTag ( Node * node )
uint8_t * dst_ptr2 = dst + w ; <NEW_LINE> for ( i = 0 ; i < h ; i ++ ) { <NEW_LINE> <START_VULN> vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <NEW_LINE>vpx_memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; <NEW_LINE>vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; <NEW_LINE> <END_VULN> src_ptr1 += src_pitch ; <NEW_LINE> src_ptr2 += src_pitch ; <NEW_LINE> dst_ptr1 += dst_pitch ;
* entity = ( const unsigned char * ) <NEW_LINE> c -> data . multicodepoint_table [ 0 ] . leading_entry . default_entity ; <NEW_LINE> * entity_len = c -> data . multicodepoint_table [ 0 ] . leading_entry . default_entity_len ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> }
inline void <NEW_LINE> JSObject::initCall ( JSContext * cx , const js::Bindings & bindings , JSObject * parent ) <NEW_LINE> { <NEW_LINE> init ( cx , & js::CallClass , & js::types::emptyTypeObject , parent , NULL , false ) ; <NEW_LINE> <START_VULN> lastProp = bindings . lastShape ( ) ; <NEW_LINE> <END_VULN> if ( bindings . extensibleParents ( ) ) <NEW_LINE> setOwnShape ( js_GenerateShape ( cx ) ) ; <NEW_LINE> else
<START_VULN> int release_vp9_frame_buffer ( void * cb_priv , <NEW_LINE>vpx_codec_frame_buffer_t * fb ) { <NEW_LINE> <END_VULN> struct ExternalFrameBuffer * const ext_fb = <NEW_LINE> ( struct ExternalFrameBuffer * ) fb -> priv ; <NEW_LINE> ( void ) cb_priv ;
return true ; <NEW_LINE> if ( privilegeContextCheck == StandardSecureContextCheck ) { <NEW_LINE> <START_VULN> Frame * parent = m_frame ? m_frame -> tree ( ) . parent ( ) : nullptr ; <NEW_LINE>if ( parent && ! parent -> canHaveSecureChild ( ) ) <NEW_LINE>return false ; <NEW_LINE> <END_VULN> } <NEW_LINE> return true ; <NEW_LINE> }
if ( sock -> file -> f_flags & O_NONBLOCK ) <NEW_LINE> msg_sys -> msg_flags |= MSG_DONTWAIT ; <NEW_LINE> <START_VULN> if ( used_address && used_address -> name_len == msg_sys -> msg_namelen && <NEW_LINE> ! memcmp ( & used_address -> name , msg -> msg_name , <NEW_LINE> <END_VULN> used_address -> name_len ) ) { <NEW_LINE> err = sock_sendmsg_nosec ( sock , msg_sys , total_len ) ; <NEW_LINE> goto out_freectl ;
list -> count = 0 ; <NEW_LINE> file -> idat -> idat_list_tail = list ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> list -> lengths [ ( list -> count ) ++ ] = file -> chunk -> chunk_length ;
if ( tail [ i ] ) nz ++ ; <NEW_LINE> return nz > 20 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1557 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> void CLASS ppm_thumb ( ) <NEW_LINE> { <NEW_LINE> char * thumb ;
return - 2 ; <NEW_LINE> LOG ( LOG_ERR , ( " % s" , strerror ( errno ) ) ) ; <NEW_LINE> <START_VULN> return - 1 ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ret == 0 ) {
MprKey * sp , * prevSp ; <NEW_LINE> int index ; <NEW_LINE> <START_VULN> if ( hash == 0 ) { <NEW_LINE>assert ( hash ) ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> } <NEW_LINE> lock ( hash ) ;
#define VMACACHE_MASK ( VMACACHE_SIZE - 1 ) <NEW_LINE> struct vmacache { <NEW_LINE> <START_VULN> u32 seqnum ; <NEW_LINE> <END_VULN> struct vm_area_struct * vmas [ VMACACHE_SIZE ] ; <NEW_LINE> } ;
if ( noff >= ( off_t ) xsh_size ) <NEW_LINE> break ; <NEW_LINE> noff = donote ( ms , nbuf , ( size_t ) noff , <NEW_LINE> <START_VULN> xsh_size , clazz , swap , 4 , flags ) ; <NEW_LINE> <END_VULN> if ( noff == 0 ) <NEW_LINE> break ; <NEW_LINE> }
nsresult <NEW_LINE> CanvasRenderingContext2D::PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <NEW_LINE> <START_VULN> unsigned char * aData , uint32_t aDataLen , <NEW_LINE> <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , <NEW_LINE> int32_t dirtyWidth , int32_t dirtyHeight ) <NEW_LINE> {
<START_VULN> #define FC_NUM_CASE_FOLD	291 <NEW_LINE> <END_VULN> #define FC_NUM_CASE_FOLD_CHARS	471 <NEW_LINE> #define FC_MAX_CASE_FOLD_CHARS	6 <NEW_LINE> #define FC_MAX_CASE_FOLD_EXPAND	4
msg . msg_iovlen = 1 ; <NEW_LINE> do { <NEW_LINE> <START_VULN> ret = sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ; <NEW_LINE> <END_VULN> } while ( ret < 0 && errno == EINTR ) ; <NEW_LINE> if ( ret < 0 ) {
case BAG_IF_ELSE: <NEW_LINE> { <NEW_LINE> <START_VULN> int cond_len , then_len , jump_len ; <NEW_LINE> <END_VULN> Node * cond = NODE_BAG_BODY ( node ) ; <NEW_LINE> Node * Then = node -> te . Then ; <NEW_LINE> Node * Else = node -> te . Else ;
{ <NEW_LINE> VipsObjectClass * class = VIPS_OBJECT_GET_CLASS ( gif ) ; <NEW_LINE> GifFileType * file = gif -> file ; <NEW_LINE> <START_VULN> ColorMapObject * map = file -> Image . ColorMap ? <NEW_LINE>file -> Image . ColorMap : file -> SColorMap ; <NEW_LINE> <END_VULN> GifByteType * extension ; <NEW_LINE> if ( DGifGetImageDesc ( gif -> file ) == GIF_ERROR ) {
png_int_32 PNGAPI <NEW_LINE> png_get_int_32 ( png_bytep buf ) <NEW_LINE> { <NEW_LINE> <START_VULN> png_int_32 i = ( ( png_int_32 ) ( * buf ) << 24 ) + <NEW_LINE> ( ( png_int_32 ) ( * ( buf + 1 ) ) << 16 ) + <NEW_LINE> ( ( png_int_32 ) ( * ( buf + 2 ) ) << 8 ) + <NEW_LINE> ( png_int_32 ) ( * ( buf + 3 ) ) ; <NEW_LINE> <END_VULN> return ( i ) ; <NEW_LINE> }
Assert . notEqual ( contents , aOriginalContents , <NEW_LINE> "the contents of the maintenanceservice . log should not " + <NEW_LINE> "be the same as the original contents" ) ; <NEW_LINE> Assert . notEqual ( contents . indexOf ( LOG_SVC_SUCCESSFUL_LAUNCH ) , - 1 , <NEW_LINE> "the contents of the maintenanceservice . log should " + <NEW_LINE> "contain the successful launch string" ) ; <NEW_LINE> } <NEW_LINE> function readServiceLogFile ( ) { <NEW_LINE> <START_VULN> let file = Cc [ "@mozilla . org / file / directory_service ; 1" ] . <NEW_LINE>getService ( Ci . nsIProperties ) . <NEW_LINE>get ( "CmAppData" , Ci . nsIFile ) ; <NEW_LINE>file . append ( "Mozilla" ) ; <NEW_LINE> <END_VULN> file . append ( "logs" ) ; <NEW_LINE> file . append ( "maintenanceservice . log" ) ; <NEW_LINE> return readFile ( file ) ; <NEW_LINE> } <NEW_LINE> function waitServiceApps ( ) { <NEW_LINE> waitForApplicationStop ( "maintenanceservice_installer . exe" ) ;
#ifdef __GNUC__ <NEW_LINE> else <NEW_LINE> argv = NULL ; <NEW_LINE> #endif <NEW_LINE> ok = ! wp -> setter || <NEW_LINE> ( ( sprop -> attrs & JSPROP_SETTER ) <NEW_LINE> ? js_InternalCall ( cx , obj , OBJECT_TO_JSVAL ( wp -> setter ) , <NEW_LINE> 1 , vp , vp ) <NEW_LINE> <START_VULN> : wp -> setter ( cx , OBJ_THIS_OBJECT ( cx , obj ) , userid , vp ) ) ; <NEW_LINE> <END_VULN> if ( injectFrame ) { <NEW_LINE> if ( frame . callobj ) <NEW_LINE> ok &= js_PutCallObject ( cx , & frame ) ; <NEW_LINE> if ( frame . argsobj ) <NEW_LINE> ok &= js_PutArgsObject ( cx , & frame ) ; <NEW_LINE> cx -> fp = frame . down ;
while ( v -> Allocated < n ) <NEW_LINE> GrowNamedColorList ( v ) ; <NEW_LINE> <START_VULN> strncpy ( v -> Prefix , Prefix , sizeof ( v -> Prefix ) ) ; <NEW_LINE>strncpy ( v -> Suffix , Suffix , sizeof ( v -> Suffix ) ) ; <NEW_LINE> <END_VULN> v -> Prefix [ 32 ] = v -> Suffix [ 32 ] = 0 ; <NEW_LINE> v -> ColorantCount = ColorantCount ;
ZVAL_RESOURCE ( & intern -> u . file . zresource , php_stream_get_resource_id ( intern -> u . file . stream ) ) ; <NEW_LINE> Z_SET_REFCOUNT ( intern -> u . file . zresource , 1 ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> intern -> u . file . delimiter = ' , ' ; <NEW_LINE> intern -> u . file . enclosure = '"' ; <NEW_LINE> intern -> u . file . escape = '\\' ;
if ( encryption_count > 0 ) { <NEW_LINE> encryption_entries_ = <NEW_LINE> <START_VULN> new ( std::nothrow ) ContentEncryption * [ encryption_count ] ; <NEW_LINE> <END_VULN> if ( ! encryption_entries_ ) { <NEW_LINE> delete [ ] compression_entries_ ; <NEW_LINE> return - 1 ;
int tok <NEW_LINE> = XmlPrologTok ( parser -> m_internalEncoding , textStart , textEnd , & next ) ; <NEW_LINE> result = doProlog ( parser , parser -> m_internalEncoding , textStart , textEnd , <NEW_LINE> <START_VULN> tok , next , & next , XML_FALSE ) ; <NEW_LINE> <END_VULN> } else <NEW_LINE> #endif <NEW_LINE> result = doContent ( parser , openEntity -> startTagLevel ,
aDatabaseFilename . Append ( NS_ConvertASCIItoUTF16 ( substring ) ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> CreateFileTables ( mozIStorageConnection * aDBConn ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "CreateFileTables" ) ; <NEW_LINE> nsresult rv = aDBConn -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( <NEW_LINE> "CREATE TABLE file ( " <NEW_LINE> "id INTEGER PRIMARY KEY , "
mChildren . EnumerateForwards ( ClearParentPtr , nullptr ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> NS_IMPL_ISUPPORTS ( nsSHEntry , nsISHContainer , nsISHEntry , nsISHEntryInternal ) <NEW_LINE> <END_VULN> NS_IMETHODIMP nsSHEntry::SetScrollPosition ( int32_t x , int32_t y ) <NEW_LINE> { <NEW_LINE> mScrollPositionX = x ;
static void reflectStringAttributeAttributeSetter ( v8::Local < v8::Value > v8Value , const v8::FunctionCallbackInfo < v8::Value > & info ) <NEW_LINE> { <NEW_LINE> v8::Local < v8::Object > holder = info . Holder ( ) ; <NEW_LINE> <START_VULN> Element * impl = V8Element::toImpl ( holder ) ; <NEW_LINE> <END_VULN> V8StringResource < > cppValue = v8Value ; <NEW_LINE> if ( ! cppValue . prepare ( ) ) <NEW_LINE> return ;
void HTMLFormControlElement::updateVisibleValidationMessage ( ) { <NEW_LINE> Page * page = document ( ) . page ( ) ; <NEW_LINE> <START_VULN> if ( ! page ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> String message ; <NEW_LINE> if ( layoutObject ( ) && willValidate ( ) )
return - END_CIRC_REASON_TORPROTOCOL ; <NEW_LINE> } else if ( rv == - 1 ) { <NEW_LINE> tor_free ( bcell . address ) ; <NEW_LINE> <START_VULN> relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
cwd [ 2 ] = '\0' ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> <START_VULN> cwd_skip = ( int ) strlen ( cwd ) + 1 ; <NEW_LINE> <END_VULN> snprintf ( work_pattern , MAXPATHLEN , " % s % c % s" , cwd , DEFAULT_SLASH , pattern ) ; <NEW_LINE> pattern = work_pattern ;
<START_VULN> <NEW_LINE> <END_VULN> #ifndef COMPILER_DEBUG_H_ <NEW_LINE> #define COMPILER_DEBUG_H_ <NEW_LINE> #include < assert . h > <NEW_LINE> #ifdef _DEBUG <NEW_LINE> #define TRACE_ENABLED
} <NEW_LINE> } <NEW_LINE> break ; <NEW_LINE> <START_VULN> case SPL_FS_DIR: <NEW_LINE> <END_VULN> zend_restore_error_handling ( & error_handling TSRMLS_CC ) ; <NEW_LINE> zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , "Operation not supported" ) ; <NEW_LINE> return NULL ;
content_encoding_entries [ i ] = content_encoding_entries_ [ i ] ; <NEW_LINE> } <NEW_LINE> <START_VULN> delete [ ] content_encoding_entries_ ; <NEW_LINE> <END_VULN> content_encoding_entries_ = content_encoding_entries ; <NEW_LINE> content_encoding_entries_ [ content_encoding_entries_size_ ] = content_encoding ;
if ( ConstructorMode::current ( ) == ConstructorMode::WrapExistingObject ) <NEW_LINE> return args . Holder ( ) ; <NEW_LINE> if ( args . Length ( ) < 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , hello , MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ; <NEW_LINE> MessagePortArray messagePortArrayTransferList ; <NEW_LINE> ArrayBufferArray arrayBufferArrayTransferList ;
void OnDidRunContentWithCertificateErrors ( RenderFrameHostImpl * source ) ; <NEW_LINE> void OnDocumentLoadedInFrame ( RenderFrameHostImpl * source ) ; <NEW_LINE> void OnDidFinishLoad ( RenderFrameHostImpl * source , const GURL & url ) ; <NEW_LINE> <START_VULN> void OnGoToEntryAtOffset ( RenderViewHostImpl * source , int offset ) ; <NEW_LINE> <END_VULN> void OnUpdateZoomLimits ( RenderViewHostImpl * source , <NEW_LINE> int minimum_percent , <NEW_LINE> int maximum_percent ) ;
cpi -> total_sq_error2 += sq_error2 ; <NEW_LINE> cpi -> totalp += frame_psnr2 ; <NEW_LINE> <START_VULN> frame_ssim2 = vp8_calc_ssim ( cpi -> Source , <NEW_LINE> & cm -> post_proc_buffer , 1 , & weight ) ; <NEW_LINE> <END_VULN> cpi -> summed_quality += frame_ssim2 * weight ; <NEW_LINE> cpi -> summed_weights += weight ;
{ <NEW_LINE> AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; <NEW_LINE> unsigned char * buf = NULL ; <NEW_LINE> <START_VULN> int ret = 0 , probe_size ; <NEW_LINE> <END_VULN> if ( ! max_probe_size ) { <NEW_LINE> max_probe_size = PROBE_BUF_MAX ;
timeout . tv_sec = 0 ; <NEW_LINE> timeout . tv_usec = 0 ; <NEW_LINE> <START_VULN> select ( sockfd [ 0 ] + 1 , & read_fds , NULL , NULL , & timeout ) ; <NEW_LINE> <END_VULN> } while ( FD_ISSET ( sockfd [ 0 ] , & read_fds ) ) ; <NEW_LINE> }
return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 861 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy39: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych == ' + ' ) goto yy40 ;
#endif <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #if defined ( PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED ) || \ <NEW_LINE> defined ( PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED )
for ( i = 0 ; i < PL -> num_properties ; i ++ ) <NEW_LINE> { <NEW_LINE> char name [ 100 ] , value [ 100 ] ; <NEW_LINE> <START_VULN> utf2char ( P [ i ] . name , name , sizeof ( name ) ) ; <NEW_LINE>utf2char ( P [ i ] . value , value , sizeof ( value ) ) ; <NEW_LINE> <END_VULN> if ( ! strcmp ( name , "ISO" ) ) <NEW_LINE> imgdata . other . iso_speed = atoi ( value ) ; <NEW_LINE> if ( ! strcmp ( name , "CAMMANUF" ) )
GetObject ( bitmapH , sizeof ( BITMAP ) , ( LPSTR ) & bitmap ) ; <NEW_LINE> if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) <NEW_LINE> { <NEW_LINE> <START_VULN> image -> rows = bitmap . bmHeight ; <NEW_LINE> <END_VULN> image -> columns = bitmap . bmWidth ; <NEW_LINE> } <NEW_LINE> Initialize the bitmap header info .
JSObject * object = nullptr ; <NEW_LINE> wrappedJS -> GetJSObject ( & object ) ; <NEW_LINE> if ( ! object ) { <NEW_LINE> return NS_ERROR_UNEXPECTED ; <NEW_LINE> } <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> NS_ENSURE_STATE ( pusher . Push ( cx ) ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , object ) ; <NEW_LINE> JS::Value thisValue = JSVAL_VOID ; <NEW_LINE> JS::Value funval ; <NEW_LINE> if ( ! JS_GetProperty ( cx , object , "constructor" , & funval ) || ! funval . isObject ( ) ) { <NEW_LINE> return NS_ERROR_UNEXPECTED ;
return FALSE ; <NEW_LINE> * data_offset = offset ; <NEW_LINE> <START_VULN> <NEW_LINE>pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ; <NEW_LINE>if ( pkt_len == - 1 ) <NEW_LINE>return FALSE ; <NEW_LINE><NEW_LINE><NEW_LINE>return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len , <NEW_LINE>wth -> frame_buffer , err , err_info ) ; <NEW_LINE> <END_VULN> }
propagateFailureToBuiltinStatus ( ok_ins , status_ins ) ; <NEW_LINE> guard ( true , lir -> ins_eq0 ( status_ins ) , STATUS_EXIT ) ; <NEW_LINE> } <NEW_LINE> JS_REQUIRES_STACK JSRecordingStatus <NEW_LINE> <START_VULN> TraceRecorder::emitNativeCall ( JSSpecializedNative * sn , uintN argc , LIns * args [ ] ) <NEW_LINE> <END_VULN> { <NEW_LINE> bool constructing = sn -> flags & JSTN_CONSTRUCTOR ; <NEW_LINE> if ( JSTN_ERRTYPE ( sn ) == FAIL_STATUS ) { <NEW_LINE> JS_ASSERT ( ! pendingSpecializedNative ) ;
{ <NEW_LINE> if ( new_size == * newlength ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( terminate ) <NEW_LINE> <END_VULN> text [ prefix_size + * newlength ] = 0 ; <NEW_LINE> if ( prefix_size > 0 )
#include "core / platform / graphics / SimpleFontData . h" <NEW_LINE> #include "core / platform / graphics / chromium / FontPlatformDataChromiumWin . h" <NEW_LINE> #include "core / platform / graphics / chromium / UniscribeHelperTextRun . h" <NEW_LINE> <START_VULN> #include "core / platform / win / HWndDC . h" <NEW_LINE>#include "core / platform / win / SystemInfo . h" <NEW_LINE> <END_VULN> namespace WebCore {
else <NEW_LINE> { <NEW_LINE> <START_VULN> png_uint_32 h = transform_height ( pp , colour_type , bit_depth ) ; <NEW_LINE>int npasses = png_set_interlace_handling ( pp ) ; <NEW_LINE> <END_VULN> int pass ; <NEW_LINE> if ( npasses != npasses_from_interlace_type ( pp , interlace_type ) )
mFrameConstructor -> ProcessPendingRestyles ( ) ; <NEW_LINE> if ( ! mIsDestroying ) { <NEW_LINE> { <NEW_LINE> <START_VULN> nsAutoCauseReflowNotifier crNotifier ( this ) ; <NEW_LINE> <END_VULN> WillDoReflow ( ) ; <NEW_LINE> AUTO_LAYOUT_PHASE_ENTRY_POINT ( GetPresContext ( ) , Reflow ) ; <NEW_LINE> mIsReflowing = PR_TRUE ; <NEW_LINE> mDirtyRoots . RemoveElement ( rootFrame ) ; <NEW_LINE> DoReflow ( rootFrame ) ;
( void ) WriteBlobByte ( image , byte ) ; <NEW_LINE> ( void ) WriteBlob ( image , tptr - tmpbuf , ( unsigned char * ) tmpbuf ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else <NEW_LINE> ( void ) WriteBlob ( image , bytes_per_row , one_row ) ;
nsIntRect r ; <NEW_LINE> if ( mImage ) { <NEW_LINE> r = mImage -> FrameRect ( imgIContainer::FRAME_CURRENT ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsTObserverArray < imgRequestProxy * > array ; <NEW_LINE>array . AppendElement ( proxy ) ; <NEW_LINE> <END_VULN> SyncNotifyState ( array , ! ! mImage , mState , r , mHadLastPart ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> imgStatusTracker::EmulateRequestFinished ( imgRequestProxy * aProxy , <NEW_LINE> nsresult aStatus ) <NEW_LINE> { <NEW_LINE> nsCOMPtr < imgIRequest > kungFuDeathGrip ( aProxy ) ;
# endif <NEW_LINE> # define TOLOWER ( x ) tolower ( x ) <NEW_LINE> #else <NEW_LINE> <START_VULN> # define TOLOWER ( x ) ( ( ( x ) < 0 || ( x ) > 256 ) ? ( x ) :mspack_tolower_map [ ( x ) ] ) <NEW_LINE> <END_VULN>
JS_PUBLIC_API ( JSBool ) <NEW_LINE> JS_RefreshCrossCompartmentWrappers ( JSContext * cx , JSObject * obj ) <NEW_LINE> { <NEW_LINE> <START_VULN> return RemapWrappers ( cx , obj , obj ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_PUBLIC_API ( JSObject * ) <NEW_LINE> JS_GetGlobalObject ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> return cx -> globalObject ; <NEW_LINE> }
cpi -> mbgraph_n_frames = n_frames ; <NEW_LINE> for ( i = 0 ; i < n_frames ; i ++ ) { <NEW_LINE> MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; <NEW_LINE> <START_VULN> vpx_memset ( frame_stats -> mb_stats , 0 , <NEW_LINE>cm -> mb_rows * cm -> mb_cols * <NEW_LINE>sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ; <NEW_LINE> <END_VULN> }
self -> mBuffer . BeginWriting ( ) + haveRead , <NEW_LINE> & dstLen ) ; <NEW_LINE> haveRead += dstLen ; <NEW_LINE> consumed += srcLen ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> <START_VULN> NS_ASSERTION ( 0 < capacity - haveRead , <NEW_LINE>"Decoder returned an error but filled the output buffer ! " <NEW_LINE>"Should not happen . " ) ; <NEW_LINE> <END_VULN> self -> mBuffer . BeginWriting ( ) [ haveRead ++ ] = 0xFFFD ; <NEW_LINE> ++ consumed ; <NEW_LINE> consumed = NS_MAX < uint32_t > ( consumed , 0 ) ; <NEW_LINE> self -> mDecoder -> Reset ( ) ; <NEW_LINE> } <NEW_LINE> } while ( consumed < aCount ) ;
<START_VULN> static const char * const cfg = " -- target = armv7 - android - gcc -- disable - runtime - cpu - detect -- sdk - path = / usr / local / google / home / hkuang / Downloads / android - ndk - r9d -- disable - neon -- disable - examples -- disable - docs -- enable - realtime - only" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
do { <NEW_LINE> nsIFrame * childFrame = aFrame -> GetFirstChild ( childListName ) ; <NEW_LINE> for ( ; childFrame ; childFrame = childFrame -> GetNextSibling ( ) ) { <NEW_LINE> NS_ASSERTION ( ! ( childFrame -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) , <NEW_LINE> "out - of - flow on wrong child list" ) ; <NEW_LINE> if ( NS_LIKELY ( nsGkAtoms::placeholderFrame != childFrame -> GetType ( ) ) ) { <NEW_LINE> <START_VULN> RECURSE ( aRemovedFrame , childFrame ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> nsIFrame * outOfFlowFrame = <NEW_LINE> nsPlaceholderFrame::GetRealFrameForPlaceholder ( childFrame ) ; <NEW_LINE> aFrameManager -> UnregisterPlaceholderFrame ( ( nsPlaceholderFrame * ) childFrame ) ;
<START_VULN> void OnDidGetDefaultPageLayout ( <NEW_LINE>const printing::PageSizeMargins & page_layout , <NEW_LINE>const gfx::Rect & printable_area , <NEW_LINE>bool has_custom_page_size_style ) ; <NEW_LINE> <END_VULN>
load_fake ( png_charp param , png_bytepp profile ) <NEW_LINE> { <NEW_LINE> char * endptr = NULL ; <NEW_LINE> <START_VULN> unsigned long long int size = strtoull ( param , & endptr , 0 ) ; <NEW_LINE> <END_VULN> if ( endptr != NULL && * endptr == ' * ' )
char * _cookies , user [ 64 ] = { '\0' } , outbuf [ FILENAME_MAX ] ; <NEW_LINE> AddressTree ptree ; <NEW_LINE> int rc ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( ! L ) return ( - 1 ) ; <NEW_LINE> luaL_openlibs ( L ) ;
return ; <NEW_LINE> } <NEW_LINE> <START_VULN> l_row -- ; <NEW_LINE>l_column -- ; <NEW_LINE> <END_VULN> ( * o_column_idx ) [ l_i ] = l_column ; <NEW_LINE> ( * o_values ) [ l_i ] = l_value ;
MEDIA_EXPORT extern const char kVideoThreads [ ] ; <NEW_LINE> <START_VULN> MEDIA_EXPORT extern const char kDisableAudioMixer [ ] ; <NEW_LINE> <END_VULN> }
EXPECT_TRUE ( this -> SetCanonicalCookie ( <NEW_LINE> cs , <NEW_LINE> <START_VULN> base::MakeUnique < CanonicalCookie > ( <NEW_LINE> <END_VULN> "C" , "D" , " . " + foo_bar_domain , " / bar" , two_hours_ago , base::Time ( ) , <NEW_LINE> one_hour_ago , false , true , CookieSameSite::DEFAULT_MODE , <NEW_LINE> COOKIE_PRIORITY_DEFAULT ) ,
return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> GetAllHelper::ReleaseMainThreadObjects ( ) <NEW_LINE> { <NEW_LINE> mKeyRange = nullptr ; <NEW_LINE> for ( uint32_t index = 0 ; index < mCloneReadInfos . Length ( ) ; index ++ ) { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( <NEW_LINE>mCloneReadInfos [ index ] . mCloneBuffer ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> ObjectStoreHelper::ReleaseMainThreadObjects ( ) ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> GetAllHelper::PackArgumentsForParentProcess ( ObjectStoreRequestParams & aParams ) <NEW_LINE> { <NEW_LINE> FIXME_Bug_521898_objectstore::GetAllParams params ;
if ( mb_row != pc -> mb_rows - 1 ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memcpy ( ( pbi -> mt_yabove_row [ mb_row + 1 ] + 32 + mb_col * 16 ) , ( xd -> dst . y_buffer + 15 * recon_y_stride ) , 16 ) ; <NEW_LINE>vpx_memcpy ( ( pbi -> mt_uabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . u_buffer + 7 * recon_uv_stride ) , 8 ) ; <NEW_LINE>vpx_memcpy ( ( pbi -> mt_vabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . v_buffer + 7 * recon_uv_stride ) , 8 ) ; <NEW_LINE> <END_VULN> }
CERTCertList * certList = CERT_NewCertList ( ) ; <NEW_LINE> if ( ! certList ) <NEW_LINE> return nullptr ; <NEW_LINE> for ( size_t iEV = 0 ; iEV < ( sizeof ( myTrustedEVInfos ) / sizeof ( nsMyTrustedEVInfo ) ) ; ++ iEV ) { <NEW_LINE> nsMyTrustedEVInfo & entry = myTrustedEVInfos [ iEV ] ; <NEW_LINE> if ( ! entry . oid_name ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> if ( entry . oid_tag == oid_tag ) <NEW_LINE>CERT_AddCertToListTail ( certList , CERT_DupCertificate ( entry . cert ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef PSM_ENABLE_TEST_EV_ROOTS <NEW_LINE> getRootsForOidFromExternalRootsFile ( certList , oid_tag ) ; <NEW_LINE> #endif <NEW_LINE> return certList ; <NEW_LINE> }
} <NEW_LINE> <START_VULN> if ( ! preferred ) <NEW_LINE> <END_VULN> return 1 ; <NEW_LINE> }
\ ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** / <NEW_LINE> <START_VULN> jas_matrix_t * jas_seq2d_create ( int xstart , int ystart , int xend , int yend ) <NEW_LINE> <END_VULN> { <NEW_LINE> jas_matrix_t * matrix ; <NEW_LINE> assert ( xstart <= xend && ystart <= yend ) ;
yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != '"' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 609 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> size_t len , maxlen ; <NEW_LINE> char * str ;
virtual bool CanCommitURL ( RenderProcessHost * process_host , const GURL & url ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> virtual bool ShouldAllowOpenURL ( SiteInstance * site_instance , const GURL & url ) ;
* <NEW_LINE> #include "nsIEnumerator . h" <NEW_LINE> #include "nsCOMPtr . h" <NEW_LINE> <START_VULN> #include "nsVoidArray . h" <NEW_LINE> <END_VULN> class nsIDocShellTreeItem ; <NEW_LINE> #define NS_DOCSHELL_FORWARDS_ENUMERATOR_CID \ <NEW_LINE> { 0x13cbc281 , 0x35ae , 0x11d5 , { 0xbe , 0x5b , 0xbd , 0xe0 , 0xed , 0xec , 0xe4 , 0x3c } }
} <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! ap_strchr_c ( range , ' , ' ) ) { <NEW_LINE><NEW_LINE>num_ranges = 1 ; <NEW_LINE> } <NEW_LINE>else { <NEW_LINE><NEW_LINE>num_ranges = 2 ; <NEW_LINE> } <NEW_LINE> <END_VULN> r -> status = HTTP_PARTIAL_CONTENT ; <NEW_LINE> r -> range = range + 6 ;
XYZ . blue_Y = int_blue_Y ; <NEW_LINE> XYZ . blue_Z = int_blue_Z ; <NEW_LINE> <START_VULN> if ( png_colorspace_set_endpoints ( png_ptr , & info_ptr -> colorspace , & XYZ , 2 ) ) <NEW_LINE> <END_VULN> info_ptr -> colorspace . flags |= PNG_COLORSPACE_FROM_cHRM ; <NEW_LINE> png_colorspace_sync_info ( png_ptr , info_ptr ) ;
if ( ! parent -> isHTMLElement ( ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> RefPtr < DocumentFragment > fragment = Range::createDocumentFragmentForElement ( markup , toHTMLElement ( parent ) ) ; <NEW_LINE> <END_VULN> ExceptionCode exception = 0 ; <NEW_LINE> if ( ! m_element -> nextSibling ( ) )
JSStackTraceElem * framesDest = priv -> stackElems ; <NEW_LINE> Value * valuesDest = reinterpret_cast < Value * > ( framesDest + frames . length ( ) ) ; <NEW_LINE> JS_ASSERT ( valuesDest == GetStackTraceValueBuffer ( priv ) ) ; <NEW_LINE> PodCopy ( framesDest , frames . begin ( ) , frames . length ( ) ) ; <NEW_LINE> PodCopy ( valuesDest , values . begin ( ) , values . length ( ) ) ; <NEW_LINE> <START_VULN> exnObject -> setPrivate ( priv ) ; <NEW_LINE> <END_VULN> return true ; <NEW_LINE> } <NEW_LINE> static inline JSExnPrivate * <NEW_LINE> GetExnPrivate ( JSObject * obj ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( obj -> isError ( ) ) ; <NEW_LINE> return ( JSExnPrivate * ) obj -> getPrivate ( ) ;
if ( ( number_planes & 0x01 ) == 0 ) <NEW_LINE> ( void ) ReadBlobByte ( image ) ; <NEW_LINE> if ( EOFBlob ( image ) != MagickFalse ) <NEW_LINE> <START_VULN> { <NEW_LINE>ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , <NEW_LINE>image -> filename ) ; <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE> <END_VULN> colormap = ( unsigned char * ) NULL ; <NEW_LINE> if ( number_colormaps != 0 ) <NEW_LINE> {
#ifndef XPCONNECT_STANDALONE <NEW_LINE> nsresult <NEW_LINE> xpc_EvalInSandbox ( JSContext * cx , JSObject * sandbox , const nsAString & source , <NEW_LINE> <START_VULN> const char * filename , PRInt32 lineNo , jsval * rval ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( JS_GetClass ( cx , sandbox ) != & SandboxClass ) <NEW_LINE> return NS_ERROR_INVALID_ARG ;
} <NEW_LINE> } <NEW_LINE> if ( ccx ) { <NEW_LINE> #ifdef DEBUG_xpc_hacker <NEW_LINE> printf ( " ! xpc - deferring destruction of JSContext @ % p\n" , <NEW_LINE> ( void * ) aJSContext ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> ccx -> SetDestroyJSContextInDestructor ( true ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_ASSERTION ( ! XPCJSRuntime::Get ( ) -> GetJSContextStack ( ) -> HasJSContext ( aJSContext ) , <NEW_LINE> "JSContext still in threadjscontextstack ! " ) ; <NEW_LINE> if ( noGC )
if ( overflow || scaledSize . width <= 0 || scaledSize . height <= 0 ) <NEW_LINE> return result ; <NEW_LINE> gfxRect r ( aDataRect . x , aDataRect . y , aDataRect . width , aDataRect . height ) ; <NEW_LINE> r . Scale ( 1 / kernelX , 1 / kernelY ) ; <NEW_LINE> r . RoundOut ( ) ; <NEW_LINE> if ( ! gfxUtils::GfxRectToIntRect ( r , & result . mDataRect ) ) <NEW_LINE> return result ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> result . mSource = new gfxImageSurface ( scaledSize , <NEW_LINE> gfxASurface::ImageFormatARGB32 ) ; <NEW_LINE> result . mTarget = new gfxImageSurface ( scaledSize , <NEW_LINE> gfxASurface::ImageFormatARGB32 ) ; <NEW_LINE> if ( ! result . mSource || result . mSource -> CairoStatus ( ) || <NEW_LINE> ! result . mTarget || result . mTarget -> CairoStatus ( ) ) { <NEW_LINE> result . mSource = nullptr ; <NEW_LINE> result . mTarget = nullptr ;
} <NEW_LINE> static int _vorbis_pack_info ( oggpack_buffer * opb , vorbis_info * vi ) { <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> if ( ! ci ) return ( OV_EFAULT ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> oggpack_write ( opb , 0x01 , 8 ) ; <NEW_LINE> _v_writestring ( opb , "vorbis" , 6 ) ; <NEW_LINE> oggpack_write ( opb , 0x00 , 32 ) ; <NEW_LINE> oggpack_write ( opb , vi -> channels , 8 ) ; <NEW_LINE> oggpack_write ( opb , vi -> rate , 32 ) ;
break ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) { <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , " % s" , tstr ) ) ; <NEW_LINE> ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; <NEW_LINE> return ;
#endif <NEW_LINE> if ( cfname ) <NEW_LINE> fp = fopen ( cfname , "r" ) ; <NEW_LINE> <START_VULN> #line 4151 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> if ( ! fp ) <NEW_LINE> { <NEW_LINE> #ifdef LIBRAW_LIBRARY_BUILD
bool done ( ) const { return done_ ; } <NEW_LINE> <START_VULN> const char * name ( ) const { return name_ ; } <NEW_LINE> <END_VULN>
nsCOMPtr < nsIScriptGlobalObject > sgo = do_QueryInterface ( GetOwner ( ) ) ; <NEW_LINE> NS_ENSURE_TRUE_VOID ( sgo ) ; <NEW_LINE> nsIScriptContext * scriptContext = sgo -> GetContext ( ) ; <NEW_LINE> NS_ENSURE_TRUE_VOID ( scriptContext ) ; <NEW_LINE> <START_VULN> JSContext * cx = scriptContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE_VOID ( cx ) ; <NEW_LINE> while ( mMessagesToDispatch . GetSize ( ) > 0 ) { <NEW_LINE> nsAutoPtr < Message > <NEW_LINE> message ( static_cast < Message * > ( mMessagesToDispatch . PopFront ( ) ) ) ; <NEW_LINE> jsval jsData ;
return ; <NEW_LINE> } <NEW_LINE> <START_VULN> alphablending_bak = im -> alphaBlendingFlag ; <NEW_LINE> <END_VULN> im -> alphaBlendingFlag = 0 ; <NEW_LINE> if ( nc == gdTiled ) {
{ <NEW_LINE> INC_STATS ( "DOM . DataView . setInt8" ) ; <NEW_LINE> if ( args . Length ( ) < 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> DataView * imp = V8DataView::toNative ( args . Holder ( ) ) ; <NEW_LINE> ExceptionCode ec = 0 ;
return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1161 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy76: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych == 'N' ) goto yy73 ;
NS_DEFINE_CLASSINFO_DATA ( Window , nsWindowSH , <NEW_LINE> DEFAULT_SCRIPTABLE_FLAGS | <NEW_LINE> WINDOW_SCRIPTABLE_FLAGS ) <NEW_LINE> NS_DEFINE_CLASSINFO_DATA ( Location , nsLocationSH , <NEW_LINE> <START_VULN> DOM_DEFAULT_SCRIPTABLE_FLAGS ) <NEW_LINE> <END_VULN> NS_DEFINE_CLASSINFO_DATA ( Navigator , nsNavigatorSH , <NEW_LINE> DOM_DEFAULT_SCRIPTABLE_FLAGS | <NEW_LINE> nsIXPCScriptable::WANT_PRECREATE ) <NEW_LINE> NS_DEFINE_CLASSINFO_DATA ( Plugin , nsPluginSH , <NEW_LINE> ARRAY_SCRIPTABLE_FLAGS ) <NEW_LINE> NS_DEFINE_CLASSINFO_DATA ( PluginArray , nsPluginArraySH , <NEW_LINE> ARRAY_SCRIPTABLE_FLAGS )
result += prot . readListEnd ( ) ; <NEW_LINE> return result ; <NEW_LINE> } <NEW_LINE> <START_VULN> default: <NEW_LINE>return 0 ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
<START_VULN> class SharedMemory { <NEW_LINE> <END_VULN> public: <NEW_LINE> SharedMemory ( ) ;
} <NEW_LINE> return ; <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , "\n\t\t packet exceeded snapshot" ) ) ; <NEW_LINE> <END_VULN> }
c = CUR_CHAR ( l ) ; <NEW_LINE> <START_VULN> while ( ( NXT ( 0 ) != limit ) && <NEW_LINE> ( IS_CHAR ( c ) ) && ( c != ' < ' ) ) { <NEW_LINE> <END_VULN> if ( c == 0 ) break ; <NEW_LINE> if ( c == ' & ' ) { <NEW_LINE> in_space = 0 ;
aHighestFrame = nsnull ; <NEW_LINE> if ( nsLayoutAtoms::tableFrame == aPseudoFrames . mLowestType ) { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>if ( nsLayoutAtoms::tableColGroupFrame == aHighestType ) { <NEW_LINE>if ( aPseudoFrames . mColGroup . mFrame ) { <NEW_LINE>rv = ProcessPseudoFrame ( aPresContext , aPseudoFrames . mColGroup , aHighestFrame ) ; <NEW_LINE> } <NEW_LINE>return rv ; <NEW_LINE> <END_VULN> } <NEW_LINE> rv = ProcessPseudoTableFrame ( aPresContext , aPseudoFrames , aHighestFrame ) ; <NEW_LINE> if ( nsLayoutAtoms::tableOuterFrame == aHighestType ) return rv ;
mTrans -> mConnection -> SetSecurityCallbacks ( mCallbacks ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> private: <NEW_LINE> nsRefPtr < nsHttpTransaction > mTrans ; <NEW_LINE> nsCOMPtr < nsIInterfaceRequestor > mCallbacks ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> Mutex mCallbacksLock ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIInterfaceRequestor > mCallbacks ; <NEW_LINE> nsCOMPtr < nsITransportEventSink > mTransportSink ; <NEW_LINE> nsCOMPtr < nsIEventTarget > mConsumerTarget ; <NEW_LINE> nsCOMPtr < nsISupports > mSecurityInfo ; <NEW_LINE> nsCOMPtr < nsIAsyncInputStream > mPipeIn ; <NEW_LINE> nsCOMPtr < nsIAsyncOutputStream > mPipeOut ; <NEW_LINE> nsCOMPtr < nsILoadGroupConnectionInfo > mLoadGroupCI ;
const struct rule_actions * actions = rule_get_actions ( rule ) ; <NEW_LINE> <START_VULN> ovs_assert ( rule -> state == RULE_INITIALIZED ) ; <NEW_LINE> <END_VULN> if ( rule -> hard_timeout || rule -> idle_timeout ) { <NEW_LINE> ovs_list_insert ( & ofproto -> expirable , & rule -> expirable ) ;
if ( SerializeInt ( writer_header_ , kEbmlUnknownValue , 8 ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> payload_pos_ = writer_header_ -> Position ( ) ; <NEW_LINE> <END_VULN> if ( mode_ == kFile && writer_header_ -> Seekable ( ) ) {
<START_VULN> #line 496 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> { <NEW_LINE> YYCTYPE yych ; <NEW_LINE> static const unsigned char yybm [ ] = {
PNG_EXPORT ( 73 , void , png_set_compression_method , ( png_structrp png_ptr , <NEW_LINE> int method ) ) ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) <NEW_LINE> { <NEW_LINE> <START_VULN> #ifndef _MSC_VER <NEW_LINE>char buf [ EXT2_BLOCK_SIZE ( data ) ] ; <NEW_LINE>#else <NEW_LINE>char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; <NEW_LINE>#endif <NEW_LINE> <END_VULN> struct grub_ext4_extent_header * leaf ; <NEW_LINE> struct grub_ext4_extent * ext ; <NEW_LINE> int i ;
src_y = src_ybc -> y_buffer + yoffset ; <NEW_LINE> dst_y = dst_ybc -> y_buffer + yoffset ; <NEW_LINE> <START_VULN> vpx_memcpy ( dst_y , src_y , ystride * linestocopy ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static int calc_partial_ssl_err ( YV12_BUFFER_CONFIG * source ,
if ( APR_STATUS_IS_ENOSPC ( rv ) ) { <NEW_LINE> r -> status = HTTP_REQUEST_URI_TOO_LARGE ; <NEW_LINE> <START_VULN> r -> proto_num = HTTP_VERSION ( 1 , 0 ) ; <NEW_LINE>r -> protocol = apr_pstrdup ( r -> pool , "HTTP / 1 . 0" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> else if ( APR_STATUS_IS_TIMEUP ( rv ) ) { <NEW_LINE> r -> status = HTTP_REQUEST_TIME_OUT ; <NEW_LINE> } <NEW_LINE> else if ( APR_STATUS_IS_EINVAL ( rv ) ) { <NEW_LINE> r -> status = HTTP_BAD_REQUEST ; <NEW_LINE> } <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> } while ( ( len <= 0 ) && ( ++ num_blank_lines < max_blank_lines ) ) ;
perf_fetch_caller_regs ( & hot_regs ) ; <NEW_LINE> regs = & hot_regs ; <NEW_LINE> } <NEW_LINE> <START_VULN> __perf_sw_event ( event_id , nr , nmi , regs , addr ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
txNodeSetContext * evalContext = new txNodeSetContext ( aNodes , aEs ) ; <NEW_LINE> NS_ENSURE_TRUE ( evalContext , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> rv = aEs -> pushEvalContext ( evalContext ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> PRUint32 len = static_cast < PRUint32 > ( aNodes -> size ( ) ) ; <NEW_LINE> <START_VULN> void * mem = PR_Malloc ( len * ( sizeof ( PRUint32 ) + mNKeys * sizeof ( TxObject * ) ) ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( mem , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> PRUint32 * indexes = static_cast < PRUint32 * > ( mem ) ; <NEW_LINE> TxObject ** sortValues = reinterpret_cast < TxObject ** > ( indexes + len ) ; <NEW_LINE> PRUint32 i ; <NEW_LINE> for ( i = 0 ; i < len ; ++ i ) {
qsort ( f , numf , sizeof ( struct mschmd_file * ) , & sortfunc ) ; <NEW_LINE> for ( i = 0 ; i < numf ; i ++ ) { <NEW_LINE> <START_VULN> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <NEW_LINE> <END_VULN> printf ( "Extracting % s\n" , outname ) ; <NEW_LINE> ensure_filepath ( outname ) ; <NEW_LINE> if ( chmd -> extract ( chmd , f [ i ] , outname ) ) {
int i ; <NEW_LINE> for ( i = 0 ; i < svc -> number_spatial_layers ; ++ i ) { <NEW_LINE> <START_VULN> struct twopass_rc * const twopass = & svc -> layer_context [ i ] . twopass ; <NEW_LINE> <END_VULN> svc -> spatial_layer_id = i ; <NEW_LINE> vp9_init_second_pass ( cpi ) ;
InlineBox * RenderInline::culledInlineLastLineBox ( ) const <NEW_LINE> { <NEW_LINE> for ( RenderObject * curr = lastChild ( ) ; curr ; curr = curr -> previousSibling ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> continue ;
cpi -> twopass . frames_to_key = 1 ; <NEW_LINE> <START_VULN> vpx_memcpy ( & first_frame , this_frame , sizeof ( * this_frame ) ) ; <NEW_LINE> <END_VULN> cpi -> twopass . kf_group_bits = 0 ; <NEW_LINE> cpi -> twopass . kf_group_error_left = 0 ;
update_layer_contexts ( cpi ) ; <NEW_LINE> <START_VULN> layer = cpi -> oxcf . layer_id [ <NEW_LINE>cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ; <NEW_LINE> <END_VULN> restore_layer_context ( cpi , layer ) ; <NEW_LINE> vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; <NEW_LINE> }
nsIFrame * kidFrame = mFrames . FirstChild ( ) ; <NEW_LINE> nsHTMLReflowMetrics kidDesiredSize ; <NEW_LINE> nsSize availableSpace ( aReflowState . availableWidth , <NEW_LINE> aReflowState . availableHeight ) ; <NEW_LINE> nsHTMLReflowState kidReflowState ( aPresContext , aReflowState , <NEW_LINE> kidFrame , availableSpace ) ; <NEW_LINE> <START_VULN> kidReflowState . SetComputedHeight ( aReflowState . availableHeight ) ; <NEW_LINE> <END_VULN> rv = ReflowChild ( kidFrame , aPresContext , kidDesiredSize , kidReflowState , <NEW_LINE> 0 , 0 , 0 , aStatus ) ; <NEW_LINE> kidHeight = kidDesiredSize . height ; <NEW_LINE> FinishReflowChild ( kidFrame , aPresContext , nsnull , kidDesiredSize , 0 , 0 , 0 ) ; <NEW_LINE> } else { <NEW_LINE> kidHeight = mFrames . FirstChild ( ) -> GetSize ( ) . height ; <NEW_LINE> }
#endif <NEW_LINE> if ( JS_UNLIKELY ( cx -> compartment ( ) -> debugMode ( ) ) ) <NEW_LINE> interpReturnOK = ScriptDebugEpilogue ( cx , REGS . fp ( ) , interpReturnOK ) ; <NEW_LINE> if ( ! REGS . fp ( ) -> isYielding ( ) ) <NEW_LINE> REGS . fp ( ) -> epilogue ( cx ) ; <NEW_LINE> else <NEW_LINE> <START_VULN> probes::ExitScript ( cx , script , script -> function ( ) , REGS . fp ( ) ) ; <NEW_LINE> <END_VULN> #if defined ( JS_ION ) <NEW_LINE> jit_return_pop_frame: <NEW_LINE> #endif <NEW_LINE> activation . popInlineFrame ( REGS . fp ( ) ) ; <NEW_LINE> SET_SCRIPT ( REGS . fp ( ) -> script ( ) ) ;
chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; <NEW_LINE> <START_VULN> if ( numChannels < chansSpecified || numChannels < 1 ) { <NEW_LINE> <END_VULN> error_line ( " % s is not a valid . DFF file ! " , infilename ) ; <NEW_LINE> free ( prop_chunk ) ; <NEW_LINE> return WAVPACK_SOFT_ERROR ;
DCHECK ( ! thread_state -> Heap ( ) . GetStackFrameDepth ( ) . IsEnabled ( ) ) ; <NEW_LINE> <START_VULN> ThreadHeap::GcInfo ( header -> GcInfoIndex ( ) ) <NEW_LINE> <END_VULN> -> trace_ ( thread_state -> CurrentVisitor ( ) , value ) ; <NEW_LINE> #endif <NEW_LINE> }
aValue , <NEW_LINE> PR_TRUE ) ; <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> mValue = aValue ; <NEW_LINE> if ( mChild ) { <NEW_LINE> if ( mValue . IsEmpty ( ) ) { <NEW_LINE> <START_VULN> doRemoveChild ( ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> mChild -> SetText ( mValue , PR_FALSE ) ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> EnsureChildState ( ) ; <NEW_LINE> } <NEW_LINE> }
<START_VULN> PHP_FUNCTION ( locale_get_display_language ) <NEW_LINE> <END_VULN> { <NEW_LINE> get_icu_disp_value_src_php ( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; <NEW_LINE> }
<START_VULN> if ( png_ptr -> transformations & PNG_RGB_TO_GRAY ) <NEW_LINE> <END_VULN> png_colorspace_set_rgb_coefficients ( png_ptr ) ; <NEW_LINE> #endif
return ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int isofs_read_inode ( struct inode * ) ; <NEW_LINE> <END_VULN> static int isofs_statfs ( struct dentry * , struct kstatfs * ) ; <NEW_LINE> static struct kmem_cache * isofs_inode_cachep ;
png_ptr -> current_buffer_size - = save_size ; <NEW_LINE> png_ptr -> current_buffer_ptr += save_size ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! png_ptr -> idat_size ) <NEW_LINE> { <NEW_LINE>if ( png_ptr -> buffer_size < 4 ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE> <END_VULN> png_crc_finish ( png_ptr , 0 ) ; <NEW_LINE> png_ptr -> mode &= ~ PNG_HAVE_CHUNK_HEADER ; <NEW_LINE> png_ptr -> mode |= PNG_AFTER_IDAT ;
clearClipRects ( ) ; <NEW_LINE> <START_VULN> if ( ! renderer ( ) -> isPositioned ( ) && renderer ( ) -> parent ( ) ) { <NEW_LINE> <END_VULN> RenderObject * curr = renderer ( ) -> parent ( ) ;
if ( hp -> conn && hp -> conn -> sock ) { <NEW_LINE> obj = ejsCreateEmptyPot ( ejs ) ; <NEW_LINE> for ( key = stok ( mprGetSocketState ( hp -> conn -> sock ) , " , " , & next ) ; key ; key = stok ( NULL , " , " , & next ) ) { <NEW_LINE> <START_VULN> stok ( key , " = " , & value ) ; <NEW_LINE> <END_VULN> ejsSetPropertyByName ( ejs , obj , EN ( key ) , ejsCreateStringFromAsc ( ejs , value ) ) ; <NEW_LINE> } <NEW_LINE> return obj ;
switch ( crev ) { <NEW_LINE> case 1: <NEW_LINE> tv_info = ( ATOM_ANALOG_TV_INFO * ) ( mode_info -> atom_context -> bios + data_offset ) ; <NEW_LINE> <START_VULN> if ( index > MAX_SUPPORTED_TV_TIMING ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> mode -> crtc_htotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Total ) ;
#ifndef WOFF_H_ <NEW_LINE> #define WOFF_H_ <NEW_LINE> #ifdef _MSC_VER <NEW_LINE> <START_VULN> typedef char int8_t ; <NEW_LINE> <END_VULN> typedef short int16_t ; <NEW_LINE> typedef int int32_t ; <NEW_LINE> typedef unsigned char uint8_t ; <NEW_LINE> typedef unsigned short uint16_t ; <NEW_LINE> typedef unsigned int uint32_t ; <NEW_LINE> typedef unsigned __int64 uint64_t ; <NEW_LINE> #else <NEW_LINE> #include < inttypes . h >
CuePoint * const cue = cue_entries_ [ i ] ; <NEW_LINE> delete cue ; <NEW_LINE> } <NEW_LINE> <START_VULN> delete [ ] cue_entries_ ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
if ( nodeToInsertBefore && nodeToInsertBefore -> GetParent ( ) != this ) { <NEW_LINE> aError . Throw ( NS_ERROR_DOM_HIERARCHY_REQUEST_ERR ) ; <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> for ( uint32_t i = 0 ; i < count ; ++ i ) { <NEW_LINE> <START_VULN> if ( fragChildren . ref ( ) . ElementAt ( i ) -> GetParent ( ) ) { <NEW_LINE> <END_VULN> aError . Throw ( NS_ERROR_DOM_HIERARCHY_REQUEST_ERR ) ; <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> }
const long long idpos = pos ; <NEW_LINE> <START_VULN> const long long id = ReadUInt ( m_pReader , idpos , len ) ; <NEW_LINE>assert ( id > 0 ) ; <NEW_LINE> <END_VULN> pos += len ;
void HTMLElement::setInnerHTML ( const String & html , ExceptionCode & ec ) <NEW_LINE> { <NEW_LINE> <START_VULN> RefPtr < DocumentFragment > fragment = createFragmentFromSource ( html , this , ec ) ; <NEW_LINE>if ( fragment ) <NEW_LINE> <END_VULN> replaceChildrenWithFragment ( this , fragment . release ( ) , ec ) ; <NEW_LINE> }
++ encryption_count ; <NEW_LINE> pos += size ; <NEW_LINE> <START_VULN> assert ( pos <= stop ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( compression_count <= 0 && encryption_count <= 0 )
DISALLOW_COPY_AND_ASSIGN ( InProgressRequest ) ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> WebRequestProxyingURLLoaderFactory ( void * browser_context , InfoMap * info_map ) ; <NEW_LINE> <END_VULN> void StartProxying ( <NEW_LINE> int render_process_id ,
rv = static_cast < PresShell * > ( shell . get ( ) ) -> <NEW_LINE> HandleRetargetedEvent ( aEvent , aEventStatus , eventTarget ) ; <NEW_LINE> } <NEW_LINE> return rv ; <NEW_LINE> } else { <NEW_LINE> mCurrentEventContent = eventTarget ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! mCurrentEventContent || ! GetCurrentEventFrame ( ) || <NEW_LINE> <END_VULN> InZombieDocument ( mCurrentEventContent ) ) { <NEW_LINE> rv = RetargetEventToParent ( aEvent , aEventStatus ) ; <NEW_LINE> PopCurrentEventInfo ( ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> mCurrentEventFrame = frame ; <NEW_LINE> }
for ( j = 0 ; j < source -> y_width ; j += 16 ) <NEW_LINE> { <NEW_LINE> unsigned int sse ; <NEW_LINE> <START_VULN> Total += vp8_mse16x16 ( src + j , source -> y_stride , dst + j , dest -> y_stride , & sse ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> src += 16 * source -> y_stride ;
} <NEW_LINE> href . Append ( data ) ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIURI > uri ; <NEW_LINE> result = NS_NewURI ( getter_AddRefs ( uri ) , href , <NEW_LINE> flatDocCharset . get ( ) , baseURI ) ; <NEW_LINE> if ( NS_FAILED ( result ) ) return result ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( handler ) { <NEW_LINE>handler -> OnLinkClick ( mContent , uri , nsnull ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> return result ; <NEW_LINE> } <NEW_LINE> void nsIsIndexFrame::GetSubmitCharset ( nsCString & oCharset ) <NEW_LINE> { <NEW_LINE> oCharset . AssignLiteral ( "UTF - 8" ) ;
nsFocusManager * fm = nsFocusManager::GetFocusManager ( ) ; <NEW_LINE> const nsIContent * content = aFrame -> GetContent ( ) ; <NEW_LINE> if ( fm && content ) { <NEW_LINE> mContentFocused = ( content == fm -> GetFocusedContent ( ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( mContent && mContent -> OwnerDoc ( ) && mContent -> OwnerDoc ( ) -> GetWindow ( ) ) { <NEW_LINE>nsCOMPtr < EventTarget > windowRoot = mContent -> OwnerDoc ( ) -> GetWindow ( ) -> GetTopWindowRoot ( ) ; <NEW_LINE> <END_VULN> if ( windowRoot ) { <NEW_LINE> windowRoot -> AddEventListener ( NS_LITERAL_STRING ( "activate" ) , <NEW_LINE> this , false , false ) ; <NEW_LINE> windowRoot -> AddEventListener ( NS_LITERAL_STRING ( "deactivate" ) , <NEW_LINE> this , false , false ) ; <NEW_LINE> windowRoot -> AddEventListener ( NS_LITERAL_STRING ( "MozPerformDelayedBlur" ) , <NEW_LINE> this , false , false ) ; <NEW_LINE> }
for a value . Note: all values are stored as strings . <NEW_LINE> @return JSON object <NEW_LINE> @ingroup MprJson <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC MprJson * mprCreateJson ( int type ) ;
return SC_ERROR_INVALID_ARGUMENTS ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( sec_attr == NULL ) { <NEW_LINE> <END_VULN> if ( file -> sec_attr != NULL ) <NEW_LINE> free ( file -> sec_attr ) ; <NEW_LINE> file -> sec_attr = NULL ;
return NULL ; <NEW_LINE> if ( ! JS_DefineProperty ( cx , glob , "customNative" , UndefinedValue ( ) , <NEW_LINE> <START_VULN> ( JSPropertyOp ) its_get_customNative , <NEW_LINE> ( JSStrictPropertyOp ) its_set_customNative , <NEW_LINE> <END_VULN> JSPROP_SHARED | JSPROP_NATIVE_ACCESSORS ) ) <NEW_LINE> { <NEW_LINE> return NULL ;
protected: <NEW_LINE> nsresult MakeFileInputStream ( nsIFile * file , nsCOMPtr < nsIInputStream > & stream , <NEW_LINE> nsCString & contentType ) ; <NEW_LINE> <START_VULN> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** result ) ; <NEW_LINE> <END_VULN> private: <NEW_LINE> nsCOMPtr < nsIInputStream > mUploadStream ; <NEW_LINE> PRInt64 mUploadLength ; <NEW_LINE> } ; <NEW_LINE> #endif
} <NEW_LINE> } <NEW_LINE> using namespace android ; <NEW_LINE> OmxDecoder::OmxDecoder ( MediaResource * aResource , <NEW_LINE> AbstractMediaDecoder * aDecoder ) : <NEW_LINE> mResource ( aResource ) , <NEW_LINE> <START_VULN> mDecoder ( aDecoder ) , <NEW_LINE> <END_VULN> mVideoWidth ( 0 ) , <NEW_LINE> mVideoHeight ( 0 ) , <NEW_LINE> mVideoColorFormat ( 0 ) , <NEW_LINE> mVideoStride ( 0 ) , <NEW_LINE> mVideoSliceHeight ( 0 ) , <NEW_LINE> mVideoRotation ( 0 ) , <NEW_LINE> mAudioChannels ( - 1 ) , <NEW_LINE> mAudioSampleRate ( - 1 ) ,
#define UserMediaRequest_h <NEW_LINE> #include "core / dom / ActiveDOMObject . h" <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "modules / mediastream / NavigatorUserMediaErrorCallback . h" <NEW_LINE> #include "modules / mediastream / NavigatorUserMediaSuccessCallback . h" <NEW_LINE> #include "wtf / PassRefPtr . h" <NEW_LINE> #include "wtf / RefCounted . h" <NEW_LINE> #include "wtf / text / WTFString . h"
} zend_end_try ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> obj = & EG ( objects_store ) . object_buckets [ handle ] . bucket . obj ;
bool <NEW_LINE> WebAudioDecodeJob::AllocateBuffer ( ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( ! mOutput ) ; <NEW_LINE> MOZ_ASSERT ( NS_IsMainThread ( ) ) ; <NEW_LINE> <START_VULN> JSContext * cx = GetJSContext ( ) ; <NEW_LINE> <END_VULN> if ( ! cx ) { <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> mOutput = new AudioBuffer ( mContext , mResampledFrames , mContext -> SampleRate ( ) ) ; <NEW_LINE> if ( ! mOutput -> InitializeBuffers ( mChannels , cx ) ) { <NEW_LINE> return false ;
{ <NEW_LINE> int ret = 0 ; <NEW_LINE> struct hns_roce_ucontext * context ; <NEW_LINE> <START_VULN> struct hns_roce_ib_alloc_ucontext_resp resp ; <NEW_LINE> <END_VULN> struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ; <NEW_LINE> resp . qp_tab_size = hr_dev -> caps . num_qps ;
static int crypto_report_one ( struct crypto_alg * alg , <NEW_LINE> struct crypto_user_alg * ualg , struct sk_buff * skb ) <NEW_LINE> { <NEW_LINE> <START_VULN> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <NEW_LINE>memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <NEW_LINE>sizeof ( ualg -> cru_driver_name ) ) ; <NEW_LINE>memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <NEW_LINE>CRYPTO_MAX_ALG_NAME ) ; <NEW_LINE><NEW_LINE> <END_VULN> ualg -> cru_flags = alg -> cra_flags ; <NEW_LINE> ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ;
int i ; <NEW_LINE> BEST_SEG_INFO bsi ; <NEW_LINE> <START_VULN> vpx_memset ( & bsi , 0 , sizeof ( bsi ) ) ; <NEW_LINE> <END_VULN> bsi . segment_rd = best_rd ; <NEW_LINE> bsi . ref_mv = best_ref_mv ;
return true ; <NEW_LINE> case MediaResourceSpecific: <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> NS_IMPL_CYCLE_COLLECTION_3 ( TextTrackManager , mTextTracks , <NEW_LINE> <END_VULN> mPendingTextTracks , mNewCues ) <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE ( TextTrackManager , AddRef ) <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE ( TextTrackManager , Release ) <NEW_LINE> StaticRefPtr < nsIWebVTTParserWrapper > TextTrackManager::sParserWrapper ; <NEW_LINE> TextTrackManager::TextTrackManager ( HTMLMediaElement * aMediaElement ) <NEW_LINE> : mMediaElement ( aMediaElement )
if ( flags & ( MSG_OOB ) ) <NEW_LINE> return - EOPNOTSUPP ; <NEW_LINE> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; <NEW_LINE> if ( ! skb ) { <NEW_LINE> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) <NEW_LINE> return 0 ; <NEW_LINE> return err ; <NEW_LINE> } <NEW_LINE> <START_VULN> msg -> msg_namelen = 0 ; <NEW_LINE><NEW_LINE> <END_VULN> copied = skb -> len ; <NEW_LINE> if ( len < copied ) { <NEW_LINE> msg -> msg_flags |= MSG_TRUNC ;
char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ; <NEW_LINE> * new_path = '\0' ; <NEW_LINE> <START_VULN> if ( strlen ( location ) < 8 || ( strncasecmp ( location , "http: <NEW_LINE>strncasecmp ( location , "https: <NEW_LINE>strncasecmp ( location , "ftp: <NEW_LINE>strncasecmp ( location , "ftps: <NEW_LINE> <END_VULN> { <NEW_LINE> if ( * location != ' / ' ) { <NEW_LINE> if ( * ( location + 1 ) != '\0' && resource -> path ) {
Wrapper::Action action = ( flags & JSRESOLVE_ASSIGNING ) ? Wrapper::SET : Wrapper::GET ; <NEW_LINE> desc -> obj = NULL ; <NEW_LINE> if ( ! this -> enter ( cx , wrapper , id , action , & status ) ) <NEW_LINE> return status ; <NEW_LINE> typename Traits::ResolvingIdImpl resolving ( wrapper , id ) ; <NEW_LINE> <START_VULN> if ( XrayUtils::IsTransparent ( cx , wrapper ) ) { <NEW_LINE> <END_VULN> JSObject * obj = Traits::getTargetObject ( wrapper ) ; <NEW_LINE> { <NEW_LINE> JSAutoCompartment ac ( cx , obj ) ; <NEW_LINE> if ( ! JS_GetPropertyDescriptorById ( cx , obj , id , flags , desc ) ) <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> if ( desc -> obj )
break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> return 0 ; <NEW_LINE> <END_VULN> case I_EOL: <NEW_LINE> if ( * sp == 0 ) { <NEW_LINE> pc = pc + 1 ;
return - 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( mount ( console -> name , path , "none" , MS_BIND , 0 ) ) { <NEW_LINE> <END_VULN> ERROR ( "failed to mount ' % s' on ' % s'" , console -> name , path ) ; <NEW_LINE> return - 1 ; <NEW_LINE> }
magick_info = GetMagickInfo ( write_info -> magick , exception ) ; <NEW_LINE> if ( ( magick_info == ( const MagickInfo * ) NULL ) || <NEW_LINE> ( GetMagickMimeType ( magick_info ) == ( const char * ) NULL ) ) <NEW_LINE> <START_VULN> ThrowWriterException ( CorruptImageError , "ImageTypeNotSupported" ) ; <NEW_LINE> <END_VULN> ( void ) CopyMagickString ( image -> filename , write_info -> filename , MaxTextExtent ) ; <NEW_LINE> blob_length = 2048 ; <NEW_LINE> write_image = CloneImage ( image , 0 , 0 , MagickTrue , exception ) ;
JSBool <NEW_LINE> nsJSUtils::GetCallingLocation ( JSContext * aContext , const char * * aFilename , <NEW_LINE> <START_VULN> PRUint32 * aLineno ) <NEW_LINE> <END_VULN> { <NEW_LINE> JSStackFrame * frame = nsnull ;
{ <NEW_LINE> if ( map ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memcpy ( cpi -> active_map , map , rows * cols ) ; <NEW_LINE> <END_VULN> cpi -> active_map_enabled = 1 ; <NEW_LINE> } <NEW_LINE> else
nsIPresShell::SetCapturingContent ( nsnull , 0 ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> if ( nsEventStatus_eConsumeNoDefault != * aStatus ) { <NEW_LINE> nsCOMPtr < nsIContent > newFocus ; <NEW_LINE> <START_VULN> nsIContent * activeContent = nsnull ; <NEW_LINE> <END_VULN> PRBool suppressBlur = PR_FALSE ; <NEW_LINE> if ( mCurrentTarget ) { <NEW_LINE> mCurrentTarget -> GetContentForEvent ( mPresContext , aEvent , getter_AddRefs ( newFocus ) ) ; <NEW_LINE> const nsStyleUserInterface * ui = mCurrentTarget -> GetStyleUserInterface ( ) ; <NEW_LINE> suppressBlur = ( ui -> mUserFocus == NS_STYLE_USER_FOCUS_IGNORE ) ; <NEW_LINE> activeContent = mCurrentTarget -> GetContent ( ) ; <NEW_LINE> }
ObserverList < DestructionObserver > destruction_observers_ ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> bool nestable_tasks_allowed_ ;
static mif_hdr_t * mif_hdr_get ( jas_stream_t * in ) <NEW_LINE> { <NEW_LINE> <START_VULN> uchar magicbuf [ MIF_MAGICLEN ] ; <NEW_LINE> <END_VULN> char buf [ 4096 ] ; <NEW_LINE> mif_hdr_t * hdr ; <NEW_LINE> bool done ;
<START_VULN> <NEW_LINE> <END_VULN> #include "prmem . h" <NEW_LINE> #include "prprf . h" <NEW_LINE> #include "nsIServiceManager . h"
jsbytecode * nextpc , * testpc ; <NEW_LINE> REOp nextop ; <NEW_LINE> RECapture * cap ; <NEW_LINE> <START_VULN> REProgState * curState ; <NEW_LINE> <END_VULN> const jschar * startcp ; <NEW_LINE> size_t parenIndex , k ; <NEW_LINE> size_t parenSoFar = 0 ;
#ifdef PNG_READ_iCCP_SUPPORTED <NEW_LINE> else if ( png_ptr -> chunk_name == png_iCCP ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_iCCP ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
jpc_streamlist_t * jpc_ppmstabtostreams ( jpc_ppxstab_t * tab ) <NEW_LINE> { <NEW_LINE> jpc_streamlist_t * streams ; <NEW_LINE> <START_VULN> uchar * dataptr ; <NEW_LINE> <END_VULN> uint_fast32_t datacnt ; <NEW_LINE> uint_fast32_t tpcnt ; <NEW_LINE> jpc_ppxstabent_t * ent ;
LOGFOCUS ( ( " SetFocus [ % p ] \n" , ( void * ) this ) ) ; <NEW_LINE> if ( ! mDrawingarea ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> <START_VULN> GtkWidget * owningWidget = <NEW_LINE>get_gtk_widget_for_gdk_window ( mDrawingarea -> inner_window ) ; <NEW_LINE> <END_VULN> if ( ! owningWidget ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> GtkWidget * toplevelWidget = gtk_widget_get_toplevel ( owningWidget ) ; <NEW_LINE> if ( gRaiseWindows && aRaise && toplevelWidget &&
JSContext * cx = xdr -> cx ; <NEW_LINE> JSScript * script = * scriptp ; <NEW_LINE> nsrcnotes = ntrynotes = natoms = nobjects = nregexps = nconsts = 0 ; <NEW_LINE> jssrcnote * notes = NULL ; <NEW_LINE> <START_VULN> XDRScriptState * state = xdr -> state ; <NEW_LINE><NEW_LINE>JS_ASSERT ( state ) ; <NEW_LINE> <END_VULN> JS_ASSERT_IF ( script , ! JSScript::isValidOffset ( script -> globalsOffset ) ) ;
pos = mWidget -> mapFromScene ( pos ) ; <NEW_LINE> pos = mWidget -> mapToParent ( pos ) ; <NEW_LINE> mWidget -> setPos ( pos ) ; <NEW_LINE> } <NEW_LINE> mBounds . x = pos . x ( ) ; <NEW_LINE> mBounds . y = pos . y ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsWindow::PlaceBehind ( nsTopLevelWidgetZPlacement aPlacement , <NEW_LINE> nsIWidget * aWidget , <NEW_LINE> bool aActivate ) <NEW_LINE> {
<START_VULN> WindowsVersion windowsVersion ( int * major = 0 , int * minor = 0 ) ; <NEW_LINE> <END_VULN> }
<START_VULN> for ( i = rows ; i < rows + 17 ; i ++ ) <NEW_LINE>s [ i * pitch ] = s [ ( rows - 1 ) * pitch ] ; <NEW_LINE> <END_VULN> for ( i = - 8 ; i <= 6 ; i ++ ) <NEW_LINE> {
int not , ji ; <NEW_LINE> for ( ITERATE_CONFIG ( route , prop , child , ji ) ) { <NEW_LINE> <START_VULN> name = mprGetJson ( child , "name" ) ; <NEW_LINE>value = mprGetJson ( child , "value" ) ; <NEW_LINE>not = smatch ( mprGetJson ( child , "equals" ) , "true" ) ? 0 : HTTP_ROUTE_NOT ; <NEW_LINE> <END_VULN> httpAddRouteParam ( route , name , value , not ) ; <NEW_LINE> } <NEW_LINE> }
{ <NEW_LINE> RenderStyle * oldStyle = style ( ) ; <NEW_LINE> s_canPropagateFloatIntoSibling = oldStyle ? ! isFloatingOrOutOfFlowPositioned ( ) && ! avoidsFloats ( ) : false ; <NEW_LINE> <START_VULN> if ( oldStyle && parent ( ) && diff == StyleDifferenceLayout && oldStyle -> position ( ) != newStyle . position ( ) <NEW_LINE> <END_VULN> && containsFloats ( ) && ! isFloating ( ) && ! isOutOfFlowPositioned ( ) && newStyle . hasOutOfFlowPosition ( ) ) <NEW_LINE> markAllDescendantsWithFloatsForLayout ( ) ;
const std::string & content , <NEW_LINE> const std::string & base_page_url , <NEW_LINE> const std::string & encoding , <NEW_LINE> <START_VULN> int now_on_tap_version ) ; <NEW_LINE> <END_VULN> ContextualSearchParams ( const ContextualSearchParams & other ) ; <NEW_LINE> ~ ContextualSearchParams ( ) ;
virtual ~ WtsConsoleSessionProcessDriver ( ) ; <NEW_LINE> <START_VULN> virtual void OnChannelConnected ( ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual bool OnMessageReceived ( const IPC::Message & message ) OVERRIDE ; <NEW_LINE> virtual void OnPermanentError ( ) OVERRIDE ;
while ( ( aImg -> mSourceData . Length ( ) > aImg -> mBytesDecoded && <NEW_LINE> bytesToDecode > 0 && <NEW_LINE> ! aImg -> IsDecodeFinished ( ) && <NEW_LINE> ! ( aDecodeType == DECODE_TYPE_UNTIL_SIZE && aImg -> mHasSize ) && <NEW_LINE> ! aImg -> mDecoder -> NeedsNewFrame ( ) ) || <NEW_LINE> ( aImg -> mDecodeRequest && aImg -> mDecodeRequest -> mAllocatedNewFrame ) ) { <NEW_LINE> chunkCount ++ ; <NEW_LINE> uint32_t chunkSize = std::min ( bytesToDecode , maxBytes ) ; <NEW_LINE> <START_VULN> nsresult rv = aImg -> DecodeSomeData ( chunkSize ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) { <NEW_LINE> aImg -> DoError ( ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> bytesToDecode - = chunkSize ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . objMethodWithArgs" ) ; <NEW_LINE> if ( args . Length ( ) < 3 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( int , intArg , toInt32 ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , strArg , MAYBE_MISSING_PARAMETER ( args , 1 , DefaultIsUndefined ) ) ;
usb_fill_control_urb ( urb , priv -> udev , usb_sndctrlpipe ( priv -> udev , 0 ) , <NEW_LINE> ( unsigned char * ) dr , buf , len , <NEW_LINE> rtl8187_iowrite_async_cb , buf ) ; <NEW_LINE> <START_VULN> usb_submit_urb ( urb , GFP_ATOMIC ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline void rtl818x_iowrite32_async ( struct rtl8187_priv * priv ,
NS_IF_ADDREF ( * aEndContent ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsFocusManager::DetermineElementToMoveFocus ( nsPIDOMWindow * aWindow , <NEW_LINE> nsIContent * aStartContent , <NEW_LINE> <START_VULN> PRInt32 aType , <NEW_LINE> <END_VULN> nsIContent ** aNextContent ) <NEW_LINE> { <NEW_LINE> * aNextContent = nsnull ; <NEW_LINE> nsCOMPtr < nsIDocShell > docShell = aWindow -> GetDocShell ( ) ; <NEW_LINE> if ( ! docShell ) <NEW_LINE> return NS_OK ;
* <NEW_LINE> <START_VULN> void read_png ( FILE * fp , unsigned int sig_read ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_structp png_ptr ; <NEW_LINE> png_infop info_ptr ;
<START_VULN> vpx_memset ( above_ctx , partition_context_lookup [ subsize ] . above , bs ) ; <NEW_LINE>vpx_memset ( left_ctx , partition_context_lookup [ subsize ] . left , bs ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static INLINE int partition_plane_context ( const MACROBLOCKD * xd ,
! type || <NEW_LINE> ( isArray && count > maxArraySlots ) || <NEW_LINE> ( ! isArray && ! baseobj ) || <NEW_LINE> ( ! isArray && baseobj -> hasDynamicSlots ( ) ) ) { <NEW_LINE> prepareStubCall ( Uses ( 0 ) ) ; <NEW_LINE> masm . storePtr ( ImmPtr ( type ) , FrameAddress ( offsetof ( VMFrame , scratch ) ) ) ; <NEW_LINE> masm . move ( ImmPtr ( stubArg ) , Registers::ArgReg1 ) ; <NEW_LINE> INLINE_STUBCALL ( stub , REJOIN_FALLTHROUGH ) ; <NEW_LINE> <START_VULN> frame . pushSynced ( JSVAL_TYPE_OBJECT ) ; <NEW_LINE> <END_VULN> frame . extra ( frame . peek ( - 1 ) ) . initArray = ( * PC == JSOP_NEWARRAY ) ; <NEW_LINE> frame . extra ( frame . peek ( - 1 ) ) . initObject = baseobj ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> JSObject * templateObject ;
void * executableCopy ( ExecutablePool * allocator ) ; <NEW_LINE> #ifndef NDEBUG <NEW_LINE> <START_VULN> unsigned debugOffset ( ) { return m_formatter . debugOffset ( ) ; } <NEW_LINE> <END_VULN> #endif
struct TypedArrayObjectStorage : AllTypedArraysBase { <NEW_LINE> protected: <NEW_LINE> JSObject * mObj ; <NEW_LINE> <START_VULN> TypedArrayObjectStorage ( ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> TypedArrayObjectStorage ( TypedArrayObjectStorage && aOther ) <NEW_LINE> : mObj ( aOther . mObj ) <NEW_LINE> { <NEW_LINE> aOther . mObj = nullptr ; <NEW_LINE> }
case ESP_TOK_EXPR: <NEW_LINE> if ( * token == ' % ' ) { <NEW_LINE> <START_VULN> fmt = stok ( token , ": \t\r\n" , & token ) ; <NEW_LINE>if ( token == 0 ) { <NEW_LINE>token = "" ; <NEW_LINE> } <NEW_LINE> <END_VULN> token = strim ( token , " \t\r\n ; " , MPR_TRIM_BOTH ) ; <NEW_LINE> mprPutToBuf ( body , " espRender ( conn , \" % s\" , % s ) ; \n" , fmt , token ) ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIScriptGlobalObject > sgo = do_QueryInterface ( GetOwner ( ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( sgo , NS_ERROR_FAILURE ) ; <NEW_LINE> nsIScriptContext * sc = sgo -> GetContext ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( sc , NS_ERROR_FAILURE ) ; <NEW_LINE> <START_VULN> JSContext * cx = sc -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( cx , NS_ERROR_FAILURE ) ; <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> jsval jsData ; <NEW_LINE> if ( aBinary ) { <NEW_LINE> if ( mBinaryType == DC_BINARY_TYPE_BLOB ) { <NEW_LINE> rv = nsContentUtils::CreateBlobBuffer ( cx , aData , jsData ) ;
uint8_t ip6r0_nxt ; <NEW_LINE> uint8_t ip6r0_len ; <NEW_LINE> uint8_t ip6r0_type ; <NEW_LINE> <START_VULN> uint8_t ip6r0_segleft ; <NEW_LINE>uint8_t ip6r0_reserved ; <NEW_LINE>uint8_t ip6r0_slmap [ 3 ] ; <NEW_LINE> <END_VULN> struct in6_addr ip6r0_addr [ 1 ] ; <NEW_LINE> } UNALIGNED ;
goto inline_return ; <NEW_LINE> exit: <NEW_LINE> if ( JS_UNLIKELY ( cx -> compartment ( ) -> debugMode ( ) ) ) <NEW_LINE> interpReturnOK = ScriptDebugEpilogue ( cx , REGS . fp ( ) , interpReturnOK ) ; <NEW_LINE> if ( ! REGS . fp ( ) -> isYielding ( ) ) <NEW_LINE> REGS . fp ( ) -> epilogue ( cx ) ; <NEW_LINE> else <NEW_LINE> <START_VULN> probes::ExitScript ( cx , script , script -> function ( ) , REGS . fp ( ) ) ; <NEW_LINE> <END_VULN> gc::MaybeVerifyBarriers ( cx , true ) ; <NEW_LINE> #if JS_TRACE_LOGGING <NEW_LINE> TraceLogging::defaultLogger ( ) -> log ( TraceLogging::SCRIPT_STOP ) ; <NEW_LINE> #endif <NEW_LINE> #ifdef JS_ION
z = x % dz + start [ 2 ] ; <NEW_LINE> y = ( x / dz ) % dy + start [ 1 ] ; <NEW_LINE> x = ( x / dzy ) + start [ 0 ] ; <NEW_LINE> <START_VULN> if ( z < sz && y < sy && x < sx ) { <NEW_LINE>j = ( x * szy + y * sz + z ) * size + b ; <NEW_LINE> <END_VULN> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <NEW_LINE> } <NEW_LINE> }
{ <NEW_LINE> png_uint_32 height = png_get_image_height ( png_ptr , info_ptr ) ; <NEW_LINE> <START_VULN> int passes = png_set_interlace_handling ( png_ptr ) ; <NEW_LINE> <END_VULN> int pass ; <NEW_LINE> png_start_read_image ( png_ptr ) ;
nsresult Read ( nsIScriptContext * aContext , nsIObjectInputStream * aStream ) ; <NEW_LINE> nsresult Write ( nsIScriptContext * aContext , nsIObjectOutputStream * aStream ) ; <NEW_LINE> const PRUnichar * GetName ( ) const { return mName ; } <NEW_LINE> unsigned AccessorAttributes ( ) const { <NEW_LINE> return JSPROP_SHARED | JSPROP_GETTER | JSPROP_SETTER | <NEW_LINE> <START_VULN> ( mJSAttributes & ( JSPROP_ENUMERATE | JSPROP_PERMANENT ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool IsEmpty ( ) const { return mFieldTextLength == 0 ; } <NEW_LINE> protected: <NEW_LINE> nsXBLProtoImplField * mNext ; <NEW_LINE> PRUnichar * mName ; <NEW_LINE> PRUnichar * mFieldText ;
PHP_FUNCTION ( mcrypt_module_get_algo_block_size ) <NEW_LINE> { <NEW_LINE> MCRYPT_GET_MODE_DIR_ARGS ( algorithms_dir ) <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> RETURN_LONG ( mcrypt_module_get_algo_block_size ( module , dir ) ) ; <NEW_LINE> }
parent_inode , & key , <NEW_LINE> BTRFS_FT_DIR , index ) ; <NEW_LINE> <START_VULN> BUG_ON ( ret == - EEXIST ) ; <NEW_LINE> <END_VULN> if ( ret ) { <NEW_LINE> btrfs_abort_transaction ( trans , root , ret ) ; <NEW_LINE> goto fail ; <NEW_LINE> commit 9c52057c698fb96f8f07e7a4bcf4801a092bda89 <NEW_LINE> Author: Chris Mason < chris . mason@fusionio . com > <NEW_LINE> Date: Mon Dec 17 14:26:57 2012 - 0500 <NEW_LINE> Btrfs: fix hash overflow handling <NEW_LINE> The handling for directory crc hash overflows was fairly obscure , <NEW_LINE> split_leaf returns EOVERFLOW when we try to extend the item and that is <NEW_LINE> supposed to bubble up to userland . For a while it did so , but along the <NEW_LINE> way we added better handling of errors and forced the FS readonly if we <NEW_LINE> hit IO errors during the directory insertion . <NEW_LINE> Along the way , we started testing only for EEXIST and the EOVERFLOW case <NEW_LINE> was dropped . The end result is that we may force the FS readonly if we <NEW_LINE> catch a directory hash bucket overflow . <NEW_LINE> This fixes a few problem spots . First I add tests for EOVERFLOW in the <NEW_LINE> places where we can
void <NEW_LINE> nsContinuingTextFrame::Destroy ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! mPrevContinuation || <NEW_LINE> <END_VULN> mPrevContinuation -> GetStyleContext ( ) != GetStyleContext ( ) ) { <NEW_LINE> ClearTextRun ( ) ; <NEW_LINE> } <NEW_LINE> nsSplittableFrame::RemoveFromFlow ( this ) ; <NEW_LINE> nsFrame::Destroy ( ) ; <NEW_LINE> }
public: <NEW_LINE> <START_VULN> PlatformSensorAmbientLightMac ( mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> PlatformSensorProvider * provider ) ; <NEW_LINE> mojom::ReportingMode GetReportingMode ( ) override ;
exit ( 1 ) ; <NEW_LINE> case 16: <NEW_LINE> <START_VULN> value = ( unsigned int ) floor ( 65535 * pow ( value / 65535 . , conv ) + . 5 ) ; <NEW_LINE> <END_VULN> * row ++ = ( png_byte ) ( value >> 8 ) ; <NEW_LINE> * row = ( png_byte ) value ; <NEW_LINE> return ;
txStack mResultHandlerStack ; <NEW_LINE> txStack mParamStack ; <NEW_LINE> txInstruction * mNextInstruction ; <NEW_LINE> txVariableMap * mLocalVariables ; <NEW_LINE> txVariableMap mGlobalVariableValues ; <NEW_LINE> nsRefPtr < txAExprResult > mGlobalVarPlaceholderValue ; <NEW_LINE> PRInt32 mRecursionDepth ; <NEW_LINE> <START_VULN> TemplateRule * mTemplateRules ; <NEW_LINE>PRInt32 mTemplateRulesBufferSize ; <NEW_LINE>PRInt32 mTemplateRuleCount ; <NEW_LINE> <END_VULN> txIEvalContext * mEvalContext ; <NEW_LINE> txIEvalContext * mInitialEvalContext ; <NEW_LINE> txOwningExpandedNameMap < txIGlobalParameter > * mGlobalParams ; <NEW_LINE> txLoadedDocumentsHash mLoadedDocuments ; <NEW_LINE> txKeyHash mKeyHash ;
return false ; \ <NEW_LINE> const Class * clasp = obj -> getClass ( ) ; \ <NEW_LINE> return clasp == & TypedArrayObject::classes [ TypedArrayObjectTemplate < NativeType > ::ArrayTypeID ( ) ] ; \ <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Int8 , int8_t ) <NEW_LINE> IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS ( Uint8 , uint8_t )
SPL_METHOD ( DirectoryIterator , key ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
DEBUG_PRINT_ERROR ( "ERROR: dev_free_buf ( ) Failed for i / p buf" ) ; <NEW_LINE> } <NEW_LINE> if ( ! secure_session ) { <NEW_LINE> <START_VULN> munmap ( m_pInput_pmem [ index ] . buffer , m_pInput_pmem [ index ] . size ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> close ( m_pInput_pmem [ index ] . fd ) ; <NEW_LINE> #ifdef USE_ION
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "lowkeyi . h" <NEW_LINE> #include "secasn1 . h" <NEW_LINE> #include "secder . h" <NEW_LINE> #include "secoid . h" <NEW_LINE> #include "blapi . h" <NEW_LINE> #include "secitem . h" <NEW_LINE> #include "pcert . h"
<START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> if ( header -> payloadSize ( ) >= newSize ) <NEW_LINE> return true ; <NEW_LINE> size_t allocationSize = ThreadHeap::allocationSizeFromSize ( newSize ) ;
goto out ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int isofs_read_inode ( struct inode * inode ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct super_block * sb = inode -> i_sb ; <NEW_LINE> struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ;
return - 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> req . len = res ; <NEW_LINE> <END_VULN> req . socket . fd = sipsock ; <NEW_LINE> set_socket_transport ( & req . socket , SIP_TRANSPORT_UDP ) ; <NEW_LINE> req . socket . tcptls_session = NULL ;
bool canPropagateFloatIntoSibling = ! isFloatingOrOutOfFlowPositioned ( ) && ! avoidsFloats ( ) ; <NEW_LINE> <START_VULN> if ( diff == StyleDifferenceLayout && s_canPropagateFloatIntoSibling && ! canPropagateFloatIntoSibling && hasOverhangingFloats ( ) ) { <NEW_LINE> <END_VULN> RenderBlockFlow * parentBlockFlow = this ; <NEW_LINE> const FloatingObjectSet & floatingObjectSet = m_floatingObjects -> set ( ) ; <NEW_LINE> FloatingObjectSetIterator end = floatingObjectSet . end ( ) ;
autoFloatManager . CreateFloatManager ( aPresContext ) ; <NEW_LINE> ClearLineCursor ( ) ; <NEW_LINE> <START_VULN> if ( IsFrameTreeTooDeep ( aReflowState , aMetrics ) ) { <NEW_LINE>aStatus = NS_FRAME_COMPLETE ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> PRBool marginRoot = BlockIsMarginRoot ( this ) ; <NEW_LINE> nsBlockReflowState state ( aReflowState , aPresContext , this , aMetrics , <NEW_LINE> marginRoot , marginRoot , needFloatManager ) ; <NEW_LINE> #ifdef IBMBIDI
if ( ! childrenInline ( ) ) { <NEW_LINE> for ( RenderObject * child = firstChild ( ) ; child ; child = child -> nextSibling ( ) ) { <NEW_LINE> <START_VULN> if ( ( ! floatToRemove && child -> isFloatingOrPositioned ( ) ) || ! child -> isRenderBlock ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> RenderBlock * childBlock = toRenderBlock ( child ) ; <NEW_LINE> if ( ( floatToRemove ? childBlock -> containsFloat ( floatToRemove ) : childBlock -> containsFloats ( ) ) || childBlock -> shrinkToAvoidFloats ( ) )
return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> JSJavaThreadState * jsj_env = NULL ; <NEW_LINE> JSObjectHandle * handle = ( JSObjectHandle * ) obj ; <NEW_LINE> JSObject * js_obj = handle -> js_obj ; <NEW_LINE> JSContext * cx = NULL ; <NEW_LINE> jsval js_val ; <NEW_LINE> JSErrorReporter saved_state = NULL ; <NEW_LINE> jsj_env = jsj_enter_js ( jEnv , mJavaClient , NULL , & cx , NULL , & saved_state , principalsArray , numPrincipals , securitySupports ) ; <NEW_LINE> if ( ! jsj_env ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> <START_VULN> AutoPushJSContext autopush ( securitySupports , cx ) ; <NEW_LINE>if ( NS_FAILED ( autopush . ResultOfPush ( ) ) ) <NEW_LINE>goto done ; <NEW_LINE><NEW_LINE> <END_VULN> if ( ! name ) { <NEW_LINE> JS_ReportError ( cx , "illegal null member name" ) ; <NEW_LINE> goto done ; <NEW_LINE> } <NEW_LINE> if ( ! jsj_ConvertJavaObjectToJSValue ( cx , jEnv , java_obj , & js_val ) ) <NEW_LINE> goto done ; <NEW_LINE> JS_SetUCProperty ( cx , js_obj , name , length , & js_val ) ;
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> void trace_print_stats ( void ) <NEW_LINE> { <NEW_LINE> ulong count ;
<START_VULN> if ( transforms & PNG_TRANSFORM_STRIP_16 ) <NEW_LINE> <END_VULN> #ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED <NEW_LINE> png_set_strip_16 ( png_ptr ) ; <NEW_LINE> #else
if ( ! copyFromTypedArray ( cx , tarray , arg0 , offset ) ) <NEW_LINE> return false ; <NEW_LINE> } else { <NEW_LINE> uint32_t len ; <NEW_LINE> if ( ! GetLengthProperty ( cx , arg0 , & len ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( len > length ( tarray ) - offset ) { <NEW_LINE> <END_VULN> JS_ReportErrorNumber ( cx , js_GetErrorMessage , NULL , JSMSG_BAD_ARRAY_LENGTH ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> if ( ! copyFromArray ( cx , tarray , arg0 , len , offset ) ) <NEW_LINE> return false ; <NEW_LINE> }
class TranslateInfoBarBase : public TranslateInfoBarView , <NEW_LINE> <START_VULN> public InfoBar { <NEW_LINE> <END_VULN> public: <NEW_LINE> explicit TranslateInfoBarBase ( TranslateInfoBarDelegate * delegate ) ; <NEW_LINE> virtual ~ TranslateInfoBarBase ( ) ;
vma -> vm_mm = mm ; <NEW_LINE> down_write ( & mm -> mmap_sem ) ; <NEW_LINE> <START_VULN> insert_vm_struct ( mm , vma ) ; <NEW_LINE> <END_VULN> mm -> total_vm += npages ; <NEW_LINE> up_write ( & mm -> mmap_sem ) ; <NEW_LINE> return 0 ;
const uint64 total_entry_size = kSeekEntryCount * MaxEntrySize ( ) ; <NEW_LINE> const uint64 total_size = <NEW_LINE> <START_VULN> EbmlMasterElementSize ( kMkvSeekHead , <NEW_LINE>total_entry_size ) + total_entry_size ; <NEW_LINE> <END_VULN> const int64 size_left = total_size - ( writer -> Position ( ) - start_pos_ ) ; <NEW_LINE> const uint64 bytes_written = WriteVoidElement ( writer , size_left ) ;
} <NEW_LINE> ctxt = xmlRelaxNGNewValidCtxt ( schemas ) ; <NEW_LINE> <START_VULN> xmlRelaxNGSetValidErrors ( ctxt , <NEW_LINE> ( xmlRelaxNGValidityErrorFunc ) testErrorHandler , <NEW_LINE> ( xmlRelaxNGValidityWarningFunc ) testErrorHandler , <NEW_LINE>ctxt ) ; <NEW_LINE> <END_VULN> ret = xmlRelaxNGValidateDoc ( ctxt , doc ) ; <NEW_LINE> if ( ret == 0 ) { <NEW_LINE> testErrorHandler ( NULL , " % s validates\n" , filename ) ;
if ( s -> q_seq ) <NEW_LINE> for ( i = 1 ; i < s -> dim ; i ++ ) <NEW_LINE> <START_VULN> v [ i ] += v [ i - 1 ] ; <NEW_LINE> <END_VULN> } <NEW_LINE> return 0 ;
struct cpu_context_save cpu_context ; <NEW_LINE> __u32 syscall ; <NEW_LINE> __u8 used_cp [ 16 ] ; <NEW_LINE> <START_VULN> unsigned long tp_value ; <NEW_LINE> <END_VULN> #ifdef CONFIG_CRUNCH <NEW_LINE> struct crunch_state crunchstate ; <NEW_LINE> #endif
RETURN_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( str_len > INT_MAX ) { <NEW_LINE> <END_VULN> RETURN_FALSE ; <NEW_LINE> }
~ Prompt ( ) ; <NEW_LINE> void SetPermissions ( std::vector < string16 > permissions ) ; <NEW_LINE> <START_VULN> void SetInlineInstallWebstoreData ( std::string localized_user_count , <NEW_LINE> <END_VULN> double average_rating , <NEW_LINE> int rating_count ) ;
} <NEW_LINE> BufferMeta * bufferMeta = ( BufferMeta * ) ( header -> pAppPrivate ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> sp < ABuffer > data = bufferMeta -> getBuffer ( <NEW_LINE> header , false , false ) ; <NEW_LINE> bufferMeta -> setNativeHandle ( nativeHandle ) ;
apr_status_t ap_http_filter ( ap_filter_t * f , apr_bucket_brigade * b , <NEW_LINE> <START_VULN> ap_input_mode_t mode , apr_read_type_e block , apr_off_t readbytes ) <NEW_LINE> <END_VULN> { <NEW_LINE> core_server_config * conf ; <NEW_LINE> apr_bucket * e ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: channel mapping 0 implementation <NEW_LINE> <START_VULN> last mod: $ Id: mapping0 . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < stdio . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h >
else if ( ! gui_mode && url_arg ) { <NEW_LINE> char * ext ; <NEW_LINE> <START_VULN> strcpy ( the_url , url_arg ) ; <NEW_LINE> <END_VULN> ext = strrchr ( the_url , ' . ' ) ; <NEW_LINE> if ( ext && ( ! stricmp ( ext , " . m3u" ) || ! stricmp ( ext , " . pls" ) ) ) { <NEW_LINE> GF_Err e = GF_OK ;
errorPageUrl . AppendLiteral ( " & d = " ) ; <NEW_LINE> errorPageUrl . AppendASCII ( escapedDescription . get ( ) ) ; <NEW_LINE> nsCOMPtr < nsIURI > errorPageURI ; <NEW_LINE> rv = NS_NewURI ( getter_AddRefs ( errorPageURI ) , errorPageUrl ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> return InternalLoad ( errorPageURI , nullptr , mozilla::net::RP_Default , <NEW_LINE>nullptr , INTERNAL_LOAD_FLAGS_INHERIT_OWNER , nullptr , <NEW_LINE>nullptr , NullString ( ) , nullptr , nullptr , LOAD_ERROR_PAGE , <NEW_LINE>nullptr , true , NullString ( ) , this , nullptr , nullptr , <NEW_LINE>nullptr ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsDocShell::Reload ( uint32_t aReloadFlags ) <NEW_LINE> { <NEW_LINE> if ( ! IsNavigationAllowed ( ) ) { <NEW_LINE> return NS_OK ; <NEW_LINE> }
static int is_integer ( char * string ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( isdigit ( string [ 0 ] ) || string [ 0 ] == ' - ' || string [ 0 ] == ' + ' ) { <NEW_LINE>while ( * ++ string && isdigit ( * string ) ) <NEW_LINE> <END_VULN> ; <NEW_LINE> if ( ! * string ) <NEW_LINE> return 1 ;
} <NEW_LINE> } <NEW_LINE> if ( ! StoringSourceData ( ) && mHasSize ) { <NEW_LINE> { <NEW_LINE> <START_VULN> AutoSetSyncDecode syncDecode ( mDecoder ) ; <NEW_LINE>rv = WriteToDecoder ( aBuffer , aCount ) ; <NEW_LINE> <END_VULN> CONTAINER_ENSURE_SUCCESS ( rv ) ; <NEW_LINE> } <NEW_LINE> nsRefPtr < Decoder > kungFuDeathGrip = mDecoder ; <NEW_LINE> mInDecoder = true ;
} <NEW_LINE> result . append ( u'E' ) ; <NEW_LINE> int32_t _scale = upperPos + scale ; <NEW_LINE> <START_VULN> if ( _scale < 0 ) { <NEW_LINE> <END_VULN> _scale *= - 1 ; <NEW_LINE> result . append ( u' - ' ) ; <NEW_LINE> } else {
int read_xattrs_from_disk ( int fd , struct squashfs_super_block * sBlk , int flag , long long * table_start ) <NEW_LINE> { <NEW_LINE> <START_VULN> int res , bytes , i , indexes , index_bytes , ids ; <NEW_LINE> <END_VULN> long long * index , start , end ; <NEW_LINE> struct squashfs_xattr_table id_table ;
document . frame ( ) -> spellChecker ( ) . updateMarkersForWordsAffectedByEditing ( <NEW_LINE> isSpaceOrNewline ( text [ 0 ] ) ) ; <NEW_LINE> <START_VULN> insertText ( document , text , <NEW_LINE>frame -> selection ( ) . computeVisibleSelectionInDOMTreeDeprecated ( ) , <NEW_LINE>options , composition , isIncrementalInsertion ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void TypingCommand::adjustSelectionAfterIncrementalInsertion (
MAKE_STD_ZVAL ( http_header ) ; <NEW_LINE> ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ; <NEW_LINE> } <NEW_LINE> } else {
uint8_t * dataPointer ( ) const ; <NEW_LINE> <START_VULN> void neuter ( JSContext * cx ) ; <NEW_LINE> <END_VULN>
if ( seg -> update_map ) { <NEW_LINE> if ( seg -> temporal_update ) { <NEW_LINE> const int pred_flag = mbmi -> seg_id_predicted ; <NEW_LINE> <START_VULN> vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; <NEW_LINE>vp9_write ( w , pred_flag , pred_prob ) ; <NEW_LINE> <END_VULN> if ( ! pred_flag ) <NEW_LINE> write_segment_id ( w , seg , segment_id ) ; <NEW_LINE> } else {
<START_VULN> if ( id == GetRTStringByIndex ( cx , XPCJSRuntime::IDX_WRAPPED_JSOBJECT ) || <NEW_LINE>id == GetRTStringByIndex ( cx , XPCJSRuntime::IDX_TO_STRING ) ) { <NEW_LINE>return JS_TRUE ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! EnsureLegalActivity ( cx , obj ) ) {
static int CVE_2012_1183_milliwatt_generate ( struct ast_channel * chan , void * data , int len , int samples ) <NEW_LINE> { <NEW_LINE> unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; <NEW_LINE> <START_VULN> const int maxsamples = ARRAY_LEN ( buf ) ; <NEW_LINE> <END_VULN> int i , * indexp = ( int * ) data ; <NEW_LINE> struct ast_frame wf = { <NEW_LINE> . frametype = AST_FRAME_VOICE ,
return markup . toString ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> PassRefPtr < DocumentFragment > createFragmentFromSource ( const String & markup , Element * contextElement , ExceptionCode & ec ) <NEW_LINE> <END_VULN> { <NEW_LINE> Document * document = contextElement -> document ( ) ; <NEW_LINE> RefPtr < DocumentFragment > fragment = DocumentFragment::create ( document ) ;
if ( ! beforeChild && isAfterContent ( lastChild ( ) ) ) <NEW_LINE> beforeChild = lastChild ( ) ; <NEW_LINE> <START_VULN> if ( ! newChild -> isInline ( ) && ! newChild -> isFloatingOrPositioned ( ) ) { <NEW_LINE> <END_VULN>
if ( ! args ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> <START_VULN> args -> m_cx = cx ; <NEW_LINE> <END_VULN> args -> m_scope = JS_GetParent ( cx , script_obj ) ; <NEW_LINE> args -> m_jsCallback . Adopt ( jsCallback ? nsCRT::strdup ( jsCallback ) : 0 ) ; <NEW_LINE> args -> m_principals = principals ;
if ( fp >= DBL_MIN && fp <= DBL_MAX ) <NEW_LINE> { <NEW_LINE> <START_VULN> int exp_b10 ; <NEW_LINE> <END_VULN> double base ;
mType = type ; <NEW_LINE> allocateStorage ( size ) ; <NEW_LINE> <START_VULN> memcpy ( storage ( ) , data , size ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void MetaData::typed_data::getData (
int new_width = cpi -> oxcf . Width ; <NEW_LINE> int new_height = cpi -> oxcf . Height ; <NEW_LINE> <START_VULN> int projected_buffer_level = ( int ) cpi -> buffer_level ; <NEW_LINE> <END_VULN> int tmp_q ; <NEW_LINE> double projected_bits_perframe ;
return NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! ( exp -> ex_layout_types & ( 1 << layout_type ) ) ) { <NEW_LINE> <END_VULN> dprintk ( " % s: layout type % d not supported\n" , <NEW_LINE> __func__ , layout_type ) ; <NEW_LINE> return NULL ;
#ifdef _MSC_VER <NEW_LINE> <START_VULN> #pragma warning ( disable:4996 ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> namespace mkvmuxer {
if ( NS_FAILED ( CheckInnerWindowCorrectness ( ) ) ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSContext * cx = GetJSContext ( ) ; <NEW_LINE> <END_VULN> if ( ! cx ) { <NEW_LINE> NS_WARNING ( "Failed to get safe JSContext ! " ) ; <NEW_LINE> rv = NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ; <NEW_LINE> SetError ( rv ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> JSObject * global = GetParentObject ( ) ;
return nsnull ; <NEW_LINE> nsIFrame * yeahBaby = scrollFrame -> GetScrolledFrame ( ) ; <NEW_LINE> if ( ! yeahBaby ) <NEW_LINE> return nsnull ; <NEW_LINE> <START_VULN> CallQueryInterface ( yeahBaby , & mListBoxBody ) ; <NEW_LINE> <END_VULN> return mListBoxBody ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsListBoxObject::Clear ( ) <NEW_LINE> { <NEW_LINE> ClearCachedValues ( ) ;
pos = png_safecat ( message , ( sizeof message ) , 0 , "profile '" ) ; <NEW_LINE> pos = png_safecat ( message , pos + 79 , pos , name ) ; <NEW_LINE> pos = png_safecat ( message , ( sizeof message ) , pos , "': " ) ; <NEW_LINE> <START_VULN> if ( is_ICC_signature ( value ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_icc_tag_name ( message + pos , ( png_uint_32 ) value ) ;
if ( PASS == conn -> m -> local_tx_start ( conn , this_func TSRMLS_CC ) ) { <NEW_LINE> ret = conn -> m -> query ( conn , ( mode ) ? "SET AUTOCOMMIT = 1":"SET AUTOCOMMIT = 0" , sizeof ( "SET AUTOCOMMIT = 1" ) - 1 TSRMLS_CC ) ; <NEW_LINE> <START_VULN> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> DBG_RETURN ( ret ) ;
nsMathMLTokenFrame::SetInitialChildList ( nsIAtom * aListName , <NEW_LINE> nsFrameList & aChildList ) <NEW_LINE> { <NEW_LINE> nsresult rv = nsMathMLContainerFrame::SetInitialChildList ( aListName , aChildList ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) <NEW_LINE> return rv ; <NEW_LINE> <START_VULN> SetQuotes ( ) ; <NEW_LINE> <END_VULN> ProcessTextData ( ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsMathMLTokenFrame::Reflow ( nsPresContext * aPresContext , <NEW_LINE> nsHTMLReflowMetrics & aDesiredSize , <NEW_LINE> const nsHTMLReflowState & aReflowState ,
struct fake_dirent * fde ; <NEW_LINE> blocksize = dir -> i_sb -> s_blocksize ; <NEW_LINE> <START_VULN> dxtrace ( printk ( KERN_DEBUG "Creating index\n" ) ) ; <NEW_LINE> <END_VULN> retval = ext4_journal_get_write_access ( handle , bh ) ; <NEW_LINE> if ( retval ) { <NEW_LINE> ext4_std_error ( dir -> i_sb , retval ) ;
#include "nsLayoutUtils . h" <NEW_LINE> #include "nsDisplayList . h" <NEW_LINE> #include "nsContentUtils . h" <NEW_LINE> #include "mozilla / LookAndFeel . h" <NEW_LINE> using namespace mozilla ; <NEW_LINE> <START_VULN> const nscoord kMaxDropDownRows = 20 ; <NEW_LINE> <END_VULN> const PRInt32 kNothingSelected = - 1 ; <NEW_LINE> nsListControlFrame * nsListControlFrame::mFocused = nsnull ; <NEW_LINE> nsString * nsListControlFrame::sIncrementalString = nsnull ; <NEW_LINE> #define INCREMENTAL_SEARCH_KEYPRESS_TIME 1000
uint8_t * buf ) { <NEW_LINE> int steps ; <NEW_LINE> if ( length == olength ) { <NEW_LINE> <START_VULN> memcpy ( output , input , sizeof ( uint8_t ) * length ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> } <NEW_LINE> steps = get_down2_steps ( length , olength ) ;
private int <NEW_LINE> dophn_exec ( struct magic_set * ms , int clazz , int swap , int fd , off_t off , <NEW_LINE> <START_VULN> int num , size_t size , off_t fsize , int * flags , int sh_num ) <NEW_LINE> <END_VULN> { <NEW_LINE> Elf32_Phdr ph32 ; <NEW_LINE> Elf64_Phdr ph64 ;
txExpandedName name ; <NEW_LINE> rv = getQNameAttr ( aAttributes , aAttrCount , nsGkAtoms::name , true , <NEW_LINE> aState , name ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsAutoPtr < txCheckParam > checkParam ( new txCheckParam ( name ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> rv = aState . pushPtr ( checkParam ) ; <NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsAutoPtr < txInstruction > instr ( checkParam . forget ( ) ) ; <NEW_LINE> rv = aState . addInstruction ( instr ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsAutoPtr < Expr > select ; <NEW_LINE> rv = getExprAttr ( aAttributes , aAttrCount , nsGkAtoms::select , false ,
OfflineLoadPage ( TabContents * tab_contents , const GURL & url , <NEW_LINE> Delegate * delegate ) ; <NEW_LINE> <START_VULN> virtual ~ OfflineLoadPage ( ) { } <NEW_LINE> <END_VULN> void EnableTest ( ) {
#if CONFIG_WEBM_IO <NEW_LINE> if ( stream -> config . write_webm ) { <NEW_LINE> <START_VULN> write_webm_file_footer ( & stream -> ebml , stream -> hash ) ; <NEW_LINE>free ( stream -> ebml . cue_list ) ; <NEW_LINE>stream -> ebml . cue_list = NULL ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif
static NS_DEFINE_CID ( kEventQueueServiceCID , NS_EVENTQUEUESERVICE_CID ) ; <NEW_LINE> void <NEW_LINE> <START_VULN> FireDOMEvent ( nsIContent * aContent , PRUint32 aMessage ) <NEW_LINE> <END_VULN> { <NEW_LINE> nsCOMPtr < nsIEventQueueService > event_service = <NEW_LINE> do_GetService ( kEventQueueServiceCID ) ;
blob . release ( ) ; <NEW_LINE> <START_VULN> return GraphicsJNI::createBitmap ( env , bitmap , buffer , getPremulBitmapCreateFlags ( isMutable ) , <NEW_LINE>NULL , NULL , density ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static jboolean Bitmap_writeToParcel ( JNIEnv * env , jobject ,
} <NEW_LINE> break ; <NEW_LINE> case rsaKey: <NEW_LINE> { <NEW_LINE> SECItem digest ; <NEW_LINE> digest . data = final ; <NEW_LINE> digest . len = part ; <NEW_LINE> if ( sig ) { <NEW_LINE> PORT_Assert ( cx -> hashAlg != SEC_OID_UNKNOWN ) ; <NEW_LINE> <START_VULN> SECOidTag hashid ; <NEW_LINE> <END_VULN> rv = recoverPKCS1DigestInfo ( cx -> hashAlg , & hashid , <NEW_LINE> & cx -> pkcs1RSADigestInfo , <NEW_LINE> & cx -> pkcs1RSADigestInfoLen , <NEW_LINE> cx -> key , <NEW_LINE> sig , cx -> wincx ) ; <NEW_LINE> PORT_Assert ( cx -> hashAlg == hashid ) ; <NEW_LINE> if ( rv != SECSuccess ) { <NEW_LINE> return SECFailure ;
NS_IMETHODIMP <NEW_LINE> nsSecurityNameSet::InitializeNameSet ( nsIScriptContext * aScriptContext ) <NEW_LINE> { <NEW_LINE> <START_VULN> JSContext * cx = aScriptContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSObject * global = JS_ObjectToInnerObject ( cx , JS_GetGlobalObject ( cx ) ) ; <NEW_LINE> JSObject * obj = global ; <NEW_LINE> JSObject * proto ;
nsCOMPtr < nsIDocument > doc ; <NEW_LINE> nsCOMPtr < nsIScriptGlobalObject > global ; <NEW_LINE> if ( node ) { <NEW_LINE> <START_VULN> global = node -> OwnerDoc ( ) -> GetScriptGlobalObject ( ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> nsCOMPtr < nsPIDOMWindow > win ( do_QueryInterface ( mTarget ) ) ; <NEW_LINE> if ( win ) { <NEW_LINE> NS_ASSERTION ( win -> IsInnerWindow ( ) , <NEW_LINE> "Event listener added to outer window ! " ) ; <NEW_LINE> nsCOMPtr < nsIDOMDocument > domdoc ; <NEW_LINE> win -> GetDocument ( getter_AddRefs ( domdoc ) ) ;
if ( color ) { <NEW_LINE> memset ( s -> frame -> data [ 0 ] + y * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; <NEW_LINE> <START_VULN> if ( half_vert ) <NEW_LINE> <END_VULN> memset ( s -> frame -> data [ 0 ] + ( y + 1 ) * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; <NEW_LINE> } <NEW_LINE> x += run_length ;
{ <NEW_LINE> png_fixed_point result ; <NEW_LINE> <START_VULN> if ( png_muldiv ( & result , a , times , divisor ) ) <NEW_LINE> <END_VULN> return result ; <NEW_LINE> png_warning ( png_ptr , "fixed point overflow ignored" ) ;
UrlIndex * url_index ( ) const { return url_index_ ; } <NEW_LINE> <START_VULN> bool has_opaque_data ( ) const { return has_opaque_data_ ; } <NEW_LINE> <END_VULN>
nsIFrame * next = frame -> GetNextInFlow ( ) ; <NEW_LINE> if ( next ) { <NEW_LINE> currentLine -> MarkDirty ( ) ; <NEW_LINE> <START_VULN> nsIFrame * parent = frame ; <NEW_LINE>nsIFrame * nextParent = next ; <NEW_LINE>while ( parent && nextParent ) { <NEW_LINE>if ( parent == nextParent || <NEW_LINE>nextParent != parent -> GetNextInFlow ( ) || <NEW_LINE> ! IsBidiSplittable ( parent ) ) { <NEW_LINE>break ; <NEW_LINE> } <NEW_LINE>parent -> SetNextContinuation ( nextParent ) ; <NEW_LINE>nextParent -> SetPrevContinuation ( parent ) ; <NEW_LINE><NEW_LINE>parent = parent -> GetParent ( ) ; <NEW_LINE>nextParent = nextParent -> GetParent ( ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> frame -> AdjustOffsetsForBidi ( contentOffset , contentOffset + fragmentLength ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> ++ lineOffset ; <NEW_LINE> }
else if ( row_info -> bit_depth == 16 ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( at_start ) <NEW_LINE> <END_VULN> sp += 2 ; <NEW_LINE> else <NEW_LINE> sp += 8 , dp += 6 ;
return priv -> page -> pageScaleFactor ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> Eina_Bool ewk_view_scale_set ( Evas_Object * ewkView , float scaleFactor , Evas_Coord centerX , Evas_Coord centerY ) <NEW_LINE> <END_VULN> { <NEW_LINE> EWK_VIEW_SD_GET_OR_RETURN ( ewkView , smartData , false ) ; <NEW_LINE> EWK_VIEW_PRIV_GET_OR_RETURN ( smartData , priv , false ) ;
{ <NEW_LINE> if ( <NEW_LINE> #ifdef PNG_MNG_FEATURES_SUPPORTED <NEW_LINE> <START_VULN> ( png_ptr -> num_palette || <NEW_LINE> ( ! ( png_ptr -> mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE ) ) ) && <NEW_LINE> <END_VULN> #endif <NEW_LINE> back -> index >= png_ptr -> num_palette ) <NEW_LINE> {
r = read_file ( p15card , ( u8 * ) "\x2F\x02" , efbin , & len , 1 ) ; <NEW_LINE> LOG_TEST_RET ( card -> ctx , r , "Skipping optional EF . C_DevAut" ) ; <NEW_LINE> <START_VULN> <NEW_LINE>ptr = realloc ( priv -> EF_C_DevAut , len ) ; <NEW_LINE>if ( ptr ) { <NEW_LINE>memcpy ( ptr , efbin , len ) ; <NEW_LINE>priv -> EF_C_DevAut = ptr ; <NEW_LINE>priv -> EF_C_DevAut_len = len ; <NEW_LINE> <END_VULN> } <NEW_LINE> ptr = efbin ;
* got_data = 0 ; <NEW_LINE> while ( ( pkt = vpx_codec_get_cx_data ( & stream -> encoder , & iter ) ) ) { <NEW_LINE> static size_t fsize = 0 ; <NEW_LINE> <START_VULN> static off_t ivf_header_pos = 0 ; <NEW_LINE> <END_VULN> switch ( pkt -> kind ) { <NEW_LINE> case VPX_CODEC_CX_FRAME_PKT:
if ( chunk -> size != 9 ) <NEW_LINE> return ( - 1 ) ; <NEW_LINE> <START_VULN> if ( ! set_location ( png_ptr , my_user_chunk_data , have_vpAg ) ) <NEW_LINE> <END_VULN> return ( 0 ) ; <NEW_LINE> my_user_chunk_data -> vpAg_width = png_get_uint_31 ( png_ptr , chunk -> data ) ;
const struct ikev2_n * p ; <NEW_LINE> struct ikev2_n n ; <NEW_LINE> const u_char * cp ; <NEW_LINE> <START_VULN> u_char showspi , showdata , showsomedata ; <NEW_LINE> <END_VULN> const char * notify_name ; <NEW_LINE> uint32_t type ;
#include "nsInputStreamChannel . h" <NEW_LINE> nsresult <NEW_LINE> <START_VULN> nsInputStreamChannel::OpenContentStream ( PRBool async , nsIInputStream ** result ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ENSURE_TRUE ( mContentStream , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE> PRInt64 len = ContentLength64 ( ) ; <NEW_LINE> if ( len < 0 ) {
jng_width = ( png_uint_32 ) mng_get_long ( p ) ; <NEW_LINE> jng_height = ( png_uint_32 ) mng_get_long ( & p [ 4 ] ) ; <NEW_LINE> if ( ( jng_width == 0 ) || ( jng_height == 0 ) ) <NEW_LINE> <START_VULN> { <NEW_LINE>DestroyJNG ( chunk , & color_image , & color_image_info , <NEW_LINE> & alpha_image , & alpha_image_info ) ; <NEW_LINE><NEW_LINE>ThrowReaderException ( CorruptImageError , <NEW_LINE>"NegativeOrZeroImageSize" ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> jng_color_type = p [ 8 ] ; <NEW_LINE> jng_image_sample_depth = p [ 9 ] ; <NEW_LINE> jng_image_compression_method = p [ 10 ] ;
else <NEW_LINE> lang_key_len = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> # else <NEW_LINE> <END_VULN> { <NEW_LINE> png_chunk_report ( png_ptr , "iTXt chunk not supported" , <NEW_LINE> PNG_CHUNK_WRITE_ERROR ) ;
bool IsIMEDoingKakuteiUndo ( ) const ; <NEW_LINE> <START_VULN> void RemoveMessageAndDispatchPluginEvent ( UINT aFirstMsg , UINT aLastMsg ) const ; <NEW_LINE> <END_VULN> bool IsKeyDownMessage ( ) const <NEW_LINE> { <NEW_LINE> return ( mMsg . message == WM_KEYDOWN || mMsg . message == WM_SYSKEYDOWN ) ; <NEW_LINE> } <NEW_LINE> bool IsFollowedByCharMessage ( ) const <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( mMsg . message == WM_KEYDOWN || mMsg . message == WM_SYSKEYDOWN ) ;
char radio_text [ MAX_RDS_RADIO_TEXT + 1 ] ; <NEW_LINE> len = control -> size - 1 ; <NEW_LINE> <START_VULN> if ( len > MAX_RDS_RADIO_TEXT ) { <NEW_LINE> <END_VULN> rval = - ERANGE ; <NEW_LINE> goto exit ; <NEW_LINE> }
for ( index = 0 ; index < payloads ; index ++ ) <NEW_LINE> { <NEW_LINE> uint32_t payloadsize = GetPayloadSize ( mp4 , index ) ; <NEW_LINE> <START_VULN> float in = 0 . 0 , out = 0 . 0 ; <NEW_LINE> <END_VULN> payload = GetPayload ( mp4 , payload , index ) ; <NEW_LINE> if ( payload == NULL ) <NEW_LINE> goto cleanup ;
JS_ASSERT ( tracecx -> bailExit ) ; <NEW_LINE> tm -> tracecx = NULL ; <NEW_LINE> tm -> prohibitFlush ++ ; <NEW_LINE> debug_only_print0 ( LC_TMTracer , "Deep bail . \n" ) ; <NEW_LINE> LeaveTree ( * tracecx -> interpState , tracecx -> bailExit ) ; <NEW_LINE> tracecx -> bailExit = NULL ; <NEW_LINE> <START_VULN> tracecx -> interpState -> builtinStatus |= JSBUILTIN_BAILED ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_REQUIRES_STACK jsval & <NEW_LINE> TraceRecorder::argval ( unsigned n ) const <NEW_LINE> { <NEW_LINE> JS_ASSERT ( n < cx -> fp -> fun -> nargs ) ; <NEW_LINE> return cx -> fp -> argv [ n ] ; <NEW_LINE> }
if ( R - offset < noise [ i ] ) noise [ i ] = R - offset ; <NEW_LINE> } <NEW_LINE> for ( ; i < n ; i ++ , x += 1 . f ) { <NEW_LINE> R = ( A + x * B ) / D ; <NEW_LINE> if ( R - offset < noise [ i ] ) noise [ i ] = R - offset ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> static float FLOOR1_fromdB_INV_LOOKUP [ 256 ] = { <NEW_LINE> <END_VULN> 0 . F , 8 . 81683e + 06F , 8 . 27882e + 06F , 7 . 77365e + 06F , <NEW_LINE> 7 . 29930e + 06F , 6 . 85389e + 06F , 6 . 43567e + 06F , 6 . 04296e + 06F , <NEW_LINE> 5 . 67422e + 06F , 5 . 32798e + 06F , 5 . 00286e + 06F , 4 . 69759e + 06F , <NEW_LINE> 4 . 41094e + 06F , 4 . 14178e + 06F , 3 . 88905e + 06F , 3 . 65174e + 06F , <NEW_LINE> 3 . 42891e + 06F , 3 . 21968e + 06F ,
offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <NEW_LINE> number_planes + plane ; <NEW_LINE> operand ++ ; <NEW_LINE> <START_VULN> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( number_colormaps != 0 ) <NEW_LINE> colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;
MOZ_ASSERT ( JSID_IS_VOID ( memberId ) != ! memberName ) ; <NEW_LINE> char * sz ; <NEW_LINE> const char * format ; <NEW_LINE> const char * name ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( XPCThrower::CheckForPendingException ( rv , cx ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> if ( ! nsXPCException::NameAndFormatForNSResult ( NS_ERROR_XPC_NATIVE_RETURNED_FAILURE , nullptr , & format ) || <NEW_LINE> ! format ) { <NEW_LINE> format = "" ; <NEW_LINE> }
#ifdef PNG_READ_hIST_SUPPORTED <NEW_LINE> else if ( chunk_name == png_hIST ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_hIST ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( mount ( dirname , cgpath , "none" , MS_BIND , 0 ) ) { <NEW_LINE> <END_VULN> SYSERROR ( "Failed to bind mount % s to % s" , dirname , cgpath ) ; <NEW_LINE> return false ; <NEW_LINE> }
private: <NEW_LINE> std::unique_ptr < content::ContentClient > content_client_ ; <NEW_LINE> <START_VULN> std::unique_ptr < content::ContentBrowserClient > browser_client_ ; <NEW_LINE> <END_VULN> zx::channel context_channel_ ;
} <NEW_LINE> NS_IMETHODIMP nsPluginInstanceOwner::GetTagType ( nsPluginTagType * result ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_ARG_POINTER ( result ) ; <NEW_LINE> * result = nsPluginTagType_Unknown ; <NEW_LINE> <START_VULN> nsIAtom * atom = mContent -> Tag ( ) ; <NEW_LINE> <END_VULN> if ( atom == nsGkAtoms::applet ) <NEW_LINE> * result = nsPluginTagType_Applet ; <NEW_LINE> else if ( atom == nsGkAtoms::embed ) <NEW_LINE> * result = nsPluginTagType_Embed ; <NEW_LINE> else if ( atom == nsGkAtoms::object ) <NEW_LINE> * result = nsPluginTagType_Object ;
AutoValueArray autoArray ( cx , ( Value * ) elems , arrayInitialized ) ; <NEW_LINE> if ( ! AddLengthProperty ( cx , this ) ) { <NEW_LINE> this -> shape_ = oldShape ; <NEW_LINE> <START_VULN> cx -> free_ ( getElementsHeader ( ) ) ; <NEW_LINE> <END_VULN> elements = elems ; <NEW_LINE> return false ; <NEW_LINE> }
void Retry ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>void StopAutoRetry ( ) ; <NEW_LINE> <END_VULN> virtual void HandlePolicyResponse (
ctx -> limit_used += totalread ; <NEW_LINE> if ( ctx -> limit < ctx -> limit_used ) { <NEW_LINE> <START_VULN> ap_log_rerror ( <NEW_LINE>APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01591 ) "Read content - length of % " APR_OFF_T_FMT " is larger than the configured limit" <NEW_LINE>" of % " APR_OFF_T_FMT , ctx -> limit_used , ctx -> limit ) ; <NEW_LINE> <END_VULN> return APR_ENOSPC ; <NEW_LINE> } <NEW_LINE> }
if ( connect ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> unlink ( hdl -> c_path ) ; <END_VULN> <NEW_LINE> <START_VULN> close ( fd ) ; <END_VULN> <NEW_LINE> <START_VULN> return HSM_COM_CONX_ERR ; <END_VULN> <NEW_LINE> <NEW_LINE> <NEW_LINE> } <NEW_LINE> hdl -> client_fd = fd ;
#include "jsapi . h" <NEW_LINE> #include "jsfriendapi . h" <NEW_LINE> #include "mozilla / Util . h" <NEW_LINE> #include "nsDOMException . h" <NEW_LINE> #include "nsTraceRefcnt . h" <NEW_LINE> #include "WorkerInlines . h" <NEW_LINE> <START_VULN> #define PROPERTY_FLAGS \ <NEW_LINE> ( JSPROP_ENUMERATE | JSPROP_SHARED ) <NEW_LINE><NEW_LINE>#define CONSTANT_FLAGS \ <NEW_LINE>JSPROP_ENUMERATE | JSPROP_SHARED | JSPROP_PERMANENT | JSPROP_READONLY <NEW_LINE><NEW_LINE> <END_VULN> using namespace mozilla ; <NEW_LINE> USING_WORKERS_NAMESPACE
if ( result != 0 ) <NEW_LINE> return NULL ; <NEW_LINE> <START_VULN> const long long id = ReadUInt ( m_pReader , pos , len ) ; <NEW_LINE>assert ( id == 0x0F43B675 ) ; <NEW_LINE>if ( id != 0x0F43B675 ) <NEW_LINE> <END_VULN> return NULL ; <NEW_LINE> pos += len ;
static enum XML_Error doProlog ( XML_Parser parser , const ENCODING * enc , <NEW_LINE> const char * s , const char * end , int tok , <NEW_LINE> const char * next , const char ** nextPtr , <NEW_LINE> <START_VULN> XML_Bool haveMore ) ; <NEW_LINE> <END_VULN> static enum XML_Error processInternalEntity ( XML_Parser parser , ENTITY * entity , <NEW_LINE> XML_Bool betweenDecl ) ; <NEW_LINE> static enum XML_Error doContent ( XML_Parser parser , int startTagLevel ,
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> sequence < ScriptProfile > * sequenceArg ( toNativeArray < ScriptProfile > ( exec , MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
<START_VULN> #ifndef CHROME_BROWSER_CHROMEOS_BRIGHTNESS_OBSERVER_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_BRIGHTNESS_OBSERVER_H_ <NEW_LINE> <END_VULN> #pragma once <NEW_LINE> #include "base / basictypes . h"
int document_cookie ; <NEW_LINE> bool selection_only ; <NEW_LINE> bool supports_alpha_blend ; <NEW_LINE> <START_VULN> std::string preview_ui_addr ; <NEW_LINE> <END_VULN> int preview_request_id ; <NEW_LINE> bool is_first_request ; <NEW_LINE> WebKit::WebPrintScalingOption print_scaling_option ;
if ( context && php_stream_context_get_option ( context , "http" , "header" , & tmpzval ) == SUCCESS ) { <NEW_LINE> tmp = NULL ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { <NEW_LINE> HashPosition pos ; <NEW_LINE> zval ** tmpheader = NULL ;
len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; <NEW_LINE> len += fread ( & mp4 -> clockdemon , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockdemon = BYTESWAP32 ( mp4 -> clockdemon ) ; <NEW_LINE> len += fread ( & mp4 -> clockcount , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockcount = BYTESWAP32 ( mp4 -> clockcount ) ; <NEW_LINE> <START_VULN> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <NEW_LINE> <END_VULN> NESTSIZE ( qtsize ) ; <NEW_LINE> }
} else if ( mCurrentIndex > 0 ) { <NEW_LINE> <START_VULN> PRUint32 childCount = listBoxContent -> GetChildCount ( ) ; <NEW_LINE>if ( childCount > 0 ) { <NEW_LINE>nsIContent * lastChild = listBoxContent -> GetChildAt ( childCount - 1 ) ; <NEW_LINE> <END_VULN> nsIFrame * lastChildFrame = <NEW_LINE> aPresContext -> PresShell ( ) -> GetPrimaryFrameFor ( lastChild ) ; <NEW_LINE> if ( lastChildFrame ) { <NEW_LINE> mTopFrame = nsnull ; <NEW_LINE> mRowsToPrepend = 1 ; <NEW_LINE> -- mCurrentIndex ; <NEW_LINE> mYPosition = mCurrentIndex * mRowHeight ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeContentView::GetImageSrc ( PRInt32 aRow , nsITreeColumn * aCol , nsAString & _retval ) <NEW_LINE> { <NEW_LINE> _retval . Truncate ( ) ; <NEW_LINE> <START_VULN> NS_ENSURE_ARG_POINTER ( aCol ) ; <NEW_LINE> <END_VULN> NS_PRECONDITION ( aRow >= 0 && aRow < PRInt32 ( mRows . Length ( ) ) , "bad row" ) ; <NEW_LINE> if ( aRow < 0 || aRow >= PRInt32 ( mRows . Length ( ) ) ) <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> Row * row = mRows [ aRow ] ; <NEW_LINE> nsIContent * realRow = <NEW_LINE> nsTreeUtils::GetImmediateChild ( row -> mContent , nsGkAtoms::treerow ) ;
case 'J': <NEW_LINE> usage = certificateUsageObjectSigner ; <NEW_LINE> break ; <NEW_LINE> default: <NEW_LINE> PORT_SetError ( SEC_ERROR_INVALID_ARGS ) ; <NEW_LINE> return ( SECFailure ) ; <NEW_LINE> } <NEW_LINE> do { <NEW_LINE> <START_VULN> cert = CERT_FindCertByNicknameOrEmailAddr ( handle , name ) ; <NEW_LINE> <END_VULN> if ( ! cert ) { <NEW_LINE> SECU_PrintError ( progName , "could not find certificate named \" % s\"" , <NEW_LINE> name ) ; <NEW_LINE> GEN_BREAK ( SECFailure ) <NEW_LINE> } <NEW_LINE> if ( date != NULL ) { <NEW_LINE> rv = DER_AsciiToTime ( & timeBoundary , date ) ;
<START_VULN> if ( ! cpi -> dummy_packing && cpi -> sf . auto_mv_step_size ) { <NEW_LINE> <END_VULN> unsigned int maxv = MAX ( abs ( mv -> row ) , abs ( mv -> col ) ) >> 3 ; <NEW_LINE> cpi -> max_mv_magnitude = MAX ( maxv , cpi -> max_mv_magnitude ) ; <NEW_LINE> }
return user_cloud_policy_subsystem_ . get ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>void SetDeviceCredentials ( const std::string & owner_email , <NEW_LINE>const std::string & token , <NEW_LINE>TokenType token_type ) ; <NEW_LINE> <END_VULN>
AffineTransform ctm = deprecatedCalculateTransformToLayer ( layoutObject ) * SubtreeContentTransformScope::currentContentTransformation ( ) ; <NEW_LINE> ctm . scale ( layoutObject -> document ( ) . frameHost ( ) -> deviceScaleFactorDeprecated ( ) ) ; <NEW_LINE> <START_VULN> return narrowPrecisionToFloat ( sqrt ( ( pow ( ctm . xScale ( ) , 2 ) + pow ( ctm . yScale ( ) , 2 ) ) / 2 ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline bool compareCandidateDistance ( const SearchCandidate & r1 , const SearchCandidate & r2 )
if ( ! pred_exists ) { <NEW_LINE> <START_VULN> tmp_rd = rd_pick_best_mbsegmentation ( cpi , x , tile , <NEW_LINE> & mbmi -> ref_mvs [ ref_frame ] [ 0 ] , <NEW_LINE>second_ref , <NEW_LINE>best_yrd , <NEW_LINE> & rate , & rate_y , & distortion , <NEW_LINE> & skippable , & total_sse , <NEW_LINE> ( int ) this_rd_thresh , seg_mvs , <NEW_LINE>bsi , 0 , <NEW_LINE>mi_row , mi_col ) ; <NEW_LINE> <END_VULN> if ( tmp_rd == INT64_MAX ) <NEW_LINE> continue ; <NEW_LINE> } else {
ui::SequentialIDGenerator id_generator_ ; <NEW_LINE> <START_VULN> <NEW_LINE>bool scroll_styles_set_ ; <NEW_LINE> <END_VULN> DISALLOW_COPY_AND_ASSIGN ( HWNDMessageHandler ) ; <NEW_LINE> } ;
if ( s_den == 0 ) { <NEW_LINE> return 0 ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> return php_ifd_get32s ( value , motorola_intel ) / s_den ; <NEW_LINE> <END_VULN> } <NEW_LINE> case TAG_FMT_SSHORT: return php_ifd_get16u ( value , motorola_intel ) ;
#include "WebSecurityOrigin . h" <NEW_LINE> #include "core / dom / Document . h" <NEW_LINE> #include "core / platform / mediastream / MediaStreamDescriptor . h" <NEW_LINE> <START_VULN> #include "core / platform / mediastream / MediaStreamSource . h" <NEW_LINE> <END_VULN> #include "modules / mediastream / UserMediaRequest . h" <NEW_LINE> #include "platform / mediastream / MediaConstraints . h" <NEW_LINE> #include "weborigin / SecurityOrigin . h" <NEW_LINE> using namespace WebCore ;
nsLineBox * line = NewLineBox ( prevSibLine , aPrevSibling -> GetNextSibling ( ) , rem ) ; <NEW_LINE> if ( ! line ) { <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> } <NEW_LINE> lineList -> after_insert ( prevSibLine , line ) ; <NEW_LINE> <START_VULN> MarkLineDirty ( prevSibLine ) ; <NEW_LINE> <END_VULN> line -> MarkDirty ( ) ; <NEW_LINE> line -> SetInvalidateTextRuns ( true ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> else if ( ! lineList -> empty ( ) ) { <NEW_LINE> lineList -> front ( ) -> MarkDirty ( ) ;
nsMargin margin ( 0 , 0 , 0 , 0 ) ; <NEW_LINE> if ( styleContext -> GetStylePadding ( ) -> GetPadding ( margin ) ) <NEW_LINE> width += margin . LeftRight ( ) ; <NEW_LINE> width += styleContext -> GetStyleBorder ( ) -> GetActualBorder ( ) . LeftRight ( ) ; <NEW_LINE> if ( styleContext -> GetStyleMargin ( ) -> GetMargin ( margin ) ) <NEW_LINE> width += margin . LeftRight ( ) ; <NEW_LINE> <START_VULN> nsIContent * listbox = mContent -> GetBindingParent ( ) ; <NEW_LINE>NS_ENSURE_TRUE ( listbox , largestWidth ) ; <NEW_LINE>PRUint32 childCount = listbox -> GetChildCount ( ) ; <NEW_LINE><NEW_LINE>for ( PRUint32 i = 0 ; i < childCount && i < 100 ; ++ i ) { <NEW_LINE>nsIContent * child = listbox -> GetChildAt ( i ) ; <NEW_LINE> <END_VULN> if ( child -> Tag ( ) == nsGkAtoms::listitem ) { <NEW_LINE> nsIRenderingContext * rendContext = aBoxLayoutState . GetRenderingContext ( ) ; <NEW_LINE> if ( rendContext ) { <NEW_LINE> nsAutoString value ; <NEW_LINE> PRUint32 textCount = child -> GetChildCount ( ) ; <NEW_LINE> for ( PRUint32 j = 0 ; j < textCount ; ++ j ) { <NEW_LINE> nsIContent * text = child ->
publicId , <NEW_LINE> systemId , <NEW_LINE> voidString ) ; <NEW_LINE> NS_ASSERTION ( docType , "Doctype creation failed . " ) ; <NEW_LINE> nsCOMPtr < nsIContent > asContent = do_QueryInterface ( docType ) ; <NEW_LINE> return AppendToDocument ( asContent , aBuilder ) ; <NEW_LINE> } <NEW_LINE> case eTreeOpMarkAsBroken: { <NEW_LINE> <START_VULN> aBuilder -> MarkAsBroken ( ) ; <NEW_LINE> <END_VULN> return rv ; <NEW_LINE> } <NEW_LINE> case eTreeOpRunScript: { <NEW_LINE> nsIContent * node = * ( mOne . node ) ; <NEW_LINE> nsAHtml5TreeBuilderState * snapshot = mTwo . state ; <NEW_LINE> if ( snapshot ) { <NEW_LINE> aBuilder -> InitializeDocWriteParserState ( snapshot , mFour . integer ) ; <NEW_LINE> }
#include < string . h > <NEW_LINE> #include "allheaders . h" <NEW_LINE> <START_VULN> static const l_int32 L_BUF_SIZE = 512 ; <NEW_LINE> <END_VULN> static const char * version = "1 . 5" ;
{ <NEW_LINE> struct crypto_report_blkcipher rblkcipher ; <NEW_LINE> <START_VULN> snprintf ( rblkcipher . type , CRYPTO_MAX_ALG_NAME , " % s" , "ablkcipher" ) ; <NEW_LINE>snprintf ( rblkcipher . geniv , CRYPTO_MAX_ALG_NAME , " % s" , <NEW_LINE>alg -> cra_ablkcipher . geniv ? : " < default > " ) ; <NEW_LINE> <END_VULN> rblkcipher . blocksize = alg -> cra_blocksize ; <NEW_LINE> rblkcipher . min_keysize = alg -> cra_ablkcipher . min_keysize ;
trimmedName = & sp -> name [ 1 ] ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ( dp = mprLookupJsonObj ( dest , trimmedName ) ) == 0 ) { <NEW_LINE> <END_VULN> if ( pflags & MPR_JSON_COMBINE && sp -> type == MPR_JSON_OBJ ) { <NEW_LINE> dp = mprCreateJson ( sp -> type ) ;
JS_ASSERT ( obj2 == scope -> object ) ; <NEW_LINE> obj = obj2 ; <NEW_LINE> } else if ( obj2 != obj ) { <NEW_LINE> <START_VULN> JS_UNLOCK_OBJ ( cx , obj2 ) ; <NEW_LINE> <END_VULN> JS_LOCK_OBJ ( cx , obj ) ; <NEW_LINE> } <NEW_LINE> }
plen = strlen ( passwdp ) ; <NEW_LINE> <START_VULN> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <NEW_LINE> <END_VULN> return CURLE_OUT_OF_MEMORY ; <NEW_LINE> plainlen = 2 * ulen + plen + 2 ;
} <NEW_LINE> static JSBool <NEW_LINE> <START_VULN> ReportBadReturn ( JSContext * cx , JSTreeContext * tc , uintN flags , uintN errnum , <NEW_LINE> <END_VULN> uintN anonerrnum ) <NEW_LINE> { <NEW_LINE> JSAutoByteString name ;
kf_group_coded_err += this_frame -> coded_error ; <NEW_LINE> <START_VULN> vpx_memcpy ( & last_frame , this_frame , sizeof ( * this_frame ) ) ; <NEW_LINE> <END_VULN> input_stats ( cpi , this_frame ) ;
{ <NEW_LINE> vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstu + 4 , stride , <NEW_LINE> dstu + 4 , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> q += 32 ;
PRUint32 numChildren = colsContent -> GetChildCount ( ) ; <NEW_LINE> for ( PRUint32 i = 0 ; i < numChildren ; ++ i ) { <NEW_LINE> nsIContent * child = colsContent -> GetChildAt ( i ) ; <NEW_LINE> nsAutoString ordinal ; <NEW_LINE> ordinal . AppendInt ( i ) ; <NEW_LINE> child -> SetAttr ( kNameSpaceID_None , nsGkAtoms::ordinal , ordinal , PR_TRUE ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> NS_IF_RELEASE ( mFirstColumn ) ; <NEW_LINE> <END_VULN> mTree -> Invalidate ( ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsTreeColumn * <NEW_LINE> nsTreeColumns::GetPrimaryColumn ( )
png_write_chunk_data ( png_ptr , new_key , key_len + 1 ) ; <NEW_LINE> <START_VULN> if ( text_len ) <NEW_LINE> <END_VULN> png_write_chunk_data ( png_ptr , ( png_const_bytep ) text , text_len ) ; <NEW_LINE> png_write_chunk_end ( png_ptr ) ;
FormatType & operator = ( const FormatType & other ) ; <NEW_LINE> #endif <NEW_LINE> private: <NEW_LINE> friend class Clipboard ; <NEW_LINE> <START_VULN> bool Equals ( const FormatType & other ) const ; <NEW_LINE> <END_VULN>
const unsigned char * bufptr = br -> user_buffer ; <NEW_LINE> VP8_BD_VALUE value = br -> value ; <NEW_LINE> int count = br -> count ; <NEW_LINE> <START_VULN> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <NEW_LINE> <END_VULN> size_t bytes_left = br -> user_buffer_end - bufptr ; <NEW_LINE> size_t bits_left = bytes_left * CHAR_BIT ; <NEW_LINE> int x = ( int ) ( shift + CHAR_BIT - bits_left ) ;
#pragma once <NEW_LINE> #include "base / basictypes . h" <NEW_LINE> <START_VULN> #include "base / callback . h" <NEW_LINE> <END_VULN> #include "base / memory / ref_counted . h" <NEW_LINE> #include "base / memory / scoped_ptr . h" <NEW_LINE> #include "base / message_loop_proxy . h"
( void ) ResetMagickMemory ( colormap_index , ( - 1 ) , MaxColormapSize * <NEW_LINE> sizeof ( * colormap_index ) ) ; <NEW_LINE> if ( AcquireImageColormap ( image , MaxColormapSize ) == MagickFalse ) <NEW_LINE> <START_VULN> ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , <NEW_LINE>image -> filename ) ; <NEW_LINE> <END_VULN> image -> colors = 0 ; <NEW_LINE> status = MagickTrue ; <NEW_LINE> exception = ( & image -> exception ) ;
nsIFile ** aDirectory ) const ; <NEW_LINE> nsresult <NEW_LINE> EnsureOriginIsInitialized ( const nsACString & aOrigin , <NEW_LINE> bool aTrackQuota , <NEW_LINE> nsIFile ** aDirectory ) ; <NEW_LINE> void <NEW_LINE> <START_VULN> UninitializeOriginsByPattern ( const nsACString & aPattern ) ; <NEW_LINE> <END_VULN> nsIThread * <NEW_LINE> IOThread ( ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( mIOThread , "This should never be null ! " ) ; <NEW_LINE> return mIOThread ; <NEW_LINE> }
} <NEW_LINE> <START_VULN> if ( node -> data ( ) . low ( ) < interval . high ( ) ) { <NEW_LINE> <END_VULN> SearchForOverlapsFrom ( node -> right ( ) , interval , res ) ; <NEW_LINE> } <NEW_LINE> }
#ifndef _TYPES_INCLUDED <NEW_LINE> #define _TYPES_INCLUDED <NEW_LINE> #include "compiler / BaseTypes . h" <NEW_LINE> #include "compiler / Common . h" <NEW_LINE> <START_VULN> #include "compiler / debug . h" <NEW_LINE> <END_VULN> class TType ; <NEW_LINE> struct TTypeLine { <NEW_LINE> TType * type ; <NEW_LINE> int line ; <NEW_LINE> rename from gfx / angle / src / compiler / debug . cpp <NEW_LINE> rename to gfx / angle / src / compiler / compilerdebug . cpp
case FILE_LELDATE: <NEW_LINE> case FILE_MELDATE: <NEW_LINE> if ( file_printf ( ms , F ( ms , m , " % s" ) , <NEW_LINE> <START_VULN> file_fmttime ( p -> l , 0 , tbuf ) ) == - 1 ) <NEW_LINE> <END_VULN> return - 1 ; <NEW_LINE> t = ms -> offset + sizeof ( uint32_t ) ; <NEW_LINE> break ;
* ( dp ++ ) = * ( sp ++ ) ; <NEW_LINE> sp += 3 ; dp = sp ; <NEW_LINE> <START_VULN> * ( dp ++ ) = ( png_byte ) ( 255 - * ( sp ++ ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
else if ( ! ctx -> iface -> enc . get_glob_hdrs ) <NEW_LINE> ctx -> err = VPX_CODEC_INCAPABLE ; <NEW_LINE> else <NEW_LINE> <START_VULN> buf = ctx -> iface -> enc . get_glob_hdrs ( ctx -> priv -> alg_priv ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return buf ;
return ; <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " [ | truncated ] " ) ) ; <NEW_LINE> <END_VULN> return ; <NEW_LINE> tooshort:
codesize ++ ; <NEW_LINE> codemask += avail ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> oldcode = incode ; <NEW_LINE> do { <NEW_LINE> <START_VULN> * rowp ++ = * -- stackp ; <NEW_LINE> <END_VULN> if ( rowp == rowend ) <NEW_LINE> OUTPUT_ROW ( ) ; <NEW_LINE> } while ( stackp > stack ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> END:
continue ; <NEW_LINE> } <NEW_LINE> } else { <NEW_LINE> <START_VULN> NEED_OP ( t ) ; <NEW_LINE> <END_VULN> do { <NEW_LINE> * op ++ = * m_pos ++ ; <NEW_LINE> } while ( op < oe ) ;
if ( delta ) { <NEW_LINE> float newPosition = static_cast < float > ( thumbPos + delta ) * maximum ( ) / ( trackLen - thumbLen ) ; <NEW_LINE> <START_VULN> scrollableArea ( ) -> scrollToOffsetWithoutAnimation ( m_orientation , newPosition ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
static void php_array_replace_recursive ( PointerSet & seen , bool check , <NEW_LINE> Array & arr1 , const Array & arr2 ) { <NEW_LINE> <START_VULN> if ( check ) { <NEW_LINE>if ( seen . find ( ( void * ) arr1 . get ( ) ) != seen . end ( ) ) { <NEW_LINE>raise_warning ( "array_replace_recursive ( ) : recursion detected" ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE>seen . insert ( ( void * ) arr1 . get ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> for ( ArrayIter iter ( arr2 ) ; iter ; ++ iter ) {
} <NEW_LINE> unsigned context ; <NEW_LINE> <START_VULN> if ( currentNode -> renderStyle ( ) -> visualInvalidationDiff ( * startingStyle , context ) == StyleDifferenceEqual && ! context ) <NEW_LINE> <END_VULN> topNodeWithStartingStyle = currentNode ; <NEW_LINE> }
return folly::none ; <NEW_LINE> } <NEW_LINE> <START_VULN> TLSMessage msg ; <NEW_LINE> <END_VULN>
ND_PRINT ( ( ndo , " ( length bogus , should be = 6 ) " ) ) ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , ": 0x % 08x" , EXTRACT_32BITS ( p + 2 ) ) ) ; <NEW_LINE> break ; <NEW_LINE> case LCPOPT_PFC:
override ; <NEW_LINE> net::NetLog * GetNetLog ( ) override ; <NEW_LINE> DevToolsManagerDelegate * GetDevToolsManagerDelegate ( ) override ; <NEW_LINE> <START_VULN> void OpenURL ( BrowserContext * browser_context , <NEW_LINE> <END_VULN> const OpenURLParams & params , <NEW_LINE> const base::Callback < void ( WebContents * ) > & callback ) override ; <NEW_LINE> scoped_refptr < LoginDelegate > CreateLoginDelegate (
} <NEW_LINE> if ( ! aFrame ) { <NEW_LINE> if ( mInstanceOwner ) { <NEW_LINE> mInstanceOwner -> SetFrame ( nullptr ) ; <NEW_LINE> <START_VULN> <NEW_LINE>nsCOMPtr < nsIRunnable > event = new CheckPluginStopEvent ( this ) ; <NEW_LINE>mPendingCheckPluginStopEvent = event ; <NEW_LINE>nsCOMPtr < nsIAppShell > appShell = do_GetService ( kAppShellCID ) ; <NEW_LINE>if ( appShell ) { <NEW_LINE>appShell -> RunInStableState ( event ) ; <NEW_LINE> } else { <NEW_LINE>NS_NOTREACHED ( "No app shell ? " ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> if ( ! mInstanceOwner ) {
size_t gc_info_index = GCInfoTrait < T > ::Index ( ) ; <NEW_LINE> <START_VULN> DCHECK ( ! ThreadHeap::GcInfo ( previous_header -> GcInfoIndex ( ) ) -> HasFinalizer ( ) ) ; <NEW_LINE> <END_VULN> DCHECK_EQ ( previous_header -> GcInfoIndex ( ) , gc_info_index ) ; <NEW_LINE> HeapAllocHooks::FreeHookIfEnabled ( static_cast < Address > ( previous ) ) ; <NEW_LINE> Address address ;
static u32 challenge_timestamp ; <NEW_LINE> static unsigned int challenge_count ; <NEW_LINE> struct tcp_sock * tp = tcp_sk ( sk ) ; <NEW_LINE> <START_VULN> u32 now ; <NEW_LINE> <END_VULN> if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb ,
* n_devs = 0 ; <NEW_LINE> <START_VULN> fd = open ( authfile , O_RDONLY , 0 ) ; <NEW_LINE> <END_VULN> if ( fd < 0 ) { <NEW_LINE> if ( verbose ) <NEW_LINE> D ( debug_file , "Cannot open file: % s ( % s ) " , authfile , strerror ( errno ) ) ;
if ( header -> IsFree ( ) || ! header -> IsMarked ( ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> const GCInfo * info = ThreadHeap::GcInfo ( header -> GcInfoIndex ( ) ) ; <NEW_LINE> <END_VULN> const bool can_verify = <NEW_LINE> ! info -> HasVTable ( ) || blink::VTableInitialized ( header -> Payload ( ) ) ; <NEW_LINE> if ( can_verify ) {
rowsperstrip = td -> td_rowsperstrip ; <NEW_LINE> if ( rowsperstrip > td -> td_imagelength ) <NEW_LINE> rowsperstrip = td -> td_imagelength ; <NEW_LINE> <START_VULN> stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ; <NEW_LINE> <END_VULN> stripinplane = ( strip % stripsperplane ) ; <NEW_LINE> plane = ( uint16 ) ( strip / stripsperplane ) ; <NEW_LINE> rows = td -> td_imagelength - stripinplane * rowsperstrip ;
pptr += opli ; <NEW_LINE> } <NEW_LINE> trunc: <NEW_LINE> <START_VULN> return ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void
define_sid = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! PS ( id ) && <NEW_LINE> <END_VULN> zend_hash_find ( & EG ( symbol_table ) , "_GET" , <NEW_LINE> sizeof ( "_GET" ) , ( void ** ) & data ) == SUCCESS && <NEW_LINE> Z_TYPE_PP ( data ) == IS_ARRAY &&
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: libvorbis codec headers <NEW_LINE> <START_VULN> last mod: $ Id: codec . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _vorbis_codec_h_ <NEW_LINE> #define _vorbis_codec_h_ <NEW_LINE> #ifdef __cplusplus <NEW_LINE> extern "C"
PositionForPoint ( const LayoutPoint & frame_point ) ; <NEW_LINE> Document * DocumentAtPoint ( const LayoutPoint & ) ; <NEW_LINE> <START_VULN> bool ShouldReuseDefaultView ( const KURL & ) const ; <NEW_LINE> <END_VULN> void RemoveSpellingMarkersUnderWords ( const Vector < String > & words ) ; <NEW_LINE> bool ShouldThrottleRendering ( ) const ;
<< GLES2Util::GetStringBufferuiv ( buffer ) << " , " <NEW_LINE> << drawbuffers << " , " << static_cast < const void * > ( value ) <NEW_LINE> << " ) " ) ; <NEW_LINE> <START_VULN> size_t count = 4 ; <NEW_LINE> <END_VULN> for ( size_t ii = 0 ; ii < count ; ++ ii ) <NEW_LINE> GPU_CLIENT_LOG ( "value [ " << ii << " ] : " << value [ ii ] ) ; <NEW_LINE> helper_ -> ClearBufferuivImmediate ( buffer , drawbuffers , value ) ;
mbedtls_x509_sequence * cur = NULL ; <NEW_LINE> mbedtls_pk_type_t pk_type ; <NEW_LINE> <START_VULN> if ( profile == NULL ) <NEW_LINE>return ( MBEDTLS_ERR_X509_BAD_INPUT_DATA ) ; <NEW_LINE><NEW_LINE> <END_VULN> * flags = 0 ; <NEW_LINE> if ( cn != NULL ) <NEW_LINE> { <NEW_LINE> name = & crt -> subject ;
#ifdef PNG_READ_bKGD_SUPPORTED <NEW_LINE> else if ( chunk_name == png_bKGD ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr -> push_length + 4 > png_ptr -> buffer_size ) <NEW_LINE> { <NEW_LINE>png_push_save_buffer ( png_ptr ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE> <END_VULN> png_handle_bKGD ( png_ptr , info_ptr , png_ptr -> push_length ) ; <NEW_LINE> }
bool skipWhitespace ; <NEW_LINE> nscoord trailingWhitespace ; <NEW_LINE> <START_VULN> nsTArray < nsIFrame * > floats ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> struct InlineMinWidthData : public InlineIntrinsicWidthData { <NEW_LINE> InlineMinWidthData ( ) <NEW_LINE> : trailingTextFrame ( nullptr ) <NEW_LINE> , atStartOfLine ( true ) <NEW_LINE> { }
if ( JSDOUBLE_IS_NaN ( local ) ) <NEW_LINE> return ; <NEW_LINE> local = date_msecFromDate ( YearFromTime ( local ) , <NEW_LINE> MonthFromTime ( local ) , <NEW_LINE> DateFromTime ( local ) , <NEW_LINE> hours , <NEW_LINE> MinFromTime ( local ) , <NEW_LINE> SecFromTime ( local ) , <NEW_LINE> msFromTime ( local ) ) ; <NEW_LINE> <START_VULN> SetUTCTime ( cx , obj , NULL , UTC ( local ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_FRIEND_API ( void ) <NEW_LINE> js_DateSetMinutes ( JSContext * cx , JSObject * obj , int minutes ) <NEW_LINE> { <NEW_LINE> jsdouble local ; <NEW_LINE> if ( ! GetAndCacheLocalTime ( cx , obj , NULL , & local ) ) <NEW_LINE> return ;
<START_VULN> #ifndef BASE_PROCESS_PROCESS_PROCESS_H_ <NEW_LINE>#define BASE_PROCESS_PROCESS_PROCESS_H_ <NEW_LINE> <END_VULN> #include "base / base_export . h" <NEW_LINE> #include "base / basictypes . h"
return 1 ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> void
int i , j , k ; <NEW_LINE> int stride ; <NEW_LINE> <START_VULN> vpx_memset ( accumulator , 0 , 384 * sizeof ( unsigned int ) ) ; <NEW_LINE>vpx_memset ( count , 0 , 384 * sizeof ( unsigned short ) ) ; <NEW_LINE> <END_VULN> #if ALT_REF_MC_ENABLED <NEW_LINE> cpi -> mb . mv_col_min = - ( ( mb_col * 16 ) + ( 16 - 5 ) ) ;
error = 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> # ifdef PNG_MNG_FEATURES_SUPPORTED <NEW_LINE> <END_VULN>
return png_icc_profile_error ( png_ptr , colorspace , name , temp , <NEW_LINE> "invalid embedded Abstract ICC profile" ) ; <NEW_LINE> <START_VULN> case 0x6C696E6B: <NEW_LINE> <END_VULN>
virtual void didProcessTask ( ) override <NEW_LINE> { <NEW_LINE> <START_VULN> Microtask::performCheckpoint ( ) ; <NEW_LINE> <END_VULN> if ( WorkerGlobalScope * globalScope = m_workerThread -> workerGlobalScope ( ) ) { <NEW_LINE> if ( WorkerScriptController * scriptController = globalScope -> script ( ) ) <NEW_LINE> scriptController -> rejectedPromises ( ) -> processQueue ( ) ;
bool GetHitRegionRect ( Element * aElement , nsRect & aRect ) ; <NEW_LINE> protected: <NEW_LINE> nsresult GetImageDataArray ( JSContext * aCx , int32_t aX , int32_t aY , <NEW_LINE> uint32_t aWidth , uint32_t aHeight , <NEW_LINE> JSObject ** aRetval ) ; <NEW_LINE> nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <NEW_LINE> <START_VULN> unsigned char * aData , uint32_t aDataLen , <NEW_LINE> <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , <NEW_LINE> int32_t dirtyWidth , int32_t dirtyHeight ) ; <NEW_LINE> nsresult Initialize ( int32_t width , int32_t height ) ;
args . rval ( ) . setUndefined ( ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> static JSBool <NEW_LINE> FieldSetter ( JSContext * cx , unsigned argc , JS::Value * vp ) <NEW_LINE> { <NEW_LINE> JS::CallArgs args = JS::CallArgsFromVp ( argc , vp ) ; <NEW_LINE> <START_VULN> return JS::CallNonGenericMethod < ValueHasISupportsPrivate , FieldSetterImpl > <NEW_LINE> <END_VULN> ( cx , args ) ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsXBLProtoImplField::InstallAccessors ( JSContext * aCx , <NEW_LINE> JSObject * aTargetClassObject ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( js::IsObjectInContextCompartment ( aTargetClassObject , aCx ) ) ;
return E_FILE_FORMAT_INVALID ; <NEW_LINE> } else if ( id == 0x7E2 ) { <NEW_LINE> <START_VULN> delete [ ] encryption -> key_id ; <NEW_LINE> <END_VULN> encryption -> key_id = NULL ; <NEW_LINE> encryption -> key_id_len = 0 ;
NS_PRECONDITION ( ! mIsDocumentGone , "Unexpected ContentAppended" ) ; <NEW_LINE> NS_PRECONDITION ( aDocument == mDocument , "Unexpected aDocument" ) ; <NEW_LINE> NS_PRECONDITION ( aContainer , "must have container" ) ; <NEW_LINE> if ( ! mDidInitialReflow ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE> <END_VULN> MOZ_TIMER_DEBUGLOG ( ( "Start: Frame Creation: PresShell::ContentAppended ( ) , this = % p\n" , this ) ) ; <NEW_LINE> MOZ_TIMER_START ( mFrameCreationWatch ) ; <NEW_LINE> mFrameConstructor -> RestyleForAppend ( aContainer , aNewIndexInContainer ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: lookup based functions <NEW_LINE> <START_VULN> last mod: $ Id: lookup . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < math . h > <NEW_LINE> #include "lookup . h" <NEW_LINE> #include "lookup_data . h" <NEW_LINE> #include "os . h" <NEW_LINE> #include "misc . h"
int tmp_best_skippable = 0 ; <NEW_LINE> int switchable_filter_index ; <NEW_LINE> int_mv * second_ref = comp_pred ? <NEW_LINE> <START_VULN> & mbmi -> ref_mvs [ second_ref_frame ] [ 0 ] : NULL ; <NEW_LINE> <END_VULN> b_mode_info tmp_best_bmodes [ 16 ] ; <NEW_LINE> MB_MODE_INFO tmp_best_mbmode ; <NEW_LINE> BEST_SEG_INFO bsi [ SWITCHABLE_FILTERS ] ;
#include "conf_space . h" <NEW_LINE> #include "conf_space_quirks . h" <NEW_LINE> <START_VULN> static bool permissive ; <NEW_LINE> <END_VULN> module_param ( permissive , bool , 0644 ) ;
const PRUint8 nsSMILTimedElement::sMaxNumIntervals = 20 ; <NEW_LINE> const PRUint8 nsSMILTimedElement::sMaxNumInstanceTimes = 100 ; <NEW_LINE> <START_VULN> const PRUint16 nsSMILTimedElement::sMaxUpdateIntervalRecursionDepth = 20 ; <NEW_LINE> <END_VULN> nsSMILTimedElement::nsSMILTimedElement ( ) <NEW_LINE> : <NEW_LINE> mAnimationElement ( nsnull ) , <NEW_LINE> mFillMode ( FILL_REMOVE ) ,
} else if ( port == OMX_CORE_OUTPUT_PORT_INDEX ) { <NEW_LINE> nPortIndex = buffer - client_buffers . get_il_buf_hdr ( ) ; <NEW_LINE> <START_VULN> if ( nPortIndex < drv_ctx . op_buf . actualcount ) { <NEW_LINE> <END_VULN> DEBUG_PRINT_LOW ( "free_buffer on o / p port - Port idx % d" , nPortIndex ) ; <NEW_LINE> BITMASK_CLEAR ( & m_out_bm_count , nPortIndex ) ;
lp ++ ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( buflen == 0 ) <NEW_LINE> <END_VULN> ( void ) snprintf ( buf , sizeof ( buf ) , fmt == NULL ? "# % 08x" : fmt , v ) ; <NEW_LINE> return ( buf ) ;
static void copyStereo8 ( <NEW_LINE> short * dst , <NEW_LINE> <START_VULN> const int * const * src , <NEW_LINE> <END_VULN> unsigned nSamples , <NEW_LINE> unsigned ) { <NEW_LINE> for ( unsigned i = 0 ; i < nSamples ; ++ i ) {
} <NEW_LINE> if ( ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) || <NEW_LINE> ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) ) { <NEW_LINE> int32_t skipLength = newLineOffset >= 0 ? length - 1 : length ; <NEW_LINE> int32_t whitespaceCount = <NEW_LINE> GetTrimmableWhitespaceCount ( frag , offset , skipLength , 1 ) ; <NEW_LINE> <START_VULN> offset += whitespaceCount ; <NEW_LINE>length - = whitespaceCount ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool completedFirstLetter = false ; <NEW_LINE> if ( aLineLayout . GetInFirstLetter ( ) || aLineLayout . GetInFirstLine ( ) ) { <NEW_LINE> SetLength ( maxContentLength , & aLineLayout , <NEW_LINE> ALLOW_FRAME_CREATION_AND_DESTRUCTION ) ;
if ( eCSSUnit_Calc_Minimum == unit ) { <NEW_LINE> aResult . AppendLiteral ( " - moz - min ( " ) ; <NEW_LINE> } else { <NEW_LINE> aResult . AppendLiteral ( " - moz - max ( " ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> for ( PRUint32 i = 0 , i_end = array -> Count ( ) ; i < i_end ; ++ i ) { <NEW_LINE> <END_VULN> if ( i != 0 ) { <NEW_LINE> aResult . AppendLiteral ( " , " ) ; <NEW_LINE> } <NEW_LINE> AppendCSSValueToString ( eCSSProperty_UNKNOWN , array -> Item ( i ) , aResult ) ;
enum { ALLOW_MEMMOVE = PR_TRUE } ; <NEW_LINE> ChangeCallback mKey ; <NEW_LINE> } ; <NEW_LINE> private: <NEW_LINE> void FireChangeCallbacks ( nsIContent * aOldContent , nsIContent * aNewContent ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> nsSmallVoidArray mIdContentList ; <NEW_LINE> nsBaseContentList * mNameContentList ; <NEW_LINE> nsRefPtr < nsContentList > mDocAllList ; <NEW_LINE> nsAutoPtr < nsTHashtable < ChangeCallbackEntry > > mChangeCallbacks ; <NEW_LINE> } ; <NEW_LINE> class nsDocHeaderData
void ClearTextRun ( nsTextFrame * aStartContinuation , <NEW_LINE> TextRunType aWhichTextRun ) ; <NEW_LINE> void ClearTextRuns ( ) { <NEW_LINE> ClearTextRun ( nsnull , nsTextFrame::eInflated ) ; <NEW_LINE> <START_VULN> ClearTextRun ( nsnull , nsTextFrame::eNotInflated ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> struct TrimmedOffsets { <NEW_LINE> PRInt32 mStart ; <NEW_LINE> PRInt32 mLength ;
SECStatus newrv = PK11_Authenticate ( slot , PR_TRUE , pwarg ) ; <NEW_LINE> if ( newrv != SECSuccess ) { <NEW_LINE> SECU_PrintError ( progName , "could not authenticate to token % s . " , <NEW_LINE> PK11_GetTokenName ( slot ) ) ; <NEW_LINE> return SECFailure ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( name ) { <NEW_LINE> <START_VULN> CERTCertificate * the_cert ; <NEW_LINE>the_cert = CERT_FindCertByNicknameOrEmailAddr ( handle , name ) ; <NEW_LINE>if ( ! the_cert ) { <NEW_LINE>the_cert = PK11_FindCertFromNickname ( name , NULL ) ; <NEW_LINE>if ( ! the_cert ) { <NEW_LINE>SECU_PrintError ( progName , "Could not find: % s\n" , name ) ; <NEW_LINE>return SECFailure ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <END_VULN> certs = CERT_CreateSubjectCertList ( NULL , handle , & the_cert -> derSubject , <NEW_LINE> PR_Now ( ) , PR_FALSE ) ;
|| renderer ( ) -> isApplet ( ) <NEW_LINE> || renderer ( ) -> isRenderIFrame ( ) <NEW_LINE> || renderer ( ) -> style ( ) -> specifiesColumns ( ) ) <NEW_LINE> <START_VULN> && ! renderer ( ) -> isPositioned ( ) <NEW_LINE> <END_VULN> && ! renderer ( ) -> isRelPositioned ( ) <NEW_LINE> && ! renderer ( ) -> hasTransform ( ) <NEW_LINE> #if ENABLE ( CSS_FILTERS )
GPLOT * <NEW_LINE> gplotRead ( const char * filename ) <NEW_LINE> { <NEW_LINE> <START_VULN> char buf [ L_BUF_SIZE ] ; <NEW_LINE> <END_VULN> char * rootname , * title , * xlabel , * ylabel , * ignores ; <NEW_LINE> l_int32 outformat , ret , version , ignore ; <NEW_LINE> FILE * fp ;
Cluster * const cluster = cluster_list_ [ i ] ; <NEW_LINE> delete cluster ; <NEW_LINE> } <NEW_LINE> <START_VULN> delete [ ] cluster_list_ ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( frames_ ) {
types::StackTypeSet * barrier ; <NEW_LINE> types::StackTypeSet * types = oracle -> returnTypeSet ( script ( ) , pc , & barrier ) ; <NEW_LINE> return pushTypeBarrier ( apply , types , barrier ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> JS_ASSERT ( inliningDepth > 0 ) ; <NEW_LINE> <END_VULN> CallInfo callInfo ( cx , false ) ; <NEW_LINE> MPassArg * passVp = current -> pop ( ) -> toPassArg ( ) ; <NEW_LINE> passVp -> replaceAllUsesWith ( passVp -> getArgument ( ) ) ; <NEW_LINE> passVp -> block ( ) -> discard ( passVp ) ;
rv = ScriptShape ( shapeDC , mCurrentFont -> ScriptCache ( ) , <NEW_LINE> str , mRangeLength , <NEW_LINE> mMaxGlyphs , & sa , <NEW_LINE> mGlyphs . Elements ( ) , mClusters . Elements ( ) , <NEW_LINE> mAttr . Elements ( ) , & mNumGlyphs ) ; <NEW_LINE> if ( rv == E_OUTOFMEMORY ) { <NEW_LINE> mMaxGlyphs *= 2 ; <NEW_LINE> <START_VULN> mGlyphs . SetLength ( mMaxGlyphs ) ; <NEW_LINE>mAttr . SetLength ( mMaxGlyphs ) ; <NEW_LINE> <END_VULN> continue ; <NEW_LINE> }
* ( -- dp ) = * ( -- sp ) ; <NEW_LINE> * ( -- dp ) = * ( -- sp ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> * ( -- dp ) = hi_filler ; <NEW_LINE> <END_VULN> * ( -- dp ) = lo_filler ; <NEW_LINE> row_info -> channels = 4 ; <NEW_LINE> row_info -> pixel_depth = 64 ; <NEW_LINE> row_info -> rowbytes = row_width * 8 ;
{ <NEW_LINE> uint8_t tunnel_type , flags ; <NEW_LINE> tunnel_type = * ( tptr + 1 ) ; <NEW_LINE> flags = * tptr ; <NEW_LINE> tlen = len ; <NEW_LINE> <START_VULN> ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , "\n\t Tunnel - type % s ( % u ) , Flags [ % s ] , MPLS Label % u" , <NEW_LINE> tok2str ( bgp_pmsi_tunnel_values , "Unknown" , tunnel_type ) , <NEW_LINE> tunnel_type ,
void createRequest ( ExceptionState & ) ; <NEW_LINE> <START_VULN> void genericError ( ) ; <NEW_LINE>void networkError ( ) ; <NEW_LINE>void abortError ( ) ; <NEW_LINE> <END_VULN> OwnPtr < XMLHttpRequestUpload > m_upload ;
nsCOMPtr < nsIContent > bodyContent ( do_QueryInterface ( bodyElement ) ) ; <NEW_LINE> if ( ! bodyContent ) return NS_ERROR_FAILURE ; <NEW_LINE> <START_VULN> DeleteRefToAnonymousNode ( mPositioningShadow , bodyContent , docObserver ) ; <NEW_LINE> <END_VULN> mPositioningShadow = nsnull ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIDOMEventReceiver > erP ;
} <NEW_LINE> #endif <NEW_LINE> if ( bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT ) { <NEW_LINE> <START_VULN> status = nfsd4_encode_bitmap ( xdr , NFSD_SUPPATTR_EXCLCREAT_WORD0 , <NEW_LINE>NFSD_SUPPATTR_EXCLCREAT_WORD1 , <NEW_LINE>NFSD_SUPPATTR_EXCLCREAT_WORD2 ) ; <NEW_LINE> <END_VULN> if ( status ) <NEW_LINE> goto out ; <NEW_LINE> }
} <NEW_LINE> if ( numrows >= 2 ) { <NEW_LINE> <START_VULN> hstartcol = ( numrows + 1 - parity ) >> 1 ; <NEW_LINE><NEW_LINE>m = numrows - hstartcol ; <NEW_LINE> <END_VULN> n = m ;
for ( RenderBox * child = firstChildBox ( ) ; child ; child = child -> nextSiblingBox ( ) ) { <NEW_LINE> <START_VULN> if ( child -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( ! child -> isSelfCollapsingBlock ( ) ) <NEW_LINE> return false ;
mDocShellDependentStuffKnown ( PR_FALSE ) , <NEW_LINE> mExternalErrorReporting ( PR_FALSE ) , <NEW_LINE> mForSTARTTLS ( PR_FALSE ) , <NEW_LINE> mHandshakePending ( PR_TRUE ) , <NEW_LINE> mCanceled ( PR_FALSE ) , <NEW_LINE> mHasCleartextPhase ( PR_FALSE ) , <NEW_LINE> mHandshakeInProgress ( PR_FALSE ) , <NEW_LINE> mAllowTLSIntoleranceTimeout ( PR_TRUE ) , <NEW_LINE> mRememberClientAuthCertificate ( PR_FALSE ) , <NEW_LINE> mHandshakeStartTime ( 0 ) , <NEW_LINE> <START_VULN> mPort ( 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> mThreadData = new nsSSLSocketThreadData ; <NEW_LINE> } <NEW_LINE> nsNSSSocketInfo:: ~ nsNSSSocketInfo ( ) <NEW_LINE> { <NEW_LINE> delete mThreadData ; <NEW_LINE> nsNSSShutDownPreventionLock locker ; <NEW_LINE> if ( isAlreadyShutDown ( ) )
@param json JSON object tree <NEW_LINE> @return An MprHash instance <NEW_LINE> @ingroup MprJson <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC MprHash * mprJsonToHash ( MprJson * json ) ;
decoder_set_fb_fn , <NEW_LINE> } , <NEW_LINE> { <NEW_LINE> <START_VULN> NOT_IMPLEMENTED , <NEW_LINE>NOT_IMPLEMENTED , <NEW_LINE>NOT_IMPLEMENTED , <NEW_LINE>NOT_IMPLEMENTED , <NEW_LINE>NOT_IMPLEMENTED , <NEW_LINE>NOT_IMPLEMENTED <NEW_LINE> <END_VULN> } <NEW_LINE> } ;
err = - fd ; <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> r = verify_vc_kbmode ( fd ) ; <NEW_LINE> <END_VULN> if ( r < 0 ) { <NEW_LINE> if ( ! err ) <NEW_LINE> err = - r ;
nsComboboxControlFrame * mComboBox ; <NEW_LINE> } ; <NEW_LINE> NS_IMPL_ISUPPORTS1 ( nsComboButtonListener , <NEW_LINE> nsIDOMEventListener ) <NEW_LINE> <START_VULN> nsComboboxControlFrame * nsComboboxControlFrame::mFocused = nsnull ; <NEW_LINE> <END_VULN> nsIFrame * <NEW_LINE> NS_NewComboboxControlFrame ( nsIPresShell * aPresShell , nsStyleContext * aContext , PRUint32 aStateFlags ) <NEW_LINE> { <NEW_LINE> nsComboboxControlFrame * it = new ( aPresShell ) nsComboboxControlFrame ( aContext ) ; <NEW_LINE> if ( it ) {
res_dp += len ; <NEW_LINE> res_sz - = len ; <NEW_LINE> <START_VULN> } <NEW_LINE>else if ( cmd ) { <NEW_LINE><NEW_LINE> <END_VULN> if ( delta_end - delta < cmd || res_sz < cmd ) <NEW_LINE> goto fail ; <NEW_LINE> memcpy ( res_dp , delta , cmd ) ;
php_stream_seek ( fp , sizeof ( phar_zip_file_header ) + entry . header_offset + entry . filename_len + PHAR_GET_16 ( zipentry . extra_len ) , SEEK_SET ) ; <NEW_LINE> sig = ( char * ) emalloc ( entry . uncompressed_filesize ) ; <NEW_LINE> read = php_stream_read ( fp , sig , entry . uncompressed_filesize ) ; <NEW_LINE> <START_VULN> if ( read != entry . uncompressed_filesize ) { <NEW_LINE> <END_VULN> php_stream_close ( sigfile ) ; <NEW_LINE> efree ( sig ) ; <NEW_LINE> PHAR_ZIP_FAIL ( "signature cannot be read" ) ;
PRUint32 count = 0 ; <NEW_LINE> char * buffer = nsnull ; <NEW_LINE> if ( ! mInputStream ) return NS_ERROR_NOT_INITIALIZED ; <NEW_LINE> rv = mInputStream -> Available ( & count ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> <START_VULN> count = NS_MIN ( count , aCount ) ; <NEW_LINE> <END_VULN> buffer = ( char * ) nsMemory::Alloc ( count + 1 ) ; <NEW_LINE> if ( ! buffer ) return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> PRUint32 amtRead = 0 ; <NEW_LINE> rv = mInputStream -> Read ( buffer , count , & amtRead ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> nsMemory::Free ( buffer ) ; <NEW_LINE> return rv ;
if ( JSDOUBLE_IS_NaN ( local ) ) <NEW_LINE> return ; <NEW_LINE> local = date_msecFromDate ( YearFromTime ( local ) , <NEW_LINE> MonthFromTime ( local ) , <NEW_LINE> DateFromTime ( local ) , <NEW_LINE> HourFromTime ( local ) , <NEW_LINE> minutes , <NEW_LINE> SecFromTime ( local ) , <NEW_LINE> msFromTime ( local ) ) ; <NEW_LINE> <START_VULN> SetUTCTime ( cx , obj , NULL , UTC ( local ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JS_FRIEND_API ( void ) <NEW_LINE> js_DateSetSeconds ( JSContext * cx , JSObject * obj , int seconds ) <NEW_LINE> { <NEW_LINE> jsdouble local ; <NEW_LINE> if ( ! GetAndCacheLocalTime ( cx , obj , NULL , & local ) ) <NEW_LINE> return ;
bool wantXrays = ! ( sameOrigin && ! targetdata -> wantXrays ) ; <NEW_LINE> <START_VULN> bool waiveXrays = wantXrays && ! securityWrapper && <NEW_LINE> ( flags & WAIVE_XRAY_WRAPPER_FLAG ) ; <NEW_LINE> <END_VULN> wrapper = SelectWrapper ( securityWrapper , wantXrays , xrayType , waiveXrays ) ; <NEW_LINE> }
bool InitiateHTTPRequest ( unsigned long resource_id , <NEW_LINE> WebPluginResourceClient * client , <NEW_LINE> <START_VULN> const char * method , const char * buf , int buf_len , <NEW_LINE>const GURL & url , const char * range_info , <NEW_LINE> <END_VULN> Referrer referrer_flag ) ; <NEW_LINE> gfx::Rect GetWindowClipRect ( const gfx::Rect & rect ) ;
_WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { <NEW_LINE> uint32_t hmi_tmp = 0 ; <NEW_LINE> uint8_t * hmi_base = hmi_data ; <NEW_LINE> uint16_t hmi_bpm = 0 ; <NEW_LINE> uint16_t hmi_division = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> uint32_t hmi_track_cnt = 0 ; <NEW_LINE> uint32_t * hmi_track_offset = NULL ; <NEW_LINE> uint32_t i = 0 ;
char * path_name ( struct strbuf * path , const char * name ) ; <NEW_LINE> <START_VULN> extern void show_object_with_name ( FILE * , struct object * , <NEW_LINE>struct strbuf * , const char * ) ; <NEW_LINE> <END_VULN> extern void add_pending_object ( struct rev_info * revs , <NEW_LINE> struct object * obj , const char * name ) ;
#include "vpx / vpx_codec . h" <NEW_LINE> <START_VULN> static const char * const cfg = " -- target = mips32 - linux - gcc -- enable - dspr2 -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
route = state -> route ; <NEW_LINE> tok = sclone ( value ) ; <NEW_LINE> while ( ( option = maGetNextArg ( tok , & tok ) ) != 0 ) { <NEW_LINE> <START_VULN> option = stok ( option , " = \t , " , & ovalue ) ; <NEW_LINE> <END_VULN> ovalue = strim ( ovalue , "\"'" , MPR_TRIM_BOTH ) ; <NEW_LINE> if ( scaselessmatch ( option , "origin" ) ) { <NEW_LINE> route -> corsOrigin = sclone ( ovalue ) ;
if ( knownToHaveNoOverflow ( ) ) <NEW_LINE> maxLogicalRight = max ( logicalLeft , maxLogicalRight ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> if ( curr -> renderer ( ) -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> if ( curr -> renderer ( ) -> parent ( ) -> style ( ) -> isLeftToRightDirection ( ) ) <NEW_LINE> curr -> setLogicalLeft ( logicalLeft ) ; <NEW_LINE> else
<START_VULN> int comp_inter_joint_search_thresh ; <NEW_LINE> <END_VULN>
mprLog ( "warn http config" , 4 , "Already logging . Ignoring log configuration" ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> location = mprGetJson ( prop , "location" ) ; <NEW_LINE>level = ( int ) stoi ( mprGetJson ( prop , "level" ) ) ; <NEW_LINE>backup = ( int ) stoi ( mprGetJson ( prop , "backup" ) ) ; <NEW_LINE>anew = smatch ( mprGetJson ( prop , "anew" ) , "true" ) ; <NEW_LINE>size = ( ssize ) httpGetNumber ( mprGetJson ( prop , "size" ) ) ; <NEW_LINE>timestamp = httpGetNumber ( mprGetJson ( prop , "timestamp" ) ) ; <NEW_LINE> <END_VULN> if ( size < HTTP_TRACE_MIN_LOG_SIZE ) { <NEW_LINE> size = HTTP_TRACE_MIN_LOG_SIZE ;
nsCOMPtr < nsIDocument > doc = do_QueryInterface ( domDoc ) ; <NEW_LINE> return doc . forget ( ) ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsLocation::CheckURL ( nsIURI * aURI , nsIDocShellLoadInfo ** aLoadInfo ) <NEW_LINE> { <NEW_LINE> * aLoadInfo = nsnull ; <NEW_LINE> nsCOMPtr < nsIDocShell > docShell ( do_QueryReferent ( mDocShell ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( docShell , NS_ERROR_NOT_AVAILABLE ) ; <NEW_LINE> nsresult rv ; <NEW_LINE> nsCOMPtr < nsIJSContextStack > <NEW_LINE> stack ( do_GetService ( "@mozilla . org / js / xpc / ContextStack ; 1" , & rv ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> JSContext * cx ; <NEW_LINE><NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( GetContextFromStack ( stack , & cx ) , NS_ERROR_FAILURE ) ; <NEW_LINE> nsCOMPtr < nsISupports > owner ; <NEW_LINE> nsCOMPtr < nsIURI > sourceURI ; <NEW_LINE> if ( cx ) {
#define PACKAGE_NAME "fontconfig" <NEW_LINE> <START_VULN> #define PACKAGE_STRING "fontconfig 2 . 13 . 0" <NEW_LINE> <END_VULN> #define PACKAGE_TARNAME "fontconfig"
xmlCharEncoding enc ) { <NEW_LINE> xmlParserInputBufferPtr ret ; <NEW_LINE> <START_VULN> if ( size <= 0 ) return ( NULL ) ; <NEW_LINE> <END_VULN> if ( mem == NULL ) return ( NULL ) ; <NEW_LINE> ret = ( xmlParserInputBufferPtr ) xmlMalloc ( sizeof ( xmlParserInputBuffer ) ) ;
} <NEW_LINE> void ImageCapture::ResolveWithMediaTrackConstraints ( <NEW_LINE> <START_VULN> MediaTrackConstraints constraints , <NEW_LINE> <END_VULN> ScriptPromiseResolver * resolver ) { <NEW_LINE> DCHECK ( resolver ) ; <NEW_LINE> resolver -> Resolve ( constraints ) ;
} <NEW_LINE> <START_VULN> if ( ! ArrayBufferObject::neuterViews ( cx , buffer ) ) { <NEW_LINE> <END_VULN> if ( buffer -> hasStealableContents ( ) ) { <NEW_LINE> FreeOp fop ( cx -> runtime ( ) , false ) ; <NEW_LINE> fop . free_ ( newHeader ) ;
~ EmulationHandler ( ) override ; <NEW_LINE> void Wire ( UberDispatcher * dispatcher ) override ; <NEW_LINE> <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE> <END_VULN> RenderFrameHostImpl * frame_host ) override ; <NEW_LINE> Response Disable ( ) override ;
while ( count > 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> memcpy ( temp , temp - r -> bpp , r -> bpp ) ; <NEW_LINE>temp += r -> bpp ; <NEW_LINE>count - = r -> bpp ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
uid = userToID ( owner ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> group = stok ( tok , ":" , & perms ) ; <NEW_LINE> <END_VULN> if ( group && * group ) { <NEW_LINE> if ( snumber ( group ) ) { <NEW_LINE> gid = ( int ) stoi ( group ) ;
png_ptr -> info_rowbytes = info_ptr -> rowbytes ; <NEW_LINE> #ifndef PNG_READ_EXPAND_SUPPORTED <NEW_LINE> <START_VULN> if ( png_ptr ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> #endif <NEW_LINE> }
case 3: <NEW_LINE> if ( memcmp ( argv [ i ] , "all" , 3 ) == 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> png_set_keep_unknown_chunks ( d -> png_ptr , option , NULL , - 1 ) ; <NEW_LINE> <END_VULN> d -> keep = option ; <NEW_LINE> for ( chunk = 0 ; chunk < NINFO ; ++ chunk )
uint32_t str_key_len , base_len = p_obj -> l ; <NEW_LINE> phar_entry_data * data ; <NEW_LINE> php_stream * fp ; <NEW_LINE> <START_VULN> php_stat_len fname_len ; <NEW_LINE> <END_VULN> size_t contents_len ; <NEW_LINE> char * fname , * error = NULL , * base = p_obj -> b , * save = NULL , * temp = NULL ; <NEW_LINE> zend_string * opened ;
efree ( error ) ; <NEW_LINE> goto valid_alias ; <NEW_LINE> } <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> RETURN_FALSE ; <NEW_LINE> }
#if defined ( PNG_READ_BACKGROUND_SUPPORTED ) || \ <NEW_LINE> defined ( PNG_READ_ALPHA_MODE_SUPPORTED ) || \ <NEW_LINE> defined ( PNG_READ_RGB_TO_GRAY_SUPPORTED ) <NEW_LINE> <START_VULN> if ( png_ptr -> transformations & ( PNG_COMPOSE | PNG_RGB_TO_GRAY ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_build_16bit_table ( png_ptr , & png_ptr -> gamma_16_to_1 , shift , <NEW_LINE> png_reciprocal ( png_ptr -> colorspace . gamma ) ) ;
} <NEW_LINE> NS_IMETHODIMP <NEW_LINE> SmsManager::Send ( const jsval & aNumber , const nsAString & aMessage , jsval * aReturn ) <NEW_LINE> { <NEW_LINE> nsresult rv ; <NEW_LINE> nsIScriptContext * sc = GetContextForEventHandlers ( & rv ) ; <NEW_LINE> NS_ENSURE_STATE ( sc ) ; <NEW_LINE> <START_VULN> JSContext * cx = sc -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( cx , "Failed to get a context ! " ) ; <NEW_LINE> if ( ! aNumber . isString ( ) && <NEW_LINE> ! ( aNumber . isObject ( ) && JS_IsArrayObject ( cx , & aNumber . toObject ( ) ) ) ) { <NEW_LINE> return NS_ERROR_INVALID_ARG ; <NEW_LINE> } <NEW_LINE> JSObject * global = sc -> GetNativeGlobal ( ) ;
TraceMonitor & localtm = * traceMonitor ; <NEW_LINE> JSContext * localcx = cx ; <NEW_LINE> JSObject * obj2 ; <NEW_LINE> JSProperty * prop ; <NEW_LINE> JSBool ok = obj -> lookupProperty ( cx , id , & obj2 , & prop ) ; <NEW_LINE> if ( ! localtm . recorder ) { <NEW_LINE> if ( prop ) <NEW_LINE> obj2 -> dropProperty ( localcx , prop ) ; <NEW_LINE> return ARECORD_ABORTED ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! ok ) <NEW_LINE>RETURN_ERROR_A ( "obj -> lookupProperty failed in JSOP_IN" ) ; <NEW_LINE> <END_VULN> bool cond = prop != NULL ; <NEW_LINE> if ( prop ) <NEW_LINE> obj2 -> dropProperty ( cx , prop ) ;
if ( all_in ) { <NEW_LINE> unsigned int sad_array [ 4 ] ; <NEW_LINE> <START_VULN> for ( j = 0 ; j < x -> searches_per_step ; j += 4 ) { <NEW_LINE> <END_VULN> unsigned char const * block_offset [ 4 ] ; <NEW_LINE> for ( t = 0 ; t < 4 ; t ++ )
#if ! defined ( LIBXML_STATIC ) <NEW_LINE> #define XMLPUBVAR __declspec ( dllimport ) extern <NEW_LINE> #else <NEW_LINE> <START_VULN> #define XMLPUBVAR <NEW_LINE> <END_VULN> #endif <NEW_LINE> #endif <NEW_LINE> #define XMLCALL __cdecl
static bool IsShowingTranslateInfobar ( TabContents * tab ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> static bool IsTranslatableURL ( const GURL & url ) ;
Node * VisibleSelection::nonBoundaryShadowTreeRootNode ( ) const <NEW_LINE> { <NEW_LINE> <START_VULN> return start ( ) . deprecatedNode ( ) ? start ( ) . deprecatedNode ( ) -> nonBoundaryShadowTreeRootNode ( ) : 0 ; <NEW_LINE> <END_VULN> } <NEW_LINE> VisibleSelection::ChangeObserver::ChangeObserver ( )
virtual bool ShouldBlockRequestByInspector ( const KURL & ) const = 0 ; <NEW_LINE> virtual void DispatchDidBlockRequest ( const ResourceRequest & , <NEW_LINE> const FetchInitiatorInfo & , <NEW_LINE> <START_VULN> ResourceRequestBlockedReason ) const = 0 ; <NEW_LINE> <END_VULN> virtual bool ShouldBypassMainWorldCSP ( ) const = 0 ; <NEW_LINE> virtual bool IsSVGImageChromeClient ( ) const = 0 ; <NEW_LINE> virtual bool ShouldBlockFetchByMixedContentCheck (
} <NEW_LINE> if ( discoverable ) { <NEW_LINE> <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <NEW_LINE> <END_VULN> fprintf ( stdout , "BT adapter is up\n" ) ; <NEW_LINE> bt_property_t * property = property_new_scan_mode ( BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE ) ;
RenderObject * child = firstChild ( ) ; <NEW_LINE> <START_VULN> ASSERT ( ! child || ! child -> isRubyText ( ) || ! child -> isFloatingOrPositioned ( ) ) ; <NEW_LINE> <END_VULN> return child && child -> isRubyText ( ) ? static_cast < RenderRubyText * > ( child ) : 0 ; <NEW_LINE> }
va_list ap ; <NEW_LINE> va_start ( ap , ctrl_id ) ; <NEW_LINE> <START_VULN> res = entry -> fn ( ctx -> priv -> alg_priv , ctrl_id , ap ) ; <NEW_LINE> <END_VULN> va_end ( ap ) ; <NEW_LINE> break ; <NEW_LINE> }
void NPP_Destroy ( ) ; <NEW_LINE> bool NPP_Print ( NPPrint * platform_print ) ; <NEW_LINE> <START_VULN> void SendJavaScriptStream ( const GURL & url , const std::string & result , <NEW_LINE>bool success , bool notify_needed , <NEW_LINE>intptr_t notify_data ) ; <NEW_LINE> <END_VULN> void DidReceiveManualResponse ( const GURL & url , <NEW_LINE> const std::string & mime_type ,
if ( paginationStrut ) { <NEW_LINE> <START_VULN> if ( atBeforeSideOfBlock && oldTop == result && ! isPositioned ( ) && ! isTableCell ( ) ) { <NEW_LINE> <END_VULN>
@param hash MprHash object <NEW_LINE> @return An MprJson instance <NEW_LINE> @ingroup MprJson <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC MprJson * mprHashToJson ( MprHash * hash ) ;
_retval . AppendInt ( length ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! nsContentUtils::IsCallerChrome ( ) && <NEW_LINE> <END_VULN> ( header . LowerCaseEqualsASCII ( "set - cookie" ) || <NEW_LINE> header . LowerCaseEqualsASCII ( "set - cookie2" ) ) ) { <NEW_LINE> NS_WARNING ( "blocked access to response header" ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> if ( mState & XML_HTTP_REQUEST_USE_XSITE_AC ) {
if ( exists ) { <NEW_LINE> rv = aFile -> GetFileSize ( & fileSize ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , nullptr ) ; <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> fileSize = 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>QuotaObject * quotaObject ; <NEW_LINE> <END_VULN> { <NEW_LINE> MutexAutoLock lock ( mQuotaMutex ) ; <NEW_LINE> GroupInfoPair * pair ; <NEW_LINE> if ( ! mGroupInfoPairs . Get ( aGroup , & pair ) ) { <NEW_LINE> return nullptr ; <NEW_LINE> }
static void CVE_2011_2536_transmit_fake_auth_response ( struct sip_pvt * p , int sipmethod , struct sip_request * req , enum xmittype reliable ) <NEW_LINE> { <NEW_LINE> <START_VULN> const char * response = "407 Proxy Authentication Required" ; <NEW_LINE>const char * reqheader = "Proxy - Authorization" ; <NEW_LINE>const char * respheader = "Proxy - Authenticate" ; <NEW_LINE> <END_VULN> const char * authtoken ; <NEW_LINE> struct ast_str * buf ; <NEW_LINE> char * c ;
int size = zmq_recv ( handler , client_key , 32 , 0 ) ; <NEW_LINE> assert ( size == 32 ) ; <NEW_LINE> <START_VULN> char client_key_text [ 40 ] ; <NEW_LINE> <END_VULN> zmq_z85_encode ( client_key_text , client_key , 32 ) ; <NEW_LINE> assert ( streq ( version , "1 . 0" ) ) ;
#include < string > <NEW_LINE> <START_VULN> #include "base / callback . h" <NEW_LINE> <END_VULN> #include "base / gtest_prod_util . h" <NEW_LINE> #include "content / browser / cancelable_request . h"
0 . 8928678298F , 0 . 9080153310F , 0 . 9217306608F , 0 . 9340480615F , <NEW_LINE> 0 . 9450138200F , 0 . 9546851041F , 0 . 9631286621F , 0 . 9704194171F , <NEW_LINE> 0 . 9766389810F , 0 . 9818741197F , 0 . 9862151938F , 0 . 9897546035F , <NEW_LINE> 0 . 9925852598F , 0 . 9947991032F , 0 . 9964856900F , 0 . 9977308602F , <NEW_LINE> 0 . 9986155015F , 0 . 9992144193F , 0 . 9995953200F , 0 . 9998179155F , <NEW_LINE> 0 . 9999331503F , 0 . 9999825563F , 0 . 9999977357F , 0 . 9999999720F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin256 [ 128 ] = { <NEW_LINE> <END_VULN> 0 . 0000591390F , 0 . 0005321979F , 0 . 0014780301F , 0 . 0028960636F , <NEW_LINE> 0 . 0047854363F , 0 . 0071449926F , 0 . 0099732775F , 0 . 0132685298F , <NEW_LINE> 0 . 0170286741F , 0 . 0212513119F , 0 . 0259337111F , 0 . 0310727950F , <NEW_LINE> 0 . 0366651302F , 0 . 0427069140F , 0 . 0491939614F , 0 . 0561216907F , <NEW_LINE> 0 . 0634851102F , 0 . 0712788035F , 0 . 0794969160F , 0 . 0881331402F ,
sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <NEW_LINE> image -> depth = 24 ; <NEW_LINE> image -> storage_class = PseudoClass ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) <NEW_LINE> { <NEW_LINE> sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ;
regs -> loadrs = 0 ; \ <NEW_LINE> regs -> r8 = get_dumpable ( current -> mm ) ; \ <NEW_LINE> regs -> r12 = new_sp - 16 ; \ <NEW_LINE> <START_VULN> if ( unlikely ( ! get_dumpable ( current -> mm ) ) ) { \ <NEW_LINE> <END_VULN>
return mChunkOffsetOffset >= 0 <NEW_LINE> && mSampleToChunkOffset >= 0 <NEW_LINE> && mSampleSizeOffset >= 0 <NEW_LINE> <START_VULN> && ! mTimeToSample . empty ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> status_t SampleTable::setChunkOffsetParams (
virtual void CastToReceiver ( const std::string & receiver_id ) = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>virtual void StopCasting ( const std::string & activity_id ) = 0 ; <NEW_LINE> <END_VULN> virtual void LaunchCastOptions ( ) = 0 ;
inet -> inet_daddr = daddr ; <NEW_LINE> inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ; <NEW_LINE> <START_VULN> if ( inet -> opt != NULL ) <NEW_LINE>inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; <NEW_LINE> <END_VULN>
{ <NEW_LINE> INC_STATS ( "DOM . DataView . getUint8" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> DataView * imp = V8DataView::toNative ( args . Holder ( ) ) ; <NEW_LINE> ExceptionCode ec = 0 ;
EXPECT_TRUE ( this -> SetCanonicalCookie ( <NEW_LINE> cs , <NEW_LINE> <START_VULN> base::MakeUnique < CanonicalCookie > ( <NEW_LINE> <END_VULN> "G" , "H" , http_foo_host , " / unique" , base::Time ( ) , base::Time ( ) , <NEW_LINE> base::Time ( ) , false , true , <NEW_LINE> CookieSameSite::DEFAULT_MODE , COOKIE_PRIORITY_DEFAULT ) ,
if ( size > ( MAX_SIZE_T - RESERVE_SIZE ) ) { <NEW_LINE> xmlGenericError ( xmlGenericErrorContext , <NEW_LINE> <START_VULN> "xmlMallocAtomicLoc : Unsigned overflow prevented\n" ) ; <NEW_LINE> <END_VULN> xmlMemoryDump ( ) ; <NEW_LINE> return ( NULL ) ; <NEW_LINE> }
} <NEW_LINE> is_foveon = 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 7493 "dcraw / dcraw . c" <NEW_LINE> <END_VULN>
} <NEW_LINE> } <NEW_LINE> mDelayedBlurFocusEvents . AppendElement ( <NEW_LINE> nsDelayedBlurOrFocusEvent ( aType , aPresShell , aDocument , eventTarget ) ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsCOMPtr < nsPresContext > presContext = aPresShell -> GetPresContext ( ) ; <NEW_LINE><NEW_LINE>nsEventStatus status = nsEventStatus_eIgnore ; <NEW_LINE>nsFocusEvent event ( PR_TRUE , aType ) ; <NEW_LINE>event . flags |= NS_EVENT_FLAG_CANT_BUBBLE ; <NEW_LINE>event . fromRaise = aWindowRaised ; <NEW_LINE><NEW_LINE>nsEventDispatcher::Dispatch ( aTarget , presContext , & event , nsnull , & status ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsFocusManager::ScrollIntoView ( nsIPresShell * aPresShell , <NEW_LINE> nsIContent * aContent , <NEW_LINE> PRUint32 aFlags ) <NEW_LINE> {
#define DEBUG_CheckUnwrapSafety ( obj , handler , origin , target ) { } <NEW_LINE> #endif <NEW_LINE> JSObject * <NEW_LINE> WrapperFactory::Rewrap ( JSContext * cx , JSObject * existing , JSObject * obj , <NEW_LINE> JSObject * wrappedProto , JSObject * parent , <NEW_LINE> unsigned flags ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! IsWrapper ( obj ) || <NEW_LINE>GetProxyHandler ( obj ) == & XrayWaiver || <NEW_LINE>js::GetObjectClass ( obj ) -> ext . innerObject , <NEW_LINE>"wrapped object passed to rewrap" ) ; <NEW_LINE>NS_ASSERTION ( JS_GetClass ( obj ) != & XrayUtils::HolderClass , "trying to wrap a holder" ) ; <NEW_LINE> <END_VULN> JSCompartment * origin = js::GetObjectCompartment ( obj ) ; <NEW_LINE> JSCompartment * target = js::GetContextCompartment ( cx ) ; <NEW_LINE> JSObject * proxyProto = wrappedProto ;
} <NEW_LINE> NS_IMETHODIMP <NEW_LINE> Navigator::Vibrate ( const jsval & aPattern , JSContext * cx ) <NEW_LINE> { <NEW_LINE> nsCOMPtr < nsPIDOMWindow > win = do_QueryReferent ( mWindow ) ; <NEW_LINE> NS_ENSURE_TRUE ( win , NS_OK ) ; <NEW_LINE> <START_VULN> nsIDOMDocument * domDoc = win -> GetExtantDocument ( ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( domDoc , NS_ERROR_FAILURE ) ; <NEW_LINE> bool hidden = true ; <NEW_LINE> domDoc -> GetMozHidden ( & hidden ) ; <NEW_LINE> if ( hidden ) { <NEW_LINE> return NS_OK ; <NEW_LINE> }
<START_VULN> #ifndef CHROME_BROWSER_CHROMEOS_AUDIO_MIXER_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_AUDIO_MIXER_H_ <NEW_LINE> <END_VULN> #pragma once <NEW_LINE> #include "base / basictypes . h"
failed ( FileError::SECURITY_ERR ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> ThreadableBlobRegistry::registerBlobURL ( scriptExecutionContext -> securityOrigin ( ) , m_urlForReading , blob -> url ( ) ) ; <NEW_LINE> <END_VULN> ResourceRequest request ( m_urlForReading ) ;
#ifndef VPX_VP8CX_H_ <NEW_LINE> #define VPX_VP8CX_H_ <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include " . / vp8 . h" <NEW_LINE>
strlcpy ( psz_share , psz_parser , sizeof ( psz_share ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> sprintf ( psz_remote , "\\\\ % s\\ % s" , psz_server , psz_share ) ; <NEW_LINE> <END_VULN> net_resource . lpRemoteName = psz_remote ; <NEW_LINE> i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ) ;
unsigned char decrypted [ sizeof ( VP8_BD_VALUE ) + 1 ] ; <NEW_LINE> if ( br -> decrypt_cb ) { <NEW_LINE> <START_VULN> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <NEW_LINE> <END_VULN> br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ; <NEW_LINE> bufptr = decrypted ; <NEW_LINE> }
If the original socket has an SSL configuration , the new socket will share the same SSL configuration object . <NEW_LINE> @return A new socket object <NEW_LINE> @ingroup MprSocket <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC MprSocket * mprCloneSocket ( MprSocket * sp ) ;
} <NEW_LINE> size_offsets = ( size_offsets + 1 ) * 3 ; <NEW_LINE> offsets = ( int * ) safe_emalloc ( size_offsets , sizeof ( int ) , 0 ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> array_init ( return_value ) ;
if ( ( entry -> flags & SC_ASN1_UNSIGNED ) <NEW_LINE> <START_VULN> && obj [ 0 ] == 0x00 && objlen > 1 ) { <NEW_LINE> <END_VULN> objlen -- ; <NEW_LINE> obj ++ ; <NEW_LINE> }
#define QINDEX_RANGE ( MAXQ - MINQ + 1 ) <NEW_LINE> #define QINDEX_BITS 8 <NEW_LINE> <START_VULN> void vp9_init_quant_tables ( ) ; <NEW_LINE><NEW_LINE>int16_t vp9_dc_quant ( int qindex , int delta ) ; <NEW_LINE>int16_t vp9_ac_quant ( int qindex , int delta ) ; <NEW_LINE> <END_VULN> int vp9_get_qindex ( const struct segmentation * seg , int segment_id , <NEW_LINE> int base_qindex ) ;
nsAString & aDest ) <NEW_LINE> { <NEW_LINE> nsAString::iterator writer ; <NEW_LINE> <START_VULN> aDest . SetLength ( Distance ( aSrcStart , aSrcEnd ) ) ; <NEW_LINE> <END_VULN> aDest . BeginWriting ( writer ) ; <NEW_LINE> nsScannerIterator fromBegin ( aSrcStart ) ;
IPC_SYNC_MESSAGE_ROUTED2_1 ( PrintHostMsg_CheckForCancel , <NEW_LINE> <START_VULN> std::string , <NEW_LINE> <END_VULN> int , <NEW_LINE> bool )
const KURL & base_url = source_code . Url ( ) ; <NEW_LINE> <START_VULN> return ClassicScript::Create ( source_code , base_url , options_ , <NEW_LINE>resource -> CalculateAccessControlStatus ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void ClassicPendingScript::SetStreamer ( ScriptStreamer * streamer ) {
if ( page == active_frame . GetPage ( ) ) <NEW_LINE> page -> GetFocusController ( ) . SetFocusedFrame ( frame ) ; <NEW_LINE> else <NEW_LINE> <START_VULN> page -> GetChromeClient ( ) . Focus ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> return frame ;
case '7': case '8': case '9': <NEW_LINE> case ' + ': case ' - ': case ' . ': <NEW_LINE> if ( state -> ptr == tmp ) { <NEW_LINE> <START_VULN> return tmp ; <NEW_LINE> <END_VULN> } <NEW_LINE> case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':
{ <NEW_LINE> char * old = x -> ptr ; <NEW_LINE> int newlen ; <NEW_LINE> <START_VULN> newlen = x -> length * 6 / 5 ; <NEW_LINE>if ( newlen == x -> length ) <NEW_LINE> <END_VULN> newlen += 2 ; <NEW_LINE> x -> ptr = GC_MALLOC_ATOMIC ( newlen ) ; <NEW_LINE> x -> area_size = newlen ;
} <NEW_LINE> while ( power > 0 ) ; <NEW_LINE> <START_VULN> if ( recip ) d = 1 / d ; <NEW_LINE> <END_VULN> }
continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) { <NEW_LINE> <END_VULN> continue ; <NEW_LINE> }
{ <NEW_LINE> png_debug ( 1 , "in png_set_scale_16" ) ; <NEW_LINE> <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> png_ptr -> transformations |= PNG_SCALE_16_TO_8 ;
<START_VULN> mBuf . SetCapacity ( len + aCount + 1 ) ; <NEW_LINE>if ( ! mBuf . get ( ) ) <NEW_LINE> <END_VULN> return NS_ERROR_OUT_OF_MEMORY ;
bool feature_enabled ( ) const { <NEW_LINE> <START_VULN> return voice_interaction_enabled_ && voice_interaction_context_enabled_ ; <NEW_LINE> <END_VULN> }
} <NEW_LINE> JSObject * workerProto = worker::InitClass ( aCx , global , eventTargetProto , <NEW_LINE> false ) ; <NEW_LINE> if ( ! workerProto ) { <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( worker -> IsChromeWorker ( ) && <NEW_LINE> ( ! chromeworker::InitClass ( aCx , global , workerProto , false ) || <NEW_LINE> ! DefineChromeWorkerFunctions ( aCx , global ) ) ) { <NEW_LINE>return NULL ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( ! DefineOSFileConstants ( aCx , global ) ) { <NEW_LINE>return NULL ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! events::InitClasses ( aCx , global , false ) || <NEW_LINE> ! file::InitClasses ( aCx , global ) || <NEW_LINE> ! exceptions::InitClasses ( aCx , global ) || <NEW_LINE> ! location::InitClass ( aCx , global ) || <NEW_LINE> ! imagedata::InitClass ( aCx , global ) ||
<START_VULN> WindowsArchitecture GetWindowsArchitecture ( ) ; <NEW_LINE> <END_VULN> enum WOW64Status { <NEW_LINE> WOW64_DISABLED ,
case eTreeOpAppend: { <NEW_LINE> nsIContent * node = * ( mOne . node ) ; <NEW_LINE> nsIContent * parent = * ( mTwo . node ) ; <NEW_LINE> return Append ( node , parent , aBuilder ) ; <NEW_LINE> } <NEW_LINE> case eTreeOpDetach: { <NEW_LINE> nsIContent * node = * ( mOne . node ) ; <NEW_LINE> aBuilder -> FlushPendingAppendNotifications ( ) ; <NEW_LINE> <START_VULN> nsCOMPtr < nsIContent > parent = node -> GetParent ( ) ; <NEW_LINE> <END_VULN> if ( parent ) { <NEW_LINE> nsHtml5OtherDocUpdate update ( parent -> OwnerDoc ( ) , <NEW_LINE> aBuilder -> GetDocument ( ) ) ; <NEW_LINE> int32_t pos = parent -> IndexOf ( node ) ; <NEW_LINE> NS_ASSERTION ( ( pos >= 0 ) , "Element not found as child of its parent" ) ; <NEW_LINE> parent -> RemoveChildAt ( pos , true ) ; <NEW_LINE> } <NEW_LINE> return NS_OK ;
if ( instrumentedProfiling ( ) ) <NEW_LINE> predecessor -> add ( MFunctionBoundary::New ( script ( ) , <NEW_LINE> MFunctionBoundary::Inline_Enter , <NEW_LINE> <START_VULN> inliningDepth ) ) ; <NEW_LINE> <END_VULN> predecessor -> end ( MGoto::New ( current ) ) ; <NEW_LINE> if ( ! current -> addPredecessorWithoutPhis ( predecessor ) ) <NEW_LINE> return false ; <NEW_LINE> JS_ASSERT ( inlinedArguments_ . length ( ) == 0 ) ;
stateEnum state ( ) { return state_ ; } <NEW_LINE> CSecurity * csecurity ; <NEW_LINE> <START_VULN> SecurityClient * security ; <NEW_LINE> <END_VULN> protected: <NEW_LINE> void setState ( stateEnum s ) { state_ = s ; }
"menu" , "p" , "head" , "ul" , NULL , <NEW_LINE> "p" , "p" , "head" , "h1" , "h2" , "h3" , "h4" , "h5" , "h6" , FONTSTYLE , NULL , <NEW_LINE> "div" , "p" , "head" , NULL , <NEW_LINE> <START_VULN> "noscript" , "p" , NULL , <NEW_LINE> <END_VULN> "center" , "font" , "b" , "i" , "p" , "head" , NULL , <NEW_LINE> "a" , "a" , "head" , NULL , <NEW_LINE> "caption" , "p" , NULL ,
<START_VULN> Result AskUserForSettings ( gfx::NativeWindow window , int max_pages , <NEW_LINE> <END_VULN> bool has_selection ) ;
shift [ channels ++ ] = bit_depth - sig_bits -> gray ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( color_type & PNG_COLOR_MASK_ALPHA ) <NEW_LINE> <END_VULN> { <NEW_LINE> shift [ channels ++ ] = bit_depth - sig_bits -> alpha ; <NEW_LINE> }
if ( touchedElement != currentFocusElement ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> LayoutPoint contentPos ( m_webPage -> mapFromViewportToContents ( point ) ) ; <NEW_LINE> <END_VULN> contentPos = DOMSupport::convertPointToFrame ( m_webPage -> mainFrame ( ) , m_webPage -> focusedOrMainFrame ( ) , roundedIntPoint ( contentPos ) ) ; <NEW_LINE> Document * document = currentFocusElement -> document ( ) ;
} <NEW_LINE> } <NEW_LINE> void <NEW_LINE> gfxFont::SanitizeMetrics ( gfxFont::Metrics * aMetrics , bool aIsBadUnderlineFont ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( mStyle . size == 0 ) { <NEW_LINE> <END_VULN> memset ( aMetrics , 0 , sizeof ( gfxFont::Metrics ) ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> if ( aMetrics -> superscriptOffset <= 0 ||
spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> char * path ; <NEW_LINE> int path_len ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; <NEW_LINE> if ( body_size > job_data_size_limit ) { <NEW_LINE> <START_VULN> return reply_msg ( c , MSG_JOB_TOO_BIG ) ; <NEW_LINE> <END_VULN> }
rootingUnnecessary ( false ) , <NEW_LINE> #endif <NEW_LINE> compartment ( NULL ) , <NEW_LINE> enterCompartmentDepth_ ( 0 ) , <NEW_LINE> savedFrameChains_ ( ) , <NEW_LINE> defaultCompartmentObject_ ( NULL ) , <NEW_LINE> stack ( thisDuringConstruction ( ) ) , <NEW_LINE> parseMapPool_ ( NULL ) , <NEW_LINE> <START_VULN> sharpObjectMap ( thisDuringConstruction ( ) ) , <NEW_LINE> <END_VULN> argumentFormatMap ( NULL ) , <NEW_LINE> lastMessage ( NULL ) , <NEW_LINE> errorReporter ( NULL ) , <NEW_LINE> operationCallback ( NULL ) , <NEW_LINE> data ( NULL ) , <NEW_LINE> data2 ( NULL ) , <NEW_LINE> #ifdef JS_THREADSAFE <NEW_LINE> outstandingRequests ( 0 ) ,
clearDescendantsHaveSameLineHeightAndBaseline ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! child -> renderer ( ) -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> if ( child -> isText ( ) ) { <NEW_LINE> RenderStyle * childStyle = child -> renderer ( ) -> style ( isFirstLineStyle ( ) ) ; <NEW_LINE> if ( childStyle -> letterSpacing ( ) < 0 || childStyle -> textShadow ( ) || childStyle -> textEmphasisMark ( ) != TextEmphasisMarkNone || childStyle -> textStrokeWidth ( ) )
JSValue JSWebKitMutationObserver::observe ( ExecState * exec ) <NEW_LINE> { <NEW_LINE> if ( exec -> argumentCount ( ) < 2 ) <NEW_LINE> <START_VULN> return throwError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> Node * target = toNode ( exec -> argument ( 0 ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return jsUndefined ( ) ;
class nsIDOMNodeList ; <NEW_LINE> class mozAutoSubtreeModified ; <NEW_LINE> struct JSObject ; <NEW_LINE> class nsFrameLoader ; <NEW_LINE> class nsIBoxObject ; <NEW_LINE> #define NS_IDOCUMENT_IID \ <NEW_LINE> <START_VULN> { 0x2ca82a51 , 0x4a6a , 0x4dfa , \ <NEW_LINE> { 0xa6 , 0x5f , 0x49 , 0x52 , 0xa3 , 0xaa , 0x02 , 0xef } } <NEW_LINE> <END_VULN> #define NS_STYLESHEET_FROM_CATALOG ( 1 << 0 )
return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 860 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy39: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych == ' + ' ) goto yy40 ;
} <NEW_LINE> nsresult <NEW_LINE> PresShell::ReconstructFrames ( void ) <NEW_LINE> { <NEW_LINE> if ( ! mPresContext || ! mPresContext -> IsDynamic ( ) ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE> <END_VULN> mFrameConstructor -> BeginUpdate ( ) ; <NEW_LINE> nsresult rv = mFrameConstructor -> ReconstructDocElementHierarchy ( ) ; <NEW_LINE> VERIFY_STYLE_TREE ; <NEW_LINE> mFrameConstructor -> EndUpdate ( ) ; <NEW_LINE> return rv ; <NEW_LINE> }
#include "base / observer_list . h" <NEW_LINE> #include "base / time . h" <NEW_LINE> #include "base / timer . h" <NEW_LINE> <START_VULN> #include "third_party / cros / chromeos_input_method . h" <NEW_LINE> <END_VULN> namespace chromeos {
<START_VULN> #ifndef BASE_SAFE_CONVERSIONS_IMPL_H_ <NEW_LINE>#define BASE_SAFE_CONVERSIONS_IMPL_H_ <NEW_LINE> <END_VULN> #include < limits >
phar_flush ( entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> } <NEW_LINE> RETURN_TRUE ;
bool selection_did_not_change_dom_position = <NEW_LINE> new_selection == GetFrame ( ) . Selection ( ) . GetSelectionInDOMTree ( ) ; <NEW_LINE> GetFrame ( ) . Selection ( ) . SetSelection ( <NEW_LINE> <START_VULN> SelectionInDOMTree::Builder ( new_selection ) <NEW_LINE> . SetIsHandleVisible ( GetFrame ( ) . Selection ( ) . IsHandleVisible ( ) ) <NEW_LINE> . Build ( ) , <NEW_LINE>options ) ; <NEW_LINE> <END_VULN>
PHP_NAMED_FUNCTION ( zif_locale_set_default ) <NEW_LINE> { <NEW_LINE> char * locale_name = NULL ; <NEW_LINE> <START_VULN> int len = 0 ; <NEW_LINE> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "s" , <NEW_LINE> & locale_name , & len ) == FAILURE )
const_cast < jsbytecode * > ( emptyScriptCode ) , <NEW_LINE> 1 , JSVERSION_DEFAULT , 0 , 0 , 0 , 0 , 0 , 0 , 0 , true , false , false , false , false , <NEW_LINE> false , <NEW_LINE> false , <NEW_LINE> true , <NEW_LINE> #ifdef JS_METHODJIT <NEW_LINE> false , <NEW_LINE> #endif <NEW_LINE> const_cast < jsbytecode * > ( emptyScriptCode ) , <NEW_LINE> <START_VULN> { 0 , NULL } , NULL , NULL , 0 , 0 , 0 , <NEW_LINE> <END_VULN> 0 , <NEW_LINE> 0 , <NEW_LINE> NULL , { NULL } , <NEW_LINE> #ifdef CHECK_SCRIPT_OWNER <NEW_LINE> reinterpret_cast < JSThread * > ( 1 ) <NEW_LINE> #endif <NEW_LINE> } ; <NEW_LINE> #if JS_HAS_XDR
ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( prev_slice_err == 1 ) <NEW_LINE> {
} <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSBool ok = ::JS_DefineUCProperty ( cx , obj , ::JS_GetStringChars ( str ) , <NEW_LINE> ::JS_GetStringLength ( str ) , v , nsnull , <NEW_LINE> <START_VULN> nsnull , JSPROP_ENUMERATE ) ; <NEW_LINE> <END_VULN> if ( ! ok ) { <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> * objp = obj ; <NEW_LINE> return NS_OK ;
void V8RecursionScope::didLeaveScriptContext ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> Microtask::performCheckpoint ( ) ; <NEW_LINE> <END_VULN> V8PerIsolateData::from ( m_isolate ) -> runEndOfScopeTasks ( ) ; <NEW_LINE> }
void CVE_2011_3003_CopySubDataIfElementArray ( GLuint byteOffset , GLuint byteLength , const void * data ) { <NEW_LINE> <START_VULN> if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER ) { <NEW_LINE> <END_VULN> memcpy ( ( void * ) ( size_t ( mData ) + byteOffset ) , data , byteLength ) ; <NEW_LINE> } <NEW_LINE> }
typedef struct { <NEW_LINE> void ( * pack ) ( vorbis_info_floor * , oggpack_buffer * ) ; <NEW_LINE> vorbis_info_floor * ( * unpack ) ( vorbis_info * , oggpack_buffer * ) ; <NEW_LINE> vorbis_look_floor * ( * look ) ( vorbis_dsp_state * , vorbis_info_floor * ) ; <NEW_LINE> void ( * free_info ) ( vorbis_info_floor * ) ; <NEW_LINE> void ( * free_look ) ( vorbis_look_floor * ) ; <NEW_LINE> void * ( * inverse1 ) ( struct vorbis_block * , vorbis_look_floor * ) ; <NEW_LINE> int ( * inverse2 ) ( struct vorbis_block * , vorbis_look_floor * , <NEW_LINE> <START_VULN> void * buffer , float * ) ; <NEW_LINE> <END_VULN> } vorbis_func_floor ; <NEW_LINE> typedef struct { <NEW_LINE> int order ; <NEW_LINE> long rate ; <NEW_LINE> long barkmap ; <NEW_LINE> int ampbits ;
virtual void SendJavaScriptStream ( const GURL & url , <NEW_LINE> const std::string & result , <NEW_LINE> <START_VULN> bool success , bool notify_needed , <NEW_LINE>intptr_t notify_data ) = 0 ; <NEW_LINE> <END_VULN> virtual void DidReceiveManualResponse ( const GURL & url ,
unsigned char * buf ; <NEW_LINE> <START_VULN> if ( chunk_num > chm -> num_chunks ) return NULL ; <NEW_LINE> <END_VULN> if ( ! chm -> chunk_cache ) {
paramString . Length ( ) - <NEW_LINE> mozParseOptions . Length ( ) ) ; <NEW_LINE> params . Append ( parseOptions ) ; <NEW_LINE> usingCustomParseOptions = true ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIInputStream > stream ; <NEW_LINE> <START_VULN> nsresult rv = ExtractData ( type , params , getter_AddRefs ( stream ) , <NEW_LINE>fallbackToPNG ) ; <NEW_LINE> <END_VULN> if ( rv == NS_ERROR_INVALID_ARG && usingCustomParseOptions ) { <NEW_LINE> fallbackToPNG = false ; <NEW_LINE> rv = ExtractData ( type , EmptyString ( ) , getter_AddRefs ( stream ) , fallbackToPNG ) ; <NEW_LINE> }
} <NEW_LINE> bool AXNodeObject::canSetValueAttribute ( ) const { <NEW_LINE> <START_VULN> if ( equalIgnoringCase ( getAttribute ( aria_readonlyAttr ) , "true" ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> if ( isProgressIndicator ( ) || isSlider ( ) )
xd -> dst . u_buffer = dst_buffer [ 1 ] + recon_uvoffset ; <NEW_LINE> xd -> dst . v_buffer = dst_buffer [ 2 ] + recon_uvoffset ; <NEW_LINE> <START_VULN> xd -> pre . y_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 0 ] + recon_yoffset ; <NEW_LINE>xd -> pre . u_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 1 ] + recon_uvoffset ; <NEW_LINE>xd -> pre . v_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 2 ] + recon_uvoffset ; <NEW_LINE> <END_VULN> xd -> corrupted |= ref_fb_corrupted [ xd -> mode_info_context -> mbmi . ref_frame ] ;
mFrames . AppendFrames ( this , overflowFrames ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> if ( IsFrameTreeTooDeep ( aReflowState , aMetrics ) ) { <NEW_LINE>aStatus = NS_FRAME_COMPLETE ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> InlineReflowState irs ; <NEW_LINE> irs . mPrevFrame = nsnull ; <NEW_LINE> irs . mLineContainer = lineContainer ;
#ifdef DEBUG <NEW_LINE> JSContext * top = nsContentUtils::GetCurrentJSContext ( ) ; <NEW_LINE> NS_ASSERTION ( mContext == top , "Context not properly pushed ! " ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> JSAutoRequest ar ( mContext ) ; <NEW_LINE> <END_VULN> JSFunction * fun = <NEW_LINE> ::JS_CompileUCFunctionForPrincipalsVersion ( mContext , <NEW_LINE> nsnull , nsnull , <NEW_LINE> nsAtomCString ( aName ) . get ( ) , aArgCount , aArgNames , <NEW_LINE> ( jschar * ) PromiseFlatString ( aBody ) . get ( ) , <NEW_LINE> aBody . Length ( ) , <NEW_LINE> aURL , aLineNo , JSVersion ( aVersion ) ) ;
} <NEW_LINE> virtual void didProcessTask ( ) override <NEW_LINE> { <NEW_LINE> <START_VULN> Microtask::performCheckpoint ( ) ; <NEW_LINE> <END_VULN> V8GCController::reportDOMMemoryUsageToV8 ( mainThreadIsolate ( ) ) ; <NEW_LINE> V8Initializer::reportRejectedPromisesOnMainThread ( ) ; <NEW_LINE> }
RANGE_CHECK_HI ( cfg , ts_periodicity , 16 ) ; <NEW_LINE> for ( i = 1 ; i < cfg -> ts_number_layers ; i ++ ) <NEW_LINE> <START_VULN> if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] ) <NEW_LINE> <END_VULN> ERROR ( "ts_target_bitrate entries are not strictly increasing" ) ; <NEW_LINE> RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ;
} <NEW_LINE> } <NEW_LINE> void disjunction ( ) <NEW_LINE> { <NEW_LINE> m_alternative = m_alternative -> m_parent -> addNewAlternative ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> unsigned setupAlternativeOffsets ( PatternAlternative * alternative , unsigned currentCallFrameSize , unsigned initialInputPosition ) <NEW_LINE> <END_VULN> { <NEW_LINE> alternative -> m_hasFixedSize = true ; <NEW_LINE> unsigned currentInputPosition = initialInputPosition ; <NEW_LINE> for ( unsigned i = 0 ; i < alternative -> m_terms . size ( ) ; ++ i ) { <NEW_LINE> PatternTerm & term = alternative -> m_terms [ i ] ; <NEW_LINE> switch ( term . type ) {
Variant & v = arr1 . lvalAt ( key , AccessFlags::Key ) ; <NEW_LINE> auto subarr1 = v . toArray ( ) . copy ( ) ; <NEW_LINE> <START_VULN> php_array_merge_recursive ( seen , v . isReferenced ( ) , subarr1 , <NEW_LINE> <END_VULN> value . toArray ( ) ) ; <NEW_LINE> v . unset ( ) ; <NEW_LINE> v = subarr1 ;
assert ( comp != 0 ) ; <NEW_LINE> <START_VULN> vp9_write ( w , sign , mvcomp -> sign ) ; <NEW_LINE> <END_VULN> vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes ,
if ( ( ~ tc -> flags & ( TCF_RETURN_EXPR | TCF_FUN_IS_GENERATOR ) ) == 0 ) { <NEW_LINE> <START_VULN> ReportBadReturn ( context , tc , JSREPORT_ERROR , <NEW_LINE> <END_VULN> JSMSG_BAD_GENERATOR_RETURN , <NEW_LINE> JSMSG_BAD_ANON_GENERATOR_RETURN ) ; <NEW_LINE> return NULL ;
} else { <NEW_LINE> goto next_specialization ; <NEW_LINE> } <NEW_LINE> argp -- ; <NEW_LINE> } <NEW_LINE> #if defined DEBUG <NEW_LINE> JS_ASSERT ( args [ 0 ] != ( LIns * ) 0xcdcdcdcd ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> return emitNativeCall ( sn , argc , args ) ; <NEW_LINE> <END_VULN> next_specialization: ; <NEW_LINE> } while ( ( sn ++ ) -> flags & JSTN_MORE ) ; <NEW_LINE> return JSRS_STOP ; <NEW_LINE> } <NEW_LINE> JS_REQUIRES_STACK JSRecordingStatus
int channels = 0 ; <NEW_LINE> int bit_depth = row_info -> bit_depth ; <NEW_LINE> <START_VULN> if ( color_type & PNG_COLOR_MASK_COLOR ) <NEW_LINE> <END_VULN> { <NEW_LINE> shift [ channels ++ ] = bit_depth - sig_bits -> red ; <NEW_LINE> shift [ channels ++ ] = bit_depth - sig_bits -> green ;
{ <NEW_LINE> if ( ( const u_char * ) ( lshp + 1 ) > dataend ) <NEW_LINE> goto trunc ; <NEW_LINE> <START_VULN> ND_TCHECK ( lshp -> ls_type ) ; <NEW_LINE>ND_TCHECK ( lshp -> ls_seq ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , "\n\t Advertising Router % s , seq 0x % 08x , age % us , length % u" , <NEW_LINE> ipaddr_string ( ndo , & lshp -> ls_router ) ,
} else { <NEW_LINE> errnum = anonerrnum ; <NEW_LINE> } <NEW_LINE> <START_VULN> return ReportCompileErrorNumber ( cx , TS ( tc -> parser ) , NULL , flags , errnum , name . ptr ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static JSBool
ScaleQuantumToLong ( GetPixelGreen ( image , p ) ) , <NEW_LINE> ScaleQuantumToLong ( GetPixelBlue ( image , p ) ) ) ; <NEW_LINE> extent = ( size_t ) count ; <NEW_LINE> <START_VULN> ( void ) strncpy ( ( char * ) q , buffer , extent ) ; <NEW_LINE>q += extent ; <NEW_LINE> <END_VULN> if ( ( q - pixels + extent + 2 ) >= sizeof ( pixels ) ) <NEW_LINE> { <NEW_LINE> * q ++ = '\n' ; <NEW_LINE> ( void ) WriteBlob ( image , q - pixels , pixels ) ; <NEW_LINE> q = pixels ; <NEW_LINE> } <NEW_LINE> p += GetPixelChannels ( image ) ; <NEW_LINE> } <NEW_LINE> * q ++ = '\n' ;
<START_VULN> CopyPixels ( clone_info -> pixels , cache_info -> pixels , cache_info -> columns * <NEW_LINE>cache_info -> rows ) ; <NEW_LINE> <END_VULN> if ( ( cache_info -> active_index_channel != MagickFalse ) && <NEW_LINE> ( clone_info -> active_index_channel != MagickFalse ) ) <NEW_LINE> ( void ) memcpy ( clone_info -> indexes , cache_info -> indexes ,
return NS_ERROR_DOM_SECURITY_ERR ; <NEW_LINE> nsCOMPtr < nsIPrincipal > origPrincipal = origDocument -> NodePrincipal ( ) ; <NEW_LINE> scContainer = new nsStructuredCloneContainer ( ) ; <NEW_LINE> JSContext * cx = aCx ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> if ( ! cx ) { <NEW_LINE> cx = nsContentUtils::GetContextFromDocument ( document ) ; <NEW_LINE> <START_VULN> pusher . Push ( cx , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> rv = scContainer -> InitFromVariant ( aData , cx ) ; <NEW_LINE> if ( NS_FAILED ( rv ) && ! aCx ) { <NEW_LINE> JS_ClearPendingException ( aCx ) ; <NEW_LINE> }
const nsPromiseFlatCString & username = PromiseFlatCString ( input ) ; <NEW_LINE> LOG ( ( "nsStandardURL::SetUsername [ username = % s ] \n" , username . get ( ) ) ) ; <NEW_LINE> if ( mURLType == URLTYPE_NO_AUTHORITY ) { <NEW_LINE> if ( username . IsEmpty ( ) ) <NEW_LINE> return NS_OK ; <NEW_LINE> <START_VULN> NS_ERROR ( "cannot set username on no - auth url" ) ; <NEW_LINE> <END_VULN> return NS_ERROR_UNEXPECTED ; <NEW_LINE> } <NEW_LINE> if ( username . IsEmpty ( ) ) <NEW_LINE> return SetUserPass ( username ) ; <NEW_LINE> InvalidateCache ( ) ;
{ <NEW_LINE> struct crypto_report_blkcipher rblkcipher ; <NEW_LINE> <START_VULN> snprintf ( rblkcipher . type , CRYPTO_MAX_ALG_NAME , " % s" , "givcipher" ) ; <NEW_LINE>snprintf ( rblkcipher . geniv , CRYPTO_MAX_ALG_NAME , " % s" , <NEW_LINE>alg -> cra_ablkcipher . geniv ? : " < built - in > " ) ; <NEW_LINE> <END_VULN> rblkcipher . blocksize = alg -> cra_blocksize ; <NEW_LINE> rblkcipher . min_keysize = alg -> cra_ablkcipher . min_keysize ;
} <NEW_LINE> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , <NEW_LINE> cpi -> mb . mvcost , 128 ) ;
if ( unlikely ( error_code & PF_RSVD ) ) <NEW_LINE> pgtable_bad ( regs , error_code , address ) ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN>
copy -> stackDepth = 0 ; <NEW_LINE> copy -> exnType = priv -> exnType ; <NEW_LINE> JSObject * proto ; <NEW_LINE> if ( ! js_GetClassPrototype ( cx , scope -> getGlobal ( ) , GetExceptionProtoKey ( copy -> exnType ) , & proto ) ) <NEW_LINE> return NULL ; <NEW_LINE> JSObject * copyobj = NewObjectWithGivenProto ( cx , & ErrorClass , proto , NULL ) ; <NEW_LINE> <START_VULN> copyobj -> setPrivate ( copy ) ; <NEW_LINE> <END_VULN> autoFree . p = NULL ; <NEW_LINE> return copyobj ; <NEW_LINE> }
void <NEW_LINE> nsSMILAnimationController::NotifyRefreshDriverCreated ( <NEW_LINE> nsRefreshDriver * aRefreshDriver ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! mPauseState && ! mDeferredStartSampling ) { <NEW_LINE>StartSampling ( aRefreshDriver ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsSMILAnimationController::NotifyRefreshDriverDestroying ( <NEW_LINE> nsRefreshDriver * aRefreshDriver ) <NEW_LINE> { <NEW_LINE> if ( ! mPauseState && ! mDeferredStartSampling ) {
x1ul = x1 - half ; <NEW_LINE> y1ul = y1 - half ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> x2lr = x2 + half ; <NEW_LINE> y2lr = y2 + half ;
nsCOMPtr < nsIScriptElement > oldCurrent = mCurrentScript ; <NEW_LINE> mCurrentScript = aRequest -> mElement ; <NEW_LINE> nsCAutoString url ; <NEW_LINE> nsContentUtils::GetWrapperSafeScriptFilename ( mDocument , uri , url ) ; <NEW_LINE> bool isUndefined ; <NEW_LINE> rv = context -> EvaluateString ( aScript , globalObject -> GetGlobalJSObject ( ) , <NEW_LINE> <START_VULN> mDocument -> NodePrincipal ( ) , url . get ( ) , <NEW_LINE>aRequest -> mLineNo , aRequest -> mJSVersion , nsnull , <NEW_LINE> & isUndefined ) ; <NEW_LINE> <END_VULN> mCurrentScript = oldCurrent ; <NEW_LINE> JSContext * cx = nsnull ; <NEW_LINE> if ( stid == nsIProgrammingLanguage::JAVASCRIPT ) { <NEW_LINE> cx = context -> GetNativeContext ( ) ; <NEW_LINE> ::JS_BeginRequest ( cx ) ;
x = vpx_memalign ( DEFAULT_ALIGNMENT , num * size ) ; <NEW_LINE> if ( x ) <NEW_LINE> <START_VULN> VPX_MEMSET_L ( x , 0 , num * size ) ; <NEW_LINE> <END_VULN> return x ; <NEW_LINE> }
if ( info -> register_invocation ) { <NEW_LINE> info -> connection = connection ; <NEW_LINE> <START_VULN> tcmur_register_handler ( handler ) ; <NEW_LINE> <END_VULN> dbus_export_handler ( handler , G_CALLBACK ( on_dbus_check_config ) ) ; <NEW_LINE> g_dbus_method_invocation_return_value ( info -> register_invocation , <NEW_LINE> g_variant_new ( " ( bs ) " , TRUE , "succeeded" ) ) ;
jpc_ms_dump ( ms , stderr ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( JAS_CAST ( ulong , jas_stream_tell ( tmpstream ) ) != ms -> len ) { <NEW_LINE> <END_VULN> jas_eprintf ( <NEW_LINE> "warning: trailing garbage in marker segment ( % ld bytes ) \n" , <NEW_LINE> ms -> len - jas_stream_tell ( tmpstream ) ) ;
#endif <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> class BASE_EXPORT Win32StackFrameUnwinder { <NEW_LINE> public:
xmlParserInputBufferPtr ret ; <NEW_LINE> int errcode ; <NEW_LINE> <START_VULN> if ( size <= 0 ) return ( NULL ) ; <NEW_LINE> <END_VULN> if ( mem == NULL ) return ( NULL ) ; <NEW_LINE> ret = xmlAllocParserInputBuffer ( enc ) ;
{ <NEW_LINE> OwnPtr < GIFImageDecoder > decoder = createDecoder ( ) ; <NEW_LINE> <START_VULN> RefPtr < SharedBuffer > data = readFile ( " / LayoutTests / fast / images / resources / animated . gif" ) ; <NEW_LINE> <END_VULN> ASSERT_TRUE ( data . get ( ) ) ; <NEW_LINE> size_t frameCount = 0 ;
encode_frame ( & codec , & raw , frame_count ++ , writer ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> encode_frame ( & codec , NULL , - 1 , writer ) ; <NEW_LINE> <END_VULN> printf ( "\n" ) ; <NEW_LINE> fclose ( infile ) ;
return regs -> ARM_r0 ; <NEW_LINE> case NR ( set_tls ) : <NEW_LINE> <START_VULN> thread -> tp_value = regs -> ARM_r0 ; <NEW_LINE> <END_VULN> if ( tls_emu ) <NEW_LINE> return 0 ; <NEW_LINE> if ( has_tls_reg ) {
UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; <NEW_LINE> UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; <NEW_LINE> UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <NEW_LINE> <START_VULN> WORD16 i2_level_arr [ 4 ] ; <NEW_LINE> <END_VULN> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; <NEW_LINE> WORD16 * pi2_coeff_data ;
extern void ipx_print ( netdissect_options * , const u_char * , u_int ) ; <NEW_LINE> extern void isakmp_print ( netdissect_options * , const u_char * , u_int , const u_char * ) ; <NEW_LINE> extern void isakmp_rfc3948_print ( netdissect_options * , const u_char * , u_int , const u_char * ) ; <NEW_LINE> <START_VULN> extern void isoclns_print ( netdissect_options * , const u_char * , u_int , u_int ) ; <NEW_LINE> <END_VULN> extern void krb_print ( netdissect_options * , const u_char * ) ; <NEW_LINE> extern void l2tp_print ( netdissect_options * , const u_char * , u_int ) ; <NEW_LINE> extern void lane_print ( netdissect_options * , const u_char * , u_int , u_int ) ;
static void copyStereo24 ( <NEW_LINE> short * dst , <NEW_LINE> <START_VULN> const int * const * src , <NEW_LINE> <END_VULN> unsigned nSamples , <NEW_LINE> unsigned ) { <NEW_LINE> for ( unsigned i = 0 ; i < nSamples ; ++ i ) {
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File: file . c , v 1 . 158 2014 / 11 / 28 02:35:05 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include "magic . h"
d . Clear ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> delete [ ] displays_ ; <NEW_LINE> <END_VULN> displays_ = NULL ; <NEW_LINE> displays_size_ = 0 ;
SetSelection ( <NEW_LINE> SelectionInDOMTree::Builder ( <NEW_LINE> GetGranularityStrategy ( ) -> UpdateExtent ( contents_point , frame_ ) ) <NEW_LINE> <START_VULN> . SetIsHandleVisible ( true ) <NEW_LINE> <END_VULN> . Build ( ) , <NEW_LINE> SetSelectionData::Builder ( ) <NEW_LINE> . SetShouldCloseTyping ( true ) <NEW_LINE> . SetShouldClearTypingStyle ( true ) <NEW_LINE> . SetDoNotClearStrategy ( true ) <NEW_LINE> . SetSetSelectionBy ( SetSelectionBy::kUser ) <NEW_LINE> . Build ( ) ) ; <NEW_LINE> }
<START_VULN> while ( next_format ( & colour_type , & bit_depth , & palette_number , 1 ) ) <NEW_LINE>if ( palette_number == 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> double test_gamma = 1 . 0 ; <NEW_LINE> while ( test_gamma >= . 4 )
return FALSE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> return send ( ts [ h ] . cmd_fdw , cmd_send , size_send , 0 ) == size_send ; <NEW_LINE> <END_VULN> } <NEW_LINE> int btsock_thread_wakeup ( int h ) <NEW_LINE> {
IPV6_SET_L4PROTO ( p , nh ) ; <NEW_LINE> hdrextlen = ( * ( pkt + 1 ) + 1 ) << 3 ; <NEW_LINE> if ( hdrextlen > plen ) { <NEW_LINE> <START_VULN> ENGINE_SET_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <NEW_LINE> <END_VULN> SCReturn ; <NEW_LINE> }
bool ContentEncoding::Write ( IMkvWriter * writer ) const { <NEW_LINE> const uint64 encryption_size = EncryptionSize ( ) ; <NEW_LINE> const uint64 encoding_size = EncodingSize ( 0 , encryption_size ) ; <NEW_LINE> <START_VULN> const uint64 size = EbmlMasterElementSize ( kMkvContentEncoding , <NEW_LINE>encoding_size ) + <NEW_LINE>encoding_size ; <NEW_LINE> <END_VULN> const int64 payload_position = writer -> Position ( ) ; <NEW_LINE> if ( payload_position < 0 )
const uint8_t * clear = data ; <NEW_LINE> if ( decrypt_cb ) <NEW_LINE> { <NEW_LINE> <START_VULN> int n = data_sz > 10 ? 10 : data_sz ; <NEW_LINE> <END_VULN> decrypt_cb ( decrypt_state , data , clear_buffer , n ) ; <NEW_LINE> clear = clear_buffer ; <NEW_LINE> }
static const int64 kInvalidMetaHandle = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> enum { <NEW_LINE> BEGIN_FIELDS = 0 ,
else if ( jsvIsFloat ( var ) ) jsiConsolePrintf ( "Double % f" , jsvGetFloat ( var ) ) ; <NEW_LINE> else if ( jsvIsFunctionParameter ( var ) ) jsiConsolePrintf ( "Param % q " , var ) ; <NEW_LINE> else if ( jsvIsArrayBufferName ( var ) ) jsiConsolePrintf ( "ArrayBufferName [ % d ] " , jsvGetInteger ( var ) ) ; <NEW_LINE> <START_VULN> else if ( jsvIsArrayBuffer ( var ) ) jsiConsolePrintf ( " % s " , jswGetBasicObjectName ( var ) ) ; <NEW_LINE> <END_VULN> else if ( jsvIsString ( var ) ) { <NEW_LINE> size_t blocks = 1 ; <NEW_LINE> if ( jsvGetLastChild ( var ) ) {
if ( lineIter != this -> begin_lines ( ) ) { <NEW_LINE> lineIter -- ; <NEW_LINE> nsBlockInFlowLineIterator bifLineIter ( this , lineIter , PR_FALSE ) ; <NEW_LINE> if ( ! bifLineIter . Next ( ) || <NEW_LINE> ! bifLineIter . GetLine ( ) -> IsDirty ( ) ) { <NEW_LINE> <START_VULN> if ( IS_TRUE_OVERFLOW_CONTAINER ( aState . mNextInFlow ) ) <NEW_LINE>NS_FRAME_SET_OVERFLOW_INCOMPLETE ( aState . mReflowStatus ) ; <NEW_LINE>else <NEW_LINE>NS_FRAME_SET_INCOMPLETE ( aState . mReflowStatus ) ; <NEW_LINE> <END_VULN> skipPull = PR_TRUE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( ! skipPull && aState . mNextInFlow ) { <NEW_LINE> while ( keepGoing && ( nsnull != aState . mNextInFlow ) ) { <NEW_LINE> nsBlockFrame * nextInFlow = aState . mNextInFlow ; <NEW_LINE> line_iterator nifLine = nextInFlow -> begin_lines ( ) ;
trunc: <NEW_LINE> ND_PRINT ( ( ndo , " % s" , tstr ) ) ; <NEW_LINE> <START_VULN> return ( mhlen ) ; <NEW_LINE> <END_VULN> }
GIFFrameContext * currentFrame = m_frames . last ( ) . get ( ) ; <NEW_LINE> currentFrame -> setHeaderDefined ( ) ; <NEW_LINE> currentFrame -> setRect ( xOffset , yOffset , width , height ) ; <NEW_LINE> <START_VULN> m_screenWidth = std::max ( m_screenWidth , width ) ; <NEW_LINE>m_screenHeight = std::max ( m_screenHeight , height ) ; <NEW_LINE> <END_VULN> currentFrame -> setInterlaced ( currentComponent [ 8 ] & 0x40 ) ;
return rv ; <NEW_LINE> if ( ( mFirstRange || ( aStartIndex != aEndIndex ) ) && single ) <NEW_LINE> return NS_OK ; <NEW_LINE> if ( ! aAugment ) { <NEW_LINE> if ( mFirstRange ) { <NEW_LINE> <START_VULN> mFirstRange -> Invalidate ( ) ; <NEW_LINE>delete mFirstRange ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> if ( aStartIndex == - 1 ) { <NEW_LINE> if ( mShiftSelectPivot != - 1 ) <NEW_LINE> aStartIndex = mShiftSelectPivot ; <NEW_LINE> else if ( mCurrentIndex != - 1 ) <NEW_LINE> aStartIndex = mCurrentIndex ;
unsigned long value ; <NEW_LINE> unsigned int res ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <NEW_LINE>1 , 0 , regs , 0 ) ; <NEW_LINE> <END_VULN>
png_uint_32 height = image -> height ; <NEW_LINE> png_uint_32 width = image -> width ; <NEW_LINE> ptrdiff_t step_row = display -> row_bytes ; <NEW_LINE> <START_VULN> unsigned int channels = ( image -> format & PNG_FORMAT_FLAG_COLOR ) ? 3 : 1 ; <NEW_LINE> <END_VULN> int pass ; <NEW_LINE> for ( pass = 0 ; pass < passes ; ++ pass )
<START_VULN> static const char * const cfg = " -- force - target = mips32 - android - gcc -- disable - runtime - cpu - detect -- sdk - path = / usr / local / google / home / hkuang / Downloads / android - ndk - r9d -- disable - examples -- disable - docs -- enable - realtime - only" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
virtual void DidManualLoadFail ( ) ; <NEW_LINE> virtual void InstallMissingPlugin ( ) ; <NEW_LINE> virtual webkit_glue::WebPluginResourceClient * CreateResourceClient ( <NEW_LINE> <START_VULN> unsigned long resource_id , <NEW_LINE>const GURL & url , <NEW_LINE>bool notify_needed , <NEW_LINE>intptr_t notify_data , <NEW_LINE>intptr_t stream ) ; <NEW_LINE> <END_VULN> virtual NPError Device2DQueryCapability ( int32 capability , int32 * value ) ;
assert ( sp -> encoderow != NULL ) ; <NEW_LINE> <START_VULN> ( * sp -> encodepfunc ) ( tif , bp , cc ) ; <NEW_LINE> <END_VULN> return ( * sp -> encoderow ) ( tif , bp , cc , s ) ; <NEW_LINE> }
mImageBufferCurr = mImageBufferStart ; <NEW_LINE> EncodeFileHeader ( ) ; <NEW_LINE> EncodeInfoHeader ( ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>NS_IMETHODIMP nsBMPEncoder::GetImageBufferSize ( PRUint32 * aOutputSize ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ENSURE_ARG_POINTER ( aOutputSize ) ; <NEW_LINE> * aOutputSize = mImageBufferSize ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsBMPEncoder::GetImageBuffer ( char ** aOutputBuffer )
{ <NEW_LINE> OwnPtr < GIFImageDecoder > decoder = createDecoder ( ) ; <NEW_LINE> <START_VULN> RefPtr < SharedBuffer > data = readFile ( " / LayoutTests / fast / images / resources / animated . gif" ) ; <NEW_LINE> <END_VULN> ASSERT_TRUE ( data . get ( ) ) ; <NEW_LINE> decoder -> setData ( data . get ( ) , true ) ;
if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { <NEW_LINE> int size = 0 ; <NEW_LINE> <START_VULN> if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size ) <NEW_LINE> <END_VULN> cleanup_rfc_slot ( slot ) ; <NEW_LINE> }
propTable -> SetProperty ( frame , nsGkAtoms::embeddingLevel , <NEW_LINE> NS_INT32_TO_PTR ( embeddingLevel ) , <NEW_LINE> nsnull , nsnull ) ; <NEW_LINE> propTable -> SetProperty ( frame , nsGkAtoms::baseLevel , <NEW_LINE> NS_INT32_TO_PTR ( paraLevel ) , nsnull , nsnull ) ; <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> PRInt32 start , end ; <NEW_LINE> frame -> GetOffsets ( start , end ) ; <NEW_LINE> <START_VULN> fragmentLength = end - start ; <NEW_LINE> <END_VULN> contentOffset = start ; <NEW_LINE> isTextFrame = PR_TRUE ; <NEW_LINE> } <NEW_LINE> else { <NEW_LINE> isTextFrame = PR_FALSE ;
case '\'': <NEW_LINE> ds += 5 ; <NEW_LINE> <START_VULN> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <NEW_LINE> <END_VULN> if ( NULL == tmp ) <NEW_LINE> {
} <NEW_LINE> NS_IMPL_ISUPPORTS3 ( nsStreamLoader , nsIStreamLoader , <NEW_LINE> nsIRequestObserver , nsIStreamListener ) <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsStreamLoader::GetNumBytesRead ( PRUint32 * aNumBytes ) <NEW_LINE> { <NEW_LINE> <START_VULN> * aNumBytes = mData . Length ( ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsStreamLoader::GetRequest ( nsIRequest ** aRequest ) <NEW_LINE> { <NEW_LINE> NS_IF_ADDREF ( * aRequest = mRequest ) ;
} <NEW_LINE> static void <NEW_LINE> <START_VULN> insert_hIST ( png_structp png_ptr , png_infop info_ptr , int nparams , png_charpp params ) <NEW_LINE> <END_VULN> { <NEW_LINE> int i ; <NEW_LINE> png_uint_16 freq [ 256 ] ;
void PNGAPI <NEW_LINE> png_set_invalid ( png_const_structrp png_ptr , png_inforp info_ptr , int mask ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr && info_ptr ) <NEW_LINE> <END_VULN> info_ptr -> valid &= ~ mask ; <NEW_LINE> }
ZVAL_STRINGL ( * rval , str , len , 0 ) ; <NEW_LINE> return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 916 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy46: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych == ' + ' ) goto yy47 ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . overloadedMethod12" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , type , MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ; <NEW_LINE> TestObj::overloadedMethod1 ( type ) ; <NEW_LINE> return v8::Handle < v8::Value > ( ) ;
mCursor . swap ( cursor ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> OpenCursorHelper::ReleaseMainThreadObjects ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( mCloneReadInfo . mCloneBuffer ) ; <NEW_LINE> <END_VULN> mSerializedCloneReadInfo . data = nullptr ; <NEW_LINE> mSerializedCloneReadInfo . dataLength = 0 ; <NEW_LINE> OpenKeyCursorHelper::ReleaseMainThreadObjects ( ) ; <NEW_LINE> }
Token currentToken ; <NEW_LINE> unsigned lookahead ; <NEW_LINE> Token lookaheadTokens [ maxLookahead ] ; <NEW_LINE> } ; <NEW_LINE> void advance ( size_t position ) ; <NEW_LINE> void tell ( Position * ) ; <NEW_LINE> void seek ( const Position & pos ) ; <NEW_LINE> <START_VULN> void seek ( const Position & pos , const TokenStream & other ) ; <NEW_LINE> <END_VULN> void positionAfterLastFunctionKeyword ( Position & pos ) ; <NEW_LINE> size_t positionToOffset ( const Position & pos ) const { <NEW_LINE> return pos . buf - userbuf . base ( ) ; <NEW_LINE> } <NEW_LINE> bool hasSourceMap ( ) const { <NEW_LINE> return sourceMap != NULL ;
case SIOCFINDIPDDPRT: <NEW_LINE> spin_lock_bh ( & ipddp_route_lock ) ; <NEW_LINE> rp = __ipddp_find_route ( & rcp ) ; <NEW_LINE> <START_VULN> if ( rp ) <NEW_LINE>memcpy ( & rcp2 , rp , sizeof ( rcp2 ) ) ; <NEW_LINE> <END_VULN> spin_unlock_bh ( & ipddp_route_lock ) ; <NEW_LINE> if ( rp ) {
AutoValueVector vals ( cx ) ; <NEW_LINE> if ( ! vals . resize ( keys . length ( ) ) ) <NEW_LINE> return false ; <NEW_LINE> for ( size_t i = 0 , len = keys . length ( ) ; i < len ; i ++ ) { <NEW_LINE> jsid id = keys [ i ] ; <NEW_LINE> if ( JSID_IS_INT ( id ) ) { <NEW_LINE> <START_VULN> JSString * str = js_IntToString ( cx , JSID_TO_INT ( id ) ) ; <NEW_LINE> <END_VULN> if ( ! str ) <NEW_LINE> return false ; <NEW_LINE> vals [ i ] . setString ( str ) ; <NEW_LINE> } else if ( JSID_IS_ATOM ( id ) ) { <NEW_LINE> vals [ i ] . setString ( JSID_TO_STRING ( id ) ) ; <NEW_LINE> if ( ! cx -> compartment -> wrap ( cx , & vals [ i ] ) ) <NEW_LINE> return false ; <NEW_LINE> } else {
if ( out == NULL ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> gdImageWebpCtx ( im , out , quality ) ; <NEW_LINE> <END_VULN> out -> gd_free ( out ) ; <NEW_LINE> }
std::cout << "FAILED:" ; <NEW_LINE> else <NEW_LINE> std::cout << "passed:" ; <NEW_LINE> <START_VULN> std::cout << " GenerateWord32 and Crop\n" ; <NEW_LINE> <END_VULN> } <NEW_LINE> #endif
based temporary image . * / <NEW_LINE> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <NEW_LINE> if ( ! pim ) { <NEW_LINE> <START_VULN> return ; <NEW_LINE> <END_VULN> } <NEW_LINE> tim = pim ; <NEW_LINE> }
break ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> if ( cookies ) { <NEW_LINE>ast_variables_destroy ( cookies ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> return mngid ; <NEW_LINE> }
} <NEW_LINE> Struct * ptr_ ; <NEW_LINE> } ; <NEW_LINE> template < typename Struct > <NEW_LINE> class InlinedStructPtr { <NEW_LINE> <START_VULN> MOVE_ONLY_TYPE_FOR_CPP_03 ( InlinedStructPtr ) ; <NEW_LINE><NEW_LINE> <END_VULN> public: <NEW_LINE> InlinedStructPtr ( ) : is_null_ ( true ) { }
u_char status ; <NEW_LINE> u_char user [ 65 ] ; <NEW_LINE> u_char type ; <NEW_LINE> <START_VULN> u_char password [ 65 ] ; <NEW_LINE> <END_VULN> u_char hash [ 33 ] ; <NEW_LINE> u_char salt [ 9 ] ; <NEW_LINE> u_char database [ 65 ] ;
} <NEW_LINE> <START_VULN> cert_sig = sig_verify ( ctx , cert -> signature , cert -> sig_len , <NEW_LINE> <END_VULN> bi_clone ( ctx , mod ) , bi_clone ( ctx , expn ) ) ; <NEW_LINE> if ( cert_sig && cert -> digest )
inst = bytestream_get_byte ( & buf ) ; <NEW_LINE> inst &= CDG_MASK ; <NEW_LINE> buf += 2 ; <NEW_LINE> <START_VULN> bytestream_get_buffer ( & buf , cdg_data , buf_size - CDG_HEADER_SIZE ) ; <NEW_LINE> <END_VULN> if ( ( command & CDG_MASK ) == CDG_COMMAND ) { <NEW_LINE> switch ( inst ) {
return parse_uid_node ( object , size ) ; <NEW_LINE> case BPLIST_DICT: <NEW_LINE> <START_VULN> if ( * object + size > bplist -> offset_table ) { <NEW_LINE>PLIST_BIN_ERR ( " % s: BPLIST_REAL data bytes point outside of valid range\n" , __func__ ) ; <NEW_LINE> <END_VULN> return NULL ; <NEW_LINE> } <NEW_LINE> return parse_dict_node ( bplist , object , size ) ; <NEW_LINE> commit 32ee5213fe64f1e10ec76c1ee861ee6f233120dd <NEW_LINE> Author: Nikias Bassen < nikias@gmx . li > <NEW_LINE> Date: Fri Feb 10 13:42:46 2017 + 0100 <NEW_LINE> bplist: Fix data range check for string / data / dict / array nodes <NEW_LINE> Passing a size of 0xFFFFFFFFFFFFFFFF to parse_string_node ( ) might result <NEW_LINE> in a memcpy with a size of - 1 , leading to undefined behavior . <NEW_LINE> This commit makes sure that the actual node data ( which depends on the size ) <NEW_LINE> is in the range start_of_object . . start_of_object + size . <NEW_LINE> Credit to OSS - Fuzz
JSString * id = JS_GetFunctionId ( static_cast < JSFunction * > ( JS_GetPrivate ( obj ) ) ) ; <NEW_LINE> JSAutoByteString bytes ; <NEW_LINE> const char * name = ! id ? "anonymous" : bytes . encode ( mContext , id ) ? bytes . ptr ( ) : " < error > " ; <NEW_LINE> NS_TIME_FUNCTION_FMT ( 1 . 0 , " % s ( line % d ) ( function: % s ) " , MOZ_FUNCTION_NAME , __LINE__ , name ) ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> SAMPLE_LABEL ( "JS" , "CallEventHandler" ) ; <NEW_LINE> <START_VULN> JSAutoRequest ar ( mContext ) ; <NEW_LINE> <END_VULN> xpc_UnmarkGrayObject ( aScope ) ; <NEW_LINE> xpc_UnmarkGrayObject ( aHandler ) ; <NEW_LINE> JSObject * target = nsnull ; <NEW_LINE> nsresult rv = JSObjectFromInterface ( aTarget , aScope , & target ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> JS::AutoObjectRooter targetVal ( mContext , target ) ; <NEW_LINE> jsval rval = JSVAL_VOID ;
opj_stream_destroy ( jp2_stream ) ; <NEW_LINE> for ( i = 0 ; i < ( ssize_t ) jp2_image -> numcomps ; i ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ( jp2_image -> comps [ i ] . dx == 0 ) || ( jp2_image -> comps [ i ] . dy == 0 ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> opj_destroy_codec ( jp2_codec ) ; <NEW_LINE> opj_image_destroy ( jp2_image ) ;
struct crypto_report_aead raead ; <NEW_LINE> struct aead_alg * aead = & alg -> cra_aead ; <NEW_LINE> <START_VULN> snprintf ( raead . type , CRYPTO_MAX_ALG_NAME , " % s" , "nivaead" ) ; <NEW_LINE>snprintf ( raead . geniv , CRYPTO_MAX_ALG_NAME , " % s" , aead -> geniv ) ; <NEW_LINE> <END_VULN> raead . blocksize = alg -> cra_blocksize ; <NEW_LINE> raead . maxauthsize = aead -> maxauthsize ;
0 . 9999667820F , 0 . 9999720773F , 0 . 9999767136F , 0 . 9999807479F , <NEW_LINE> 0 . 9999842344F , 0 . 9999872249F , 0 . 9999897688F , 0 . 9999919127F , <NEW_LINE> 0 . 9999937009F , 0 . 9999951749F , 0 . 9999963738F , 0 . 9999973342F , <NEW_LINE> 0 . 9999980900F , 0 . 9999986724F , 0 . 9999991103F , 0 . 9999994297F , <NEW_LINE> 0 . 9999996543F , 0 . 9999998049F , 0 . 9999999000F , 0 . 9999999552F , <NEW_LINE> 0 . 9999999836F , 0 . 9999999957F , 0 . 9999999994F , 1 . 0000000000F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin2048 [ 1024 ] = { <NEW_LINE> <END_VULN> 0 . 0000009241F , 0 . 0000083165F , 0 . 0000231014F , 0 . 0000452785F , <NEW_LINE> 0 . 0000748476F , 0 . 0001118085F , 0 . 0001561608F , 0 . 0002079041F , <NEW_LINE> 0 . 0002670379F , 0 . 0003335617F , 0 . 0004074748F , 0 . 0004887765F , <NEW_LINE> 0 . 0005774661F , 0 . 0006735427F , 0 . 0007770054F , 0 . 0008878533F , <NEW_LINE> 0 . 0010060853F , 0 . 0011317002F , 0 . 0012646969F , 0 . 0014050742F ,
<START_VULN> if ( code ) { <NEW_LINE> <END_VULN> if ( toktype == KG_TOK_SEAL_MSG ) <NEW_LINE> gssalloc_free ( token . value ) ; <NEW_LINE> * minor_status = 0 ;
NS_ASSERTION ( ! mRootNode || mState != LIST_DIRTY , <NEW_LINE> "PopulateSelf left the list in a dirty ( useless ) state ! " ) ; <NEW_LINE> <START_VULN> return NS_STATIC_CAST ( nsIContent * , mElements . SafeElementAt ( aIndex ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsIContent *
GetName ( name ) ; <NEW_LINE> LOG_FUNC_WITH_PARAM ( GetImgLog ( ) , "imgRequestProxy::OnStopRequest" , "name" , name . get ( ) ) ; <NEW_LINE> #endif <NEW_LINE> nsCOMPtr < imgIRequest > kungFuDeathGrip ( this ) ; <NEW_LINE> <START_VULN> if ( mListener ) { <NEW_LINE> <END_VULN> nsCOMPtr < imgINotificationObserver > kungFuDeathGrip ( mListener ) ; <NEW_LINE> mListener -> Notify ( this , imgINotificationObserver::LOAD_COMPLETE , nullptr ) ; <NEW_LINE> }
} <NEW_LINE> <START_VULN> for ( i = 1 ; i <= lpc_order ; i ++ ) <NEW_LINE> <END_VULN> buffer_out [ i ] = sign_extend ( buffer_out [ i - 1 ] + error_buffer [ i ] , bps ) ;
oggpack_buffer * b ) ; <NEW_LINE> #else <NEW_LINE> static inline ogg_uint32_t decode_packed_entry_number ( codebook * book , <NEW_LINE> <START_VULN> oggpack_buffer * b ) { <NEW_LINE> <END_VULN> ogg_uint32_t chase = 0 ; <NEW_LINE> int read = book -> dec_maxlength ; <NEW_LINE> long lok = oggpack_look ( b , read ) , i ;
} <NEW_LINE> nsRefPtr < nsGlobalWindow > newInnerWindow ; <NEW_LINE> bool createdInnerWindow = false ; <NEW_LINE> bool thisChrome = IsChromeWindow ( ) ; <NEW_LINE> nsCxPusher cxPusher ; <NEW_LINE> <START_VULN> if ( ! cxPusher . Push ( cx , nsCxPusher::ASSERT_SCRIPT_CONTEXT ) ) { <NEW_LINE> <END_VULN> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> XPCAutoRequest ar ( cx ) ; <NEW_LINE> nsCOMPtr < WindowStateHolder > wsh = do_QueryInterface ( aState ) ; <NEW_LINE> NS_ASSERTION ( ! aState || wsh , "What kind of weird state are you giving me here ? " ) ;
flags |= IS_RDONLY ( d_inode ( lower_dentry ) ) ? O_RDONLY : O_RDWR ; <NEW_LINE> ( * lower_file ) = dentry_open ( & req . path , flags , cred ) ; <NEW_LINE> if ( ! IS_ERR ( * lower_file ) ) <NEW_LINE> <START_VULN> goto out ; <NEW_LINE> <END_VULN> if ( ( flags & O_ACCMODE ) == O_RDONLY ) { <NEW_LINE> rc = PTR_ERR ( ( * lower_file ) ) ; <NEW_LINE> goto out ;
void RequestEarlyExit ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>virtual bool SyncShare ( sessions::SyncSession * session , <NEW_LINE> <END_VULN> SyncerStep first_step , <NEW_LINE> SyncerStep last_step ) ;
void OnDidGetPrintedPagesCount ( int cookie , int number_pages ) override ; <NEW_LINE> <START_VULN> void OnDidPrintPage ( const PrintHostMsg_DidPrintPage_Params & params ) ; <NEW_LINE> <END_VULN> void OnPrintingFailed ( int cookie ) override ; <NEW_LINE> void OnShowInvalidPrinterSettingsError ( ) ; <NEW_LINE> void OnNotifyPrintJobEvent ( const JobEventDetails & event_details ) ;
if ( * data <= 0x1F ) <NEW_LINE> { <NEW_LINE> if ( length < 1 ) <NEW_LINE> <START_VULN> { <NEW_LINE>ND_PRINT ( ( ndo , " % s" , tstr ) ) ; <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE> <END_VULN> if ( * data ) <NEW_LINE> ND_PRINT ( ( ndo , "Tag [ % u ] " , * data ) ) ; <NEW_LINE> else
friend class SoftwareDevice ; <NEW_LINE> void InvokeComposite ( const gfx::Transform & transform , <NEW_LINE> <START_VULN> gfx::Rect viewport , <NEW_LINE>gfx::Rect clip , <NEW_LINE>gfx::Rect viewport_rect_for_tile_priority , <NEW_LINE>gfx::Transform transform_for_tile_priority , <NEW_LINE> <END_VULN> bool hardware_draw ) ; <NEW_LINE> bool CalledOnValidThread ( ) const ;
#endif <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE>#if defined ( _WIN32 ) && defined ( __CYGWIN__ ) <NEW_LINE> <END_VULN> #undef EXSLTPUBFUN <NEW_LINE> #undef EXSLTPUBVAR <NEW_LINE> #undef EXSLTCALL
} <NEW_LINE> if ( get_name ) { <NEW_LINE> <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <NEW_LINE> <END_VULN> fprintf ( stdout , "BT adapter is up\n" ) ; <NEW_LINE> int error ; <NEW_LINE> CALL_AND_WAIT ( error = bt_interface -> get_adapter_property ( BT_PROPERTY_BDNAME ) , adapter_properties ) ;
content_encodings_size += encoding -> Size ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! WriteEbmlMasterElement ( writer , <NEW_LINE>kMkvContentEncodings , <NEW_LINE> <END_VULN> content_encodings_size ) ) <NEW_LINE> return false ;
* isKnownConstant = false ; <NEW_LINE> if ( id != types::IdToTypeId ( id ) ) <NEW_LINE> return true ; <NEW_LINE> <START_VULN> if ( ! CanEffectlesslyCallLookupGenericOnObject ( obj ) ) <NEW_LINE> <END_VULN> return true ; <NEW_LINE> RootedObject holder ( cx ) ; <NEW_LINE> RootedShape shape ( cx ) ; <NEW_LINE> if ( ! JSObject::lookupGeneric ( cx , obj , id , & holder , & shape ) ) <NEW_LINE> return false ; <NEW_LINE> if ( ! shape ) <NEW_LINE> return true ;
{ <NEW_LINE> sc_file_t * file ; <NEW_LINE> int r , file_type ; <NEW_LINE> <START_VULN> u8 files [ SC_MAX_APDU_BUFFER_SIZE ] ; <NEW_LINE> <END_VULN> r = sc_lock ( card ) ; <NEW_LINE> if ( r == SC_SUCCESS )
} ; <NEW_LINE> static const uint32_t HZCharLenTable [ ] = { 0 , 0 , 0 , 0 , 0 , 0 } ; <NEW_LINE> const SMModel HZSMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , HZ_cls } , <NEW_LINE> 6 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , HZ_st } , <NEW_LINE> <START_VULN> HZCharLenTable , <NEW_LINE> <END_VULN> "HZ - GB - 2312" , <NEW_LINE> } ; <NEW_LINE> static const uint32_t ISO2022CN_cls [ 256 / 8 ] = { <NEW_LINE> PCK4BITS ( 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) , <NEW_LINE> PCK4BITS ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) , <NEW_LINE> PCK4BITS ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) ,
goto error ; <NEW_LINE> if ( ! JS_XDRBytes ( xdr , ( char * ) notes , nsrcnotes * sizeof ( jssrcnote ) ) || <NEW_LINE> ! JS_XDRUint32 ( xdr , & lineno ) || <NEW_LINE> ! JS_XDRUint32 ( xdr , & nslots ) ) { <NEW_LINE> goto error ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( xdr -> mode == JSXDR_DECODE && state -> filename ) { <NEW_LINE>if ( ! state -> filenameSaved ) { <NEW_LINE>const char * filename = state -> filename ; <NEW_LINE>filename = SaveScriptFilename ( xdr -> cx , filename ) ; <NEW_LINE>xdr -> cx -> free_ ( ( void * ) state -> filename ) ; <NEW_LINE>state -> filename = filename ; <NEW_LINE>state -> filenameSaved = true ; <NEW_LINE>if ( ! filename ) <NEW_LINE>goto error ; <NEW_LINE> } <NEW_LINE>script -> filename = state -> filename ; <NEW_LINE> } <NEW_LINE><NEW_LINE>JS_ASSERT_IF ( xdr -> mode == JSXDR_ENCODE , state -> filename == script -> filename ) ; <NEW_LINE><NEW_LINE> <END_VULN> callbacks = JS_GetSecurityCallbacks ( cx ) ; <NEW_LINE> if ( xdr -> mode == JSXDR_ENCODE ) { <NEW_LINE> principals = script -> principals ;
av_log ( avctx , AV_LOG_ERROR , "width must be even for this colorspace\n" ) ; <NEW_LINE> return AVERROR_INVALIDDATA ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> alloc_temp ( s ) ; <NEW_LINE> return 0 ;
DEBUG_PRINT_LOW ( "free_buffer on o / p port - Port idx % u , actual cnt % u" , <NEW_LINE> nPortIndex , ( unsigned int ) m_sOutPortDef . nBufferCountActual ) ; <NEW_LINE> <START_VULN> if ( nPortIndex < m_sOutPortDef . nBufferCountActual ) { <NEW_LINE> <END_VULN> BITMASK_CLEAR ( & m_out_bm_count , nPortIndex ) ; <NEW_LINE> m_sOutPortDef . bPopulated = OMX_FALSE ;
write_vpAg_chunk ( write_ptr ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #endif <NEW_LINE>#else <NEW_LINE> <END_VULN> # define write_chunks ( pp , loc ) ( ( void ) 0 ) <NEW_LINE> #endif
nsHTMLPluginObjElementSH::SetupProtoChain ( nsIXPConnectWrappedNative * wrapper , <NEW_LINE> JSContext * cx , <NEW_LINE> JSObject * obj ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( nsContentUtils::IsSafeToRunScript ( ) , <NEW_LINE> "Shouldn't have gotten in here" ) ; <NEW_LINE> nsCxPusher cxPusher ; <NEW_LINE> <START_VULN> if ( ! cxPusher . Push ( cx ) ) { <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , obj ) ; <NEW_LINE> nsRefPtr < nsNPAPIPluginInstance > pi ; <NEW_LINE> nsresult rv = GetPluginInstanceIfSafe ( wrapper , obj , cx , getter_AddRefs ( pi ) ) ;
{ <NEW_LINE> int need_crc = 1 ; <NEW_LINE> <START_VULN> if ( PNG_CHUNK_ANCILLARY ( png_ptr -> chunk_name ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ( png_ptr -> flags & PNG_FLAG_CRC_ANCILLARY_MASK ) == <NEW_LINE> ( PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN ) )
"Decoding transited encoding" ) ; <NEW_LINE> return ret ; <NEW_LINE> } <NEW_LINE> if ( strcmp ( client_realm , tgt_realm ) && strcmp ( server_realm , tgt_realm ) ) { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( num_realms + 1 > UINT_MAX / sizeof ( * realms ) ) { <NEW_LINE> ret = ERANGE ; <NEW_LINE> goto free_realms ;
void Initialize ( const media::VideoCodecProfile profile , <NEW_LINE> <START_VULN> IPC::Message * init_done_msg , <NEW_LINE>base::ProcessHandle renderer_process ) ; <NEW_LINE> <END_VULN> private:
while ( c -- ) { <NEW_LINE> from - = 3 ; <NEW_LINE> * -- to = gfxPackedPixel ( 0xFF , from [ 0 ] , from [ 1 ] , from [ 2 ] ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> void <NEW_LINE> <START_VULN> nsGIFDecoder2::WriteInternal ( const char * aBuffer , uint32_t aCount ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ABORT_IF_FALSE ( ! HasError ( ) , "Shouldn't call WriteInternal after error ! " ) ; <NEW_LINE> const uint8_t * buf = ( const uint8_t * ) aBuffer ; <NEW_LINE> uint32_t len = aCount ; <NEW_LINE> const uint8_t * q = buf ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE>#define for_each_leaf_cfs_rq_safe ( rq , cfs_rq , pos ) \ <NEW_LINE>list_for_each_entry_safe ( cfs_rq , pos , & rq -> leaf_cfs_rq_list , \ <NEW_LINE>leaf_cfs_rq_list ) <NEW_LINE> <END_VULN> static inline struct cfs_rq *
rdr::OutStream * os ; <NEW_LINE> SMsgReader * reader_ ; <NEW_LINE> SMsgWriter * writer_ ; <NEW_LINE> <START_VULN> SecurityServer * security ; <NEW_LINE> <END_VULN> SSecurity * ssecurity ; <NEW_LINE> stateEnum state_ ; <NEW_LINE> rdr::S32 preferredEncoding ;
<START_VULN> <NEW_LINE>bool BindInstance ( ) ; <NEW_LINE>bool UnbindInstance ( ) ; <NEW_LINE> <END_VULN> bool IsOnTaskRunner ( RunnerId runner_id ) ;
if ( ariaRoleAttribute ( ) == ToggleButtonRole ) { <NEW_LINE> <START_VULN> if ( equalIgnoringCase ( getAttribute ( aria_pressedAttr ) , "true" ) || <NEW_LINE>equalIgnoringCase ( getAttribute ( aria_pressedAttr ) , "mixed" ) ) <NEW_LINE> <END_VULN> return true ; <NEW_LINE> return false ; <NEW_LINE> }
* analyze_script_file_name , getErrorText ( ) ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> if ( os_info . user_specified ) <NEW_LINE>pg_free ( user_specification ) ; <NEW_LINE> <END_VULN> check_ok ( ) ; <NEW_LINE> }
image -> numcmpts_ = 0 ; <NEW_LINE> image -> maxcmpts_ = 0 ; <NEW_LINE> image -> cmpts_ = 0 ; <NEW_LINE> <START_VULN> image -> inmem_ = true ; <NEW_LINE> <END_VULN> image -> cmprof_ = 0 ; <NEW_LINE> return image ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: bitrate tracking and management <NEW_LINE> <START_VULN> last mod: $ Id: bitrate . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
typename CalcOps::result_type lhs = ComputeCalc ( arr -> Item ( 0 ) , aOps ) ; <NEW_LINE> float rhs = aOps . ComputeNumber ( arr -> Item ( 1 ) ) ; <NEW_LINE> return aOps . MergeMultiplicativeR ( CalcOps::GetUnit ( aValue ) , lhs , rhs ) ; <NEW_LINE> } <NEW_LINE> case eCSSUnit_Calc_Minimum: <NEW_LINE> case eCSSUnit_Calc_Maximum: { <NEW_LINE> typename CalcOps::input_array_type * arr = aValue . GetArrayValue ( ) ; <NEW_LINE> typename CalcOps::result_type result = ComputeCalc ( arr -> Item ( 0 ) , aOps ) ; <NEW_LINE> <START_VULN> for ( PRUint32 i = 1 , i_end = arr -> Count ( ) ; i < i_end ; ++ i ) { <NEW_LINE> <END_VULN> typename CalcOps::result_type tmp = ComputeCalc ( arr -> Item ( i ) , aOps ) ; <NEW_LINE> result = aOps . MergeAdditive ( CalcOps::GetUnit ( aValue ) , result , tmp ) ; <NEW_LINE> } <NEW_LINE> return result ; <NEW_LINE> } <NEW_LINE> default: { <NEW_LINE> return aOps . ComputeLeafValue ( aValue ) ; <NEW_LINE> }
double doubleinfo ; <NEW_LINE> while ( ptr && * ptr ) { <NEW_LINE> <START_VULN> if ( ' % ' == * ptr ) { <NEW_LINE> <END_VULN> if ( ' % ' == ptr [ 1 ] ) { <NEW_LINE> fputc ( ' % ' , stream ) ;
connection_type_ = connection_type ; <NEW_LINE> } <NEW_LINE> <START_VULN> bool ShouldAddDefaultProxyBypassRules ( ) const override ; <NEW_LINE> <END_VULN> void SetShouldAddDefaultProxyBypassRules ( bool add_default_proxy_bypass_rules ) ;
} <NEW_LINE> <START_VULN> SetSelection ( SelectionInDOMTree::Builder ( ) <NEW_LINE> . SelectAllChildren ( * root ) <NEW_LINE> . SetIsHandleVisible ( IsHandleVisible ( ) ) <NEW_LINE> <END_VULN> . Build ( ) ) ; <NEW_LINE> SelectFrameElementInParentIfFullySelected ( ) ;
void * reghash ; <NEW_LINE> void * userdata ; <NEW_LINE> JSScript * script ; <NEW_LINE> <START_VULN> js::XDRScriptState * state ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> extern JS_PUBLIC_API ( void )
if ( childState == SelectionBoth || childState == SelectionEnd ) <NEW_LINE> sawSelectionEnd = true ; <NEW_LINE> <START_VULN> if ( curr -> isFloatingOrPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( curr -> isRelPositioned ( ) && curr -> hasLayer ( ) ) {
#endif <NEW_LINE> #endif <NEW_LINE> <START_VULN> if ( strict ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_set_benign_errors ( read_ptr , 0 ) ;
if ( ! ( obj -> type & MPR_JSON_VALUE ) ) { <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> value = stok ( value , "'\"" , NULL ) ; <NEW_LINE> <END_VULN> switch ( operator ) { <NEW_LINE> case JSON_OP_EQ: <NEW_LINE> return smatch ( obj -> value , value ) ;
if ( fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { <NEW_LINE> zend_throw_error ( exception_ce , message ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> zend_error ( E_ERROR , message ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> efree ( message ) ;
"only allowed for select groups" ) ; <NEW_LINE> return OFPERR_OFPBPC_BAD_VALUE ; <NEW_LINE> default: <NEW_LINE> <START_VULN> OVS_NOT_REACHED ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> switch ( group_cmd ) {
else if ( ! strncmp ( caf_chunk_header . mChunkType , "data" , 4 ) ) { <NEW_LINE> uint32_t mEditCount ; <NEW_LINE> <START_VULN> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <NEW_LINE> <END_VULN> bcount != sizeof ( mEditCount ) ) { <NEW_LINE> error_line ( " % s is not a valid . CAF file ! " , infilename ) ; <NEW_LINE> return WAVPACK_SOFT_ERROR ;
return FALSE ; <NEW_LINE> } <NEW_LINE> sock_cmd_t cmd = { CMD_WAKEUP , 0 , 0 , 0 , 0 } ; <NEW_LINE> <START_VULN> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> int btsock_thread_exit ( int h ) <NEW_LINE> {
void RenderSVGGradientStop::styleDidChange ( StyleDifference diff , const RenderStyle * oldStyle ) <NEW_LINE> { <NEW_LINE> RenderObject::styleDidChange ( diff , oldStyle ) ; <NEW_LINE> <START_VULN> if ( diff == StyleDifferenceEqual ) <NEW_LINE> <END_VULN> return ;
if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <NEW_LINE>data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ; <NEW_LINE>kunmap_atomic ( vapic ) ; <NEW_LINE> <END_VULN> apic_set_tpr ( vcpu -> arch . apic , data & 0xff ) ; <NEW_LINE> }
s += 11 ; <NEW_LINE> SKIPWS ( s ) ; <NEW_LINE> ptmp = tmp ; <NEW_LINE> <START_VULN> while ( isdigit ( ( unsigned char ) * s ) ) <NEW_LINE> <END_VULN> * ptmp ++ = * s ++ ; <NEW_LINE> * ptmp = '\0' ; <NEW_LINE> if ( mutt_str_atol ( tmp , & h -> content_length ) < 0 ) <NEW_LINE> commit 1b0f0d0988e6df4e32e9f4bf8780846ea95d4485 <NEW_LINE> Author: JerikoOne < jeriko . one@gmx . us > <NEW_LINE> Date: Sat Jul 7 14:03:46 2018 - 0500 <NEW_LINE> Don't overflow stack buffer in msg_parse_fetch
if ( ! to . empty ( ) ) { <NEW_LINE> int to_len = to . size ( ) ; <NEW_LINE> if ( to_len > 0 ) { <NEW_LINE> <START_VULN> to_r = strndup ( to . data ( ) , to_len ) ; <NEW_LINE> <END_VULN> for ( ; to_len ; to_len -- ) { <NEW_LINE> if ( ! isspace ( ( unsigned char ) to_r [ to_len - 1 ] ) ) { <NEW_LINE> break ;
if ( callingNew ) { <NEW_LINE> frame . discardFe ( origThis ) ; <NEW_LINE> <START_VULN> if ( cx -> typeInferenceEnabled ( ) ) <NEW_LINE>masm . storeValue ( NullValue ( ) , frame . addressOf ( origThis ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! cx -> typeInferenceEnabled ( ) ) { <NEW_LINE> CompileStatus status = callArrayBuiltin ( callImmArgc , callingNew ) ; <NEW_LINE> if ( status != Compile_InlineAbort ) <NEW_LINE> return ( status == Compile_Okay ) ; <NEW_LINE> }
retval = copy_strings_kernel ( 1 , & i_name , bprm ) ; <NEW_LINE> if ( retval ) return retval ; <NEW_LINE> bprm -> argc ++ ; <NEW_LINE> <START_VULN> bprm -> interp = interp ; <NEW_LINE> <END_VULN>
extern void <NEW_LINE> js_LeaveSharpObject ( JSContext * cx , JSIdArray ** idap ) ; <NEW_LINE> extern JSBool <NEW_LINE> js_obj_toSource ( JSContext * cx , JSObject * obj , uintN argc , jsval * argv , <NEW_LINE> jsval * rval ) ; <NEW_LINE> <START_VULN> - <NEW_LINE> <END_VULN> 1 . 4 . 1
return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> uint8_t * data ; <NEW_LINE>if ( ! getDataPointer ( cx , obj , args , sizeof ( NativeType ) , & data ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> NativeType value ;
{ <NEW_LINE> struct crypto_report_kpp rkpp ; <NEW_LINE> <START_VULN> strlcpy ( rkpp . type , "kpp" , sizeof ( rkpp . type ) ) ; <NEW_LINE> <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , <NEW_LINE> sizeof ( struct crypto_report_kpp ) , & rkpp ) )
NS_IMETHOD_ ( void ) NoteNativeRoot ( void * root , nsCycleCollectionParticipant * participant ) ; <NEW_LINE> NS_IMETHOD_ ( void ) NoteXPCOMChild ( nsISupports * child ) ; <NEW_LINE> NS_IMETHOD_ ( void ) NoteJSChild ( void * child ) ; <NEW_LINE> NS_IMETHOD_ ( void ) NoteNativeChild ( void * child , <NEW_LINE> nsCycleCollectionParticipant * participant ) ; <NEW_LINE> NS_IMETHOD_ ( void ) NoteNextEdgeName ( const char * name ) ; <NEW_LINE> <START_VULN> NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * val ) ; <NEW_LINE> <END_VULN> private: <NEW_LINE> NS_IMETHOD_ ( void ) NoteRoot ( void * root , <NEW_LINE> nsCycleCollectionParticipant * participant ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( root ) ; <NEW_LINE> MOZ_ASSERT ( participant ) ;
pn = NULL ; <NEW_LINE> } else { <NEW_LINE> if ( tc -> flags & TCF_FUN_IS_GENERATOR ) { <NEW_LINE> <START_VULN> ReportBadReturn ( context , tc , JSREPORT_ERROR , <NEW_LINE> <END_VULN> JSMSG_BAD_GENERATOR_RETURN , <NEW_LINE> JSMSG_BAD_ANON_GENERATOR_RETURN ) ; <NEW_LINE> pn = NULL ;
#define jas_seq2d_size ( s ) \ <NEW_LINE> ( jas_seq2d_width ( s ) * jas_seq2d_height ( s ) ) <NEW_LINE> <START_VULN> void jas_seq2d_bindsub ( jas_matrix_t * s , jas_matrix_t * s1 , int xstart , <NEW_LINE>int ystart , int xend , int yend ) ; <NEW_LINE> <END_VULN>
static void open_output_file ( struct stream_state * stream , <NEW_LINE> <START_VULN> struct VpxEncoderConfig * global ) { <NEW_LINE> <END_VULN> const char * fn = stream -> config . out_fn ; <NEW_LINE> const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ;
void PNGAPI <NEW_LINE> png_set_chunk_cache_max ( png_structrp png_ptr , png_uint_32 user_chunk_cache_max ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( png_ptr ) <NEW_LINE>png_ptr -> user_chunk_cache_max = user_chunk_cache_max ; <NEW_LINE> <END_VULN> }
{ <NEW_LINE> errmsg = JS_NewStringCopyZ ( cx , LOAD_ERROR_READUNDERFLOW ) ; <NEW_LINE> goto return_exception ; <NEW_LINE> } <NEW_LINE> <START_VULN> rv = mSystemPrincipal -> GetJSPrincipals ( cx , & jsPrincipals ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) || ! jsPrincipals ) { <NEW_LINE> errmsg = JS_NewStringCopyZ ( cx , LOAD_ERROR_NOPRINCIPALS ) ; <NEW_LINE> goto return_exception ; <NEW_LINE> } <NEW_LINE> er = JS_SetErrorReporter ( cx , mozJSLoaderErrorReporter ) ;
uint32 w , l , tw , tl ; <NEW_LINE> int bychunk ; <NEW_LINE> <START_VULN> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <NEW_LINE> <END_VULN> if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { <NEW_LINE> fprintf ( stderr , <NEW_LINE> " % s: Cannot handle different planar configuration w / bits / sample != 8\n" ,
SPL_METHOD ( SplFileObject , current ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
NS_ASSERTION ( ! IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> mActorChild -> Send__delete__ ( mActorChild ) ; <NEW_LINE> NS_ASSERTION ( ! mActorChild , "Should have cleared in Send__delete__ ! " ) ; <NEW_LINE> } <NEW_LINE> if ( mRooted ) { <NEW_LINE> NS_DROP_JS_OBJECTS ( this , IDBCursor ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( mCloneReadInfo . mCloneBuffer ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsresult <NEW_LINE> IDBCursor::ContinueInternal ( const Key & aKey , <NEW_LINE> int32_t aCount ) <NEW_LINE> { <NEW_LINE> NS_ASSERTION ( NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> NS_ASSERTION ( aCount > 0 , "Must have a count ! " ) ;
** be used as the cert's identity . <NEW_LINE> rv = cert_VerifySubjectAltName ( cert , hn ) ; <NEW_LINE> if ( rv == SECSuccess || PORT_GetError ( ) != SEC_ERROR_EXTENSION_NOT_FOUND ) <NEW_LINE> return rv ; <NEW_LINE> cn = CERT_GetCommonName ( & cert -> subject ) ; <NEW_LINE> if ( cn ) { <NEW_LINE> <START_VULN> rv = cert_TestHostName ( cn , hn ) ; <NEW_LINE> <END_VULN> PORT_Free ( cn ) ; <NEW_LINE> } else <NEW_LINE> PORT_SetError ( SSL_ERROR_BAD_CERT_DOMAIN ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> PRBool <NEW_LINE> CERT_CompareCerts ( CERTCertificate * c1 , CERTCertificate * c2 )
hasClient = true ; <NEW_LINE> result = String8::format ( " Device is open . Client instance dump:\n" ) ; <NEW_LINE> write ( fd , result . string ( ) , result . size ( ) ) ; <NEW_LINE> <START_VULN> client -> dump ( fd , args ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! hasClient ) { <NEW_LINE> result = String8::format ( "\nNo active camera clients yet . \n" ) ;
{ <NEW_LINE> png_debug ( 1 , "in png_set_palette_to_rgb" ) ; <NEW_LINE> <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> png_ptr -> transformations |= ( PNG_EXPAND | PNG_EXPAND_tRNS ) ;
nsIFocusManager * fm = nsFocusManager::GetFocusManager ( ) ; <NEW_LINE> if ( ! fm ) <NEW_LINE> return NS_OK ; <NEW_LINE> nsCOMPtr < nsIDOMElement > result ; <NEW_LINE> <START_VULN> return fm -> MoveFocus ( nsnull , this , nsIFocusManager::MOVEFOCUS_FORWARD , 0 , <NEW_LINE> <END_VULN> getter_AddRefs ( result ) ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsHTMLLegendElement::PerformAccesskey ( bool aKeyCausesActivation , <NEW_LINE> bool aIsTrustedEvent ) <NEW_LINE> {
if ( alu_dbl ( src1 , imm , dest , op , sc , c ) ) <NEW_LINE> return ; <NEW_LINE> if ( negOp != op_invalid && <NEW_LINE> <START_VULN> alu_dbl ( src1 , negImm , dest , negOp , sc , c ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> if ( hasMOVWT ( ) ) { <NEW_LINE> as_movw ( ScratchRegister , imm . value & 0xffff , c ) ;
void <NEW_LINE> gfxPattern::AddColorStop ( gfxFloat offset , const gfxRGBA & c ) <NEW_LINE> { <NEW_LINE> if ( mPattern ) { <NEW_LINE> mStops = NULL ; <NEW_LINE> if ( gfxPlatform::GetCMSMode ( ) == eCMSMode_All ) { <NEW_LINE> gfxRGBA cms ; <NEW_LINE> <START_VULN> gfxPlatform::TransformPixel ( c , cms , gfxPlatform::GetCMSRGBTransform ( ) ) ; <NEW_LINE> <END_VULN> cairo_pattern_add_color_stop_rgba ( mPattern , offset , <NEW_LINE> cms . r , cms . g , cms . b , c . a ) ; <NEW_LINE> } <NEW_LINE> else <NEW_LINE> cairo_pattern_add_color_stop_rgba ( mPattern , offset , c . r , c . g , c . b , c . a ) ;
} <NEW_LINE> } <NEW_LINE> if ( action ) { <NEW_LINE> <START_VULN> httpSetParam ( conn , "controller" , stok ( sclone ( rx -> target ) , " - " , & actionName ) ) ; <NEW_LINE> <END_VULN> httpSetParam ( conn , "action" , actionName ) ; <NEW_LINE> if ( eroute -> commonController ) { <NEW_LINE> ( eroute -> commonController ) ( conn ) ;
SiteFeatureUsage UsesAudioInBackground ( ) const override ; <NEW_LINE> SiteFeatureUsage UsesNotificationsInBackground ( ) const override ; <NEW_LINE> <START_VULN> const scoped_refptr < internal::LocalSiteCharacteristicsDataImpl > <NEW_LINE>impl_for_testing ( ) const { <NEW_LINE>return impl_ ; <NEW_LINE> <END_VULN> } <NEW_LINE> private:
} <NEW_LINE> } <NEW_LINE> PRInt32 FindMaxUshortElement ( ) { <NEW_LINE> if ( mHasCachedMaxUshortElement ) { <NEW_LINE> return mCachedMaxUshortElement ; <NEW_LINE> } else { <NEW_LINE> mHasCachedMaxUshortElement = true ; <NEW_LINE> <START_VULN> mCachedMaxUshortElement = FindMaxElementInSubArray < GLshort > ( mByteLength >> 1 , 0 ) ; <NEW_LINE> <END_VULN> return mCachedMaxUshortElement ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> NS_DECL_ISUPPORTS <NEW_LINE> NS_DECL_NSIWEBGLBUFFER <NEW_LINE> protected:
args = mprCreateHash ( 0 , MPR_HASH_STABLE ) ; <NEW_LINE> list = stolist ( remedyArgs ) ; <NEW_LINE> for ( ITERATE_ITEMS ( list , arg , next ) ) { <NEW_LINE> <START_VULN> key = stok ( arg , " = " , & value ) ; <NEW_LINE> <END_VULN> mprAddKey ( args , key , strim ( value , "\"'" , 0 ) ) ; <NEW_LINE> } <NEW_LINE> if ( ! remedy ) {
if ( _make_words ( lengthlist , s -> entries , <NEW_LINE> <START_VULN> s -> dec_table , quantvals , s , opb , maptype ) ) return 1 ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
EVP_MD_CTX_free ( hmac ) ; <NEW_LINE> return - 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! send && ! SSL_USE_ETM ( ssl ) && FIPS_mode ( ) ) <NEW_LINE> <END_VULN> if ( ! tls_fips_digest_extra ( ssl -> enc_read_ctx , <NEW_LINE> mac_ctx , rec -> input , <NEW_LINE> rec -> length , rec -> orig_len ) ) {
status = 0 ; <NEW_LINE> goto done ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( colb + tilew > imagew ) { <NEW_LINE> <END_VULN> uint32 width = imagew - colb ; <NEW_LINE> uint32 oskew = tilew - width ; <NEW_LINE> cpStripToTile ( bufp + colb ,
if ( attr ) <NEW_LINE> { <NEW_LINE> <START_VULN> attr -> value_tag = IPP_TAG_KEYWORD ; <NEW_LINE>cupsdSetString ( & ( attr -> values [ 0 ] . string . text ) , "no - hold" ) ; <NEW_LINE> <END_VULN> }
} <NEW_LINE> bool <NEW_LINE> GetElementParIC::attachTypedArrayElement ( LockedJSContext & cx , IonScript * ion , <NEW_LINE> TypedArrayObject * tarr , const Value & idval ) <NEW_LINE> { <NEW_LINE> MacroAssembler masm ( cx , ion ) ; <NEW_LINE> DispatchStubPrepender attacher ( * this ) ; <NEW_LINE> <START_VULN> GenerateGetTypedArrayElement ( cx , masm , attacher , tarr , idval , object ( ) , index ( ) , output ( ) ) ; <NEW_LINE> <END_VULN> return linkAndAttachStub ( cx , masm , attacher , ion , "parallel typed array" ) ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> GetElementParIC::update ( ForkJoinSlice * slice , size_t cacheIndex , HandleObject obj , <NEW_LINE> HandleValue idval , MutableHandleValue vp ) <NEW_LINE> { <NEW_LINE> AutoFlushCache afc ( "GetElementParCache" , slice -> runtime ( ) -> jitRuntime ( ) ) ;
bool browser_only_ = false ; <NEW_LINE> base::flat_map < std::string , std::unique_ptr < protocol::DevToolsDomainHandler >> <NEW_LINE> handlers_ ; <NEW_LINE> <START_VULN> RenderProcessHost * process_ ; <NEW_LINE> <END_VULN> RenderFrameHostImpl * host_ ; <NEW_LINE> std::unique_ptr < protocol::UberDispatcher > dispatcher_ ;
} <NEW_LINE> if ( ! silent ) <NEW_LINE> <START_VULN> printf ( "gamma % f: maximum 8 bit error % f\n" , g , maxerr ) ; <NEW_LINE> <END_VULN> maxerr = 0 ; <NEW_LINE> for ( j = 0 ; j < 65536 ; ++ j )
rootFrame -> Invalidate ( rect ) ; <NEW_LINE> if ( mCaretEnabled && mCaret ) { <NEW_LINE> mCaret -> CheckCaretDrawingState ( ) ; <NEW_LINE> } <NEW_LINE> nsRootPresContext * rootPC = mPresContext -> GetRootPresContext ( ) ; <NEW_LINE> if ( rootPC ) { <NEW_LINE> <START_VULN> rootPC -> RequestUpdatePluginGeometry ( rootFrame ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> nsPIDOMWindow * win = mDocument -> GetWindow ( ) ; <NEW_LINE> if ( win ) <NEW_LINE> win -> SetReadyForFocus ( ) ;
if ( mGraphiteShaper && gfxPlatform::GetPlatform ( ) -> UseGraphiteShaping ( ) ) { <NEW_LINE> ok = mGraphiteShaper -> ShapeText ( aContext , aText , <NEW_LINE> aOffset , aLength , <NEW_LINE> aScript , aShapedText ) ; <NEW_LINE> } <NEW_LINE> if ( ! ok && mHarfBuzzShaper ) { <NEW_LINE> <START_VULN> if ( gfxPlatform::GetPlatform ( ) -> UseHarfBuzzForScript ( aScript ) ) { <NEW_LINE> <END_VULN> ok = mHarfBuzzShaper -> ShapeText ( aContext , aText , aOffset , aLength , <NEW_LINE> aScript , aShapedText ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( ! ok ) { <NEW_LINE> GDIFontEntry * fe = static_cast < GDIFontEntry * > ( GetFontEntry ( ) ) ; <NEW_LINE> bool preferUniscribe =
} <NEW_LINE> } <NEW_LINE> <START_VULN> SkipDXTMipmaps ( image , dds_info , 16 ) ; <NEW_LINE><NEW_LINE>return MagickTrue ; <NEW_LINE> <END_VULN> } <NEW_LINE> static MagickBooleanType ReadUncompressedRGB ( Image * image , DDSInfo * dds_info ,
unsigned int i ; <NEW_LINE> for ( i = 0 ; i < ctx -> max_sz ; i ++ ) <NEW_LINE> <START_VULN> vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; <NEW_LINE> <END_VULN> free ( ctx -> buf ) ; <NEW_LINE> } <NEW_LINE> free ( ctx ) ;
if ( ! getNode ( ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> if ( equalIgnoringCase ( getAttribute ( aria_disabledAttr ) , "true" ) ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> if ( toElement ( getNode ( ) ) -> hasAttribute ( disabledAttr ) )
<START_VULN> if ( capacity * elemSize > size_type ( - 1 ) / 2 ) { <NEW_LINE> <END_VULN> NS_ERROR ( "Attempting to allocate excessively large array" ) ; <NEW_LINE> return PR_FALSE ; <NEW_LINE> }
return false ; <NEW_LINE> if ( ! js_IsCallable ( vp ) ) { <NEW_LINE> vp . setObject ( * obj ) ; <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> return Invoke ( cx , ObjectValue ( * obj ) , vp , 0 , NULL , vp . address ( ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> JSBool <NEW_LINE> <END_VULN> js::DefaultValue ( JSContext * cx , HandleObject obj , JSType hint , MutableHandleValue vp ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( hint == JSTYPE_NUMBER || hint == JSTYPE_STRING || hint == JSTYPE_VOID ) ; <NEW_LINE> Rooted < jsid > id ( cx ) ; <NEW_LINE> Class * clasp = obj -> getClass ( ) ; <NEW_LINE> if ( hint == JSTYPE_STRING ) {
goto out ; <NEW_LINE> else if ( ( addr = ( ulong ) shmaddr ) ) { <NEW_LINE> if ( addr & ( shmlba - 1 ) ) { <NEW_LINE> <START_VULN> if ( shmflg & SHM_RND ) <NEW_LINE>addr &= ~ ( shmlba - 1 ) ; <NEW_LINE> <END_VULN> else <NEW_LINE> #ifndef __ARCH_FORCE_SHMLBA <NEW_LINE> if ( addr & ~ PAGE_MASK )
NS_WARNING ( "Could not set up socket ! " ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> nsRefPtr < OnSocketEventTask > t = <NEW_LINE> new OnSocketEventTask ( this , OnSocketEventTask::CONNECT_SUCCESS ) ; <NEW_LINE> NS_DispatchToMainThread ( t ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>XRE_GetIOMessageLoop ( ) -> PostTask ( FROM_HERE , <NEW_LINE>new StartImplReadingTask ( this ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> UnixSocketImpl::SetNonblockFlags ( ) <NEW_LINE> { <NEW_LINE> int n = 1 ; <NEW_LINE> setsockopt ( mFd , SOL_SOCKET , SO_REUSEADDR , & n , sizeof ( n ) ) ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> #endif <NEW_LINE> nsresult nsPluginInstanceOwner::Init ( nsIContent * aContent ) <NEW_LINE> { <NEW_LINE> mLastEventloopNestingLevel = GetEventloopNestingLevel ( ) ; <NEW_LINE> <START_VULN> mContent = aContent ; <NEW_LINE> <END_VULN> nsIFrame * frame = aContent -> GetPrimaryFrame ( ) ; <NEW_LINE> nsIObjectFrame * iObjFrame = do_QueryFrame ( frame ) ; <NEW_LINE> nsPluginFrame * objFrame = static_cast < nsPluginFrame * > ( iObjFrame ) ; <NEW_LINE> if ( objFrame ) { <NEW_LINE> SetFrame ( objFrame ) ;
continue ; <NEW_LINE> case REOP_ASSERTTEST: <NEW_LINE> <START_VULN> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> -- curState ; <NEW_LINE> x -> cp = gData -> cpbegin + curState -> index ; <NEW_LINE> gData -> backTrackSP =
} <NEW_LINE> if ( val > maxval ) <NEW_LINE> <START_VULN> ERREXIT ( cinfo , JERR_PPM_TOOLARGE ) ; <NEW_LINE> <END_VULN> return val ; <NEW_LINE> }
MOZ_ASSERT ( NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> bool wantAllTraces = false ; <NEW_LINE> if ( aListener ) { <NEW_LINE> aListener -> GetWantAllTraces ( & wantAllTraces ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> mCollector -> GCIfNeeded ( wantAllTraces ) ; <NEW_LINE> <END_VULN> MutexAutoLock autoLock ( mLock ) ; <NEW_LINE> if ( ! mRunning ) <NEW_LINE> return ; <NEW_LINE> nsAutoTArray < PtrInfo * , 4000 > whiteNodes ; <NEW_LINE> if ( ! mCollector -> PrepareForCollection ( aResults , & whiteNodes ) )
if ( ! isNumber || maxModes == 0 ) maxModes = 1 ; <NEW_LINE> QStringList nickList ; <NEW_LINE> <START_VULN> if ( nicks == " * " ) { <NEW_LINE> <END_VULN> const QList < IrcUser * > users = network ( ) -> ircChannel ( bufferInfo . bufferName ( ) ) -> ircUsers ( ) ; <NEW_LINE> foreach ( IrcUser * user , users ) { <NEW_LINE> if ( ( addOrRemove == ' + ' && ! network ( ) -> ircChannel ( bufferInfo . bufferName ( ) ) -> userModes ( user ) . contains ( mode ) )
( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { <NEW_LINE> ext4_msg ( sb , KERN_ERR , "Journal does not support " <NEW_LINE> "requested data journaling mode" ) ; <NEW_LINE> <START_VULN> goto failed_mount4 ; <NEW_LINE> <END_VULN> } <NEW_LINE> default: <NEW_LINE> break ;
return site_identity_status_ ; <NEW_LINE> } <NEW_LINE> <START_VULN> const SafeBrowsingStatus & safe_browsing_status ( ) const { <NEW_LINE>return safe_browsing_status_ ; <NEW_LINE> } <NEW_LINE><NEW_LINE>const base::string16 & site_details_message ( ) const { <NEW_LINE>return site_details_message_ ; <NEW_LINE> <END_VULN> } <NEW_LINE> const base::string16 & organization_name ( ) const { return organization_name_ ; }
rv = BuildArrayRecursive ( curChild , inItemArray ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsresult nsDocShellBackwardsEnumerator::BuildArrayRecursive ( nsIDocShellTreeItem * inItem , nsVoidArray & inItemArray ) <NEW_LINE> <END_VULN> { <NEW_LINE> nsresult rv ; <NEW_LINE> nsCOMPtr < nsIDocShellTreeNode > itemAsNode = do_QueryInterface ( inItem , & rv ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE> PRInt32 numChildren ; <NEW_LINE> rv = itemAsNode -> GetChildCount ( & numChildren ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ;
nsGlobalWindow * frameWin = ( nsGlobalWindow * ) frame . get ( ) ; <NEW_LINE> NS_ASSERTION ( frameWin -> IsOuterWindow ( ) , "GetChildFrame gave us an inner ? " ) ; <NEW_LINE> frameWin -> EnsureInnerWindow ( ) ; <NEW_LINE> nsCOMPtr < nsIXPConnectJSObjectHolder > holder ; <NEW_LINE> jsval v ; <NEW_LINE> <START_VULN> rv = WrapNative ( cx , frameWin -> GetGlobalJSObject ( ) , frame , <NEW_LINE> & NS_GET_IID ( nsIDOMWindow ) , true , & v , <NEW_LINE> <END_VULN> getter_AddRefs ( holder ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> if ( ! JS_WrapValue ( cx , & v ) ) { <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> * vp = v ;
int slots = <NEW_LINE> #endif <NEW_LINE> FlushNativeStackFrame ( cx , innermost -> calldepth , <NEW_LINE> innermost -> stackTypeMap ( ) , <NEW_LINE> stack , NULL ) ; <NEW_LINE> JS_ASSERT ( unsigned ( slots ) == innermost -> numStackSlots ) ; <NEW_LINE> if ( innermost -> nativeCalleeWord ) <NEW_LINE> <START_VULN> SynthesizeSlowNativeFrame ( cx , innermost ) ; <NEW_LINE> <END_VULN> double * global = ( double * ) ( & state + 1 ) ; <NEW_LINE> FlushNativeGlobalFrame ( cx , global , <NEW_LINE> ngslots , gslots , globalTypeMap ) ; <NEW_LINE> #ifdef DEBUG <NEW_LINE> for ( JSStackFrame * fp = cx -> fp ; fp ; fp = fp -> down ) {
return ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_ptr -> num_trans = 0 ; <NEW_LINE> return ;
{ <NEW_LINE> WebGLuint progname ; <NEW_LINE> if ( ! GetGLName < WebGLProgram > ( "validateProgram" , pobj , & progname ) ) <NEW_LINE> return NS_OK ; <NEW_LINE> MakeContextCurrent ( ) ; <NEW_LINE> #ifdef XP_MACOSX <NEW_LINE> <START_VULN> if ( gl -> Vendor ( ) == gl::GLContext::VendorNVIDIA ) { <NEW_LINE>LogMessageIfVerbose ( "validateProgram: implemented as a no - operation " <NEW_LINE>"on Mac / NVIDIA to work around a driver crash" ) ; <NEW_LINE>return NS_OK ; <NEW_LINE> } <NEW_LINE> <END_VULN> #endif <NEW_LINE> gl -> fValidateProgram ( progname ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP
V8URLSearchParams::toImpl ( body . As < v8::Object > ( ) ) -> toEncodedFormData ( ) ; <NEW_LINE> bodyBuffer = new BodyStreamBuffer ( scriptState , FetchFormDataConsumerHandle::create ( executionContext , formData . release ( ) ) ) ; <NEW_LINE> contentType = "application / x - www - form - urlencoded ; charset = UTF - 8" ; <NEW_LINE> <START_VULN> } else if ( RuntimeEnabledFeatures::responseConstructedWithReadableStreamEnabled ( ) && ReadableStreamOperations::isReadableStream ( scriptState , bodyValue ) ) { <NEW_LINE>if ( RuntimeEnabledFeatures::responseBodyWithV8ExtraStreamEnabled ( ) ) { <NEW_LINE>bodyBuffer = new BodyStreamBuffer ( scriptState , bodyValue ) ; <NEW_LINE> } else { <NEW_LINE>std::unique_ptr < FetchDataConsumerHandle > bodyHandle ; <NEW_LINE>reader = ReadableStreamOperations::getReader ( scriptState , bodyValue , exceptionState ) ; <NEW_LINE>if ( exceptionState . hadException ( ) ) { <NEW_LINE>reader = ScriptValue ( ) ; <NEW_LINE>bodyHandle = createFetchDataConsumerHandleFromWebHandle ( createUnexpectedErrorDataConsumerHandle ( ) ) ; <NEW_LINE>exceptionState . clearException ( ) ; <NEW_LINE> } else { <NEW_LINE>bodyHandle = ReadableStreamDataConsumerHandle::create ( scriptState , reader ) ; <NEW_LINE> } <NEW_LINE>bodyBuffer = new BodyStreamBuffer ( scriptState , std::move ( bodyHandle ) ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } else { <NEW_LINE> String string = toUSVString ( isolate , body , exceptionState ) ; <NEW_LINE> if ( exceptionState . hadException ( ) )
nsAutoCString buf1 ; <NEW_LINE> if ( net_FilterURIString ( spec , buf1 ) ) { <NEW_LINE> spec = buf1 . get ( ) ; <NEW_LINE> specLength = buf1 . Length ( ) ; <NEW_LINE> } <NEW_LINE> nsresult rv = ParseURL ( spec , specLength ) ; <NEW_LINE> <START_VULN> if ( NS_FAILED ( rv ) ) return rv ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>rv = BuildNormalizedSpec ( spec ) ; <NEW_LINE> <END_VULN> #if defined ( PR_LOGGING ) <NEW_LINE> if ( LOG_ENABLED ( ) ) { <NEW_LINE> LOG ( ( " spec = % s\n" , mSpec . get ( ) ) ) ; <NEW_LINE> LOG ( ( " port = % d\n" , mPort ) ) ; <NEW_LINE> LOG ( ( " scheme = ( % u , % d ) \n" , mScheme . mPos , mScheme . mLen ) ) ; <NEW_LINE> LOG ( ( " authority = ( % u , % d ) \n" , mAuthority . mPos , mAuthority . mLen ) ) ; <NEW_LINE> LOG ( ( " username = ( % u , % d ) \n" , mUsername . mPos , mUsername . mLen ) ) ;
NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> UpgradeSchemaFrom9_0To10_0 ( mozIStorageConnection * aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "UpgradeSchemaFrom9_0To10_0" ) ; <NEW_LINE> nsresult rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( <NEW_LINE> "ALTER TABLE object_data ADD COLUMN file_ids TEXT ; " <NEW_LINE> ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
#endif <NEW_LINE> mWnd = nsnull ; <NEW_LINE> mPaintDC = nsnull ; <NEW_LINE> mPrevWndProc = nsnull ; <NEW_LINE> mDeferredPositioner = nsnull ; <NEW_LINE> mOldIMC = nsnull ; <NEW_LINE> mNativeDragTarget = nsnull ; <NEW_LINE> <START_VULN> mIsDestroying = PR_FALSE ; <NEW_LINE> <END_VULN> mIsVisible = PR_FALSE ; <NEW_LINE> mHas3DBorder = PR_FALSE ; <NEW_LINE> mIsInMouseCapture = PR_FALSE ; <NEW_LINE> mIsPluginWindow = PR_FALSE ; <NEW_LINE> mIsTopWidgetWindow = PR_FALSE ; <NEW_LINE> mInWheelProcessing = PR_FALSE ; <NEW_LINE> mUnicodeWidget = PR_TRUE ; <NEW_LINE> mWindowType = eWindowType_child ;
return false ; <NEW_LINE> const bool cues_open = chunk_writer_cues_ -> Open ( name ) ; <NEW_LINE> <START_VULN> delete [ ] name ; <NEW_LINE> <END_VULN> if ( ! cues_open ) <NEW_LINE> return false ; <NEW_LINE> }
const AffineTransform & localToSVGParentTransform ( ) const override { return m_localToParentTransform ; } <NEW_LINE> void calcViewport ( ) override ; <NEW_LINE> <START_VULN> bool calculateLocalTransform ( ) override ; <NEW_LINE> <END_VULN> bool pointIsInsideViewportClip ( const FloatPoint & pointInParent ) override ;
ND_PRINT ( ( ndo , " ( length bogus , should be >= 4 ) " ) ) ; <NEW_LINE> return len ; <NEW_LINE> } <NEW_LINE> <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , ": Features: % u , PxP: % s , History: % u , #CTX - ID: % u" , <NEW_LINE> ( p [ 2 ] & 0xc0 ) >> 6 , <NEW_LINE> ( p [ 2 ] & 0x20 ) ? "Enabled" : "Disabled" ,
if ( newContent -> IsRootOfAnonymousSubtree ( ) ) { <NEW_LINE> return NS_ERROR_DOM_NOT_SUPPORTED_ERR ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsINode * oldParent = newContent -> GetNodeParent ( ) ; <NEW_LINE> <END_VULN> if ( oldParent ) { <NEW_LINE> PRInt32 removeIndex = oldParent -> IndexOf ( newContent ) ; <NEW_LINE> if ( removeIndex < 0 ) { <NEW_LINE> NS_ERROR ( "How come our flags didn't catch this ? " ) ; <NEW_LINE> return NS_ERROR_DOM_NOT_SUPPORTED_ERR ; <NEW_LINE> }
<START_VULN> int count = recv ( fd , buffer , L2CAP_MAX_SDU_LENGTH , <NEW_LINE>MSG_NOSIGNAL | MSG_DONTWAIT ) ; <NEW_LINE> <END_VULN> APPL_TRACE_DEBUG ( "btsock_l2cap_signaled - % d bytes received from socket" , <NEW_LINE> count ) ; <NEW_LINE> if ( sock -> fixed_chan ) {
WiFiDisplayMediaDatagramPacket ( WiFiDisplayMediaDatagramPacket && ) ; <NEW_LINE> private: <NEW_LINE> <START_VULN> DISALLOW_COPY_AND_ASSIGN_WITH_MOVE_FOR_BIND ( WiFiDisplayMediaDatagramPacket ) ; <NEW_LINE> <END_VULN> } ;
m_pOutput_pmem [ i ] . size = m_sOutPortDef . nBufferSize ; <NEW_LINE> m_pOutput_pmem [ i ] . offset = 0 ; <NEW_LINE> <START_VULN> m_pOutput_pmem [ i ] . buffer = ( OMX_U8 * ) SECURE_BUFPTR ; <NEW_LINE> <END_VULN> if ( ! secure_session ) { <NEW_LINE> #ifdef _MSM8974_ <NEW_LINE> m_pOutput_pmem [ i ] . buffer = ( unsigned char * ) mmap ( NULL ,
ctxt = xmlRelaxNGNewValidCtxt ( schema ) ; <NEW_LINE> xmlRelaxNGSetValidErrors ( ctxt , <NEW_LINE> <START_VULN> ( xmlRelaxNGValidityErrorFunc ) fprintf , <NEW_LINE> ( xmlRelaxNGValidityWarningFunc ) fprintf , <NEW_LINE>stderr ) ; <NEW_LINE> <END_VULN> ret = xmlRelaxNGValidateDoc ( ctxt , doc ) ; <NEW_LINE> if ( ret == 0 ) { <NEW_LINE> printf ( " % s validates\n" , argv [ i ] ) ;
return SetOuterObject ( cx , outer ) ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsGlobalWindow::SetOuterObject ( JSContext * aCx , JS::Handle < JSObject * > aOuterObject ) <NEW_LINE> { <NEW_LINE> JSAutoCompartment ac ( aCx , aOuterObject ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> JS_SetGlobalObject ( aCx , aOuterObject ) ; <NEW_LINE> JSObject * inner = JS_GetParent ( aOuterObject ) ; <NEW_LINE> JS::Rooted < JSObject * > proto ( aCx ) ; <NEW_LINE> if ( ! JS_GetPrototype ( aCx , inner , proto . address ( ) ) ) { <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> }
* <NEW_LINE> #ifndef _nsCrypto_h_ <NEW_LINE> #define _nsCrypto_h_ <NEW_LINE> #include "nsCOMPtr . h" <NEW_LINE> #include "nsIDOMCRMFObject . h" <NEW_LINE> #include "nsIDOMCrypto . h" <NEW_LINE> <START_VULN> #include "nsIDOMPkcs11 . h" <NEW_LINE> <END_VULN> #include "nsIRunnable . h" <NEW_LINE> #include "nsString . h" <NEW_LINE> #include "jsapi . h" <NEW_LINE> #include "nsIPrincipal . h" <NEW_LINE> #define NS_CRYPTO_CLASSNAME "Crypto JavaScript Class" <NEW_LINE> #define NS_CRYPTO_CID \ <NEW_LINE> { 0x929d9320 , 0x251e , 0x11d4 , { 0x8a , 0x7c , 0x00 , 0x60 , 0x08 , 0xc8 , 0x44 , 0xc3 } }
MCRYPT_GET_TD_ARG <NEW_LINE> if ( mcrypt_enc_is_block_algorithm ( pm -> td ) == 1 ) { <NEW_LINE> <START_VULN> RETURN_TRUE <NEW_LINE> <END_VULN> } else { <NEW_LINE> RETURN_FALSE <NEW_LINE> }
gMediaCache -> NoteBlockUsage ( this , cacheBlock , mCurrentMode , TimeStamp::Now ( ) ) ; <NEW_LINE> PRInt64 offset = cacheBlock * BLOCK_SIZE + offsetInStreamBlock ; <NEW_LINE> <START_VULN> nsresult rv = gMediaCache -> ReadCacheFile ( offset , aBuffer + count , size , & bytes ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) ) { <NEW_LINE> if ( count == 0 ) <NEW_LINE> return rv ;
default: <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> start ++ ; <NEW_LINE> <START_VULN> nsresult nsIDNService::decodeACE ( const nsACString & in , nsACString & out ) <NEW_LINE> <END_VULN> { <NEW_LINE> PRBool isAce ; <NEW_LINE> IsACE ( in , & isAce ) ; <NEW_LINE> if ( ! isAce ) { <NEW_LINE> out . Assign ( in ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
class DSA_Signature_Operation final : public PK_Ops::Signature_with_EMSA <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> <START_VULN> DSA_Signature_Operation ( const DSA_PrivateKey & dsa , const std::string & emsa ) : <NEW_LINE> <END_VULN> PK_Ops::Signature_with_EMSA ( emsa ) , <NEW_LINE> m_group ( dsa . get_group ( ) ) , <NEW_LINE> m_x ( dsa . get_x ( ) ) ,
if ( p == 0 ) <NEW_LINE> return 1 . 0 ; <NEW_LINE> return pow ( d , p ) ; <NEW_LINE> } <NEW_LINE> static jsdouble FASTCALL <NEW_LINE> math_random_tn ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> <START_VULN> return random_nextDouble ( JS_THREAD_DATA ( cx ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static jsdouble FASTCALL <NEW_LINE> math_round_tn ( jsdouble x ) <NEW_LINE> { <NEW_LINE> return js_copysign ( floor ( x + 0 . 5 ) , x ) ; <NEW_LINE> }
unsigned int lci , new_lci ; <NEW_LINE> unsigned char cause , diagnostic ; <NEW_LINE> struct net_device * dev ; <NEW_LINE> <START_VULN> int len , res = 0 ; <NEW_LINE> <END_VULN> char buf [ 11 ] ; <NEW_LINE> #if 0
else { <NEW_LINE> NS_ERROR ( "forward references have already been resolved" ) ; <NEW_LINE> delete aRef ; <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> nsresult <NEW_LINE> nsXULDocument::ResolveForwardReferences ( ) <NEW_LINE> { <NEW_LINE> if ( mResolutionPhase == nsForwardReference::eDone ) <NEW_LINE> return NS_OK ; <NEW_LINE> const nsForwardReference::Phase * pass = nsForwardReference::kPasses ; <NEW_LINE> while ( ( mResolutionPhase = * pass ) != nsForwardReference::eDone ) {
} <NEW_LINE> bool VideoTrack::SetAlphaMode ( uint64 alpha_mode ) { <NEW_LINE> <START_VULN> if ( alpha_mode != kNoAlpha && <NEW_LINE>alpha_mode != kAlpha ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> alpha_mode_ = alpha_mode ;
void CreateDownloadDir ( ) ; <NEW_LINE> void StartURLFetch ( const GURL & url ) ; <NEW_LINE> <START_VULN> void OnNetworkFetcherComplete ( base::FilePath file_path , <NEW_LINE>int net_error , <NEW_LINE>int64_t content_size ) ; <NEW_LINE> <END_VULN> void OnResponseStarted ( int response_code , int64_t content_length ) ; <NEW_LINE> void OnDownloadProgress ( int64_t content_length ) ;
} <NEW_LINE> pos += cluster_size ; <NEW_LINE> <START_VULN> assert ( ( segment_stop < 0 ) || ( pos <= segment_stop ) ) ; <NEW_LINE> <END_VULN> return 2 ; <NEW_LINE> }
if ( file_seek ( wth -> fh , frame_table_offset , SEEK_SET , err ) == - 1 ) { <NEW_LINE> return - 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> frame_table = ( guint32 * ) g_malloc ( frame_table_length ) ; <NEW_LINE> <END_VULN> errno = WTAP_ERR_CANT_READ ; <NEW_LINE> bytes_read = file_read ( frame_table , frame_table_length , wth -> fh ) ; <NEW_LINE> if ( ( guint32 ) bytes_read != frame_table_length ) {
if ( ! ( block = nlmsvc_find_block ( cookie ) ) ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> if ( block ) { <NEW_LINE>if ( status == nlm_lck_denied_grace_period ) { <NEW_LINE><NEW_LINE>nlmsvc_insert_block ( block , 10 * HZ ) ; <NEW_LINE> } else { <NEW_LINE><NEW_LINE>nlmsvc_unlink_block ( block ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> nlmsvc_release_block ( block ) ; <NEW_LINE> }
else if ( ! ctx -> iface || ! ctx -> priv ) <NEW_LINE> res = VPX_CODEC_ERROR ; <NEW_LINE> else { <NEW_LINE> <START_VULN> if ( ctx -> priv -> alg_priv ) <NEW_LINE>ctx -> iface -> destroy ( ctx -> priv -> alg_priv ) ; <NEW_LINE> <END_VULN> ctx -> iface = NULL ; <NEW_LINE> ctx -> name = NULL ;
<START_VULN> bool ReplyToRenderer ( const IPC::ChannelHandle & channel_handle ) ; <NEW_LINE> <END_VULN>
filePathLen -- ; <NEW_LINE> } <NEW_LINE> WCHAR * lowercasePath = new WCHAR [ filePathLen + 2 ] ; <NEW_LINE> <START_VULN> wcscpy ( lowercasePath , filePath ) ; <NEW_LINE> <END_VULN> _wcslwr ( lowercasePath ) ; <NEW_LINE> BYTE * hash ; <NEW_LINE> DWORD hashSize = 0 ; <NEW_LINE> if ( ! CalculateMD5 ( reinterpret_cast < const char * > ( lowercasePath ) , <NEW_LINE> filePathLen * 2 , <NEW_LINE> & hash , hashSize ) ) { <NEW_LINE> delete [ ] lowercasePath ;
if ( ua ) { <NEW_LINE> efree ( ua ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> } <NEW_LINE> if ( user_headers ) {
if ( byte_run > 0 ) { <NEW_LINE> pixel = AV_RL16 ( & buf [ stream_ptr ] ) ; <NEW_LINE> stream_ptr += 2 ; <NEW_LINE> <START_VULN> CHECK_PIXEL_PTR ( byte_run ) ; <NEW_LINE> <END_VULN> for ( j = 0 ; j < byte_run ; j ++ ) { <NEW_LINE> * ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel ; <NEW_LINE> pixel_ptr += 2 ;
vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; <NEW_LINE> <START_VULN> if ( p -> eobs [ block ] > 0 ) <NEW_LINE>xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void vp9_encode_sby_pass1 ( MACROBLOCK * x , BLOCK_SIZE bsize ) {
<START_VULN> found = ( unsigned char * ) php_memnstr ( ( char * ) haystack + offset , ( char * ) needle , needle_len , ( char * ) haystack + haystack_len ) ; <NEW_LINE> <END_VULN> if ( ! found ) {
<START_VULN> if ( ! ( png_ptr -> flags & PNG_FLAG_ROW_INIT ) ) <NEW_LINE> <END_VULN> png_read_start_row ( png_ptr ) ;
{ <NEW_LINE> errmsg = JS_NewStringCopyZ ( cx , LOAD_ERROR_READUNDERFLOW ) ; <NEW_LINE> goto return_exception ; <NEW_LINE> } <NEW_LINE> <START_VULN> rv = mSystemPrincipal -> GetJSPrincipals ( cx , & jsPrincipals ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) || ! jsPrincipals ) <NEW_LINE> { <NEW_LINE> errmsg = JS_NewStringCopyZ ( cx , LOAD_ERROR_NOPRINCIPALS ) ; <NEW_LINE> goto return_exception ; <NEW_LINE> }
void DestroyWhenUsingTooManyResources ( ) ; <NEW_LINE> <START_VULN> RenderViewHost * render_view_host ( ) { return render_view_host_ ; } <NEW_LINE> <END_VULN>
nsRefPtr < nsPluginHost > ph = nsPluginHost::GetInst ( ) ; <NEW_LINE> if ( ph ) { <NEW_LINE> nsPluginTag * tag = ph -> TagForPlugin ( mPlugin ) ; <NEW_LINE> if ( tag ) { <NEW_LINE> pluginName = tag -> mName ; <NEW_LINE> pluginVersion = tag -> mVersion ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> notes . Put ( NS_LITERAL_CSTRING ( "PluginName" ) , pluginName ) ; <NEW_LINE> notes . Put ( NS_LITERAL_CSTRING ( "PluginVersion" ) , pluginVersion ) ; <NEW_LINE> CrashReporterParent * crashReporter = CrashReporter ( ) ; <NEW_LINE> if ( crashReporter ) { <NEW_LINE> #ifdef XP_WIN <NEW_LINE> if ( mPluginCpuUsageOnHang . Length ( ) > 0 ) { <NEW_LINE> notes . Put ( NS_LITERAL_CSTRING ( "NumberOfProcessors" ) ,
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestSerializedScriptValueInterface::s_info ) ; <NEW_LINE> TestSerializedScriptValueInterface * impl = static_cast < TestSerializedScriptValueInterface * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> RefPtr < SerializedScriptValue > data ( SerializedScriptValue::create ( exec , MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
PRBool <NEW_LINE> CVE_2011_2980_ThinkPadSensor::Startup ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> mLibrary = LoadLibraryW ( L"sensor . dll" ) ; <NEW_LINE> <END_VULN> if ( ! mLibrary ) <NEW_LINE> return PR_FALSE ;
if ( bitmapUpdate -> number > bitmapUpdate -> count ) <NEW_LINE> { <NEW_LINE> <START_VULN> UINT16 count ; <NEW_LINE>BITMAP_DATA * newdata ; <NEW_LINE>count = bitmapUpdate -> number * 2 ; <NEW_LINE>newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , <NEW_LINE>sizeof ( BITMAP_DATA ) * count ) ; <NEW_LINE> <END_VULN> if ( ! newdata ) <NEW_LINE> goto fail ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File: magic . c , v 1 . 89 2014 / 11 / 28 02:46:39 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include "magic . h"
double ConvolverNode::latencyTime ( ) const <NEW_LINE> { <NEW_LINE> <START_VULN> return m_reverb ? m_reverb -> latencyFrames ( ) / static_cast < double > ( sampleRate ( ) ) : 0 ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
text_info . text = text ; <NEW_LINE> text_info . text_length = strlen ( text ) ; <NEW_LINE> <START_VULN> if ( png_set_text_2 ( png_ptr , info_ptr , & text_info , 1 ) ) <NEW_LINE> <END_VULN> png_warning ( png_ptr , "Insufficient memory to process text chunk" ) ; <NEW_LINE> } <NEW_LINE> #endif
return bHavePrivateHTMLFlavor ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsHTMLEditor::Paste ( int32_t aSelectionType ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! FireClipboardEvent ( NS_PASTE ) ) <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> nsresult rv ; <NEW_LINE> nsCOMPtr < nsIClipboard > clipboard ( do_GetService ( "@mozilla . org / widget / clipboard ; 1" , & rv ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ;
<START_VULN> if ( ( fd = open ( clonedev , O_RDWR ) ) < 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> BTIF_TRACE_DEBUG ( "could not open % s , err: % d" , clonedev , errno ) ; <NEW_LINE> return fd ;
if ( ! expected ) { <NEW_LINE> unaligned_fixups_notify ( current , instruction , regs ) ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <NEW_LINE> <END_VULN> regs , address ) ; <NEW_LINE> }
<START_VULN> detach ( ) ; <NEW_LINE> <END_VULN> m_inputType -> destroyShadowSubtree ( ) ; <NEW_LINE> m_inputType -> createShadowSubtree ( ) ; <NEW_LINE> if ( ! attached ( ) ) <NEW_LINE> attach ( ) ;
if ( status == MagickFalse ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> Ar = GetCacheViewVirtualPixels ( Ar_view , 0 , y , <NEW_LINE>MagickMax ( Ar_image -> columns , Cr_image -> columns ) , 1 , exception ) ; <NEW_LINE>Ai = GetCacheViewVirtualPixels ( Ai_view , 0 , y , <NEW_LINE>MagickMax ( Ai_image -> columns , Ci_image -> columns ) , 1 , exception ) ; <NEW_LINE>Br = GetCacheViewVirtualPixels ( Br_view , 0 , y , <NEW_LINE>MagickMax ( Br_image -> columns , Cr_image -> columns ) , 1 , exception ) ; <NEW_LINE>Bi = GetCacheViewVirtualPixels ( Bi_view , 0 , y , <NEW_LINE>MagickMax ( Bi_image -> columns , Ci_image -> columns ) , 1 , exception ) ; <NEW_LINE> <END_VULN> Cr = QueueCacheViewAuthenticPixels ( Cr_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE> Ci = QueueCacheViewAuthenticPixels ( Ci_view , 0 , y , Ci_image -> columns , 1 , exception ) ; <NEW_LINE> if ( ( Ar == ( const Quantum * ) NULL ) || ( Ai == ( const Quantum * ) NULL ) ||
box ( ) . setPreviousPaintInvalidationRect ( box ( ) . boundsRectForPaintInvalidation ( paintInvalidationContainer ) ) ; <NEW_LINE> frameView -> updateAnnotatedRegions ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>frameView -> updateWidgetPositions ( ) ; <NEW_LINE>RELEASE_ASSERT ( frameView -> renderView ( ) ) ; <NEW_LINE> <END_VULN> updateCompositingLayersAfterScroll ( ) ; <NEW_LINE> }
int ( * init ) ( bt_callbacks_t * callbacks ) ; <NEW_LINE> <START_VULN> int ( * enable ) ( void ) ; <NEW_LINE> <END_VULN> int ( * disable ) ( void ) ;
} <NEW_LINE> } ; <NEW_LINE> NS_IMPL_ISUPPORTS1 ( CompressDataBlobsFunction , mozIStorageFunction ) <NEW_LINE> nsresult <NEW_LINE> UpgradeSchemaFrom8To9_0 ( mozIStorageConnection * aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "UpgradeSchemaFrom8To9_0" ) ; <NEW_LINE> nsresult rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( <NEW_LINE> "UPDATE database SET dataVersion = 0 ; " <NEW_LINE> ) ) ;
yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != '"' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 610 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> size_t len , maxlen ; <NEW_LINE> char * str ;
for ( midx = 0 ; midx < INTER_MODES ; ++ midx ) <NEW_LINE> bsi -> rdstat [ iy ] [ midx ] . brdcost = INT64_MAX ; <NEW_LINE> bsi -> segment_rd = INT64_MAX ; <NEW_LINE> <START_VULN> return ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
<START_VULN> #line 182 "hex_grammar . c" <NEW_LINE> <END_VULN> #ifdef short <NEW_LINE> # undef short
nsAutoString buffer ; <NEW_LINE> rv = aUnicodeDecoder -> GetMaxLength ( aANSIString , numberOfBytes , & outUnicodeLen ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> <START_VULN> buffer . SetCapacity ( outUnicodeLen ) ; <NEW_LINE> <END_VULN> rv = aUnicodeDecoder -> Convert ( aANSIString , & numberOfBytes , buffer . BeginWriting ( ) , & outUnicodeLen ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> buffer . SetLength ( outUnicodeLen ) ;
phar_flush ( phar_obj -> arc . archive , stub , stub_len , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> }
<START_VULN> static PNG_CONST color_encoding test_encodings [ ] = <NEW_LINE> <END_VULN> { <NEW_LINE> { 1 / 2 . 2 ,
png_debug1 ( 1 , "in % s retrieval function" , "cHRM" ) ; <NEW_LINE> if ( png_ptr != NULL && info_ptr != NULL && <NEW_LINE> <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( white_x != NULL ) <NEW_LINE> * white_x = info_ptr -> colorspace . end_points_xy . whitex ;
#endif <NEW_LINE> <START_VULN> if ( transforms & PNG_TRANSFORM_SWAP_ALPHA ) <NEW_LINE> <END_VULN> #ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED <NEW_LINE> png_set_swap_alpha ( png_ptr ) ; <NEW_LINE> #else
dp . diph . dwHow = DIPH_DEVICE ; <NEW_LINE> if ( gamepad . device -> GetProperty ( DIPROP_VIDPID , & dp . diph ) == DI_OK ) { <NEW_LINE> sprintf ( gamepad . idstring , " % x - % x - % s" , <NEW_LINE> LOWORD ( dp . dwData ) , HIWORD ( dp . dwData ) , gamepad . name ) ; <NEW_LINE> } <NEW_LINE> DIDEVCAPS caps ; <NEW_LINE> caps . dwSize = sizeof ( DIDEVCAPS ) ; <NEW_LINE> if ( gamepad . device -> GetCapabilities ( & caps ) == DI_OK ) { <NEW_LINE> <START_VULN> gamepad . numAxes = caps . dwAxes ; <NEW_LINE> <END_VULN> gamepad . numHats = caps . dwPOVs ; <NEW_LINE> gamepad . numButtons = caps . dwButtons ; <NEW_LINE> } <NEW_LINE> gamepad . device -> EnumObjects ( EnumObjectsCallback , & gamepad , DIDFT_AXIS ) ; <NEW_LINE> dp . diph . dwHeaderSize = sizeof ( DIPROPHEADER ) ; <NEW_LINE> dp . diph . dwSize = sizeof ( DIPROPDWORD ) ; <NEW_LINE> dp . diph . dwObj = 0 ; <NEW_LINE> dp . diph . dwHow = DIPH_DEVICE ; <NEW_LINE> dp . dwData = 64 ;
static String HHVM_FUNCTION ( bcmul , const String & left , const String & right , <NEW_LINE> int64_t scale ) { <NEW_LINE> <START_VULN> if ( scale < 0 ) scale = BCG ( bc_precision ) ; <NEW_LINE> <END_VULN> bc_num first , second , result ; <NEW_LINE> bc_init_num ( & first ) ; <NEW_LINE> bc_init_num ( & second ) ;
bool nsWindow::DispatchPluginEvent ( UINT aMessage , <NEW_LINE> WPARAM aWParam , <NEW_LINE> LPARAM aLParam , <NEW_LINE> bool aDispatchPendingEvents ) <NEW_LINE> { <NEW_LINE> bool ret = nsWindowBase::DispatchPluginEvent ( <NEW_LINE> WinUtils::InitMSG ( aMessage , aWParam , aLParam , mWnd ) ) ; <NEW_LINE> <START_VULN> if ( aDispatchPendingEvents ) { <NEW_LINE> <END_VULN> DispatchPendingEvents ( ) ; <NEW_LINE> } <NEW_LINE> return ret ; <NEW_LINE> } <NEW_LINE> bool nsWindow::DispatchMouseEvent ( uint32_t aEventType , WPARAM wParam , <NEW_LINE> LPARAM lParam , bool aIsContextMenuKey ,
if ( png_muldiv ( & res , ( png_int_32 ) info_ptr -> y_pixels_per_unit , PNG_FP_1 , <NEW_LINE> <START_VULN> ( png_int_32 ) info_ptr -> x_pixels_per_unit ) ) <NEW_LINE> <END_VULN> return res ; <NEW_LINE> } <NEW_LINE> #else
} <NEW_LINE> int main ( int argc , char * argv [ ] ) { <NEW_LINE> <START_VULN> p_fm_config_conx_hdlt hdl ; <NEW_LINE> <END_VULN> int instance = 0 ; <NEW_LINE> fm_mgr_config_errno_t res ; <NEW_LINE> char * rem_addr = NULL ;
<START_VULN> length = ( MagickSizeType ) ReadBlobByte ( image ) ; <NEW_LINE> <END_VULN> combined_length += length + 1 ; <NEW_LINE> if ( length > 0 ) <NEW_LINE> ( void ) ReadBlob ( image , ( size_t ) length ++ , layer_info [ i ] . name ) ;
fname -> disk_name . len = iname -> len ; <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> ret = fscrypt_get_crypt_info ( dir ) ; <NEW_LINE> <END_VULN> if ( ret && ret != - EOPNOTSUPP ) <NEW_LINE> return ret ;
nsSMILTimeValueSpec::IsWhitelistedEvent ( ) <NEW_LINE> { <NEW_LINE> if ( mParams . mType == nsSMILTimeValueSpecParams::REPEAT ) { <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> if ( mParams . mType == nsSMILTimeValueSpecParams::EVENT && <NEW_LINE> ( mParams . mEventSymbol == nsGkAtoms::repeat || <NEW_LINE> <START_VULN> mParams . mEventSymbol == NS_NewAtom ( "repeatEvent" ) || <NEW_LINE>mParams . mEventSymbol == NS_NewAtom ( "beginEvent" ) || <NEW_LINE>mParams . mEventSymbol == NS_NewAtom ( "endEvent" ) ) ) { <NEW_LINE> <END_VULN> return true ; <NEW_LINE> } <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsSMILTimeValueSpec::RegisterEventListener ( Element * aTarget )
void NormalPageArena::promptlyFreeObject ( HeapObjectHeader * header ) { <NEW_LINE> ASSERT ( ! getThreadState ( ) -> sweepForbidden ( ) ) ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> Address address = reinterpret_cast < Address > ( header ) ; <NEW_LINE> Address payload = header -> payload ( ) ; <NEW_LINE> size_t size = header -> size ( ) ;
{ <NEW_LINE> register u_int i ; <NEW_LINE> register char * cp ; <NEW_LINE> <START_VULN> register struct enamemem * tp ; <NEW_LINE> <END_VULN> if ( len == 0 ) <NEW_LINE> return ( " < empty > " ) ;
return - 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( hdr -> hdr . orig_len > WTAP_MAX_PACKET_SIZE ) { <NEW_LINE><NEW_LINE> * err = WTAP_ERR_BAD_FILE ; <NEW_LINE>if ( err_info != NULL ) { <NEW_LINE> * err_info = g_strdup_printf ( "pcap: File has % u - byte packet , bigger than maximum of % u" , <NEW_LINE>hdr -> hdr . orig_len , WTAP_MAX_PACKET_SIZE ) ; <NEW_LINE> } <NEW_LINE>return - 1 ; <NEW_LINE> <END_VULN> } <NEW_LINE> return bytes_read ;
for ( i = - 32 ; i < 32 ; i ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> const int v = ( int ) ( . 5 + 256 * vp8_gaussian ( sigma , 0 , i ) ) ; <NEW_LINE> <END_VULN> if ( v ) <NEW_LINE> {
enum dma_data_direction direction ; <NEW_LINE> struct list_head frmr_list ; <NEW_LINE> } ; <NEW_LINE> <START_VULN> struct svc_rdma_req_map { <NEW_LINE>struct list_head free ; <NEW_LINE>unsigned long count ; <NEW_LINE>union { <NEW_LINE>struct kvec sge [ RPCSVC_MAXPAGES ] ; <NEW_LINE>struct svc_rdma_chunk_sge ch [ RPCSVC_MAXPAGES ] ; <NEW_LINE>unsigned long lkey [ RPCSVC_MAXPAGES ] ; <NEW_LINE> } ; <NEW_LINE> } ; <NEW_LINE> <END_VULN> #define RDMACTXT_F_LAST_CTXT 2 <NEW_LINE> #define SVCRDMA_DEVCAP_FAST_REG 1
pixel . blue &= mask ; <NEW_LINE> if ( scale != ( Quantum * ) NULL ) <NEW_LINE> { <NEW_LINE> <START_VULN> pixel . red = scale [ pixel . red ] ; <NEW_LINE>pixel . green = scale [ pixel . green ] ; <NEW_LINE>pixel . blue = scale [ pixel . blue ] ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> SetPixelRed ( image , ( Quantum ) pixel . red , q ) ;
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1 ; <NEW_LINE> else <NEW_LINE> <START_VULN> max [ 1 ] = 31 ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] ) {
def = sfmt ( " [ % s ] " , sjoinArgs ( argc - 2 , ( cchar ** ) & argv [ 2 ] , " , " ) ) ; <NEW_LINE> abilities = mprParseJson ( def ) ; <NEW_LINE> key = sfmt ( "app . http . auth . roles . % s" , rolename ) ; <NEW_LINE> <START_VULN> if ( mprSetJsonObj ( app -> config , key , abilities ) < 0 ) { <NEW_LINE> <END_VULN> fail ( "Cannot update % s" , key ) ; <NEW_LINE> return ; <NEW_LINE> }
#include < algorithm > <NEW_LINE> #include "base / logging . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> namespace remoting {
offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ) ; <NEW_LINE> <START_VULN> length = tvb_length_remaining ( tvb , offset ) ; <NEW_LINE> <END_VULN> nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + sizeof ( struct udp_hdr ) + length ) ; <NEW_LINE> nhdr_list -> next = NULL ; <NEW_LINE> nhdr_list -> proto = IP_PROTO_UDP ;
#if DEPRECATED || 1 <NEW_LINE> static void parseContentKeep ( HttpRoute * route , cchar * key , MprJson * prop ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( mprGetJson ( prop , " [ @ = c ] " ) ) { <NEW_LINE> <END_VULN> route -> keepSource = 1 ; <NEW_LINE> } <NEW_LINE> }
restart: <NEW_LINE> for ( s = local_socket_list . next ; s != & local_socket_list ; s = s -> next ) { <NEW_LINE> if ( s -> transport == t || ( s -> peer && s -> peer -> transport == t ) ) { <NEW_LINE> <START_VULN> local_socket_close ( s ) ; <NEW_LINE> <END_VULN> goto restart ; <NEW_LINE> } <NEW_LINE> }
if ( ! targetObjectIsNew ) <NEW_LINE> return NS_OK ; <NEW_LINE> JSObject * targetScriptObject ; <NEW_LINE> holder -> GetJSObject ( & targetScriptObject ) ; <NEW_LINE> <START_VULN> JSContext * cx = context -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , targetClassObject ) ; <NEW_LINE> AutoVersionChecker avc ( cx ) ; <NEW_LINE> for ( nsXBLProtoImplMember * curr = mMembers ; <NEW_LINE> curr ; <NEW_LINE> curr = curr -> GetNext ( ) )
} else if ( ( s -> bits_per_pixel == 1 || s -> bits_per_pixel == 2 || s -> bits_per_pixel == 4 || s -> bits_per_pixel == 8 ) && <NEW_LINE> s -> color_type == PNG_COLOR_TYPE_PALETTE ) { <NEW_LINE> avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; <NEW_LINE> <START_VULN> } else if ( s -> bit_depth == 1 ) { <NEW_LINE> <END_VULN> avctx -> pix_fmt = AV_PIX_FMT_MONOBLACK ; <NEW_LINE> } else if ( s -> bit_depth == 8 && <NEW_LINE> s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA ) {
bool IndexPointsToConfigureImeMenuItem ( int index ) const ; <NEW_LINE> <START_VULN> scoped_ptr < InputMethodDescriptors > input_method_descriptors_ ; <NEW_LINE> <END_VULN> StringPrefMember previous_input_method_pref_ ;
return ; <NEW_LINE> HeapObjectHeader * header = HeapObjectHeader::fromPayload ( address ) ; <NEW_LINE> <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <NEW_LINE> <END_VULN> NormalPageArena * arena = static_cast < NormalPage * > ( page ) -> arenaForNormalPage ( ) ; <NEW_LINE> state -> promptlyFreed ( header -> gcInfoIndex ( ) ) ; <NEW_LINE> arena -> promptlyFreeObject ( header ) ;
if ( pc -> refresh_entropy_probs == 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memcpy ( & cpi -> common . lfc , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> vp8_update_coef_probs ( cpi ) ;
} <NEW_LINE> off64_t size ; <NEW_LINE> <START_VULN> if ( mDurationUs >= 0 && mDataSource -> getSize ( & size ) == OK ) { <NEW_LINE> <END_VULN> * bitrate = size * 8000000ll / mDurationUs ; <NEW_LINE> return true ; <NEW_LINE> }
# define PNG_IMAGE_WARNING 1 <NEW_LINE> # define PNG_IMAGE_ERROR 2 <NEW_LINE> #define PNG_FORMAT_FLAG_ALPHA 0x01U <NEW_LINE> #define PNG_FORMAT_FLAG_COLOR 0x02U <NEW_LINE> <START_VULN> #define PNG_FORMAT_FLAG_LINEAR 0x04U <NEW_LINE> <END_VULN> #define PNG_FORMAT_FLAG_COLORMAP 0x08U <NEW_LINE> #ifdef PNG_FORMAT_BGR_SUPPORTED
} <NEW_LINE> void Control ( int ctrl_id , int arg ) { <NEW_LINE> <START_VULN> InitOnce ( ) ; <NEW_LINE>const vpx_codec_err_t res = vpx_codec_control_ ( & decoder_ , ctrl_id , arg ) ; <NEW_LINE>ASSERT_EQ ( VPX_CODEC_OK , res ) << DecodeError ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void Control ( int ctrl_id , const void * arg ) {
return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> uint64 Segment::AddAudioTrack ( int32 sample_rate , <NEW_LINE>int32 channels , <NEW_LINE>int32 number ) { <NEW_LINE> <END_VULN> AudioTrack * const track = new ( std::nothrow ) AudioTrack ( & seed_ ) ; <NEW_LINE> if ( ! track ) <NEW_LINE> return 0 ;
{ <NEW_LINE> int intent ; <NEW_LINE> <START_VULN> if ( png_get_sRGB ( read_ptr , read_info_ptr , & intent ) ) <NEW_LINE> <END_VULN> png_set_sRGB ( write_ptr , write_info_ptr , intent ) ; <NEW_LINE> } <NEW_LINE> #endif
if ( ret != XpmSuccess ) { <NEW_LINE> return 0 ; <NEW_LINE> } <NEW_LINE> if ( ! ( im = gdImageCreate ( image . width , image . height ) ) ) { <NEW_LINE> goto done ; <NEW_LINE> } <NEW_LINE> <START_VULN> number = image . ncolors ; <NEW_LINE> <END_VULN> colors = ( int * ) safe_emalloc ( number , sizeof ( int ) , 0 ) ; <NEW_LINE> for ( i = 0 ; i < number ; i ++ ) { <NEW_LINE> switch ( strlen ( image . colorTable [ i ] . c_color ) ) {
tmpStr . Truncate ( ) ; <NEW_LINE> text -> AppendTo ( tmpStr ) ; <NEW_LINE> t -> AppendTextForNormalize ( tmpStr . get ( ) , tmpStr . Length ( ) , PR_TRUE , node ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> nsINode * parent = node -> GetNodeParent ( ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( parent || hasRemoveListeners , <NEW_LINE> "Should always have a parent unless " <NEW_LINE> "mutation events messed us up" ) ; <NEW_LINE> if ( parent ) { <NEW_LINE> parent -> RemoveChildAt ( parent -> IndexOf ( node ) , PR_TRUE ) ; <NEW_LINE> } <NEW_LINE> }
PHP_FUNCTION ( mcrypt_module_get_algo_key_size ) <NEW_LINE> { <NEW_LINE> MCRYPT_GET_MODE_DIR_ARGS ( algorithms_dir ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> RETURN_LONG ( mcrypt_module_get_algo_key_size ( module , dir ) ) ; <NEW_LINE> }
mPresContext -> FlushUserFontSet ( ) ; <NEW_LINE> if ( mDocument -> HasAnimationController ( ) ) { <NEW_LINE> mDocument -> GetAnimationController ( ) -> FlushResampleRequests ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsAutoScriptBlocker scriptBlocker ; <NEW_LINE>mFrameConstructor -> CreateNeededFrames ( ) ; <NEW_LINE>mFrameConstructor -> ProcessPendingRestyles ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! mIsDestroying ) { <NEW_LINE> mPresContext -> AnimationManager ( ) -> DispatchEvents ( ) ; <NEW_LINE> }
NS_ENSURE_SUCCESS ( rv , NS_ERROR_UNEXPECTED ) ; <NEW_LINE> JSAutoRequest ar ( aCx ) ; <NEW_LINE> JSAutoCompartment ac ( aCx , JS_GetGlobalObject ( aCx ) ) ; <NEW_LINE> JS_WrapValue ( aCx , & jsData ) ; <NEW_LINE> nsCxPusher cxPusher ; <NEW_LINE> <START_VULN> cxPusher . Push ( aCx ) ; <NEW_LINE> <END_VULN> uint64_t * jsBytes = nullptr ; <NEW_LINE> bool success = JS_WriteStructuredClone ( aCx , jsData , & jsBytes , & mSize , <NEW_LINE> nullptr , nullptr , JSVAL_VOID ) ; <NEW_LINE> NS_ENSURE_STATE ( success ) ; <NEW_LINE> NS_ENSURE_STATE ( jsBytes ) ;
const unsigned char * clear = data ; <NEW_LINE> if ( pbi -> decrypt_cb ) <NEW_LINE> { <NEW_LINE> <START_VULN> int n = ( int ) ( data_end - data ) ; <NEW_LINE>if ( n > 10 ) n = 10 ; <NEW_LINE> <END_VULN> pbi -> decrypt_cb ( pbi -> decrypt_state , data , clear_buffer , n ) ; <NEW_LINE> clear = clear_buffer ; <NEW_LINE> }
virtual void SendJavaScriptStream ( const GURL & url , <NEW_LINE> const std::string & result , <NEW_LINE> <START_VULN> bool success , bool notify_needed , <NEW_LINE>intptr_t notify_data ) ; <NEW_LINE> <END_VULN> virtual void DidReceiveManualResponse ( const GURL & url , <NEW_LINE> const std::string & mime_type ,
LoadFromTypedArray ( masm , tarray , addr , typeReg , objReg ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> Jump done1 = masm . jump ( ) ; <NEW_LINE><NEW_LINE>outOfBounds . linkTo ( masm . label ( ) , & masm ) ; <NEW_LINE>masm . loadValueAsComponents ( UndefinedValue ( ) , typeReg , objReg ) ; <NEW_LINE><NEW_LINE>Jump done2 = masm . jump ( ) ; <NEW_LINE> <END_VULN> PICLinker buffer ( masm , * this ) ; <NEW_LINE> if ( ! buffer . init ( cx ) )
int error_resilient_mode ; <NEW_LINE> int frame_parallel_decoding_mode ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>unsigned int coding_use_prev_mi ; <NEW_LINE><NEW_LINE> <END_VULN> int log2_tile_cols , log2_tile_rows ; <NEW_LINE> void * cb_priv ;
return ; <NEW_LINE> for ( InlineBox * curr = firstChild ( ) ; curr ; curr = curr -> nextOnLine ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> renderer ( ) -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> InlineFlowBox * inlineFlowBox = curr -> isInlineFlowBox ( ) ? toInlineFlowBox ( curr ) : 0 ;
nsObjectLoadingContent::ParameterUpdateFlags retval = eParamNoChange ; <NEW_LINE> <START_VULN> if ( thisContent -> NodeInfo ( ) -> Equals ( nsGkAtoms::applet ) ) { <NEW_LINE> <END_VULN> newMime . AssignLiteral ( "application / x - java - vm" ) ; <NEW_LINE> isJava = true ; <NEW_LINE> } else { <NEW_LINE> nsAutoString typeAttr ; <NEW_LINE> thisContent -> GetAttr ( kNameSpaceID_None , nsGkAtoms::type , typeAttr ) ; <NEW_LINE> if ( ! typeAttr . IsEmpty ( ) ) { <NEW_LINE> CopyUTF16toUTF8 ( typeAttr , newMime ) ; <NEW_LINE> isJava = nsPluginHost::IsJavaMIMEType ( newMime . get ( ) ) ;
<START_VULN> PHPAPI void php_stat ( const char * filename , php_stat_len filename_length , int type , zval * return_value ) <NEW_LINE> <END_VULN> { <NEW_LINE> zval stat_dev , stat_ino , stat_mode , stat_nlink , stat_uid , stat_gid , stat_rdev , <NEW_LINE> stat_size , stat_atime , stat_mtime , stat_ctime , stat_blksize , stat_blocks ;
<START_VULN> return ( colour_type & PNG_COLOR_MASK_ALPHA ) == 0 ; <NEW_LINE> <END_VULN> } <NEW_LINE> IT ( tRNS_to_alpha ) ;
void GetReceiversAndActivities ( <NEW_LINE> const ReceiversAndActivitesCallback & callback ) override ; <NEW_LINE> void CastToReceiver ( const std::string & receiver_id ) override ; <NEW_LINE> <START_VULN> void StopCasting ( const std::string & activity_id ) override ; <NEW_LINE> <END_VULN> void LaunchCastOptions ( ) override ; <NEW_LINE> DISALLOW_COPY_AND_ASSIGN ( CastConfigDelegateChromeos ) ;
<START_VULN> static int get_minq_index ( double maxq , double x3 , double x2 , double x1 ) { <NEW_LINE> <END_VULN> int i ; <NEW_LINE> const double minqtarget = MIN ( ( ( x3 * maxq + x2 ) * maxq + x1 ) * maxq , <NEW_LINE> maxq ) ;
} else if ( child -> type & MPR_JSON_OBJ ) { <NEW_LINE> newRoute = 0 ; <NEW_LINE> <START_VULN> pattern = mprLookupJson ( child , "pattern" ) ; <NEW_LINE> <END_VULN> if ( pattern ) { <NEW_LINE> newRoute = httpLookupRouteByPattern ( route -> host , pattern ) ; <NEW_LINE> if ( ! newRoute ) {
virtual void DeleteMatch ( const AutocompleteMatch & match ) OVERRIDE ; <NEW_LINE> protected: <NEW_LINE> <START_VULN> HistoryProvider ( ACProviderListener * listener , <NEW_LINE> <END_VULN> Profile * profile , <NEW_LINE> const char * name ) ; <NEW_LINE> virtual ~ HistoryProvider ( ) ;
nsTextFrame * nextContinuation = <NEW_LINE> static_cast < nsTextFrame * > ( aPrevInFlow -> GetNextContinuation ( ) ) ; <NEW_LINE> #endif <NEW_LINE> SetPrevInFlow ( aPrevInFlow ) ; <NEW_LINE> aPrevInFlow -> SetNextInFlow ( this ) ; <NEW_LINE> nsTextFrame * prev = static_cast < nsTextFrame * > ( aPrevInFlow ) ; <NEW_LINE> mContentOffset = prev -> GetContentOffset ( ) + prev -> GetContentLengthHint ( ) ; <NEW_LINE> <START_VULN> NS_ASSERTION ( mContentOffset < aContent -> GetText ( ) -> GetLength ( ) , <NEW_LINE> <END_VULN> "Creating ContinuingTextFrame , but there is no more content" ) ; <NEW_LINE> if ( prev -> GetStyleContext ( ) != GetStyleContext ( ) ) { <NEW_LINE> prev -> ClearTextRun ( ) ; <NEW_LINE> } else { <NEW_LINE> mTextRun = prev -> GetTextRun ( ) ; <NEW_LINE> }
if ( overflow || scaledSize . width <= 0 || scaledSize . height <= 0 ) <NEW_LINE> return result ; <NEW_LINE> gfxRect r ( aDataRect . x , aDataRect . y , aDataRect . width , aDataRect . height ) ; <NEW_LINE> <START_VULN> r . Scale ( gfxFloat ( scaledSize . width ) / aTarget -> mImage -> Width ( ) , <NEW_LINE>gfxFloat ( scaledSize . height ) / aTarget -> mImage -> Height ( ) ) ; <NEW_LINE> <END_VULN> r . RoundOut ( ) ; <NEW_LINE> if ( ! gfxUtils::GfxRectToIntRect ( r , & result . mDataRect ) ) <NEW_LINE> return result ; <NEW_LINE> result . mSource = new gfxImageSurface ( scaledSize , <NEW_LINE> gfxASurface::ImageFormatARGB32 ) ; <NEW_LINE> result . mTarget = new gfxImageSurface ( scaledSize , <NEW_LINE> gfxASurface::ImageFormatARGB32 ) ;
void <NEW_LINE> nsGenericHTMLElement::RemoveFocus ( nsPresContext * aPresContext ) <NEW_LINE> { <NEW_LINE> if ( ! aPresContext ) <NEW_LINE> return ; <NEW_LINE> if ( IsContentOfType ( eHTML_FORM_CONTROL ) ) { <NEW_LINE> <START_VULN> nsIFormControlFrame * formControlFrame = GetFormControlFrame ( PR_FALSE ) ; <NEW_LINE> <END_VULN> if ( formControlFrame ) { <NEW_LINE> formControlFrame -> SetFocus ( PR_FALSE , PR_FALSE ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( IsInDoc ( ) ) { <NEW_LINE> aPresContext -> EventStateManager ( ) -> SetContentState ( nsnull , <NEW_LINE> NS_EVENT_STATE_FOCUS ) ;
#endif <NEW_LINE> #ifndef M_PI <NEW_LINE> # define M_PI ( 3 . 1415926536f ) <NEW_LINE> #endif <NEW_LINE> #if defined ( _WIN32 ) && ! defined ( __SYMBIAN32__ ) <NEW_LINE> # include < malloc . h > <NEW_LINE> <START_VULN> # define rint ( x ) ( floor ( ( x ) + 0 . 5f ) ) <NEW_LINE> <END_VULN> # define NO_FLOAT_MATH_LIB <NEW_LINE> # define FAST_HYPOT ( a , b ) sqrt ( ( a ) * ( a ) + ( b ) * ( b ) ) <NEW_LINE> #endif <NEW_LINE> #if defined ( __SYMBIAN32__ ) && defined ( __WINS__ ) <NEW_LINE> void * _alloca ( size_t size ) ; <NEW_LINE> # define alloca _alloca <NEW_LINE> #endif
zval ** * params = ( zval ** * ) safe_emalloc ( num_args , sizeof ( zval ** ) , 0 ) ; <NEW_LINE> params [ 0 ] = & zresource_ptr ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( arg2 ) { <NEW_LINE> params [ 1 ] = & arg2 ; <NEW_LINE> }
if ( ( ignore_depth == 0 ) && ( IsSkipTag ( tag ) == MagickFalse ) ) <NEW_LINE> ParseOpenTag ( root , tag , attributes ) ; <NEW_LINE> else <NEW_LINE> <START_VULN> ignore_depth ++ ; <NEW_LINE> <END_VULN> * p = c ; <NEW_LINE> } <NEW_LINE> else
fd_printf ( STO , " ** * cannot read filename ** * \r\n" ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> <START_VULN> run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; <NEW_LINE> <END_VULN> free ( fname ) ; <NEW_LINE> break ; <NEW_LINE> case KEY_BREAK:
} <NEW_LINE> <START_VULN> if ( length == png_sRGB_checks [ i ] . length && <NEW_LINE>intent == png_sRGB_checks [ i ] . intent ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( adler == 0 )
#include < stdint . h > <NEW_LINE> #include < utility > <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "mojo / public / cpp / system / message_pipe . h" <NEW_LINE> namespace mojo {
<START_VULN> if ( poll ( & pfd , 1 , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) == 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> BTIF_TRACE_EVENT ( "poll timeout ( % d ms ) " , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) ; <NEW_LINE> break ;
} ; <NEW_LINE> using ResourceRefs = base::flat_map < ASurfaceControl * , ResourceRef > ; <NEW_LINE> <START_VULN> void CommitPendingTransaction ( SwapCompletionCallback completion_callback , <NEW_LINE> <END_VULN> PresentationCallback callback ) ;
#define MagickPackageName "ImageMagick" <NEW_LINE> #define MagickCopyright "Copyright ( C ) 1999 - 2015 ImageMagick Studio LLC" <NEW_LINE> <START_VULN> #define MagickSVNRevision "18658:18662M" <NEW_LINE> <END_VULN> #define MagickLibVersion 0x700 <NEW_LINE> #define MagickLibVersionText "7 . 0 . 0" <NEW_LINE> #define MagickLibVersionNumber 0 , 0 , 0
tnl_hlen = skb_tnl_header_len ( skb ) ; <NEW_LINE> <START_VULN> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <NEW_LINE> <END_VULN> if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) <NEW_LINE> goto out ; <NEW_LINE> }
if ( ls -> mListenerType == eNativeListener ) { <NEW_LINE> aPusher -> Pop ( ) ; <NEW_LINE> } else if ( ! aPusher -> RePush ( aCurrentTarget ) ) { <NEW_LINE> continue ; <NEW_LINE> } <NEW_LINE> <START_VULN> EventListenerHolder kungFuDeathGrip ( ls -> mListener ) ; <NEW_LINE>if ( NS_FAILED ( HandleEventSubType ( ls , ls -> mListener , * aDOMEvent , <NEW_LINE>aCurrentTarget , aPusher ) ) ) { <NEW_LINE> <END_VULN> aEvent -> mFlags . mExceptionHasBeenRisen = true ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> aEvent -> currentTarget = nullptr ;
} <NEW_LINE> if ( WrapperMap::Ptr p = crossCompartmentWrappers . lookup ( * vp ) ) { <NEW_LINE> * vp = p -> value ; <NEW_LINE> if ( vp -> isObject ( ) ) { <NEW_LINE> JSObject * obj = & vp -> toObject ( ) ; <NEW_LINE> JS_ASSERT ( IsCrossCompartmentWrapper ( obj ) ) ; <NEW_LINE> <START_VULN> if ( obj -> getParent ( ) != global ) { <NEW_LINE> <END_VULN> do { <NEW_LINE> obj -> setParent ( global ) ; <NEW_LINE> obj = obj -> getProto ( ) ; <NEW_LINE> } while ( obj && IsCrossCompartmentWrapper ( obj ) ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return true ; <NEW_LINE> }
++ str ; <NEW_LINE> valueStart = str ; <NEW_LINE> for ( valueEnd = str ; * valueEnd ; ++ valueEnd ) { <NEW_LINE> <START_VULN> if ( * valueEnd == '\\' ) <NEW_LINE> <END_VULN> ++ valueEnd ; <NEW_LINE> else if ( * valueEnd == '"' ) <NEW_LINE> break ;
{ <NEW_LINE> ALOGV ( "setDataSource ( % d , % " PRId64 " , % " PRId64 " ) " , fd , offset , length ) ; <NEW_LINE> status_t err = UNKNOWN_ERROR ; <NEW_LINE> <START_VULN> const sp < IMediaPlayerService > & service ( getMediaPlayerService ( ) ) ; <NEW_LINE> <END_VULN> if ( service != 0 ) { <NEW_LINE> sp < IMediaPlayer > player ( service -> create ( this , mAudioSessionId ) ) ; <NEW_LINE> if ( ( NO_ERROR != doSetRetransmitEndpoint ( player ) ) ||
int jas_seq2d_output ( jas_matrix_t * matrix , FILE * out ) <NEW_LINE> { <NEW_LINE> #define MAXLINELEN 80 <NEW_LINE> <START_VULN> int i ; <NEW_LINE>int j ; <NEW_LINE> <END_VULN> jas_seqent_t x ; <NEW_LINE> char buf [ MAXLINELEN + 1 ] ; <NEW_LINE> char sbuf [ MAXLINELEN + 1 ] ;
while ( filt_val >= min_filter_level ) <NEW_LINE> { <NEW_LINE> <START_VULN> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <NEW_LINE> <END_VULN> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ;
class RawData ; <NEW_LINE> class SecurityOrigin ; <NEW_LINE> <START_VULN> class ThreadableBlobRegistry { <NEW_LINE> <END_VULN> public: <NEW_LINE> static void registerBlobURL ( const KURL & , PassOwnPtr < BlobData > ) ; <NEW_LINE> static void registerStreamURL ( const KURL & , const String & ) ;
class NET_EXPORT URLRequestContext <NEW_LINE> <START_VULN> : NON_EXPORTED_BASE ( public base::NonThreadSafe ) , <NEW_LINE>public base::SupportsWeakPtr < URLRequestContext > { <NEW_LINE> <END_VULN> public: <NEW_LINE> URLRequestContext ( ) ; <NEW_LINE> virtual ~ URLRequestContext ( ) ;
gfx::Rect visible_rect ; <NEW_LINE> protected: <NEW_LINE> <START_VULN> friend class base::RefCounted < H264Picture > ; <NEW_LINE> <END_VULN> virtual ~ H264Picture ( ) ; <NEW_LINE> private:
} <NEW_LINE> } <NEW_LINE> <START_VULN> static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , <NEW_LINE> <END_VULN> UINT32 scanline ) <NEW_LINE> { <NEW_LINE> nsc_encode_argb_to_aycocg_sse2 ( context , data , scanline ) ;
class CONTENT_EXPORT ResourceDispatcherHostImpl <NEW_LINE> : public ResourceDispatcherHost , <NEW_LINE> public net::URLRequest::Delegate , <NEW_LINE> <START_VULN> public SSLErrorHandler::Delegate { <NEW_LINE> <END_VULN> public: <NEW_LINE> ResourceDispatcherHostImpl ( ) ; <NEW_LINE> virtual ~ ResourceDispatcherHostImpl ( ) ;
NS_RUNTIMEABORT ( "unused" ) ; <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> TabChild::DeallocPOfflineCacheUpdateChild ( POfflineCacheUpdateChild * actor ) <NEW_LINE> { <NEW_LINE> OfflineCacheUpdateChild * offlineCacheUpdate = static_cast < OfflineCacheUpdateChild * > ( actor ) ; <NEW_LINE> <START_VULN> delete offlineCacheUpdate ; <NEW_LINE> <END_VULN> return true ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> TabChild::RecvLoadRemoteScript ( const nsString & aURL , const bool & aRunInGlobalScope ) <NEW_LINE> { <NEW_LINE> if ( ! mGlobal && ! InitTabChildGlobal ( ) )
if ( amt_read == 0 && ! fail_on_eof ) <NEW_LINE> return ( 0 ) ; <NEW_LINE> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , <NEW_LINE> <START_VULN> "truncated dump file ; tried to read % " PRIsize " bytes , only got % " PRIsize , <NEW_LINE> <END_VULN> bytes_to_read , amt_read ) ; <NEW_LINE> } <NEW_LINE> return ( - 1 ) ;
case 7: <NEW_LINE> if ( memcmp ( argv [ i ] , "default" , 7 ) == 0 ) <NEW_LINE> { <NEW_LINE> <START_VULN> png_set_keep_unknown_chunks ( d -> png_ptr , option , NULL , 0 ) ; <NEW_LINE> <END_VULN> d -> keep = option ; <NEW_LINE> continue ; <NEW_LINE> }
#define IPC_MESSAGE_FORWARD_DELAY_REPLY ( msg_class , obj , member_func ) \ <NEW_LINE> case msg_class::ID: { \ <NEW_LINE> <START_VULN> TRACK_RUN_IN_IPC_HANDLER ( member_func ) ; \ <NEW_LINE> <END_VULN> if ( ! msg_class::DispatchDelayReply ( & ipc_message__ , obj , param__ , \ <NEW_LINE> & member_func ) ) \ <NEW_LINE> ipc_message__ . set_dispatch_error ( ) ; \
} <NEW_LINE> grayhi = rhi * data . red_coefficient + ghi * data . green_coefficient + <NEW_LINE> <START_VULN> bhi * data . blue_coefficient + 1 . / 32768 + out_qe ; <NEW_LINE> <END_VULN> grayhi *= ( 1 + 6 * DBL_EPSILON ) ; <NEW_LINE> if ( grayhi >= 1 ) <NEW_LINE> grayhi = 1 ;
for ( i = 1 ; i <= length ; i ++ ) { <NEW_LINE> if ( ! IndexToId ( cx , i , & id ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> <START_VULN> if ( ! IndexToId ( cx , i - 1 , & id2 ) ) <NEW_LINE>return JS_FALSE ; <NEW_LINE> <END_VULN> if ( ! OBJ_GET_PROPERTY ( cx , obj , id , & argv [ 0 ] ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> if ( ! OBJ_SET_PROPERTY ( cx , obj , id2 , & argv [ 0 ] ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> }
else <NEW_LINE> running_avg_y [ c ] = sig [ c ] - adjustment ; <NEW_LINE> <START_VULN> sum_diff - = adjustment ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
byte_run = - byte_run ; <NEW_LINE> palette_idx1 = buf [ stream_ptr ++ ] ; <NEW_LINE> palette_idx2 = buf [ stream_ptr ++ ] ; <NEW_LINE> <START_VULN> CHECK_PIXEL_PTR ( byte_run ) ; <NEW_LINE> <END_VULN> for ( j = 0 ; j < byte_run ; j ++ , pixel_countdown - = 2 ) { <NEW_LINE> pixels [ pixel_ptr ++ ] = palette_idx1 ; <NEW_LINE> pixels [ pixel_ptr ++ ] = palette_idx2 ;
PRInt32 GetContentLengthHint ( ) const { return mContentLengthHint ; } <NEW_LINE> PRInt32 GetInFlowContentLength ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>void ClearTextRun ( ) ; <NEW_LINE> <END_VULN> gfxSkipCharsIterator EnsureTextRun ( gfxContext * aReferenceContext = nsnull , <NEW_LINE> nsIFrame * aLineContainer = nsnull , <NEW_LINE> const nsLineList::iterator * aLine = nsnull , <NEW_LINE> PRUint32 * aFlowEndInTextRun = nsnull ) ; <NEW_LINE> gfxTextRun * GetTextRun ( ) { return mTextRun ; } <NEW_LINE> void SetTextRun ( gfxTextRun * aTextRun ) { mTextRun = aTextRun ; } <NEW_LINE> struct TrimmedOffsets { <NEW_LINE> PRInt32 mStart ; <NEW_LINE> PRInt32 mLength ; <NEW_LINE> PRInt32 GetEnd ( ) { return mStart + mLength ; }
exif_iif_add_tag ( ImageInfo , SECTION_APP12 , "Company" , <NEW_LINE> TAG_NONE , TAG_FMT_STRING , l1 , buffer + 2 ) ; <NEW_LINE> if ( length > 2 + l1 + 1 ) { <NEW_LINE> <START_VULN> l2 = php_strnlen ( buffer + 2 + l1 + 1 , length - 2 - l1 + 1 ) ; <NEW_LINE> <END_VULN> exif_iif_add_tag ( ImageInfo , SECTION_APP12 , "Info" , <NEW_LINE> TAG_NONE , TAG_FMT_STRING , l2 , buffer + 2 + l1 + 1 ) ; <NEW_LINE> }
MOZ_ASSERT ( tableScript ) ; <NEW_LINE> } <NEW_LINE> aTableScript . set ( tableScript ) ; <NEW_LINE> <START_VULN> mThisObjects . Put ( tableScript , obj ) ; <NEW_LINE> <END_VULN> bool ok = false ; <NEW_LINE> { <NEW_LINE> AutoSaveContextOptions asco ( cx ) ; <NEW_LINE> if ( aPropagateExceptions ) <NEW_LINE> ContextOptionsRef ( cx ) . setDontReportUncaught ( true ) ; <NEW_LINE> if ( script ) { <NEW_LINE> ok = JS_ExecuteScriptVersion ( cx , obj , script , nullptr , JSVERSION_LATEST ) ;
SPL_METHOD ( DirectoryIterator , rewind ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
private: <NEW_LINE> void layout ( ) override ; <NEW_LINE> void calcViewport ( ) override ; <NEW_LINE> <START_VULN> bool calculateLocalTransform ( ) override ; <NEW_LINE> <END_VULN> AffineTransform viewportTransform ( ) const ;
<START_VULN> typedef png_libpng_version_1_6_10 Your_png_h_is_not_version_1_6_10 ; <NEW_LINE> <END_VULN> #if defined ( PNG_READ_SUPPORTED ) || defined ( PNG_WRITE_SUPPORTED )
#endif <NEW_LINE> if ( ssap == LLCSAP_ISONS && dsap == LLCSAP_ISONS <NEW_LINE> && control == LLC_UI ) { <NEW_LINE> <START_VULN> isoclns_print ( ndo , p , length , caplen ) ; <NEW_LINE> <END_VULN> return ( hdrlen ) ; <NEW_LINE> }
} <NEW_LINE> if ( ! cx ) { <NEW_LINE> cx = nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>mRootedCallable . construct ( cx , aCallback ) ; <NEW_LINE><NEW_LINE> <END_VULN> mCxPusher . Push ( cx ) ; <NEW_LINE> mCtx = ctx ;
static bool shouldCheckLines ( RenderObject * obj ) <NEW_LINE> { <NEW_LINE> <START_VULN> return ! obj -> isFloatingOrPositioned ( ) && ! obj -> isRunIn ( ) && <NEW_LINE>obj -> isBlockFlow ( ) && obj -> style ( ) -> height ( ) . isAuto ( ) && <NEW_LINE> ( ! obj -> isDeprecatedFlexibleBox ( ) || obj -> style ( ) -> boxOrient ( ) == VERTICAL ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static RootInlineBox * getLineAtIndex ( RenderBlock * block , int i , int & count )
return HB_WORK_DONE ; <NEW_LINE> } <NEW_LINE> <START_VULN> pv -> context = avcodec_alloc_context3 ( codec ) ; <NEW_LINE> <END_VULN> pv -> context -> workaround_bugs = FF_BUG_AUTODETECT ; <NEW_LINE> pv -> context -> err_recognition = AV_EF_CRCCHECK ; <NEW_LINE> pv -> context -> error_concealment = FF_EC_GUESS_MVS | FF_EC_DEBLOCK ;
<START_VULN> static int __perf_event_overflow ( struct perf_event * event , int nmi , <NEW_LINE> <END_VULN> int throttle , struct perf_sample_data * data , <NEW_LINE> struct pt_regs * regs ) <NEW_LINE> {
frame_ -> GetPage ( ) -> GetChromeClient ( ) . InstallSupplements ( * frame_ ) ; <NEW_LINE> if ( ! overriding_url . IsEmpty ( ) ) <NEW_LINE> document -> SetBaseURLOverride ( overriding_url ) ; <NEW_LINE> <START_VULN> DidInstallNewDocument ( document ) ; <NEW_LINE> <END_VULN>
return ; <NEW_LINE> } <NEW_LINE> <START_VULN> StyleDifference diff = StyleDifferenceEqual ; <NEW_LINE> <END_VULN> unsigned contextSensitiveProperties = ContextSensitivePropertyNone ; <NEW_LINE> if ( m_style ) <NEW_LINE> diff = m_style -> visualInvalidationDiff ( * style , contextSensitiveProperties ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: modified discrete cosine transform prototypes <NEW_LINE> <START_VULN> last mod: $ Id: mdct . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _OGG_mdct_H_ <NEW_LINE> #define _OGG_mdct_H_ <NEW_LINE> #include "vorbis / codec . h"
char * _equal ; <NEW_LINE> if ( strncmp ( tok , "csrf" , strlen ( "csrf" ) ) <NEW_LINE> <START_VULN> && ( _equal = strchr ( tok , ' = ' ) ) ) { <NEW_LINE> <END_VULN> char * decoded_buf ; <NEW_LINE> int len ;
virtual void SiteInstanceDeleting ( SiteInstance * site_instance ) { } <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>virtual bool ShouldSwapProcessesForNavigation ( const GURL & current_url , <NEW_LINE> <END_VULN> const GURL & new_url ) ;
png_debug ( 1 , "in png_do_gray_to_rgb" ) ; <NEW_LINE> if ( row_info -> bit_depth >= 8 && <NEW_LINE> <START_VULN> ! ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( row_info -> color_type == PNG_COLOR_TYPE_GRAY ) <NEW_LINE> {
#endif <NEW_LINE> #ifdef PNG_EASY_ACCESS_SUPPORTED <NEW_LINE> <START_VULN> if ( verbose ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_uint_32 iwidth , iheight ; <NEW_LINE> iwidth = png_get_image_width ( write_ptr , write_info_ptr ) ;
. open = ftrace_notrace_open , <NEW_LINE> . read = seq_read , <NEW_LINE> . write = ftrace_notrace_write , <NEW_LINE> <START_VULN> . llseek = ftrace_regex_lseek , <NEW_LINE> <END_VULN> . release = ftrace_regex_release , <NEW_LINE> } ;
break ; <NEW_LINE> case LOCAL_GL_DEPTH_STENCIL_ATTACHMENT: <NEW_LINE> mDepthStencilAttachment . SetRenderbuffer ( wrb ) ; <NEW_LINE> break ; <NEW_LINE> default: <NEW_LINE> if ( attachment != LOCAL_GL_COLOR_ATTACHMENT0 ) <NEW_LINE> return mContext -> ErrorInvalidEnumInfo ( "framebufferRenderbuffer: attachment" , attachment ) ; <NEW_LINE> <START_VULN> if ( ! isNull ) { <NEW_LINE><NEW_LINE><NEW_LINE>setDimensions ( wrb ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> mColorAttachment . SetRenderbuffer ( wrb ) ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> mContext -> MakeContextCurrent ( ) ; <NEW_LINE> if ( attachment == LOCAL_GL_DEPTH_STENCIL_ATTACHMENT ) { <NEW_LINE> mContext -> gl -> fFramebufferRenderbuffer ( target , LOCAL_GL_DEPTH_ATTACHMENT , rbtarget , renderbuffername ) ; <NEW_LINE> mContext -> gl -> fFramebufferRenderbuffer ( target , LOCAL_GL_STENCIL_ATTACHMENT , rbtarget , renderbuffername ) ;
for ( ; rp > png_ptr -> row_buf ; rp -- ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( * rp >> padding != 0 ) <NEW_LINE> <END_VULN> png_ptr -> num_palette_max = 1 ; <NEW_LINE> padding = 0 ; <NEW_LINE> }
protected: <NEW_LINE> nsPresContext * mPresContext ; <NEW_LINE> nsCOMPtr < nsIPresShell > mPresShell ; <NEW_LINE> nsCOMPtr < nsISelection > mSelection ; <NEW_LINE> nsRefPtr < nsRange > mFirstSelectedRange ; <NEW_LINE> nsCOMPtr < nsIContent > mRootContent ; <NEW_LINE> nsresult Init ( WidgetQueryContentEvent * aEvent ) ; <NEW_LINE> nsresult Init ( WidgetSelectionEvent * aEvent ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> nsresult InitCommon ( ) ; <NEW_LINE> public: <NEW_LINE> static nsresult GetFlatTextOffsetOfRange ( nsIContent * aRootContent , <NEW_LINE> nsINode * aNode , <NEW_LINE> int32_t aNodeOffset ,
image -> depth = 8 ; <NEW_LINE> image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; <NEW_LINE> <START_VULN> if ( image_info -> ping ) goto Finish ; <NEW_LINE> <END_VULN> if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <NEW_LINE> <END_VULN> { <NEW_LINE> WLog_DBG ( TAG , " % s ( Len: % "PRIu16" MaxLen: % "PRIu16" BufferOffset: % "PRIu32" ) " , <NEW_LINE> name , fields -> Len , fields -> MaxLen , fields -> BufferOffset ) ;
vcpu -> arch . cr2 = sregs -> cr2 ; <NEW_LINE> mmu_reset_needed |= vcpu -> arch . cr3 != sregs -> cr3 ; <NEW_LINE> <START_VULN> vcpu -> arch . cr3 = sregs -> cr3 ; <NEW_LINE> <END_VULN> kvm_set_cr8 ( vcpu , sregs -> cr8 ) ;
