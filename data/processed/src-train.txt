vert_band_scale ( temp_area + dest_pitch , dest_pitch , dest , dest_pitch , dest_width ) ; if ( interpolation ) <START_VULN> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ; <END_VULN> source += ( unsigned long ) source_band_height * source_pitch ;
} and 40 , replicate the 100dB curve to 110 * for ( j = 0 ; j < 6 ; j ++ ) memcpy ( workc [ i ] [ j + 2 ] , tonemasks [ i ] [ j ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ j ] ) ) ; memcpy ( workc [ i ] [ 0 ] , tonemasks [ i ] [ 0 ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ 0 ] ) ) ; memcpy ( workc [ i ] [ 1 ] , tonemasks [ i ] [ 0 ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ 0 ] ) ) ; <START_VULN> <END_VULN> for ( j = 0 ; j < P_LEVELS ; j ++ ) { for ( k = 0 ; k < EHMER_MAX ; k ++ ) { float adj = center_boost + abs ( EHMER_OFFSET - k ) * center_decay_rate ; if ( adj < 0 . && center_boost>0 ) adj = 0 . ; if ( adj>0 . && center_boost < 0 ) adj = 0 . ; workc [ i ] [ j ] [ k ] += adj ; }
#include "basesynchronizationlock . h" #include "basethreadingthread_checker . h" #include "componentsschedulerchildtask_queue_selector . h" <START_VULN> #include "componentsschedulerchildtime_source . h"<END_VULN> #include "componentsschedulerscheduler_export . h" namespace base { namespace trace_event { class ConvertableToTraceFormat ; class TracedValue ; } } namespace scheduler {
} static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , <START_VULN> u64 nr , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) {
} if ( intern -> u . dir . sub_path ) { efree ( intern -> u . dir . sub_path ) ; <START_VULN> } <END_VULN> break ; case SPL_FS_FILE : if ( intern -> u . file . stream ) {
int c = ( int ) ( chunk_name >> ishift ) & 0xff ; ishift -= 8 ; <START_VULN> if ( isnonalpha ( c ) ) <END_VULN> { buffer [ iout ++ ] = PNG_LITERAL_LEFT_SQUARE_BRACKET ; buffer [ iout ++ ] = png_digit [ ( c & 0xf0 ) >> 4 ] ;
if ( lpc_order == 31 ) { for ( i = 1 ; i < nb_samples ; i ++ ) { buffer_out [ i ] = sign_extend ( buffer_out [ i - 1 ] + error_buffer [ i ] , bps ) ; } return ; } <START_VULN> for ( i = 1 ; i <= lpc_order ; i ++ ) <END_VULN> buffer_out [ i ] = sign_extend ( buffer_out [ i - 1 ] + error_buffer [ i ] , bps ) ; for ( ; i < nb_samples ; i ++ ) { int j ; int val = 0 ; int error_val = error_buffer [ i ] ; int error_sign ; int d = * pred ++ ;
for ( i = 0 , l = 0 ; i < partvals ; l ++ ) { if ( s == 0 ) { for ( j = 0 ; j < ch ; j ++ ) { int temp = vorbis_book_decode ( look -> phrasebook , & vb -> opb ) ; <START_VULN> if ( temp == - 1 ) goto eopbreak ; <END_VULN> partword [ j ] [ l ] = look -> decodemap [ temp ] ; if ( partword [ j ] [ l ] == NULL ) goto errout ; } } for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) for ( j = 0 ; j < ch ; j ++ ) {
png_write_complete_chunk ( png_ptr , png_IHDR , buf , ( png_size_t ) 13 ) ; <START_VULN> if ( ! ( png_ptr -> do_filter ) ) <END_VULN> { if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE | | png_ptr -> bit_depth < 8 )
{ unsigned int sse ; <START_VULN> vp8_mse16x16 ( orig + col , orig_stride , <END_VULN> recon + col , recon_stride , & sse ) ; total_sse += sse ;
vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , <START_VULN> vpx_codec_dec_cfg_t * cfg , <END_VULN> vpx_codec_flags_t flags , int ver ) ;
void ResolveWithNothing ( ScriptPromiseResolver * ) ; void ResolveWithPhotoSettings ( ScriptPromiseResolver * ) ; void ResolveWithPhotoCapabilities ( ScriptPromiseResolver * ) ; <START_VULN> void ResolveWithMediaTrackConstraints ( MediaTrackConstraints , <END_VULN> ScriptPromiseResolver * ) ; Member < MediaStreamTrack> stream_track_ ;
template < typename T , typename . . . Args> std : : unique_ptr < T> SpdyMakeUniqueImpl ( Args && . . . args ) { <START_VULN> return base : : MakeUnique < T> ( std : : forward < Args> ( args ) . . . ) ; <END_VULN> } template < typename T>
result = ejsCreatePot ( ejs , ESV ( Object ) , 0 ) ; for ( ep = environ ; ep && * ep ; ep ++ ) { pair = sclone ( * ep ) ; <START_VULN> key = stok ( pair , " = " , & value ) ; <END_VULN> ejsSetPropertyByName ( ejs , result , EN ( key ) , ejsCreateStringFromAsc ( ejs , value ) ) ; } return result ;
static void cheby ( float * g , int ord ) { int i , j ; g [ 0 ] *= . 5f ; for ( i = 2 ; i <= ord ; i ++ ) { for ( j = ord ; j > = i ; j -- ) { g [ j - 2 ] -= g [ j ] ; <START_VULN> g [ j ] += g [ j ] ; <END_VULN> } } } static int comp ( const void * a , const void * b ) { return ( * ( float * ) a < * ( float * ) b ) - ( * ( float * ) a> * ( float * ) b ) ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : normalized modified discrete cosine transform power of two length transform only [ 64 <= n ] <START_VULN> last mod : $ Id : mdct . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> Original algorithm adapted long ago from _The use of multirate filter banks for coding of high quality digital audio_ , by T . Sporer , K . Brandenburg and B . Edler , collection of the European Signal Processing Conference ( EUSIPCO ) , Amsterdam , June 1992 , Vol . 1 , pp 211 - 214 The below code implements an algorithm that no longer looks much like
return ZEND_HASH_APPLY_STOP ; } <START_VULN> fname_len = ( php_stat_len ) strlen ( fname ) ; <END_VULN> save = fname ; goto phar_spl_fileinfo ; }
vqc . id = control -> id ; rval = si4713_queryctrl ( & sdev -> sd , & vqc ) ; if ( rval < 0 ) goto exit ; switch ( control -> id ) { case V4L2_CID_RDS_TX_PS_NAME : { char ps_name [ MAX_RDS_PS_NAME + 1 ] ; len = control -> size - 1 ; <START_VULN> if ( len > MAX_RDS_PS_NAME ) { <END_VULN> rval = - ERANGE ; goto exit ; } rval = copy_from_user ( ps_name , control -> string , len ) ; if ( rval < 0 ) goto exit ; ps_name [ len ] = '0' ; if ( strlen ( ps_name ) % vqc . step ) { rval = - ERANGE ;
else if ( isspace ( UCHAR_MAX & * str ) ) putc ( '_' , out ) ; <START_VULN> <END_VULN> else fprintf ( out , " % . 3o" , * str ) ; }
char * vorbis_comment_query ( vorbis_comment * vc , const char * tag , int count ) { long i ; int found = 0 ; int taglen = strlen ( tag ) + 1 ; char * fulltag = alloca ( taglen + 1 ) ; strcpy ( fulltag , tag ) ; strcat ( fulltag , " = " ) ; <START_VULN> <END_VULN> for ( i = 0 ; i < vc -> comments ; i ++ ) { if ( ! tagcompare ( vc -> user_comments [ i ] , fulltag , taglen ) ) { if ( count == found ) return vc -> user_comments [ i ] + taglen ; else found ++ ; }
else if ( color_type == PNG_COLOR_TYPE_GRAY ) { <START_VULN> <END_VULN> if ( tran -> gray > = ( 1 << png_ptr -> bit_depth ) ) { png_app_warning ( png_ptr ,
virtual bool SetImeConfig ( const std : : string & section , const std : : string & config_name , <START_VULN> const ImeConfigValue & value ) = 0 ; <END_VULN>
} if ( ret & VM_FAULT_MAJOR ) { current -> maj_flt ++ ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <END_VULN> regs , address ) ; #ifdef CONFIG_PPC_SMLPAR if ( firmware_has_feature ( FW_FEATURE_CMO ) ) {
if ( _make_words ( lengthlist , s -> entries , <START_VULN> s -> dec_table , quantvals , s , opb , maptype ) ) return 1 ; <END_VULN> return 0 ; }
if ( exception -> severity != UndefinedException ) goto FINISH_UNL ; if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ; <START_VULN> ( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <END_VULN>
if ( ! init_done_ ) { const vpx_codec_err_t res = vpx_codec_dec_init ( & decoder_ , CodecInterface ( ) , <START_VULN> & cfg_ , 0 ) ; <END_VULN> ASSERT_EQ ( VPX_CODEC_OK , res ) << DecodeError ( ) ; init_done_ = true ; }
return ( H264SWDEC_PARAM_ERR ) ; } <START_VULN> pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) ) ; <END_VULN> if ( pDecCont == NULL ) {
if ( info -> register_invocation ) { info -> connection = connection ; <START_VULN> tcmur_register_handler ( handler ) ; <END_VULN> dbus_export_handler ( handler , G_CALLBACK ( on_dbus_check_config ) ) ; g_dbus_method_invocation_return_value ( info -> register_invocation , g_variant_new ( " ( bs ) " , TRUE , "succeeded" ) ) ;
float secs = ( float ) nvi -> rate ; amp += secs * gi -> ampmax_att_per_sec ; if ( amp < - 9999 ) amp = - 9999 ; return ( amp ) ; } static void couple_lossless ( float A , float B , <START_VULN> float * qA , float * qB ) { <END_VULN> int test1 = fabs ( * qA ) >fabs ( * qB ) ; test1 -= fabs ( * qA ) < fabs ( * qB ) ; if ( ! test1 ) test1 = ( ( fabs ( A ) >fabs ( B ) ) << 1 ) - 1 ; if ( test1 == 1 ) { * qB = ( * qA>0 . f ? * qA - * qB : * qB - * qA ) ; } else { float temp = * qB ;
int pnm_validate ( jas_stream_t * in ) { <START_VULN> uchar buf [ 2 ] ; <END_VULN> int i ; int n ;
long line_add = ( intern -> u . file . current_line | | intern -> u . file . current_zval ) ? 1 : 0 ; spl_filesystem_file_free_line ( intern TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( php_stream_eof ( intern -> u . file . stream ) ) { if ( ! silent ) { zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , "Cannot read from file % s" , intern -> file_name ) ;
struct inode ; <START_VULN> extern int parse_rock_ridge_inode ( struct iso_directory_record * , struct inode * ) ; <END_VULN> extern int get_rock_ridge_filename ( struct iso_directory_record * , char * , struct inode * ) ; extern int isofs_name_translate ( struct iso_directory_record * , char * , struct inode * ) ;
} } <START_VULN> singletonPos = getSingletonPos ( loc_name ) ; <END_VULN> if ( singletonPos == 0 ) {
bool CreateSharedBufferIfNeeded ( ) ; <START_VULN> mojo : : ScopedSharedBufferMapping MapSharedBufferForType ( <END_VULN> mojom : : SensorType type ) ; THREAD_CHECKER ( thread_checker_ ) ;
break ; case 2 : tv_info_v1_2 = ( ATOM_ANALOG_TV_INFO_V1_2 * ) ( mode_info -> atom_context -> bios + data_offset ) ; <START_VULN> if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 ) <END_VULN> return false ; dtd_timings = & tv_info_v1_2 -> aModeTimings [ index ] ;
websError ( wp , HTTP_CODE_BAD_REQUEST | WEBS_CLOSE | WEBS_NOLOG , "Bad URL" ) ; return ; } <START_VULN> if ( ( wp -> path = websNormalizeUriPath ( path ) ) == 0 ) { <END_VULN> error ( "Cannot normalize URL : % s" , url ) ; websError ( wp , HTTP_CODE_BAD_REQUEST | WEBS_CLOSE | WEBS_NOLOG , "Bad URL" ) ; wfree ( buf ) ;
VALUE cCipher ; VALUE eCipherError ; <START_VULN> static ID id_auth_tag_len ; <END_VULN> static VALUE ossl_cipher_alloc ( VALUE klass ) ; static void ossl_cipher_free ( void * ptr ) ;
for ( i = 0 ; i < 16 ; i ++ ) xd -> mode_info_context -> bmi [ i ] . mv . as_int = best_mode . bmodes [ i ] . mv . as_int ; <START_VULN> vpx_memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ; <END_VULN> x -> e_mbd . mode_info_context -> mbmi . mv . as_int = x -> partition_info -> bmi [ 15 ] . mv . as_int ;
{ if ( row_info -> bit_depth == 8 ) { <START_VULN> if ( at_start ) <END_VULN> ++ sp ; else sp += 2 , ++ dp ;
class nsPNGDecoder : public Decoder { public : nsPNGDecoder ( RasterImage & aImage ) ; virtual ~ nsPNGDecoder ( ) ; virtual void InitInternal ( ) ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual Telemetry : : ID SpeedHistogram ( ) ; void CreateFrame ( png_uint_32 x_offset , png_uint_32 y_offset , int32_t width , int32_t height , gfxImageFormat format ) ; void EndImageFrame ( ) ;
continue ; split_huge_page_pmd ( walk -> mm , pmd ) ; <START_VULN> if ( pmd_none_or_clear_bad ( pmd ) ) <END_VULN> goto again ; err = walk_pte_range ( pmd , addr , next , walk ) ; if ( err )
<START_VULN> if ( png_ptr -> flags & PNG_FLAG_ZSTREAM_INITIALIZED ) <END_VULN> ret = deflateReset ( & png_ptr -> zstream ) ; else
case FILE_LEDATE : case FILE_MEDATE : if ( file_printf ( ms , F ( ms , m , " % s" ) , <START_VULN> file_fmttime ( p -> l , FILE_T_LOCAL , tbuf ) ) == - 1 ) <END_VULN> return - 1 ; t = ms -> offset + sizeof ( uint32_t ) ; break ;
typedef void vorbis_info_residue ; typedef void vorbis_info_mapping ; #include "psy . h" #include "bitrate . h" typedef struct private_state { <START_VULN> envelope_lookup * ve ; <END_VULN> int window [ 2 ] ; vorbis_look_transform ** transform [ 2 ] ; drft_lookup fft_look [ 2 ] ; int modebits ; vorbis_look_floor ** flr ; vorbis_look_residue ** residue ; vorbis_look_psy * psy ;
} mflags = add_required_remount_flags ( source , destination , default_mounts [ i ] . flags ) ; <START_VULN> r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ; <END_VULN> saved_errno = errno ; if ( r < 0 && errno == ENOENT ) { INFO ( "Mount source or target for % s on % s doesn't exist . Skipping . " , source , destination ) ;
add_next_index_stringl ( match_pair , str , len , 1 ) ; add_next_index_long ( match_pair , offset ) ; <START_VULN> <END_VULN> if ( name ) { zval_add_ref ( & match_pair ) ; zend_hash_update ( Z_ARRVAL_P ( result ) , name , strlen ( name ) + 1 , & match_pair , sizeof ( zval * ) , NULL ) ;
return true ; if ( ( uint64_t ) capacity * elemSize > size_type ( - 1 ) 2 ) { <START_VULN> NS_ERROR ( "Attempting to allocate excessively large array" ) ; <END_VULN> return false ; } if ( mHdr == EmptyHdr ( ) ) { Header * header = static_cast < Header * > ( Alloc : : Malloc ( sizeof ( Header ) + capacity * elemSize ) ) ; if ( ! header )
} return pdu_len + 4 ; trunc : <START_VULN> ND_PRINT ( ( ndo , "tt packet exceeded snapshot" ) ) ; <END_VULN> return 0 ; }
#ifndef COMPONENTS_DOM_DISTILLER_CONTENT_BROWSER_DISTILLER_JAVASCRIPT_SERVICE_IMPL_H_ #define COMPONENTS_DOM_DISTILLER_CONTENT_BROWSER_DISTILLER_JAVASCRIPT_SERVICE_IMPL_H_ <START_VULN> #include "componentsdom_distillercontentbrowserexternal_feedback_reporter . h"<END_VULN> #include "componentsdom_distillercontentcommondistiller_javascript_service . mojom . h" #include "third_partymojosrcmojopubliccppbindingsstring . h" #include "third_partymojosrcmojopubliccppbindingsstrong_binding . h"
( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ( neighbors [ j ] . row ) * in_what_stride + neighbors [ j ] . col + best_address ; <START_VULN> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <END_VULN> if ( thissad < bestsad ) {
} } } else { <START_VULN> pCur -> iPtr = 0 ; <END_VULN> pCur -> iCnt = 0 ; } pCur -> iRowid = 1 ;
int cg_mkdir ( const char * path , mode_t mode ) { struct fuse_context * fc = fuse_get_context ( ) ; <START_VULN> char * fpath = NULL , * path1 , * cgdir = NULL , * controller ; <END_VULN> const char * cgroup ; int ret ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic shared codebook operations <START_VULN> last mod : $ Id : codebook . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_CODEBOOK_H_ #define _V_CODEBOOK_H_ #include < oggogg . h>
static int image_transform_png_set_rgb_to_gray_add ( image_transform * this , <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <END_VULN> { UNUSED ( bit_depth )
shift [ channels ++ ] = bit_depth - sig_bits -> gray ; } <START_VULN> if ( color_type & PNG_COLOR_MASK_ALPHA ) <END_VULN> { shift [ channels ++ ] = bit_depth - sig_bits -> alpha ; }
dst = dst_ybc -> v_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { <START_VULN> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <END_VULN> src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; }
int partwords = ( partvals + partitions_per_word - 1 ) partitions_per_word ; char * partword = <START_VULN> ( char * ) alloca ( partwords * partitions_per_word * sizeof ( * partword ) ) ; <END_VULN> int beginoff = info -> beginch ; for ( i = 0 ; i < ch ; i ++ ) if ( nonzero [ i ] ) break ;
const std : : vector < uint8_t> & data ) ; <START_VULN> const int instance_id_ ; <END_VULN> scoped_refptr < base : : SingleThreadTaskRunner> thread_runner_ ;
void OnDidGetPreviewPageCount ( const PrintHostMsg_DidGetPreviewPageCount_Params & params ) ; void OnDidPreviewPage ( const PrintHostMsg_DidPreviewPage_Params & params ) ; <START_VULN> void OnCheckForCancel ( const std : : string & preview_ui_addr , <END_VULN> int preview_request_id , bool * cancel ) ;
json_set_alloc_funcs ( my_malloc , my_free ) ; create_and_free_complex_object ( ) ; <START_VULN> if ( malloc_called != 20 | | free_called != 20 ) <END_VULN> fail ( "Custom allocation failed" ) ; }
<START_VULN> * <END_VULN>
#defineVTP_DOMAIN_NAME_LEN32 #defineVTP_MD5_DIGEST_LEN16 #define VTP_UPDATE_TIMESTAMP_LEN12 <START_VULN> #define VTP_VLAN_INFO_OFFSET12<END_VULN> #define VTP_SUMMARY_ADV0x01 #define VTP_SUBSET_ADV0x02
if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { <START_VULN> if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == <END_VULN> MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ;
if ( amt_read == 0 && ! fail_on_eof ) return ( 0 ) ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , <START_VULN> "truncated dump file ; tried to read % " PRIsize " bytes , only got % " PRIsize , <END_VULN> bytes_to_read , amt_read ) ; } return ( - 1 ) ;
vpx_codec_err_t res ; <START_VULN> res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , <END_VULN> & stream -> config . cfg , global -> usage ) ; if ( res )
bool hasSelfPaintingLayer ( ) const ; RenderLayer * layer ( ) const { return m_layer ; } <START_VULN> virtual bool requiresLayer ( ) const { return isRoot ( ) | | isPositioned ( ) | | isRelPositioned ( ) | | isTransparent ( ) | | hasTransform ( ) | | hasHiddenBackface ( ) | | hasMask ( ) | | hasReflection ( ) | | hasFilter ( ) | | style ( ) -> specifiesColumns ( ) ; } <END_VULN> virtual IntRect borderBoundingBox ( ) const = 0 ;
Impl * impl , KeyType * key , v8 : : PersistentContainerValue value ) { v8 : : PersistentContainerValue oldValue = Get ( impl , key ) ; <START_VULN> impl -> add ( key , value ) ; <END_VULN> return oldValue ; } static v8 : : PersistentContainerValue Get ( const Impl * impl , KeyType * key )
} DBGPRINTF ( "imzmq3 : connect for % s successful" , info -> description ) ; } else { <START_VULN> rv = zsocket_bind ( * sock , info -> description ) ; <END_VULN> if ( rv == - 1 ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS ,
#if DEPRECATED | | 1 static void parseContentKeep ( HttpRoute * route , cchar * key , MprJson * prop ) { <START_VULN> if ( mprGetJson ( prop , " [ @ = c ] " ) ) { <END_VULN> route -> keepSource = 1 ; } }
LOOKUP_CLEAN_RETURN ( NULL ) ; } cur_arr [ i * 2 ] = erealloc ( cur_arr [ i * 2 ] , strlen ( lang_tag ) + 1 ) ; <START_VULN> result = strToMatch ( lang_tag , cur_arr [ i * 2 ] ) ; <END_VULN> efree ( lang_tag ) ; if ( result == 0 ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "lookup_loc_range : unable to canonicalize lang_tag" , 0 TSRMLS_CC ) ;
#include "chromebrowserchromeoscroscros_library . h" #include "chromebrowserchromeoscrosnetwork_library . h" #include "chrometestin_process_browser_test . h" <START_VULN> #include "third_partycroschromeos_input_method . h"<END_VULN> namespace chromeos {
bc + candidates [ t ] [ i ] . col } ; thissad = vfp -> sdf ( what -> buf , what -> stride , get_buf_from_mv ( in_what , & this_mv ) , <START_VULN> in_what -> stride , bestsad ) ; <END_VULN> CHECK_BETTER } } else {
void Wire ( UberDispatcher * dispatcher ) override ; <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) override ;
} <START_VULN> mpz_powm ( v , v , key -> d , key -> n ) ; <END_VULN> return 0 ; }
while ( Z_TYPE_PP ( zdata_ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & test_ptr ) ) { <START_VULN> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <END_VULN> if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) {
} ; private : <START_VULN> DISALLOW_IMPLICIT_CONSTRUCTORS ( AutoLock ) ; <END_VULN> CRITICAL_SECTION * lock_ ; } ;
<START_VULN> <END_VULN> #line 1 "extstandardvar_unserializer . re" + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- +
<START_VULN> const uint64_t mask_y = ( ( ( 1 << columns ) - 1 ) ) * 0x0101010101010101 ; <END_VULN> const uint16_t mask_uv = ( ( 1 << ( ( columns + 1 ) >> 1 ) ) - 1 ) * 0x1111 ;
modifier *= modifier ; modifier *= 3 ; <START_VULN> modifier += 1 << ( strength - 1 ) ; <END_VULN> modifier >>= strength ; if ( modifier > 16 )
} } else { if ( state -> array_nl ) ruby_xfree ( state -> array_nl ) ; <START_VULN> state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ; <END_VULN> state -> array_nl_len = len ; } return Qnil ;
yych = * ++ YYCURSOR ; if ( yych != '"' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 698 "extstandardvar_unserializer . re"<END_VULN> { if ( ! var_hash ) return 0 ;
if ( clear [ 3 ] != 0x9d | | clear [ 4 ] != 0x01 | | clear [ 5 ] != 0x2a ) <START_VULN> res = VPX_CODEC_UNSUP_BITSTREAM ; <END_VULN> si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ; si -> h = ( clear [ 8 ] | ( clear [ 9 ] << 8 ) ) & 0x3fff ;
png_debug ( 1 , "in png_do_read_intrapixel" ) ; if ( <START_VULN> ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) ) <END_VULN> { int bytes_per_pixel ; png_uint_32 row_width = row_info -> width ;
"only allowed for select groups" ) ; return OFPERR_OFPBPC_BAD_VALUE ; default : <START_VULN> OVS_NOT_REACHED ( ) ; <END_VULN> } switch ( group_cmd ) {
class ShellMainDelegate : public ContentMainDelegate { public : <START_VULN> ShellMainDelegate ( ) ; <END_VULN> ~ ShellMainDelegate ( ) override ;
vpx_malloc ( sizeof ( sem_t ) * th_count ) ) ; CHECK_MEM_ERROR ( cpi -> mb_row_ei , vpx_memalign ( 32 , sizeof ( MB_ROW_COMP ) * th_count ) ) ; <START_VULN> vpx_memset ( cpi -> mb_row_ei , 0 , sizeof ( MB_ROW_COMP ) * th_count ) ; <END_VULN> CHECK_MEM_ERROR ( cpi -> en_thread_data , vpx_malloc ( sizeof ( ENCODETHREAD_DATA ) * th_count ) ) ;
} extra -> match_limit = PCRE_G ( backtrack_limit ) ; extra -> match_limit_recursion = PCRE_G ( recursion_limit ) ; <START_VULN> <END_VULN> array_init ( return_value ) ;
if ( yych <= '9' ) goto yy97 ; if ( yych != ' ; ' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 500 "extstandardvar_unserializer . re"<END_VULN> { long id ;
MACROBLOCKD * const xd = & x -> e_mbd ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <START_VULN> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <END_VULN> int i , j ; uint8_t * dst ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ;
return t1 - t0 ; } <START_VULN> #elif defined ( HAVE_GETRUSAGE ) <END_VULN> void jas_tmr_start ( jas_tmr_t * tmr ) {
<START_VULN> const chromeos : : InputMethodDescriptor * GetInputMethodDescriptorFromId ( <END_VULN> const std : : string & input_method_id ) ;
body = rbuf ; <START_VULN> if ( sc_asn1_read_tag ( & body , 0xffff , & cla_out , & tag_out , & bodylen ) != SC_SUCCESS<END_VULN> | | body == NULL ) { sc_log ( card -> ctx , " ** ** * received buffer tag MISSING " ) ;
static void spl_filesystem_dir_it_move_forward ( zend_object_iterator * iter TSRMLS_DC ) { spl_filesystem_object * object = spl_filesystem_iterator_to_object ( ( spl_filesystem_iterator * ) iter ) ; <START_VULN> <END_VULN> object -> u . dir . index ++ ; spl_filesystem_dir_read ( object TSRMLS_CC ) ; if ( object -> file_name ) {
if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <START_VULN> strlcpy ( rl . type , "larval" , sizeof ( rl . type ) ) ; <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ;
phar_obj -> arc . archive -> alias = oldalias ; phar_obj -> arc . archive -> alias_len = oldalias_len ; phar_obj -> arc . archive -> is_temporary_alias = old_temp ; <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> if ( readd ) { zend_hash_add ( & ( PHAR_GLOBALS -> phar_alias_map ) , oldalias , oldalias_len , ( void * ) & ( phar_obj -> arc . archive ) , sizeof ( phar_archive_data * ) , NULL ) ; }
<START_VULN> png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , <END_VULN> NULL , NULL , NULL ) ; if ( ! png_ptr ) return FALSE ;
<START_VULN> mp_err<END_VULN> ec_GFp_pt_dbl_jm ( const mp_int * px , const mp_int * py , const mp_int * pz , const mp_int * paz4 , mp_int * rx , mp_int * ry , mp_int * rz , mp_int * raz4 , mp_int scratch [ ] , const ECGroup * group ) { mp_err res = MP_OKAY ; mp_int * t0 , * t1 , * M , * S ; t0 = & scratch [ 0 ] ;
void AddInterstitialObservers ( content : : WebContents * contents ) ; <START_VULN> void RemoveInterstitialObservers ( TabContents * contents ) ; <END_VULN> inline BrowserWindow * window ( ) ; inline Profile * profile ( ) ;
return ( DestroyImageList ( image ) ) ; } packets = ( bits_per_pixel * image -> columns + 7 ) 8 ; <START_VULN> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <END_VULN> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ;
newserv -> usn [ l ] = '0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <START_VULN> if ( p + l > buf + n ) { <END_VULN> syslog ( LOG_WARNING , "bad request ( length encoding ) " ) ; goto error ; }
bool IsIMEDoingKakuteiUndo ( ) const ; <START_VULN> void RemoveMessageAndDispatchPluginEvent ( UINT aFirstMsg , UINT aLastMsg ) const ; <END_VULN> bool IsKeyDownMessage ( ) const { return ( mMsg . message == WM_KEYDOWN | | mMsg . message == WM_SYSKEYDOWN ) ; } bool IsFollowedByCharMessage ( ) const { MOZ_ASSERT ( mMsg . message == WM_KEYDOWN | | mMsg . message == WM_SYSKEYDOWN ) ;
ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <START_VULN> <END_VULN> if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ;
#include "basefilesfile_path . h" #include "basefilesfile_tracing . h" #include "basefilesscoped_file . h" <START_VULN> #include "basemove . h"<END_VULN> #include "basetimetime . h" #include "buildbuild_config . h"
% <START_VULN> static unsigned int XBMInteger ( Image * image , short int * hex_digits ) <END_VULN> { int c ;
bool isLayoutSizeChanged ( ) const { return m_isLayoutSizeChanged ; } void determineIfLayoutSizeChanged ( ) override ; <START_VULN> void setNeedsTransformUpdate ( ) override { m_needsTransformUpdate = true ; } <END_VULN> void paint ( const PaintInfo & , const LayoutPoint & ) const override ;
png_write_info_before_PLTE ( png_ptr , info_ptr ) ; <START_VULN> if ( info_ptr -> valid & PNG_INFO_PLTE ) <END_VULN> png_write_PLTE ( png_ptr , info_ptr -> palette , ( png_uint_32 ) info_ptr -> num_palette ) ;
char * pair , * tok ; pair = stok ( sclone ( buf ) , " & " , & tok ) ; <START_VULN> while ( pair != 0 ) { <END_VULN> mprAddItem ( app -> formData , sclone ( pair ) ) ; pair = stok ( 0 , " & " , & tok ) ; }
if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && <START_VULN> ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) <END_VULN> ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ;
int ret = 0 ; ve -> stretch ++ ; if ( ve -> stretch>VE_MAXSTRETCH * 2 ) ve -> stretch = VE_MAXSTRETCH * 2 ; for ( i = 0 ; i < ve -> ch ; i ++ ) { float * pcm = v -> pcm [ i ] + ve -> searchstep * ( j ) ; <START_VULN> ret |= _ve_amp ( ve , gi , pcm , ve -> band , ve -> filter + i * VE_BANDS , j ) ; <END_VULN> } ve -> mark [ j + VE_POST ] = 0 ; if ( ret & 1 ) { ve -> mark [ j ] = 1 ; ve -> mark [ j + 1 ] = 1 ; }
MagickExport int LocaleUppercase ( const int c ) { <START_VULN> if ( c < 0 ) <END_VULN> return ( c ) ; #if defined ( MAGICKCORE_LOCALE_SUPPORT ) if ( c_locale != ( locale_t ) NULL )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : LPC low level routines <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_LPC_H_ #define _V_LPC_H_ #include "vorbiscodec . h"
bool mSuppressEOF ; bool mReadingFromStage ; nsTArray < nsHtml5TreeOperation> mOpQueue ; nsTArray < nsIContentPtr> mElementsSeenInThisAppendBatch ; nsTArray < nsHtml5PendingNotification> mPendingNotifications ; nsHtml5StreamParser * mStreamParser ; <START_VULN> nsCOMArray < nsIContent> mOwnedElements ; <END_VULN> nsTHashtable < nsCStringHashKey> mPreloadedURLs ; nsCOMPtr < nsIURI> mSpeculationBaseURI ;
class V4L2VP8Picture ; class VaapiVP8Picture ; <START_VULN> class VP8Picture : public base : : RefCounted < VP8Picture> { <END_VULN> public : VP8Picture ( ) ;
if ( bcache ) <START_VULN> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; <END_VULN> else { cache -> index = h -> index ;
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } break ;
* <START_VULN> void read_png ( FILE * fp , unsigned int sig_read ) <END_VULN> { png_structp png_ptr ; png_infop info_ptr ;
case FILE_BEQLDATE : case FILE_LEQLDATE : if ( file_printf ( ms , F ( ms , m , " % s" ) , <START_VULN> file_fmttime ( p -> q , 0 , tbuf ) ) == - 1 ) <END_VULN> return - 1 ; t = ms -> offset + sizeof ( uint64_t ) ; break ;
AVFormatContext * ctx ; AVOutputFormat * fmt_out ; Bool ret = GF_FALSE ; <START_VULN> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <END_VULN> const char * szExtList ; FFDemux * ffd ; if ( ! plug | | ! url )
png_ptr -> zlib_text_method = method ; } <START_VULN> #endif<END_VULN> void PNGAPI
@description This does a deep copy of a JSON object tree . This copies all properties and their sub - properties . @return A new JSON object that replices the input object . @ingroup MprJson <START_VULN> @stability Prototype<END_VULN> PUBLIC MprJson * mprCloneJson ( MprJson * obj ) ;
} } ; <START_VULN> const vp9_prob vp9_kf_uv_mode_prob [ INTRA_MODES ] [ INTRA_MODES - 1 ] = { <END_VULN> { 144 , 11 , 54 , 157 , 195 , 130 , 46 , 58 , 108 } , { 118 , 15 , 123 , 148 , 131 , 101 , 44 , 93 , 131 } , { 113 , 12 , 23 , 188 , 226 , 142 , 26 , 32 , 125 } ,
ui4_payload_type = 0 ; u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <START_VULN> while ( 0xff == u4_bits ) <END_VULN> { u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; ui4_payload_type += 255 ;
#undef mem_put_le32 #define mem_put_le32 mem_ops_wrap_symbol ( mem_put_le32 ) <START_VULN> static void mem_put_le32 ( void * vmem , MEM_VALUE_T val ) { <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; mem [ 0 ] = ( val >> 0 ) & 0xff ;
iterator -> intern . funcs = & spl_filesystem_tree_it_funcs ; } zval_add_ref ( & object ) ; <START_VULN> <END_VULN> return ( zend_object_iterator * ) iterator ; }
typedef struct { <START_VULN> uchar * data ; <END_VULN> uint_fast16_t len ;
@param ptr Pointer to the block @return Size of the allocated block . @ingroup MprMem <START_VULN> @stability Evolving<END_VULN> PUBLIC size_t psize ( void * ptr ) ;
return rc ; } <START_VULN> static int fsmVerify ( const char * path , rpmfi fi ) <END_VULN> { int rc ; int saveerrno = errno ;
rem_port = GetValueFromNameValueList ( & data , "RemotePort" ) ; protocol = GetValueFromNameValueList ( & data , "Protocol" ) ; <START_VULN> if ( ! int_port | | ! ext_port | | ! protocol ) <END_VULN> { ClearNameValueList ( & data ) ; SoapError ( h , 402 , "Invalid Args" ) ;
#ifdef AF_INET6 case AF_INET6 : #endif <START_VULN> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <END_VULN> break ; default :
} } <START_VULN> int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <END_VULN> { if ( Stream_GetRemainingLength ( s ) < 12 ) return - 1 ;
return 1 ; } <START_VULN> #line 1142 "extstandardvar_unserializer . c"<END_VULN> yy76 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy73 ;
( void ) ResetMagickMemory ( & dib_info , 0 , sizeof ( dib_info ) ) ; dib_info . size = ReadBlobLSBLong ( image ) ; <START_VULN> if ( dib_info . size != 40 ) <END_VULN> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; Microsoft Windows 3 . X DIB image file .
{ unsigned int i ; <START_VULN> for ( i = 0 ; i < TTABLE_SIZE ; ++ i ) <END_VULN> { if ( transform_info [ i ] . when & TRANSFORM_R ) read_transforms |= transform_info [ i ] . transform ;
{ uint8 * bufp = buf ; int32 bytes_read = 0 ; <START_VULN> uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ; <END_VULN> uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ;
} } } else { <START_VULN> for ( j = 0 ; j < x -> searches_per_step ; j ++ ) { <END_VULN> const MV this_mv = { best_mv -> row + ss [ i ] . mv . row , best_mv -> col + ss [ i ] . mv . col } ;
uint32_t table_id , count , size_required ; uint32_t num_extensions = 0 ; <START_VULN> if ( size_left && size_left < 4 ) { <END_VULN> LogError ( "Process_ipfix [ % u ] Template size error at % s line % u" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ;
* #ifndef _nsCrypto_h_ #define _nsCrypto_h_ #include "nsCOMPtr . h" #include "nsIDOMCRMFObject . h" #include "nsIDOMCrypto . h" <START_VULN> #include "nsIDOMPkcs11 . h"<END_VULN> #include "nsIRunnable . h" #include "nsString . h" #include "jsapi . h" #include "nsIPrincipal . h" #define NS_CRYPTO_CLASSNAME "Crypto JavaScript Class" #define NS_CRYPTO_CID { 0x929d9320 , 0x251e , 0x11d4 , { 0x8a , 0x7c , 0x00 , 0x60 , 0x08 , 0xc8 , 0x44 , 0xc3 } }
jas_cmprof_t * cmprof_ ; <START_VULN> bool inmem_ ; <END_VULN> } jas_image_t ;
_vp_offset_and_mix ( psy_look , noise , tone , 1 , logmask , mdct , logmdct ) ; <START_VULN> <END_VULN> #if 0 if ( vi -> channels == 2 ) { if ( i == 0 ) _analysis_output ( "aotuvM1_L" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ; else _analysis_output ( "aotuvM1_R" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ; } else { _analysis_output ( "aotuvM1" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ;
HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; switch ( Z_TYPE_P ( offset ) ) { <START_VULN> case IS_STRING : <END_VULN> if ( zend_symtable_find ( ht , Z_STRVAL_P ( offset ) , Z_STRLEN_P ( offset ) + 1 , ( void ** ) & tmp ) != FAILURE ) { if ( check_empty == 2 ) { return 1 ;
cwd [ 2 ] = '0' ; } #endif <START_VULN> cwd_skip = ( int ) strlen ( cwd ) + 1 ; <END_VULN> snprintf ( work_pattern , MAXPATHLEN , " % s % c % s" , cwd , DEFAULT_SLASH , pattern ) ; pattern = work_pattern ;
png_uint_32 crc ; int need_crc = 1 ; <START_VULN> if ( PNG_CHUNK_ANCILLARY ( png_ptr -> chunk_name ) ) <END_VULN> { if ( ( png_ptr -> flags & PNG_FLAG_CRC_ANCILLARY_MASK ) == ( PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN ) )
do { next = pmd_addr_end ( addr , end ) ; split_huge_page_pmd ( vma -> vm_mm , pmd ) ; <START_VULN> if ( pmd_none_or_clear_bad ( pmd ) ) <END_VULN> continue ; if ( check_pte_range ( vma , pmd , addr , next , nodes , flags , private ) )
png_ptr -> background = * background_color ; png_ptr -> background_gamma = background_gamma ; png_ptr -> background_gamma_type = ( png_byte ) ( background_gamma_code ) ; <START_VULN> if ( need_expand ) <END_VULN> png_ptr -> transformations |= PNG_BACKGROUND_EXPAND ; else png_ptr -> transformations &= ~ PNG_BACKGROUND_EXPAND ;
<START_VULN> extern const void * lh_table_lookup ( struct lh_table * t , const void * k ) ; <END_VULN>
const std : : string & content , const std : : string & base_page_url , const std : : string & encoding , <START_VULN> int now_on_tap_version ) ; <END_VULN> ContextualSearchParams ( const ContextualSearchParams & other ) ; ~ ContextualSearchParams ( ) ;
#endif if ( ssap == LLCSAP_ISONS && dsap == LLCSAP_ISONS && control == LLC_UI ) { <START_VULN> isoclns_print ( ndo , p , length , caplen ) ; <END_VULN> return ( hdrlen ) ; }
class DOMHandler : public DevToolsDomainHandler , public DOM : : Backend { public : <START_VULN> DOMHandler ( ) ; <END_VULN> ~ DOMHandler ( ) override ; void Wire ( UberDispatcher * dispatcher ) override ;
} blk_finish_plug ( & plug ) ; <START_VULN> kiocb_batch_free ( & batch ) ; <END_VULN> put_ioctx ( ctx ) ; return i ? i : ret ; }
@param ptr Pointer to the block @remarks Do not mix calls to pfree and free . @ingroup MprMem <START_VULN> @stability Evolving<END_VULN> PUBLIC void pfree ( void * ptr ) ;
for ( ; rp > png_ptr -> row_buf ; rp -- ) { <START_VULN> if ( * rp >> padding != 0 ) <END_VULN> png_ptr -> num_palette_max = 1 ; padding = 0 ; }
return ; } <START_VULN> alphablending_bak = im -> alphaBlendingFlag ; <END_VULN> im -> alphaBlendingFlag = 0 ; if ( nc == gdTiled ) {
DISALLOW_COPY_AND_ASSIGN ( DevToolsClient ) ; } ; <START_VULN> #endif<END_VULN>
printf ( "PCIe FPGA config : " ) ; do { <START_VULN> done = qrio_get_gpio ( GPIO_A , FPGA_DONE ) ; <END_VULN> if ( timeout -- == 0 ) { printf ( " FPGA_DONE timeout" ) ; ret = - EFAULT ;
ZVAL_NULL ( rval ) ; return 1 ; } <START_VULN> #line 1237 "extstandardvar_unserializer . c"<END_VULN> yy89 : yych = * ++ YYCURSOR ; if ( yych <= ' , ' ) {
image -> filename ) ; return ( FALSE ) ; } <START_VULN> <END_VULN> iptc_profile = ( StringInfo * ) GetImageProfile ( image , "8bim" ) ; if ( iptc_profile != ( StringInfo * ) NULL ) {
return NULL ; } <START_VULN> ret = snprintf ( dest , len , " % slocklxc % s" , rundir , p ) ; <END_VULN> if ( ret < 0 | | ret > = len ) { free ( dest ) ; free ( rundir ) ;
#include "vpxvpx_codec . h" <START_VULN> static const char * const cfg = " -- target = armv6 - linux - gcc -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
<START_VULN> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <END_VULN> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; best_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ;
if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; <START_VULN> image -> columns = image -> rows = 0 ; <END_VULN> image -> colors = 0 ; break ;
& lib_dir , & lib_dir_len ) == FAILURE ) { return ; } <START_VULN> <END_VULN> array_init ( return_value ) ; modules = mcrypt_list_algorithms ( lib_dir , & count ) ;
void WalkRules ( nsIStyleRuleProcessor : : EnumFunc aFunc , void * aData ) ; nsINodeList * GetAnonymousNodes ( ) ; static nsresult DoInitJSClass ( JSContext * cx , JSObject * global , JSObject * obj , const nsAFlatCString & aClassName , nsXBLPrototypeBinding * aProtoBinding , <START_VULN> JSObject ** aClassObject ) ; <END_VULN> bool AllowScripts ( ) ; void RemoveInsertionParent ( nsIContent * aParent ) ; bool HasInsertionParent ( nsIContent * aParent ) ; protected :
if ( ( regs -> sr & SR_IMASK ) != SR_IMASK ) local_irq_enable ( ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <END_VULN>
OD ( nsExtEntityLogo , SEC_OID_NS_CERT_EXT_ENTITY_LOGO , "Certificate Entity Logo" , CKM_INVALID_MECHANISM , UNSUPPORTED_CERT_EXTENSION ) , OD ( nsExtUserPicture , SEC_OID_NS_CERT_EXT_USER_PICTURE , "Certificate User Picture" , CKM_INVALID_MECHANISM , UNSUPPORTED_CERT_EXTENSION ) , OD ( nsExtSSLServerName , SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME , "Certificate SSL Server Name" , <START_VULN> CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , <END_VULN> OD ( nsExtComment , SEC_OID_NS_CERT_EXT_COMMENT , "Certificate Comment" , CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , OD ( nsExtLostPasswordURL , SEC_OID_NS_CERT_EXT_LOST_PASSWORD_URL , "Lost Password URL" , CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , OD ( nsExtCertRenewalTime , SEC_OID_NS_CERT_EXT_CERT_RENEWAL_TIME , "Certificate Renewal Time" ,
case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL | | cmdSize != sizeof ( effect_config_t ) <START_VULN> | | pReplyData == NULL | | * replySize != sizeof ( int ) ) { <END_VULN> return - EINVAL ; } * ( int * ) pReplyData = Downmix_Configure ( pDwmModule ,
void init_context_counters ( void ) { <START_VULN> vpx_memset ( context_counters , 0 , sizeof ( context_counters ) ) ; <END_VULN> } void print_context_counters ( )
PORT_ZFree ( slotPw . data , PL_strlen ( slotPw . data ) ) ; if ( p12FilePw . data != NULL ) PORT_ZFree ( p12FilePw . data , PL_strlen ( p12FilePw . data ) ) ; if ( slot ) PK11_FreeSlot ( slot ) ; if ( NSS_Shutdown ( ) != SECSuccess ) { pk12uErrno = 1 ; } PR_Cleanup ( ) ; <START_VULN> PL_ArenaFinish ( ) ; <END_VULN> return pk12uErrno ; }
} } * q = '0' ; <START_VULN> <END_VULN> RETVAL_STRINGL ( erealloc ( out_str , q - out_str + 1 ) , q - out_str , 0 ) ; }
nsIPrincipal * originPrincipal , nsISupports * context , const nsACString & mimeType , nsISupports * extra , int16_t * decision , nsIContentPolicy * policyService = nullptr , nsIScriptSecurityManager * aSecMan = nullptr ) { <START_VULN> CHECK_PRINCIPAL ; <END_VULN> if ( policyService ) { CHECK_CONTENT_POLICY_WITH_SERVICE ( ShouldLoad , policyService ) ; } CHECK_CONTENT_POLICY ( ShouldLoad ) ; }
} <START_VULN> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <END_VULN> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;
BOOL updaterIsCorrect ; if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) ) { LOG_WARN ( ( "Error checking if the updaters are the same . " "Path 1 : % lsPath 2 : % ls" , argv [ 0 ] , installDirUpdater ) ) ; result = FALSE ; } if ( result && ! updaterIsCorrect ) { <START_VULN> LOG_WARN ( ( "The updaters do not match , udpater will not run . " ) ) ; <END_VULN> result = FALSE ; } if ( result ) { LOG ( ( "updater . exe was compared successfully to the installation directory" " updater . exe . " ) ) ; } else { if ( ! WriteStatusFailure ( argv [ 1 ] , SERVICE_UPDATER_COMPARE_ERROR ) ) { LOG_WARN ( ( "Could not write update . status updater compare failure . " ) ) ;
} <START_VULN> if ( i > ( int ) rec -> length ) <END_VULN> {
} static void read_coef_probs ( FRAME_CONTEXT * fc , TX_MODE tx_mode , <START_VULN> vp9_reader * r ) { <END_VULN> const TX_SIZE max_tx_size = tx_mode_to_biggest_tx_size [ tx_mode ] ; TX_SIZE tx_size ; for ( tx_size = TX_4X4 ; tx_size <= max_tx_size ; ++ tx_size )
#endif #ifdef HAVE_GNUTLS_GNUTLS_H <START_VULN> const int tls_kx_order [ ] = { <END_VULN> GNUTLS_KX_ANON_DH , GNUTLS_KX_DHE_RSA , GNUTLS_KX_DHE_DSS ,
#define MBREX ( g ) ( MBSTRG ( mb_regex_globals ) -> g ) <START_VULN> static void php_mb_regex_free_cache ( php_mb_regex_t ** pre ) <END_VULN> { onig_free ( * pre ) ; }
printk ( KERN_WARNING "nfs_callback_create_svc : no kthread , % d users ? ? " , cb_info -> users ) ; <START_VULN> serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ; <END_VULN> if ( ! serv ) { printk ( KERN_ERR "nfs_callback_create_svc : create service failed" ) ; return ERR_PTR ( - ENOMEM ) ;
png_text_compress_init ( & comp , ( png_const_bytep ) text , strlen ( text ) ) ; <START_VULN> if ( compression ) <END_VULN> { if ( png_text_compress ( png_ptr , png_iTXt , & comp , prefix_len ) != Z_OK ) png_error ( png_ptr , png_ptr -> zstream . msg ) ;
unsigned int lci , new_lci ; unsigned char cause , diagnostic ; struct net_device * dev ; <START_VULN> int len , res = 0 ; <END_VULN> char buf [ 11 ] ; #if 0
if ( ! page ) { ret = - ENOMEM ; page = page_cache_alloc_cold ( mapping ) ; if ( unlikely ( ! page ) ) goto out_ret ; ret = add_to_page_cache_lru ( page , mapping , index , GFP_KERNEL ) ; if ( unlikely ( ret ) ) <START_VULN> goto out ; <END_VULN> } ret = mapping -> a_ops -> prepare_write ( file , page , offset , offset + this_len ) ; if ( unlikely ( ret ) ) { loff_t isize = i_size_read ( mapping -> host ) ; if ( ret != AOP_TRUNCATED_PAGE ) unlock_page ( page ) ; page_cache_release ( page ) ; if ( ret == AOP_TRUNCATED_PAGE )
{ png_debug ( 1 , "in png_do_bgr" ) ; <START_VULN> if ( ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) ) <END_VULN> { png_uint_32 row_width = row_info -> width ; if ( row_info -> bit_depth == 8 )
virtual bool IsTransportSeekable ( ) = 0 ; <START_VULN> static MediaResource * Create ( MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <END_VULN> virtual nsresult Open ( nsIStreamListener ** aStreamListener ) = 0 ;
static PHP_MINIT_FUNCTION ( pcre ) { REGISTER_INI_ENTRIES ( ) ; <START_VULN> <END_VULN> REGISTER_LONG_CONSTANT ( "PREG_PATTERN_ORDER" , PREG_PATTERN_ORDER , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( "PREG_SET_ORDER" , PREG_SET_ORDER , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( "PREG_OFFSET_CAPTURE" , PREG_OFFSET_CAPTURE , CONST_CS | CONST_PERSISTENT ) ;
#define HAVE_FTIME 1 <START_VULN> #define HAVE_GCRYPT 1<END_VULN> #define HAVE_GETTIMEOFDAY 1
ret = cur = xmlNewDocElementContent ( ctxt -> myDoc , NULL , XML_ELEMENT_CONTENT_PCDATA ) ; if ( ret == NULL ) return ( NULL ) ; } <START_VULN> while ( RAW == ' | ' ) { <END_VULN> NEXT ; if ( elem == NULL ) { ret = xmlNewDocElementContent ( ctxt -> myDoc , NULL , XML_ELEMENT_CONTENT_OR ) ;
#ifndef PPAPI_HOST_DISPATCH_HOST_MESSAGE_H_ #define PPAPI_HOST_DISPATCH_HOST_MESSAGE_H_ <START_VULN> #include "baseprofilerscoped_profile . h"<END_VULN> #include "ipcipc_message_macros . h" #include "ppapicpp_errors . h"
void GatherGlobalUsageComplete ( ) ; void GatherHostUsageComplete ( const std : : string & host ) ; <START_VULN> int64 GetCachedHostUsage ( const std : : string & host ) ; <END_VULN> int64 GetCachedGlobalUnlimitedUsage ( ) ; virtual void OnSpecialStoragePolicyChanged ( ) OVERRIDE ; void NoopHostUsageCallback (
void GetReceiversAndActivities ( const ReceiversAndActivitesCallback & callback ) override ; void CastToReceiver ( const std : : string & receiver_id ) override ; <START_VULN> void StopCasting ( const std : : string & activity_id ) override ; <END_VULN> void LaunchCastOptions ( ) override ; DISALLOW_COPY_AND_ASSIGN ( CastConfigDelegateChromeos ) ;
} grayhi = rhi * data . red_coefficient + ghi * data . green_coefficient + <START_VULN> bhi * data . blue_coefficient + 1 . 32768 + out_qe ; <END_VULN> grayhi *= ( 1 + 6 * DBL_EPSILON ) ; if ( grayhi > = 1 ) grayhi = 1 ;
#include "basebasictypes . h" #include "basecompiler_specific . h" #include "basememoryscoped_ptr . h" <START_VULN> #include "componentsdom_distillercontentbrowserexternal_feedback_reporter . h"<END_VULN> #include "contentpublicbrowserurl_data_source . h" namespace dom_distiller {
zend_throw_exception_ex ( spl_ce_LogicException , 0 TSRMLS_CC , "Can't truncate file % s" , intern -> file_name ) ; RETURN_FALSE ; } <START_VULN> <END_VULN> RETURN_BOOL ( 0 == php_stream_truncate_set_size ( intern -> u . file . stream , size ) ) ; }
Stop a dispatcher by removing it from the run queue @param dispatcher Dispatcher object created via #mprCreateDispatcher @return Zero if successful , otherwise a negative MPR status code . <START_VULN> @stability Prototype<END_VULN> @ingroup MprEvent PUBLIC int mprStopDispatcher ( MprDispatcher * dispatcher ) ;
static void array_cleanup ( char * arr [ ] , int arr_size ) { int i = 0 ; <START_VULN> for ( i = 0 ; i < arr_size ; i ++ ) { <END_VULN> if ( arr [ i * 2 ] ) { efree ( arr [ i * 2 ] ) ; }
#elif ULONG_MAX > 4294967294 typedef unsigned long int png_uint_32 ; #else <START_VULN> # error "libpng requires an unsigned 32 bit ( or more ) type"<END_VULN> #endif
} if ( half_horiz ) run_length *= 2 ; if ( run_length > s -> avctx -> width - x ) return AVERROR_INVALIDDATA ; if ( color ) { memset ( s -> frame -> data [ 0 ] + y * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; <START_VULN> if ( half_vert ) <END_VULN> memset ( s -> frame -> data [ 0 ] + ( y + 1 ) * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; } x += run_length ; if ( x > = s -> avctx -> width ) { x = 0 ; y += 1 + half_vert ; } }
void InitAsProxiedNaCl ( <START_VULN> scoped_ptr < PluginDelegate : : OutOfProcessProxy> out_of_process_proxy , <END_VULN> PP_Instance instance ) ; static const PPB_Core * GetCore ( ) ;
* bry = tmpbry ; } <START_VULN> static inline long decode_twos_comp ( ulong c , int prec ) <END_VULN> { long result ; assert ( prec > = 2 ) ;
png_free ( png_ptr , row ) ; <START_VULN> if ( ! result ) <END_VULN> return 0 ; }
"" " function setTimer ( ) { " " checkSession ( ) ; " <START_VULN> " timerID = setInterval ( 'checkSession ( ) ' , % s ) ; "<END_VULN> " } " "" " function receiveMessage ( e ) { "
uint16_t transmitted_length = 0 ; while ( length > 0 ) { <START_VULN> ssize_t ret = write ( fd , data + transmitted_length , length ) ; <END_VULN> switch ( ret ) { case - 1 : LOG_ERROR ( "In % s , error writing to the serial port with fd % d : % s" , __func__ , fd , strerror ( errno ) ) ;
} processed ++ ; } else if ( afi == AF_INET6 ) { <START_VULN> if ( ! ND_TTEST2 ( * tptr , 1 ) ) <END_VULN> return ( 0 ) ; status_byte = * ( tptr ++ ) ; bit_length = * ( tptr ++ ) ;
#define MAJOR_VERSION 0 #define MINOR_VERSION 0 #define BUILD_VERSION 0 <START_VULN> #define BUILD_REVISION 740<END_VULN> #define STRINGIFY ( x ) #x #define MACRO_STRINGIFY ( x ) STRINGIFY ( x ) #define REVISION_STRING MACRO_STRINGIFY ( BUILD_REVISION ) #define VERSION_STRING MACRO_STRINGIFY ( MAJOR_VERSION ) " . " MACRO_STRINGIFY ( MINOR_VERSION ) " . " MACRO_STRINGIFY ( BUILD_VERSION ) " . " MACRO_STRINGIFY ( BUILD_REVISION )
base : : WeakPtrFactory < WebGraphicsContext3DCommandBufferImpl> weak_ptr_factory_ ; #ifdef FLIP_FRAMEBUFFER_VERTICALLY <START_VULN> scoped_array < uint8> scanline_ ; <END_VULN> void FlipVertically ( uint8 * framebuffer , unsigned int width , unsigned int height ) ;
va_list ap ; va_start ( ap , ctrl_id ) ; <START_VULN> res = entry -> fn ( ctx -> priv -> alg_priv , ctrl_id , ap ) ; <END_VULN> va_end ( ap ) ; break ; }
if ( pal ) { s -> frame -> palette_has_changed = 1 ; memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ; } memcpy ( s -> frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ; } if ( avctx -> height * istride == avpkt -> size ) { <START_VULN> int linesize = ( avctx -> width * avctx -> bits_per_coded_sample + 7 ) 8 ; <END_VULN> uint8_t * ptr = s -> frame -> data [ 0 ] ; uint8_t * buf = avpkt -> data + ( avctx -> height - 1 ) * istride ; int i , j ; for ( i = 0 ; i < avctx -> height ; i ++ ) { if ( avctx -> bits_per_coded_sample == 4 ) { for ( j = 0 ; j < avctx -> width - 1 ; j += 2 ) { ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ; ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF ; }
criteria = "x" ; } if ( schr ( name , '#' ) ) { <START_VULN> name = stok ( sclone ( name ) , "#" , ( char ** ) & criteria ) ; <END_VULN> } files = mprGetPathFiles ( mprJoinPath ( app -> paksCacheDir , name ) , MPR_PATH_RELATIVE ) ; mprSortList ( files , ( MprSortProc ) reverseSortFiles , 0 ) ;
} yy63 : ++ YYCURSOR ; <START_VULN> #line 600 "extstandardvar_unserializer . re"<END_VULN> { #if SIZEOF_LONG == 4 use_double :
{ png_debug ( 1 , "in png_do_write_intrapixel" ) ; <START_VULN> if ( ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) ) <END_VULN> { int bytes_per_pixel ; png_uint_32 row_width = row_info -> width ;
if ( strchr ( wp -> query , ' = ' ) == NULL ) { query = sclone ( wp -> query ) ; websDecodeUrl ( query , query , strlen ( query ) ) ; <START_VULN> for ( cp = stok ( query , " " , & tok ) ; cp != NULL ; ) { <END_VULN> * ( argp + n ) = cp ; trace ( 5 , "ARG [ % d ] % s" , n , argp [ n - 1 ] ) ; n ++ ;
bool hasStaticBlockPosition ( bool horizontal ) const { return horizontal ? hasAutoTopAndBottom ( ) : hasAutoLeftAndRight ( ) ; } EPosition position ( ) const { return static_cast < EPosition> ( noninherited_flags . _position ) ; } <START_VULN> bool isPositioned ( ) const { return position ( ) == AbsolutePosition | | position ( ) == FixedPosition ; } <END_VULN> EFloat floating ( ) const { return static_cast < EFloat> ( noninherited_flags . _floating ) ; } Length width ( ) const { return m_box -> width ( ) ; }
perf_fetch_caller_regs ( & hot_regs ) ; regs = & hot_regs ; } <START_VULN> __perf_sw_event ( event_id , nr , nmi , regs , addr ) ; <END_VULN> } }
int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <START_VULN> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <END_VULN> unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ;
0 . 9999998698F , 0 . 9999998906F , 0 . 9999999088F , 0 . 9999999246F , 0 . 9999999383F , 0 . 9999999500F , 0 . 9999999600F , 0 . 9999999684F , 0 . 9999999754F , 0 . 9999999811F , 0 . 9999999858F , 0 . 9999999896F , 0 . 9999999925F , 0 . 9999999948F , 0 . 9999999965F , 0 . 9999999978F , 0 . 9999999986F , 0 . 9999999992F , 0 . 9999999996F , 0 . 9999999998F , 0 . 9999999999F , 1 . 0000000000F , 1 . 0000000000F , 1 . 0000000000F , } ; <START_VULN> static float vwin8192 [ 4096 ] = { <END_VULN> 0 . 0000000578F , 0 . 0000005198F , 0 . 0000014438F , 0 . 0000028299F , 0 . 0000046780F , 0 . 0000069882F , 0 . 0000097604F , 0 . 0000129945F , 0 . 0000166908F , 0 . 0000208490F , 0 . 0000254692F , 0 . 0000305515F , 0 . 0000360958F , 0 . 0000421021F , 0 . 0000485704F , 0 . 0000555006F , 0 . 0000628929F , 0 . 0000707472F , 0 . 0000790635F , 0 . 0000878417F , 0 . 0000970820F , 0 . 0001067842F , 0 . 0001169483F , 0 . 0001275744F , 0 . 0001386625F , 0 . 0001502126F , 0 . 0001622245F , 0 . 0001746984F , 0 . 0001876343F , 0 . 0002010320F , 0 . 0002148917F , 0 . 0002292132F ,
{ UWORD8 i ; dec_seq_params_t * ps_seq = NULL ; <START_VULN> UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ; <END_VULN> UWORD16 i2_max_frm_num ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ;
else goto end ; } <START_VULN> if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) ) <END_VULN> goto loop ; }
png_fixed_point * int_blue_Z ) { if ( png_ptr != NULL && info_ptr != NULL && <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) ) <END_VULN> { png_debug1 ( 1 , "in % s retrieval function" , "cHRM_XYZ" ) ;
# endif # define TOLOWER ( x ) tolower ( x ) #else <START_VULN> # define TOLOWER ( x ) ( ( ( x ) < 0 | | ( x ) >256 ) ? ( x ) : mspack_tolower_map [ ( x ) ] ) <END_VULN>
} static INLINE void add_token_no_extra ( TOKENEXTRA ** t , <START_VULN> const vp9_prob * context_tree , <END_VULN> uint8_t token , uint8_t skip_eob_node , unsigned int * counts ) {
if ( fp > = DBL_MIN && fp <= DBL_MAX ) { <START_VULN> int exp_b10 ; <END_VULN> double base ;
case NLPID_CLNP : if ( ! clnp_print ( ndo , p , length ) ) <START_VULN> print_unknown_data ( ndo , p , "t" , caplen ) ; <END_VULN> break ; case NLPID_ESIS :
#include "chromebrowseruibrowser_navigator_params . h" #include "contentpubliccommonreferrer . h" <START_VULN> #include "third_partyblinkpublicmojomwindow_featureswindow_features . mojom . h"<END_VULN> #include "uibasewindow_open_disposition . h" #include "urlgurl . h" #include "urlorigin . h"
settings . use_cas = true ; settings . access = 0700 ; settings . port = 11211 ; <START_VULN> settings . udpport = 11211 ; <END_VULN> settings . inter = NULL ; settings . maxbytes = 64 * 1024 * 1024 ;
httpResetCredentials ( conn ) ; if ( password == NULL && strchr ( username , ' : ' ) != 0 ) { <START_VULN> conn -> username = stok ( sclone ( username ) , " : " , & ptok ) ; <END_VULN> conn -> password = sclone ( ptok ) ; } else { conn -> username = sclone ( username ) ;
this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <END_VULN> CHECK_BETTER } }
png_byte vpag_chunk_data [ 9 ] ; <START_VULN> if ( verbose ) <END_VULN> fprintf ( STDERR , " vpAg = % lu x % lu , units = % d" , ( unsigned long ) user_chunk_data . vpAg_width , ( unsigned long ) user_chunk_data . vpAg_height ,
a -> y2a = y2a * weight + y2b ; a -> xya = xya * weight + xyb ; a -> an = na * weight + nb ; } return ( na ) ; } <START_VULN> static void fit_line ( lsfit_acc * a , int fits , int * y0 , int * y1 ) { <END_VULN> long x = 0 , y = 0 , x2 = 0 , y2 = 0 , xy = 0 , an = 0 , i ; long x0 = a [ 0 ] . x0 ; long x1 = a [ fits - 1 ] . x1 ; for ( i = 0 ; i < fits ; i ++ ) { x += a [ i ] . xa ; y += a [ i ] . ya ; x2 += a [ i ] . x2a ;
return - 1 ; hdrlen = 2 ; } else { <START_VULN> switch ( pimv2_addr_len ) { <END_VULN> case sizeof ( struct in_addr ) : af = AF_INET ; break ;
<START_VULN> Copyright ( c ) 2000 , 2013 , Oracle andor its affiliates . All rights reserved . <END_VULN> This program is free software ; you can redistribute it andor modify it under the terms of the GNU General Public License as published by
if ( nentries > 0 ) png_chunk_report ( png_ptr , "sPLT out of memory" , PNG_CHUNK_WRITE_ERROR ) ; } <START_VULN> #endif<END_VULN> #ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED static png_byte
} if ( priv -> cac_id_len ) { serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ; <START_VULN> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <END_VULN> SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ;
void AccumulateContentLength ( int64 received_payload_byte_count , int64 original_payload_byte_count , <START_VULN> bool data_reduction_proxy_was_used ) ; <END_VULN> scoped_refptr < extensions : : EventRouterForwarder> event_router_ ; void * profile_ ;
ALOGV ( "Downmix_Command EFFECT_CMD_GET_PARAM pCmdData % p , * replySize % " PRIu32 " , pReplyData : % p" , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL | | cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) | | <START_VULN> pReplyData == NULL | | <END_VULN> * replySize < ( int ) sizeof ( effect_param_t ) + 2 * sizeof ( int32_t ) ) { return - EINVAL ; }
const TOKENEXTRA * stop = cpi -> tplist [ mb_row ] . stop ; int tokens = ( int ) ( stop - p ) ; <START_VULN> vp8_pack_tokens_c ( w , p , tokens ) ; <END_VULN> } }
#include "third_partyblinkpublicmojomdevtoolsconsole_message . mojom . h" #include "third_partyblinkpublicmojompermissionspermission_status . mojom . h" #include "third_partyblinkpublicmojomrenderer_preferences . mojom . h" <START_VULN> #include "third_partyblinkpublicmojomwindow_featureswindow_features . mojom . h"<END_VULN> #include "third_partyblinkpublicplatformweb_drag_operation . h" #include "third_partyblinkpublicplatformweb_history_scroll_restoration_type . h" #include "third_partyblinkpublicplatformweb_point . h" #include "third_partyblinkpublicplatformweb_rect . h" #include "third_partyblinkpublicplatformweb_security_style . h" #include "third_partyblinkpublicplatformweb_url_request . h" #include "uiaccessibilityax_event . h" #include "uiaccessibilityax_node_data . h" #include "uiaccessibilityax_relative_bounds . h"
zval ** * params = ( zval ** * ) safe_emalloc ( num_args , sizeof ( zval ** ) , 0 ) ; params [ 0 ] = & zresource_ptr ; <START_VULN> <END_VULN> if ( arg2 ) { params [ 1 ] = & arg2 ; }
#ifndef WITH_MODULES #define WITH_MODULES #endif <START_VULN> #define LIBXSLT_DEFAULT_PLUGINS_PATH ( ) "usrlocalliblibxslt - plugins"<END_VULN> #endif
for ( i = 1 ; i < L ; i ++ ) <START_VULN> NLSF_Q15 [ i ] = silk_max_int ( NLSF_Q15 [ i ] , NLSF_Q15 [ i - 1 ] + NDeltaMin_Q15 [ i ] ) ; <END_VULN> NLSF_Q15 [ L - 1 ] = silk_min_int ( NLSF_Q15 [ L - 1 ] , ( 1 << 15 ) - NDeltaMin_Q15 [ L ] ) ;
const AffineTransform & localToSVGParentTransform ( ) const override { return m_localToParentTransform ; } void calcViewport ( ) override ; <START_VULN> bool calculateLocalTransform ( ) override ; <END_VULN> bool pointIsInsideViewportClip ( const FloatPoint & pointInParent ) override ;
{ int len = strlen ( buffer ) ; <START_VULN> if ( ( len + * stringlen ) > * stralloc ) { <END_VULN> char * newptr = realloc ( string , * stralloc * 2 ) ; if ( newptr ) { string = newptr ;
} <START_VULN> for ( pass = HID_PASS + 1 ; pass < nb_guids ; pass ++ ) { <END_VULN> safe_free ( guid [ pass ] ) ; }
# define afirst 0 # endif # ifdef PNG_FORMAT_BGR_SUPPORTED <START_VULN> const int bgr = ( image -> format & PNG_FORMAT_FLAG_BGR ) ? 2 : 0 ; <END_VULN> # else # define bgr 0 # endif
} if ( set_name ) { <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <END_VULN> fprintf ( stdout , "BT adapter is up" ) ; bt_property_t * property = property_new_name ( bd_name ) ;
int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filt_val ; <START_VULN> int best_filt_val = cm -> filter_level ; <END_VULN> YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ;
{ <START_VULN> int czero , clead , cdigits ; <END_VULN> char exponent [ 10 ] ;
DevToolsAgentHostImpl * host ) ; void Wire ( UberDispatcher * dispatcher ) override ; <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) override ; void TargetCrashed ( ) ;
const int offset [ ] = { 1 , mode_info_stride - 1 , 1 , - mode_info_stride - 1 } ; <START_VULN> <END_VULN> const int shift_32_y [ ] = { 0 , 4 , 32 , 36 } ;
static int image_transform_png_set_strip_alpha_add ( image_transform * this , <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <END_VULN> { UNUSED ( bit_depth )
} break ; } <START_VULN> option = stok ( option , " = t , " , & ovalue ) ; <END_VULN> ovalue = strim ( ovalue , ""'" , MPR_TRIM_BOTH ) ; if ( ( int ) isdigit ( ( uchar ) * option ) ) { lifespan = httpGetTicks ( option ) ;
mse [ 1 ] , mse [ 2 ] , mse [ 3 ] ) ; bytes_total += si -> bytes_sum [ i ] ; <START_VULN> <END_VULN> si -> bytes_sum [ i ] = 0 ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] = 0 ;
<START_VULN> if ( transforms & PNG_TRANSFORM_EXPAND ) <END_VULN> #ifdef PNG_READ_EXPAND_SUPPORTED png_set_expand ( png_ptr ) ; #else
if ( row_info . pixel_depth != png_ptr -> pixel_depth | | <START_VULN> row_info . pixel_depth != png_ptr -> transformed_pixel_depth ) <END_VULN> png_error ( png_ptr , "internal write transform logic error" ) ; #ifdef PNG_MNG_FEATURES_SUPPORTED
static int _vds_shared_init ( vorbis_dsp_state * v , vorbis_info * vi , int encp ) { int i ; codec_setup_info * ci = vi -> codec_setup ; private_state * b = NULL ; int hs ; if ( ci == NULL ) return 1 ; <START_VULN> hs = ci -> halfrate_flag ; <END_VULN> memset ( v , 0 , sizeof ( * v ) ) ; b = v -> backend_state = _ogg_calloc ( 1 , sizeof ( * b ) ) ; v -> vi = vi ; b -> modebits = ilog2 ( ci -> modes ) ; b -> transform [ 0 ] = _ogg_calloc ( VI_TRANSFORMB , sizeof ( * b -> transform [ 0 ] ) ) ;
png_crc_read ( png_ptr , buffer , length ) ; <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <END_VULN> return ; buffer [ length ] = 0 ;
if ( ! path ) { path = sclone ( option ) ; } else { <START_VULN> option = stok ( option , " = t , " , & ovalue ) ; <END_VULN> ovalue = strim ( ovalue , ""'" , MPR_TRIM_BOTH ) ; if ( smatch ( option , "anew" ) ) { flags |= MPR_LOG_ANEW ;
* y0 = rint ( a + b * x0 ) ; * y1 = rint ( a + b * x1 ) ; if ( * y0>1023 ) * y0 = 1023 ; if ( * y1>1023 ) * y1 = 1023 ; if ( * y0 < 0 ) * y0 = 0 ; if ( * y1 < 0 ) * y1 = 0 ; <START_VULN> <END_VULN> return 0 ; } else { * y0 = 0 ; * y1 = 0 ; return 1 ; } } }
double dr = ( double ) cpi -> bytes_in_layer [ i ] * 8 . 0 1000 . 0 time_encoded ; double samples = 3 . 0 2 * cpi -> frames_in_layer [ i ] * <START_VULN> lst_yv12 -> y_width * lst_yv12 -> y_height ; <END_VULN> double total_psnr = vpx_sse_to_psnr ( samples , 255 . 0 , cpi -> total_error2 [ i ] ) ;
#define RETURN ( xxx ) { param -> res = xxx ; goto CLEANRET ; } <START_VULN> #define LINESIZE 2048<END_VULN> extern FILE * writable ; FILE * confopen ( ) ;
if ( info_ptr != NULL ) { png_controlp control = png_voidcast ( png_controlp , <START_VULN> png_malloc_warn ( png_ptr , ( sizeof * control ) ) ) ; <END_VULN> if ( control != NULL ) {
compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = options . compression ? <START_VULN> "zlib@openssh . com , zlib , none" : "none , zlib@openssh . com , zlib" ; <END_VULN> myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ; if ( options . hostkeyalgorithms != NULL ) {
} rval = si4713_set_rds_ps_name ( sdev , ps_name ) ; } break ; case V4L2_CID_RDS_TX_RADIO_TEXT : { char radio_text [ MAX_RDS_RADIO_TEXT + 1 ] ; len = control -> size - 1 ; <START_VULN> if ( len > MAX_RDS_RADIO_TEXT ) { <END_VULN> rval = - ERANGE ; goto exit ; } rval = copy_from_user ( radio_text , control -> string , len ) ; if ( rval < 0 ) goto exit ; radio_text [ len ] = '0' ; if ( strlen ( radio_text ) % vqc . step ) { rval = - ERANGE ;
draw_info -> miterlimit = 10 ; draw_info -> decorate = NoDecoration ; draw_info -> pointsize = 12 . 0 ; <START_VULN> draw_info -> undercolor . alpha = ( Quantum ) TransparentAlpha ; <END_VULN> draw_info -> compose = OverCompositeOp ; draw_info -> render = MagickTrue ; draw_info -> debug = IsEventLogging ( ) ;
{ c = ReadBlobByte ( image ) ; if ( c == EOF ) <START_VULN> return ( 0 ) ; <END_VULN> } while ( ( c == ' ' ) | | ( c == 't' ) | | ( c == '' ) | | ( c == 'r' ) ) ; Evaluate number .
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : fft transform <START_VULN> last mod : $ Id : smallft . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_SMFT_H_ #define _V_SMFT_H_ #include "vorbiscodec . h"
APPL_TRACE_ERROR ( " % s : Device not found" , __FUNCTION__ ) return - 1 ; } <START_VULN> ret = read ( p_dev -> fd , & ev , sizeof ( ev ) ) ; <END_VULN> if ( ret == 0 ) { APPL_TRACE_ERROR ( " % s : Read HUP on uhid - cdev % s" , __FUNCTION__ , strerror ( errno ) ) ;
{ png_fixed_point result ; <START_VULN> if ( png_muldiv ( & result , a , times , divisor ) ) <END_VULN> return result ; png_warning ( png_ptr , "fixed point overflow ignored" ) ;
break ; case PNG_FP_EXPONENT + PNG_FP_SAW_SIGN : <START_VULN> if ( state & PNG_FP_SAW_ANY ) <END_VULN> goto PNG_FP_End ; png_fp_add ( state , PNG_FP_SAW_SIGN ) ;
double scal_width , scal_height ; if ( png_get_sCAL ( read_ptr , read_info_ptr , & unit , & scal_width , <START_VULN> & scal_height ) ) <END_VULN> { png_set_sCAL ( write_ptr , write_info_ptr , unit , scal_width , scal_height ) ; }
static void btsnoop_write ( const void * data , size_t length ) { if ( logfile_fd != INVALID_FD ) <START_VULN> write ( logfile_fd , data , length ) ; <END_VULN> btsnoop_net_write ( data , length ) ; }
SPL_METHOD ( SplFileObject , eof ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
#endif <START_VULN> if ( transforms & PNG_TRANSFORM_INVERT_ALPHA ) <END_VULN> #ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED png_set_invert_alpha ( png_ptr ) ; #else
if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) | | qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) ) { <START_VULN> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <END_VULN> NESTSIZE ( qtsize ) ; continue ; }
sizeof ( * clone_image -> colormap ) ) ; if ( clone_image -> colormap == ( PixelPacket * ) NULL ) { <START_VULN> clone_image = DestroyImage ( clone_image ) ; <END_VULN> ThrowImageException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } ( void ) CopyMagickMemory ( clone_image -> colormap , image -> colormap , length *
#include < jasperjas_config . h> #include < jasperjas_types . h> <START_VULN> uchar jas_iccprofdata_srgb [ ] = <END_VULN> { 0x00 , 0x00 , 0x0c , 0x48 , 0x4c , 0x69 , 0x6e , 0x6f , 0x02 , 0x10 , 0x00 , 0x00 , 0x6d , 0x6e , 0x74 , 0x72 ,
double prev_layer_framerate = 0 ; assert ( oxcf -> number_of_layers <= VPX_TS_MAX_LAYERS ) ; <START_VULN> for ( i = 0 ; i < oxcf -> number_of_layers ; i ++ ) <END_VULN> { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ;
} <START_VULN> static void<END_VULN> vpx_usec_timer_mark ( struct vpx_usec_timer * t ) { #if defined ( _WIN32 ) QueryPerformanceCounter ( & t -> end ) ;
@param join String to use as the element join string . @return String consisting of the joined hash values @ingroup MprHash <START_VULN> @stability Evolving<END_VULN> PUBLIC char * mprHashToString ( MprHash * hash , cchar * join ) ;
static int CVE_2009_2844_cmp_ies ( u8 num , u8 * ies1 , size_t len1 , u8 * ies2 , size_t len2 ) { const u8 * ie1 = find_ie ( num , ies1 , len1 ) ; const u8 * ie2 = find_ie ( num , ies2 , len2 ) ; int r ; if ( ! ie1 && ! ie2 ) return 0 ; <START_VULN> if ( ! ie1 ) <END_VULN> return - 1 ; r = memcmp ( ie1 + 2 , ie2 + 2 , min ( ie1 [ 1 ] , ie2 [ 1 ] ) ) ; if ( r == 0 && ie1 [ 1 ] != ie2 [ 1 ] ) return ie2 [ 1 ] - ie1 [ 1 ] ; return r ; }
die ( "Weird page fault" , regs , SIGSEGV ) ; } <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <END_VULN>
OpenSSL_add_all_algorithms ( ) ; #endif <START_VULN> while ( ( ch = getopt ( ac , av , "cDdksE : a : t : " ) ) != - 1 ) { <END_VULN> switch ( ch ) { case 'E' : fingerprint_hash = ssh_digest_alg_by_name ( optarg ) ;
const char * aPropertyName , const char * anInterfaceName , PRBool aForceReport ) ; private : nsXPCWrappedJSClass ( ) ;
c = CUR_CHAR ( l ) ; } if ( ( in_space ) && ( normalize ) ) { <START_VULN> while ( buf [ len - 1 ] == 0x20 ) len -- ; <END_VULN> } buf [ len ] = 0 ; if ( RAW == ' < ' ) {
nameh2 = stringNew ( "" ) ; namev2 = stringNew ( "" ) ; } <START_VULN> snprintf ( buf , L_BUF_SIZE , <END_VULN> " { % d , % d , % d , " % s" , " % s" , " % s" , " % s" } , " , size , size1 , size2 , nameh1 , nameh2 , namev1 , namev2 ) ; sarrayAddString ( sa , buf , L_COPY ) ;
size_t extent ; <START_VULN> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <END_VULN> { memory = RelinquishMagickMemory ( memory ) ; return ( ( void * ) NULL ) ;
void CLASS foveon_dp_load_raw ( ) { unsigned c , roff [ 4 ] , row , col , diff ; <START_VULN> ushort huff [ 512 ] , vpred [ 2 ] [ 2 ] , hpred [ 2 ] ; <END_VULN> fseek ( ifp , 8 , SEEK_CUR ) ; foveon_huff ( huff ) ;
exit ( 1 ) ; } <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <END_VULN> fprintf ( stdout , "BT adapter is up" ) ; const btsock_interface_t * sock = bt_interface -> get_profile_interface ( BT_PROFILE_SOCKETS_ID ) ;
btif_hh_cb . device_num ++ ; <START_VULN> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <END_VULN> if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( " % s : Error : failed to open uhid , err : % s" , __FUNCTION__ , strerror ( errno ) ) ;
String getSelectedText ( ) ; bool gestureWillBegin ( const WebCore : : IntPoint & ) ; <START_VULN> void gestureDidScroll ( const WebCore : : IntSize & ) ; <END_VULN> void gestureDidEnd ( ) ; #endif #if ENABLE ( TILED_BACKING_STORE )
int independent_partitions ; int frame_corrupt_residual ; <START_VULN> vp8_decrypt_cb * decrypt_cb ; <END_VULN> void * decrypt_state ; } VP8D_COMP ;
r = sc_check_sw ( card , sm -> sw1 , sm -> sw2 ) ; if ( r == SC_SUCCESS ) { if ( exdata -> sm ) { <START_VULN> if ( 0 != decrypt_response ( card , sm -> resp , plain -> resp , & len ) ) <END_VULN> return SC_ERROR_CARD_CMD_FAILED ; } else {
using CopyOrMoveOption = FileSystemOperation : : CopyOrMoveOption ; using GetMetadataField = FileSystemOperation : : GetMetadataField ; <START_VULN> using OperationID = int ; <END_VULN> virtual ~ FileSystemOperationRunner ( ) ;
conn -> current_result = NULL ; } while ( 0 ) ; <START_VULN> conn -> m -> local_tx_end ( conn , this_func , result == NULL ? FAIL : PASS TSRMLS_CC ) ; <END_VULN> } DBG_RETURN ( result ) ; }
& cipher , & cipher_len , & module , & module_len ) == FAILURE ) { return ; } <START_VULN> <END_VULN> td = mcrypt_module_open ( cipher , cipher_dir_string , module , module_dir_string ) ; if ( td != MCRYPT_FAILED ) { RETVAL_LONG ( mcrypt_enc_get_block_size ( td ) ) ;
int ( * init ) ( bt_callbacks_t * callbacks ) ; <START_VULN> int ( * enable ) ( void ) ; <END_VULN> int ( * disable ) ( void ) ;
static png_bytep <START_VULN> store_image_row ( PNG_CONST png_store * ps , png_const_structp pp , int nImage , <END_VULN> png_uint_32 y ) { png_size_t coffset = ( nImage * ps -> image_h + y ) * ( ps -> cb_row + 5 ) + 2 ;
<START_VULN> static void _php_mb_regex_set_options ( OnigOptionType options , OnigSyntaxType * syntax , OnigOptionType * prev_options , OnigSyntaxType ** prev_syntax TSRMLS_DC ) <END_VULN> { if ( prev_options != NULL ) { * prev_options = MBREX ( regex_default_options ) ;
return ( KDC_ERR_MUST_USE_USER2USER ) ; } <START_VULN> if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) { <END_VULN> * status = "ANONYMOUS NOT ALLOWED" ; return ( KDC_ERR_POLICY ) ; }
void inheritFrom ( const SVGRenderStyle * ) ; void copyNonInheritedFrom ( const SVGRenderStyle * ) ; <START_VULN> StyleDifference diff ( const SVGRenderStyle * ) const ; <END_VULN> bool operator == ( const SVGRenderStyle & ) const ; bool operator != ( const SVGRenderStyle & o ) const { return ! ( * this == o ) ; }
ND_PRINT ( ( ndo , " ( length bogus , should be > = 4 ) " ) ) ; return len ; } <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <END_VULN> ND_PRINT ( ( ndo , " : Features : % u , PxP : % s , History : % u , #CTX - ID : % u" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? "Enabled" : "Disabled" ,
#define EHMER_OFFSET 16 #define EHMER_MAX 56 <START_VULN> static float tonemasks [ P_BANDS ] [ 6 ] [ EHMER_MAX ] = { <END_VULN> { { - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 62 , - 62 , - 65 , - 73 , - 69 , - 68 , - 68 , - 67 , - 70 , - 70 , - 72 , - 74 , - 75 , - 79 , - 79 , - 80 , - 83 , - 88 , - 93 , - 100 , - 110 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 } ,
Define SIXEL pixels . output = sixel_output_create ( image ) ; <START_VULN> sixel_pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns * image -> rows , 1 ) ; <END_VULN> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { ( void ) GetVirtualPixels ( image , 0 , y , image -> columns , 1 , exception ) ;
long vorbis_book_decodevs_add ( codebook * book , ogg_int32_t * a , <START_VULN> oggpack_buffer * b , int n , int point ) { <END_VULN> if ( book -> used_entries>0 ) { int step = nbook -> dim ; ogg_int32_t * v = book -> dec_buf ;
# define mp_uintmax_t unsigned long #endif <START_VULN> #define BUFFSIZE 256<END_VULN> #define MAX_PARAMETERS 128 #ifdef __AMIGA__
errmsg = "too many profiles" ; <START_VULN> if ( ! finished ) <END_VULN> png_crc_finish ( png_ptr , length ) ; png_ptr -> colorspace . flags |= PNG_COLORSPACE_INVALID ;
<START_VULN> bool OutputFasterPlayback ( uint8 * dest ) ; <END_VULN>
if ( unlikely ( req -> src != req -> dst ) ) { scatterwalk_start ( & dst_sg_walk , req -> dst ) ; dst = scatterwalk_map ( & dst_sg_walk ) ; } } else { src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ) ; if ( ! src ) return - ENOMEM ; <START_VULN> assoc = ( src + req -> cryptlen + auth_tag_len ) ; <END_VULN> scatterwalk_map_and_copy ( src , req -> src , 0 , req -> cryptlen , 0 ) ; scatterwalk_map_and_copy ( assoc , req -> assoc , 0 , req -> assoclen , 0 ) ; dst = src ; } aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ) ;
png_colorspace_sync_info ( png_ptr , info_ptr ) ; <START_VULN> if ( ! result ) <END_VULN> return ;
EXPECT_FALSE ( this -> SetCanonicalCookie ( cs , <START_VULN> base : : MakeUnique < CanonicalCookie> ( <END_VULN> "G" , "H" , http_foo_host , "unique" , base : : Time ( ) , base : : Time ( ) , base : : Time ( ) , false , true , CookieSameSite : : DEFAULT_MODE , COOKIE_PRIORITY_DEFAULT ) ,
#define VP9_ENCODER_VP9_SEGMENTATION_H_ #include "vp9commonvp9_blockd . h" <START_VULN> #include "vp9encodervp9_onyx_int . h"<END_VULN> #ifdef __cplusplus extern "C" {
extern const char kEnableAccessibilityTabSwitcher [ ] ; extern const char kEnableAppLink [ ] ; extern const char kEnableContextualSearch [ ] ; <START_VULN> extern const char kEnableContextualSearchNowOnTapBarIntegration [ ] ; <END_VULN> extern const char kEnableHostedMode [ ] ; extern const char kEnableHungRendererInfoBar [ ] ; extern const char kEnableVrShell [ ] ;
<START_VULN> #define UNP_RECIPROCAL ( alpha ) ( ( ( ( 0xffff * 0xff ) << 7 ) + ( alpha >> 1 ) ) alpha ) <END_VULN> static png_byte png_unpremultiply ( png_uint_32 component , png_uint_32 alpha ,
SPL_METHOD ( SplFileObject , next ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
JSTokenStream * ts ; JSPrincipals * principals ; jschar * collected_args , * cp ; <START_VULN> size_t arg_length , args_length ; <END_VULN> JSTokenType tt ; JSBool ok ;
if ( mbmi -> skip && is_inter_block ( mbmi ) ) return ; <START_VULN> <END_VULN>
explicit SkAutoTMalloc ( size_t count ) { <START_VULN> fPtr = count ? ( T * ) sk_malloc_flags ( count * sizeof ( T ) , SK_MALLOC_THROW ) : nullptr ; <END_VULN> } SkAutoTMalloc ( SkAutoTMalloc < T> && that ) : fPtr ( that . release ( ) ) { }
} } } <START_VULN> <END_VULN> if ( eval ) { zval v ;
MCRYPT_GET_TD_ARG if ( mcrypt_enc_is_block_algorithm ( pm -> td ) == 1 ) { <START_VULN> RETURN_TRUE<END_VULN> } else { RETURN_FALSE }
int channels = 0 ; int bit_depth = row_info -> bit_depth ; <START_VULN> if ( color_type & PNG_COLOR_MASK_COLOR ) <END_VULN> { shift [ channels ++ ] = bit_depth - sig_bits -> red ; shift [ channels ++ ] = bit_depth - sig_bits -> green ;
return object_common2 ( UNSERIALIZE_PASSTHRU , object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; } <START_VULN> #line 818 "extstandardvar_unserializer . c"<END_VULN> yy32 : yych = * ++ YYCURSOR ; if ( yych == ' + ' ) goto yy33 ;
if ( intern -> file_name ) { pnstr = spl_gen_private_prop_name ( spl_ce_SplFileInfo , "fileName" , sizeof ( "fileName" ) - 1 , & pnlen TSRMLS_CC ) ; spl_filesystem_object_get_path ( intern , & path_len TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( path_len && path_len < intern -> file_name_len ) { add_assoc_stringl_ex ( & zrv , pnstr , pnlen + 1 , intern -> file_name + path_len + 1 , intern -> file_name_len - ( path_len + 1 ) , 1 ) ; } else {
return ; } <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <END_VULN> { png_ptr -> num_trans = 0 ; return ;
nptrs = backtrace ( buffer , 100 ) ; if ( file_name ) { <START_VULN> fd = open ( file_name , O_WRONLY | O_APPEND | O_CREAT , 0644 ) ; <END_VULN> if ( str ) dprintf ( fd , " % s" , str ) ; backtrace_symbols_fd ( buffer , nptrs , fd ) ;
HDC mMemoryDC ; nsTransparencyMode mTransparencyMode ; #endif PRPackedBool mIsTopWidgetWindow ; PRPackedBool mHas3DBorder ; PRPackedBool mIsShiftDown ; PRPackedBool mIsControlDown ; PRPackedBool mIsAltDown ; <START_VULN> PRPackedBool mIsDestroying ; <END_VULN> PRPackedBool mIsVisible ; PRPackedBool mIsInMouseCapture ; PRPackedBool mIsInMouseWheelProcessing ; PRPackedBool mUnicodeWidget ; PRPackedBool mIsPluginWindow ; PRPackedBool mPainting ; char mLeadByte ;
char * sub_name ; int len ; char slash = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_UNIXPATHS ) ? '' : DEFAULT_SLASH ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
for ( i = left_contexts ; i < tx_size_in_blocks ; ++ i ) l [ i ] = 0 ; } else { <START_VULN> vpx_memset ( l , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <END_VULN> } }
exit ( 1 ) ; } <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <END_VULN> fprintf ( stdout , "BT adapter is up" ) ; int rc = bt_interface -> create_bond ( & bt_remote_bdaddr , 0 ) ;
static int open_unix_listener ( h2o_configurator_command_t * cmd , yoml_t * node , struct sockaddr_un * sa ) { struct stat st ; <START_VULN> int fd ; <END_VULN> struct passwd * owner = NULL , pwbuf ; char pwbuf_buf [ 65536 ] ; unsigned mode = UINT_MAX ;
int num_unknowns = png_get_unknown_chunks ( read_ptr , read_info_ptr , & unknowns ) ; <START_VULN> if ( num_unknowns ) <END_VULN> { png_set_unknown_chunks ( write_ptr , write_info_ptr , unknowns , num_unknowns ) ;
} #endif <START_VULN> #endif<END_VULN>
#ifndef VP9_ENCODER_VP9_COST_H_ #define VP9_ENCODER_VP9_COST_H_ <START_VULN> #include "vp9commonvp9_prob . h"<END_VULN> #ifdef __cplusplus extern "C" {
static void TraceBlackJS ( JSTracer * trc , void * data ) ; static void TraceGrayJS ( JSTracer * trc , void * data ) ; void TraceXPConnectRoots ( JSTracer * trc ) ; void AddXPConnectRoots ( nsCycleCollectionTraversalCallback & cb ) ; void UnmarkSkippableJSHolders ( ) ; static void GCCallback ( JSRuntime * rt , JSGCStatus status ) ; <START_VULN> static void FinalizeCallback ( JSFreeOp * fop , JSFinalizeStatus status ) ; <END_VULN> inline void AddVariantRoot ( XPCTraceableVariant * variant ) ; inline void AddWrappedJSRoot ( nsXPCWrappedJS * wrappedJS ) ; inline void AddObjectHolderRoot ( XPCJSObjectHolder * holder ) ; nsresult AddJSHolder ( void * aHolder , nsScriptObjectTracer * aTracer ) ; nsresult RemoveJSHolder ( void * aHolder ) ;
static void <START_VULN> perform_formatting_test ( png_store * volatile ps ) <END_VULN> { #ifdef PNG_TIME_RFC1123_SUPPORTED png_uint_32 id ; png_uint_32 w ; png_uint_32 h ;
l_int32 direction ) { char * selname ; <START_VULN> char combname [ L_BUF_SIZE ] ; <END_VULN> l_int32 i , nsels , sx , sy , found ; SEL * sel ;
if ( eventfd_read ( semaphore -> fd , & value ) == - 1 ) return false ; <START_VULN> if ( fcntl ( semaphore -> fd , F_SETFL , flags ) == - 1 ) <END_VULN> LOG_ERROR ( " % s unable to resetore flags for semaphore fd : % s" , __func__ , strerror ( errno ) ) ; return true ; }
else <START_VULN> #endif<END_VULN> if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_CSV ) && zend_hash_num_elements ( Z_ARRVAL_P ( intern -> u . file . current_zval ) ) == 1 ) { zval ** first = Z_ARRVAL_P ( intern -> u . file . current_zval ) -> pListHead -> pData ; <START_VULN> <END_VULN> return Z_TYPE_PP ( first ) == IS_STRING && Z_STRLEN_PP ( first ) == 0 ; } return zend_hash_num_elements ( Z_ARRVAL_P ( intern -> u . file . current_zval ) ) == 0 ;
if ( xd -> update_mb_segmentation_map ) { <START_VULN> vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; <END_VULN> for ( i = 0 ; i < MB_FEATURE_TREE_PROBS ; i ++ )
jpc_ms_dump ( ms , stderr ) ; } <START_VULN> if ( JAS_CAST ( ulong , jas_stream_tell ( tmpstream ) ) != ms -> len ) { <END_VULN> jas_eprintf ( "warning : trailing garbage in marker segment ( % ld bytes ) " , ms -> len - jas_stream_tell ( tmpstream ) ) ;
t_encode += ( t_stop - t_start ) ; t_start = t_stop ; #endif <START_VULN> #endif<END_VULN> #ifndef SINGLE_ROWBUF_ALLOC pngtest_debug2 ( "Freeing row buffer ( pass % d , y = % u ) " , pass , y ) ;
static JS_ALWAYS_INLINE REMatchState * CVE_2011_2998_ExecuteREBytecode ( REGlobalData * gData , REMatchState * x ) { REMatchState * result = NULL ; REBackTrackData * backTrackData ; jsbytecode * nextpc , * testpc ; REOp nextop ; RECapture * cap ; <START_VULN> REProgState * curState ; <END_VULN> const jschar * startcp ; size_t parenIndex , k ; size_t parenSoFar = 0 ; jschar matchCh1 , matchCh2 ; RECharSet * charSet ; JSBool anchor ; jsbytecode * pc = gData -> regexp -> program ; REOp op = ( REOp ) * pc ++ ;
else { cur_lang_tag = ecalloc ( 1 , strlen ( lang_tag ) + 1 ) ; <START_VULN> <END_VULN> result = strToMatch ( lang_tag , cur_lang_tag ) ; if ( result == 0 ) { efree ( cur_lang_tag ) ;
res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; if ( res ) <START_VULN> return res ; <END_VULN> res = register_netdevice ( hsr_dev ) ; if ( res )
ref_costs_single [ ALTREF_FRAME ] = 512 ; } if ( cm -> reference_mode != SINGLE_REFERENCE ) { <START_VULN> vp9_prob ref_comp_p = vp9_get_pred_prob_comp_ref_p ( cm , xd ) ; <END_VULN> unsigned int base_cost = vp9_cost_bit ( intra_inter_p , 1 ) ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT )
#include < vector> #include "baselogging . h" <START_VULN> #include "basemove . h"<END_VULN> #include "basestl_util . h"
~ IOHandler ( ) override ; void Wire ( UberDispatcher * dispatcher ) override ; <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) override ;
make_random_bytes ( seed , bytes , 4 ) ; } <START_VULN> #ifdef PNG_READ_SUPPORTED<END_VULN> static void randomize ( void * pv , size_t size ) {
else { vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ; <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <END_VULN> } q += 16 ;
} sock_cmd_t cmd = { CMD_ADD_FD , fd , type , flags , user_id } ; APPL_TRACE_DEBUG ( "adding fd : % d , flags : 0x % x" , fd , flags ) ; <START_VULN> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <END_VULN> } bool btsock_thread_remove_fd_and_close ( int thread_handle , int fd )
boolneedquotes ; <START_VULN> needquotes = false ; <END_VULN> for ( s = str ; * s ; s ++ ) { if ( ! ( ( * s > = 'a' && * s <= 'z' ) | | ( * s > = 'A' && * s <= 'Z' ) | |
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : residue backend 0 , 1 and 2 implementation <START_VULN> last mod : $ Id : res0 . c 16327 2009 - 07 - 24 00 : 49 : 25Z xiphmont $ <END_VULN>
return png_icc_profile_error ( png_ptr , colorspace , name , temp , "unexpected DeviceLink ICC profile class" ) ; <START_VULN> case 0x6E6D636C : <END_VULN> ( void ) png_icc_profile_error ( png_ptr , NULL , name , temp ,
static int CVE_2008_3915_init_state ( struct posix_acl_state * state , int cnt ) { int alloc ; memset ( state , 0 , sizeof ( struct posix_acl_state ) ) ; state -> empty = 1 ; alloc = sizeof ( struct posix_ace_state_array ) <START_VULN> + cnt * sizeof ( struct posix_ace_state ) ; <END_VULN> state -> users = kzalloc ( alloc , GFP_KERNEL ) ; if ( ! state -> users ) return - ENOMEM ; state -> groups = kzalloc ( alloc , GFP_KERNEL ) ; if ( ! state -> groups ) { kfree ( state -> users ) ; return - ENOMEM ; } return 0 ; }
#include "WrapperFactory . h" class nsIPrincipal ; namespace xpc { class AccessCheck { public : <START_VULN> static bool isSameOrigin ( JSCompartment * a , JSCompartment * b ) ; <END_VULN> static bool isChrome ( JSCompartment * compartment ) ; static bool callerIsChrome ( ) ; static nsIPrincipal * getPrincipal ( JSCompartment * compartment ) ; static bool isCrossOriginAccessPermitted ( JSContext * cx , JSObject * obj , jsid id , js : : Wrapper : : Action act ) ; static bool isSystemOnlyAccessPermitted ( JSContext * cx ) ; static bool isLocationObjectSameOrigin ( JSContext * cx , JSObject * wrapper ) ; static bool documentDomainMakesSameOrigin ( JSContext * cx , JSObject * obj ) ;
#ifdef PNG_READ_BACKGROUND_SUPPORTED static int image_transform_default_add ( image_transform * this , <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <END_VULN> { UNUSED ( colour_type ) UNUSED ( bit_depth )
void SetVolumePercent ( double volume_percent ) ; <START_VULN> <END_VULN> void AdjustVolumeByPercent ( double adjust_by_percent ) ;
@param list List pointer returned from mprCreateList . @param join String to use as the element join string . May be null . @ingroup MprList <START_VULN> @stability Evolving<END_VULN> PUBLIC char * mprListToString ( MprList * list , cchar * join ) ;
if ( ! sparc_perf_event_set_period ( event , hwc , idx ) ) continue ; <START_VULN> if ( perf_event_overflow ( event , 1 , & data , regs ) ) <END_VULN> sparc_pmu_stop ( event , 0 ) ; }
static int le_mcrypt ; <START_VULN> typedef struct _php_mcrypt { <END_VULN> MCRYPT td ; zend_bool init ; } php_mcrypt ;
const unsigned char * bufptr = br -> user_buffer ; VP8_BD_VALUE value = br -> value ; int count = br -> count ; <START_VULN> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <END_VULN> size_t bytes_left = br -> user_buffer_end - bufptr ; size_t bits_left = bytes_left * CHAR_BIT ; int x = ( int ) ( shift + CHAR_BIT - bits_left ) ;
seg -> enabled = 0 ; seg -> update_map = 0 ; seg -> update_data = 0 ; <START_VULN> vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ; <END_VULN> vp9_clearall_segfeatures ( seg ) ; }
ssize_t pathlen = 0 ; if ( node -> parent && node -> graft_path == NULL ) { <START_VULN> pathlen = get_node_path_locked ( node -> parent , buf , bufsize - namelen - 2 ) ; <END_VULN> if ( pathlen < 0 ) { return - 1 ; }
ND_PRINT ( ( ndo , " ( length bogus , should be = 6 ) " ) ) ; return len ; } <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <END_VULN> ND_PRINT ( ( ndo , " : Magic - Num 0x % 08x" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default :
for ( ITERATE_KEYS ( abilities , kp ) ) { mprSetJson ( job , " $ " , kp -> key ) ; } <START_VULN> mprSetJsonObj ( route -> config , "app . http . auth . auto . abilities" , job ) ; <END_VULN> } }
trimmedName = & sp -> name [ 1 ] ; } } <START_VULN> if ( ( dp = mprLookupJsonObj ( dest , trimmedName ) ) == 0 ) { <END_VULN> if ( pflags & MPR_JSON_COMBINE && sp -> type == MPR_JSON_OBJ ) { dp = mprCreateJson ( sp -> type ) ;
0 . 9999667820F , 0 . 9999720773F , 0 . 9999767136F , 0 . 9999807479F , 0 . 9999842344F , 0 . 9999872249F , 0 . 9999897688F , 0 . 9999919127F , 0 . 9999937009F , 0 . 9999951749F , 0 . 9999963738F , 0 . 9999973342F , 0 . 9999980900F , 0 . 9999986724F , 0 . 9999991103F , 0 . 9999994297F , 0 . 9999996543F , 0 . 9999998049F , 0 . 9999999000F , 0 . 9999999552F , 0 . 9999999836F , 0 . 9999999957F , 0 . 9999999994F , 1 . 0000000000F , } ; <START_VULN> static float vwin2048 [ 1024 ] = { <END_VULN> 0 . 0000009241F , 0 . 0000083165F , 0 . 0000231014F , 0 . 0000452785F , 0 . 0000748476F , 0 . 0001118085F , 0 . 0001561608F , 0 . 0002079041F , 0 . 0002670379F , 0 . 0003335617F , 0 . 0004074748F , 0 . 0004887765F , 0 . 0005774661F , 0 . 0006735427F , 0 . 0007770054F , 0 . 0008878533F , 0 . 0010060853F , 0 . 0011317002F , 0 . 0012646969F , 0 . 0014050742F , 0 . 0015528307F , 0 . 0017079650F , 0 . 0018704756F , 0 . 0020403610F , 0 . 0022176196F , 0 . 0024022497F , 0 . 0025942495F , 0 . 0027936173F , 0 . 0030003511F , 0 . 0032144490F , 0 . 0034359088F , 0 . 0036647286F ,
@param join String to use as the element join string . @return String consisting of the joined hash keys @ingroup MprHash <START_VULN> @stability Evolving<END_VULN> PUBLIC char * mprHashKeysToString ( MprHash * hash , cchar * join ) ;
bool AssociateForeignSpecifics ( const sync_pb : : SessionSpecifics & specifics , <START_VULN> const base : : Time & modification_time ) ; <END_VULN> void DisassociateForeignSession ( const std : : string & foreign_session_tag ) ;
ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; } pixels_length = height * bytes_per_line ; <START_VULN> sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( pixels_length , <END_VULN> sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) {
<START_VULN> return mutt_bcache_del ( bcache , id ) ; <END_VULN> } #ifdef USE_HCACHE
png_colorspace_sync_info ( png_ptr , info_ptr ) ; } #endif <START_VULN> #endif<END_VULN> #ifdef PNG_COLORSPACE_SUPPORTED
#include < string . h> #include "allheaders . h" <START_VULN> static const l_int32 L_BUF_SIZE = 256 ; <END_VULN> static const l_int32 INITIAL_PTR_ARRAYSIZE = 50 ; static const l_int32 MANY_SELS = 1000 ;
continue ; } <START_VULN> if ( verify_vc_kbmode ( fd_d ) < 0 ) <END_VULN> continue ; toggle_utf8 ( ttyname , fd_d , utf8 ) ;
continue ; thissad = vfp -> sdf ( what -> buf , what -> stride , get_buf_from_mv ( in_what , & this_mv ) , <START_VULN> in_what -> stride , bestsad ) ; <END_VULN> CHECK_BETTER } }
int retcode = 0 ; unsigned long insn ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <END_VULN> #ifdef DEBUG_MATHEMU printk ( "In do_mathemu ( ) . . . pc is % 08lx" , regs -> pc ) ;
#endif } else { current -> min_flt ++ ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <END_VULN> regs , address ) ; } up_read ( & mm -> mmap_sem ) ;
void PNGAPI png_set_invalid ( png_const_structrp png_ptr , png_inforp info_ptr , int mask ) { <START_VULN> if ( png_ptr && info_ptr ) <END_VULN> info_ptr -> valid &= ~ mask ; }
q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; <START_VULN> if ( q > e ) { <END_VULN> DPRINTF ( ( "Ran of the end % p > % p" , q , e ) ) ; goto out ; }
#include "basemacros . h" #include "contentpublicbrowserdevtools_frontend_host . h" #include "mojopubliccppbindingsassociated_binding . h" <START_VULN> #include "third_partyblinkpublicmojomdevtoolsdevtools_frontend . mojom . h"<END_VULN> namespace content {
private : friend class base : : RefCountedThreadSafe < PlatformSensor> ; <START_VULN> const mojo : : ScopedSharedBufferMapping shared_buffer_mapping_ ; <END_VULN> std : : unique_ptr < SensorReadingSharedBufferReader> shared_buffer_reader_ ; mojom : : SensorType type_ ; ConfigMap config_map_ ;
ZVAL_DOUBLE ( * rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ; return 1 ; } <START_VULN> #line 1068 "extstandardvar_unserializer . c"<END_VULN> yy65 : yych = * ++ YYCURSOR ; if ( yych <= ' , ' ) {
unsigned char * buf ; <START_VULN> if ( chunk_num > chm -> num_chunks ) return NULL ; <END_VULN> if ( ! chm -> chunk_cache ) {
v = gamma_to_1 [ * sp ] ; png_composite ( w , v , a , png_ptr -> background_1 . gray ) ; <START_VULN> if ( ! optimize ) <END_VULN> w = gamma_from_1 [ w ] ; * sp = w ; }
& parameters . subsampling_dx , & parameters . subsampling_dy ) ; property = GetImageProperty ( image , "comment" ) ; if ( property != ( const char * ) NULL ) <START_VULN> parameters . cp_comment = property ; <END_VULN> channels = 3 ; jp2_colorspace = OPJ_CLRSPC_SRGB ; if ( image -> colorspace == YUVColorspace )
} <START_VULN> if ( png_ptr -> colorspace . flags & PNG_COLORSPACE_INVALID ) <END_VULN> { png_crc_finish ( png_ptr , length ) ; return ;
<START_VULN> PUBLIC MprJson * mprLookupJsonObj ( MprJson * obj , cchar * name ) <END_VULN> { MprJson * child ; int i , index ;
TraceMonitor * tm = & JS_THREAD_DATA ( cx ) -> traceMonitor ; JS_ASSERT ( tm -> codeAlloc && tm -> dataAlloc && tm -> traceAlloc ) ; if ( bytes > 1 G ) bytes = 1 G ; if ( bytes < 128 K ) bytes = 128 K ; tm -> maxCodeCacheBytes = bytes ; } <START_VULN> void<END_VULN> InitJIT ( TraceMonitor * tm ) { #if defined JS_JIT_SPEW tm -> profAlloc = NULL ; if ( ! did_we_set_up_debug_logging ) { InitJITLogController ( ) ; did_we_set_up_debug_logging = true ; }
long dim ; long entries ; long used_entries ; const static_codebook * c ; <START_VULN> float * valuelist ; <END_VULN> ogg_uint32_t * codelist ; int * dec_index ; char * dec_codelengths ; ogg_uint32_t * dec_firsttable ; int dec_firsttablen ; int dec_maxlength ;
#include "googleurlsrcgurl . h" #include "third_partynpapibindingsnpapi . h" <START_VULN> class MessageLoop ; <END_VULN> namespace webkit_glue { class WebPlugin ; } namespace NPAPI
return false ; } <START_VULN> if ( mount ( dirname , cgpath , "none" , MS_BIND , 0 ) ) { <END_VULN> SYSERROR ( "Failed to bind mount % s to % s" , dirname , cgpath ) ; return false ; }
#define VP9_COMMON_VP9_SCALE_H_ #include "vp9commonvp9_mv . h" <START_VULN> #include "vp9commonvp9_convolve . h"<END_VULN> #ifdef __cplusplus extern "C" {
} <START_VULN> class ScopedZxHandle<END_VULN> : public ScopedGeneric < zx_handle_t , internal : : ScopedZxHandleTraits> { public : ScopedZxHandle ( ) = default ;
if ( ( ( avail & codemask ) == 0 ) && ( avail < 4096 ) ) { codesize ++ ; codemask += avail ; } } oldcode = incode ; do { <START_VULN> * rowp ++ = * -- stackp ; <END_VULN> if ( rowp == rowend ) OUTPUT_ROW ( ) ; } while ( stackp > stack ) ; } } END : mGIFStruct . avail = avail ;
init_validate_info ( validate_info * vi , gamma_display * dp , png_const_structp pp , int in_depth , int out_depth ) { <START_VULN> PNG_CONST unsigned int outmax = ( 1U << out_depth ) - 1 ; <END_VULN> vi -> pp = pp ; vi -> dp = dp ;
<START_VULN> class LogMessageVoidify { <END_VULN> public : LogMessageVoidify ( ) { }
( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ( neighbors [ j ] . row ) * in_what_stride + neighbors [ j ] . col + best_address ; <START_VULN> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <END_VULN> if ( thissad < bestsad ) {
#if CHAR_BIT == 8 && UCHAR_MAX == 255 typedef unsigned char png_byte ; #else <START_VULN> # error "libpng requires 8 bit bytes"<END_VULN> #endif #if INT_MIN == - 32768 && INT_MAX == 32767
OfflineLoadPage ( TabContents * tab_contents , const GURL & url , Delegate * delegate ) ; <START_VULN> virtual ~ OfflineLoadPage ( ) { } <END_VULN> void EnableTest ( ) {
next_image -> depth = 16 ; monochrome = IsMonochromeImage ( image , & image -> exception ) && ( image -> depth == 1 ) ? MagickTrue : MagickFalse ; <START_VULN> quantum_info = AcquireQuantumInfo ( image_info , image ) ; <END_VULN> if ( quantum_info == ( QuantumInfo * ) NULL ) return ( 0 ) ; pixels = GetQuantumPixels ( quantum_info ) ;
} fname = Z_STRVAL_P ( value ) ; <START_VULN> fname_len = ( php_stat_len ) Z_STRLEN_P ( value ) ; <END_VULN> phar_spl_fileinfo : if ( base_len ) {
else { double samples = 3 . 0 2 * cpi -> count * <START_VULN> lst_yv12 -> y_width * lst_yv12 -> y_height ; <END_VULN> double total_psnr = vpx_sse_to_psnr ( samples , 255 . 0 , cpi -> total_sq_error ) ; double total_psnr2 = vpx_sse_to_psnr ( samples , 255 . 0 ,
make_four_random_bytes ( store_seed , mark ) ; } <START_VULN> #ifdef PNG_READ_SUPPORTED<END_VULN>
case 0 : op [ 0 ] = ( unsigned char ) ( ( v ) << 6 ) ; break ; case 1 : op [ 0 ] |= ( v ) << 4 ; break ; case 2 : op [ 0 ] |= ( v ) << 2 ; break ; <START_VULN> case 3 : * op ++ |= ( v ) ; break ; <END_VULN> } }
) { <START_VULN> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , FData2 , 24 * 24 ) ; <END_VULN> if ( xoffset ) {
} } } <START_VULN> #endif<END_VULN> #ifndef PNG_STDIO_SUPPORTED
if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) ERROR ( "rc_twopass_stats_in . sz indicates truncated packet . " ) ; <START_VULN> if ( cfg -> ss_number_layers > 1 ) { <END_VULN> int i ; unsigned int n_packets_per_layer [ VPX_SS_MAX_LAYERS ] = { 0 } ;
static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , <START_VULN> vp8_decrypt_cb * decrypt_cb , <END_VULN> void * decrypt_state ) { vpx_codec_err_t res = VPX_CODEC_OK ;
php_stream_seek ( fp , sizeof ( phar_zip_file_header ) + entry . header_offset + entry . filename_len + PHAR_GET_16 ( zipentry . extra_len ) , SEEK_SET ) ; sig = ( char * ) emalloc ( entry . uncompressed_filesize ) ; read = php_stream_read ( fp , sig , entry . uncompressed_filesize ) ; <START_VULN> if ( read != entry . uncompressed_filesize ) { <END_VULN> php_stream_close ( sigfile ) ; efree ( sig ) ; PHAR_ZIP_FAIL ( "signature cannot be read" ) ;
#if 0 trunc : <START_VULN> ND_PRINT ( ( ndo , " [ | truncated ] " ) ) ; <END_VULN> return ; #endif
phar_obj -> arc . archive -> ufp = pass . fp ; phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } } else {
js : : gc : : MarkStringUnbarriered ( trc , & d . u1 . left , "left child" ) ; js : : gc : : MarkStringUnbarriered ( trc , & d . s . u2 . right , "right child" ) ; } JS_ALWAYS_INLINE void JSDependentString : : init ( JSLinearString * base , const jschar * chars , size_t length ) { JS_ASSERT ( ! js : : IsPoisonedPtr ( base ) ) ; <START_VULN> d . lengthAndFlags = buildLengthAndFlags ( length , DEPENDENT_BIT ) ; <END_VULN> d . u1 . chars = chars ; d . s . u2 . base = base ; JSString : : writeBarrierPost ( d . s . u2 . base , & d . s . u2 . base ) ; } JS_ALWAYS_INLINE JSDependentString * JSDependentString : : new_ ( JSContext * cx , JSLinearString * base_ , const jschar * chars , size_t length ) {
( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } <START_VULN> bufp += bytes_read ; <END_VULN> } return 1 ;
return FAILURE ; } <START_VULN> if ( strcmp ( key_name , LOC_LANG_TAG ) != 0 && <END_VULN> strcmp ( key_name , LOC_GRANDFATHERED_LANG_TAG ) != 0 ) { smart_str_appendl ( loc_name , SEPARATOR , sizeof ( SEPARATOR ) - 1 ) ;
NSS_CMSSignerInfo_Sign ( NSSCMSSignerInfo * signerinfo , SECItem * digest , SECItem * contentType ) { CERTCertificate * cert ; SECKEYPrivateKey * privkey = NULL ; SECOidTag digestalgtag ; SECOidTag pubkAlgTag ; SECItem signature = { 0 } ; SECStatus rv ; <START_VULN> PLArenaPool * poolp , * tmppoolp ; <END_VULN> SECAlgorithmID * algID , freeAlgID ; CERTSubjectPublicKeyInfo * spki ; PORT_Assert ( digest != NULL ) ; poolp = signerinfo -> cmsg -> poolp ; switch ( signerinfo -> signerIdentifier . identifierType ) {
printf ( "DEVNAME = % s" , devname ) ; fputs ( name , stdout ) ; fputs ( " = " , stdout ) ; <START_VULN> safe_print ( value , valsz , NULL ) ; <END_VULN> fputs ( "" , stdout ) ; } else {
<START_VULN> else if ( ! png_sRGB_checks [ i ] . have_md5 ) <END_VULN> { png_chunk_report ( png_ptr , "out - of - date sRGB profile with no signature" ,
" SKP : The chunk was skipped because of a zlib issue ( zlib - rc ) with" , " explanation 'message'" , " ERR : The read of the file was aborted . The parameters explain why . " , <START_VULN> " $ 3 status : For 'ERR' the accumulate status code from 'EXIT CODES' above . " , <END_VULN> " This is printed as a 2 digit hexadecimal value" , " comp - level : The recorded compression level ( FLEVEL ) of a zlib stream" , " expressed as a string { supfast , stdfast , default , maximum } " ,
return NULL ; <START_VULN> ascii = malloc ( str_len ) ; <END_VULN> for ( ; idx < str_len ; ++ idx ) { hex_buf [ 0 ] = str [ idx ++ ] ;
png_debug1 ( 1 , "in % s retrieval function" , "gAMA ( float ) " ) ; if ( png_ptr != NULL && info_ptr != NULL && <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_GAMMA ) && <END_VULN> file_gamma != NULL ) { * file_gamma = png_float ( png_ptr , info_ptr -> colorspace . gamma ,
_y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; <START_VULN> _y4m -> vpx_bps = 32 ; <END_VULN> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ;
for ( midx = 0 ; midx < INTER_MODES ; ++ midx ) bsi -> rdstat [ iy ] [ midx ] . brdcost = INT64_MAX ; bsi -> segment_rd = INT64_MAX ; <START_VULN> return ; <END_VULN> } } }
char * guestfs___first_line_of_file ( guestfs_h * g , const char * filename ) { <START_VULN> CLEANUP_FREE char ** lines = NULL ; <END_VULN> int64_t size ; char * ret ;
void vpx_img_free ( vpx_image_t * img ) { if ( img ) { if ( img -> img_data && img -> img_data_owner ) <START_VULN> img_buf_free ( img -> img_data ) ; <END_VULN> if ( img -> self_allocd ) free ( img ) ;
load_fake ( png_charp param , png_bytepp profile ) { char * endptr = NULL ; <START_VULN> unsigned long long int size = strtoull ( param , & endptr , 0 ) ; <END_VULN> if ( endptr != NULL && * endptr == ' * ' )
const char * ylabel ) { char * newroot ; <START_VULN> char buf [ L_BUF_SIZE ] ; <END_VULN> l_int32 badchar ; GPLOT * gplot ;
* result_len = 0 ; start_offset = 0 ; PCRE_G ( error_code ) = PHP_PCRE_NO_ERROR ; <START_VULN> <END_VULN> while ( 1 ) { count = pcre_exec ( pce -> re , extra , subject , subject_len , start_offset ,
buf [ ME_MAX_FNAME ] = '0' ; if ( buf [ 0 ] == '#' && buf [ 1 ] == ' ! ' ) { cp = start = & buf [ 2 ] ; <START_VULN> cmdShell = stok ( & buf [ 2 ] , "r" , & tok ) ; <END_VULN> if ( ! mprIsPathAbs ( cmdShell ) ) { If we cannot access the command shell and the command is not an absolute path ,
} ; <START_VULN> if ( colorspace -> flags & PNG_COLORSPACE_INVALID ) <END_VULN> return 0 ;
<START_VULN> explicit ScopedGenericObj ( C p = NULL ) : obj_ ( p ) { } <END_VULN> ~ ScopedGenericObj ( ) {
send_cookie = 0 ; } <START_VULN> if ( ! PS ( id ) && <END_VULN> zend_hash_find ( & EG ( symbol_table ) , "_POST" , sizeof ( "_POST" ) , ( void ** ) & data ) == SUCCESS && Z_TYPE_PP ( data ) == IS_ARRAY &&
} if ( up ) { <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <END_VULN> fprintf ( stdout , "BT adapter is up" ) ; fprintf ( stdout , "Waiting for % d seconds" , timeout_in_sec ) ;
vp8_default_coef_probs ( & cpi -> common ) ; <START_VULN> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <END_VULN> { int flag [ 2 ] = { 1 , 1 } ; vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cpi -> common . fc . mvc , flag ) ;
size_t mjitDataSize ; #endif <START_VULN> bool inOOMReport ; <END_VULN> #if defined ( MOZ_GCTIMER ) | | defined ( JSGC_TESTPILOT ) struct GCData { uint64 firstEnter ; bool firstEnterValid ;
class nsJPEGDecoder : public Decoder { public : nsJPEGDecoder ( RasterImage & aImage , Decoder : : DecodeStyle aDecodeStyle ) ; virtual ~ nsJPEGDecoder ( ) ; virtual void InitInternal ( ) ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal ( ) ; virtual Telemetry : : ID SpeedHistogram ( ) ; void NotifyDone ( ) ; protected : Orientation ReadOrientationFromEXIF ( ) ; void OutputScanlines ( bool * suspend ) ;
public : bool Equals ( const nsSMILInstanceTime * aElem1 , const nsSMILInstanceTime * aElem2 ) const ; bool LessThan ( const nsSMILInstanceTime * aElem1 , const nsSMILInstanceTime * aElem2 ) const ; } ; struct NotifyTimeDependentsParams { <START_VULN> nsSMILInterval * mCurrentInterval ; <END_VULN> nsSMILTimeContainer * mTimeContainer ; } ; template < class TestFunctor> void RemoveInstanceTimes ( InstanceTimeList & aArray , TestFunctor & aTest ) ;
register jpc_fix_t * dstptr ; register int n ; register int m ; <START_VULN> int hstartcol ; <END_VULN> if ( bufsize > QMFB_SPLITBUFSIZE ) {
STATE_UNINITIALIZED , STATE_INITIALIZED , STATE_CHECKING , STATE_DOWNLOADING , STATE_CANCELLED , STATE_FINISHED } mState ; <START_VULN> nsOfflineCacheUpdateOwner * mOwner ; <END_VULN> bool mAddedItems ; bool mPartialUpdate ; bool mOnlyCheckUpdate ; bool mSucceeded ; bool mObsolete ; nsCString mUpdateDomain ;
int i ; for ( i = 0 ; i < svc -> number_spatial_layers ; ++ i ) { <START_VULN> struct twopass_rc * const twopass = & svc -> layer_context [ i ] . twopass ; <END_VULN> svc -> spatial_layer_id = i ; vp9_init_second_pass ( cpi ) ;
png_pass_ystart [ png_ptr -> pass ] ) png_pass_yinc [ png_ptr -> pass ] ; <START_VULN> if ( png_ptr -> transformations & PNG_INTERLACE ) <END_VULN> break ; } while ( png_ptr -> usr_width == 0 | | png_ptr -> num_rows == 0 ) ;
@description Suspend the current thread until the application is shutting down . @param timeout Timeout to wait for shutdown . @ingroup MprDispatcher <START_VULN> @stability Prototype<END_VULN> PUBLIC void mprSuspendThread ( MprTicks timeout ) ;
Z_PARAM_PATH ( filename , filename_len ) ZEND_PARSE_PARAMETERS_END ( ) ; <START_VULN> php_stat ( filename , ( php_stat_len ) filename_len , funcnum , return_value ) ; <END_VULN> }
if ( optslen > plen ) { <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <END_VULN> nh = * pkt ;
yych = * ++ YYCURSOR ; if ( yych != '"' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 708 "extstandardvar_unserializer . re"<END_VULN> { size_t len , len2 , len3 , maxlen ; long elements ;
cur ++ ; } if ( uri != NULL ) <START_VULN> uri -> port = port & INT_MAX ; <END_VULN> * str = cur ; return ( 0 ) ; }
<START_VULN> if ( keep ) <END_VULN> { new_list = png_voidcast ( png_bytep , png_malloc ( png_ptr , 5 * ( num_chunks + old_num_chunks ) ) ) ;
efree ( error ) ; goto valid_alias ; } <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; RETURN_FALSE ; }
png_const_bytep row = png_voidcast ( png_const_bytep , display -> buffer ) ; ptrdiff_t row_bytes = display -> row_stride ; <START_VULN> if ( linear ) <END_VULN> row_bytes *= ( sizeof ( png_uint_16 ) ) ; if ( row_bytes < 0 )
jsval * rval ) ; JS_REQUIRES_STACK JSRecordingStatus newString ( JSObject * ctor , uint32 argc , jsval * argv , jsval * rval ) ; JS_REQUIRES_STACK JSRecordingStatus interpretedFunctionCall ( jsval & fval , JSFunction * fun , uintN argc , bool constructing ) ; JS_REQUIRES_STACK void propagateFailureToBuiltinStatus ( nanojit : : LIns * ok_ins , nanojit : : LIns * & status_ins ) ; JS_REQUIRES_STACK JSRecordingStatus emitNativeCall ( JSSpecializedNative * sn , uintN argc , <START_VULN> nanojit : : LIns * args [ ] ) ; <END_VULN> JS_REQUIRES_STACK void emitNativePropertyOp ( JSScope * scope , JSScopeProperty * sprop , nanojit : : LIns * obj_ins , bool setflag , nanojit : : LIns * boxed_ins ) ; JS_REQUIRES_STACK JSRecordingStatus callSpecializedNative ( JSNativeTraceInfo * trcinfo , uintN argc , bool constructing ) ; JS_REQUIRES_STACK JSRecordingStatus callNative ( uintN argc , JSOp mode ) ;
PHP_FUNCTION ( mcrypt_module_is_block_algorithm ) { MCRYPT_GET_MODE_DIR_ARGS ( algorithms_dir ) <START_VULN> <END_VULN> if ( mcrypt_module_is_block_algorithm ( module , dir ) == 1 ) { RETURN_TRUE ; } else {
private : <START_VULN> PasswordAccessoryController * controller_ ; <END_VULN> base : : android : : ScopedJavaGlobalRef < jobject> java_object_ ;
char * sb ; char * req = NULL ; struct printparam pp ; <START_VULN> int contentlen = 0 ; <END_VULN> int isform = 0 ; pp . inbuf = 0 ;
return ; trunc : <START_VULN> ND_PRINT ( ( ndo , " [ | truncated ] " ) ) ; <END_VULN> return ; tooshort :
SPL_METHOD ( DirectoryIterator , getFilename ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
yych = * ++ YYCURSOR ; if ( yych != '"' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 642 "extstandardvar_unserializer . re"<END_VULN> { size_t len , maxlen ; char * str ;
m_pos += 8 ; } while ( op < oe ) ; op = oe ; <START_VULN> if ( HAVE_IP ( 6 ) ) { <END_VULN> state = next ; COPY4 ( op , ip ) ; op += next ;
BTIF_TRACE_ERROR ( "Received HW Error . " ) ; btif_config_flush ( ) ; <START_VULN> usleep ( 100000 ) ; <END_VULN> kill ( getpid ( ) , SIGKILL ) ; break ;
while ( png_ptr -> zstream . avail_in > 0 && <START_VULN> ! ( png_ptr -> flags & PNG_FLAG_ZSTREAM_ENDED ) ) <END_VULN> { int ret ;
#include "vpxvpx_codec . h" <START_VULN> static const char * const cfg = " -- target = mips32 - linux - gcc -- enable - dspr2 -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
get_trust_val ( trust , valstr , sizeof valstr ) ; PR_LOG ( modlog , 4 , ( fmt_s_s_d , atype , valstr , attr -> ulValueLen ) ) ; break ; } case CKA_KEY_TYPE : if ( attr -> ulValueLen > 0 && attr -> pValue ) { CK_KEY_TYPE keyType = * ( ( CK_KEY_TYPE * ) attr -> pValue ) ; <START_VULN> get_obj_class ( keyType , valstr , sizeof valstr ) ; <END_VULN> PR_LOG ( modlog , 4 , ( fmt_s_s_d , atype , valstr , attr -> ulValueLen ) ) ; break ; } case CKA_LABEL : case CKA_NETSCAPE_EMAIL : case CKA_NETSCAPE_URL : if ( attr -> ulValueLen > 0 && attr -> pValue ) {
kSqrt = ( 12 << 8 ) + 26 , kDup = ( 12 << 8 ) + 27 , kExch = ( 12 << 8 ) + 28 , kIndex = ( 12 << 8 ) + 29 , kRoll = ( 12 << 8 ) + 30 , kHFlex = ( 12 << 8 ) + 34 , kFlex = ( 12 << 8 ) + 35 , kHFlex1 = ( 12 << 8 ) + 36 , <START_VULN> kFlex1 = ( 12 << 8 ) + 37 , <END_VULN> } ; } #endif
ext = strrchr ( szName , ' . ' ) ; if ( ext && strlen ( ext ) > 19 ) ext = NULL ; <START_VULN> if ( ext && strlen ( ext ) > 1 ) { <END_VULN> strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; #ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS
perf_event_header__init_id ( & throttle_event . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , <START_VULN> throttle_event . header . size , 1 , 0 ) ; <END_VULN> if ( ret ) return ;
{ struct crypto_report_cipher rcipher ; <START_VULN> snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , " % s" , "cipher" ) ; <END_VULN> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ;
gplot -> plotstyles = numaReadStream ( fp ) ; ignore = fscanf ( fp , "Number of plots : % d" , & gplot -> nplots ) ; <START_VULN> ignore = fscanf ( fp , "Output file name : % s" , buf ) ; <END_VULN> stringReplace ( & gplot -> outname , buf ) ; ignore = fscanf ( fp , "Axis scaling : % d" , & gplot -> scaling ) ;
{ png_debug ( 1 , "in png_set_expand" ) ; <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <END_VULN> return ; png_ptr -> transformations |= ( PNG_EXPAND | PNG_EXPAND_tRNS ) ;
png_colorspace_set_rgb_coefficients ( png_structrp png_ptr ) { <START_VULN> if ( ! png_ptr -> rgb_to_gray_coefficients_set && <END_VULN> ( png_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) != 0 ) {
static void spl_filesystem_dir_it_rewind ( zend_object_iterator * iter TSRMLS_DC ) { spl_filesystem_object * object = spl_filesystem_iterator_to_object ( ( spl_filesystem_iterator * ) iter ) ; <START_VULN> <END_VULN> object -> u . dir . index = 0 ; if ( object -> u . dir . dirp ) { php_stream_rewinddir ( object -> u . dir . dirp ) ;
# define PNG_ARM_NEON_IMPLEMENTATION 2 # endif <START_VULN> # endif<END_VULN> # ifndef PNG_ARM_NEON_IMPLEMENTATION
void vp9_set_segment_data ( struct segmentation * seg , signed char * feature_data , unsigned char abs_delta ) ; <START_VULN> void vp9_choose_segmap_coding_method ( VP9_COMP * cpi ) ; <END_VULN> void vp9_reset_segment_features ( struct segmentation * seg ) ;
{ public : static JSBool GetCallingLocation ( JSContext * aContext , const char * * aFilename , <START_VULN> PRUint32 * aLineno ) ; <END_VULN> static jsval ConvertStringToJSVal ( const nsString & aProp , JSContext * aContext ) ;
switch ( ( state & PNG_FP_STATE ) + ( type & PNG_FP_SAW_ANY ) ) { case PNG_FP_INTEGER + PNG_FP_SAW_SIGN : <START_VULN> if ( state & PNG_FP_SAW_ANY ) <END_VULN> goto PNG_FP_End ; png_fp_add ( state , type ) ;
g_free ( strmbuf ) ; g_free ( compr ) ; g_free ( uncompr ) ; return NULL ; } } else { inflateEnd ( strm ) ; g_free ( strm ) ; g_free ( strmbuf ) ; <START_VULN> g_free ( compr ) ; <END_VULN> if ( uncompr == NULL ) { return NULL ; } break ; } } #ifdef TVB_Z_DEBUG printf ( "inflate ( ) total passes : % u" , inflate_passes ) ; printf ( "bytes in : % ubytes out : % u" , bytes_in , bytes_out ) ;
if ( ! ( ppm -> data = jas_malloc ( ppm -> len ) ) ) { goto error ; } <START_VULN> if ( JAS_CAST ( uint , jas_stream_read ( in , ppm -> data , ppm -> len ) ) != ppm -> len ) { <END_VULN> goto error ; } } else {
LayoutPoint pagination_offset ; LayoutUnit logical_top_in_flow_thread ; std : : unique_ptr < ObjectPaintProperties> paint_properties ; <START_VULN> std : : unique_ptr < RefCountedPropertyTreeState> local_border_box_properties ; <END_VULN> bool is_clip_path_cache_valid = false ; base : : Optional < IntRect> clip_path_bounding_box ; scoped_refptr < const RefCountedPath> clip_path_path ;
struct ssl_connect_data * connssl = ( struct ssl_connect_data * ) arg ; struct Curl_easy * data = connssl -> data ; const char * nickname = connssl -> client_nickname ; if ( connssl -> obj_clicert ) { <START_VULN> static const char pem_slotname [ ] = "PEM Token #1" ; <END_VULN> SECItem cert_der = { 0 , NULL , 0 } ; void * proto_win = SSL_RevealPinArg ( sock ) ; struct CERTCertificateStr * cert ;
if ( alpha ) { if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , colorchannels ) , <START_VULN> pa , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <END_VULN> && img -> stoponerr ) { ret = 0 ;
oggpack_write ( opb , ci -> mode_param [ i ] -> transformtype , 16 ) ; oggpack_write ( opb , ci -> mode_param [ i ] -> mapping , 8 ) ; } oggpack_write ( opb , 1 , 1 ) ; return ( 0 ) ; err_out : return ( - 1 ) ; <START_VULN> } <END_VULN> int vorbis_commentheader_out ( vorbis_comment * vc , ogg_packet * op ) { oggpack_buffer opb ; oggpack_writeinit ( & opb ) ; if ( _vorbis_pack_comment ( & opb , vc ) ) return OV_EIMPL ;
Node ** array = reinterpret_cast < Node ** > ( self ) ; blink : : HeapObjectHeader * header = blink : : HeapObjectHeader : : fromPayload ( self ) ; <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <END_VULN> size_t length = header -> payloadSize ( ) sizeof ( Node * ) ; for ( size_t i = 0 ; i < length ; ++ i ) { if ( ! HashTableHelper < Node * , typename Table : : ExtractorType ,
png_ptr -> flags |= PNG_FLAG_ROW_INIT ; } <START_VULN> #endif<END_VULN>
flags |= IS_RDONLY ( d_inode ( lower_dentry ) ) ? O_RDONLY : O_RDWR ; ( * lower_file ) = dentry_open ( & req . path , flags , cred ) ; if ( ! IS_ERR ( * lower_file ) ) <START_VULN> goto out ; <END_VULN> if ( ( flags & O_ACCMODE ) == O_RDONLY ) { rc = PTR_ERR ( ( * lower_file ) ) ; goto out ;
virtual void DidFinishLoadWithReason ( const GURL & url , NPReason reason , <START_VULN> intptr_t notify_data ) = 0 ; <END_VULN> virtual int GetProcessId ( ) = 0 ;
ZVAL_STRINGL ( * rval , str , len , 0 ) ; return 1 ; } <START_VULN> #line 917 "extstandardvar_unserializer . c"<END_VULN> yy46 : yych = * ++ YYCURSOR ; if ( yych == ' + ' ) goto yy47 ;
if ( zend_parse_parameters ( argc TSRMLS_CC , "z | ss" , & arg_str , & arg_pattern , & arg_pattern_len , & arg_options , & arg_options_len ) == FAILURE ) { return ; } <START_VULN> <END_VULN> if ( argc > 1 && arg_pattern_len == 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Empty pattern" ) ; RETURN_FALSE ;
for a value . Note : all values are stored as strings . @return JSON object @ingroup MprJson <START_VULN> @stability Prototype<END_VULN> PUBLIC MprJson * mprCreateJson ( int type ) ;
for ( i = 0 ; i < cmap_entries ; ++ i ) { <START_VULN> if ( do_background && i < num_trans && trans [ i ] < 255 ) <END_VULN> { if ( trans [ i ] == 0 ) png_create_colormap_entry ( display , i , back_r , back_g ,
if ( ( png_uint_16 ) ( ( * sp >> shift ) & 0x0f ) == png_ptr -> trans_color . gray ) { <START_VULN> unsigned int tmp = * sp & ( 0xf0f >> ( 4 - shift ) ) ; <END_VULN> tmp |= png_ptr -> background . gray << shift ; * sp = ( png_byte ) ( tmp & 0xff ) ; }
if ( s -> q_seq ) for ( i = 1 ; i < s -> dim ; i ++ ) <START_VULN> v [ i ] += v [ i - 1 ] ; <END_VULN> } return 0 ;
#ifndef VPX_VP8CX_H_ #define VPX_VP8CX_H_ <START_VULN> <END_VULN> #include " . vp8 . h"
if ( chunk -> size != 9 ) return ( - 1 ) ; <START_VULN> if ( ! set_location ( png_ptr , my_user_chunk_data , have_vpAg ) ) <END_VULN> return ( 0 ) ; my_user_chunk_data -> vpAg_width = png_get_uint_31 ( png_ptr , chunk -> data ) ;
Z_TYPE_P ( return_value ) = IS_NULL ; return NULL ; } <START_VULN> <END_VULN> if ( spl_filesystem_file_open ( intern , use_include_path , 0 TSRMLS_CC ) == FAILURE ) { zend_restore_error_handling ( & error_handling TSRMLS_CC ) ; zval_dtor ( return_value ) ;
: public AutocompleteProvider , public history : : ShortcutsBackend : : ShortcutsBackendObserver { public : <START_VULN> ShortcutsProvider ( ACProviderListener * listener , Profile * profile ) ; <END_VULN>
png_free ( png_ptr , new_palette . entries ) ; } <START_VULN> #endif<END_VULN> #ifdef PNG_READ_tRNS_SUPPORTED void
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } }
SSL_TRC ( 3 , ( " % d : SSL3 [ % d ] : handle certificate_verify handshake" , SSL_GETPID ( ) , ss -> fd ) ) ; PORT_Assert ( ss -> opt . noLocks | | ssl_HaveRecvBufLock ( ss ) ) ; PORT_Assert ( ss -> opt . noLocks | | ssl_HaveSSL3HandshakeLock ( ss ) ) ; isTLS = ( PRBool ) ( ss -> ssl3 . prSpec -> version > SSL_LIBRARY_VERSION_3_0 ) ; isTLS12 = ( PRBool ) ( ss -> ssl3 . prSpec -> version > = SSL_LIBRARY_VERSION_TLS_1_2 ) ; <START_VULN> if ( ss -> ssl3 . hs . ws != wait_cert_verify | | ss -> sec . peerCert == NULL ) { <END_VULN> desc = unexpected_message ; errCode = SSL_ERROR_RX_UNEXPECTED_CERT_VERIFY ; goto alert_loser ; } if ( isTLS12 ) { rv = ssl3_ConsumeSignatureAndHashAlgorithm ( ss , & b , & length , & sigAndHash ) ;
<START_VULN> class PassPlatformFile { <END_VULN> public : explicit PassPlatformFile ( PlatformFile * value ) : value_ ( value ) { }
} else { snprintf ( lbuf , llen , " % s [ name ] " , param ) ; } <START_VULN> if ( s && s > filename ) { <END_VULN> register_http_post_files_variable ( lbuf , s + 1 , http_post_files , 0 TSRMLS_CC ) ; } else { register_http_post_files_variable ( lbuf , filename , http_post_files , 0 TSRMLS_CC ) ;
spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; zend_class_entry * ce = spl_ce_SplFileInfo ; zend_error_handling error_handling ; <START_VULN> <END_VULN> zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , " | C" , & ce ) == SUCCESS ) {
start , end + 1 , GFP_KERNEL ) ; if ( family -> id < 0 ) { err = family -> id ; <START_VULN> goto errout_locked ; <END_VULN> } err = genl_validate_assign_mc_groups ( family ) ;
{ uipc_main . read_set = uipc_main . active_set ; <START_VULN> result = select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ; <END_VULN> if ( result == 0 ) {
( * JSGCCallback ) ( JSRuntime * rt , JSGCStatus status ) ; typedef enum JSFinalizeStatus { JSFINALIZE_START , JSFINALIZE_END } JSFinalizeStatus ; typedef void <START_VULN> ( * JSFinalizeCallback ) ( JSFreeOp * fop , JSFinalizeStatus status ) ; <END_VULN> typedef void ( * JSTraceDataOp ) ( JSTracer * trc , void * data ) ;
timeout . tv_sec = 0 ; timeout . tv_usec = 0 ; <START_VULN> select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ; <END_VULN> return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ; }
} static CIE_color <START_VULN> white_point ( PNG_CONST color_encoding * encoding ) <END_VULN> { CIE_color white ;
PNG_EXPORT ( 235 , int , png_image_begin_read_from_stdio , ( png_imagep image , FILE * file ) ) ; <START_VULN> #endif<END_VULN> PNG_EXPORT ( 236 , int , png_image_begin_read_from_memory , ( png_imagep image , png_const_voidp memory , png_size_t size ) ) ;
for ( iptr = 0 ; iptr < info_ptr -> height ; iptr ++ ) info_ptr -> row_pointers [ iptr ] = png_voidcast ( png_bytep , <START_VULN> png_malloc ( png_ptr , info_ptr -> rowbytes ) ) ; <END_VULN> } png_read_image ( png_ptr , info_ptr -> row_pointers ) ;
if ( s_den == 0 ) { return 0 ; } else { <START_VULN> return php_ifd_get32s ( value , motorola_intel ) s_den ; <END_VULN> } case TAG_FMT_SSHORT : return php_ifd_get16u ( value , motorola_intel ) ;
text . text_length = 0 ; text . itxt_length = uncompressed_length ; <START_VULN> if ( png_set_text_2 ( png_ptr , info_ptr , & text , 1 ) ) <END_VULN> errmsg = "insufficient memory" ; } }
ZVAL_STRINGL ( * rval , str , len , 1 ) ; return 1 ; } <START_VULN> #line 971 "extstandardvar_unserializer . c"<END_VULN> yy53 : yych = * ++ YYCURSOR ; if ( yych <= '' ) {
} if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; RETURN_FALSE ; }
#include "vpxvpx_codec . h" <START_VULN> static const char * const cfg = " -- target = generic - gnu -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
"png_start_read_imagepng_read_update_info : duplicate call" ) ; } } <START_VULN> #endif<END_VULN> #ifdef PNG_SEQUENTIAL_READ_SUPPORTED #ifdef PNG_MNG_FEATURES_SUPPORTED
PaintInvalidationReason , const String * debug_name = nullptr ) ; PaintInvalidationReason ChunkPropertiesChanged ( <START_VULN> const RefCountedPropertyTreeState & new_chunk_state , <END_VULN> const PaintChunkInfo & new_chunk , const PaintChunkInfo & old_chunk , const PropertyTreeState & layer_state ) const ;
if ( yych <= '9' ) goto yy79 ; if ( yych != ' ; ' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 557 "extstandardvar_unserializer . re"<END_VULN> { #if SIZEOF_LONG == 4 int digits = YYCURSOR - start - 3 ;
{ size_t i ; size_t j ; <START_VULN> uchar * dp ; <END_VULN> dp = data ; for ( i = 0 ; i < len ; i += 16 ) { fprintf ( out , " % 04zx : " , i ) ;
<START_VULN> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ; <END_VULN> if ( best_mode . mbmode . mode == B_PRED ) {
{ IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; <START_VULN> WORD32 i ; <END_VULN> WORD32 sps_id ; pps_t * ps_pps ;
else if ( ! strncmp ( caf_chunk_header . mChunkType , "data" , 4 ) ) { uint32_t mEditCount ; <START_VULN> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) | | <END_VULN> bcount != sizeof ( mEditCount ) ) { error_line ( " % s is not a valid . CAF file ! " , infilename ) ; return WAVPACK_SOFT_ERROR ;
const PRUint16 platformID = ReadShortAt ( table , TableOffsetPlatformID ) ; if ( ! acceptablePlatform ( platformID ) ) continue ; const PRUint16 encodingID = ReadShortAt ( table , TableOffsetEncodingID ) ; const PRUint32 offset = ReadLongAt ( table , TableOffsetOffset ) ; NS_ASSERTION ( offset < aBufLength , "cmap table offset is longer than table size" ) ; <START_VULN> NS_ENSURE_TRUE ( offset < aBufLength , NS_ERROR_FAILURE ) ; <END_VULN> const PRUint8 * subtable = aBuf + offset ; const PRUint16 format = ReadShortAt ( subtable , SubtableOffsetFormat ) ; if ( isSymbol ( platformID , encodingID ) ) { aUnicodeFont = PR_FALSE ; aSymbolFont = PR_TRUE ; keepFormat = format ;
void RegisterFileAsBlob ( const GURL & blob_url , <START_VULN> const FilePath & virtual_path , <END_VULN> const FilePath & platform_path ) ;
samedtype = true ; dtype = jas_image_cmptdtype ( dec -> image , 0 ) ; <START_VULN> for ( i = 1 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <END_VULN> if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) { samedtype = false ; break ;
c << = 1 ; } for ( y = posision_y + i ; y < posision_y + i + n ; ++ y ) { <START_VULN> ( void ) ResetMagickMemory ( imbuf + imsx * y + posision_x , color_index , repeat_count ) ; <END_VULN> } if ( max_x < ( posision_x + repeat_count - 1 ) ) { max_x = posision_x + repeat_count - 1 ;
} static vpx_codec_err_t ctrl_set_postproc ( vpx_codec_alg_priv_t * ctx , <START_VULN> int ctr_id , va_list args ) { <END_VULN> #if CONFIG_VP9_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ;
Member < FetchContext> context_ ; <START_VULN> HashSet < String> validated_ur_ls_ ; <END_VULN> mutable DocumentResourceMap document_resources_ ; Member < HeapListHashSet < Member < Resource >> > preloads_ ;
} ; DeadResourceStatsRecorder dead_stats_recorder_ ; <START_VULN> std : : unique_ptr < HashSet < String >> preloaded_ur_ls_for_test_ ; <END_VULN> bool auto_load_images_ : 1 ;
const FragmentData & fragment_data_ ; const bool & is_actually_needed_ ; LayoutPoint old_paint_offset_ ; <START_VULN> scoped_refptr < const TransformPaintPropertyNode> old_paint_offset_translation_ ; <END_VULN> } ; class FindVisualRectNeedingUpdateScopeBase {
int php_optind = 1 , use_extended_info = 0 ; char * ini_path_override = NULL ; char * ini_entries = NULL ; <START_VULN> int ini_entries_len = 0 ; <END_VULN> int ini_ignore = 0 ; sapi_module_struct * sapi_module = & cli_sapi_module ;
int reg = ( instr >> 12 ) & 15 ; if ( reg == 15 ) return 1 ; <START_VULN> regs -> uregs [ reg ] = current_thread_info ( ) -> tp_value ; <END_VULN> regs -> ARM_pc += 4 ; return 0 ; }
this_mv . as_mv . col = bc + hex [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <END_VULN> CHECK_BETTER } }
static int keepalive_counter = 0 ; <START_VULN> static unsigned char pass_salt [ 17 ] ; <END_VULN> static char username [ MT_MNDP_MAX_STRING_SIZE ] ; static char password [ MT_MNDP_MAX_STRING_SIZE ] ; static char nonpriv_username [ MT_MNDP_MAX_STRING_SIZE ] ;
PNG_DFN "OS2 CODE PRELOAD MOVEABLE DISCARDABLE" PNG_DFN "" PNG_DFN "EXPORTS" <START_VULN> PNG_DFN " ; Version 1 . 6 . 10"<END_VULN> #define PNG_EXPORTA ( ordinal , type , name , args , attributes ) PNG_DFN "@" SYMBOL_PREFIX "@@" name "@"
const std : : string & raw_device_id , const media : : AudioParameters & output_params ) const ; <START_VULN> media : : AudioManager * audio_manager_ ; <END_VULN> MediaStreamManager * const media_stream_manager_ ; std : : unique_ptr < MediaDevicesPermissionChecker> permission_checker_ ; const int render_process_id_ ;
<START_VULN> if ( transforms & PNG_TRANSFORM_INVERT_MONO ) <END_VULN> #ifdef PNG_READ_INVERT_SUPPORTED png_set_invert_mono ( png_ptr ) ; #else
SkColor thumb_inactive_color ; SkColor track_color ; <START_VULN> <END_VULN> SkColor active_selection_bg_color ; SkColor active_selection_fg_color ; SkColor inactive_selection_bg_color ;
php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Missing y position" ) ; RETURN_FALSE ; } <START_VULN> <END_VULN> if ( type == GD_AFFINE_TRANSLATE ) { res = gdAffineTranslate ( affine , x , y ) ; } else {
} case PHP_MODE_REFLECTION_EXT_INFO : { <START_VULN> int len = ( int ) strlen ( reflection_what ) ; <END_VULN> char * lcname = zend_str_tolower_dup ( reflection_what , len ) ; zend_module_entry * module ;
if ( context && php_stream_context_get_option ( context , "http" , "header" , & tmpzval ) == SUCCESS ) { tmp = NULL ; <START_VULN> <END_VULN> if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval ** tmpheader = NULL ;
int32_t i32 ; uint32_t u32 ; JSWhyMagic why ; } payload ; } s ; double asDouble ; void * asPtr ; size_t asWord ; <START_VULN> } jsval_layout ; <END_VULN> # endif #else # if JS_BITS_PER_WORD == 32 typedef union jsval_layout { uint64_t asBits ; struct { JSValueTag tag ;
va_end ( ap ) ; } <START_VULN> int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) { <END_VULN> FILE * f = input_ctx -> file ; y4m_input * y4m = & input_ctx -> y4m ; int shortread = 0 ;
#endif <START_VULN> if ( ( mask & PNG_FREE_PLTE ) & info_ptr -> free_me ) <END_VULN> { png_free ( png_ptr , info_ptr -> palette ) ; info_ptr -> palette = NULL ;
( v -> sequence + 1 != vb -> sequence ) ) { v -> granulepos = - 1 ; b -> sample_count = - 1 ; } v -> sequence = vb -> sequence ; if ( vb -> pcm ) { <END_VULN> int n = ci -> blocksizes [ v -> W ] >> ( hs + 1 ) ; int n0 = ci -> blocksizes [ 0 ] >> ( hs + 1 ) ; int n1 = ci -> blocksizes [ 1 ] >> ( hs + 1 ) ; int thisCenter ; int prevCenter ; v -> glue_bits += vb -> glue_bits ;
virtual ~ Camera2ClientBase ( ) ; virtual status_t initialize ( camera_module_t * module ) ; <START_VULN> virtual status_t dump ( int fd , const Vector < String16> & args ) ; <END_VULN>
tmsize_t wc = cc bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; <START_VULN> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <END_VULN> if ( cc % ( bps * stride ) != 0 ) {
static void OnSSLCertificateError ( <START_VULN> base : : WeakPtr < SSLErrorHandler : : Delegate> delegate , <END_VULN> const content : : GlobalRequestID & id , ResourceType : : Type resource_type , const GURL & url ,
hashtable_do_clear ( hashtable ) ; <START_VULN> for ( i = 0 ; i < num_buckets ( hashtable ) ; i ++ ) <END_VULN> { hashtable -> buckets [ i ] . first = hashtable -> buckets [ i ] . last = & hashtable -> list ;
uint32_t str_key_len , base_len = p_obj -> l ; phar_entry_data * data ; php_stream * fp ; <START_VULN> php_stat_len fname_len ; <END_VULN> size_t contents_len ; char * fname , * error = NULL , * base = p_obj -> b , * save = NULL , * temp = NULL ; zend_string * opened ;
idx = ( ( r -> CRm & 3 ) << 3 ) | ( r -> Op2 & 7 ) ; } else { <START_VULN> BUG ( ) ; <END_VULN> } if ( ! pmu_counter_idx_valid ( vcpu , idx ) )
for ( i = 0 ; i < attribute_count ; i ++ ) { size_t record_len = coolkey_get_attribute_record_len ( attr , object_record_type , buf_len ) ; <START_VULN> if ( buf_len < record_len ) { <END_VULN> return SC_ERROR_CORRUPTED_DATA ; }
if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ; <START_VULN> frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show , <END_VULN> & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 )
const bool bcached = <START_VULN> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <END_VULN> ctx -> hdrs [ i ] -> old = false ; ctx -> hdrs [ i ] -> read = false ; if ( hcached )
sem_t * semaphore = callbacks_get_semaphore ( #callback ) ; while ( ! sem_trywait ( semaphore ) ) ; expression ; <START_VULN> sem_wait ( semaphore ) ; <END_VULN> } while ( 0 )
GC_REFCOUNT ( ht ) = 1 ; GC_TYPE_INFO ( ht ) = IS_ARRAY ; ht -> u . flags = ( persistent ? HASH_FLAG_PERSISTENT : 0 ) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS ; <START_VULN> ht -> nTableSize = zend_hash_check_size ( nSize ) ; <END_VULN> ht -> nTableMask = HT_MIN_MASK ; HT_SET_DATA_ADDR ( ht , & uninitialized_bucket ) ; ht -> nNumUsed = 0 ; ht -> nNumOfElements = 0 ; ht -> nInternalPointer = HT_INVALID_IDX ; ht -> nNextFreeElement = 0 ; ht -> pDestructor = pDestructor ; } static void ZEND_FASTCALL zend_hash_packed_grow ( HashTable * ht )
* ( q ++ ) = * p ; } } <START_VULN> <END_VULN> * q = '0' ; * retlen = ( size_t ) ( q - ret ) ; }
nsTextFrame * nextContinuation = static_cast < nsTextFrame * > ( aPrevInFlow -> GetNextContinuation ( ) ) ; #endif SetPrevInFlow ( aPrevInFlow ) ; aPrevInFlow -> SetNextInFlow ( this ) ; nsTextFrame * prev = static_cast < nsTextFrame * > ( aPrevInFlow ) ; mContentOffset = prev -> GetContentOffset ( ) + prev -> GetContentLengthHint ( ) ; <START_VULN> NS_ASSERTION ( mContentOffset < aContent -> GetText ( ) -> GetLength ( ) , <END_VULN> "Creating ContinuingTextFrame , but there is no more content" ) ; if ( prev -> GetStyleContext ( ) != GetStyleContext ( ) ) { prev -> ClearTextRun ( ) ; } else { mTextRun = prev -> GetTextRun ( ) ; }
# else PNG_UNUSED ( png_ptr ) # endif <START_VULN> if ( is_screen ) <END_VULN> output_gamma = PNG_GAMMA_sRGB ; else output_gamma = PNG_GAMMA_sRGB_INVERSE ;
png_crc_read ( png_ptr , buffer , length ) ; <START_VULN> if ( png_crc_finish ( png_ptr , skip ) ) <END_VULN> return ; key = ( png_charp ) buffer ;
int buf_size = avpkt -> size ; MP3On4DecodeContext * s = avctx -> priv_data ; MPADecodeContext * m ; int fsize , len = buf_size , out_size = 0 ; uint32_t header ; OUT_INT * out_samples ; OUT_INT * outptr , * bp ; int fr , j , n , ch , ret ; <START_VULN> s -> frame -> nb_samples = MPA_FRAME_SIZE ; <END_VULN> if ( ( ret = avctx -> get_buffer ( avctx , s -> frame ) ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "get_buffer ( ) failed" ) ; return ret ; } out_samples = ( OUT_INT * ) s -> frame -> data [ 0 ] ; if ( buf_size < HEADER_SIZE ) return AVERROR_INVALIDDATA ;
{ int i , count = 0 ; int * key_sizes ; <START_VULN> <END_VULN> MCRYPT_GET_TD_ARG array_init ( return_value ) ;
png_error ( png_ptr , "invalid compression buffer size" ) ; # ifdef PNG_SEQUENTIAL_READ_SUPPORTED <START_VULN> if ( png_ptr -> mode & PNG_IS_READ_STRUCT ) <END_VULN> { png_ptr -> IDAT_read_size = ( png_uint_32 ) size ; return ;
} return ; trunc : <START_VULN> ND_PRINT ( ( ndo , " [ | truncated ] " ) ) ; <END_VULN> return ; }
TabContents * GetVisibleTab ( ) const { return preview_ ? preview_ : tab_ ; } <START_VULN> void DetachTab ( TabContents * tab ) ; <END_VULN> virtual void Observe ( int type ,
double kf_group_coded_err = 0 . 0 ; double recent_loop_decay [ 8 ] = { 1 . 0 , 1 . 0 , 1 . 0 , 1 . 0 , 1 . 0 , 1 . 0 , 1 . 0 , 1 . 0 } ; <START_VULN> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <END_VULN> vp8_clear_system_state ( ) ; start_position = cpi -> twopass . stats_in ;
{ int n ; int i ; <START_VULN> uchar buf [ 2 ] ; <END_VULN> assert ( JAS_STREAM_MAXPUTBACK > = 2 ) ;
* ( dp ++ ) = save [ 1 ] ; } } <START_VULN> #endif<END_VULN> } } }
else * ( dp ++ ) = red ; <START_VULN> if ( have_alpha ) <END_VULN> * ( dp ++ ) = * ( sp ++ ) ; } }
ND_PRINT ( ( ndo , " ( length bogus , should be > = 6 ) " ) ) ; return len ; } <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 3 ) ; <END_VULN> ND_PRINT ( ( ndo , " : Vendor : % s ( % u ) " , tok2str ( oui_values , "Unknown" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ;
sock -> _wreq . bufs = sock -> _wreq . smallbufs ; } else { sock -> _wreq . bufs = h2o_mem_alloc ( sizeof ( h2o_iovec_t ) * bufcnt ) ; <START_VULN> sock -> _wreq . alloced_ptr = sock -> _wreq . bufs = sock -> _wreq . bufs ; <END_VULN> } memcpy ( sock -> _wreq . bufs , bufs , sizeof ( h2o_iovec_t ) * bufcnt ) ; sock -> _wreq . cnt = bufcnt ;
image -> numcmpts_ = 0 ; image -> maxcmpts_ = 0 ; image -> cmpts_ = 0 ; <START_VULN> image -> inmem_ = true ; <END_VULN> image -> cmprof_ = 0 ; return image ;
buffer = ( unsigned char * ) AcquireQuantumMemory ( 512 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <START_VULN> packet_size = ( size_t ) ( image -> depth > 8 ? 2 : 1 ) ; <END_VULN> scanline = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , packet_size * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL )
interlace_type = PNG_INTERLACE_NONE ; #endif <START_VULN> <END_VULN> png_ptr -> bit_depth = ( png_byte ) bit_depth ; png_ptr -> color_type = ( png_byte ) color_type ; png_ptr -> interlaced = ( png_byte ) interlace_type ;
} while ( png_ptr -> iwidth == 0 | | png_ptr -> num_rows == 0 ) ; } <START_VULN> #endif<END_VULN> } void
tmp -> dev = skb -> dev ; memcpy ( skb_put ( tmp , hdrlen ) , skb -> data , hdrlen ) ; memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ) ; pos += fraglen ; } <START_VULN> skb -> len = hdrlen + per_fragm ; <END_VULN> return 0 ; }
class MIDI_EXPORT TaskService final { public : using RunnerId = size_t ; <START_VULN> using InstanceId = int ; <END_VULN> static constexpr RunnerId kDefaultRunnerId = 0 ;
virtual ~ WtsConsoleSessionProcessDriver ( ) ; <START_VULN> virtual void OnChannelConnected ( ) OVERRIDE ; <END_VULN> virtual bool OnMessageReceived ( const IPC : : Message & message ) OVERRIDE ; virtual void OnPermanentError ( ) OVERRIDE ;
atalk_print ( ndo , bp , len ) ; break ; case ETHERTYPE_GRE_ISO : <START_VULN> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <END_VULN> break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;
void SetUseSecureKeyboardEntryWhenActive ( bool ) ; <START_VULN> bool IsHandleVisible ( ) const ; <END_VULN> void UpdateSecureKeyboardEntryIfActive ( ) ;
} <START_VULN> CWD_API realpath_cache_bucket * realpath_cache_lookup ( const char * path , int path_len , time_t t ) <END_VULN> { return realpath_cache_find ( path , path_len , t ) ; }
MprJson * child , * job ; int ji ; <START_VULN> if ( ( job = mprGetJsonObj ( route -> config , "app . http . auth . roles" ) ) != 0 ) { <END_VULN> parseAuthRoles ( route , "app . http . auth . roles" , job ) ; } abilities = mprCreateHash ( 0 , 0 ) ;
if ( scontains ( value , " = " ) ) { for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { <START_VULN> option = stok ( option , " = t , " , & ovalue ) ; <END_VULN> ovalue = strim ( ovalue , ""'" , MPR_TRIM_BOTH ) ; if ( smatch ( option , "auth" ) ) { auth = ovalue ;
wx2 = im -> sx ; wy2 = im -> sy ; oc = gdImageGetPixel ( im , x , y ) ; if ( oc == nc | | x < 0 | | x>wx2 | | y < 0 | | y>wy2 ) { <START_VULN> im -> alphaBlendingFlag = alphablending_bak ; <END_VULN> return ; }
mpls_print ( ndo , p , l2info . length ) ; return l2info . header_len ; case JUNIPER_LSQ_L3_PROTO_ISO : <START_VULN> isoclns_print ( ndo , p , l2info . length , l2info . caplen ) ; <END_VULN> return l2info . header_len ; default : break ;
#include "vpxvpx_codec . h" <START_VULN> static const char * const cfg = " -- force - target = armv8 - linux - gcc -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , opts , krb5_get_as_key_noop , & userid , & use_master , NULL ) ; <START_VULN> if ( code == 0 | | code == KRB5_PREAUTH_FAILED ) { <END_VULN> * canon_user = userid . user ; userid . user = NULL ; code = 0 ;
png_set_expand ( png_ptr ) ; #ifdef NJET <START_VULN> <END_VULN> if ( bit_depth == 16 ) png_set_strip_16 ( png_ptr ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : residue backend 0 , 1 and 2 implementation <START_VULN> last mod : $ Id : res0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN>
EdiRec * rec ; cchar * key ; <START_VULN> key = mprLookupJson ( params , "id" ) ; <END_VULN> if ( ( rec = ediSetFields ( ediReadRec ( getDatabase ( ) , tableName , key ) , params ) ) == 0 ) { return 0 ; }
} } <START_VULN> if ( pmd_none_or_clear_bad ( pmd ) ) <END_VULN> mincore_unmapped_range ( vma , addr , next , vec ) ; else mincore_pte_range ( vma , pmd , addr , next , vec ) ;
const TOKENEXTRA * stop = cpi -> tplist [ mb_row ] . stop ; int tokens = ( int ) ( stop - p ) ; <START_VULN> vp8_pack_tokens_c ( w , p , tokens ) ; <END_VULN> } vp8_stop_encode ( w ) ;
temp_area + i * dest_pitch , 1 , hratio , dest_width ) ; } else { <START_VULN> vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ; <END_VULN> } }
<START_VULN> bool ReplyToRenderer ( const IPC : : ChannelHandle & channel_handle ) ; <END_VULN>
#endif } ; <START_VULN> int get_vpx_encoder_count ( ) { <END_VULN> return sizeof ( vpx_encoders ) sizeof ( vpx_encoders [ 0 ] ) ; }
else { back_g = display -> background -> green ; <START_VULN> if ( output_format & PNG_FORMAT_FLAG_COLOR ) <END_VULN> { back_r = display -> background -> red ; back_b = display -> background -> blue ;
static mif_hdr_t * mif_hdr_get ( jas_stream_t * in ) { <START_VULN> uchar magicbuf [ MIF_MAGICLEN ] ; <END_VULN> char buf [ 4096 ] ; mif_hdr_t * hdr ; bool done ;
len = strlen ( filein ) ; if ( filein [ len - 1 ] == 'h' ) continue ; <START_VULN> snprintf ( buf , L_BUF_SIZE , "cpp - ansi - DNO_PROTOS % s % s" , <END_VULN> filein , tempfile ) ; ret = system ( buf ) ; if ( ret ) {
#include "vpxvpx_codec . h" <START_VULN> static const char * const cfg = " -- target = armv7 - linux - gcc -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
struct file ; struct perf_sample_data ; <START_VULN> typedef void ( * perf_overflow_handler_t ) ( struct perf_event * , int , <END_VULN> struct perf_sample_data * , struct pt_regs * regs ) ;
} return ; trunc : <START_VULN> ND_PRINT ( ( ndo , " [ | icmp6 ] " ) ) ; <END_VULN> return ; }
IPC_SYNC_MESSAGE_ROUTED2_1 ( PrintHostMsg_CheckForCancel , <START_VULN> std : : string , <END_VULN> int , bool )
#ifdef PNG_READ_TRANSFORMS_SUPPORTED static unsigned int sample ( png_const_bytep row , png_byte colour_type , png_byte bit_depth , <START_VULN> png_uint_32 x , unsigned int sample_index ) <END_VULN> { png_uint_32 bit_index , result ;
#endif if ( pc -> refresh_entropy_probs == 0 ) { <START_VULN> vpx_memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ; <END_VULN> } pc -> refresh_last_frame = pc -> frame_type == KEY_FRAME | | vp8_read_bit ( bc ) ;
#if defined ( OS_MACOSX ) <START_VULN> void GetSettingsWithUI ( gfx : : NativeWindow parent_window , <END_VULN> int document_page_count , bool has_selection ) ; #endif
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 102 20140311 21 : 00 : 13 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
unsigned OffsetVal ; OffsetVal = Get32u ( DirEntry + 8 ) ; <START_VULN> if ( OffsetVal + ByteCount > ExifLength ) { <END_VULN> ErrNonfatal ( "Illegal value pointer for tag % 04x" , Tag , 0 ) ; continue ;
#ifdef CONFIG_COMPAT . compat_ioctl = ecryptfs_compat_ioctl , #endif <START_VULN> . mmap = generic_file_mmap , <END_VULN> . open = ecryptfs_open , . flush = ecryptfs_flush , . release = ecryptfs_release ,
DISALLOW_ALLOCATION ( ) ; public : typedef ResultType * ReturnType ; <START_VULN> typedef Persistent < ResultType> StorageType ; <END_VULN> static ReturnType createFromCallbackArg ( CallbackArg argument ) {
Delegate * delegate ( ) const { return delegate_ ; } int max_pending_send_allowed ( ) const { return max_pending_send_allowed_ ; } <START_VULN> URLRequestContext * context ( ) { return context_ . get ( ) ; } <END_VULN> void set_context ( URLRequestContext * context ) ;
uint16_t transmitted_length = 0 ; while ( length > 0 ) { <START_VULN> ssize_t ret = write ( uart_fd , data + transmitted_length , length ) ; <END_VULN> switch ( ret ) { case - 1 : LOG_ERROR ( "In % s , error writing to the uart serial port : % s" , __func__ , strerror ( errno ) ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : window functions <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_WINDOW_ #define _V_WINDOW_ extern float * _vorbis_window_get ( int n ) ; extern void _vorbis_apply_window ( float * d , int * winno , long * blocksizes ,
vpx_codec_err_t vpx_codec_enc_config_default ( vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , <START_VULN> unsigned int usage ) ; <END_VULN>
* ( -- dp ) = * ( -- sp ) ; * ( -- dp ) = * ( -- sp ) ; } <START_VULN> * ( -- dp ) = hi_filler ; <END_VULN> * ( -- dp ) = lo_filler ; row_info -> channels = 4 ; row_info -> pixel_depth = 64 ; row_info -> rowbytes = row_width * 8 ;
{ int i ; <START_VULN> png_debug1 ( 1 , "in % lx storage function" , png_ptr == NULL ? "unexpected" : <END_VULN> ( unsigned long ) png_ptr -> chunk_name ) ; if ( png_ptr == NULL | | info_ptr == NULL | | num_text <= 0 | | text_ptr == NULL )
while ( filt_val < max_filter_level ) { <START_VULN> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <END_VULN> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ;
EXPECT_TRUE ( this -> SetCanonicalCookie ( cs , <START_VULN> base : : MakeUnique < CanonicalCookie> ( <END_VULN> "A" , "B" , foo_foo_host , "foo" , one_hour_ago , one_hour_from_now , base : : Time ( ) , false , false , CookieSameSite : : DEFAULT_MODE , COOKIE_PRIORITY_DEFAULT ) ,
if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ; <START_VULN> <END_VULN> eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;
static std : : vector < PageHandler * > ForAgentHost ( DevToolsAgentHostImpl * host ) ; void Wire ( UberDispatcher * dispatcher ) override ; <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) override ; void OnSwapCompositorFrame ( viz : : CompositorFrameMetadata frame_metadata ) ; void OnSynchronousSwapCompositorFrame (
we can write * vorbis_staticbook_pack ( testlist [ ptr ] , & write ) ; fprintf ( stderr , "Codebook size % ld bytes . . . " , oggpack_bytes ( & write ) ) ; for ( i = 0 ; i < TESTSIZE ; i += c . dim ) { int best = _best ( & c , qv + i , 1 ) ; vorbis_book_encodev ( & c , best , qv + i , & write ) ; } vorbis_book_clear ( & c ) ; <START_VULN> <END_VULN> fprintf ( stderr , "OK . " ) ; fprintf ( stderr , "tunpackingdecoding % ld . . . " , ptr ) ; oggpack_readinit ( & read , oggpack_get_buffer ( & write ) , oggpack_bytes ( & write ) ) ; if ( vorbis_staticbook_unpack ( & read , & s ) ) { fprintf ( stderr , "Error unpacking codebook . " ) ; exit ( 1 ) ;
if ( ! b_xiph ) { void * p_org = p_stream -> p_headers ; p_stream -> i_headers += p_oggpacket -> bytes ; p_stream -> p_headers = realloc ( p_stream -> p_headers , p_stream -> i_headers ) ; if ( p_stream -> p_headers ) { memcpy ( ( unsigned char * ) p_stream -> p_headers + p_stream -> i_headers - p_oggpacket -> bytes , <START_VULN> p_oggpacket -> packet , p_stream -> i_headers ) ; <END_VULN> } else { #warning Memory leak p_stream -> i_headers = 0 ; p_stream -> p_headers = NULL ; free ( p_org ) ; } } else if ( xiph_AppendHeaders ( & p_stream -> i_headers , & p_stream -> p_headers ,
{ png_uint_16p hist ; <START_VULN> if ( png_get_hIST ( read_ptr , read_info_ptr , & hist ) ) <END_VULN> png_set_hIST ( write_ptr , write_info_ptr , hist ) ; } #endif
#ifdef PNG_WRITE_zTXt_SUPPORTED PNG_INTERNAL_FUNCTION ( void , png_write_zTXt , ( png_structrp png_ptr , png_const_charp <START_VULN> key , png_const_charp text , png_size_t text_len , int compression ) , PNG_EMPTY ) ; <END_VULN> #endif #ifdef PNG_WRITE_iTXt_SUPPORTED
return ERR_PTR ( - ENOMEM ) ; if ( inode -> i_state & I_NEW ) { <START_VULN> ret = isofs_read_inode ( inode ) ; <END_VULN> if ( ret < 0 ) { iget_failed ( inode ) ; inode = ERR_PTR ( ret ) ;
} <START_VULN> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ; <END_VULN> source += source_band_height * source_pitch ;
#endif #ifdef PNG_EASY_ACCESS_SUPPORTED <START_VULN> if ( verbose ) <END_VULN> { png_uint_32 iwidth , iheight ; iwidth = png_get_image_width ( write_ptr , write_info_ptr ) ;
int setting = ( 2 + ( onoff != 0 ) ) << option ; int current = png_ptr -> options ; <START_VULN> png_ptr -> options = ( png_byte ) ( ( current & ~ mask ) | setting ) ; <END_VULN> return ( current & mask ) >> option ; }
void OnReadAsciiText ( ui : : Clipboard : : Buffer buffer , std : : string * result ) ; void OnReadHTML ( ui : : Clipboard : : Buffer buffer , string16 * markup , GURL * url ) ; void OnReadImage ( ui : : Clipboard : : Buffer buffer , IPC : : Message * reply_msg ) ; <START_VULN> void OnReadImageReply ( SkBitmap bitmap , IPC : : Message * reply_msg ) ; <END_VULN> #if defined ( OS_MACOSX ) void OnFindPboardWriteString ( const string16 & text ) ; #endif
CVE_2011_1495__ctl_diag_read_buffer ( void __user * arg , enum block_state state ) { struct mpt2_diag_read_buffer karg ; struct mpt2_diag_read_buffer __user * uarg = arg ; struct MPT2SAS_ADAPTER * ioc ; void * request_data , * diag_data ; Mpi2DiagBufferPostRequest_t * mpi_request ; Mpi2DiagBufferPostReply_t * mpi_reply ; int rc , i ; u8 buffer_type ; <START_VULN> unsigned long timeleft ; <END_VULN> u16 smid ; u16 ioc_status ; u8 issue_reset = 0 ; if ( copy_from_user ( & karg , arg , sizeof ( karg ) ) ) { printk ( KERN_ERR "failure at % s : % d % s ( ) ! " , __FILE__ , __LINE__ , __func__ ) ; return - EFAULT ; } if ( _ctl_verify_adapter ( karg . hdr . ioc_number , & ioc ) == - 1 | | ! ioc )
# define KERNEL_STACK_SIZE_ORDER0 #endif <START_VULN> #define IA64_RBS_OFFSET ( ( IA64_TASK_SIZE + IA64_THREAD_INFO_SIZE + 15 ) & ~ 15 ) <END_VULN> #define IA64_STK_OFFSET ( ( 1 << KERNEL_STACK_SIZE_ORDER ) * PAGE_SIZE ) #define KERNEL_STACK_SIZEIA64_STK_OFFSET
<START_VULN> #define FC_NUM_CASE_FOLD291<END_VULN> #define FC_NUM_CASE_FOLD_CHARS471 #define FC_MAX_CASE_FOLD_CHARS6 #define FC_MAX_CASE_FOLD_EXPAND4
{ return 2 ; } <START_VULN> mpz_powm ( b , b , key -> e , key -> n ) ; <END_VULN> mpz_mul ( v , v , b ) ; mpz_mod ( v , v , key -> n ) ; return 0 ;
const string16 & keyword , const AutocompleteInput & input ) ; <START_VULN> <END_VULN> virtual void Start ( const AutocompleteInput & input , bool minimal_changes ) OVERRIDE ; virtual void Stop ( ) OVERRIDE ;
virtual IntRect PageRect ( ) = 0 ; <START_VULN> virtual void Focus ( ) = 0 ; <END_VULN> virtual bool CanTakeFocus ( WebFocusType ) = 0 ; virtual void TakeFocus ( WebFocusType ) = 0 ;
} if ( val > maxval ) <START_VULN> ERREXIT ( cinfo , JERR_PPM_TOOLARGE ) ; <END_VULN> return val ; }
char * realptr ; char ** ptr = ( endptr != NULL ) ? endptr : & realptr ; <START_VULN> if ( strlen ( str ) > = sizeof ( lowstr ) ) <END_VULN> { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ;
virtual void SetCookieInfo ( const CookieInfoList & cookie_info_list ) = 0 ; <START_VULN> <END_VULN> virtual void SetPermissionInfo ( const PermissionInfoList & permission_info_list ) = 0 ;
zval_dtor ( * zcount ) ; ZVAL_LONG ( * zcount , replace_count ) ; } <START_VULN> <END_VULN> }
<START_VULN> int test_main ( int argc , char ** argv ) ; <END_VULN> No newline at end of file
char name [ FILE_NAME_SIZE ] ; <START_VULN> PNG_CONST png_uint_32 id = FILEID ( colour_type , bit_depth , 0 , <END_VULN> interlace_type , w , h , do_interlace ) ; standard_name_from_id ( name , sizeof name , 0 , id ) ;
else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else <START_VULN> pkt = ctx -> iface -> enc . get_cx_data ( ctx -> priv -> alg_priv , iter ) ; <END_VULN> } if ( pkt && pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {
if ( owner ) { <START_VULN> switch ( getFileType ( path ) ) { <END_VULN> case FT_NONEXISTANT : createDirectory ( path ) ; break ;
if ( ( ms -> flags & MAGIC_DEBUG ) != 0 ) fprintf ( stderr , "indirect + offs = % u" , offset ) ; } <START_VULN> if ( mcopy ( ms , p , m -> type , 0 , s , offset , nbytes , count ) == - 1 ) <END_VULN> return - 1 ; ms -> offset = offset ;
static int image_transform_png_set_gray_to_rgb_add ( image_transform * this , <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <END_VULN> { UNUSED ( bit_depth )
if ( ! strncmp ( prop_chunk , "SND " , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; <START_VULN> uint16_t numChannels , chansSpecified , chanMask = 0 ; <END_VULN> uint32_t sampleRate ; while ( eptr - cptr > = sizeof ( dff_chunk_header ) ) {
SPL_METHOD ( DirectoryIterator , isDot ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
sk_free ( fPtr ) ; } if ( count > kCount ) { <START_VULN> fPtr = ( T * ) sk_malloc_throw ( count * sizeof ( T ) ) ; <END_VULN> } else if ( count ) { fPtr = fTStorage ; } else {
memset ( data_s , 0 , data_size ) ; memcpy ( data_s , data , data_len ) ; } <START_VULN> <END_VULN> mdecrypt_generic ( pm -> td , data_s , data_size ) ; RETVAL_STRINGL ( data_s , data_size , 1 ) ;
else if ( ! ctx -> iface -> enc . get_preview ) ctx -> err = VPX_CODEC_INCAPABLE ; else <START_VULN> img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ; <END_VULN> } return img ;
OriginRequestSummary ( const OriginRequestSummary & other ) ; ~ OriginRequestSummary ( ) ; <START_VULN> GURL origin ; <END_VULN> bool always_access_network = false ; bool accessed_network = false ; int first_occurrence = 0 ;
virtual bool OnMessageReceived ( const IPC : : Message & message ) OVERRIDE ; void OnFindReply ( int request_id , int number_of_matches , const gfx : : Rect & selection_rect , int active_match_ordinal , bool final_update ) ; <START_VULN> private : <END_VULN> TabContentsWrapper * tab_contents_ ;
private : class UserState { public : <START_VULN> explicit UserState ( AccountId account_id ) ; <END_VULN> UserState ( UserState && ) ; ~ UserState ( ) ;
} int main ( int argc , char * argv [ ] ) { <START_VULN> p_fm_config_conx_hdlthdl ; <END_VULN> intinstance = 0 ; fm_mgr_config_errno_tres ; char * rem_addr = NULL ;
} ; <START_VULN> static void<END_VULN> vpx_usec_timer_start ( struct vpx_usec_timer * t ) { #if defined ( _WIN32 ) QueryPerformanceCounter ( & t -> begin ) ;
InstallNewDocumentReason , ParserSynchronizationPolicy , const KURL & overriding_url ) ; <START_VULN> void DidInstallNewDocument ( Document * ) ; <END_VULN> void WillCommitNavigation ( ) ; void DidCommitNavigation ( ) ;
return ; } for ( i = 0 ; i < argc ; i ++ ) { <START_VULN> key = stok ( sclone ( argv [ i ] ) , " = " , ( char ** ) & value ) ; <END_VULN> if ( value ) { setPackageKey ( key , value ) ; } else {
{ inti ; u_entry_T * uep ; <START_VULN> char_u ** array ; <END_VULN> char_u * line ; intline_len ;
blue_y ; if ( png_get_cHRM_fixed ( read_ptr , read_info_ptr , & white_x , & white_y , <START_VULN> & red_x , & red_y , & green_x , & green_y , & blue_x , & blue_y ) ) <END_VULN> { png_set_cHRM_fixed ( write_ptr , write_info_ptr , white_x , white_y , red_x , red_y , green_x , green_y , blue_x , blue_y ) ;
status = PTR_ERR ( cred ) ; goto out ; } <START_VULN> state = nfs4_do_open ( dir , & path , flags , sattr , cred ) ; <END_VULN> d_drop ( dentry ) ; if ( IS_ERR ( state ) ) { status = PTR_ERR ( state ) ;
carray_cursor * pCur = ( carray_cursor * ) cur ; sqlite3_int64 x = 0 ; switch ( i ) { <START_VULN> case CARRAY_COLUMN_POINTER : x = pCur -> iPtr ; break ; <END_VULN> case CARRAY_COLUMN_COUNT : x = pCur -> iCnt ; break ; case CARRAY_COLUMN_CTYPE : { sqlite3_result_text ( ctx , azType [ pCur -> eType ] , - 1 , SQLITE_STATIC ) ;
<START_VULN> if ( output_format & PNG_FORMAT_FLAG_ALPHA ) <END_VULN> { png_uint_32 r ;
jas_stream_putc2 ( stream , c ) ) : EOF ) #define jas_stream_putc2 ( stream , c ) ( ( ( stream ) -> bufmode_ |= JAS_STREAM_WRBUF , -- ( stream ) -> cnt_ < 0 ) ? <START_VULN> jas_stream_flushbuf ( ( stream ) , ( uchar ) ( c ) ) : <END_VULN> ( ++ ( stream ) -> rwcnt_ , ( int ) ( * ( stream ) -> ptr_ ++ = ( c ) ) ) )
#ifndef VP9_COMMON_VP9_SEG_COMMON_H_ #define VP9_COMMON_VP9_SEG_COMMON_H_ <START_VULN> #include "vp9commonvp9_prob . h"<END_VULN> #ifdef __cplusplus extern "C" {
if ( ! dev ) return - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; <START_VULN> if ( err ) <END_VULN> goto err_free_dev ; dev_net_set ( dev , net ) ;
<START_VULN> typedef png_structp version_1_2_52 ; <END_VULN> typedef png_struct FAR * FAR * png_structpp ;
png_free ( c . png_ptr , cp ) ; <START_VULN> if ( c . for_write ) <END_VULN> { # ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED png_destroy_write_struct ( & c . png_ptr , & c . info_ptr ) ;
{ char sig_on = 1 ; BTIF_TRACE_EVENT ( "UIPC SEND WAKE UP" ) ; <START_VULN> send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <END_VULN> } static int uipc_setup_server_locked ( tUIPC_CH_ID ch_id , char * name , tUIPC_RCV_CBACK * cback )
if ( p_buf -> len == 0 ) return SENT_ALL ; <START_VULN> ssize_t sent = send ( fd , p_buf -> data + p_buf -> offset , p_buf -> len , MSG_DONTWAIT ) ; <END_VULN> if ( sent == - 1 ) { if ( errno == EAGAIN | | errno == EWOULDBLOCK | | errno == EINTR )
return res ; } <START_VULN> <END_VULN> static int dwarf_elf_object_access_load_section ( void * obj_in , Dwarf_Half section_index ,
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : lookup based functions <START_VULN> last mod : $ Id : lookup . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < math . h> #include "lookup . h" #include "lookup_data . h" #include "os . h" #include "misc . h"
#include "basefilesfile . h" #include "basefilesfile_path . h" <START_VULN> #include "basemove . h"<END_VULN> #include "ipcipc_platform_file . h" namespace picasa {
PHP_FE_END } ; <START_VULN> ZEND_BEGIN_ARG_INFO_EX ( arginfo_r_dir___construct , 0 , 0 , 1 ) <END_VULN> ZEND_ARG_INFO ( 0 , path ) ZEND_ARG_INFO ( 0 , flags ) ZEND_END_ARG_INFO ( )
fcic . object_ptr = NULL ; result = zend_call_function ( & fci , & fcic TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( result == FAILURE ) { RETVAL_FALSE ; } else {
int vorbis_synthesis_pcmout ( vorbis_dsp_state * v , float ** * pcm ) { vorbis_info * vi = v -> vi ; if ( v -> pcm_returned> - 1 && v -> pcm_returned < v -> pcm_current ) { if ( pcm ) { int i ; for ( i = 0 ; i < vi -> channels ; i ++ ) <START_VULN> v -> pcmret [ i ] = v -> pcm [ i ] + v -> pcm_returned ; <END_VULN> * pcm = v -> pcmret ; } return ( v -> pcm_current - v -> pcm_returned ) ; } return ( 0 ) ; } int vorbis_synthesis_read ( vorbis_dsp_state * v , int n ) {
} efree ( match_sets ) ; } <START_VULN> <END_VULN> efree ( offsets ) ; efree ( subpat_names ) ;
float page_scale_factor ( ) const { return page_scale_factor_ ; } <START_VULN> void ScrollTo ( gfx : : Vector2d new_value ) ; <END_VULN> bool IsVisible ( ) const ;
void InitPrefMembers ( ) ; <START_VULN> virtual PrefService * GetOriginalProfilePrefs ( ) ; <END_VULN>
void mdct_init ( mdct_lookup * lookup , int n ) { int * bitrev = _ogg_malloc ( sizeof ( * bitrev ) * ( n4 ) ) ; DATA_TYPE * T = _ogg_malloc ( sizeof ( * T ) * ( n + n4 ) ) ; <START_VULN> <END_VULN> int i ; int n2 = n >> 1 ; int log2n = lookup -> log2n = rint ( log ( ( float ) n ) log ( 2 . f ) ) ; lookup -> n = n ; lookup -> trig = T ; lookup -> bitrev = bitrev ;
} static int _vorbis_pack_info ( oggpack_buffer * opb , vorbis_info * vi ) { codec_setup_info * ci = vi -> codec_setup ; if ( ! ci ) return ( OV_EFAULT ) ; <START_VULN> <END_VULN> oggpack_write ( opb , 0x01 , 8 ) ; _v_writestring ( opb , "vorbis" , 6 ) ; oggpack_write ( opb , 0x00 , 32 ) ; oggpack_write ( opb , vi -> channels , 8 ) ; oggpack_write ( opb , vi -> rate , 32 ) ;
for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) temp_in [ j ] = out [ j * 16 + i ] ; <START_VULN> iadst16 ( temp_in , temp_out ) ; <END_VULN> for ( j = 0 ; j < 16 ; ++ j ) dest [ j * pitch + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 )
<START_VULN> zlib -> file_bits = 16 ; <END_VULN> zlib -> ok_bits = 16 ; zlib -> cksum = 0 ;
case NLPID_ISIS : if ( ! isis_print ( ndo , p , length ) ) <START_VULN> print_unknown_data ( ndo , p , "t" , caplen ) ; <END_VULN> break ; case NLPID_NULLNS :
less strict that the _ve_envelope_search , the search is not run if we only use one block size * } <START_VULN> <END_VULN> _vorbis_block_ripcord ( vb ) ; vb -> lW = v -> lW ; vb -> W = v -> W ; vb -> nW = v -> nW ;
~ VaapiJpegDecoder ( ) override ; <START_VULN> bool Initialize ( const base : : RepeatingClosure & error_uma_cb ) override ; <END_VULN> scoped_refptr < VASurface> Decode ( base : : span < const uint8_t> encoded_image , VaapiImageDecodeStatus * status ) override ;
if ( ret < 0 ) hid_err ( hdev , "error setting GPIO values : % d" , ret ) ; <START_VULN> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <END_VULN> } static int cp2112_gpio_get_all ( struct gpio_chip * chip )
shader -> DecrementAttachCount ( ) ; return PR_TRUE ; } return PR_FALSE ; } PRBool HasAttachedShaderOfType ( GLenum shaderType ) { for ( PRUint32 i = 0 ; i < mAttachedShaders . Length ( ) ; ++ i ) { <START_VULN> if ( mAttachedShaders [ i ] -> ShaderType ( ) == shaderType ) { <END_VULN> return PR_TRUE ; } } return PR_FALSE ; } PRBool HasBothShaderTypesAttached ( ) { return
static void php_mcrypt_module_dtor ( zend_rsrc_list_entry * rsrc TSRMLS_DC ) { php_mcrypt * pm = ( php_mcrypt * ) rsrc -> ptr ; <START_VULN> if ( pm ) { <END_VULN> mcrypt_generic_deinit ( pm -> td ) ; mcrypt_module_close ( pm -> td ) ; efree ( pm ) ;
#include < memory> #include "componentssearch_provider_logoslogo_common . h" <START_VULN> #include "componentssearch_provider_logoslogo_service . h"<END_VULN> #include "third_partyskiaincludecoreSkBitmap . h"
if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) { <START_VULN> if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) | | <END_VULN> ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) { if ( snprintf ( scratch , scratch_len , "Host : % s : % ir" , resource -> host , resource -> port ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ;
continue ; } } else { <START_VULN> NEED_OP ( t ) ; <END_VULN> do { * op ++ = * m_pos ++ ; } while ( op < oe ) ;
} } <START_VULN> static inline int _setEdgePixel ( const gdImagePtr src , unsigned int x , unsigned int y , gdFixed coverage , const int bgColor ) <END_VULN> { const gdFixed f_127 = gd_itofx ( 127 ) ; register int c = src -> tpixels [ y ] [ x ] ;
nsIFile ** aDirectory ) const ; nsresult EnsureOriginIsInitialized ( const nsACString & aOrigin , bool aTrackQuota , nsIFile ** aDirectory ) ; void <START_VULN> UninitializeOriginsByPattern ( const nsACString & aPattern ) ; <END_VULN> nsIThread * IOThread ( ) { NS_ASSERTION ( mIOThread , "This should never be null ! " ) ; return mIOThread ; }
if ( pc -> refresh_entropy_probs == 0 ) { <START_VULN> vpx_memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ; <END_VULN> pbi -> independent_partitions = prev_independent_partitions ; }
{ int flag [ 2 ] = { 1 , 1 } ; vp8_initialize_rd_consts ( cpi , x , vp8_dc_quant ( cm -> base_qindex , cm -> y1dc_delta_q ) ) ; <START_VULN> vpx_memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <END_VULN> vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cm -> fc . mvc , flag ) ; }
entry . manifest_pos = manifest_index ; } <START_VULN> if ( entry . filename_len + 20 > endbuffer - buffer ) { <END_VULN> MAPPHAR_FAIL ( "internal corruption of phar " % s" ( truncated manifest entry ) " ) ; }
random_32 ( void ) { <START_VULN> for ( ; ; ) <END_VULN> { png_byte mark [ 4 ] ; png_uint_32 result ;
this_mv . as_mv . row = br + neighbors [ i ] . row ; this_mv . as_mv . col = bc + neighbors [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <END_VULN> CHECK_BETTER } } else
ThrowImageException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels_info = AcquireVirtualMemory ( 3 * image -> columns , image -> rows * sizeof ( * pixels ) ) ; <START_VULN> kernel = ( float * ) AcquireQuantumMemory ( MagickMax ( image -> rows , image -> columns ) , <END_VULN> GetOpenMPMaximumThreads ( ) * sizeof ( * kernel ) ) ; if ( ( pixels_info == ( MemoryInfo * ) NULL ) | | ( kernel == ( float * ) NULL ) ) {
else MB_FAILURE ( pos , 4 ) ; } <START_VULN> <END_VULN> this_char = ( ( c & 0x07 ) << 18 ) | ( ( str [ pos + 1 ] & 0x3f ) << 12 ) | ( ( str [ pos + 2 ] & 0x3f ) << 6 ) | ( str [ pos + 3 ] & 0x3f ) ; if ( this_char < 0x10000 | | this_char > 0x10FFFF ) { MB_FAILURE ( pos , 4 ) ;
} #endif <START_VULN> #endif<END_VULN> #endif
#else png_fixed_point res ; <START_VULN> if ( png_muldiv ( & res , 100000 , 100000 , a ) ) <END_VULN> return res ; #endif
u_charar_tha [ ] ; u_charar_tpa [ ] ; #endif <START_VULN> #define ar_sha ( ap ) ( ( ( const u_char * ) ( ( ap ) + 1 ) ) + 0 ) <END_VULN> #define ar_spa ( ap ) ( ( ( const u_char * ) ( ( ap ) + 1 ) ) + ( ap ) -> ar_hln ) #define ar_tha ( ap ) ( ( ( const u_char * ) ( ( ap ) + 1 ) ) + ( ap ) -> ar_hln + ( ap ) -> ar_pln ) #define ar_tpa ( ap ) ( ( ( const u_char * ) ( ( ap ) + 1 ) ) + 2 * ( ap ) -> ar_hln + ( ap ) -> ar_pln )
#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED <START_VULN> if ( png_ptr -> transformations ) <END_VULN> png_do_write_transformations ( png_ptr , & row_info ) ; #endif
u8 * out_buf ; int ret ; if ( buf [ 0 ] != REPORT_TYPE_LEDS ) return - EINVAL ; out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ) ; if ( ! out_buf ) return - ENOMEM ; <START_VULN> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <END_VULN> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ; out_buf [ 1 ] = djdev -> device_index ; memcpy ( out_buf + 2 , buf , count ) ; ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ) ; kfree ( out_buf ) ;
status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { <START_VULN> image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0 . 5 ) ; <END_VULN> image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0 . 5 ) ; } else
~ RenderFrameDevToolsAgentHost ( ) override ; <START_VULN> void AttachSession ( DevToolsSession * session ) override ; <END_VULN> void DetachSession ( DevToolsSession * session ) override ; void InspectElement ( RenderFrameHost * frame_host , int x , int y ) override ; void DispatchProtocolMessage ( DevToolsSession * session ,
{ "Trapped" , "" } , } ; <START_VULN> daddy = malloc ( sizeof ( creator_template ) ) ; <END_VULN> memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ; if ( n_elements )
unsigned __int64 __rdtsc ( void ) ; #pragma intrinsic ( __rdtsc ) #endif <START_VULN> static unsigned int<END_VULN> x86_readtsc ( void ) { #if defined ( __GNUC__ ) && __GNUC__ unsigned int tsc ;
} for ( r = 0 ; r < h ; ++ r ) { <START_VULN> size_t needed = w ; <END_VULN> size_t buf_position = 0 ; const size_t left = detect -> buf_read - detect -> position ; if ( left > 0 ) {
args = mprCreateHash ( 0 , MPR_HASH_STABLE ) ; list = stolist ( remedyArgs ) ; for ( ITERATE_ITEMS ( list , arg , next ) ) { <START_VULN> key = stok ( arg , " = " , & value ) ; <END_VULN> mprAddKey ( args , key , strim ( value , ""'" , 0 ) ) ; } if ( ! remedy ) {
phar_flush ( phar_obj -> arc . archive , NULL , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
{ case MGT_FRAME : dissect_ieee80211_mgt ( fcf , next_tvb , pinfo , tree ) ; break ; case DATA_FRAME : if ( is_amsdu && tvb_reported_length_remaining ( next_tvb , 0 ) > 4 ) { tvbuff_t * volatile msdu_tvb = NULL ; guint32 msdu_offset = 0 ; <START_VULN> guint16 i = 1 ; <END_VULN> const guint8 * lcl_src = NULL ; const guint8 * lcl_dst = NULL ; guint16 msdu_length ; proto_item * parent_item ; proto_tree * mpdu_tree ; proto_tree * subframe_tree ; parent_item = proto_tree_add_protocol_format ( tree , proto_aggregate , next_tvb , 0 , tvb_reported_length_remaining ( next_tvb , 0 ) , "IEEE 802 . 11 Aggregate MSDU" ) ; mpdu_tree = proto_item_add_subtree ( parent_item , ett_msdu_aggregation_parent_tree ) ;
#include "coredomActiveDOMObject . h" #include "coreeventsEventTarget . h" #include "coreplatformmediastreamMediaStreamDescriptor . h" <START_VULN> #include "coreplatformmediastreamMediaStreamSource . h"<END_VULN> #include "modulesmediastreamSourceInfo . h" #include "wtfRefCounted . h" #include "wtfRefPtr . h" #include "wtfVector . h"
#if 0 <START_VULN> if ( png_image_begin_read_from_file ( & image , argv [ 1 ] ) ) <END_VULN> { png_bytep buffer ;
{ spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; int skip_dots = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_SKIPDOTS ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
<START_VULN> if ( png_get_valid ( png_ptr , info_ptr , PNG_INFO_sBIT ) ) <END_VULN> { png_color_8p sig_bit_p ;
struct net_device * dev ; struct sock * sk = sock -> sk ; if ( peer ) return - EOPNOTSUPP ; uaddr -> sa_family = AF_PACKET ; rcu_read_lock ( ) ; dev = dev_get_by_index_rcu ( sock_net ( sk ) , pkt_sk ( sk ) -> ifindex ) ; if ( dev ) <START_VULN> strlcpy ( uaddr -> sa_data , dev -> name , 15 ) ; <END_VULN> else memset ( uaddr -> sa_data , 0 , 14 ) ; rcu_read_unlock ( ) ; * uaddr_len = sizeof ( * uaddr ) ; return 0 ; }
union YYSTYPE { <START_VULN> #line 73 "re_grammar . y"<END_VULN> int integer ; uint32_t range ;
<START_VULN> vpx_memset ( ( & oci -> post_proc_buffer_int ) -> buffer_alloc , 128 , ( & oci -> post_proc_buffer ) -> frame_size ) ; <END_VULN> } }
case FILE_BEQDATE : case FILE_LEQDATE : if ( file_printf ( ms , F ( ms , m , " % s" ) , <START_VULN> file_fmttime ( p -> q , FILE_T_LOCAL , tbuf ) ) == - 1 ) <END_VULN> return - 1 ; t = ms -> offset + sizeof ( uint64_t ) ; break ;
int * sortpointer [ VIF_POSIT + 2 ] ; vorbis_info_floor1 * info = ( vorbis_info_floor1 * ) in ; vorbis_look_floor1 * look = _ogg_calloc ( 1 , sizeof ( * look ) ) ; int i , j , n = 0 ; look -> vi = info ; look -> n = info -> postlist [ 1 ] ; <START_VULN> <END_VULN> for ( i = 0 ; i < info -> partitions ; i ++ ) n += info -> class_dim [ info -> partitionclass [ i ] ] ;
spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; char * path ; int path_len ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
hao -> ip6hao_len = ip6_optlen ; if ( ip6_optlen < sizeof ( hao -> ip6hao_hoa ) ) { <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <END_VULN> break ; }
explicit DevToolsDomainHandler ( const std : : string & name ) ; virtual ~ DevToolsDomainHandler ( ) ; <START_VULN> virtual void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) ; virtual void Wire ( UberDispatcher * dispatcher ) ; virtual Response Disable ( ) ;
int insn_get_code_seg_params ( struct pt_regs * regs ) { <START_VULN> struct desc_struct * desc ; <END_VULN> short sel ; if ( v8086_mode ( regs ) )
} #endif <START_VULN> vpx_memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ; <END_VULN> pbi -> frame_corrupt_residual = 0 ; #if CONFIG_MULTITHREAD
smart_str_free ( & eval_buf ) ; if ( err <= - 2 ) { <START_VULN> smart_str_free ( & out_buf ) ; <END_VULN> RETVAL_FALSE ; } else { smart_str_appendc ( & out_buf , '0' ) ;
} #define mem_get_s_generic ( end , sz ) <START_VULN> static signed MEM_VALUE_T mem_get_s##end##sz ( const void * vmem ) { <END_VULN> const MAU_T * mem = ( const MAU_T * ) vmem ; signed MEM_VALUE_T val = mem_get_##end##sz ( mem ) ; return ( val << ( MEM_VALUE_T_SZ_BITS - sz ) ) >> ( MEM_VALUE_T_SZ_BITS - sz ) ;
#include < arm_neon . h> <START_VULN> static const uint16_t bifilter4_coeff [ 8 ] [ 2 ] = { <END_VULN> { 128 , 0 } , { 112 , 16 } , { 96 , 32 } ,
} static void perf_swevent_event ( struct perf_event * event , u64 nr , <START_VULN> int nmi , struct perf_sample_data * data , <END_VULN> struct pt_regs * regs ) { struct hw_perf_event * hwc = & event -> hw ;
switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( decopts , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case OPT_MAXSIZE : <START_VULN> opts -> max_size = atoi ( jas_tvparser_getval ( tvp ) ) ; <END_VULN> break ; default : jas_eprintf ( "warning : ignoring invalid option % s" ,
static const char * exec_name ; <START_VULN> void usage_exit ( ) { <END_VULN> fprintf ( stderr , "Usage : % s < infile> < outfile>" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
} static vpx_codec_err_t ctrl_set_scale_mode ( vpx_codec_alg_priv_t * ctx , <START_VULN> int ctr_id , va_list args ) { <END_VULN> vpx_scaling_mode_t * const mode = va_arg ( args , vpx_scaling_mode_t * ) ; if ( mode ) {
png_ptr -> idat_size = png_ptr -> push_length ; } <START_VULN> if ( png_ptr -> idat_size && png_ptr -> save_buffer_size ) <END_VULN> { png_size_t save_size = png_ptr -> save_buffer_size ; png_uint_32 idat_size = png_ptr -> idat_size ;
T * array = reinterpret_cast < T * > ( self ) ; blink : : HeapObjectHeader * header = blink : : HeapObjectHeader : : fromPayload ( self ) ; <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <END_VULN> size_t length = header -> payloadSize ( ) sizeof ( T ) ;
wddx_stack_top ( stack , ( void ** ) & ent2 ) ; <START_VULN> if ( ent2 -> type == ST_FIELD && ent2 -> data == NULL ) { <END_VULN> zval_ptr_dtor ( & ent1 -> data ) ; efree ( ent1 ) ; return ;
#if defined ( CONFIG_POST ) <START_VULN> #define SELFTEST_PORTGPIO_A<END_VULN> #define SELFTEST_PIN31 int post_hotkeys_pressed ( void )
r = sc_read_record ( card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , "read document number failed" ) ; <START_VULN> buff [ r ] = '0' ; <END_VULN> set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ; p15card -> tokeninfo -> flags = SC_PKCS15_TOKEN_PRN_GENERATION
} <START_VULN> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <END_VULN> { jas_stream_t * in ; jas_iccprof_t * prof ;
class SearchProvider : public AutocompleteProvider , public net : : URLFetcherDelegate { public : <START_VULN> SearchProvider ( ACProviderListener * listener , Profile * profile ) ; <END_VULN> #if defined ( UNIT_TEST ) static void set_query_suggest_immediately ( bool value ) {
int2store ( buffer , ( unsigned int ) option ) ; ret = conn -> m -> simple_command ( conn , COM_SET_OPTION , buffer , sizeof ( buffer ) , PROT_EOF_PACKET , FALSE , TRUE TSRMLS_CC ) ; <START_VULN> <END_VULN> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; } DBG_RETURN ( ret ) ;
} static void perf_swevent_overflow ( struct perf_event * event , u64 overflow , <START_VULN> int nmi , struct perf_sample_data * data , <END_VULN> struct pt_regs * regs ) { struct hw_perf_event * hwc = & event -> hw ;
fault = handle_mm_fault ( mm , vma , address , write ? FAULT_FLAG_WRITE : 0 ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> if ( unlikely ( fault & VM_FAULT_ERROR ) ) { if ( fault & VM_FAULT_OOM ) goto out_of_memory ;
} if ( BImgBuff ) <START_VULN> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; <END_VULN> break ; } case 1 :
if ( png_muldiv ( & res , ( png_int_32 ) info_ptr -> y_pixels_per_unit , PNG_FP_1 , <START_VULN> ( png_int_32 ) info_ptr -> x_pixels_per_unit ) ) <END_VULN> return res ; } #else
{ struct crypto_report_comp rcomp ; <START_VULN> strlcpy ( rcomp . type , "compression" , sizeof ( rcomp . type ) ) ; <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ;
override ; net : : NetLog * GetNetLog ( ) override ; DevToolsManagerDelegate * GetDevToolsManagerDelegate ( ) override ; <START_VULN> void OpenURL ( BrowserContext * browser_context , <END_VULN> const OpenURLParams & params , const base : : Callback < void ( WebContents * ) > & callback ) override ; scoped_refptr < LoginDelegate> CreateLoginDelegate (
} #endif <START_VULN> <END_VULN> #ifdef PNG_SET_OPTION_SUPPORTED int PNGAPI png_set_option ( png_structrp png_ptr , int option , int onoff )
{ png_debug ( 1 , "in png_set_expand_gray_1_2_4_to_8" ) ; <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <END_VULN> return ; png_ptr -> transformations |= PNG_EXPAND ;
static void smtp_log_to_file ( smtp_t * smtp ) { <START_VULN> FILE * fp = fopen ( "tmpsmtp - alert . log" , "a" ) ; <END_VULN> time_t now ; struct tm tm ; char time_buf [ 25 ] ;
int pass ; int usage ; int deadline ; <START_VULN> int use_i420 ; <END_VULN> int quiet ; int verbose ; int limit ;
return 0 ; } <START_VULN> n = recv ( fd , p_buf + n_read , len - n_read , 0 ) ; <END_VULN>
_analysis_output ( "mask0" , seq , logmask , n2 , 1 , 0 , 0 ) ; } #endif floor_posts [ i ] [ 0 ] = floor1_fit ( vb , b -> flr [ info -> floorsubmap [ submap ] ] , logmdct , logmask ) ; <START_VULN> <END_VULN> for ( k = 1 ; k < PACKETBLOBS2 ; k ++ ) floor_posts [ i ] [ k ] = floor1_interpolate_fit ( vb , b -> flr [ info -> floorsubmap [ submap ] ] , floor_posts [ i ] [ 0 ] , floor_posts [ i ] [ PACKETBLOBS2 ] , k * 65536 ( PACKETBLOBS2 ) ) ;
<START_VULN> <END_VULN> #include "vpx_scalevpx_scale . h" #include "vpx_memvpx_mem . h"
void InlineWebstoreInstall ( int install_id , std : : string webstore_item_id , <START_VULN> GURL requestor_url ) ; <END_VULN> int browser_window_id ( ) const { return browser_window_id_ ; } content : : ViewType view_type ( ) const { return view_type_ ; }
extern struct jump_label_key perf_swevent_enabled [ PERF_COUNT_SW_MAX ] ; <START_VULN> extern void __perf_sw_event ( u32 , u64 , int , struct pt_regs * , u64 ) ; <END_VULN> #ifndef perf_arch_fetch_caller_regs static inline void perf_arch_fetch_caller_regs ( struct pt_regs * regs , unsigned long ip ) { }
if ( cm -> refresh_entropy_probs == 0 ) { <START_VULN> vpx_memcpy ( & cm -> lfc , & cm -> fc , sizeof ( cm -> fc ) ) ; <END_VULN> } vp8_update_coef_context ( cpi ) ;
ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ; } <START_VULN> <END_VULN> } if ( is_udp4 ) { if ( inet -> cmsg_flags )
#endif } } <START_VULN> #endif<END_VULN> #if defined ( PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED ) | | defined ( PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED )
yych = * ++ YYCURSOR ; if ( yych != ' ; ' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 585 "extstandardvar_unserializer . re"<END_VULN> { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ;
int dbg_color_b_modes_flag ; int dbg_display_mv_flag ; #endif <START_VULN> vp8_decrypt_cb * decrypt_cb ; <END_VULN> void * decrypt_state ; vpx_image_t img ; int img_setup ;
{ struct crypto_report_acomp racomp ; <START_VULN> strlcpy ( racomp . type , "acomp" , sizeof ( racomp . type ) ) ; <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , sizeof ( struct crypto_report_acomp ) , & racomp ) )
bdt_log ( "Bluetooth is already enabled" ) ; return ; } <START_VULN> status = sBtInterface -> enable ( ) ; <END_VULN> check_return_status ( status ) ; }
status = 0 ; goto done ; } <START_VULN> if ( colb + tilew > imagew ) { <END_VULN> uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb ,
friend class base : : RefCountedThreadSafe < SSLErrorHandler> ; <START_VULN> SSLErrorHandler ( base : : WeakPtr < Delegate> delegate , <END_VULN> const content : : GlobalRequestID & id , ResourceType : : Type resource_type , const GURL & url ,
} ; template < > struct APIClientTraits < WKBundlePageLoaderClient> { <START_VULN> static const size_t interfaceSizesByVersion [ 3 ] ; <END_VULN> } ; template < > struct APIClientTraits < WKBundlePageResourceLoadClient> {
replen = revcode ; collen = 0 ; } <START_VULN> while ( collen > 0 ) <END_VULN> { x = CVAL ( in ) ; if ( x & 1 )
#define char_to_int ( p ) ( p - '0' ) #define OSSL_MAX ( p , q ) ( ( p > = q ) ? p : q ) <START_VULN> static void<END_VULN> _dopr ( char ** sbuffer , char ** buffer , size_t * maxlen ,
balloon_stats . schedule_delay = 1 ; balloon_stats . max_schedule_delay = 32 ; balloon_stats . retry_count = 1 ; <START_VULN> balloon_stats . max_retry_count = RETRY_UNLIMITED ; <END_VULN> #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG set_online_page_callback ( & xen_online_page ) ;
case MESSAGE_UPDATE : { if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , " update" ) ) ; <START_VULN> if ( len < 1 ) <END_VULN> ND_PRINT ( ( ndo , "truncated" ) ) ; else ND_PRINT ( ( ndo , " % s % s % s" ,
#define FileInputType_h #include "coreCoreExport . h" <START_VULN> #include "corehtmlformsBaseClickableWithKeyInputType . h"<END_VULN> #include "corehtmlformsInputType . h" #include "platformFileChooser . h" #include "platformheapHandle . h" #include "wtfRefPtr . h"
bool mDroppedDown ; bool mInRedisplayText ; bool mDelayedShowDropDown ; <START_VULN> static nsComboboxControlFrame * mFocused ; <END_VULN> #ifdef DO_REFLOW_COUNTER PRInt32 mReflowId ; #endif } ; #endif
} <START_VULN> static void phar_file_stat ( const char * filename , php_stat_len filename_length , int type , void ( * orig_stat_func ) ( INTERNAL_FUNCTION_PARAMETERS ) , INTERNAL_FUNCTION_PARAMETERS ) <END_VULN> { if ( ! filename_length ) { RETURN_FALSE ;
private : <START_VULN> void OnDecode ( base : : SharedMemoryHandle handle , int32 id , int32 size ) ; <END_VULN> void OnAssignPictureBuffers ( const std : : vector < int32> & buffer_ids , const std : : vector < uint32> & texture_ids ,
{ MsgToEventLog ( M_SYSERR , TEXT ( "malloc failed" ) ) ; ReturnLastError ( pipe , L"malloc" ) ; <START_VULN> goto out ; <END_VULN> } read = ReadPipeAsync ( pipe , data , bytes , 1 , & exit_event ) ;
if ( regs && ! perf_exclude_event ( event , regs ) ) { if ( ! ( event -> attr . exclude_idle && current -> pid == 0 ) ) <START_VULN> if ( perf_event_overflow ( event , 0 , & data , regs ) ) <END_VULN> ret = HRTIMER_NORESTART ; }
ND_PRINT ( ( ndo , " ) " ) ) ; } } <START_VULN> return hdrlen + 2 + len ; <END_VULN> default : return - 1 ; }
. open = ftrace_filter_open , . read = seq_read , . write = ftrace_filter_write , <START_VULN> . llseek = ftrace_regex_lseek , <END_VULN> . release = ftrace_regex_release , } ;
#if defined ( PNG_READ_BACKGROUND_SUPPORTED ) | | defined ( PNG_READ_ALPHA_MODE_SUPPORTED ) | | defined ( PNG_READ_RGB_TO_GRAY_SUPPORTED ) <START_VULN> if ( png_ptr -> transformations & ( PNG_COMPOSE | PNG_RGB_TO_GRAY ) ) <END_VULN> { png_build_16bit_table ( png_ptr , & png_ptr -> gamma_16_to_1 , shift , png_reciprocal ( png_ptr -> colorspace . gamma ) ) ;
virtual void setTextFromItem ( unsigned listIndex ) = 0 ; virtual void listBoxSelectItem ( int , bool , bool , bool = true ) { ASSERT_NOT_REACHED ( ) ; } <START_VULN> virtual bool multiple ( ) <END_VULN> { ASSERT_NOT_REACHED ( ) ; return false ;
return err ; } <START_VULN> int check_fragments_for_errors ( VP8D_COMP * pbi ) <END_VULN> { if ( ! pbi -> ec_active && pbi -> fragments . count <= 1 && pbi -> fragments . sizes [ 0 ] == 0 )
} <START_VULN> cert_sig = sig_verify ( ctx , cert -> signature , cert -> sig_len , <END_VULN> bi_clone ( ctx , mod ) , bi_clone ( ctx , expn ) ) ; if ( cert_sig && cert -> digest )
return ; trunc : <START_VULN> ND_PRINT ( ( ndo , " [ | icmp6 ] " ) ) ; <END_VULN> }
class MockConnectionVisitor : public QuicConnectionVisitorInterface { public : MockConnectionVisitor ( ) ; <START_VULN> ~ MockConnectionVisitor ( ) ; <END_VULN> MOCK_METHOD4 ( OnPacket , bool ( const IPEndPoint & self_address , const IPEndPoint & peer_address , const QuicPacketHeader & header ,
} offset = skb -> csum_start - skb_headroom ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; <START_VULN> if ( ( skb_headroom ( skb ) < frag_hdr_sz ) && <END_VULN> pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header ( skb ) ;
extern const base : : Feature kAffiliationBasedMatching ; extern const base : : Feature kHtmlBasedUsernameDetector ; <START_VULN> extern const base : : Feature kEnableManualFallbacksFilling ; <END_VULN> extern const base : : Feature kEnableManualFallbacksFillingStandalone ; extern const base : : Feature kEnableManualFallbacksGeneration ; extern const base : : Feature kEnableManualPasswordGeneration ;
virtual mozilla : : dom : : EventTarget * GetParentTarget ( ) MOZ_OVERRIDE { return mParent ; } virtual nsIDOMWindow * GetOwnerGlobal ( ) MOZ_OVERRIDE ; NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS ( nsWindowRoot , nsIDOMEventTarget ) protected : <START_VULN> nsPIDOMWindow * mWindow ; <END_VULN> nsRefPtr < nsEventListenerManager> mListenerManager ; nsCOMPtr < nsIDOMNode> mPopupNode ; nsCOMPtr < mozilla : : dom : : EventTarget> mParent ; } ;
} <START_VULN> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ; <END_VULN> if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ;
if ( fp < 0 ) <START_VULN> * ascii ++ = 45 , -- size , num = - fp ; <END_VULN> else num = fp ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : LPC low level routines <START_VULN> last mod : $ Id : lpc . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN>
printf ( " ] ( % llu ) " , ddword_tmp ) ; break ; case PT_LONG : <START_VULN> printf ( " Value : % li" , * ( ( long * ) mapidata -> data ) ) ; <END_VULN> break ; case PT_I2 : printf ( " Value : % hi" , * ( ( short int * ) mapidata -> data ) ) ;
return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE ; } <START_VULN> return 0 ; <END_VULN> } static krb5_error_code
x1ul = x1 - half ; y1ul = y1 - half ; <START_VULN> <END_VULN> x2lr = x2 + half ; y2lr = y2 + half ;
@param . . . Variable arguments to format @return Returns the number of bytes written @ingroup MprString <START_VULN> @stability Evolving<END_VULN> PUBLIC ssize mprEprintf ( cchar * fmt , . . . ) PRINTF_ATTRIBUTE ( 1 , 2 ) ;
ALOGV ( "Downmix_Command EFFECT_CMD_SET_PARAM cmdSize % d pCmdData % p , * replySize % " PRIu32 " , pReplyData % p" , cmdSize , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL | | ( cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ) <START_VULN> | | pReplyData == NULL | | * replySize != ( int ) sizeof ( int32_t ) ) { <END_VULN> return - EINVAL ; } effect_param_t * cmd = ( effect_param_t * ) pCmdData ;
WORD32 ihevcd_ref_list ( codec_t * ps_codec , pps_t * ps_pps , sps_t * ps_sps , slice_header_t * ps_slice_hdr ) { <START_VULN> WORD32 i ; <END_VULN> WORD32 st_rps_idx ; WORD32 num_neg_pics , num_pos_pics ; WORD8 * pi1_used ;
in [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; } <START_VULN> void fadst16_8col ( __m128i * in ) { <END_VULN> __m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ; const __m128i k__cospi_p01_p31 = pair_set_epi16 ( cospi_1_64 , cospi_31_64 ) ;
} sock_cmd_t cmd = { CMD_REMOVE_FD , fd , 0 , 0 , 0 } ; <START_VULN> return send ( ts [ thread_handle ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <END_VULN> } int btsock_thread_post_cmd ( int h , int type , const unsigned char * data , int size , uint32_t user_id )
break ; case SIP_UPDATE : res = handle_request_update ( p , req ) ; break ; case SIP_ACK : if ( seqno == p -> pendinginvite ) { p -> invitestate = INV_TERMINATED ; p -> pendinginvite = 0 ; acked = __sip_ack ( p , seqno , 1 , 0 ) ; <START_VULN> if ( find_sdp ( req ) ) { <END_VULN> if ( process_sdp ( p , req , SDP_T38_NONE ) ) { return - 1 ; } if ( ast_test_flag ( & p -> flags [ 0 ] , SIP_DIRECT_MEDIA ) ) { ast_queue_control ( p -> owner , AST_CONTROL_SRCCHANGE ) ; } } check_pendings ( p ) ; } else if ( p -> glareinvite == seqno ) {
<START_VULN> const vp9_prob vp9_pareto8_full [ COEFF_PROB_MODELS ] [ MODEL_NODES ] = { <END_VULN> { 3 , 86 , 128 , 6 , 86 , 23 , 88 , 29 } , { 6 , 86 , 128 , 11 , 87 , 42 , 91 , 52 } , { 9 , 86 , 129 , 17 , 88 , 61 , 94 , 76 } ,
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : LSP ( also called LSF ) conversion routines <START_VULN> last mod : $ Id : lsp . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> The LSP generation code is taken ( with minimal modification and a few bugfixes ) from "On the Computation of the LSP Frequencies" by Joseph Rothweiler ( see http : The paper is available at : http :
if ( use_y4m && ! noblit ) { if ( ! single_file ) { fprintf ( stderr , "YUV4MPEG2 not supported with output patterns , " <START_VULN> " try -- i420 or -- yv12 . " ) ; <END_VULN> return EXIT_FAILURE ; }
if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) return ; <START_VULN> if ( perf_event_overflow ( event , 0 , data , regs ) ) <END_VULN> mipspmu -> disable_event ( idx ) ; }
png_read_data ( png_ptr , & ( info_ptr -> signature [ num_checked ] ) , num_to_check ) ; png_ptr -> sig_bytes = 8 ; <START_VULN> if ( png_sig_cmp ( info_ptr -> signature , num_checked , num_to_check ) ) <END_VULN> { if ( num_checked < 4 && png_sig_cmp ( info_ptr -> signature , num_checked , num_to_check - 4 ) )
res = read_block ( fd , id_index_table [ i ] , NULL , expected , ( ( char * ) id_table ) + i * SQUASHFS_METADATA_SIZE ) ; if ( res == FALSE ) { <START_VULN> ERROR ( "read_uids_guids : failed to read id table block"<END_VULN> "" ) ; return FALSE ; }
local_irq_enable ( ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <END_VULN>
#include " . vpx_integer . h" <START_VULN> #define VPX_MAXIMUM_WORK_BUFFERS 1<END_VULN>
<START_VULN> if ( poll ( & pfd , 1 , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) == 0 ) <END_VULN> { BTIF_TRACE_EVENT ( "poll timeout ( % d ms ) " , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) ; break ;
<START_VULN> * <END_VULN> *
png_crc_read ( png_ptr , buf , 7 ) ; <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <END_VULN> return ; mod_time . second = buf [ 6 ] ;
return 0 ; if ( uid_eq ( dir -> i_uid , fsuid ) ) return 0 ; <START_VULN> return ! inode_capable ( inode , CAP_FOWNER ) ; <END_VULN> }
file_name = make_file_name ( name , prog , namespace , instance ) ; <START_VULN> log_file = fopen ( file_name , "a" ) ; <END_VULN> if ( log_file ) { int n = fileno ( log_file ) ; fcntl ( n , F_SETFD , FD_CLOEXEC | fcntl ( n , F_GETFD ) ) ;
trunc : ND_PRINT ( ( ndo , " % s" , tstr ) ) ; <START_VULN> return ( mhlen ) ; <END_VULN> }
efree ( result ) ; } } <START_VULN> <END_VULN> zend_hash_move_forward ( Z_ARRVAL_PP ( subject ) ) ; } } else {
void ResetLoadingState ( ) ; <START_VULN> FeaturePolicy * get_feature_policy ( ) { return feature_policy_ . get ( ) ; } <END_VULN>
} <START_VULN> else if ( relaxed ) <END_VULN> { png_set_benign_errors ( read_ptr , 1 ) ;
} <START_VULN> static void pack_tokens_into_partitions_c ( VP8_COMP * cpi , unsigned char * cx_data , <END_VULN> unsigned char * cx_data_end , int num_part ) {
{ png_debug ( 1 , "in png_set_strip_alpha" ) ; <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <END_VULN> return ; png_ptr -> transformations |= PNG_STRIP_ALPHA ;
for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { <START_VULN> if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + <END_VULN> ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ;
* got_data = 0 ; while ( ( pkt = vpx_codec_get_cx_data ( & stream -> encoder , & iter ) ) ) { static size_t fsize = 0 ; <START_VULN> static off_t ivf_header_pos = 0 ; <END_VULN> switch ( pkt -> kind ) { case VPX_CODEC_CX_FRAME_PKT :
* ( dp ++ ) = red ; } <START_VULN> if ( have_alpha ) <END_VULN> * ( dp ++ ) = * ( sp ++ ) ; } }
return 1 ; } <START_VULN> void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <END_VULN> { if ( fields -> MaxLen < 1 ) fields -> MaxLen = fields -> Len ;
notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <START_VULN> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <END_VULN> log_message ( LOG_INFO , "Unable to open % snotify fifo % s - errno % d" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ;
<START_VULN> static InputMethodDescriptors * CreateInputMethodDescriptors ( ) ; <END_VULN> chromeos : : CrosLibrary : : TestApi * test_api ( ) ;
int work_batch_size_ ; <START_VULN> scoped_ptr < TimeSource> time_source_ ; <END_VULN> base : : ObserverList < base : : MessageLoop : : TaskObserver> task_observers_ ;
{ FILE * f ; <START_VULN> sprintf ( buf , " % s . conf" , set ) ; <END_VULN> if ( ( f = fopen ( buf , "r" ) ) == NULL ) { fprintf ( stderr , " % s : can't read conf file for charset % s" , prog , set ) ;
if ( ! slot ) goto out ; <START_VULN> int received = recv ( slot -> fd , buf , size , 0 ) ; <END_VULN> if ( received == size ) { ret = true ; } else {
add_assoc_long ( * subarray , "weight" , n ) ; GETSHORT ( n , cp ) ; add_assoc_long ( * subarray , "port" , n ) ; <START_VULN> n = dn_expand ( answer -> qb2 , answer -> qb2 + 65536 , cp , name , ( sizeof name ) - 2 ) ; <END_VULN> if ( n < 0 ) { return NULL ; }
threshold_image = CloneImage ( image , 0 , 0 , MagickTrue , exception ) ; if ( threshold_image == ( Image * ) NULL ) return ( ( Image * ) NULL ) ; <START_VULN> if ( width == 0 ) <END_VULN> return ( threshold_image ) ; if ( SetImageStorageClass ( threshold_image , DirectClass ) == MagickFalse ) {
<START_VULN> if ( detect_transition_to_still ( twopass , i , cpi -> key_frame_frequency - i , <END_VULN> loop_decay_rate , decay_accumulator ) ) break ;
~ ServiceWorkerHandler ( ) override ; void Wire ( UberDispatcher * dispatcher ) override ; <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) override ; Response Enable ( ) override ;
} <START_VULN> static inline realpath_cache_bucket * realpath_cache_find ( const char * path , int path_len , time_t t ) <END_VULN> { zend_ulong key = realpath_cache_key ( path , path_len ) ; zend_ulong n = key % ( sizeof ( CWDG ( realpath_cache ) ) sizeof ( CWDG ( realpath_cache ) [ 0 ] ) ) ;
headers = snclone ( content , data - content ) ; data += 2 ; for ( header = stok ( headers , "" , & tok ) ; header ; header = stok ( NULL , "" , & tok ) ) { <START_VULN> key = stok ( header , " : " , & value ) ; <END_VULN> if ( smatch ( key , "X - Status" ) ) { conn -> tx -> status = ( int ) stoi ( value ) ; } else {
v8 : : Isolate * isolate = scriptState -> isolate ( ) ; v8 : : TryCatch tryCatch ( isolate ) ; <START_VULN> v8 : : Local < v8 : : Object> creationContext ( scriptState -> context ( ) -> Global ( ) ) ; <END_VULN> v8 : : Local < v8 : : Function> v8Callback ( callback . v8Value ( ) . As < v8 : : Function> ( ) ) ; v8 : : Local < v8 : : Value> v8ThisArg ( thisArg . v8Value ( ) ) ; v8 : : Local < v8 : : Value> args [ 3 ] ;
{ 12 , 3 , 3 } , } ; <START_VULN> static const vp9_prob default_partition_probs [ PARTITION_CONTEXTS ] <END_VULN> [ PARTITION_TYPES - 1 ] = { { 199 , 122 , 141 } ,
intern -> u . file . open_mode = "wb" ; intern -> u . file . open_mode_len = 1 ; intern -> u . file . zcontext = NULL ; <START_VULN> <END_VULN> if ( spl_filesystem_file_open ( intern , 0 , 0 TSRMLS_CC ) == SUCCESS ) { intern -> _path_len = 0 ; intern -> _path = estrndup ( "" , 0 ) ;
<START_VULN> static PNG_CONST color_encoding test_encodings [ ] = <END_VULN> { { 12 . 2 ,
static void CVE_2012_4298_vwr_read_rec_data_ethernet ( wtap * wth , guint8 * data_ptr , guint8 * rec , int rec_size , int IS_TX ) { vwr_t * vwr = ( vwr_t * ) wth -> priv ; int bytes_written = 0 ; register int i ; register guint8 * s_ptr , * m_ptr ; <START_VULN> gint16 msdu_length , actual_octets ; <END_VULN> guint8 flow_seq ; guint64 s_time = LL_ZERO , e_time = LL_ZERO ; guint32 latency = 0 ; guint64 start_time , s_sec , s_usec = LL_ZERO ; guint64 end_time ; guint16 l4id , info , validityBits ; guint32 errors ; guint16 vc_id ; guint32 flow_id , d_time ;
nsresult InitClass ( const nsCString & aClassName , JSContext * aContext , JSObject * aGlobal , JSObject * aScriptObject , JSObject ** aClassObject ) ; nsresult ConstructInterfaceTable ( const nsAString & aImpls ) ; void SetImplementation ( nsXBLProtoImpl * aImpl ) { mImplementation = aImpl ; } <START_VULN> nsresult InstallImplementation ( nsIContent * aBoundElement ) ; <END_VULN> bool HasImplementation ( ) const { return mImplementation != nullptr ; } void AttributeChanged ( nsIAtom * aAttribute , int32_t aNameSpaceID , bool aRemoveFlag , nsIContent * aChangedElement , nsIContent * aAnonymousContent , bool aNotify ) ; void SetBasePrototype ( nsXBLPrototypeBinding * aBinding ) ; nsXBLPrototypeBinding * GetBasePrototype ( ) { return mBaseBinding ; }
for ( i = 0 ; i < no_tracks ; i ++ ) { running_event [ i ] = 0 ; do { <START_VULN> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <END_VULN> if ( setup_ret == 0 ) { goto _end ; }
} } <START_VULN> static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , <END_VULN> UINT32 scanline ) { nsc_encode_argb_to_aycocg_sse2 ( context , data , scanline ) ;
int ret ; while ( s ) { <START_VULN> do ret = send ( sock_fd , buf , s , 0 ) ; <END_VULN> while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) {
n = e -> band [ j ] . end ; e -> band [ j ] . window = _ogg_malloc ( n * sizeof ( * e -> band [ 0 ] . window ) ) ; for ( i = 0 ; i < n ; i ++ ) { e -> band [ j ] . window [ i ] = sin ( ( i + . 5 ) n * M_PI ) ; e -> band [ j ] . total += e -> band [ j ] . window [ i ] ; } e -> band [ j ] . total = 1 . e -> band [ j ] . total ; } <START_VULN> <END_VULN> e -> filter = _ogg_calloc ( VE_BANDS * ch , sizeof ( * e -> filter ) ) ; e -> mark = _ogg_calloc ( e -> storage , sizeof ( * e -> mark ) ) ; } void _ve_envelope_clear ( envelope_lookup * e ) { int i ; mdct_clear ( & e -> mdct ) ;
This is how the time string is formatted : snprintf ( p , sizeof ( p ) , " % 02d % 02d % 02d % 02d % 02d % 02dZ" , ts -> tm_year % 100 , <START_VULN> ts -> tm_mon + 1 , ts -> tm_mday , ts -> tm_hour , ts -> tm_min , ts -> tm_sec ) ; <END_VULN> time_t ret ;
vpx_release_frame_buffer_cb_fn_t cb_release , void * cb_priv ) { if ( cb_get == NULL | | cb_release == NULL ) { return VPX_CODEC_INVALID_PARAM ; <START_VULN> } else if ( ctx -> pbi == NULL ) { <END_VULN> ctx -> get_ext_fb_cb = cb_get ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : #ifdef jail to whip a few platforms into the UNIX ideal . <START_VULN> last mod : $ Id : os . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifdef HAVE_CONFIG_H #include "config . h" #endif #include < math . h>
bool Check ( ) const { if ( ! initialized_ ) return false ; int64_t post_store [ 8 ] ; <START_VULN> vp9_push_neon ( post_store ) ; <END_VULN> for ( int i = 0 ; i < 8 ; ++ i ) { EXPECT_EQ ( pre_store_ [ i ] , post_store [ i ] ) << "d" << i + 8 << " has been modified" ;
_y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I444 ; <START_VULN> _y4m -> vpx_bps = 24 ; <END_VULN> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ;
. open = ftrace_notrace_open , . read = seq_read , . write = ftrace_notrace_write , <START_VULN> . llseek = ftrace_regex_lseek , <END_VULN> . release = ftrace_regex_release , } ;
if ( s -> size - stream_ptr < n_blocks * 4 ) return ; while ( n_blocks -- ) { block_ptr = row_ptr + pixel_ptr ; for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { } <START_VULN> ADVANCE_BLOCK ( ) ; <END_VULN> } break ;
static INLINE void txfrm_block_to_raster_xy ( BLOCK_SIZE plane_bsize , TX_SIZE tx_size , int block , int * x , int * y ) { <START_VULN> const int bwl = b_width_log2 ( plane_bsize ) ; <END_VULN> const int tx_cols_log2 = bwl - tx_size ; const int tx_cols = 1 << tx_cols_log2 ; const int raster_mb = block >> ( tx_size << 1 ) ;
SPL_METHOD ( FilesystemIterator , current ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
} } <START_VULN> lf -> filter_level = filt_best ; <END_VULN> } void vp9_pick_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi ,
namespace content { class CertStore ; struct SSLStatus ; } class ChromeSSLHostStateDelegate ; <START_VULN> class InfoBarService ; <END_VULN> class HostContentSettingsMap ; class Profile ; class WebsiteSettingsUI ;
WEBKIT_EXPORT void skewX ( double angle ) ; WEBKIT_EXPORT void skewY ( double angle ) ; WEBKIT_EXPORT void applyPerspective ( double p ) ; <START_VULN> WEBKIT_EXPORT void blend ( const WebTransformationMatrix & from , double progress ) ; <END_VULN> WEBKIT_EXPORT bool hasPerspective ( ) const ; WEBKIT_EXPORT bool isInvertible ( ) const ;
} size_offsets = ( size_offsets + 1 ) * 3 ; offsets = ( int * ) safe_emalloc ( size_offsets , sizeof ( int ) , 0 ) ; <START_VULN> <END_VULN> array_init ( return_value ) ;
break ; } } <START_VULN> return 0 ; <END_VULN> case I_EOL : if ( * sp == 0 ) { pc = pc + 1 ;
uint8_t * buf ) { int steps ; if ( length == olength ) { <START_VULN> memcpy ( output , input , sizeof ( uint8_t ) * length ) ; <END_VULN> return ; } steps = get_down2_steps ( length , olength ) ;
jsvUnLock ( stringVar ) ; return l ; } else { <START_VULN> strncpy ( str , "" , len ) ; <END_VULN> jsExceptionHere ( JSET_INTERNALERROR , "Variable type cannot be converted to string" ) ; return 0 ; }
namespace blink { <START_VULN> class CSSCustomIdentValue : public CSSValue { <END_VULN> public : static CSSCustomIdentValue * Create ( const AtomicString & str ) { return new CSSCustomIdentValue ( str ) ;
{ int need_crc = 1 ; <START_VULN> if ( PNG_CHUNK_ANCILLARY ( png_ptr -> chunk_name ) ) <END_VULN> { if ( ( png_ptr -> flags & PNG_FLAG_CRC_ANCILLARY_MASK ) == ( PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN ) )
unsigned char buffer [ 4 ] ; <START_VULN> size_t<END_VULN> value ; if ( * length < 4 )
class ShellContentUtilityClient : public ContentUtilityClient { public : <START_VULN> ShellContentUtilityClient ( ) ; <END_VULN> ~ ShellContentUtilityClient ( ) override ;
if ( pc -> refresh_entropy_probs == 0 ) { <START_VULN> vpx_memcpy ( & cpi -> common . lfc , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <END_VULN> } vp8_update_coef_probs ( cpi ) ;
SAFE_E ( fread ( buf , 1 , 21 , fp ) , 21 , "Failed to load entry Size string . " ) ; xref -> n_entries = atoi ( buf + strlen ( "ize " ) ) ; <START_VULN> xref -> entries = calloc ( 1 , xref -> n_entries * sizeof ( struct _xref_entry ) ) ; <END_VULN> obj_id = 0 ;
return left + right ; } <START_VULN> void vp9_tree_probs_from_distribution ( vp9_tree tree , <END_VULN> unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ;
} <START_VULN> result = append_key_value ( loc_name , hash_arr , LOC_LANG_TAG ) ; <END_VULN> if ( result == LOC_NOT_FOUND ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "locale_compose : parameter array does not contain 'language' tag . " , 0 TSRMLS_CC ) ;
if ( subpats != NULL ) { <START_VULN> if ( pcre_get_substring_list ( subject , offsets , count , & stringlist ) < 0 ) { <END_VULN> efree ( subpat_names ) ; efree ( offsets ) ; if ( match_sets ) efree ( match_sets ) ;
void dump_mm ( const struct mm_struct * mm ) { <START_VULN> pr_emerg ( "mm % px mmap % px seqnum % d task_size % lu"<END_VULN> #ifdef CONFIG_MMU "get_unmapped_area % px" #endif
ra -> ip6ra_len = ip6_optlen ; if ( ip6_optlen < sizeof ( ra -> ip6ra_value ) ) { <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <END_VULN> break ; }
} <START_VULN> static int64_t<END_VULN> vpx_usec_timer_elapsed ( struct vpx_usec_timer * t ) { #if defined ( _WIN32 ) LARGE_INTEGER freq , diff ;
-- len_left ; * ( p ++ ) = '0' ; } <START_VULN> ++ len_req ; <END_VULN> if ( len < len_req ) { return len_req ; }
uhid_set_non_blocking ( p_dev -> fd ) ; while ( p_dev -> hh_keep_polling ) { <START_VULN> ret = poll ( pfds , 1 , 50 ) ; <END_VULN> if ( ret < 0 ) { APPL_TRACE_ERROR ( " % s : Cannot poll for fds : % s" , __FUNCTION__ , strerror ( errno ) ) ; break ;
} } else { if ( state -> space_before ) ruby_xfree ( state -> space_before ) ; <START_VULN> state -> space_before = strdup ( RSTRING_PTR ( space_before ) ) ; <END_VULN> state -> space_before_len = len ; } return Qnil ;
int err ; do { <START_VULN> err = nanosleep ( & delay , & delay ) ; <END_VULN> } while ( err == - 1 && errno == EINTR ) ; }
* ++ p2 = 0 ; if ( hdr ) * hdr = atom ; if ( val ) * val = p ; <START_VULN> SetHeader ( atom , nsDependentCString ( p , p2 - p ) , PR_TRUE ) ; <END_VULN> }
else if ( row_info -> bit_depth == 16 ) { <START_VULN> if ( at_start ) <END_VULN> sp += 2 ; else sp += 4 , dp += 2 ;
virtual unsigned int length ( ) const { return 1 ; } <START_VULN> bool isFloatingOrPositioned ( ) const { return ( isFloating ( ) | | isPositioned ( ) ) ; } <END_VULN> bool isTransparent ( ) const { return style ( ) -> opacity ( ) < 1 . 0f ; } float opacity ( ) const { return style ( ) -> opacity ( ) ; }
pc = pc + 1 ; break ; default : <START_VULN> return 0 ; <END_VULN> } } }
mojom : : SensorType type ) ; void SensorReaderCreated ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> const CreateSensorCallback & callback , std : : unique_ptr < PlatformSensorReaderWin> sensor_reader ) ;
{ u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) <START_VULN> return ERROR_INV_SPS_PPS_T ; <END_VULN> u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( "SH : redundant_pic_cnt" , u1_redundant_pic_cnt ) ; }
else lang_key_len = 0 ; } <START_VULN> # else<END_VULN> { png_chunk_report ( png_ptr , "iTXt chunk not supported" , PNG_CHUNK_WRITE_ERROR ) ;
if ( str [ 0 ] == ' ( ' ) { <START_VULN> ascii = malloc ( strlen ( str ) + 1 ) ; <END_VULN> strncpy ( ascii , str , strlen ( str ) + 1 ) ; return ascii ; }
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
unsigned int dest_width ) { ( void ) dest_pitch ; ( void ) src_pitch ; <START_VULN> vpx_memcpy ( dest , source , dest_width ) ; <END_VULN> } void vp8_vertical_band_2_1_scale_i_c ( unsigned char * source ,
#define ALLOCATE ( ptr , count , type ) { <START_VULN> ( ptr ) = H264SwDecMalloc ( ( count ) * sizeof ( type ) ) ; <END_VULN> }
return regs -> ARM_r0 ; case NR ( set_tls ) : <START_VULN> thread -> tp_value = regs -> ARM_r0 ; <END_VULN> if ( tls_emu ) return 0 ; if ( has_tls_reg ) {
First : no IPv4 options . <START_VULN> newinet -> opt = NULL ; <END_VULN> newnp -> rxopt . all = np -> rxopt . all ;
fReserved = false ; if ( count > preallocCount ) { fAllocCount = SkTMax ( count , kMinHeapAllocCount ) ; <START_VULN> fMemArray = sk_malloc_throw ( fAllocCount * sizeof ( T ) ) ; <END_VULN> fOwnMemory = true ; } else { fAllocCount = preallocCount ;
#define DESC_BUFFER_SIZE ( 8192 * 16 ) #ifdef _ANDROID_ <START_VULN> #define MAX_NUM_INPUT_OUTPUT_BUFFERS 32<END_VULN> #endif #ifdef _ION_HEAP_MASK_COMPATIBILITY_WA
png_chunk_benign_error ( png_const_structrp png_ptr , png_const_charp error_message ) { <START_VULN> if ( png_ptr -> flags & PNG_FLAG_BENIGN_ERRORS_WARN ) <END_VULN> png_chunk_warning ( png_ptr , error_message ) ; else
private : static bool StoreRegisters ( int64_t store [ 8 ] ) { <START_VULN> vp9_push_neon ( store ) ; <END_VULN> return true ; }
return - 1 ; } <START_VULN> return mount_entry_on_generic ( mntent , path ) ; <END_VULN> } static int mount_entry_on_relative_rootfs ( struct mntent * mntent ,
class RTCSessionDescriptionRequestImpl : public RTCSessionDescriptionRequest , public ActiveDOMObject { public : <START_VULN> static PassRefPtr < RTCSessionDescriptionRequestImpl> create ( ScriptExecutionContext * , PassRefPtr < RTCSessionDescriptionCallback> , PassRefPtr < RTCErrorCallback> ) ; <END_VULN> virtual ~ RTCSessionDescriptionRequestImpl ( ) ; virtual void requestSucceeded ( PassRefPtr < RTCSessionDescriptionDescriptor> ) OVERRIDE ;
const String & SourceText ( ) ; <START_VULN> AccessControlStatus CalculateAccessControlStatus ( ) const ; <END_VULN> private : class ScriptResourceFactory : public ResourceFactory {
Token currentToken ; unsigned lookahead ; Token lookaheadTokens [ maxLookahead ] ; } ; void advance ( size_t position ) ; void tell ( Position * ) ; void seek ( const Position & pos ) ; <START_VULN> void seek ( const Position & pos , const TokenStream & other ) ; <END_VULN> void positionAfterLastFunctionKeyword ( Position & pos ) ; size_t positionToOffset ( const Position & pos ) const { return pos . buf - userbuf . base ( ) ; } bool hasSourceMap ( ) const { return sourceMap != NULL ;
list_for_each_entry_safe ( tc , _tc , & rds_tcp_conn_list , t_tcp_node ) { struct net * c_net = read_pnet ( & tc -> t_cpath -> cp_conn -> c_net ) ; <START_VULN> if ( net != c_net | | ! tc -> t_sock ) <END_VULN> continue ; if ( ! list_has_conn ( & tmp_list , tc -> t_cpath -> cp_conn ) ) { list_move_tail ( & tc -> t_tcp_node , & tmp_list ) ;
if ( clone_info -> stroke_pattern != ( Image * ) NULL ) clone_info -> fill_pattern = CloneImage ( clone_info -> stroke_pattern , 0 , 0 , MagickTrue , exception ) ; <START_VULN> clone_info -> stroke . alpha = ( Quantum ) TransparentAlpha ; <END_VULN> clone_info -> stroke_width = 0 . 0 ; clone_info -> fill_rule = NonZeroRule ; status = MagickTrue ;
<START_VULN> bool OutputSlowerPlayback ( uint8 * dest ) ; <END_VULN> void ResetWindow ( ) ;
return ; #ifdef PNG_READ_INTERLACING_SUPPORTED <START_VULN> if ( png_ptr -> interlaced ) <END_VULN> { png_ptr -> row_number = 0 ; memset ( png_ptr -> prev_row , 0 , png_ptr -> rowbytes + 1 ) ;
if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "r" , & mcryptind ) == FAILURE ) { return ; } <START_VULN> ZEND_FETCH_RESOURCE ( pm , php_mcrypt * , & mcryptind , - 1 , "MCrypt" , le_mcrypt ) ; <END_VULN> #define MCRYPT_GET_MODE_DIR_ARGS ( DIRECTORY ) char * dir = NULL ;
virtual bool Send ( IPC : : Message * msg ) OVERRIDE ; <START_VULN> int peer_pid ( ) { return peer_pid_ ; } <END_VULN> IPC : : ChannelHandle channel_handle ( ) const { return channel_handle_ ; }
static std : : vector < NetworkHandler * > ForAgentHost ( DevToolsAgentHostImpl * host ) ; void Wire ( UberDispatcher * dispatcher ) override ; <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) override ; Response Enable ( Maybe < int> max_total_size ,
int from_kernel = ( regs -> tstate & TSTATE_PRIV ) != 0 ; unsigned long * reg ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <END_VULN> maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; reg = fetch_reg_addr ( rd , regs ) ;
vpx_decrypt_cb decrypt_cb , void * decrypt_state ) { int intra_only_flag = 0 ; <START_VULN> uint8_t clear_buffer [ 9 ] ; <END_VULN> if ( data + data_sz <= data ) return VPX_CODEC_INVALID_PARAM ;
BTIF_TRACE_DEBUG ( " % s : Sending hid report to kernel " "indicating lock key state 0x % x" , __FUNCTION__ , keylockstates ) ; <START_VULN> usleep ( 200000 ) ; <END_VULN> toggle_os_keylockstates ( p_dev -> fd , keylockstates ) ; } else
pidfile_write ( const char * pid_file , int pid ) { FILE * pidfile = NULL ; <START_VULN> int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <END_VULN> if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , "w" ) ;
#if ! defined ( LIBXSLT_STATIC ) #define XSLTPUBVAR __declspec ( dllimport ) extern #else <START_VULN> #define XSLTPUBVAR<END_VULN> #endif #endif #define XSLTCALL __cdecl
oggpack_write ( opb , 1 , 1 ) ; return ( 0 ) ; err_out : return ( - 1 ) ; } int vorbis_commentheader_out ( vorbis_comment * vc , <START_VULN> ogg_packet * op ) { <END_VULN> oggpack_buffer opb ; oggpack_writeinit ( & opb ) ; if ( _vorbis_pack_comment ( & opb , vc ) ) return OV_EIMPL ; op -> packet = _ogg_malloc ( oggpack_bytes ( & opb ) ) ; memcpy ( op -> packet , opb . buffer , oggpack_bytes ( & opb ) ) ;
} } break ; <START_VULN> } ; <END_VULN> #endif } else if ( best_address == in_what ) { ( * num00 ) ++ ;
bool startedFromUnelevatedUpdater = GetFileAttributesW ( elevatedLockFilePath ) != INVALID_FILE_ATTRIBUTES ; <START_VULN> if ( startedFromUnelevatedUpdater ) { <END_VULN> UACHelper : : DisablePrivileges ( nullptr ) ; } if ( updateLockFileHandle == INVALID_HANDLE_VALUE | | ( useService && testOnlyFallbackKeyExists && noServiceFallback ) ) { if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 ) { fprintf ( stderr , "Unable to create elevated lock file ! Exiting" ) ;
return - 1 ; } * delim = '0' ; <START_VULN> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <END_VULN> mutt_buffer_addstr ( buf , term ) ; mutt_buffer_addch ( buf , ' ' ) ;
& tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) , <START_VULN> krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ; <END_VULN> if ( ret ) goto out ;
smart_str_free ( & tmp1 ) ; smart_str_free ( & tmp2 ) ; php_info_print_table_end ( ) ; <START_VULN> <END_VULN> DISPLAY_INI_ENTRIES ( ) ; }
ret = x509_crt_verify_top ( crt , parent , ca_crl , profile , pathlen , selfsigned , flags , f_vrfy , p_vrfy ) ; if ( ret != 0 ) <START_VULN> return ( ret ) ; <END_VULN> } else {
if ( mem_get_le32 ( buf ) < 256 * 1024 * 1024 ) { for ( i = 0 ; i < get_vpx_decoder_count ( ) ; ++ i ) { const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ; <START_VULN> if ( ! vpx_codec_peek_stream_info ( decoder -> interface ( ) , <END_VULN> buf + 4 , 32 - 4 , & si ) ) { is_raw = 1 ; input -> fourcc = decoder -> fourcc ;
if ( ! strcmp ( ( char * ) name , EL_BINARY ) ) { zend_string * new_str = NULL ; <START_VULN> <END_VULN> if ( ZSTR_EMPTY_ALLOC ( ) != Z_STR ( ent1 -> data ) ) { new_str = php_base64_decode ( ( unsigned char * ) Z_STRVAL ( ent1 -> data ) , Z_STRLEN ( ent1 -> data ) ) ;
fstat ( fd , & sbuf ) ; if ( sbuf . st_size> = pCur -> nAlloc ) { <START_VULN> int nNew = sbuf . st_size * 2 ; <END_VULN> char * zNew ; if ( nNew < 1024 ) nNew = 1024 ;
* rp = table [ * rp ] ; } } <START_VULN> #endif<END_VULN> #if defined ( PNG_WRITE_FILLER_SUPPORTED ) | | defined ( PNG_READ_STRIP_ALPHA_SUPPORTED )
class PlatformSensorAndroid : public PlatformSensor { public : PlatformSensorAndroid ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> PlatformSensorProvider * provider , const base : : android : : JavaRef < jobject> & java_sensor ) ;
perf_event_header__init_id ( & task_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , <START_VULN> task_event -> event_id . header . size , 0 , 0 ) ; <END_VULN> if ( ret ) goto out ;
<START_VULN> Copyright ( c ) 2013 , The Linux Foundation . All rights reserved . <END_VULN> Redistribution and use in source and binary forms , with or without modification , are permitted provided that the following conditions are met :
#define B43_TXRING_SLOTS256 #define B43_RXRING_SLOTS64 <START_VULN> #define B43_DMA0_RX_BUFFERSIZEIEEE80211_MAX_FRAME_LEN<END_VULN> #define B43_DMA_PTR_POISON ( ( void * ) ERR_PTR ( - ENOMEM ) )
{ p -= 5 ; <START_VULN> if ( ! memcmp ( chunk_name , p , 4 ) ) <END_VULN> return p [ 4 ] ; } while ( p > p_end ) ;
} <START_VULN> stok ( sclone ( app -> controller ) , " - " , & plural ) ; <END_VULN> if ( plural ) { app -> table = sjoin ( app -> controller , plural , NULL ) ; } else {
} } if ( ctxt -> instate == XML_PARSER_EOF ) <START_VULN> return ; <END_VULN> SKIP_BLANKS ; if ( RAW != '>' ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_ENTITY_NOT_FINISHED ,
virtual void initialize ( WKContextRef contextRef = 0 , WKPageGroupRef pageGroupRef = 0 ) ; <START_VULN> virtual void onComponentComplete ( ) { } <END_VULN> virtual void enableMouseEvents ( ) { } virtual void disableMouseEvents ( ) { }
exit ( 1 ) ; } <START_VULN> if ( multiple ) <END_VULN> { int i ; #if defined ( PNG_USER_MEM_SUPPORTED ) && PNG_DEBUG
#define MediaStreamDescriptor_h #include "coreplatformmediastreamMediaStreamComponent . h" <START_VULN> #include "coreplatformmediastreamMediaStreamSource . h"<END_VULN> #include "wtfRefCounted . h" #include "wtfVector . h"
@param sp Socket object returned from #mprCreateSocket @return True if the socket has pending data to read or write . @ingroup MprSocket <START_VULN> @stability Prototype<END_VULN> PUBLIC bool mprSocketHasBuffered ( MprSocket * sp ) ;
{ FT_ASSERT ( cur [ 0 ] -> clazz ) ; <START_VULN> if ( cur [ 0 ] -> clazz -> get_interface ) <END_VULN> { result = cur [ 0 ] -> clazz -> get_interface ( cur [ 0 ] , service_id ) ; if ( result != NULL )
ast_rtp_codecs_payloads_copy ( & newtextrtp , ast_rtp_instance_get_codecs ( p -> trtp ) , p -> trtp ) ; } else { ast_rtp_instance_stop ( p -> trtp ) ; if ( debug ) ast_verbose ( "Peer doesn't provide T . 140" ) ; } } if ( p -> udptl ) { <START_VULN> if ( udptlportno > 0 ) { <END_VULN> if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_SYMMETRICRTP ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_UDPTL_DESTINATION ) ) { ast_rtp_instance_get_remote_address ( p -> rtp , isa ) ; if ( ! ast_sockaddr_isnull ( isa ) && debug ) { ast_debug ( 1 , "Peer T . 38 UDPTL is set behind NAT and with destination , destination address now % s" , ast_sockaddr_stringify ( isa ) ) ; } } ast_sockaddr_set_port ( isa , udptlportno ) ; ast_udptl_set_peer ( p -> udptl , isa ) ; if ( debug ) ast_debug ( 1 , "Peer T . 38 UDPTL is at port % s" , ast_sockaddr_stringify ( isa ) ) ;
#elif LONG_MIN < - 2147483646 && LONG_MAX > 2147483646 typedef long int png_int_32 ; #else <START_VULN> # error "libpng requires a signed 32 bit ( or more ) type"<END_VULN> #endif #if UINT_MAX > 4294967294
{ MsgToEventLog ( M_SYSERR , TEXT ( "PeekNamedPipeAsync failed" ) ) ; ReturnLastError ( pipe , L"PeekNamedPipeAsync" ) ; <START_VULN> goto out ; <END_VULN> } size = bytes sizeof ( * data ) ;
case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { <START_VULN> ND_TCHECK2 ( * mh , hlen + 8 ) ; <END_VULN> ND_PRINT ( ( ndo , " % s Init Cookie = % 08x : % 08x" , type == IP6M_HOME_TEST_INIT ? "Home" : "Care - of" , EXTRACT_32BITS ( & bp [ hlen ] ) ,
{ png_fixed_point gamma ; <START_VULN> if ( png_get_gAMA_fixed ( read_ptr , read_info_ptr , & gamma ) ) <END_VULN> png_set_gAMA_fixed ( write_ptr , write_info_ptr , gamma ) ; } #endif
* * * <START_VULN> void Write ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> void Finish ( RasterImage : : eShutdownIntent aShutdownIntent ) ;
dp = ( const struct ip6_frag * ) bp ; ip6 = ( const struct ip6_hdr * ) bp2 ; <START_VULN> ND_TCHECK ( dp -> ip6f_offlg ) ; <END_VULN> if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "frag ( 0x % 08x : % d | % ld ) " ,
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : apprentice . c , v 1 . 209 20140513 16 : 42 : 17 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
nsCOMPtr < nsIPrincipal> mSystemPrincipal ; nsCOMPtr < nsIXPConnectJSObjectHolder> mLoaderGlobal ; JSRuntime * mRuntime ; JSContext * mContext ; class ModuleEntry : public mozilla : : Module { public : <START_VULN> ModuleEntry ( ) : mozilla : : Module ( ) { <END_VULN> mVersion = mozilla : : Module : : kVersion ; mCIDs = nullptr ; mContractIDs = nullptr ; mCategoryEntries = nullptr ; getFactoryProc = GetFactory ; loadProc = nullptr ; unloadProc = nullptr ;
else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else <START_VULN> res = ctx -> iface -> enc . cfg_set ( ctx -> priv -> alg_priv , cfg ) ; <END_VULN> return SAVE_STATUS ( ctx , res ) ; }
char sbuf [ 512 ] ; struct NetBSD_elfcore_procinfo pi ; memset ( & pi , 0 , sizeof ( pi ) ) ; <START_VULN> memcpy ( & pi , nbuf + doff , descsz ) ; <END_VULN> if ( file_printf ( ms , " , from ' % . 31s' , pid = % u , uid = % u , " "gid = % u , nlwps = % u , lwp = % u ( signal % ucode % u ) " ,
<START_VULN> bool checkHeader ( ) const ; <END_VULN> #if DCHECK_IS_ON ( ) && CPU ( 64BIT )
calls mprStartDispatcher . @param dispatcher Dispatcher object created via #mprCreateDispatcher @return Zero if successful , otherwise a negative MPR status code . <START_VULN> @stability Prototype<END_VULN> @ingroup MprEvent PUBLIC int mprStartDispatcher ( MprDispatcher * dispatcher ) ;
walkbuf = result + * result_len ; <START_VULN> <END_VULN> if ( eval | | is_callable_replace ) {
<START_VULN> class BrowserCompositorMac : public DelegatedFrameHostClient { <END_VULN> public : BrowserCompositorMac ( ui : : AcceleratedWidgetMacNSView * accelerated_widget_mac_ns_view ,
{ 149 , 144 , } , } ; <START_VULN> void vp9_init_mode_probs ( FRAME_CONTEXT * fc ) { <END_VULN> vp9_copy ( fc -> uv_mode_prob , default_if_uv_probs ) ; vp9_copy ( fc -> y_mode_prob , default_if_y_probs ) ; vp9_copy ( fc -> switchable_interp_prob , default_switchable_interp_prob ) ;
iterator -> current = object ; } zval_add_ref ( & object ) ; <START_VULN> <END_VULN> return ( zend_object_iterator * ) iterator ; }
* <START_VULN> <END_VULN> #include "cert . h" #include "ssl . h" #include "cryptohi . h" #include "keyhi . h" #include "secder . h" #include "secitem . h"
} long vorbis_coslook_i ( long a ) { int i = a >> COS_LOOKUP_I_SHIFT ; int d = a & COS_LOOKUP_I_MASK ; return COS_LOOKUP_I [ i ] - ( ( d * ( COS_LOOKUP_I [ i ] - COS_LOOKUP_I [ i + 1 ] ) ) >> <START_VULN> COS_LOOKUP_I_SHIFT ) ; <END_VULN> } #endif
default : case 6 : <START_VULN> if ( ! ( png_ptr -> row_number & 1 ) ) <END_VULN> { png_read_finish_row ( png_ptr ) ; return ;
<START_VULN> if ( gamma_correction ) <END_VULN> png_ptr -> transformations |= PNG_GAMMA ; else
void RemoveAutocompleteSuggestion ( const WebKit : : WebString & name , const WebKit : : WebString & value ) ; <START_VULN> <END_VULN> void SuggestionsReceived ( int query_id , const std : : vector < string16> & values , const std : : vector < string16> & labels ,
} ; <START_VULN> const interp_kernel vp9_filteredinterp_filters625 [ ( 1 << SUBPEL_BITS ) ] = { <END_VULN> { - 1 , - 8 , 33 , 80 , 33 , - 8 , - 1 , 0 } , { - 1 , - 8 , 30 , 80 , 35 , - 8 , - 1 , 1 } , { - 1 , - 8 , 28 , 80 , 37 , - 7 , - 2 , 1 } ,
uint32_t len ; while ( packet_get_head_l ( sock , & buf , & len ) ) { <START_VULN> int sent = send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ; <END_VULN> if ( sent == ( signed ) len ) osi_free ( buf ) ;
bool isSelectionBorder ( ) const ; <START_VULN> bool hasClip ( ) const { return isPositioned ( ) && style ( ) -> hasClip ( ) ; } <END_VULN> bool hasOverflowClip ( ) const { return m_bitfields . hasOverflowClip ( ) ; } bool hasTransform ( ) const { return m_bitfields . hasTransform ( ) ; }
ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; <START_VULN> if ( ps_dec -> u1_first_slice_in_stream ) <END_VULN> { ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ;
<START_VULN> read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ; <END_VULN> } }
dp += ( len + ( 2 * sizeof ( uint32_t ) + 3 ) ) sizeof ( uint32_t ) ; <START_VULN> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <END_VULN> astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ; if ( astat != SUNRPC_SUCCESS ) { ND_PRINT ( ( ndo , " % s" , tok2str ( sunrpc_str , "ar_stat % d" , astat ) ) ) ;
{ * ( -- dp ) = * ( -- sp ) ; * ( -- dp ) = * ( -- sp ) ; <START_VULN> * ( -- dp ) = hi_filler ; <END_VULN> * ( -- dp ) = lo_filler ; } row_info -> channels = 2 ; row_info -> pixel_depth = 32 ;
<START_VULN> void reset ( C p = NULL ) { <END_VULN> if ( obj_ != p ) { FreeProc free_proc ; free_proc ( obj_ ) ;
#include "basestringsstring16 . h" <START_VULN> class PasswordAccessoryController ; <END_VULN> class PasswordGenerationDialogViewInterface { public :
} <START_VULN> if ( transforms & PNG_TRANSFORM_BGR ) <END_VULN> #ifdef PNG_WRITE_BGR_SUPPORTED png_set_bgr ( png_ptr ) ; #else
<START_VULN> if ( png_ptr -> transformations & PNG_RGB_TO_GRAY ) <END_VULN> png_colorspace_set_rgb_coefficients ( png_ptr ) ; #endif
VP8_BD_VALUE value ; int count ; unsigned int range ; <START_VULN> vp8_decrypt_cb * decrypt_cb ; <END_VULN> void * decrypt_state ; } BOOL_DECODER ;
GC_PLUGIN_IGNORE ( "http : crbug . com383741" ) Persistent < Element> m_keepAlive ; <START_VULN> Timer < ImageLoader> m_derefElementTimer ; <END_VULN> AtomicString m_failedLoadURL ; WeakPtr < Task> m_pendingTask ; std : : unique_ptr < IncrementLoadEventDelayCount> m_loadDelayCounter ;
_preextrapolate_helper ( v ) ; [ at least ] a few full blocks of zeroes at the end . * <START_VULN> vorbis_analysis_buffer ( v , ci -> blocksizes [ 1 ] * 3 ) ; <END_VULN> v -> eofflag = v -> pcm_current ; v -> pcm_current += ci -> blocksizes [ 1 ] * 3 ; for ( i = 0 ; i < vi -> channels ; i ++ ) { if ( v -> eofflag>order * 2 ) { long n ;
avctx -> pix_fmt = AV_PIX_FMT_GRAY16BE ; } else if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB ) { avctx -> pix_fmt = AV_PIX_FMT_RGB48BE ; } else if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA ) { avctx -> pix_fmt = AV_PIX_FMT_RGBA64BE ; } else if ( ( s -> bits_per_pixel == 1 | | s -> bits_per_pixel == 2 | | s -> bits_per_pixel == 4 | | s -> bits_per_pixel == 8 ) && s -> color_type == PNG_COLOR_TYPE_PALETTE ) { avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; <START_VULN> } else if ( s -> bit_depth == 1 ) { <END_VULN> avctx -> pix_fmt = AV_PIX_FMT_MONOBLACK ; } else if ( s -> bit_depth == 8 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA ) { avctx -> pix_fmt = AV_PIX_FMT_YA8 ; } else if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA ) { avctx -> pix_fmt = AV_PIX_FMT_YA16BE ; } else { av_log ( avctx , AV_LOG_ERROR , "unsupported bit depth % d " "and color type % d" ,
* <START_VULN> <END_VULN> #ifndef __SSL_ERR_H_ #define __SSL_ERR_H_ #define SSL_ERROR_BASE ( - 0x3000 ) #define SSL_ERROR_LIMIT ( SSL_ERROR_BASE + 1000 ) #define IS_SSL_ERROR ( code )
<START_VULN> #include < GUSICommandLine . h><END_VULN> No newline at end of file
this_mv . as_mv . row = br + hex [ i ] . row ; this_mv . as_mv . col = bc + hex [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <END_VULN> CHECK_BETTER } } else
void FrameReady ( VideoDecoder : : DecoderStatus status , <START_VULN> scoped_refptr < VideoFrame> frame ) ; <END_VULN>
} static inline int mount_entry_on_generic ( struct mntent * mntent , <START_VULN> const char * path ) <END_VULN> { unsigned long mntflags ; char * mntdata ;
bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; <START_VULN> if ( bmp_info . number_colors > GetBlobSize ( image ) ) <END_VULN> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse )
command = sclone ( mprLookupKey ( args , "CMD" ) ) ; data = 0 ; if ( scontains ( command , " | " ) ) { <START_VULN> data = stok ( command , " | " , & command ) ; <END_VULN> data = stemplate ( data , args ) ; } command = strim ( command , " t" , MPR_TRIM_BOTH ) ;
} if ( ! suffix ) { <START_VULN> rc = fsmVerify ( fpath , fi ) ; <END_VULN> } else { rc = ( action == FA_TOUCH ) ? 0 : RPMERR_ENOENT ; }
public : DistillerJavaScriptServiceImpl ( content : : RenderFrameHost * render_frame_host , <START_VULN> ExternalFeedbackReporter * external_feedback_reporter , <END_VULN> mojo : : InterfaceRequest < DistillerJavaScriptService> request ) ; ~ DistillerJavaScriptServiceImpl ( ) override ;
#include "hsm_config_client_api . h" <START_VULN> #define HSM_FM_SCK_PREFIX"tmp"<END_VULN> #define HSM_FM_SCK_SM"sm_" #define HSM_FM_SCK_PM"pm_" #define HSM_FM_SCK_FE"fe_"
return ( 0 ) ; } if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { <START_VULN> if ( count > = 4 ) { <END_VULN> int retTIFFReadRawTile ; _TIFFmemcpy ( buffer , jpt , count - 2 ) ;
if ( charset_hint ) { int found = 0 ; <START_VULN> <END_VULN> for ( i = 0 ; charset_map [ i ] . codeset ; i ++ ) { if ( len == strlen ( charset_map [ i ] . codeset ) && strncasecmp ( charset_hint , charset_map [ i ] . codeset , len ) == 0 ) {
{ unsigned long chunks = png_get_valid ( dp -> read_pp , dp -> read_ip , 0xffffffff ) ; <START_VULN> <END_VULN> if ( chunks != dp -> chunks ) display_log ( dp , APP_FAIL , "PNG chunks changed from 0x % lx to 0x % lx" , ( unsigned long ) dp -> chunks , chunks ) ;
RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ; <START_VULN> RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ; <END_VULN> RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ;
ND_PRINT ( ( ndo , " ( length bogus , should be > = 4 ) " ) ) ; return 0 ; } <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <END_VULN> compproto = EXTRACT_16BITS ( p + 2 ) ; ND_PRINT ( ( ndo , " : % s ( 0x % 02x ) : " ,
ND_PRINT ( ( ndo , " , length % u" , length ) ) ; return ; trunc : <START_VULN> ND_PRINT ( ( ndo , " [ | icmp6 ] " ) ) ; <END_VULN> } static const struct udphdr *
#include < stdlib . h> #include < stdio . h> #include < string . h> #include < ctype . h> <START_VULN> #include "compilerdebug . h"<END_VULN> #include "compilerpreprocessorslglobals . h" #include "compilerutil . h"
#endif #ifdef PNG_WRITE_sPLT_SUPPORTED <START_VULN> if ( info_ptr -> valid & PNG_INFO_sPLT ) <END_VULN> for ( i = 0 ; i < ( int ) info_ptr -> splt_palettes_num ; i ++ ) png_write_sPLT ( png_ptr , info_ptr -> splt_palettes + i ) ; #endif
<START_VULN> static void<END_VULN> _copy_from_pages ( char * p , struct page ** pages , size_t pgbase , size_t len ) { struct page ** pgfrom ;
int rc ; int param_num = SvIV ( param ) ; int idx = param_num - 1 ; <START_VULN> char err_msg [ 64 ] ; <END_VULN> D_imp_xxh ( sth ) ; #if MYSQL_VERSION_ID > = SERVER_PREPARE_VERSION
return - END_CIRC_REASON_TORPROTOCOL ; } else if ( rv == - 1 ) { tor_free ( bcell . address ) ; <START_VULN> relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ; <END_VULN> return 0 ; }
return 1 ; } <START_VULN> #line 1143 "extstandardvar_unserializer . c"<END_VULN> yy76 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy73 ;
return ; #ifdef PNG_READ_INTERLACING_SUPPORTED <START_VULN> if ( ! ( png_ptr -> flags & PNG_FLAG_ROW_INIT ) ) <END_VULN> { pass = png_set_interlace_handling ( png_ptr ) ;
protected : nsPresContext * mPresContext ; nsCOMPtr < nsIPresShell> mPresShell ; nsCOMPtr < nsISelection> mSelection ; nsRefPtr < nsRange> mFirstSelectedRange ; nsCOMPtr < nsIContent> mRootContent ; nsresult Init ( nsQueryContentEvent * aEvent ) ; nsresult Init ( nsSelectionEvent * aEvent ) ; <START_VULN> <END_VULN> nsresult InitCommon ( ) ; public : static nsresult GetFlatTextOffsetOfRange ( nsIContent * aRootContent , nsINode * aNode , int32_t aNodeOffset ,
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : file . c , v 1 . 158 20141128 02 : 35 : 05 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
return 0 ; code_key = ( unsigned short ) code_key_a ; <START_VULN> <END_VULN> while ( l <= h ) { m = l + ( h - l ) 2 ; if ( code_key < m -> un_code_point )
namespace blink { <START_VULN> class CSSPaintValue : public CSSImageGeneratorValue { <END_VULN> public : static CSSPaintValue * Create ( CSSCustomIdentValue * name ) { return new CSSPaintValue ( name ) ;
png_charp parameters [ 1 ] ; } chunk_insert ; <START_VULN> static int<END_VULN> channels_of_type ( int color_type ) { if ( color_type & PNG_COLOR_MASK_PALETTE )
this_mv . as_mv . row = br + next_chkpts [ k ] [ i ] . row ; this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <END_VULN> CHECK_BETTER } } else
newserv -> server [ l ] = '0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <START_VULN> if ( p + l > buf + n ) { <END_VULN> syslog ( LOG_WARNING , "bad request ( length encoding ) " ) ; goto error ; }
gss_ctx_id_t * context_handle , gss_buffer_t output_token ) { <START_VULN> OM_uint32 major_status = GSS_S_COMPLETE ; <END_VULN> if ( output_token != GSS_C_NO_BUFFER ) { output_token -> length = 0 ;
png_pass_start [ png_ptr -> pass ] ) png_pass_inc [ png_ptr -> pass ] ; <START_VULN> if ( png_ptr -> transformations & PNG_INTERLACE ) <END_VULN> break ; png_ptr -> num_rows = ( png_ptr -> height +
y ; unsigned char <START_VULN> * lastrow , <END_VULN> * one_row , * ptr ;
const bool isIncrementalInsertion = false ) ; static void insertText ( Document & , const String & , <START_VULN> const VisibleSelection & , <END_VULN> Options , TextCompositionType = TextCompositionNone , const bool isIncrementalInsertion = false ) ;
} zend_end_try ( ) ; } } <START_VULN> <END_VULN> obj = & EG ( objects_store ) . object_buckets [ handle ] . bucket . obj ;
yych = * ++ YYCURSOR ; if ( yych != ' { ' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 677 "extstandardvar_unserializer . re"<END_VULN> { long elements = parse_iv ( start + 2 ) ;
friend struct nsTreeRange ; protected : nsresult FireOnSelectHandler ( ) ; static void SelectCallback ( nsITimer * aTimer , void * aClosure ) ; protected : <START_VULN> nsITreeBoxObject * mTree ; <END_VULN> PRBool mSuppressed ; PRInt32 mCurrentIndex ; nsCOMPtr < nsITreeColumn> mCurrentColumn ; PRInt32 mShiftSelectPivot ; nsTreeRange * mFirstRange ;
if ( PASS == conn -> m -> local_tx_start ( conn , this_func TSRMLS_CC ) ) { ret = conn -> m -> query ( conn , "ROLLBACK" , sizeof ( "ROLLBACK" ) - 1 TSRMLS_CC ) ; <START_VULN> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_RETURN ( ret ) ;
out_string ( c , "OK" ) ; } } <START_VULN> } else if ( strcmp ( tokens [ 1 ] . value , "mode" ) == 0 && ntokens > = 3 && <END_VULN> settings . lru_maintainer_thread ) { if ( strcmp ( tokens [ 2 ] . value , "flat" ) == 0 ) { settings . lru_segmented = false ;
static int calc_iframe_target_size_one_pass_vbr ( const VP9_COMP * const cpi ) { static const int kf_ratio = 25 ; const RATE_CONTROL * rc = & cpi -> rc ; <START_VULN> int target = rc -> av_per_frame_bandwidth * kf_ratio ; <END_VULN> return vp9_rc_clamp_iframe_target_size ( cpi , target ) ; }
int CVE_2013_1726_mar_read_product_info_block ( MarFile * mar , struct ProductInformationBlock * infoBlock ) { <START_VULN> int i , hasAdditionalBlocks , offset , <END_VULN> offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; char buf [ 97 ] = { '0' } ; int ret = get_mar_file_info_fp ( mar -> fp , NULL , NULL , & hasAdditionalBlocks , & offsetAdditionalBlocks , & numAdditionalBlocks ) ; for ( i = 0 ; i < numAdditionalBlocks ; ++ i ) {
#if defined ( MSDOS ) | | defined ( WIN32 ) <START_VULN> char * sanitize_dos_name ( char * file_name ) ; <END_VULN> #if defined ( MSDOS ) && ( defined ( __DJGPP__ ) | | defined ( __GO32__ ) )
<START_VULN> #line 496 "extstandardvar_unserializer . c"<END_VULN> { YYCTYPE yych ; static const unsigned char yybm [ ] = {
if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <START_VULN> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <END_VULN> i ++ ; } }
static int image_transform_png_set_expand_16_add ( image_transform * this , <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <END_VULN> { UNUSED ( colour_type )
IPC_MESSAGE_ROUTED3 ( AcceleratedVideoDecoderMsg_Decode , base : : SharedMemoryHandle , int32 , <START_VULN> int32 ) <END_VULN>
static int jas_iccgetuint16 ( jas_stream_t * in , jas_iccuint16_t * val ) { <START_VULN> ulonglong tmp ; <END_VULN> if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ; * val = tmp ;
void vorbis_dsp_clear ( vorbis_dsp_state * v ) { int i ; if ( v ) { vorbis_info * vi = v -> vi ; codec_setup_info * ci = ( vi ? vi -> codec_setup : NULL ) ; private_state * b = v -> backend_state ; if ( b ) { <START_VULN> <END_VULN> if ( b -> ve ) { _ve_envelope_clear ( b -> ve ) ; _ogg_free ( b -> ve ) ; } if ( b -> transform [ 0 ] ) { mdct_clear ( b -> transform [ 0 ] [ 0 ] ) ; _ogg_free ( b -> transform [ 0 ] [ 0 ] ) ;
* #ifdef DEBUG <START_VULN> static const char CVS_ID [ ] = "@ ( # ) $ RCSfile : certdata . c , v $ $ Revision : 1 . 67 $ $ Date : 20100408 14 : 28 : 58 $ "" ; @ ( # ) $ RCSfile : certdata . c , v $ $ Revision : 1 . 67 $ $ Date : 20100408 14 : 28 : 58 $ " ; <END_VULN> #endif #ifndef BUILTINS_H #include "builtins . h" #endif static const CK_BBOOL ck_false = CK_FALSE ; static const CK_BBOOL ck_true = CK_TRUE ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : psychoacoustics not including preecho <START_VULN> last mod : $ Id : psy . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h> #include < math . h> #include < string . h> #include "vorbiscodec . h" #include "codec_internal . h"
int tok = XmlPrologTok ( parser -> m_internalEncoding , textStart , textEnd , & next ) ; result = doProlog ( parser , parser -> m_internalEncoding , textStart , textEnd , <START_VULN> tok , next , & next , XML_FALSE ) ; <END_VULN> } else #endif result = doContent ( parser , openEntity -> startTagLevel ,
@param child JSON child to remove @return The removed child element . @ingroup MprJson <START_VULN> @stability Prototype<END_VULN> PUBLIC MprJson * mprRemoveJsonChild ( MprJson * obj , MprJson * child ) ;
t = plaintext -> len ; t -= paddingLength + overhead ; <START_VULN> <END_VULN> good = DUPLICATE_MSB_TO_ALL ( ~ t ) ; t = blockSize - ( paddingLength + 1 ) ;
#elif USHRT_MAX == 65535 typedef unsigned short png_uint_16 ; #else <START_VULN> # error "libpng requires an unsigned 16 bit type"<END_VULN> #endif #if INT_MIN < - 2147483646 && INT_MAX > 2147483646
} <START_VULN> static void calc_segtree_probs ( int * segcounts , vp9_prob * segment_tree_probs ) { <END_VULN> const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ; const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ;
pthread_mutex_lock ( & client_socket_lock_ ) ; if ( client_socket_ != - 1 ) { <START_VULN> if ( send ( client_socket_ , data , length , 0 ) == - 1 && errno == ECONNRESET ) { <END_VULN> safe_close_ ( & client_socket_ ) ; } }
VideoCodec codec ; VideoCodecProfile profile ; int level ; <START_VULN> gfx : : ColorSpace : : TransferID eotf ; <END_VULN> } ; struct MEDIA_EXPORT KeySystemInfoForUMA {
#include < stddef . h> <START_VULN> #include "basemove . h"<END_VULN> namespace mojo {
{ rtnl_link_unregister ( & ipgre_tap_ops ) ; rtnl_link_unregister ( & ipgre_link_ops ) ; <START_VULN> unregister_pernet_device ( & ipgre_net_ops ) ; <END_VULN> if ( inet_del_protocol ( & ipgre_protocol , IPPROTO_GRE ) < 0 ) printk ( KERN_INFO "ipgre close : can't remove protocol" ) ; } module_init ( ipgre_init ) ;
static void unset_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { <START_VULN> vpx_active_map_t map = { 0 } ; <END_VULN> map . rows = ( cfg -> g_h + 15 ) 16 ; map . cols = ( cfg -> g_w + 15 ) 16 ;
break ; case 1 : <START_VULN> if ( ( png_ptr -> row_number & 0x07 ) | | png_ptr -> width < 5 ) <END_VULN> { png_write_finish_row ( png_ptr ) ; return ;
#endif if ( mount ( fsname , target , fstype , <START_VULN> mountflags | MS_REMOUNT , data ) ) { <END_VULN> if ( optional ) { INFO ( "failed to mount ' % s' on ' % s' ( optional ) : % s" , fsname , target , strerror ( errno ) ) ;
ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } <START_VULN> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <END_VULN> { if ( u2_first_mb_in_slice == 0 ) {
phar_flush ( entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
const struct rule_actions * actions = rule_get_actions ( rule ) ; <START_VULN> ovs_assert ( rule -> state == RULE_INITIALIZED ) ; <END_VULN> if ( rule -> hard_timeout | | rule -> idle_timeout ) { ovs_list_insert ( & ofproto -> expirable , & rule -> expirable ) ;
UNALIGNED_MEMCPY ( & rxent -> client , & ip -> ip_src , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & rxent -> server , & ip -> ip_dst , sizeof ( uint32_t ) ) ; rxent -> dport = dport ; <START_VULN> rxent -> serviceId = EXTRACT_32BITS ( & rxh -> serviceId ) ; <END_VULN> rxent -> opcode = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; }
static_assert ( ! NeedsAdjustAndMark < T> : : value , "wrapper tracing is not supported within mixins" ) ; #if DCHECK_IS_ON ( ) <START_VULN> DCHECK ( HeapObjectHeader : : fromPayload ( t ) -> checkHeader ( ) ) ; <END_VULN> #endif return reinterpret_cast < const T * > ( t ) ; }
{ <START_VULN> PNG_CONST double d = ( 255 - 128 . 5 ) 65535 ; <END_VULN> that -> rede += d ; that -> greene += d ; that -> bluee += d ;
WORD32 ih264d_read_mmco_commands ( struct _DecStruct * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; <START_VULN> dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ; <END_VULN> dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; WORD32 j ; UWORD8 u1_buf_mode ;
uint_fast16_t len ; <START_VULN> uchar * data ; <END_VULN> } jpc_com_t ;
<START_VULN> static void _php_mb_regex_globals_dtor ( zend_mb_regex_globals * pglobals TSRMLS_DC ) <END_VULN> { zend_hash_destroy ( & pglobals -> ht_rc ) ; }
png_free ( png_ptr , distance ) ; } } <START_VULN> #endif<END_VULN> #ifdef PNG_READ_GAMMA_SUPPORTED void PNGFAPI
png_crc_read ( png_ptr , buf , 9 ) ; <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <END_VULN> return ; offset_x = png_get_int_32 ( buf ) ;
bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_ENCAP ) ; <START_VULN> #if ENABLE_BGP_VNC<END_VULN> bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ; #endif
#include "vpxvpx_codec . h" <START_VULN> static const char * const cfg = " -- target = x86_64 - linux - gcc -- disable - sse4_1 -- disable - avx -- disable - avx2 -- as = yasm -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
if ( posts == 0 ) { nonzero += accumulate_fit ( logmask , logmdct , 0 , n , fits , n , info ) ; } else { for ( i = 0 ; i < posts - 1 ; i ++ ) nonzero += accumulate_fit ( logmask , logmdct , look -> sorted_index [ i ] , look -> sorted_index [ i + 1 ] , fits + i , n , info ) ; } <START_VULN> <END_VULN> if ( nonzero ) { int y0 = - 200 ; int y1 = - 200 ; fit_line ( fits , posts - 1 , & y0 , & y1 ) ; fit_valueA [ 0 ] = y0 ; fit_valueB [ 0 ] = y0 ;
' < session - name> = < session - id>' to allow URLs of the form http : <START_VULN> if ( ! PS ( id ) && <END_VULN> zend_hash_find ( & EG ( symbol_table ) , "REQUEST_URI" , sizeof ( "REQUEST_URI" ) , ( void ** ) & data ) == SUCCESS && Z_TYPE_PP ( data ) == IS_STRING &&
struct cpu_context_savecpu_context ; __u32syscall ; __u8used_cp [ 16 ] ; <START_VULN> unsigned longtp_value ; <END_VULN> #ifdef CONFIG_CRUNCH struct crunch_statecrunchstate ; #endif
{ struct crypto_report_hash rhash ; <START_VULN> snprintf ( rhash . type , CRYPTO_MAX_ALG_NAME , " % s" , "ahash" ) ; <END_VULN> rhash . blocksize = alg -> cra_blocksize ; rhash . digestsize = __crypto_hash_alg_common ( alg ) -> digestsize ;
{ int ret = 0 ; struct hns_roce_ucontext * context ; <START_VULN> struct hns_roce_ib_alloc_ucontext_resp resp ; <END_VULN> struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ; resp . qp_tab_size = hr_dev -> caps . num_qps ;
oggpack_write ( opb , 1 , 1 ) ; return ( 0 ) ; } static int _vorbis_pack_comment ( oggpack_buffer * opb , vorbis_comment * vc ) { int bytes = strlen ( ENCODE_VENDOR_STRING ) ; <START_VULN> <END_VULN> oggpack_write ( opb , 0x03 , 8 ) ; _v_writestring ( opb , "vorbis" , 6 ) ; oggpack_write ( opb , bytes , 32 ) ; _v_writestring ( opb , ENCODE_VENDOR_STRING , bytes ) ;
int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , <START_VULN> const char * name , int rep_quick ) <END_VULN> { int got_error ; uint i ;
vp8_short_idct4x4llm_c ( input , dest , stride , dest , stride ) ; <START_VULN> vpx_memset ( input , 0 , 32 ) ; <END_VULN> }
static enum XML_Error doProlog ( XML_Parser parser , const ENCODING * enc , const char * s , const char * end , int tok , const char * next , const char ** nextPtr , <START_VULN> XML_Bool haveMore ) ; <END_VULN> static enum XML_Error processInternalEntity ( XML_Parser parser , ENTITY * entity , XML_Bool betweenDecl ) ; static enum XML_Error doContent ( XML_Parser parser , int startTagLevel ,
ContextualSearchParams ( int version , const std : : string & selection , const std : : string & base_page_url , <START_VULN> int now_on_tap_version ) ; <END_VULN> ContextualSearchParams ( int version ,
attrhdrlen = 1 + 1 ; break ; <START_VULN> #if ENABLE_BGP_VNC<END_VULN> case BGP_ATTR_VNC : attrname = "VNC" ; subtlvs = attr -> vnc_subtlvs ;
parser -> m_processor = prologProcessor ; tok = XmlPrologTok ( parser -> m_encoding , s , end , & next ) ; return doProlog ( parser , parser -> m_encoding , s , end , tok , next , nextPtr , <START_VULN> ( XML_Bool ) ! parser -> m_parsingStatus . finalBuffer ) ; <END_VULN> } else #endif {
PRINTING_EXPORT extern const char kIsFirstRequest [ ] ; PRINTING_EXPORT extern const char kPreviewRequestID [ ] ; <START_VULN> PRINTING_EXPORT extern const char kPreviewUIAddr [ ] ; <END_VULN> PRINTING_EXPORT extern const char kSettingCloudPrintId [ ] ; PRINTING_EXPORT extern const char kSettingCloudPrintDialog [ ] ; PRINTING_EXPORT extern const char kSettingCollate [ ] ;
top = itr + itr_size ; result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) , <START_VULN> USB_DT_SECURITY , ( void ** ) & secd ) ; <END_VULN> if ( result == - 1 ) { dev_warn ( dev , "BUG ? WUSB host has no security descriptors" ) ; return 0 ;
perf_event_header__init_id ( & mmap_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , <START_VULN> mmap_event -> event_id . header . size , 0 , 0 ) ; <END_VULN> if ( ret ) goto out ;
} } while ( base_was_tested ) ; mpz_init_set ( tested [ i ] , a ) ; <START_VULN> mpz_powm ( z , a , m , n ) ; <END_VULN> if ( ( mpz_cmp_ui ( z , 1 ) == 0 ) | | ( mpz_cmp ( z , n_1 ) == 0 ) ) continue ; composite = 1 ;
} else { out_string ( c , "ERROR" ) ; } <START_VULN> } else if ( strcmp ( tokens [ 1 ] . value , "temp_ttl" ) == 0 && ntokens > = 3 && <END_VULN> settings . lru_maintainer_thread ) { if ( ! safe_strtol ( tokens [ 2 ] . value , & ttl ) ) { out_string ( c , "ERROR" ) ;
threshold_image = CloneImage ( image , 0 , 0 , MagickTrue , exception ) ; if ( threshold_image == ( Image * ) NULL ) return ( ( Image * ) NULL ) ; <START_VULN> if ( width == 0 ) <END_VULN> return ( threshold_image ) ; status = SetImageStorageClass ( threshold_image , DirectClass , exception ) ; if ( status == MagickFalse )
char delimiter = intern -> u . file . delimiter , enclosure = intern -> u . file . enclosure , escape = intern -> u . file . escape ; char * delim = NULL , * enclo = NULL , * esc = NULL ; int d_len = 0 , e_len = 0 , esc_len = 0 ; <START_VULN> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , " | sss" , & delim , & d_len , & enclo , & e_len , & esc , & esc_len ) == SUCCESS ) { switch ( ZEND_NUM_ARGS ( ) ) {
static int _make_words ( char * l , long n , ogg_uint32_t * r , long quantvals , <START_VULN> codebook * b , oggpack_buffer * opb , int maptype ) { <END_VULN> long i , j , count = 0 ; long top = 0 ; ogg_uint32_t marker [ MARKER_SIZE ] ;
<START_VULN> static int CVE_2014_5471_isofs_read_inode ( struct inode * inode ) <END_VULN> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ;
{ const short * HFilter ; const short * VFilter ; <START_VULN> DECLARE_ALIGNED_ARRAY ( 4 , short , FData , 16 * 8 ) ; <END_VULN> HFilter = vp8_sub_pel_filters [ xoffset ] ; VFilter = vp8_sub_pel_filters [ yoffset ] ;
{ BTIF_TRACE_DEBUG ( " % s" , __FUNCTION__ ) ; if ( uinput_fd > 0 ) { <START_VULN> ioctl ( uinput_fd , UI_DEV_DESTROY ) ; <END_VULN> close ( uinput_fd ) ; uinput_fd = - 1 ;
static void <START_VULN> standard_test ( png_store * PNG_CONST psIn , png_uint_32 PNG_CONST id , <END_VULN> int do_interlace , int use_update_info ) { standard_display d ;
} } do { <START_VULN> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <END_VULN> if ( setup_ret == 0 ) { goto _end ; }
mode_t curumsk = umask ( 022 ) ; umask ( curumsk ) ; <START_VULN> if ( fchmod ( fileno ( fp ) , 0666 - curumsk ) < 0 ) { <END_VULN> err_status = "create_chmod" ; return - 1 ; }
return - 1 ; } <START_VULN> return mount_entry_on_generic ( mntent , path ) ; <END_VULN> } static int mount_file_entries ( const struct lxc_rootfs * rootfs , FILE * file ,
return ; for ( ; overflow ; overflow -- ) { <START_VULN> if ( __perf_event_overflow ( event , nmi , throttle , <END_VULN> data , regs ) ) {
xmlBufCreateStatic ( void * mem , size_t size ) { xmlBufPtr ret ; <START_VULN> if ( ( mem == NULL ) | | ( size == 0 ) ) <END_VULN> return ( NULL ) ; ret = ( xmlBufPtr ) xmlMalloc ( sizeof ( xmlBuf ) ) ;
regs -> loadrs = 0 ; regs -> r8 = get_dumpable ( current -> mm ) ; regs -> r12 = new_sp - 16 ; <START_VULN> if ( unlikely ( ! get_dumpable ( current -> mm ) ) ) { <END_VULN>
<START_VULN> void SetRegisteredIds ( const ObjectIdSet & ids ) ; <END_VULN>
} for ( ; ; ) { <START_VULN> int client_socket = accept ( listen_socket_ , NULL , NULL ) ; <END_VULN> if ( client_socket == - 1 ) { if ( errno == EINVAL | | errno == EBADF ) { break ;
PHPAPI pcre * pcre_get_compiled_regex_ex ( char * regex , pcre_extra ** extra , int * preg_options , int * compile_options TSRMLS_DC ) { pcre_cache_entry * pce = pcre_get_compiled_regex_cache ( regex , strlen ( regex ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( extra ) { * extra = pce ? pce -> extra : NULL ; }
SPL_METHOD ( DirectoryIterator , key ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
" the following codes . Notice that the results for each file are combined" , " together - check one file at a time to get a meaningful error code ! " , " 0x01 : The zlib too - far - back error existed in at least one chunk . " , <START_VULN> " 0x02 : At least once chunk had a CRC error . " , <END_VULN> " 0x04 : A chunk length was incorrect . " , " 0x08 : The file was truncated . " , " Errors less than 16 are potentially recoverable , for a single file if the" ,
} else { newmap = malloc ( sizeof ( int ) * size ) ; newrev = malloc ( sizeof ( int ) * size ) ; atable -> size = 0 ; } if ( ! newmap | | ! newrev ) { if ( newmap ) atable -> amap = newmap ; if ( newrev ) <START_VULN> atable -> amap = newrev ; <END_VULN> return - 1 ; } memset ( & newmap [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ) ; memset ( & newrev [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ) ; atable -> amap = newmap ; atable -> arev = newrev ; atable -> size = size ; } return 0 ; }
virtual void DidAutoResize ( const WebSize & new_size ) { } <START_VULN> virtual void DidFocus ( ) { } <END_VULN>
* b += diff ; * avail -= diff ; tested = len ; <START_VULN> len = get_line_size ( * b , * avail , nl ) ; <END_VULN> if ( len > = 0 ) len += tested ; }
( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ; <START_VULN> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <END_VULN> } } }
appendItem ( result , queryLeaf ( obj , property , value , flags ) ) ; break ; <START_VULN> } else if ( ( child = mprLookupJsonObj ( obj , property ) ) == 0 ) { <END_VULN> if ( value ) { child = mprCreateJson ( termType & JSON_PROP_ARRAY ? MPR_JSON_ARRAY : MPR_JSON_OBJ ) ; setProperty ( obj , sclone ( property ) , child ) ;
__set_bit ( DONT_FORK_BIT , & debug ) ; __set_bit ( NO_SYSLOG_BIT , & debug ) ; if ( optarg && optarg [ 0 ] ) { <START_VULN> int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <END_VULN> if ( fd == - 1 ) { fprintf ( stderr , "Unable to open config - test log file % s" , optarg ) ; exit ( EXIT_FAILURE ) ;
_WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { uint32_t hmi_tmp = 0 ; uint8_t * hmi_base = hmi_data ; uint16_t hmi_bpm = 0 ; uint16_t hmi_division = 0 ; <START_VULN> <END_VULN> uint32_t hmi_track_cnt = 0 ; uint32_t * hmi_track_offset = NULL ; uint32_t i = 0 ;
<START_VULN> class ComponentContext { <END_VULN> public : ComponentContext ( ) ; ~ ComponentContext ( ) ;
# ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED # ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED <START_VULN> keep = png_chunk_unknown_handling ( png_ptr , png_ptr -> chunk_name ) ; <END_VULN> # endif # endif
sub_str_end_pos = ustr_len ; } } <START_VULN> <END_VULN> if ( sub_str_start_pos > sub_str_end_pos ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "grapheme_substr : length is beyond start" , 1 TSRMLS_CC ) ;
#include < windows . h> #include "nscore . h" #if MOZ_WINSDK_TARGETVER > = MOZ_NTDDI_LONGHORN #include < dwmapi . h> #endif <START_VULN> #if defined ( WINCE ) | | ( MOZ_WINSDK_TARGETVER == MOZ_NTDDI_WS03 ) <END_VULN> struct MARGINS { int cxLeftWidth ; int cxRightWidth ; int cyTopHeight ; int cyBottomHeight ; } ; #endif
pptr += opli ; } trunc : <START_VULN> return ; <END_VULN> } static void
x = vpx_memalign ( DEFAULT_ALIGNMENT , num * size ) ; if ( x ) <START_VULN> VPX_MEMSET_L ( x , 0 , num * size ) ; <END_VULN> return x ; }
private int toomany ( struct magic_set * ms , const char * name , uint16_t num ) { <START_VULN> if ( file_printf ( ms , " , too many % s header sections ( % u ) " , name , num<END_VULN> ) == - 1 ) return - 1 ; return 0 ;
tidx = i ; break ; } } } if ( src_end - src < 2 ) return 0 ; zsize = ( src [ 0 ] << 8 ) | src [ 1 ] ; src += 2 ; <START_VULN> if ( src_end - src < zsize ) <END_VULN> return AVERROR_INVALIDDATA ; ret = uncompress ( c -> kempf_buf , & dlen , src , zsize ) ; if ( ret ) return AVERROR_INVALIDDATA ; src += zsize ; if ( sub_type == 2 ) { kempf_restore_buf ( c -> kempf_buf , dlen , dst , c -> framebuf_stride , NULL , 0 , width , height , pal , npal , tidx ) ;
processed = ctxt -> input -> cur - ctxt -> input -> base ; xmlBufShrink ( ctxt -> input -> buf -> buffer , processed ) ; nbchars = xmlCharEncInput ( ctxt -> input -> buf , 1 ) ; if ( nbchars < 0 ) { htmlParseErr ( ctxt , XML_ERR_INVALID_ENCODING , "htmlCheckEncoding : encoder error" , NULL , NULL ) ; } <START_VULN> xmlBufResetInput ( ctxt -> input -> buf -> buffer , ctxt -> input ) ; <END_VULN> } } }
#include "basesynchronizationlock . h" #include "basesynchronizationwaitable_event . h" #include "basethreadingthread . h" <START_VULN> #include "chromebrowserchromeosaudio_mixer . h"<END_VULN> class PrefService ;
uint32_t * GetImageData ( ) ; int32_t GetCompressedImageSize ( ) const ; bool HasAlphaData ( ) const ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal ( ) ; private : NS_METHOD CalcBitShift ( ) ;
if ( r < 0 ) return log_error_errno ( r , "Virtual console % s is not allocated : % m" , src_vc ) ; <START_VULN> r = verify_vc_kbmode ( fd ) ; <END_VULN> if ( r < 0 ) return log_error_errno ( r , "Virtual console % s is not in K_XLATE or K_UNICODE : % m" , src_vc ) ;
static char error_string [ 64 ] ; DWORD error_code = GetLastError ( ) ; <START_VULN> if ( ( error_code >> 16 ) != 0x8009 ) <END_VULN> return WindowsErrorString ( ) ; switch ( error_code ) {
status = MagickFalse ; continue ; } <START_VULN> for ( x = 0 ; x < ( ssize_t ) images -> columns ; x ++ ) <END_VULN> { switch ( op ) {
SkAutoSTMalloc ( size_t count ) { if ( count > kCount ) { <START_VULN> fPtr = ( T * ) sk_malloc_flags ( count * sizeof ( T ) , SK_MALLOC_THROW | SK_MALLOC_TEMP ) ; <END_VULN> } else if ( count ) { fPtr = fTStorage ; } else {
void ErrorInvalidEnumInfo ( const char * info , WebGLenum enumvalue ) { return ErrorInvalidEnum ( " % s : invalid enum value 0x % x" , info , enumvalue ) ; } void ErrorOutOfMemory ( const char * fmt = 0 , . . . ) ; const char * ErrorName ( GLenum error ) ; bool IsTextureFormatCompressed ( GLenum format ) ; <START_VULN> void DummyFramebufferOperation ( const char * info ) ; <END_VULN> WebGLTexture * activeBoundTextureForTarget ( WebGLenum target ) { return target == LOCAL_GL_TEXTURE_2D ? mBound2DTextures [ mActiveTexture ] : mBoundCubeMapTextures [ mActiveTexture ] ; } already_AddRefed < CanvasLayer> GetCanvasLayer ( nsDisplayListBuilder * aBuilder , CanvasLayer * aOldLayer ,
" < ! -- This program is part of the Boa Webserver Copyright ( C ) 1991 - 2002 http : www . boa . org -- >" " < body> < html>" , now ) ; #endif <START_VULN> <END_VULN> return 0 ; }
#define s_pop_layer ( s , h ) ( s ) -> p = ( s ) -> h ; #define s_mark_end ( s ) ( s ) -> end = ( s ) -> p ; #define s_check ( s ) ( ( s ) -> p <= ( s ) -> end ) <START_VULN> #define s_check_rem ( s , n ) ( ( s ) -> p + n <= ( s ) -> end ) <END_VULN> #define s_check_end ( s ) ( ( s ) -> p == ( s ) -> end ) #define s_length ( s ) ( ( s ) -> end - ( s ) -> data ) #define s_left ( s ) ( ( s ) -> size - ( ( s ) -> p - ( s ) -> data ) )
#endif case PTRACE_GET_THREAD_AREA : <START_VULN> ret = put_user ( task_thread_info ( child ) -> tp_value , <END_VULN> datap ) ; break ;
public : inline void setDefaultCompartmentObject ( JSObject * obj ) ; inline void setDefaultCompartmentObjectIfUnset ( JSObject * obj ) ; JSObject * maybeDefaultCompartmentObject ( ) const { return defaultCompartmentObject_ ; } js : : ContextStack stack ; <START_VULN> <END_VULN> inline js : : Handle < js : : GlobalObject * > global ( ) const ; inline bool hasfp ( ) const { return stack . hasfp ( ) ; } inline js : : StackFrame * fp ( ) const { return stack . fp ( ) ; } inline js : : StackFrame * maybefp ( ) const { return stack . maybefp ( ) ; } inline js : : FrameRegs & regs ( ) const { return stack . regs ( ) ; } inline js : : FrameRegs * maybeRegs ( ) const { return stack . maybeRegs ( ) ; }
connection_type_ = connection_type ; } <START_VULN> bool ShouldAddDefaultProxyBypassRules ( ) const override ; <END_VULN> void SetShouldAddDefaultProxyBypassRules ( bool add_default_proxy_bypass_rules ) ;
virtual void ProcessTextData ( ) ; PRBool SetTextStyle ( ) ; <START_VULN> void SetQuotes ( ) ; <END_VULN> } ; #endif
: clasp ( clasp ) , proto ( proto ) , parent ( parent ) , nfixed ( nfixed ) , baseFlags ( baseFlags ) { } } ; inline InitialShapeEntry ( ) ; inline InitialShapeEntry ( const ReadBarriered < Shape> & shape , TaggedProto proto ) ; <START_VULN> inline Lookup getLookup ( ) ; <END_VULN> static inline HashNumber hash ( const Lookup & lookup ) ; static inline bool match ( const InitialShapeEntry & key , const Lookup & lookup ) ; } ; typedef HashSet < InitialShapeEntry , InitialShapeEntry , SystemAllocPolicy> InitialShapeSet ; struct StackShape
uint64 GetAndClearTaskWasRunOnQueueBitmap ( ) ; <START_VULN> void SetTimeSourceForTesting ( scoped_ptr < TimeSource> time_source ) ; <END_VULN> void SetWorkBatchSizeForTesting ( size_t work_batch_size ) ; TaskQueueManager * GetTaskQueueManagerForTesting ( ) ;
int ret ; do { <START_VULN> ret = epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ; <END_VULN> } while ( ret == - 1 && errno == EINTR ) ; if ( ret == - 1 ) {
Erase the contents of a string @param str String to erase @ingroup MprString <START_VULN> @stability Prototype<END_VULN> PUBLIC void serase ( char * str ) ;
status_t initDecoder ( ) ; void drainAllOutputBuffers ( bool eos ) ; <START_VULN> void drainOneOutputBuffer ( int32_t picId , uint8_t * data ) ; <END_VULN> void saveFirstOutputBuffer ( int32_t pidId , uint8_t * data ) ; CropSettingsMode handleCropParams ( const H264SwDecInfo & decInfo ) ;
} else if ( child -> type & MPR_JSON_OBJ ) { newRoute = 0 ; <START_VULN> pattern = mprLookupJson ( child , "pattern" ) ; <END_VULN> if ( pattern ) { newRoute = httpLookupRouteByPattern ( route -> host , pattern ) ; if ( ! newRoute ) {
EXPECT_TRUE ( this -> SetCanonicalCookie ( cs , <START_VULN> base : : MakeUnique < CanonicalCookie> ( <END_VULN> "G" , "H" , http_foo_host , "unique" , base : : Time ( ) , base : : Time ( ) , base : : Time ( ) , false , true , CookieSameSite : : DEFAULT_MODE , COOKIE_PRIORITY_DEFAULT ) ,
{ png_debug ( 1 , "in png_set_background_fixed" ) ; <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) | | background_color == NULL ) <END_VULN> return ; if ( background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN )
selReadStream ( FILE * fp ) { char * selname ; <START_VULN> char linebuf [ L_BUF_SIZE ] ; <END_VULN> l_int32 sy , sx , cy , cx , i , j , version , ignore ; SEL * sel ;
<START_VULN> class FileVersionInfo { <END_VULN> public : virtual ~ FileVersionInfo ( ) { } #if defined ( OS_WIN ) | | defined ( OS_MACOSX )
} clone_info = CloneDrawInfo ( ( ImageInfo * ) NULL , draw_info ) ; clone_info -> stroke_width = 0 . 0 ; <START_VULN> clone_info -> stroke . alpha = ( Quantum ) TransparentAlpha ; <END_VULN> status &= DrawPolygonPrimitive ( image , clone_info , primitive_info , exception ) ; clone_info = DestroyDrawInfo ( clone_info ) ;
int vorbis_synthesis_headerin ( vorbis_info * vi , vorbis_comment * vc , ogg_packet * op ) { oggpack_buffer opb ; <START_VULN> <END_VULN> if ( op ) { oggpack_readinit ( & opb , op -> packet , op -> bytes ) ; { char buffer [ 6 ] ; int packtype = oggpack_read ( & opb , 8 ) ;
MediaByteRange const & aByteRange ) ; virtual nsresult Close ( ) ; virtual void Suspend ( bool aCloseImmediately ) ; virtual void Resume ( ) ; virtual already_AddRefed < nsIPrincipal> GetCurrentPrincipal ( ) ; bool IsClosed ( ) const { return mCacheStream . IsClosed ( ) ; } virtual bool CanClone ( ) ; <START_VULN> virtual MediaResource * CloneData ( MediaDecoder * aDecoder ) ; <END_VULN> void RecordStatisticsTo ( MediaChannelStatistics * aStatistics ) MOZ_OVERRIDE { NS_ASSERTION ( aStatistics , "Statistics param cannot be null ! " ) ; MutexAutoLock lock ( mLock ) ; if ( ! mChannelStatistics ) { mChannelStatistics = aStatistics ; }
#include "extstandardinfo . h" #include "php_mbregex . h" #include "mbstring . h" <START_VULN> <END_VULN> #include "php_onig_compat . h" #include < oniguruma . h> #undef UChar
Compatible Regular Expression library . It defines the things POSIX says should be there . I hope . <START_VULN> Copyright ( c ) 1997 - 2007 University of Cambridge<END_VULN> -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - Redistribution and use in source and binary forms , with or without
jpc_streamlist_t * jpc_ppmstabtostreams ( jpc_ppxstab_t * tab ) { jpc_streamlist_t * streams ; <START_VULN> uchar * dataptr ; <END_VULN> uint_fast32_t datacnt ; uint_fast32_t tpcnt ; jpc_ppxstabent_t * ent ;
<START_VULN> <END_VULN> #include < r_io . h> #include < r_fs . h>
} ; <START_VULN> const vp9_tree_index vp9_intra_mode_tree [ TREE_SIZE ( INTRA_MODES ) ] = { <END_VULN> - DC_PRED , 2 , - TM_PRED , 4 , - V_PRED , 6 ,
} if ( offset + 1 > = optslen ) { <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <END_VULN> break ; }
} const nsCString & ClassName ( ) const { return mImplementation ? mImplementation -> mClassName : EmptyCString ( ) ; } nsresult InitClass ( const nsCString & aClassName , JSContext * aContext , JSObject * aGlobal , JSObject * aScriptObject , <START_VULN> JSObject ** aClassObject ) ; <END_VULN> nsresult ConstructInterfaceTable ( const nsAString & aImpls ) ; void SetImplementation ( nsXBLProtoImpl * aImpl ) { mImplementation = aImpl ; } nsresult InstallImplementation ( nsXBLBinding * aBinding ) ; bool HasImplementation ( ) const { return mImplementation != nullptr ; } void AttributeChanged ( nsIAtom * aAttribute , int32_t aNameSpaceID ,
line_len = strcspn ( buf , "r" ) ; buf [ line_len ] = '0' ; } <START_VULN> <END_VULN> intern -> u . file . current_line = buf ; intern -> u . file . current_line_len = line_len ; }
} <START_VULN> static void show_psnr ( struct stream_state * stream ) { <END_VULN> int i ; double ovpsnr ;
int tok = XmlPrologTok ( parser -> m_internalEncoding , textStart , textEnd , & next ) ; result = doProlog ( parser , parser -> m_internalEncoding , textStart , textEnd , <START_VULN> tok , next , & next , XML_FALSE ) ; <END_VULN> } else #endif result = doContent ( parser , parser -> m_tagLevel , parser -> m_internalEncoding ,
virtual ~ WorkerProcessIpcDelegate ( ) { } <START_VULN> virtual void OnChannelConnected ( ) = 0 ; <END_VULN> virtual bool OnMessageReceived ( const IPC : : Message & message ) = 0 ;
goto trunc ; if ( length < alen ) goto trunc ; <START_VULN> if ( ! bgp_attr_print ( ndo , atype , p , alen ) ) <END_VULN> goto trunc ; p += alen ; len -= alen ;
outptr = out ; for ( i = 0 ; i < 16 ; ++ i ) { <START_VULN> iadst16 ( outptr , temp_out ) ; <END_VULN> for ( j = 0 ; j < 16 ; ++ j ) dest [ j * pitch + i ] =
if ( oldlen < 64 ) { <START_VULN> maxlen = 128 ; <END_VULN> } else { maxlen = 2 * oldlen ; if ( maxlen < oldlen ) {
png_debug1 ( 1 , "in % s storage function" , "pCAL" ) ; if ( png_ptr == NULL | | info_ptr == NULL | | purpose == NULL | | units == NULL <START_VULN> | | ( nparams > 0 && params == NULL ) ) <END_VULN> return ; length = strlen ( purpose ) + 1 ;
int process_mode ; int cur_palette ; <START_VULN> #endif<END_VULN> #if defined ( __TURBOC__ ) && ! defined ( _Windows ) && ! defined ( __FLAT__ )
char buf [ 20 ] ; int ret ; uid_t uid ; cred = current_cred ( ) ; user = cred -> user ; uid = from_kuid ( cred -> user_ns , user -> uid ) ; kenter ( " % p { % u } " , user , uid ) ; <START_VULN> if ( user -> uid_keyring ) { <END_VULN> kleave ( " = 0 [ exist ] " ) ; return 0 ; } mutex_lock ( & key_user_keyring_mutex ) ; ret = 0 ; if ( ! user -> uid_keyring ) { sprintf ( buf , "_uid . % u" , uid ) ;
<START_VULN> GetNextToken ( q , & q , extent , keyword ) ; <END_VULN> if ( * keyword == '0' ) break ; if ( * keyword == '#' )
<START_VULN> PHP_FUNCTION ( locale_get_display_variant ) <END_VULN> { get_icu_disp_value_src_php ( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; }
nsresult SharedOutputString ( uint32_t aFlags , bool * aIsCollapsed , nsAString & aResult ) ; bool IsModifiable ( ) ; bool CanCutOrCopy ( ) ; <START_VULN> bool FireClipboardEvent ( int32_t aType ) ; <END_VULN> bool UpdateMetaCharset ( nsIDOMDocument * aDocument , const nsACString & aCharacterSet ) ; protected : nsCOMPtr < nsIEditRules> mRules ;
while ( v ) { ret ++ ; v >>= 1 ; } return ( ret ) ; } static void mapping0_pack ( vorbis_info * vi , vorbis_info_mapping * vm , <START_VULN> oggpack_buffer * opb ) { <END_VULN> int i ; vorbis_info_mapping0 * info = ( vorbis_info_mapping0 * ) vm ; if ( info -> submaps>1 ) { for ( i = 0 ; i < vi -> channels ; i ++ ) {
if ( crc == png_sRGB_checks [ i ] . crc ) # endif { <START_VULN> if ( png_sRGB_checks [ i ] . is_broken ) <END_VULN> {
return bestsme ; } <START_VULN> #endif<END_VULN> static void temporal_filter_iterate_c ( VP9_COMP * cpi , int frame_count , int alt_ref_index , int strength ,
user_manager : : UserList users_ ; <START_VULN> <END_VULN> std : : map < AccountId , proximity_auth : : mojom : : AuthType> user_auth_type_map_ ;
int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; <START_VULN> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <END_VULN> if ( str [ j ] == '#' ) { i -- ; continue ; }
if ( * s2 == '0' ) return s1 ; <START_VULN> for ( p = s1 ; ( p = strchr ( p , * s2 ) ) != NULL ; p = strchr ( p + 1 , * s2 ) ) { <END_VULN> if ( strncmp ( p , s2 , len ) == 0 ) return ( p ) ; }
{ const char * perm = "add" ; <START_VULN> if ( uid > = AID_APP ) { <END_VULN> return 0 ; }
SPL_METHOD ( GlobIterator , count ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
const std : : string & device_node ) override ; void CreateFusionSensor ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> const CreateSensorCallback & callback ) ;
<START_VULN> png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , mainprog_ptr , <END_VULN> readpng2_error_handler , readpng2_warning_handler ) ; if ( ! png_ptr ) return 4 ;
IntRect PageRect ( ) override { return IntRect ( ) ; } <START_VULN> void Focus ( ) override { } <END_VULN> bool CanTakeFocus ( WebFocusType ) override { return false ; } void TakeFocus ( WebFocusType ) override { }
int ret ; char buff [ MAXPATHLEN ] ; zend_error_handling error_handling ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
sz = pdf -> xrefs [ i ] . end - ftell ( fp ) ; <START_VULN> buf = malloc ( sz + 1 ) ; <END_VULN> SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , "Failed to load Root . " ) ; buf [ sz ] = '0' ; if ( ! ( c = strstr ( buf , "Root" ) ) )
public : MockDataReductionProxySettings < C> ( ) : C ( ) { } <START_VULN> MOCK_METHOD0 ( GetOriginalProfilePrefs , PrefService * ( ) ) ; <END_VULN> MOCK_METHOD0 ( GetLocalStatePrefs , PrefService * ( ) ) ; MOCK_CONST_METHOD1 ( RecordStartupState , void ( ProxyStartupState state ) ) ; } ;
<START_VULN> test_pixel . have_tRNS = dp -> this . is_transparent ; <END_VULN> test_pixel . red_sBIT = test_pixel . green_sBIT = test_pixel . blue_sBIT = test_pixel . alpha_sBIT = test_pixel . sample_depth ;
<START_VULN> if ( ( fd = accept ( sfd , ( struct sockaddr * ) & remote , & len ) ) == - 1 ) <END_VULN> { BTIF_TRACE_ERROR ( "sock accept failed ( % s ) " , strerror ( errno ) ) ; return - 1 ;
if ( yych <= '9' ) goto yy97 ; if ( yych != ' ; ' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 499 "extstandardvar_unserializer . re"<END_VULN> { long id ;
transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { <START_VULN> <END_VULN> if ( strpbrk ( mode , "awx + " ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP wrapper does not support writeable connections" ) ; php_url_free ( resource ) ;
int unit_type ; if ( png_get_oFFs ( read_ptr , read_info_ptr , & offset_x , & offset_y , <START_VULN> & unit_type ) ) <END_VULN> { png_set_oFFs ( write_ptr , write_info_ptr , offset_x , offset_y , unit_type ) ; }
destroy_bio ( struct bio * bio ) { pthread_cond_destroy ( & bio -> bio_wait ) ; <START_VULN> <END_VULN> free ( bio ) ; }
#include "conf_space . h" #include "conf_space_quirks . h" <START_VULN> static bool permissive ; <END_VULN> module_param ( permissive , bool , 0644 ) ;
static __u8 * CVE_2012_3364_nci_extract_rf_params_nfca_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfca_poll * nfca_poll , __u8 * data ) { nfca_poll -> sens_res = __le16_to_cpu ( * ( ( __u16 * ) data ) ) ; data += 2 ; <START_VULN> nfca_poll -> nfcid1_len = * data ++ ; <END_VULN> pr_debug ( "sens_res 0x % x , nfcid1_len % d" , nfca_poll -> sens_res , nfca_poll -> nfcid1_len ) ; memcpy ( nfca_poll -> nfcid1 , data , nfca_poll -> nfcid1_len ) ; data += nfca_poll -> nfcid1_len ; nfca_poll -> sel_res_len = * data ++ ; if ( nfca_poll -> sel_res_len != 0 )
u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } <START_VULN> else if ( ps_dec -> u4_first_slice_in_pic == 2 ) <END_VULN> { if ( u2_first_mb_in_slice > 0 ) {
int err ; union { int_mv mv ; <START_VULN> MB_PREDICTION_MODE mode ; <END_VULN> } m ; } ref [ MAX_REF_FRAMES ] ; } MBGRAPH_MB_STATS ;
<START_VULN> if ( png_ptr -> read_buffer ) <END_VULN> { png_bytep buffer = png_ptr -> read_buffer ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : bitrate tracking and management <START_VULN> last mod : $ Id : bitrate . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h> #include < string . h> #include < math . h> #include < oggogg . h> #include "vorbiscodec . h"
} pred_exists = 1 ; if ( switchable_filter_index == 0 && <START_VULN> cpi -> sf . use_rd_breakout && <END_VULN> best_rd < INT64_MAX ) { if ( tmp_best_rdu 2 > best_rd ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : bitrate tracking and management <START_VULN> last mod : $ Id : bitrate . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_BITRATE_H_ #define _V_BITRATE_H_ #include "vorbiscodec . h" #include "codec_internal . h"
if ( LIST_ISEMPTY ( vrrp_data -> vrrp ) ) return ; <START_VULN> file = fopen ( "tmpkeepalived . json" , "w" ) ; <END_VULN> if ( ! file ) { log_message ( LOG_INFO , "Can't open tmpkeepalived . json ( % d : % s ) " , errno , strerror ( errno ) ) ;
<START_VULN> WindowsVersion windowsVersion ( int * major = 0 , int * minor = 0 ) ; <END_VULN> }
goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE | | ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ;
png_ptr -> info_rowbytes = info_ptr -> rowbytes ; #ifndef PNG_READ_EXPAND_SUPPORTED <START_VULN> if ( png_ptr ) <END_VULN> return ; #endif }
return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } <START_VULN> #line 804 "extstandardvar_unserializer . c"<END_VULN> yy25 : yych = * ++ YYCURSOR ; if ( yych <= ' , ' ) {
# define SK_CRASH ( ) __debugbreak ( ) # else # if 1 <START_VULN> # define SK_CRASH ( ) do { SkNO_RETURN_HINT ( ) ; * ( int * ) ( uintptr_t ) 0xbbadbeef = 0 ; } while ( false ) <END_VULN> # else # define SK_CRASH ( ) do { SkNO_RETURN_HINT ( ) ; } while ( true ) # endif
some printers when `currentfile closefile' is followed by space * p += sizeof ( "currentfile closefile" ) - 1 ; <START_VULN> for ( q = p ; isspace ( * q ) && * q != '' ; q ++ ) <END_VULN> if ( q == p && ! * q ) error ( "warning : `currentfile closefile' line too long" ) ;
<START_VULN> PHP_FUNCTION ( locale_get_display_language ) <END_VULN> { get_icu_disp_value_src_php ( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; }
<START_VULN> # if PNG_LIBPNG_BUILD_BASE_TYPE > = PNG_LIBPNG_BUILD_RC<END_VULN> png_ptr -> flags |= PNG_FLAG_APP_WARNINGS_WARN ; # endif # endif
} } break ; <START_VULN> case SPL_FS_DIR : <END_VULN> zend_restore_error_handling ( & error_handling TSRMLS_CC ) ; zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , "Operation not supported" ) ; return NULL ;
if ( ! ent1 -> data ) { if ( stack -> top > 1 ) { stack -> top -- ; } else { stack -> done = 1 ; } <START_VULN> efree ( ent1 ) ; <END_VULN> return ; }
# endif # if defined ( PNG_READ_SUPPORTED ) && defined ( PNG_WRITE_SUPPORTED ) <START_VULN> else if ( ! ( png_ptr -> mode & PNG_IS_READ_STRUCT ) ) <END_VULN> # endif # ifdef PNG_WRITE_SUPPORTED
} LOCAL ( boolean ) get_sos ( j_decompress_ptr cinfo ) { INT32 length ; <START_VULN> int i , ci , n , c , cc ; <END_VULN> jpeg_component_info * compptr ; INPUT_VARS ( cinfo ) ; if ( ! cinfo -> marker -> saw_SOF ) ERREXIT ( cinfo , JERR_SOS_NO_SOF ) ; INPUT_2BYTES ( cinfo , length , return FALSE ) ;
#define UNSTORE16_INT ( ptr , val ) ( val = load_16_be ( ptr ) ) #define UNSTORE32_INT ( ptr , val ) ( val = load_32_be ( ptr ) ) <START_VULN> #define KDB_TL_USER_INFO 0x7ffe<END_VULN> #define KDB_TL_PRINCTYPE 0x01 #define KDB_TL_PRINCCOUNT 0x02
msg [ 0 ] -> msg_style == PAM_PROMPT_ECHO_ON ) ) { * resp = malloc ( sizeof ( struct pam_response ) ) ; assert ( * resp ) ; <START_VULN> ( * resp ) -> resp = calloc ( 1024 , 0 ) ; <END_VULN> struct termios termios = old_termios ; if ( msg [ 0 ] -> msg_style == PAM_PROMPT_ECHO_OFF ) { termios . c_lflag &= ~ ( ECHO | ECHONL ) ;
int asi = decode_asi ( insn , regs ) ; int flag = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <END_VULN> save_and_clear_fpu ( ) ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ 0x1c000 ;
int leftLimit = - 1 , rightLimit ; int i , restoreAlphaBlending = 0 ; <START_VULN> if ( border < 0 ) { <END_VULN> return ; }
{ int i ; for ( i = 31 ; i> = 0 ; i -- ) { <START_VULN> if ( x & ( 1 << i ) ) return i ; <END_VULN> } return 0 ; }
lp ++ ; } <START_VULN> if ( buflen == 0 ) <END_VULN> ( void ) snprintf ( buf , sizeof ( buf ) , fmt == NULL ? "# % 08x" : fmt , v ) ; return ( buf ) ;
q = r = p ; while ( r < t . e ) { <START_VULN> if ( ! vct_iscrlf ( * r ) ) { <END_VULN> r ++ ; continue ; }
for ( i = - 32 ; i < 32 ; i ++ ) { <START_VULN> const int v = ( int ) ( . 5 + 256 * vp8_gaussian ( sigma , 0 , i ) ) ; <END_VULN> if ( v ) {
RD_BOOL <START_VULN> ber_parse_header ( STREAM s , int tagval , int * length ) <END_VULN> { int tag , len ;
static int check_line_charstring ( void ) { char * p = line ; <START_VULN> while ( isspace ( * p ) ) <END_VULN> p ++ ; return ( * p == '' | | ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }
if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > GetBlobSize ( image ) ) <START_VULN> ThrowReaderException ( CorruptImageError , <END_VULN> "InsufficientImageDataInFile" ) ; if ( ~ length > = 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum *
kw_value_len = uloc_getKeywordValue ( loc_name , kw_key , kw_value , kw_value_len + 1 , & status ) ; } else if ( ! U_FAILURE ( status ) ) { kw_value = erealloc ( kw_value , kw_value_len + 1 ) ; <START_VULN> } <END_VULN> if ( U_FAILURE ( status ) ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "locale_get_keywords : Error encountered while getting the keyword value for the keyword" , 0 TSRMLS_CC ) ; if ( kw_value ) {
unsigned long addr = compute_effective_address ( regs , insn ) ; int err ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <END_VULN> switch ( dir ) { case load : err = do_int_load ( fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) ,
for ( i = 0 ; i < num_part ; i ++ ) { <START_VULN> vpx_memmove ( dp , cpi -> partition_d [ i + 1 ] , cpi -> partition_sz [ i + 1 ] ) ; <END_VULN> cpi -> partition_d [ i + 1 ] = dp ; dp += cpi -> partition_sz [ i + 1 ] ; }
static void setConfigDefaults ( HttpRoute * route ) { <START_VULN> route -> mode = mprGetJson ( route -> config , "app . mode" ) ; <END_VULN> if ( smatch ( route -> mode , "debug" ) ) { httpSetRouteShowErrors ( route , 1 ) ; route -> keepSource = 1 ;
if ( nb_components <= 0 | | nb_components > MAX_COMPONENTS ) return - 1 ; if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) ) { if ( nb_components != s -> nb_components ) { av_log ( s -> avctx , AV_LOG_ERROR , "nb_components changing in interlaced picture" ) ; return AVERROR_INVALIDDATA ; } } <START_VULN> if ( s -> ls && ! ( s -> bits <= 8 | | nb_components == 1 ) ) { <END_VULN> avpriv_report_missing_feature ( s -> avctx , "JPEG - LS that is not <= 8 " "bitscomponent or 16 - bit gray" ) ; return AVERROR_PATCHWELCOME ; } s -> nb_components = nb_components ; s -> h_max = 1 ; s -> v_max = 1 ; memset ( h_count , 0 , sizeof ( h_count ) ) ; memset ( v_count , 0 , sizeof ( v_count ) ) ;
yych = * ++ YYCURSOR ; if ( yych != '"' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 707 "extstandardvar_unserializer . re"<END_VULN> { size_t len , len2 , len3 , maxlen ; long elements ;
#include < utility> #include "basecallback . h" #include "basememoryptr_util . h" <START_VULN> #include "basemove . h"<END_VULN> #include "third_partyWebKitpublicplatformWebCallbacks . h"
} png_ptr -> num_palette = ( png_uint_16 ) num_palette ; <START_VULN> if ( full_quantize ) <END_VULN> { int i ; png_bytep distance ;
#include < string> #include "baseatomic_sequence_num . h" <START_VULN> #include "basecallback . h"<END_VULN> #include "basetime . h" #include "contentbrowsercancelable_request . h" #include "contentcommonnotification_observer . h"
PHP_FUNCTION ( mcrypt_module_is_block_algorithm_mode ) { MCRYPT_GET_MODE_DIR_ARGS ( modes_dir ) <START_VULN> <END_VULN> if ( mcrypt_module_is_block_algorithm_mode ( module , dir ) == 1 ) { RETURN_TRUE ; } else {
int colorMap [ gdMaxColors ] ; int * stx , * sty ; <START_VULN> <END_VULN> if ( overflow2 ( sizeof ( int ) , srcW ) ) { return ; }
bool isVector ( ) const { return size > 1 && ! matrix ; } bool isScalar ( ) const { return size == 1 && ! matrix && ! structure ; } TTypeList * getStruct ( ) const { return structure ; } void setStruct ( TTypeList * s ) { structure = s ; computeDeepestStructNesting ( ) ; } const TString & getTypeName ( ) const { <START_VULN> assert ( typeName ) ; <END_VULN> return * typeName ; } void setTypeName ( const TString & n ) { typeName = NewPoolTString ( n . c_str ( ) ) ; } bool isField ( ) const { return fieldName != 0 ; }
NetworkReaderProxy ( <START_VULN> int64 content_length , const base : : Closure & job_canceller ) ; <END_VULN> virtual ~ NetworkReaderProxy ( ) ;
void RemovingFromWindow ( ) ; void CopyFromCompositingSurface ( const gfx : : Rect & src_subrect , <START_VULN> const gfx : : Size & dst_size , <END_VULN> const base : : Callback < void ( bool , const SkBitmap & ) > & callback , const SkColorType color_type ) ; void CopyFromCompositingSurfaceToVideoFrame (
void AddTaskObserver ( base : : MessageLoop : : TaskObserver * task_observer ) ; void RemoveTaskObserver ( base : : MessageLoop : : TaskObserver * task_observer ) ; <START_VULN> void SetTimeSourceForTesting ( scoped_ptr < TimeSource> time_source ) ; <END_VULN>
{ * q ++ = ( unsigned char ) ( GetPixelLuma ( image , p ) > = ( QuantumRange2 . 0 ) ? '0' : '1' ) ; <START_VULN> * q ++ = ' ' ; <END_VULN> if ( ( q - pixels + 1 ) > = ( ssize_t ) sizeof ( pixels ) ) { * q ++ = '' ; ( void ) WriteBlob ( image , q - pixels , pixels ) ; q = pixels ; } p ++ ; } * q ++ = '' ;
#ifndef EXTENSIONS_BROWSER_GUEST_VIEW_GUEST_VIEW_H_ #define EXTENSIONS_BROWSER_GUEST_VIEW_GUEST_VIEW_H_ <START_VULN> #include "basebind . h"<END_VULN> #include "contentpublicbrowserrender_frame_host . h" #include "extensionsbrowserguest_viewguest_view_base . h" namespace extensions {
yych = * ++ YYCURSOR ; if ( yych != '"' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 643 "extstandardvar_unserializer . re"<END_VULN> { size_t len , maxlen ; char * str ;
<START_VULN> for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <END_VULN> jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ; }
<START_VULN> enum StyleDifference { <END_VULN> StyleDifferenceEqual , StyleDifferenceRecompositeLayer , StyleDifferenceRepaint ,
<START_VULN> for_each_leaf_cfs_rq_safe ( rq , cfs_rq , pos ) { <END_VULN> struct sched_entity * se ;
#endif PHP_GD_CHECK_OPEN_BASEDIR ( fontname , "Invalid font filename" ) ; <START_VULN> <END_VULN> #ifdef HAVE_GD_FREETYPE if ( extended ) { error = gdImageStringFTEx ( im , brect , col , fontname , ptsize , angle , x , y , str , & strex ) ;
void SetDirectionFromNewTextNode ( nsIContent * aTextNode ) ; <START_VULN> void ResetDirectionSetByTextNode ( nsTextNode * aTextNode ) ; <END_VULN> void SetDirectionalityFromValue ( mozilla : : dom : : Element * aElement , const nsAString & aValue , bool aNotify ) ;
l_int32 gplotMakeOutput ( GPLOT * gplot ) { <START_VULN> char buf [ L_BUF_SIZE ] ; <END_VULN> char * cmdname ; l_int32 ignore ;
else { vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ; <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <END_VULN> } q += 16 ;
{ BTIF_TRACE_DEBUG ( "app_idx = % d mcl_idx = 0x % x mdl_idx = 0x % x data_size = % d" , app_idx , mcl_idx , mdl_idx , data_size ) ; <START_VULN> r = send ( p_dcb -> p_scb -> socket_id [ 1 ] , p_dcb -> p_rx_pkt , data_size , 0 ) ; <END_VULN> if ( r == data_size ) {
<START_VULN> if ( bytecnt ) { <END_VULN> wpc -> file_format = * byteptr ++ ; wpc -> config . qmode = ( wpc -> config . qmode & ~ 0xff ) | * byteptr ++ ; bytecnt -= 2 ;
{ const short * HFilter ; const short * VFilter ; <START_VULN> DECLARE_ALIGNED_ARRAY ( 4 , short , FData , 12 * 4 ) ; <END_VULN> HFilter = vp8_sub_pel_filters [ xoffset ] ;
public : <START_VULN> PlatformSensorAccelerometerMac ( mojo : : ScopedSharedBufferMapping mapping , <END_VULN> PlatformSensorProvider * provider ) ; mojom : : ReportingMode GetReportingMode ( ) override ;
int re_yyget_column ( yyscan_t yyscanner ) { struct yyguts_t * yyg = ( struct yyguts_t * ) yyscanner ; <START_VULN> <END_VULN> if ( ! YY_CURRENT_BUFFER ) return 0 ;
int badop = 0 , bugs = 0 ; int ret = 1 ; int off = 0 ; <START_VULN> int no_tmp_rsa = 0 , nocert = 0 ; <END_VULN> int state = 0 ; SSL_METHOD * meth = NULL ; #ifndef NO_DH
png_debug1 ( 1 , "in % s storage function" , "tIME" ) ; if ( png_ptr == NULL | | info_ptr == NULL | | mod_time == NULL | | <START_VULN> ( png_ptr -> mode & PNG_WROTE_tIME ) ) <END_VULN> return ; if ( mod_time -> month == 0 | | mod_time -> month > 12 | |
virtual bool IsTransportSeekable ( ) = 0 ; <START_VULN> static MediaResource * Create ( MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <END_VULN> virtual nsresult Open ( nsIStreamListener ** aStreamListener ) = 0 ; #ifdef MOZ_DASH
xd -> mi [ 0 ] -> bmi [ i ] . as_mode = best_bmodes [ i ] . as_mode ; } else { for ( i = 0 ; i < 4 ; ++ i ) <START_VULN> vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ; <END_VULN> mbmi -> mv [ 0 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 0 ] . as_int ; mbmi -> mv [ 1 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 1 ] . as_int ;
void DispatchTabUpdatedEvent ( content : : WebContents * contents , <START_VULN> DictionaryValue * changed_properties ) ; <END_VULN>
} static void <START_VULN> image_transform_set_end ( PNG_CONST image_transform * this , <END_VULN> transform_display * that , png_structp pp , png_infop pi ) { UNUSED ( this )
} else { for ( i = 0 ; i < s -> entries ; i ++ ) { long num = oggpack_read ( opb , 5 ) ; if ( num == - 1 ) goto _eofout ; s -> lengthlist [ i ] = num + 1 ; } } <START_VULN> <END_VULN> break ; case 1 : { long length = oggpack_read ( opb , 5 ) + 1 ; s -> lengthlist = _ogg_malloc ( sizeof ( * s -> lengthlist ) * s -> entries ) ; for ( i = 0 ; i < s -> entries ; ) {
int new_width = cpi -> oxcf . Width ; int new_height = cpi -> oxcf . Height ; <START_VULN> int projected_buffer_level = ( int ) cpi -> buffer_level ; <END_VULN> int tmp_q ; double projected_bits_perframe ;
{ if ( ! GPMF_VALID_FOURCC ( qttag ) ) { <START_VULN> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <END_VULN> NESTSIZE ( lastsize - 8 ) ; continue ;
template < typename T , typename . . . Args> std : : unique_ptr < T> QuicMakeUniqueImpl ( Args && . . . args ) { <START_VULN> return base : : MakeUnique < T> ( std : : forward < Args> ( args ) . . . ) ; <END_VULN> } template < typename T>
If the original socket has an SSL configuration , the new socket will share the same SSL configuration object . @return A new socket object @ingroup MprSocket <START_VULN> @stability Prototype<END_VULN> PUBLIC MprSocket * mprCloneSocket ( MprSocket * sp ) ;
virtual PassRefPtr < Scrollbar> createScrollbar ( ScrollableArea * , ScrollbarOrientation , ScrollbarControlSize ) ; virtual void listBoxSelectItem ( int listIndex , bool allowMultiplySelections , bool shift , bool fireOnChangeNow = true ) ; <START_VULN> virtual bool multiple ( ) ; <END_VULN> virtual bool hasLineIfEmpty ( ) const { return true ; }
PHPAPI char * xml_utf8_decode ( const XML_Char * s , int len , int * newlen , const XML_Char * encoding ) { <START_VULN> int pos = len ; <END_VULN> char * newbuf = emalloc ( len + 1 ) ; unsigned int c ; char ( * decoder ) ( unsigned short ) = NULL ;
break ; case EFFECT_CMD_ENABLE : <START_VULN> if ( pReplyData == NULL | | * replySize != sizeof ( int ) ) { <END_VULN> return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_INITIALIZED ) {
ZVAL_STRINGL ( * rval , str , len , 1 ) ; return 1 ; } <START_VULN> #line 970 "extstandardvar_unserializer . c"<END_VULN> yy53 : yych = * ++ YYCURSOR ; if ( yych <= '' ) {
#endif <START_VULN> if ( transforms & PNG_TRANSFORM_SWAP_ENDIAN ) <END_VULN> #ifdef PNG_READ_SWAP_SUPPORTED png_set_swap ( png_ptr ) ; #else
Address addr = reinterpret_cast < Address> ( const_cast < void * > ( payload ) ) ; HeapObjectHeader * header = reinterpret_cast < HeapObjectHeader * > ( addr - sizeof ( HeapObjectHeader ) ) ; <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <END_VULN> return header ; }
header [ 11 ] = ( rec -> length ) >> 8 ; header [ 12 ] = ( rec -> length ) & 0xff ; <START_VULN> if ( ! send && ! SSL_USE_ETM ( ssl ) && <END_VULN> EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && ssl3_cbc_record_digest_supported ( mac_ctx ) ) { # define SSL_PKEY_RSA_ENC 0
{ int num = SWFInput_readBits ( input , number ) ; <START_VULN> if ( num & ( 1 << ( number - 1 ) ) ) <END_VULN> return num - ( 1 << number ) ; else return num ;
bitmapH = ( HBITMAP ) GetClipboardData ( CF_BITMAP ) ; hPal = ( HPALETTE ) GetClipboardData ( CF_PALETTE ) ; CloseClipboard ( ) ; <START_VULN> if ( bitmapH == NULL ) <END_VULN> ThrowReaderException ( CoderError , "NoBitmapOnClipboard" ) ; { BITMAPINFO
based temporary image . * pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; if ( ! pim ) { <START_VULN> return ; <END_VULN> } tim = pim ; }
void AuthorizeAllPlugins ( int render_process_id ) ; <START_VULN> virtual bool IsPluginEnabled ( <END_VULN> int render_process_id , int render_view_id , const void * context ,
#include "vpxvpx_codec . h" <START_VULN> static const char * const cfg = " -- target = mips32 - linux - gcc -- disable - dspr2 -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
#ifdef FLOAT_LOOKUP #include "vorbis_lookup . c" void vorbis_lsp_to_curve ( float * curve , int * map , int n , int ln , float * lsp , int m , <START_VULN> float amp , float ampoffset ) { <END_VULN> int i ; float wdel = M_PIln ; vorbis_fpu_control fpu ; vorbis_fpu_setround ( & fpu ) ; for ( i = 0 ; i < m ; i ++ ) lsp [ i ] = vorbis_coslook ( lsp [ i ] ) ; i = 0 ;
rowsperstrip = td -> td_rowsperstrip ; if ( rowsperstrip>td -> td_imagelength ) rowsperstrip = td -> td_imagelength ; <START_VULN> stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) rowsperstrip ) ; <END_VULN> stripinplane = ( strip % stripsperplane ) ; plane = ( uint16 ) ( stripstripsperplane ) ; rows = td -> td_imagelength - stripinplane * rowsperstrip ;
pos = png_safecat ( message , ( sizeof message ) , 0 , "profile '" ) ; pos = png_safecat ( message , pos + 79 , pos , name ) ; pos = png_safecat ( message , ( sizeof message ) , pos , "' : " ) ; <START_VULN> if ( is_ICC_signature ( value ) ) <END_VULN> { png_icc_tag_name ( message + pos , ( png_uint_32 ) value ) ;
case PseudoColor : { if ( ( header . bits_per_pixel < 1 ) | | ( header . bits_per_pixel > 15 ) | | <START_VULN> ( header . ncolors == 0 ) ) <END_VULN> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; break ; }
void RequestDecode ( RasterImage * aImg ) ; <START_VULN> void DecodeABitOf ( RasterImage * aImg ) ; <END_VULN>
* <START_VULN> <END_VULN> #include "ssl . h" #include "sslimpl . h" #include "sslproto . h" static const char * ssl_GetCompressionMethodName ( SSLCompressionMethod compression ) { switch ( compression ) {
int jpg_validate ( jas_stream_t * in ) { <START_VULN> uchar buf [ JPG_MAGICLEN ] ; <END_VULN> int i ; int n ;
if ( fp != NULL ) { if ( png_image_write_to_stdio ( image , fp , convert_to_8bit , buffer , <START_VULN> row_stride , colormap ) ) <END_VULN> { int error ;
friend class CanvasRenderingContext2DUserData ; protected : nsresult GetImageDataArray ( JSContext * aCx , int32_t aX , int32_t aY , uint32_t aWidth , uint32_t aHeight , JSObject ** aRetval ) ; nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <START_VULN> unsigned char * aData , uint32_t aDataLen , <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , int32_t dirtyWidth , int32_t dirtyHeight ) ; nsresult Initialize ( int32_t width , int32_t height ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic shared codebook operations <START_VULN> last mod : $ Id : sharedbook . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h> #include < math . h> #include < string . h> #include < oggogg . h> #include "os . h"
* entity = ( const unsigned char * ) c -> data . multicodepoint_table [ 0 ] . leading_entry . default_entity ; * entity_len = c -> data . multicodepoint_table [ 0 ] . leading_entry . default_entity_len ; <START_VULN> } <END_VULN> }
#endif #endif } else { <START_VULN> strncpy ( result , "undefined" , 10 ) ; <END_VULN> } }
break ; offset = donote ( ms , nbuf , offset , ( size_t ) bufsize , clazz , swap , align , <START_VULN> flags ) ; <END_VULN> if ( offset == 0 ) break ; }
SPL_METHOD ( DirectoryIterator , rewind ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } <START_VULN> #line 784 "extstandardvar_unserializer . c"<END_VULN> yy25 : yych = * ++ YYCURSOR ; if ( yych <= ' , ' ) {
DestroyQuantumPixels ( quantum_info ) ; quantum = ( quantum_info -> pad + 6 ) * ( quantum_info -> depth + 7 ) 8 ; extent = image -> columns * quantum ; <START_VULN> if ( quantum != ( extentimage -> columns ) ) <END_VULN> return ( MagickFalse ) ; return ( AcquireQuantumPixels ( quantum_info , extent ) ) ; }
<START_VULN> snprintf ( buf , sizeof ( buf ) , filename , dec_ctx -> frame_number ) ; <END_VULN> pgm_save ( frame -> data [ 0 ] , frame -> linesize [ 0 ] , frame -> width , frame -> height , buf ) ; }
} ; GpuChannelHostFactory * factory_ ; <START_VULN> int gpu_process_id_ ; <END_VULN> int client_id_ ; State state_ ;
if ( size > ( MAX_SIZE_T - RESERVE_SIZE ) ) { xmlGenericError ( xmlGenericErrorContext , <START_VULN> "xmlMallocAtomicLoc : Unsigned overflow prevented" ) ; <END_VULN> xmlMemoryDump ( ) ; return ( NULL ) ; }
const png_structrp png_ptr = image -> opaque -> png_ptr ; const png_uint_32 output_format = image -> format ; <START_VULN> const int output_encoding = ( output_format & PNG_FORMAT_FLAG_LINEAR ) ? <END_VULN> P_LINEAR : P_sRGB ; unsigned int cmap_entries ;
PTA * ptaReadStream ( FILE * fp ) { <START_VULN> char typestr [ 128 ] ; <END_VULN> l_int32 i , n , ix , iy , type , version ; l_float32 x , y ; PTA * pta ;
if ( ! src -> trueColor ) { gdImagePaletteToTrueColor ( src ) ; } <START_VULN> <END_VULN> gdAffineTranslate ( m , - bbox . x , - bbox . y ) ; gdAffineConcat ( m , affine , m ) ;
else if ( jsvIsFloat ( var ) ) jsiConsolePrintf ( "Double % f" , jsvGetFloat ( var ) ) ; else if ( jsvIsFunctionParameter ( var ) ) jsiConsolePrintf ( "Param % q " , var ) ; else if ( jsvIsArrayBufferName ( var ) ) jsiConsolePrintf ( "ArrayBufferName [ % d ] " , jsvGetInteger ( var ) ) ; <START_VULN> else if ( jsvIsArrayBuffer ( var ) ) jsiConsolePrintf ( " % s " , jswGetBasicObjectName ( var ) ) ; <END_VULN> else if ( jsvIsString ( var ) ) { size_t blocks = 1 ; if ( jsvGetLastChild ( var ) ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <START_VULN> #if defined ( HAVE_GETTIMEOFDAY ) <END_VULN> void jas_tmr_start ( jas_tmr_t * tmr ) {
DEBUG ( "emulate a2dp write delay ( % d us ) " , us_delay ) ; <START_VULN> usleep ( us_delay ) ; <END_VULN> pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; }
cpi -> twopass . frames_to_key = 1 ; <START_VULN> vpx_memcpy ( & first_frame , this_frame , sizeof ( * this_frame ) ) ; <END_VULN> cpi -> twopass . kf_group_bits = 0 ; cpi -> twopass . kf_group_error_left = 0 ;
int y4m_write_file_header ( char * buf , size_t len , int width , int height , const struct VpxRational * framerate , <START_VULN> vpx_img_fmt_t fmt ) ; <END_VULN> int y4m_write_frame_header ( char * buf , size_t len ) ; #ifdef __cplusplus
return length ; } <START_VULN> int get_down2_steps ( int in_length , int out_length ) { <END_VULN> int steps = 0 ; int proj_in_length ; while ( ( proj_in_length = get_down2_length ( in_length , 1 ) ) > = out_length ) {
status = MagickTrue ; maximum_length = 0 . 0 ; total_length = 0 . 0 ; <START_VULN> for ( i = 1 ; ( i < number_vertices ) && ( length > = 0 . 0 ) ; i ++ ) <END_VULN> { dx = primitive_info [ i ] . point . x - primitive_info [ i - 1 ] . point . x ; dy = primitive_info [ i ] . point . y - primitive_info [ i - 1 ] . point . y ;
} ; extern nsresult <START_VULN> NS_CreateJSTimeoutHandler ( nsIScriptContext * aContext , <END_VULN> PRBool * aIsInterval , PRInt32 * aInterval , nsIScriptTimeoutHandler ** aRet ) ;
} if ( ntohs ( uh -> uh_dport ) == TFTP_SERVER ) { tftp_input ( m ) ; goto bad ; } so = slirp -> udp_last_so ; <START_VULN> if ( so -> so_lport != uh -> uh_sport | | <END_VULN> so -> so_laddr . s_addr != ip -> ip_src . s_addr ) { struct socket * tmp ; for ( tmp = slirp -> udb . so_next ; tmp != & slirp -> udb ; tmp = tmp -> so_next ) { if ( tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr ) { so = tmp ; break ; }
} } } <START_VULN> #endif<END_VULN> void PNGAPI png_read_row ( png_structrp png_ptr , png_bytep row , png_bytep dsp_row )
#ifdef PNG_READ_sPLT_SUPPORTED PNG_INTERNAL_FUNCTION ( void , png_handle_sPLT , ( png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) , PNG_EMPTY ) ; <START_VULN> #endif<END_VULN> #ifdef PNG_READ_sRGB_SUPPORTED PNG_INTERNAL_FUNCTION ( void , png_handle_sRGB , ( png_structrp png_ptr ,
1 , - 533200896 , 1611661312 , 4 , 1 , partial_quantlist1 , NULL , NULL , NULL , 0 } ; static float test5_result [ ] = { - 3 , - 6 , - 9 , 4 , 1 , - 2 , - 1 , - 4 , - 7 , - 3 , 1 , - 2 , 4 , 8 , 5 , - 1 , 3 , 0 , <START_VULN> - 3 , - 4 , - 7 , 4 , 3 , 0 , - 1 , - 2 , - 5 , <END_VULN> - 3 , - 6 , - 2 , 4 , 1 , 5 , - 1 , - 4 , 0 , - 3 , 1 , 5 , 4 , 8 , 12 , - 1 , 3 , 7 , - 3 , - 4 , 0 , 4 , 3 , 7 , - 1 , - 2 , 2 , - 3 , - 6 , - 7 , 4 , 1 , 0 , - 1 , - 4 , - 5 , - 3 , 1 , 0 , 4 , 8 , 7 , - 1 , 3 , 2 , - 3 , - 4 , - 5 , 4 , 3 , 2 , - 1 , - 2 , - 3 } ; void run_test ( static_codebook * b , float * comp ) {
<START_VULN> if ( ( fd = open ( clonedev , O_RDWR ) ) < 0 ) <END_VULN> { BTIF_TRACE_DEBUG ( "could not open % s , err : % d" , clonedev , errno ) ; return fd ;
set_intr_gate ( X86_TRAP_OLD_MF , coprocessor_segment_overrun ) ; set_intr_gate ( X86_TRAP_TS , invalid_TSS ) ; set_intr_gate ( X86_TRAP_NP , segment_not_present ) ; <START_VULN> set_intr_gate_ist ( X86_TRAP_SS , & stack_segment , STACKFAULT_STACK ) ; <END_VULN> set_intr_gate ( X86_TRAP_GP , general_protection ) ; set_intr_gate ( X86_TRAP_SPURIOUS , spurious_interrupt_bug ) ; set_intr_gate ( X86_TRAP_MF , coprocessor_error ) ;
} static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , <START_VULN> int ctr_id , va_list args ) { <END_VULN> vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ; if ( frame != NULL ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : modified discrete cosine transform prototypes <START_VULN> last mod : $ Id : mdct . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _OGG_mdct_H_ #define _OGG_mdct_H_ #include "vorbiscodec . h"
PHP_FUNCTION ( mcrypt_module_self_test ) { MCRYPT_GET_MODE_DIR_ARGS ( algorithms_dir ) ; <START_VULN> <END_VULN> if ( mcrypt_module_self_test ( module , dir ) == 0 ) { RETURN_TRUE ; } else {
vpx_codec_iter_t iter = NULL ; vpx_image_t * img ; struct vpx_usec_timer timer ; <START_VULN> int corrupted ; <END_VULN> frame_avail = 0 ; if ( ! stop_after | | frame_in < stop_after ) {
MagickExport int LocaleLowercase ( const int c ) { <START_VULN> if ( c < 0 ) <END_VULN> return ( c ) ; #if defined ( MAGICKCORE_LOCALE_SUPPORT ) if ( c_locale != ( locale_t ) NULL )
IPC_STRUCT_MEMBER ( GURL , opener_url ) <START_VULN> IPC_STRUCT_MEMBER ( std : : string , opener_security_origin ) <END_VULN>
if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'u' , 'd' , 't' , 'a' ) ) { <START_VULN> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <END_VULN> NESTSIZE ( qtsize ) ; continue ; }
if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; } <START_VULN> <END_VULN> RETURN_FALSE ; }
{ vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstv + 4 , stride , dstv + 4 , stride ) ; <START_VULN> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <END_VULN> } q += 32 ;
<START_VULN> found = ( unsigned char * ) php_memnstr ( ( char * ) haystack + offset , ( char * ) needle , needle_len , ( char * ) haystack + haystack_len ) ; <END_VULN> if ( ! found ) {
ND_PRINT ( ( ndo , " ] " ) ) ; return ; trunc : <START_VULN> ND_PRINT ( ( ndo , " [ | icmp6 ] " ) ) ; <END_VULN> return ; }
case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; <START_VULN> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; <END_VULN> switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; ND_PRINT ( ( ndo , " % s Setup Priority : % u , Holding Priority : % u , Hop - limit : % u , Bandwidth : % . 10g Mbps" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio ,
io -> flag = 0 ; io -> offset = 0 ; io -> size = 0 ; <START_VULN> io -> error = 0 ; <END_VULN> INIT_WORK ( & io -> work , ext4_end_io_work ) ; INIT_LIST_HEAD ( & io -> list ) ; }
return 1 ; } mpz_init ( temp ) ; <START_VULN> mpz_powm ( r , key -> g , k , key -> p ) ; <END_VULN> mpz_mod ( r , r , key -> q ) ; mpz_invert ( s , k , key -> q ) ; mpz_mul ( temp , key -> x , r ) ;
Try { <START_VULN> make_transform_images ( & pm . this ) ; <END_VULN> if ( pm . test_standard )
int subtype , hexdump = FALSE ; u_int sublen ; u_int tval ; <START_VULN> uint8_t i ; <END_VULN> if ( tlv_len < 4 ) { return hexdump ;
ulong flags ; TRACE2 ( ( "CVE_2009_3080_gdth_read_event ( ) handle % d" , handle ) ) ; spin_lock_irqsave ( & ha -> smp_lock , flags ) ; if ( handle == - 1 ) eindex = eoldidx ; else eindex = handle ; estr -> event_source = 0 ; <START_VULN> if ( eindex > = MAX_EVENTS ) { <END_VULN> spin_unlock_irqrestore ( & ha -> smp_lock , flags ) ; return eindex ; } e = & ebuffer [ eindex ] ; if ( e -> event_source != 0 ) { if ( eindex != elastidx ) { if ( ++ eindex == MAX_EVENTS ) eindex = 0 ; } else { eindex = - 1 ;
@param dispatcher Event dispatcher @return Event mark 64 bit integer @ingroup MprDispatcher <START_VULN> @stability Prototype<END_VULN> PUBLIC int64 mprGetEventMark ( MprDispatcher * dispatcher ) ;
SPL_METHOD ( FilesystemIterator , getFlags ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
MAKE_STD_ZVAL ( http_header ) ; ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ; <START_VULN> <END_VULN> zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ; } } else {
<START_VULN> int npasses = png_set_interlace_handling ( pp ) ; <END_VULN> int pass ; if ( npasses != npasses_from_interlace_type ( pp , interlace_type ) )
bucket_t * bucket ; size_t index ; <START_VULN> index = hash % num_buckets ( hashtable ) ; <END_VULN> bucket = & hashtable -> buckets [ index ] ; pair = hashtable_find_pair ( hashtable , bucket , key , hash ) ;
proto_tree_add_text ( sched_subtree , tvb , offset , 1 , "Slot : % d reserved MDT : % x" , new_slots [ k ] , octet1 ) ; other_slots [ new_slots [ i ] - 1 ] = 0xFFFE ; } } proto_item_set_end ( item , tvb , offset ) ; item = proto_tree_add_text ( sched_tree , tvb , offset , 0 , "Other message slots in this schedule" ) ; sched_subtree = proto_item_add_subtree ( item , ett_schedule_new_msg ) ; <START_VULN> for ( k = 0 ; offset < len ; j ++ ) <END_VULN> { while ( ( other_slots [ k ] != 0xFFFF ) && ( k < sched_end ) ) { k ++ ; } if ( k > = sched_end ) break ; octet1 = tvb_get_guint8 ( tvb , offset ) ; if ( ( octet1 & 0x80 ) == 0x80 )
break ; } } <START_VULN> <END_VULN> if ( RAW != 0 ) { xmlFatalErr ( ctxt , XML_ERR_EXT_SUBSET_NOT_FINISHED , NULL ) ; }
class nsIconDecoder : public Decoder { public : nsIconDecoder ( RasterImage & aImage ) ; virtual ~ nsIconDecoder ( ) ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> uint8_t mWidth ; uint8_t mHeight ; uint32_t mPixBytesRead ; uint32_t mState ; } ; enum {
RefPtr < Image> previous_image_ ; Member < ScriptedAnimationController> scripted_animation_controller_ ; <START_VULN> bool pending_raf_ = false ; <END_VULN> bool pending_vsync_ = false ; bool in_animation_frame_ = false ; bool in_display_activate_ = false ;
static void cpStripToTile ( uint8 * out , uint8 * in , <START_VULN> uint32 rows , uint32 cols , int outskew , int inskew ) <END_VULN> { while ( rows -- > 0 ) { uint32 j = cols ;
) ; } <START_VULN> void vp8_pack_tokens_c ( vp8_writer * w , const TOKENEXTRA * p , int xcount ) <END_VULN> { const TOKENEXTRA * stop = p + xcount ; unsigned int split ;
} } <START_VULN> <END_VULN> efree ( offsets ) ; }
int result = - 1 ; int i = 0 ; int len = 0 ; <START_VULN> <END_VULN> if ( str && ( ( len = strlen ( str ) ) >0 ) ) { for ( i = 0 ; i < len ; i ++ ) { if ( isIDSeparator ( * ( str + i ) ) ) {
if ( pv -> context -> extradata == NULL ) { <START_VULN> if ( pv -> parser == NULL | | pv -> parser == NULL | | <END_VULN> pv -> parser -> parser -> split == NULL ) { return 0 ;
WiFiDisplayMediaDatagramPacket ( WiFiDisplayMediaDatagramPacket && ) ; private : <START_VULN> DISALLOW_COPY_AND_ASSIGN_WITH_MOVE_FOR_BIND ( WiFiDisplayMediaDatagramPacket ) ; <END_VULN> } ;
const u_char * bp , u_int length , const u_char * bp2 ) { <START_VULN> <END_VULN> if ( length == 1 && bp [ 0 ] == 0xff ) { ND_PRINT ( ( ndo , "isakmp - nat - keep - alive" ) ) ; return ;
SPL_METHOD ( SplFileObject , getMaxLineLen ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
{ D45_PRED , { INTRA_FRAME , NONE } } , } ; <START_VULN> const REF_DEFINITION vp9_ref_order [ MAX_REFS ] = { <END_VULN> { { LAST_FRAME , NONE } } , { { GOLDEN_FRAME , NONE } } , { { ALTREF_FRAME , NONE } } ,
{ char * filein , * str , * tempfile , * prestring , * outprotos , * protostr ; const char * spacestr = " " ; <START_VULN> char buf [ L_BUF_SIZE ] ; <END_VULN> l_uint8 * allheaders ; l_int32 i , maxindex , in_line , nflags , protos_added , firstfile , len , ret ; size_t nbytes ;
{ const short * HFilter ; const short * VFilter ; <START_VULN> DECLARE_ALIGNED_ARRAY ( 4 , short , FData , 24 * 16 ) ; <END_VULN> HFilter = vp8_sub_pel_filters [ xoffset ] ; VFilter = vp8_sub_pel_filters [ yoffset ] ;
} break ; case rsaKey : { SECItem digest ; digest . data = final ; digest . len = part ; if ( sig ) { PORT_Assert ( cx -> hashAlg != SEC_OID_UNKNOWN ) ; <START_VULN> SECOidTag hashid ; <END_VULN> rv = recoverPKCS1DigestInfo ( cx -> hashAlg , & hashid , & cx -> pkcs1RSADigestInfo , & cx -> pkcs1RSADigestInfoLen , cx -> key , sig , cx -> wincx ) ; PORT_Assert ( cx -> hashAlg == hashid ) ; if ( rv != SECSuccess ) { return SECFailure ;
#include < freerdpapi . h> <START_VULN> FREERDP_LOCAL void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , <END_VULN> UINT32 rowstride ) ; #endif
interlace_type < INTERLACE_LAST ; ++ interlace_type ) { standard_test ( & pm -> this , FILEID ( colour_type , DEPTH ( bdlo ) , 0 , <START_VULN> interlace_type , 0 , 0 , 0 ) , 0 , pm -> use_update_info ) ; <END_VULN> if ( fail ( pm ) ) return 0 ;
protected : virtual ~ PlatformSensor ( ) ; PlatformSensor ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> PlatformSensorProvider * provider ) ; using ReadingBuffer = SensorReadingSharedBuffer ;
if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip && <START_VULN> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <END_VULN> rxent -> dport == sport ) {
#ifdef PNG_READ_iCCP_SUPPORTED PNG_INTERNAL_FUNCTION ( void , png_handle_iCCP , ( png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) , PNG_EMPTY ) ; <START_VULN> #endif<END_VULN> #ifdef PNG_READ_iTXt_SUPPORTED PNG_INTERNAL_FUNCTION ( void , png_handle_iTXt , ( png_structrp png_ptr ,
def = sfmt ( " { password : ' % s' , roles : [ % s ] } " , encodedPassword , sjoinArgs ( argc - 3 , ( cchar ** ) & argv [ 3 ] , " , " ) ) ; credentials = mprParseJson ( def ) ; key = sfmt ( "app . http . auth . users . % s" , username ) ; <START_VULN> if ( mprSetJsonObj ( app -> config , key , credentials ) < 0 ) { <END_VULN> fail ( "Cannot update % s" , key ) ; return ; }
int size ; syscall_nr = trace_get_syscall_nr ( current , regs ) ; <START_VULN> if ( syscall_nr < 0 ) <END_VULN> return ; if ( ! test_bit ( syscall_nr , enabled_perf_enter_syscalls ) ) return ;
fd_printf ( STO , " ** * cannot read filename ** * r" ) ; break ; } <START_VULN> run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; <END_VULN> free ( fname ) ; break ; case KEY_BREAK :
JSObject * argv6 = JSVAL_TO_OBJECT ( argv [ 6 ] ) ; jsval js_width , js_height , js_data ; JS_GetProperty ( cx , argv6 , "width" , & js_width ) ; JS_GetProperty ( cx , argv6 , "height" , & js_height ) ; JS_GetProperty ( cx , argv6 , "data" , & js_data ) ; if ( js_width == JSVAL_VOID | | js_height == JSVAL_VOID | | <START_VULN> js_data == JSVAL_VOID ) <END_VULN> { xpc_qsThrowBadArg ( cx , NS_ERROR_FAILURE , vp , 6 ) ; return JS_FALSE ; } int32_t int_width , int_height ; JSObject * obj_data = JSVAL_TO_OBJECT ( js_data ) ; if ( ! JS_ValueToECMAInt32 ( cx , js_width , & int_width ) | | ! JS_ValueToECMAInt32 ( cx , js_height , & int_height ) )
Client * client_ = nullptr ; const PreserveDrawingBuffer preserve_drawing_buffer_ ; <START_VULN> const WebGLVersion web_gl_version_ ; <END_VULN> std : : unique_ptr < WebGraphicsContext3DProviderWrapper> context_provider_ ;
( void ) WriteBlobByte ( image , tga_info . bits_per_pixel ) ; ( void ) WriteBlobByte ( image , tga_info . attributes ) ; if ( tga_info . id_length != 0 ) <START_VULN> ( void ) WriteBlob ( image , tga_info . id_length , ( unsigned char * ) value ) ; <END_VULN> if ( tga_info . colormap_type != 0 ) { unsigned char
pixel . black = ( ( aggregate . black + total_weight2 . 0 ) total_weight ) ; pixel . alpha = ( ( aggregate . alpha + total_weight2 . 0 ) total_weight ) ; } <START_VULN> SetPixelViaPixelInfo ( image , & pixel , q ) ; <END_VULN> p += GetPixelChannels ( image ) ; q += GetPixelChannels ( enhance_image ) ; }
const uint8_t * clear = data ; if ( decrypt_cb ) { <START_VULN> int n = data_sz > 10 ? 10 : data_sz ; <END_VULN> decrypt_cb ( decrypt_state , data , clear_buffer , n ) ; clear = clear_buffer ; }
if ( unlikely ( cork -> opt == NULL ) ) return - ENOBUFS ; } <START_VULN> memcpy ( cork -> opt , opt , sizeof ( struct ip_options ) + opt -> optlen ) ; <END_VULN> cork -> flags |= IPCORK_OPT ; cork -> addr = ipc -> addr ; }
* ( dp ++ ) = * ( sp ++ ) ; sp += 3 ; dp = sp ; <START_VULN> * ( dp ++ ) = ( png_byte ) ( 255 - * ( sp ++ ) ) ; <END_VULN> } }
<START_VULN> if ( base_format & PNG_FORMAT_FLAG_ALPHA ) <END_VULN> do_local_background = 1 ; png_set_rgb_to_gray_fixed ( png_ptr , PNG_ERROR_ACTION_NONE ,
static int image_transform_png_set_scale_16_add ( image_transform * this , <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <END_VULN> { UNUSED ( colour_type )
for ( i = 0 ; i < get_vpx_decoder_count ( ) ; ++ i ) { const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ; fprintf ( stderr , " % - 6s - % s" , <START_VULN> decoder -> name , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <END_VULN> } exit ( EXIT_FAILURE ) ;
<START_VULN> static void<END_VULN> ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) {
for ( i = 0 ; i < vi -> channels ; i ++ ) { int submap = info -> chmuxlist [ i ] ; float * mdct = gmdct [ i ] ; float * res = vb -> pcm [ i ] ; int * ilogmask = ilogmaskch [ i ] = _vorbis_block_alloc ( vb , n2 * sizeof ( ** gmdct ) ) ; <START_VULN> <END_VULN> nonzero [ i ] = floor1_encode ( opb , vb , b -> flr [ info -> floorsubmap [ submap ] ] , floor_posts [ i ] [ k ] , ilogmask ) ; #if 0 { char buf [ 80 ] ; sprintf ( buf , "maskI % c % d" , i ? 'R' : 'L' , k ) ; float work [ n2 ] ;
} } <START_VULN> void vp9_encode_mv ( VP9_COMP * cpi , vp9_writer * w , <END_VULN> const MV * mv , const MV * ref , const nmv_context * mvctx , int usehp ) { const MV diff = { mv -> row - ref -> row ,
String packet_end ( ) ; bool serialize_value ( const Variant & varVariant ) ; bool recursiveAddVar ( const String & varName , const Variant & varVariant , <START_VULN> bool hasVarTag ) ; <END_VULN> private : String getWddxEncoded ( const String & varType ,
int arnr_strength ; int arnr_type ; <START_VULN> struct vpx_fixed_buf two_pass_stats_in ; <END_VULN> struct vpx_codec_pkt_list * output_pkt_list ; vp8e_tuning tuning ;
Error : <START_VULN> cmsPipelineFree ( Lut ) ; <END_VULN> if ( Result != NULL ) cmsPipelineFree ( Result ) ; return NULL ;
DomDistillerViewerSource ( DomDistillerServiceInterface * dom_distiller_service , const std : : string & scheme , <START_VULN> scoped_ptr < ExternalFeedbackReporter> external_reporter ) ; <END_VULN> ~ DomDistillerViewerSource ( ) override ; class RequestViewerHandle ;
class SSLCertErrorHandler : public SSLErrorHandler { public : <START_VULN> SSLCertErrorHandler ( base : : WeakPtr < Delegate> delegate , <END_VULN> const content : : GlobalRequestID & id , ResourceType : : Type resource_type , const GURL & url ,
while ( vct_issp ( * p ) ) p ++ ; hh [ n ++ ] = p ; <START_VULN> while ( ! vct_iscrlf ( * p ) ) <END_VULN> p ++ ; q = p ; p += vct_skipcrlf ( p ) ;
free ( devices ) ; devices = NULL ; } <START_VULN> return 1 ; <END_VULN> }
<START_VULN> * f<END_VULN>
} else { fit_valueB [ ln ] = ly0 ; if ( ln == 0 ) fit_valueA [ ln ] = ly0 ; fit_valueA [ i ] = ly1 ; fit_valueB [ i ] = hy0 ; fit_valueA [ hn ] = hy1 ; if ( hn == 1 ) fit_valueB [ hn ] = hy1 ; <START_VULN> <END_VULN> if ( ly1> = 0 | | hy0> = 0 ) { for ( j = sortpos - 1 ; j> = 0 ; j -- ) if ( hineighbor [ j ] == hn ) hineighbor [ j ] = i ; else break ; for ( j = sortpos + 1 ; j < posts ; j ++ )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : PCM data envelope analysis and manipulation <START_VULN> last mod : $ Id : envelope . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_ENVELOPE_ #define _V_ENVELOPE_ #include "mdct . h"
char * result ; if ( len <= 0 ) return NULL ; result = ALLOC_N ( char , len ) ; <START_VULN> memccpy ( result , ptr , 0 , len ) ; <END_VULN> return result ; }
void CVE_2011_3003_CopySubDataIfElementArray ( GLuint byteOffset , GLuint byteLength , const void * data ) { <START_VULN> if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER ) { <END_VULN> memcpy ( ( void * ) ( size_t ( mData ) + byteOffset ) , data , byteLength ) ; } }
if ( R - offset < noise [ i ] ) noise [ i ] = R - offset ; } for ( ; i < n ; i ++ , x += 1 . f ) { R = ( A + x * B ) D ; if ( R - offset < noise [ i ] ) noise [ i ] = R - offset ; } } <START_VULN> static float FLOOR1_fromdB_INV_LOOKUP [ 256 ] = { <END_VULN> 0 . F , 8 . 81683e + 06F , 8 . 27882e + 06F , 7 . 77365e + 06F , 7 . 29930e + 06F , 6 . 85389e + 06F , 6 . 43567e + 06F , 6 . 04296e + 06F , 5 . 67422e + 06F , 5 . 32798e + 06F , 5 . 00286e + 06F , 4 . 69759e + 06F , 4 . 41094e + 06F , 4 . 14178e + 06F , 3 . 88905e + 06F , 3 . 65174e + 06F , 3 . 42891e + 06F , 3 . 21968e + 06F , 3 . 02321e + 06F , 2 . 83873e + 06F , 2 . 66551e + 06F , 2 . 50286e + 06F , 2 . 35014e + 06F , 2 . 20673e + 06F , 2 . 07208e + 06F , 1 . 94564e + 06F , 1 . 82692e + 06F , 1 . 71544e + 06F , 1 . 61076e + 06F , 1 . 51247e + 06F , 1 . 42018e + 06F , 1 . 33352e + 06F ,
} <START_VULN> static void pack_mb_row_tokens_c ( VP8_COMP * cpi , vp8_writer * w ) <END_VULN> { int mb_row ;
nsCycleCollectionParticipant * helper ) = 0 ; NS_IMETHOD_ ( void ) NoteNextEdgeName ( const char * name ) = 0 ; <START_VULN> NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * val ) = 0 ; <END_VULN> enum { WANT_DEBUG_INFO = ( 1 << 0 ) ,
png_crc_read ( png_ptr , buffer , length ) ; <START_VULN> if ( png_crc_finish ( png_ptr , skip ) ) <END_VULN> return ; buffer [ length ] = 0 ;
conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; } <START_VULN> DBG_RETURN ( ret ) ; <END_VULN> }
break ; } <START_VULN> if ( inchar == EOF ) <END_VULN> break ; if ( buf [ 4 ] == 73 && buf [ 5 ] == 69 && buf [ 6 ] == 78 && buf [ 7 ] == 68 )
int32_t i32 ; uint32_t u32 ; JSWhyMagic why ; } payload ; } s ; double asDouble ; void * asPtr ; size_t asWord ; <START_VULN> } jsval_layout ; <END_VULN> # endif #endif JS_STATIC_ASSERT ( sizeof ( jsval_layout ) == 8 ) ; #if JS_BITS_PER_WORD == 32
switch ( intern -> type ) { case SPL_FS_DIR : test = spl_filesystem_object_get_path ( intern , NULL ) ; <START_VULN> fname_len = ( php_stat_len ) spprintf ( & fname , 0 , " % s % c % s" , test , DEFAULT_SLASH , intern -> u . dir . entry . d_name ) ; <END_VULN> php_stat ( fname , fname_len , FS_IS_DIR , & dummy ) ; if ( Z_TYPE ( dummy ) == IS_TRUE ) {
RETURN_FALSE ; } <START_VULN> if ( str_len > INT_MAX ) { <END_VULN> RETURN_FALSE ; }
unsigned rendering_context_id = 0 ; CompositingReasons direct_compositing_reasons = CompositingReason : : kNone ; CompositorElementId compositor_element_id ; <START_VULN> scoped_refptr < const ScrollPaintPropertyNode> scroll ; <END_VULN> bool operator == ( const State & o ) const { return matrix == o . matrix && origin == o . origin &&
if ( verbose ) appendPQExpBuffer ( & sql , " ( VERBOSE ) " ) ; <START_VULN> appendPQExpBuffer ( & sql , " SYSTEM % s ; " , PQdb ( conn ) ) ; <END_VULN> if ( ! executeMaintenanceCommand ( conn , sql . data , echo ) ) {
} static int _make_decode_table ( codebook * s , char * lengthlist , long quantvals , <START_VULN> oggpack_buffer * opb , int maptype ) { <END_VULN> int i ; ogg_uint32_t * work ;
#include < set> #include "basememoryscoped_ptr . h" <START_VULN> #include "remotinghosturl_fetcher . h"<END_VULN> #include "third_partylibjinglesourcetalkp2pclienthttpportallocator . h" namespace net {
l_int32 plotstyle , const char * plottitle ) { <START_VULN> char buf [ L_BUF_SIZE ] ; <END_VULN> char emptystring [ ] = "" ; char * datastr , * title ; l_int32 n , i ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis codec headers <START_VULN> last mod : $ Id : codec . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _vorbis_codec_h_ #define _vorbis_codec_h_ #ifdef __cplusplus extern "C"
void SensorDeviceFound ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> const PlatformSensorProviderBase : : CreateSensorCallback & callback , const SensorInfoLinux * sensor_device ) ;
walk ++ ; } else return 0 ; <START_VULN> <END_VULN> if ( * walk && * walk > = '0' && * walk <= '9' ) { * backref = * backref * 10 + * walk - '0' ; walk ++ ;
ND_PRINT ( ( ndo , " ( length bogus , should be = 4 ) " ) ) ; return 0 ; } <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <END_VULN> ND_PRINT ( ( ndo , " : % u" , EXTRACT_16BITS ( p + 2 ) ) ) ; break ; case LCPOPT_MLED :
cpi -> twopass . frames_to_key = 2 ; <START_VULN> vpx_memcpy ( & tmp_frame , & first_frame , sizeof ( first_frame ) ) ; <END_VULN> reset_fpf_position ( cpi , start_position ) ;
for ( i = above_contexts ; i < tx_size_in_blocks ; ++ i ) a [ i ] = 0 ; } else { <START_VULN> vpx_memset ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <END_VULN> }
regs -> loadrs = 0 ; regs -> r8 = get_dumpable ( current -> mm ) ; regs -> r12 = new_sp - 16 ; <START_VULN> if ( unlikely ( ! get_dumpable ( current -> mm ) ) ) { <END_VULN> int get_dumpable ( struct mm_struct * mm ) { return __get_dumpable ( mm -> flags ) ;
source_rectangle = size_rectangle ; destination_rectangle = size_rectangle ; base_address = 0xff ; <START_VULN> row_bytes = ( unsigned short ) ( image -> columns | 0x8000 ) ; <END_VULN> bounds . top = 0 ; bounds . left = 0 ; bounds . bottom = ( short ) image -> rows ;
if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "ss | l" , & arg_pattern , & arg_pattern_len , & string , & string_len , & count ) == FAILURE ) { RETURN_FALSE ; <START_VULN> } <END_VULN> if ( count > 0 ) { count -- ;
return 0 ; } <START_VULN> if ( mount ( console -> name , lxcpath , "none" , MS_BIND , 0 ) ) { <END_VULN> ERROR ( "failed to mount ' % s' on ' % s'" , console -> name , lxcpath ) ; return - 1 ; }
return 1 ; } <START_VULN> #line 1267 "extstandardvar_unserializer . c"<END_VULN> yy95 : yych = * ++ YYCURSOR ; if ( yych <= ' , ' ) {
goto out_unlock ; memcpy ( dst -> iov_base , p , len ) ; <START_VULN> credits = be32_to_cpu ( rmsgp -> rm_credit ) ; <END_VULN> if ( credits == 0 ) credits = 1 ; else if ( credits > r_xprt -> rx_buf . rb_bc_max_requests )
const char * last ; const char * buf ; const char * end ; <START_VULN> size_t lines , linecnt , bytecnt ; <END_VULN> if ( s == NULL ) { ms -> search . s_len = 0 ;
memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; <START_VULN> if ( l > = ( len - o ) ) { <END_VULN> iter -> err_off = o ; goto mark_invalid ; }
#define LIBRAW_MAJOR_VERSION 0 #define LIBRAW_MINOR_VERSION 16 <START_VULN> #define LIBRAW_PATCH_VERSION 0<END_VULN> #define LIBRAW_VERSION_TAIL Release #define LIBRAW_SHLIB_CURRENT 10
uint_fast16_t len ; <START_VULN> uchar * data ; <END_VULN> } jpc_ppm_t ;
curind = optind ; <START_VULN> while ( longindex = - 1 , ( c = getopt_long ( argc , argv , " : vhlndDRS : f : p : i : mM : : g : : Gt : : "<END_VULN> #if defined _WITH_VRRP_ && defined _WITH_LVS_ "PC" #endif
static const struct net_offload ipip_offload = { . callbacks = { . gso_segment = inet_gso_segment , <START_VULN> . gro_receive = inet_gro_receive , <END_VULN> . gro_complete = ipip_gro_complete , } , } ;
struct TypedArrayObjectStorage : AllTypedArraysBase { protected : JSObject * mObj ; <START_VULN> TypedArrayObjectStorage ( ) <END_VULN> { } explicit TypedArrayObjectStorage ( TypedArrayObjectStorage && aOther ) : mObj ( aOther . mObj ) { aOther . mObj = nullptr ; }
htmlParseElementInternal ( htmlParserCtxtPtr ctxt ) { const xmlChar * name ; const htmlElemDesc * info ; <START_VULN> htmlParserNodeInfo node_info = { 0 , } ; <END_VULN> int failed ; if ( ( ctxt == NULL ) | | ( ctxt -> input == NULL ) ) {
bool adapter_enable_disable ( ) { int error ; <START_VULN> CALL_AND_WAIT ( error = bt_interface -> enable ( ) , adapter_state_changed ) ; <END_VULN> TASSERT ( error == BT_STATUS_SUCCESS , "Error enabling Bluetooth : % d" , error ) ; TASSERT ( adapter_get_state ( ) == BT_STATE_ON , "Adapter did not turn on . " ) ;
return hdrlen ; } if ( ndo -> ndo_vflag ) <START_VULN> ND_PRINT ( ( ndo , " % 04x : % s " , panid , le64addr_string ( ndo , p + 2 ) ) ) ; <END_VULN> p += 8 ; caplen -= 8 ; hdrlen += 8 ;
data_length = length - ( png_uint_32 ) ( entry_start - buffer ) ; <START_VULN> if ( data_length % entry_size ) <END_VULN> { png_warning ( png_ptr , "sPLT chunk has bad length" ) ; return ;
size_t length ; gchar * ret = NULL ; <START_VULN> f = fopen ( filepath , "rb" ) ; <END_VULN> if ( f ) { fseek ( f , 0 , SEEK_END ) ; length = ( size_t ) ftell ( f ) ;
if ( FAILURE == phar_copy_entry_fp ( oldentry , & newentry , & error TSRMLS_CC ) ) { efree ( newentry . filename ) ; php_stream_close ( newentry . fp ) ; <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; return ; }
array_transpose_8x8 ( in , in ) ; } <START_VULN> void fadst8_sse2 ( __m128i * in ) { <END_VULN> const __m128i k__cospi_p02_p30 = pair_set_epi16 ( cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_p30_m02 = pair_set_epi16 ( cospi_30_64 , - cospi_2_64 ) ;
perf_event_header__init_id ( & comm_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , <START_VULN> comm_event -> event_id . header . size , 0 , 0 ) ; <END_VULN> if ( ret ) goto out ;
#undef mem_put_be32 #define mem_put_be32 mem_ops_wrap_symbol ( mem_put_be32 ) <START_VULN> static void mem_put_be32 ( void * vmem , MEM_VALUE_T val ) { <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; mem [ 0 ] = ( val >> 24 ) & 0xff ;
if ( * p == LLC_UI ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "CNLPID " ) ) ; <START_VULN> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <END_VULN> return hdrlen ; }
static void spl_filesystem_dir_it_current_data ( zend_object_iterator * iter , zval ** * data TSRMLS_DC ) { spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ; <START_VULN> <END_VULN> * data = & iterator -> current ; }
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 114 20141211 14 : 19 : 36 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
} else { <START_VULN> rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , <END_VULN> & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ; }
p = a = text ; while ( a < e ) { <START_VULN> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <END_VULN> break ; b = m . sub [ 0 ] . sp ;
vorbis_info * vi = v -> vi ; codec_setup_info * ci = vi -> codec_setup ; int hs = ci -> halfrate_flag ; private_state * b = v -> backend_state ; if ( b -> window [ W ] - 1 < 0 ) return NULL ; return _vorbis_window_get ( b -> window [ W ] - hs ) ; } <START_VULN> <END_VULN>
#include < algorithm> #include "baselogging . h" <START_VULN> #include "basemove . h"<END_VULN> namespace remoting {
double decay_accumulator = 1 . 0 ; double next_iiratio ; <START_VULN> vpx_memcpy ( & local_next_frame , next_frame , sizeof ( * next_frame ) ) ; <END_VULN> start_pos = cpi -> twopass . stats_in ;
u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) <START_VULN> return ERROR_INV_SPS_PPS_T ; <END_VULN> COPYTHECONTEXT ( "SH : " , u4_idr_pic_id ) ; }
else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ; <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <END_VULN> } if ( eobs [ 1 ] > 1 )
if ( ast_strlen_zero ( header_content ) ) { ast_log ( LOG_ERROR , "Could not fetch header for message number % ld" , vms -> msgArray [ vms -> curmsg ] ) ; return - 1 ; } snprintf ( todir , sizeof ( todir ) , " % s % s % stmp" , VM_SPOOL_DIR , vmu -> context , vmu -> mailbox ) ; make_gsm_file ( vms -> fn , vms -> imapuser , todir , vms -> curmsg ) ; mail_fetchstructure ( vms -> mailstream , vms -> msgArray [ vms -> curmsg ] , & body ) ; <START_VULN> if ( body -> nested . part -> next && body -> nested . part -> next -> body . parameter -> value ) { <END_VULN> attachedfilefmt = ast_strdupa ( body -> nested . part -> next -> body . parameter -> value ) ; } else { ast_log ( LOG_ERROR , "There is no file attached to this IMAP message . " ) ; return - 1 ; } strsep ( & attachedfilefmt , " . " ) ; if ( ! attachedfilefmt ) {
spl_filesystem_file_free_line ( intern TSRMLS_CC ) ; ret = spl_filesystem_file_read_line_ex ( this_ptr , intern , silent TSRMLS_CC ) ; } <START_VULN> <END_VULN> return ret ; }
png_debug ( 1 , "in png_handle_IHDR" ) ; <START_VULN> if ( png_ptr -> mode & PNG_HAVE_IHDR ) <END_VULN> png_chunk_error ( png_ptr , "out of place" ) ;
RETURN_FALSE ; <START_VULN> result = append_key_value ( loc_name , hash_arr , LOC_GRANDFATHERED_LANG_TAG ) ; <END_VULN> if ( result == SUCCESS ) { RETURN_SMART_STR ( loc_name ) ; }
phar_flush ( entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } RETURN_TRUE ;
} phar_flush ( phar_obj -> arc . archive , ( char * ) & zstub , len , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } RETURN_TRUE ;
XPCWrappedNativeScope * GetScope ( ) const { return mScope ; } XPCJSRuntime * GetRuntime ( ) const { return mScope -> GetRuntime ( ) ; } JSObject * <START_VULN> GetJSProtoObject ( ) const { return mJSProtoObject ; } <END_VULN> nsIClassInfo * GetClassInfo ( ) const { return mClassInfo ; } XPCNativeSet * GetSet ( ) const { return mSet ; } XPCNativeScriptableInfo *
MEDIA_EXPORT bool ParseNewStyleVp9CodecID ( const std : : string & codec_id , VideoCodecProfile * profile , uint8_t * level_idc , <START_VULN> gfx : : ColorSpace : : TransferID * eotf ) ; <END_VULN> MEDIA_EXPORT bool ParseLegacyVp9CodecID ( const std : : string & codec_id , VideoCodecProfile * profile ,
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : floor backend 1 implementation <START_VULN> last mod : $ Id : floor1 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h> #include < string . h> #include < math . h> #include < oggogg . h> #include "vorbiscodec . h"
bit , byte , color , <START_VULN> * lastrow , <END_VULN> * one_row , * ptr , version ;
* ( dp ++ ) = ( png_byte ) ( ( w >> 8 ) & 0xff ) ; * ( dp ++ ) = ( png_byte ) ( w & 0xff ) ; <START_VULN> if ( have_alpha ) <END_VULN> { * ( dp ++ ) = * ( sp ++ ) ; * ( dp ++ ) = * ( sp ++ ) ;
gfx : : Rect visible_rect ; protected : <START_VULN> friend class base : : RefCounted < H264Picture> ; <END_VULN> virtual ~ H264Picture ( ) ; private :
extern "C" { #endif <START_VULN> #include "vp9encodervp9_onyx_int . h"<END_VULN> struct yv12_buffer_config ; struct VP9_COMP ;
return FAILURE ; } break ; <START_VULN> <END_VULN> case cs_8859_15 : if ( code < 0xA4 | | ( code > 0xBE && code <= 0xFF ) ) { * res = code ;
if ( row == 0 ) { gd_error ( "gd - jpeg : error : unable to allocate JPEG row structure : gdCalloc returns NULL" ) ; jpeg_destroy_compress ( & cinfo ) ; <START_VULN> return ; <END_VULN> } rowptr [ 0 ] = row ;
{ png_app_error ( png_ptr , "invalid unknown chunk location" ) ; <START_VULN> if ( ( location & PNG_HAVE_IDAT ) ) <END_VULN> location = PNG_AFTER_IDAT ; else
gfx : : Rect visible_rect ; protected : <START_VULN> friend class base : : RefCounted < VP8Picture> ; <END_VULN> virtual ~ VP8Picture ( ) ; DISALLOW_COPY_AND_ASSIGN ( VP8Picture ) ;
for ( index = 0 ; index < payloads ; index ++ ) { uint32_t payloadsize = GetPayloadSize ( mp4 , index ) ; <START_VULN> float in = 0 . 0 , out = 0 . 0 ; <END_VULN> payload = GetPayload ( mp4 , payload , index ) ; if ( payload == NULL ) goto cleanup ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : #ifdef jail to whip a few platforms into the UNIX ideal . <START_VULN> last mod : $ Id : os_types . h 16649 2009 - 10 - 25 00 : 49 : 58Z ds $ <END_VULN> #ifndef _OS_TYPES_H #define _OS_TYPES_H different malloc than stdlib * #define _ogg_malloc malloc
void * arg ) { int plane ; <START_VULN> for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ ) <END_VULN> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ; }
{ Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ; int qps_changed = 0 , i , err ; #define copy_fields ( to , from , start_field , end_field ) memcpy ( & to -> start_field , & from -> start_field , ( char * ) & to -> end_field - ( char * ) & to -> start_field ) if ( ! s1 -> current_frame . data [ 0 ] | | s -> width != s1 -> width | | s -> height != s1 -> height ) { if ( s != s1 ) <START_VULN> copy_fields ( s , s1 , golden_frame , current_frame ) ; <END_VULN> return - 1 ; } if ( s != s1 ) { if ( ! s -> current_frame . data [ 0 ] ) { int y_fragment_count , c_fragment_count ; s -> avctx = dst ; err = allocate_tables ( dst ) ; if ( err )
ND_PRINT ( ( ndo , " ( length bogus , should be > = 4 ) " ) ) ; return len ; } <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <END_VULN> ND_PRINT ( ( ndo , " : Window : % uK , Method : % s ( 0x % x ) , MBZ : % u , CHK : % u" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? "zlib" : "unknown" ,
status_t resetDecoder ( ) ; status_t resetPlugin ( ) ; <START_VULN> void setDecodeArgs ( ivd_video_decode_ip_t * ps_dec_ip , <END_VULN> ivd_video_decode_op_t * ps_dec_op , OMX_BUFFERHEADERTYPE * inHeader , OMX_BUFFERHEADERTYPE * outHeader ,
guint16 CVE_2014_5163_de_sm_apn ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) { guint32curr_offset ; guintcurr_len ; guint8str [ MAX_APN_LENGTH + 1 ] ; curr_offset = offset ; <START_VULN> memset ( str , 0 , MAX_APN_LENGTH ) ; <END_VULN> tvb_memcpy ( tvb , str , offset , len < MAX_APN_LENGTH ? len : MAX_APN_LENGTH ) ; curr_len = 0 ; while ( ( curr_len < len ) && ( curr_len < MAX_APN_LENGTH ) ) { guint step = str [ curr_len ] ; str [ curr_len ] = ' . ' ; curr_len += step + 1 ; }
uint32 w , l , tw , tl ; int bychunk ; <START_VULN> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <END_VULN> if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , " % s : Cannot handle different planar configuration w bitssample != 8" ,
addr = compute_effective_address ( regs , insn , ( ( insn >> 25 ) & 0x1f ) ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <END_VULN> switch ( asi ) { case ASI_NL : case ASI_AIUPL :
@description This is useful for detached commands . @param cmd MprCmd object created via mprCreateCmd @ingroup MprCmd <START_VULN> @stability Prototype<END_VULN> PUBLIC void mprStartWinPollTimer ( MprCmd * cmd ) ; #endif
if ( tstate & TSTATE_PRIV ) die_if_kernel ( "stdfmna from kernel" , regs ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , sfar ) ; <END_VULN> if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ; if ( get_user ( insn , ( u32 __user * ) pc ) != - EFAULT ) {
<START_VULN> <END_VULN> #ifndef COMPILER_DEBUG_H_ #define COMPILER_DEBUG_H_ #include < assert . h> #ifdef _DEBUG #define TRACE_ENABLED
else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ; <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <END_VULN> } if ( eobs [ 1 ] > 1 )
#define free ( ptr ) hunspell_free ( ptr ) inline void * hunspell_realloc ( void * ptr , size_t size ) { HunspellReportMemoryDeallocation ( ptr ) ; void * result = moz_realloc ( ptr , size ) ; if ( result ) { HunspellReportMemoryAllocation ( result ) ; <START_VULN> } else { <END_VULN> HunspellReportMemoryAllocation ( ptr ) ; } return result ; } #define realloc ( ptr , size ) hunspell_realloc ( ptr , size ) inline char * hunspell_strdup ( const char * str )
0 . 8928678298F , 0 . 9080153310F , 0 . 9217306608F , 0 . 9340480615F , 0 . 9450138200F , 0 . 9546851041F , 0 . 9631286621F , 0 . 9704194171F , 0 . 9766389810F , 0 . 9818741197F , 0 . 9862151938F , 0 . 9897546035F , 0 . 9925852598F , 0 . 9947991032F , 0 . 9964856900F , 0 . 9977308602F , 0 . 9986155015F , 0 . 9992144193F , 0 . 9995953200F , 0 . 9998179155F , 0 . 9999331503F , 0 . 9999825563F , 0 . 9999977357F , 0 . 9999999720F , } ; <START_VULN> static float vwin256 [ 128 ] = { <END_VULN> 0 . 0000591390F , 0 . 0005321979F , 0 . 0014780301F , 0 . 0028960636F , 0 . 0047854363F , 0 . 0071449926F , 0 . 0099732775F , 0 . 0132685298F , 0 . 0170286741F , 0 . 0212513119F , 0 . 0259337111F , 0 . 0310727950F , 0 . 0366651302F , 0 . 0427069140F , 0 . 0491939614F , 0 . 0561216907F , 0 . 0634851102F , 0 . 0712788035F , 0 . 0794969160F , 0 . 0881331402F , 0 . 0971807028F , 0 . 1066323515F , 0 . 1164803426F , 0 . 1267164297F , 0 . 1373318534F , 0 . 1483173323F , 0 . 1596630553F , 0 . 1713586755F , 0 . 1833933062F , 0 . 1957555184F , 0 . 2084333404F , 0 . 2214142599F ,
#include < utility> #include "baselogging . h" <START_VULN> #include "basemove . h"<END_VULN> #include "mojopubliccppbindingsarray . h" #include "mojopubliccppbindingslibmap_data_internal . h" #include "mojopubliccppbindingslibtemplate_util . h"
if ( Speed > = 15 ) sf -> half_pixel_search = 0 ; <START_VULN> vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ; <END_VULN> } ;
if ( ! version | | ! * version | | smatch ( version , "0 . 0 . 0" ) ) { version = " * " ; } <START_VULN> mprSetJson ( route -> config , sfmt ( "dependencies . % s" , name ) , version ) ; <END_VULN> }
int received_content_length , int original_content_length , bool with_data_reduction_proxy_enabled , <START_VULN> bool via_data_reduction_proxy , <END_VULN> PrefService * prefs ) ; }
#define VERSION ( ) <START_VULN> printf ( "unsquashfs version 4 . 3 - git ( 20190705 ) " ) ; <END_VULN> printf ( "copyright ( C ) 2019 Phillip Lougher " " < phillip@squashfs . org . uk>" ) ; printf ( "This program is free software ; you can redistribute it andor"
plen = strlen ( passwdp ) ; <START_VULN> if ( ( ulen > SIZE_T_MAX2 ) | | ( plen > ( SIZE_T_MAX2 - 2 ) ) ) <END_VULN> return CURLE_OUT_OF_MEMORY ; plainlen = 2 * ulen + plen + 2 ;
fit_value [ i ] = val + predicted ; fit_value [ look -> loneighbor [ i - 2 ] ] &= 0x7fff ; fit_value [ look -> hineighbor [ i - 2 ] ] &= 0x7fff ; } else { fit_value [ i ] = predicted | 0x8000 ; } <START_VULN> <END_VULN> } return ( fit_value ) ; } eop : return ( NULL ) ; }
struct carray_cursor { sqlite3_vtab_cursor base ; sqlite3_int64 iRowid ; <START_VULN> sqlite3_int64 iPtr ; <END_VULN> sqlite3_int64 iCnt ; unsigned char eType ; } ;
XPCCompartmentSet & GetCompartmentSet ( ) { return mCompartmentSet ; } XPCLock * GetMapLock ( ) const { return mMapLock ; } JSBool OnJSContextNew ( JSContext * cx ) ; <START_VULN> JSBool DeferredRelease ( nsISupports * obj ) ; <END_VULN> JSBool GetDoingFinalization ( ) const { return mDoingFinalization ; } enum {
<START_VULN> if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( uint , <END_VULN> jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( "warning : number of components mismatch" ) ; }
if ( e == text ) { <START_VULN> if ( js_regexec ( re -> prog , text , & m , 0 ) ) { <END_VULN> if ( len == limit ) return ; js_pushliteral ( J , "" ) ; js_setindex ( J , - 2 , 0 ) ;
} else if ( ! strncmp ( dff_chunk_header . ckID , "DSD " , 4 ) ) { <START_VULN> if ( ! config -> num_channels ) { <END_VULN> error_line ( " % s is not a valid . DFF file ! " , infilename ) ; return WAVPACK_SOFT_ERROR ; }
if ( owner == png_IDAT ) { <START_VULN> if ( png_ptr -> flags & PNG_FLAG_ZLIB_CUSTOM_STRATEGY ) <END_VULN> strategy = png_ptr -> zlib_strategy ; else if ( png_ptr -> do_filter != PNG_FILTER_NONE )
} } <START_VULN> static void perf_event_output ( struct perf_event * event , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) {
} <START_VULN> for ( i = 0 ; i < ( height ) ; i ++ ) <END_VULN> row_pointers [ i ] = png_pixels + i * row_bytes ;
{ wchar_t time_buf [ 29 ] ; wsprintf ( time_buf , TEXT ( " % d % S % d % 02d : % 02d : % 02d + 0000" ) , <START_VULN> ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] , <END_VULN> ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ; WideCharToMultiByte ( CP_ACP , 0 , time_buf , - 1 , png_ptr -> time_buffer ,
return ( PTA * ) ERROR_PTR ( "not a pta file" , procName , NULL ) ; if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( "invalid pta version" , procName , NULL ) ; <START_VULN> if ( fscanf ( fp , " Number of pts = % d ; format = % s" , & n , typestr ) != 2 ) <END_VULN> return ( PTA * ) ERROR_PTR ( "not a pta file" , procName , NULL ) ; if ( ! strcmp ( typestr , "float" ) ) type = 0 ;
MEDIA_EXPORT extern const char kVideoThreads [ ] ; <START_VULN> MEDIA_EXPORT extern const char kDisableAudioMixer [ ] ; <END_VULN> }
gpointer user_data ) { struct tcmur_handler * handler = find_handler_by_subtype ( subtype ) ; <START_VULN> struct dbus_info * info = handler -> opaque ; <END_VULN> if ( ! handler ) { g_dbus_method_invocation_return_value ( invocation ,
MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , 1 , 0 ) ) ; MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , 2 , 0 ) ) ; } <START_VULN> else<END_VULN> #endif #if defined ( ECP_SHORTWEIERSTRASS ) if ( ecp_get_type ( grp ) == ECP_TYPE_SHORT_WEIERSTRASS ) {
png_debug ( 1 , "in png_write_sBIT" ) ; <START_VULN> if ( color_type & PNG_COLOR_MASK_COLOR ) <END_VULN> { png_byte maxbits ;
goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , <START_VULN> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; <END_VULN> for ( d = alldevs ; d != NULL ; d = d -> next )
j = m + 1 ; while ( j -- ) { double d = 0 ; for ( i = j ; i < n ; i ++ ) d += ( double ) data [ i ] * data [ i - j ] ; aut [ j ] = d ; } <START_VULN> <END_VULN> error = aut [ 0 ] * ( 1 . + 1e - 10 ) ; epsilon = 1e - 9 * aut [ 0 ] + 1e - 10 ; for ( i = 0 ; i < m ; i ++ ) { double r = - aut [ i + 1 ] ;
if ( info -> action == ACTION_CONNECT ) { <START_VULN> rv = zsocket_connect ( * sock , info -> description ) ; <END_VULN> if ( rv == - 1 ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS ,
static inline unsigned int __xfrm4_daddr_saddr_hash ( xfrm_address_t * daddr , xfrm_address_t * saddr ) { <START_VULN> return ntohl ( daddr -> a4 ^ saddr -> a4 ) ; <END_VULN> } static inline unsigned int __xfrm6_daddr_saddr_hash ( xfrm_address_t * daddr , xfrm_address_t * saddr )
#endif <START_VULN> if ( transforms & PNG_TRANSFORM_SWAP_ALPHA ) <END_VULN> #ifdef PNG_READ_SWAP_ALPHA_SUPPORTED png_set_swap_alpha ( png_ptr ) ; #else
{ ASSERT ( ! childNeedsStyleInvalidation ( ) ) ; ASSERT ( ! needsStyleInvalidation ( ) ) ; <START_VULN> ASSERT ( insertionPoint -> inDocument ( ) | | isContainerNode ( ) ) ; <END_VULN> if ( insertionPoint -> inDocument ( ) ) { setFlag ( InDocumentFlag ) ; insertionPoint -> document ( ) . incrementNodeCount ( ) ;
if ( code > 0xFF ) { return FAILURE ; <START_VULN> } <END_VULN> * res = code ; break ;
ps_dec -> u4_deblk_mb_x = 0 ; ps_dec -> u4_deblk_mb_y = 0 ; <START_VULN> <END_VULN> H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return OK ;
#include < string . h> #include "allheaders . h" <START_VULN> static const l_int32 L_BUF_SIZE = 512 ; <END_VULN> const char * gplotstylenames [ ] = { "with lines" , "with points" ,
#define PROGNAME "rpng2 - x" #define LONGNAME "Progressive PNG Viewer for X" <START_VULN> #define VERSION "2 . 03 of 25 February 2010"<END_VULN> #define RESNAME "rpng2" #define RESCLASS "Rpng"
static void set_segmentation_map ( VP8_COMP * cpi , unsigned char * segmentation_map ) { <START_VULN> vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <END_VULN> cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ;
ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } <START_VULN> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <END_VULN> { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc ,
{ if ( map ) { <START_VULN> vpx_memcpy ( cpi -> active_map , map , rows * cols ) ; <END_VULN> cpi -> active_map_enabled = 1 ; } else
} else { <START_VULN> memcpy ( cp , qp -> d_memory , memory_length ) ; <END_VULN> qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ; qp -> d_write = cp + ( qp -> d_write - qp -> d_memory ) ; }
break ; case PT_OSI : <START_VULN> isoclns_print ( ndo , p , length , length ) ; <END_VULN> break ; default :
<START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 85 ) <END_VULN>
unsigned bufferpos ; const FLAC__Frame * frame ; <START_VULN> FLAC__bool bufferbackup ; <END_VULN> unsigned compression ; } FLAC_PRIVATE ; typedef struct
} ; <START_VULN> static void watchdog_overflow_callback ( struct perf_event * event , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) {
# endif } <START_VULN> return ( png_byte ) value ; <END_VULN> } #ifdef PNG_16BIT_SUPPORTED
PNG_EXPORT ( 73 , void , png_set_compression_method , ( png_structrp png_ptr , int method ) ) ; <START_VULN> #endif<END_VULN> #ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
if ( IsUnpromptedElevation ( unpromptedElevation ) ) { useService = ! unpromptedElevation ; } } if ( useService ) { WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) ) { <START_VULN> HKEY baseKey ; <END_VULN> if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS ) { RegCloseKey ( baseKey ) ; } else { useService = testOnlyFallbackKeyExists ; if ( ! useService ) { lastFallbackError = FALLBACKKEY_NOKEY_ERROR ; }
#include "basecallback_forward . h" #include "basefilesfile_path . h" #include "basememoryref_counted . h" <START_VULN> #include "basemove . h"<END_VULN> #include "storagebrowserstorage_browser_export . h" namespace base {
domains = 0 ; age = 0 ; for ( option = stok ( sclone ( rest ) , " t" , & tok ) ; option ; option = stok ( 0 , " t" , & tok ) ) { <START_VULN> option = stok ( option , " = t , " , & ovalue ) ; <END_VULN> ovalue = strim ( ovalue , ""'" , MPR_TRIM_BOTH ) ; if ( smatch ( option , "age" ) ) { age = sfmt ( " % lld" , ( int64 ) httpGetTicks ( ovalue ) ) ;
keywords [ 3 ] = "password" ; values [ 3 ] = password ; keywords [ 4 ] = "dbname" ; <START_VULN> values [ 4 ] = newdb ; <END_VULN> keywords [ 5 ] = "fallback_application_name" ; values [ 5 ] = progname ; keywords [ 6 ] = NULL ;
if ( preg_options ) { * preg_options = pce ? pce -> preg_options : 0 ; } <START_VULN> <END_VULN> return pce ? pce -> re : NULL ; }
_y4m -> convert = y4m_convert_422_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I422 ; <START_VULN> _y4m -> vpx_bps = 16 ; <END_VULN> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h
} ; static const struct multistate multistate_compression [ ] = { { "delayed" , COMP_DELAYED } , <START_VULN> { "yes" , COMP_ZLIB } , <END_VULN> { "no" , COMP_NONE } , { NULL , - 1 } } ;
if ( ( c = strstr ( fname , " . pdf" ) ) ) * c = '0' ; <START_VULN> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <END_VULN> snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , " % s % s - version - % d . pdf" , dirname , fname , xref -> version ) ;
#if ! defined ( LIBEXSLT_STATIC ) #define EXSLTPUBVAR __declspec ( dllimport ) extern #else <START_VULN> #define EXSLTPUBVAR<END_VULN> #endif #endif #define EXSLTCALL __cdecl
} <START_VULN> #line 106 "re_grammar . c"<END_VULN> # ifndef YY_NULLPTR # if defined __cplusplus && 201103L <= __cplusplus
} <START_VULN> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <END_VULN> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; {
<START_VULN> if ( transforms & PNG_TRANSFORM_PACKING ) <END_VULN> #ifdef PNG_READ_PACK_SUPPORTED png_set_packing ( png_ptr ) ; #else
static int CVE_2010_3875_ax25_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) { struct full_sockaddr_ax25 * fsa = ( struct full_sockaddr_ax25 * ) uaddr ; struct sock * sk = sock -> sk ; unsigned char ndigi , i ; ax25_cb * ax25 ; int err = 0 ; lock_sock ( sk ) ; ax25 = ax25_sk ( sk ) ; if ( peer != 0 ) { if ( sk -> sk_state != TCP_ESTABLISHED ) { err = - ENOTCONN ; goto out ; } fsa -> fsa_ax25 . sax25_family = AF_AX25 ; fsa -> fsa_ax25 . sax25_call = ax25 -> dest_addr ; <START_VULN> fsa -> fsa_ax25 . sax25_ndigis = 0 ; <END_VULN> if ( ax25 -> digipeat != NULL ) { ndigi = ax25 -> digipeat -> ndigi ; fsa -> fsa_ax25 . sax25_ndigis = ndigi ; for ( i = 0 ; i < ndigi ; i ++ ) fsa -> fsa_digipeater [ i ] = ax25 -> digipeat -> calls [ i ] ; } } else { fsa -> fsa_ax25 . sax25_family = AF_AX25 ;
@param flags Same flags as for #mprJsonToString : MPR_JSON_PRETTY , MPR_JSON_QUOTES , MPR_JSON_STRINGS . @return Zero if successful , otherwise a negative MPR error code . @ingroup MprJson <START_VULN> @stability Prototype<END_VULN> PUBLIC int mprSaveJson ( MprJson * obj , cchar * path , int flags ) ;
const base : : string16 & object_store_name ) ; std : : unique_ptr < Storage : : Frontend> frontend_ ; <START_VULN> RenderProcessHost * process_ ; <END_VULN> std : : unique_ptr < CacheStorageObserver> cache_storage_observer_ ; std : : unique_ptr < IndexedDBObserver> indexed_db_observer_ ;
case 217 : <START_VULN> #line 1017 "ntp_parser . y"<END_VULN> { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;
RETURN_STRINGL ( fname , flen , 0 ) ; } <START_VULN> <END_VULN>
int i ; const int n = mv_class + CLASS0_BITS - 1 ; for ( i = 0 ; i < n ; ++ i ) <START_VULN> vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ; <END_VULN> }
PepperDeviceEnumerationHostHelper ( ppapi : : host : : ResourceHost * resource_host , <START_VULN> Delegate * delegate , <END_VULN> PP_DeviceType_Dev device_type , const GURL & document_url ) ; ~ PepperDeviceEnumerationHostHelper ( ) ;
png_crc_read ( png_ptr , buf , 9 ) ; <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <END_VULN> return ; res_x = png_get_uint_32 ( buf ) ;
} else { spe_cp = uni_cp ; } <START_VULN> <END_VULN> written_k2 = write_octet_sequence ( & key [ written_k1 ] , charset , spe_cp ) ; memcpy ( & entity [ 1 ] , mcpr [ i ] . normal_entry . entity , l ) ; entity [ l + 1 ] = ' ; ' ;
struct optimize_ctx * const ctx = args -> ctx ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <START_VULN> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <END_VULN> int i , j ; uint8_t * dst ; ENTROPY_CONTEXT * a , * l ;
{ uint8_t tunnel_type , flags ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; <START_VULN> ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <END_VULN> ND_PRINT ( ( ndo , "t Tunnel - type % s ( % u ) , Flags [ % s ] , MPLS Label % u" , tok2str ( bgp_pmsi_tunnel_values , "Unknown" , tunnel_type ) , tunnel_type ,
if ( yych <= '9' ) goto yy79 ; if ( yych != ' ; ' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 558 "extstandardvar_unserializer . re"<END_VULN> { #if SIZEOF_LONG == 4 int digits = YYCURSOR - start - 3 ;
private : already_AddRefed < nsIAtom> GetNameAtom ( nsIContent * aContent ) ; void EnsureChildState ( ) ; <START_VULN> void doRemoveChild ( ) ; <END_VULN> nsString mValue ; nsIContent * mChild ; mozilla : : dom : : Element * GetContentInternal ( ) const
} } } <START_VULN> #endif<END_VULN> FCLOSE ( fpin ) ; FCLOSE ( fpout ) ;
typedef struct _dumpOptions { <START_VULN> const char * dbname ; <END_VULN> const char * pghost ; const char * pgport ; const char * username ;
#undef mem_put_be16 #define mem_put_be16 mem_ops_wrap_symbol ( mem_put_be16 ) <START_VULN> static void mem_put_be16 ( void * vmem , MEM_VALUE_T val ) { <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; mem [ 0 ] = ( val >> 8 ) & 0xff ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : lookup data ; generated by lookups . pl ; edit there <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_LOOKUP_DATA_H_ #ifdef FLOAT_LOOKUP #define COS_LOOKUP_SZ 128 static const float COS_LOOKUP [ COS_LOOKUP_SZ + 1 ] = {
} } <START_VULN> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <END_VULN> { if ( fields ) {
return 0 ; } <START_VULN> <END_VULN> void trace_print_stats ( void ) { ulong count ;
ASSERT ( ! WTF : : IsTriviallyDestructible < T> : : value ) ; HeapObjectHeader * header = HeapObjectHeader : : fromPayload ( pointer ) ; <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <END_VULN> size_t length = header -> payloadSize ( ) sizeof ( T ) ;
template < typename PaintPropertyNode> <START_VULN> bool Clear ( scoped_refptr < PaintPropertyNode> & field ) { <END_VULN> if ( field ) { field = nullptr ; return true ;
const std : : vector < SkISize> supported_sizes_ ; <START_VULN> Mutex generator_mutex_ ; <END_VULN> bool decode_failed_ = false ; bool yuv_decoding_failed_ = false ;
Ci -> green = Ai -> green - Bi -> green ; Cr -> blue = Ar -> blue - Br -> blue ; Ci -> blue = Ai -> blue - Bi -> blue ; <START_VULN> if ( images -> matte != MagickFalse ) <END_VULN> { Cr -> opacity = Ar -> opacity - Br -> opacity ; Ci -> opacity = Ai -> opacity - Bi -> opacity ;
int ret ; ret = png_set_text_2 ( png_ptr , info_ptr , text_ptr , num_text ) ; <START_VULN> if ( ret ) <END_VULN> png_error ( png_ptr , "Insufficient memory to store text" ) ; }
SPL_METHOD ( SplFileObject , current ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
bool hasStartTime ( ) const { return ! isNull ( m_startTime ) ; } double startTime ( ) const { return m_startTime ; } <START_VULN> void setStartTime ( double ) ; <END_VULN> TimedItem * source ( ) { return m_content . get ( ) ; } TimedItem * source ( bool & isNull ) { isNull = ! m_content ; return m_content . get ( ) ; }
extern void _vp_remove_floor ( vorbis_look_psy * p , float * mdct , int * icodedflr , float * residue , int sliding_lowpass ) ; extern void _vp_noisemask ( vorbis_look_psy * p , <START_VULN> float * logmdct , <END_VULN> float * logmask ) ; extern void _vp_tonemask ( vorbis_look_psy * p , float * logfft , float * logmask , float global_specmax , float local_specmax ) ;
virtual void DeleteMatch ( const AutocompleteMatch & match ) OVERRIDE ; protected : <START_VULN> HistoryProvider ( ACProviderListener * listener , <END_VULN> Profile * profile , const char * name ) ; virtual ~ HistoryProvider ( ) ;
virtual ~ RenderWidgetHostViewAura ( ) ; void UpdateCursorIfOverSelf ( ) ; <START_VULN> bool ShouldFastACK ( uint64 surface_id ) ; <END_VULN> void UpdateExternalTexture ( ) ; ui : : InputMethod * GetInputMethod ( ) const ;
#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED static void <START_VULN> image_transform_png_set_strip_alpha_set ( PNG_CONST image_transform * this , <END_VULN> transform_display * that , png_structp pp , png_infop pi ) { png_set_strip_alpha ( pp ) ;
<START_VULN> void ConfigureStreams ( bool require_photo ) ; <END_VULN> void OnConfiguredStreams ( int32_t result , cros : : mojom : : Camera3StreamConfigurationPtr updated_config ) ;
static apr_status_t parse_chunk_size ( http_ctx_t * ctx , const char * buffer , <START_VULN> apr_size_t len , int linelimit ) <END_VULN> { apr_size_t i = 0 ;
virtual void appendElement ( StringBuilder & , Element * , Namespaces * ) ; void appendOpenTag ( StringBuilder & , Element * , Namespaces * ) ; void appendCloseTag ( StringBuilder & , Element * ) ; <START_VULN> virtual void appendAttribute ( StringBuilder & , Element * , const Attribute & , Namespaces * ) ; <END_VULN> void appendCDATASection ( StringBuilder & , const String & ) ; void appendStartMarkup ( StringBuilder & , const Node * , Namespaces * ) ; bool shouldSelfClose ( const Node * ) ;
{ spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ; spl_filesystem_object * object = spl_filesystem_iterator_to_object ( iterator ) ; <START_VULN> <END_VULN> object -> u . dir . index ++ ; do { spl_filesystem_dir_read ( object TSRMLS_CC ) ;
int res_unpack ( vorbis_info_residue * info , <START_VULN> vorbis_info * vi , oggpack_buffer * opb ) { <END_VULN> int j , k ; codec_setup_info * ci = ( codec_setup_info * ) vi -> codec_setup ; memset ( info , 0 , sizeof ( * info ) ) ;
mm_segment_t seg ; perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , <START_VULN> 1 , 0 , regs , regs -> cp0_badvaddr ) ; <END_VULN>
int x , y ; float x_ratio , y_ratio ; long ignore_warning ; <START_VULN> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "pplll" , & f_org , & f_org_len , & f_dest , & f_dest_len , & height , & width , & threshold ) == FAILURE ) { return ; }
uint_fast32_t len ; <START_VULN> uchar * data ; <END_VULN> } jpc_ppxstabent_t ;
lfm -> int_4x4_y &= mask_y ; lfm -> int_4x4_uv &= mask_uv_int ; <START_VULN> <END_VULN> if ( columns == 1 ) { lfm -> left_uv [ TX_8X8 ] |= lfm -> left_uv [ TX_16X16 ] ;
progressive_row ( png_structp ppIn , png_bytep new_row , png_uint_32 y , int pass ) { png_const_structp pp = ppIn ; <START_VULN> PNG_CONST standard_display * dp = voidcast ( standard_display * , <END_VULN> png_get_progressive_ptr ( pp ) ) ; y = PNG_ROW_FROM_PASS_ROW ( y , pass ) ; }
ZVAL_STR ( rval , str ) ; return 1 ; } <START_VULN> #line 936 "extstandardvar_unserializer . c"<END_VULN> yy46 : yych = * ++ YYCURSOR ; if ( yych == ' + ' ) goto yy47 ;
<START_VULN> class AutocompleteController : public ACProviderListener { <END_VULN> public : static const int kNoItemSelected ;
void GetOverflowItems ( std : : vector < LauncherItem> * items ) ; <START_VULN> void ShowOverflowMenu ( ) ; <END_VULN>
if ( event ) { found = 1 ; <START_VULN> record_and_restart ( event , val , regs , nmi ) ; <END_VULN> } else {
ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 | | i_temp > = ps_seq -> i4_max_pic_order_cntLsb ) <START_VULN> return ERROR_INV_SPS_PPS_T ; <END_VULN> s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( "SH : pic_order_cnt_lsb" , s_tmp_poc . i4_pic_order_cnt_lsb ) ;
fseek ( fp , 0 , SEEK_SET ) ; <START_VULN> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <END_VULN> ver = 1 ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) {
static png_structp set_store_for_read ( png_store * ps , png_infopp ppi , png_uint_32 id , <START_VULN> PNG_CONST char * name ) <END_VULN> { safecat ( ps -> test , sizeof ps -> test , 0 , name ) ;
if ( tlen ) { oid_len = * tptr ; <START_VULN> if ( tlen < oid_len ) { <END_VULN> return 0 ; } if ( oid_len ) {
( void ) WriteBlobByte ( image , byte ) ; ( void ) WriteBlob ( image , tptr - tmpbuf , ( unsigned char * ) tmpbuf ) ; } <START_VULN> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <END_VULN> } else ( void ) WriteBlob ( image , bytes_per_row , one_row ) ;
} } <START_VULN> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <END_VULN> { WLog_DBG ( TAG , " % s ( Len : % "PRIu16" MaxLen : % "PRIu16" BufferOffset : % "PRIu32" ) " , name , fields -> Len , fields -> MaxLen , fields -> BufferOffset ) ;
if ( NXT ( 1 ) == '#' ) { int i = 0 ; <START_VULN> xmlChar out [ 10 ] ; <END_VULN> int hex = NXT ( 2 ) ; int value = xmlParseCharRef ( ctxt ) ;
class V4L2VP9Picture ; class VaapiVP9Picture ; <START_VULN> class VP9Picture : public base : : RefCounted < VP9Picture> { <END_VULN> public : VP9Picture ( ) ;
} if ( ! silent ) <START_VULN> printf ( "gamma % f : maximum 8 bit error % f" , g , maxerr ) ; <END_VULN> maxerr = 0 ; for ( j = 0 ; j < 65536 ; ++ j )
protected : nsPresContext * mPresContext ; nsCOMPtr < nsIPresShell> mPresShell ; nsCOMPtr < nsISelection> mSelection ; nsRefPtr < nsRange> mFirstSelectedRange ; nsCOMPtr < nsIContent> mRootContent ; nsresult Init ( WidgetQueryContentEvent * aEvent ) ; nsresult Init ( WidgetSelectionEvent * aEvent ) ; <START_VULN> <END_VULN> nsresult InitCommon ( ) ; public : static nsresult GetFlatTextOffsetOfRange ( nsIContent * aRootContent , nsINode * aNode , int32_t aNodeOffset ,
yych = * ++ YYCURSOR ; if ( yych != '"' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 609 "extstandardvar_unserializer . re"<END_VULN> { size_t len , maxlen ; char * str ;
long n = look -> n ; long posts = look -> posts ; long nonzero = 0 ; lsfit_acc fits [ VIF_POSIT + 1 ] ; int fit_valueA [ VIF_POSIT + 2 ] ; int fit_valueB [ VIF_POSIT + 2 ] ; int loneighbor [ VIF_POSIT + 2 ] ; <START_VULN> int hineighbor [ VIF_POSIT + 2 ] ; <END_VULN> int * output = NULL ; int memo [ VIF_POSIT + 2 ] ; for ( i = 0 ; i < posts ; i ++ ) fit_valueA [ i ] = - 200 ; for ( i = 0 ; i < posts ; i ++ ) fit_valueB [ i ] = - 200 ; for ( i = 0 ; i < posts ; i ++ ) loneighbor [ i ] = 0 ; for ( i = 0 ; i < posts ; i ++ ) hineighbor [ i ] = 1 ; for ( i = 0 ; i < posts ; i ++ ) memo [ i ] = - 1 ;
double sigma ; int ai = a , qi = q , i ; <START_VULN> vp9_clear_system_state ( ) ; <END_VULN> sigma = ai + . 5 + . 6 * ( 63 - qi ) 63 . 0 ;
if ( noff > = ( off_t ) xsh_size ) break ; noff = donote ( ms , nbuf , ( size_t ) noff , <START_VULN> xsh_size , clazz , swap , 4 , flags ) ; <END_VULN> if ( noff == 0 ) break ; }
dcfg -> hash_is_enabled = HASH_DISABLED ; dcfg -> hash_enforcement = HASH_DISABLED ; } <START_VULN> else return apr_psprintf ( cmd -> pool , "ModSecurity : Invalid value for SecRuleEngine : % s" , p1 ) ; <END_VULN> return NULL ; }
else if ( output_gamma == PNG_GAMMA_MAC_18 | | output_gamma == PNG_FP_1 PNG_GAMMA_MAC_18 ) { <START_VULN> if ( is_screen ) <END_VULN> output_gamma = PNG_GAMMA_MAC_OLD ; else output_gamma = PNG_GAMMA_MAC_INVERSE ;
png_debug1 ( 1 , "in % s retrieval function" , "gAMA" ) ; if ( png_ptr != NULL && info_ptr != NULL && <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_GAMMA ) && <END_VULN> file_gamma != NULL ) { * file_gamma = info_ptr -> colorspace . gamma ;
} static __always_inline void <START_VULN> perf_sw_event ( u32 event_id , u64 nr , int nmi , struct pt_regs * regs , u64 addr ) <END_VULN> { struct pt_regs hot_regs ;
void set_config ( QuicStringPiece config ) { config . CopyToString ( & config_ ) ; } QuicServerConfigProtobuf : : PrivateKey * add_key ( ) { <START_VULN> keys_ . push_back ( base : : MakeUnique < PrivateKey> ( ) ) ; <END_VULN> return keys_ . back ( ) . get ( ) ; }
inline void setNextView ( ArrayBufferViewObject * view ) ; <START_VULN> void neuter ( JSContext * cx ) ; <END_VULN> static void trace ( JSTracer * trc , JSObject * obj ) ;
ND_PRINT ( ( ndo , " ( length bogus , should be > = 4 ) " ) ) ; return 0 ; } <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <END_VULN> if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , " : LQR" ) ) ; else
int tox , toy ; int ncR , ncG , ncB ; toy = dstY ; <START_VULN> <END_VULN> for ( y = srcY ; y < ( srcY + h ) ; y ++ ) { tox = dstX ; for ( x = srcX ; x < ( srcX + w ) ; x ++ ) {
<START_VULN> PHP_FUNCTION ( locale_get_display_name ) <END_VULN> { get_icu_disp_value_src_php ( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; }
#endif <START_VULN> typedef png_libpng_version_1_6_10 Your_png_h_is_not_version_1_6_10 ; <END_VULN>
if ( ! op && ! adv ) return ( 1 ) ; { int size = os -> lacing_vals [ ptr ] & 0xff ; <START_VULN> int bytes = size ; <END_VULN> int eos = os -> lacing_vals [ ptr ] & 0x200 ; int bos = os -> lacing_vals [ ptr ] & 0x100 ; while ( size == 255 ) { int val = os -> lacing_vals [ ++ ptr ] ; size = val & 0xff ; if ( val & 0x200 ) eos = 0x200 ; bytes += size ;
#include < ft2build . h> #include FT_CONFIG_CONFIG_H #include FT_INTERNAL_OBJECTS_H #include FT_INTERNAL_DEBUG_H #include FT_MODULE_H #include "basepic . h" <START_VULN> <END_VULN> #undef FT_COMPONENT #define FT_COMPONENT trace_init
switch ( cmdCode ) { case EFFECT_CMD_INIT : <START_VULN> if ( pReplyData == NULL | | * replySize != sizeof ( int ) ) { <END_VULN> return - EINVAL ; } * ( int * ) pReplyData = Downmix_Init ( pDwmModule ) ;
e = gf_dm_sess_process ( sess ) ; if ( ! e ) { strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; <START_VULN> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <END_VULN> } gf_dm_sess_del ( sess ) ; }
: public base : : RefCounted < BluetoothAdapter> { public : <START_VULN> class Observer { <END_VULN> public : virtual ~ Observer ( ) { }
<START_VULN> <END_VULN> if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 | | ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 | |
int perf_output_begin ( struct perf_output_handle * handle , struct perf_event * event , unsigned int size , <START_VULN> int nmi , int sample ) <END_VULN> { struct ring_buffer * rb ; unsigned long tail , offset , head ;
int ji ; for ( ITERATE_CONFIG ( route , prop , child , ji ) ) { <START_VULN> if ( mprGetJson ( route -> config , sfmt ( "app . http . content . minify [ @ = ' % s' ] " , child -> value ) ) ) { <END_VULN> httpAddRouteMapping ( route , child -> value , " $ { 1 } . gz , min . $ { 1 } . gz , min . $ { 1 } " ) ; } else { httpAddRouteMapping ( route , child -> value , " $ { 1 } . gz" ) ;
clone_info = CloneDrawInfo ( ( ImageInfo * ) NULL , draw_info ) ; clone_info -> stroke_width = 0 . 0 ; <START_VULN> clone_info -> stroke . alpha = ( Quantum ) TransparentAlpha ; <END_VULN> status &= DrawPolygonPrimitive ( image , clone_info , primitive_info , exception ) ; clone_info = DestroyDrawInfo ( clone_info ) ;
SimpleStringList tableNames ; intuseDB ; <START_VULN> char * dbname ; <END_VULN> char * pgport ; char * pghost ; char * username ;
MarFile * CVE_2013_1726_mar_wopen ( const wchar_t * path ) { FILE * fp ; <START_VULN> fp = _wfopen ( path , L"rb" ) ; <END_VULN> if ( ! fp ) return NULL ; return mar_fpopen ( fp ) ; }
NULL , 0 , 0 , 0 , 0 , 0 , NULL , NULL , NULL , NULL , 0 } ; static float * test1_result = NULL ; <START_VULN> <END_VULN> static_codebook test2 = { 4 , 3 , NULL , 2 , - 533200896 , 1611661312 , 4 , 0 , full_quantlist1 , NULL , NULL , NULL ,
#endif <START_VULN> if ( transforms & PNG_TRANSFORM_EXPAND_16 ) <END_VULN> #ifdef PNG_READ_EXPAND_16_SUPPORTED png_set_expand_16 ( png_ptr ) ; #else
if ( ! fstype ) { error = - ENODEV ; goto out ; } if ( fstype -> fs_flags & FS_REQUIRES_DEV ) need_dev = 1 ; } if ( need_dev ) { <START_VULN> if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) { <END_VULN> error = - ENOENT ; goto out ; } requested_dev_name = tomoyo_realpath_from_path ( & path ) ; if ( ! requested_dev_name ) { error = - ENOENT ; goto out ; } } else {
#endif virtual nsresult Close ( ) ; virtual void Suspend ( bool aCloseImmediately ) ; virtual void Resume ( ) ; virtual already_AddRefed < nsIPrincipal> GetCurrentPrincipal ( ) ; bool IsClosed ( ) const { return mCacheStream . IsClosed ( ) ; } virtual bool CanClone ( ) ; <START_VULN> virtual MediaResource * CloneData ( MediaDecoder * aDecoder ) ; <END_VULN> void RecordStatisticsTo ( MediaChannelStatistics * aStatistics ) MOZ_OVERRIDE { NS_ASSERTION ( aStatistics , "Statistics param cannot be null ! " ) ; MutexAutoLock lock ( mLock ) ; if ( ! mChannelStatistics ) { mChannelStatistics = aStatistics ; }
ret = gpiochip_add_data ( & gpio_dev -> gc , gpio_dev ) ; if ( ret ) <START_VULN> goto out1 ; <END_VULN> ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ;
tpgt_str += 5 ; tpgt = ( unsigned short int ) simple_strtoul ( tpgt_str , & end_ptr , 0 ) ; <START_VULN> if ( tpgt > TL_TPGS_PER_HBA ) { <END_VULN> printk ( KERN_ERR "Passed tpgt : % hu exceeds TL_TPGS_PER_HBA : " " % u" , tpgt , TL_TPGS_PER_HBA ) ; return ERR_PTR ( - EINVAL ) ;
#include "vpxvpx_codec . h" <START_VULN> static const char * const cfg = " -- target = mips64 - linux - gcc -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
readbuf [ i ] = png_get_uint_16 ( buf ) ; } <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <END_VULN> return ; png_set_hIST ( png_ptr , info_ptr , readbuf ) ;
linenr_Tline_lnum ; colnr_Tline_colnr ; linenr_Tline_count ; <START_VULN> intnum_head = 0 ; <END_VULN> longold_header_seq , new_header_seq , cur_header_seq ; longseq_last , seq_cur ; longlast_save_nr = 0 ;
#undef mem_put_be24 #define mem_put_be24 mem_ops_wrap_symbol ( mem_put_be24 ) <START_VULN> static void mem_put_be24 ( void * vmem , MEM_VALUE_T val ) { <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; mem [ 0 ] = ( val >> 16 ) & 0xff ;
DEBUG ( "emulate a2dp read delay ( % d us ) " , us_delay ) ; <START_VULN> usleep ( us_delay ) ; <END_VULN> pthread_mutex_unlock ( & in -> common . lock ) ; return - 1 ; }
ret = FAIL ; break ; } <START_VULN> <END_VULN> new_charset_name = mnd_pestrdup ( value , conn -> persistent ) ; if ( ! new_charset_name ) { goto oom ;
Codec codec , VideoCodecProfile video_profile , uint8_t video_level , <START_VULN> gfx : : ColorSpace : : TransferID eotf , <END_VULN> bool is_encrypted ) const ;
return png_ptr -> io_ptr ; } <START_VULN> #endif<END_VULN>
& cipher , & cipher_len , & module , & module_len ) == FAILURE ) { return ; } <START_VULN> <END_VULN> td = mcrypt_module_open ( cipher , cipher_dir_string , module , module_dir_string ) ; if ( td != MCRYPT_FAILED ) { RETVAL_LONG ( mcrypt_enc_get_key_size ( td ) ) ;
const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ; const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; <START_VULN> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <END_VULN> const __m128i k__const_0 = _mm_set1_epi16 ( 0 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ;
return 1 ; } <START_VULN> void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <END_VULN> { if ( fields -> Len > 0 ) {
{ return png_ptr -> chunk_name ; } <START_VULN> #endif<END_VULN> #ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED # ifdef PNG_GET_PALETTE_MAX_SUPPORTED
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : single - block PCM analysis mode dispatch <START_VULN> last mod : $ Id : analysis . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdio . h> #include < string . h> #include < math . h> #include < oggogg . h> #include "vorbiscodec . h"
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_PREFERRED_CODEC ) ) { ast_codec_choose ( & p -> prefs , p -> jointcaps , 1 , & tmp_fmt ) ; ast_format_cap_set ( p -> jointcaps , & tmp_fmt ) ; } } if ( p -> rtp ) { <START_VULN> if ( portno > 0 ) { <END_VULN> ast_sockaddr_set_port ( sa , portno ) ; ast_rtp_instance_set_remote_address ( p -> rtp , sa ) ; if ( debug ) { ast_verbose ( "Peer audio RTP is at port % s" , ast_sockaddr_stringify ( sa ) ) ; } ast_rtp_codecs_payloads_copy ( & newaudiortp , ast_rtp_instance_get_codecs ( p -> rtp ) , p -> rtp ) ; ast_rtp_instance_set_prop ( p -> rtp , AST_RTP_PROPERTY_RTCP , 1 ) ;
#define MAXstring 64 #define MAGICNO0xF11E041C <START_VULN> #define VERSIONNO11<END_VULN> #define FILE_MAGICSIZE248 #defineFILE_LOAD0
Id id ; <START_VULN> RefCountedPropertyTreeState properties ; <END_VULN>
unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ ) <START_VULN> vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; <END_VULN> free ( ctx -> buf ) ; } free ( ctx ) ;
#define VIEWS_REPEAT_CONTROLLER_H_ #pragma once <START_VULN> #include "basecallback . h"<END_VULN> #include "basememoryscoped_ptr . h" #include "basetimer . h"
YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; <START_VULN> vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <END_VULN> cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ;
return SC_ERROR_INVALID_ARGUMENTS ; } <START_VULN> if ( sec_attr == NULL ) { <END_VULN> if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ;
* <START_VULN> if ( ! do_local_compose && do_local_background != 2 ) <END_VULN> passes = png_set_interlace_handling ( png_ptr ) ; png_read_update_info ( png_ptr , info_ptr ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : maintain the info structure , info < -> header packets <START_VULN> last mod : $ Id : info . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h> #include < string . h>
<START_VULN> IPC_STRUCT_TRAITS_MEMBER ( preview_ui_addr ) <END_VULN> IPC_STRUCT_TRAITS_MEMBER ( preview_request_id )
} length ++ ; } <START_VULN> length = length * BezierQuantum2 ; <END_VULN> break ; } case CirclePrimitive :
struct ipcm_cookie * ipc , struct rtable ** rtp ) { struct inet_sock * inet = inet_sk ( sk ) ; <START_VULN> struct ip_options * opt ; <END_VULN> struct rtable * rt ;
} * tail = vp ; <START_VULN> while ( * tail ) tail = & vp -> next ; <END_VULN> p += alen ; } }
} addr = compute_effective_address ( regs , insn ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <END_VULN> switch ( dir ) { case load : err = do_int_load ( fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) ,
#include < vector> #include "basecallback . h" <START_VULN> #include "basemove . h"<END_VULN> #include "extensionsrendererapidisplay_sourcewifi_displaywifi_display_transport_stream_packetizer . h" namespace extensions {
static void Create ( <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> PlatformSensorProvider * provider , std : : unique_ptr < PlatformSensorFusionAlgorithm> fusion_algorithm , const PlatformSensorProviderBase : : CreateSensorCallback & callback ) ;
} ; <START_VULN> const interp_kernel vp9_filteredinterp_filters1000 [ ( 1 << SUBPEL_BITS ) ] = { <END_VULN> { 0 , 0 , 0 , 128 , 0 , 0 , 0 , 0 } , { 0 , 1 , - 3 , 128 , 3 , - 1 , 0 , 0 } , { - 1 , 2 , - 6 , 127 , 7 , - 2 , 1 , 0 } ,
} #ifdef CONFIG_HAVE_HW_BREAKPOINT <START_VULN> void ptrace_triggered ( struct perf_event * bp , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event_attr attr ;
} <START_VULN> PUBLIC ssize slen ( char * s ) <END_VULN> { return s ? strlen ( s ) : 0 ; }
#include "basemacros . h" #include "basememoryref_counted . h" #include "basesingle_thread_task_runner . h" #include "basesynchronizationlock . h" <START_VULN> #include "basesynchronizationread_write_lock . h"<END_VULN> #include "basethreadingthread . h" #include "basetimetime . h" #include "mediamidimidi_export . h"
0 . 9919389832F , 0 . 9931929973F , 0 . 9942985174F , 0 . 9952667537F , 0 . 9961087037F , 0 . 9968351119F , 0 . 9974564312F , 0 . 9979827858F , 0 . 9984239359F , 0 . 9987892441F , 0 . 9990876435F , 0 . 9993276081F , 0 . 9995171241F , 0 . 9996636648F , 0 . 9997741654F , 0 . 9998550016F , 0 . 9999119692F , 0 . 9999502656F , 0 . 9999744742F , 0 . 9999885497F , 0 . 9999958064F , 0 . 9999989077F , 0 . 9999998584F , 0 . 9999999983F , } ; <START_VULN> static float vwin512 [ 256 ] = { <END_VULN> 0 . 0000147849F , 0 . 0001330607F , 0 . 0003695946F , 0 . 0007243509F , 0 . 0011972759F , 0 . 0017882983F , 0 . 0024973285F , 0 . 0033242588F , 0 . 0042689632F , 0 . 0053312973F , 0 . 0065110982F , 0 . 0078081841F , 0 . 0092223540F , 0 . 0107533880F , 0 . 0124010466F , 0 . 0141650703F , 0 . 0160451800F , 0 . 0180410758F , 0 . 0201524373F , 0 . 0223789233F , 0 . 0247201710F , 0 . 0271757958F , 0 . 0297453914F , 0 . 0324285286F , 0 . 0352247556F , 0 . 0381335972F , 0 . 0411545545F , 0 . 0442871045F , 0 . 0475306997F , 0 . 0508847676F , 0 . 0543487103F , 0 . 0579219038F ,
<START_VULN> static PNG_CONST<END_VULN> png_byte adam7 [ 8 ] [ 8 ] = { { 1 , 6 , 4 , 6 , 2 , 6 , 4 , 6 } ,
static nsresult CVE_2013_1705_cryptojs_ReadArgsAndGenerateKey ( JSContext * cx , jsval * argv , nsKeyPairInfo * keyGenType , nsIInterfaceRequestor * uiCxt , PK11SlotInfo ** slot , bool willEscrow ) { JSString * jsString ; <START_VULN> JSAutoByteString params , keyGenAlg ; <END_VULN> int keySize ; nsresult rv ; if ( ! JSVAL_IS_INT ( argv [ 0 ] ) ) { JS_ReportError ( cx , " % s % s" , JS_ERROR , "passed in non - integer for key size" ) ; return NS_ERROR_FAILURE ; } keySize = JSVAL_TO_INT ( argv [ 0 ] ) ; if ( ! JSVAL_IS_NULL ( argv [ 1 ] ) ) {
int pgx_validate ( jas_stream_t * in ) { <START_VULN> uchar buf [ PGX_MAGICLEN ] ; <END_VULN> uint_fast32_t magic ; int i ; int n ;
efree ( ustr ) ; } ubrk_close ( bi ) ; <START_VULN> RETURN_EMPTY_STRING ( ) ; <END_VULN> }
len = strlen ( locale_name ) ; } <START_VULN> zend_alter_ini_entry ( LOCALE_INI_NAME , sizeof ( LOCALE_INI_NAME ) , locale_name , len , PHP_INI_USER , PHP_INI_STAGE_RUNTIME ) ; <END_VULN> RETURN_TRUE ; }
the debug channel , the log handler will be invoked to accept the output message . @param handler Callback handler @return Prior log handler <START_VULN> @stability Evolving<END_VULN> PUBLIC MprLogHandler mprSetLogHandler ( MprLogHandler handler ) ;
modifier *= modifier ; modifier *= 3 ; <START_VULN> modifier += 1 << ( strength - 1 ) ; <END_VULN> modifier >>= strength ; if ( modifier > 16 )
break ; } <START_VULN> setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , 0 ) ; <END_VULN> if ( setup_ret == 0 ) { goto _mus_end ; }
nsIPrincipal * originPrincipal , nsISupports * context , const nsACString & mimeType , nsISupports * extra , int16_t * decision , nsIContentPolicy * policyService = nullptr , nsIScriptSecurityManager * aSecMan = nullptr ) { <START_VULN> CHECK_PRINCIPAL ; <END_VULN> if ( policyService ) { CHECK_CONTENT_POLICY_WITH_SERVICE ( ShouldProcess , policyService ) ; } CHECK_CONTENT_POLICY ( ShouldProcess ) ; } #undef CHECK_CONTENT_POLICY #undef CHECK_CONTENT_POLICY_WITH_SERVICE
int ret = - 1 ; while ( r ) { <START_VULN> do ret = recv ( sock_fd , buf , r , MSG_WAITALL ) ; <END_VULN> while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) {
assert ( bufsize > JAS_STREAM_MAXPUTBACK ) ; <START_VULN> stream -> bufbase_ = JAS_CAST ( uchar * , buf ) ; <END_VULN> stream -> bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK ; } } else {
else poolDiscard ( & dtd -> pool ) ; elementType -> prefix = prefix ; <START_VULN> <END_VULN> } } return 1 ;
return 1 ; } <START_VULN> #line 1161 "extstandardvar_unserializer . c"<END_VULN> yy76 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy73 ;
qrio_enable_app_buffer ( ) ; <START_VULN> return ret ; <END_VULN> } unsigned long get_board_sys_clk ( unsigned long dummy )
} else { use_key_length = max_key_length ; for ( i = 0 ; i < count ; i ++ ) { <START_VULN> if ( key_length_sizes [ i ] > = key_len && <END_VULN> key_length_sizes [ i ] < use_key_length ) { use_key_length = key_length_sizes [ i ] ;
ExtensionToolbarModel toolbar_model_ ; <START_VULN> <END_VULN> typedef std : : map < std : : string , FilePath> UnloadedExtensionPathMap ; UnloadedExtensionPathMap unloaded_extension_paths_ ;
Vector < CFGState , 8 , IonAllocPolicy> cfgStack_ ; Vector < ControlFlowInfo , 4 , IonAllocPolicy> loops_ ; Vector < ControlFlowInfo , 0 , IonAllocPolicy> switches_ ; Vector < ControlFlowInfo , 2 , IonAllocPolicy> labels_ ; Vector < MInstruction * , 2 , IonAllocPolicy> iterators_ ; TypeOracle * oracle ; <START_VULN> size_t inliningDepth ; <END_VULN> Vector < MDefinition * , 0 , IonAllocPolicy> inlinedArguments_ ; bool failedBoundsCheck_ ;
dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; } <START_VULN> if ( unlikely ( len > ring -> rx_buffersize ) ) { <END_VULN>
yyg -> yy_hold_char = * ++ yyg -> yy_c_buf_p ; if ( c == '' ) <START_VULN> <END_VULN> do { yylineno ++ ; yycolumn = 0 ; } while ( 0 )
#define png_zTXt PNG_U32 ( 122 , 84 , 88 , 116 ) #endif <START_VULN> <END_VULN> #define sig1 PNG_U32 ( 137 , 80 , 78 , 71 ) #define sig2 PNG_U32 ( 13 , 10 , 26 , 10 )
} <START_VULN> if ( mount ( "cgroup" , cgpath , "tmpfs" , 0 , "size = 10000 , mode = 755" ) ) { <END_VULN> SYSERROR ( "Failed to mount tmpfs at % s" , cgpath ) ; return false ; }
#endif if ( ! is_anonymous ) { <START_VULN> if ( s && s > filename ) { <END_VULN> safe_php_register_variable ( lbuf , s + 1 , strlen ( s + 1 ) , NULL , 0 TSRMLS_CC ) ; } else { safe_php_register_variable ( lbuf , filename , strlen ( filename ) , NULL , 0 TSRMLS_CC ) ;
int tmp_best_skippable = 0 ; int switchable_filter_index ; int_mv * second_ref = comp_pred ? <START_VULN> & mbmi -> ref_mvs [ second_ref_frame ] [ 0 ] : NULL ; <END_VULN> b_mode_info tmp_best_bmodes [ 16 ] ; MB_MODE_INFO tmp_best_mbmode ; BEST_SEG_INFO bsi [ SWITCHABLE_FILTERS ] ;
#include < stddef . h> #include < utility> <START_VULN> #include "basemove . h"<END_VULN> #include "mojopubliccppbindingslibarray_internal . h" #include "mojopubliccppbindingslibbindings_internal . h" #include "mojopubliccppbindingslibtemplate_util . h"
virtual bool OnMakeCurrent ( gfx : : GLContext * context ) OVERRIDE ; <START_VULN> virtual void OnBufferPresented ( bool presented , <END_VULN> uint32 sync_point ) OVERRIDE ; virtual void OnResizeViewACK ( ) OVERRIDE ; virtual void OnResize ( gfx : : Size size ) OVERRIDE ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : channel mapping 0 implementation <START_VULN> last mod : $ Id : mapping0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h> #include < stdio . h> #include < string . h> #include < math . h> #include < oggogg . h>
else valx = startx + i * delx ; numaGetFValue ( nay , i , & valy ) ; <START_VULN> snprintf ( buf , L_BUF_SIZE , " % f % f" , valx , valy ) ; <END_VULN> sarrayAddString ( sa , buf , L_COPY ) ; } datastr = sarrayToString ( sa , 0 ) ;
png_debug1 ( 1 , "in % s retrieval function" , "cHRM" ) ; if ( png_ptr != NULL && info_ptr != NULL && <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) ) <END_VULN> { if ( white_x != NULL ) * white_x = info_ptr -> colorspace . end_points_xy . whitex ;
} } <START_VULN> void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <END_VULN> int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct16x16_add ( input , dest , stride , eob ) ;
return ( png_uint_16 ) val ; } <START_VULN> #endif<END_VULN> void
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - <START_VULN> Copyright ( c ) 1998 - 2007 Greg Roelofs . All rights reserved . <END_VULN> This software is provided "as is , " without warranty of any kind , express or implied . In no event shall the author or contributors
for ( int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK ; i > 0 ; i -- , to ++ ) { JSBool marked = to -> IsMarked ( ) ; to -> Unmark ( ) ; if ( marked ) continue ; <START_VULN> if ( ! to -> GetJSObject ( ) ) { <END_VULN> nsISupports * obj = to -> GetNative ( ) ; if ( obj ) { obj -> Release ( ) ; to -> SetNative ( nsnull ) ; } to -> SetInterface ( nsnull ) ; } }
parser -> m_processor = prologProcessor ; return doProlog ( parser , parser -> m_encoding , s , end , tok , next , nextPtr , <START_VULN> ( XML_Bool ) ! parser -> m_parsingStatus . finalBuffer ) ; <END_VULN> } static enum XML_Error PTRCALL
if ( PASS == conn -> m -> local_tx_start ( conn , this_func TSRMLS_CC ) ) { ret = conn -> m -> query ( conn , "COMMIT" , sizeof ( "COMMIT" ) - 1 TSRMLS_CC ) ; <START_VULN> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_RETURN ( ret ) ;
# if PNG_sRGB_PROFILE_CHECKS == 0 <START_VULN> if ( png_sRGB_checks [ i ] . have_md5 ) <END_VULN> return 1 + png_sRGB_checks [ i ] . is_broken ; # endif
while ( 1 ) { <START_VULN> ret = poll ( & pfd , 1 , 1 ) ; <END_VULN> BTIF_TRACE_VERBOSE ( " % s ( ) - polling fd % d , revents : 0x % x , ret % d" , __FUNCTION__ , pfd . fd , pfd . revents , ret ) ;
char * start = s ; char * t = s ; for ( ; * s ; s ++ ) { <START_VULN> if ( isspace ( * s ) ) <END_VULN> continue ; if ( c1 ) { * t ++ = ( hexval ( c1 ) << 4 ) + hexval ( * s ) ;
char delimiter [ 2 ] , enclosure [ 2 ] ; array_init ( return_value ) ; <START_VULN> <END_VULN> delimiter [ 0 ] = intern -> u . file . delimiter ; delimiter [ 1 ] = '0' ; enclosure [ 0 ] = intern -> u . file . enclosure ;
unsigned short len = data_len ; <START_VULN> if ( packet -> size + 4 + data_len > MT_PACKET_LEN ) { <END_VULN> fprintf ( stderr , _ ( "mndp_add_attribute : ERROR , too large packet . Exceeds % d bytes" ) , MT_PACKET_LEN ) ; return - 1 ; }
#include "vmRegExpObject . h" #include "jsscopeinlines . h" namespace js { inline Bindings : : Bindings ( JSContext * cx ) <START_VULN> : lastBinding ( NULL ) , nargs ( 0 ) , nvars ( 0 ) , nupvars ( 0 ) <END_VULN> { } inline void Bindings : : transfer ( JSContext * cx , Bindings * bindings ) { JS_ASSERT ( ! lastBinding ) ; JS_ASSERT ( ! bindings -> lastBinding | | ! bindings -> lastBinding -> inDictionary ( ) ) ;
#include "chromecommonnotification_registrar . h" class Extension ; <START_VULN> class FindManager ; <END_VULN> class NavigationController ; class PasswordManager ; class PasswordManagerDelegate ;
<START_VULN> if ( cdigits + czero - clead + 1 < ( int ) precision ) <END_VULN> fp = modf ( fp , & d ) ; else
} } <START_VULN> if ( context && <END_VULN> php_stream_context_get_option ( context , "http" , "user_agent" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) { ua_str = Z_STRVAL_PP ( ua_zval ) ;
fputs ( " " , stdout ) ; fputs ( name , stdout ) ; fputs ( " = "" , stdout ) ; <START_VULN> safe_print ( value , valsz , """ ) ; <END_VULN> fputs ( """ , stdout ) ; } }
# endif } #endif <START_VULN> #endif<END_VULN> void png_chunk_report ( png_const_structrp png_ptr , png_const_charp message , int error )
<START_VULN> key = stok ( key , " : rt " , & junk ) ; <END_VULN> httpSetHeaderString ( conn , key , value ) ; } }
void mdct_clear ( mdct_lookup * l ) { if ( l ) { if ( l -> trig ) _ogg_free ( l -> trig ) ; if ( l -> bitrev ) _ogg_free ( l -> bitrev ) ; memset ( l , 0 , sizeof ( * l ) ) ; } } <START_VULN> STIN void mdct_bitreverse ( mdct_lookup * init , <END_VULN> DATA_TYPE * x ) { int n = init -> n ; int * bit = init -> bitrev ; DATA_TYPE * w0 = x ; DATA_TYPE * w1 = x = w0 + ( n >> 1 ) ; DATA_TYPE * T = init -> trig + n ; do {
int n ; int c ; bool s ; <START_VULN> ulong tmp ; <END_VULN> assert ( ( ! sgnd && prec > = 1 ) | | ( sgnd && prec > = 2 ) ) ; if ( sgnd ) { val = encode_twos_comp ( val , prec ) ;
SPL_METHOD ( SplFileObject , key ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
if ( scale == ( Quantum * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; range = GetQuantumRange ( depth ) ; <START_VULN> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) <END_VULN> scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression )
} <START_VULN> if ( dataSize > MAX_DLS_WAVE_SIZE ) <END_VULN> { return EAS_ERROR_SOUND_LIBRARY ; }
png_fixed_error ( png_ptr , text ) ; # ifndef PNG_ERROR_TEXT_SUPPORTED <START_VULN> PNG_UNUSED ( text ) <END_VULN> # endif return ( png_fixed_point ) r ;
if ( * endptr | | umask_long < 0 | | umask_long & ~ 0777L ) { fprintf ( stderr , "Invalid -- umask option % s" , optarg ) ; <START_VULN> return ; <END_VULN> } umask_val = umask_long & 0777 ;
{ spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ; spl_filesystem_object * object = spl_filesystem_iterator_to_object ( iterator ) ; <START_VULN> <END_VULN> object -> u . dir . index = 0 ; if ( object -> u . dir . dirp ) { php_stream_rewinddir ( object -> u . dir . dirp ) ;
if ( ! smatch ( location , "stdout" ) && ! smatch ( location , "stderr" ) ) { location = httpMakePath ( route , 0 , location ) ; } <START_VULN> if ( ( levels = mprGetJsonObj ( prop , "levels" ) ) != 0 ) { <END_VULN> for ( ITERATE_CONFIG ( route , prop , child , ji ) ) { httpSetTraceEventLevel ( route -> trace , child -> name , ( int ) stoi ( child -> value ) ) ; }
} <START_VULN> strcpy ( tmpf , argv [ c ] ) ; <END_VULN> } else
PHP_FUNCTION ( mcrypt_module_get_algo_key_size ) { MCRYPT_GET_MODE_DIR_ARGS ( algorithms_dir ) ; <START_VULN> <END_VULN> RETURN_LONG ( mcrypt_module_get_algo_key_size ( module , dir ) ) ; }
{ const struct mp_capable * mpc = ( const struct mp_capable * ) opt ; <START_VULN> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <END_VULN> ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ;
#ifndef WOFF_H_ #define WOFF_H_ #ifdef _MSC_VER <START_VULN> typedef char int8_t ; <END_VULN> typedef short int16_t ; typedef int int32_t ; typedef unsigned char uint8_t ; typedef unsigned short uint16_t ; typedef unsigned int uint32_t ; typedef unsigned __int64 uint64_t ; #else #include < inttypes . h>
if ( row ) { gdFree ( row ) ; } <START_VULN> return ; <END_VULN> } cinfo . err -> error_exit = fatal_jpeg_error ;
IPV6_SET_L4PROTO ( p , nh ) ; hdrextlen = sizeof ( IPV6EspHdr ) ; if ( hdrextlen > plen ) { <START_VULN> ENGINE_SET_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <END_VULN> SCReturn ; }
<START_VULN> extern const char kIncognitoSwitch [ ] ; <END_VULN>
else { <START_VULN> if ( png_ptr -> flags & PNG_FLAG_CRC_CRITICAL_IGNORE ) <END_VULN> need_crc = 0 ; }
if ( ( c = strrchr ( name , ' . ' ) ) ) * c = '0' ; <START_VULN> dname = malloc ( strlen ( name ) + 16 ) ; <END_VULN> sprintf ( dname , " % s - versions" , name ) ; if ( ! ( dir = opendir ( dname ) ) ) mkdir ( dname , S_IRWXU ) ;
#include < CoreFoundationCoreFoundation . h> <START_VULN> #include "basecallback . h"<END_VULN> #include "basemacscoped_cftyperef . h" #include "basememoryscoped_ptr . h" #include "uigfxrect . h"
<START_VULN> if ( allowed ) <END_VULN> png_ptr -> flags |= PNG_FLAG_BENIGN_ERRORS_WARN | PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN ;
bool mListenerEnabled ; bool mReturnInEmptyLIKillsList ; bool mDidDeleteSelection ; bool mDidRangedDelete ; bool mRestoreContentEditableCount ; nsRefPtr < nsRange> mUtilRange ; PRUint32 mJoinOffset ; nsCOMPtr < nsIDOMNode> mNewBlock ; <START_VULN> nsRangeStore mRangeItem ; <END_VULN> StyleCache mCachedStyles [ SIZE_STYLE_TABLE ] ; } ; #endif
class CORE_EXPORT Microtask { public : <START_VULN> static void performCheckpoint ( ) ; <END_VULN> static bool performingCheckpoint ( v8 : : Isolate * ) ;
if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <START_VULN> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <END_VULN> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ;
private : nsGfxScrollFrameInner * mInner ; } ; void FinishReflowForScrollbar ( nsIContent * aContent , nscoord aMinXY , nscoord aMaxXY , nscoord aCurPosXY , nscoord aPageIncrement , nscoord aIncrement ) ; <START_VULN> static void SetScrollbarEnabled ( nsIContent * aContent , nscoord aMaxPos ) ; <END_VULN> void SetCoordAttribute ( nsIContent * aContent , nsIAtom * aAtom , nscoord aSize ) ; nscoord GetCoordAttribute ( nsIFrame * aFrame , nsIAtom * aAtom , nscoord aDefaultValue , nscoord * aRangeStart , nscoord * aRangeLength ) ; void UpdateScrollbarPosition ( ) ; nsRect GetScrollPortRect ( ) const { return mScrollPort ; }
fsize += pkt -> data . frame . sz ; if ( ! ( pkt -> data . frame . flags & VPX_FRAME_IS_FRAGMENT ) ) { <START_VULN> off_t currpos = ftello ( stream -> file ) ; <END_VULN> fseeko ( stream -> file , ivf_header_pos , SEEK_SET ) ; ivf_write_frame_size ( stream -> file , fsize ) ; fseeko ( stream -> file , currpos , SEEK_SET ) ;
png_color_16p trans_color ; if ( png_get_tRNS ( read_ptr , read_info_ptr , & trans_alpha , & num_trans , <START_VULN> & trans_color ) ) <END_VULN> { int sample_max = ( 1 << bit_depth ) ;
} <START_VULN> #line 111 "hex_grammar . c"<END_VULN> # ifndef YY_NULLPTR # if defined __cplusplus && 201103L <= __cplusplus
void png_app_warning ( png_const_structrp png_ptr , png_const_charp error_message ) { <START_VULN> if ( png_ptr -> flags & PNG_FLAG_APP_WARNINGS_WARN ) <END_VULN> png_warning ( png_ptr , error_message ) ; else png_error ( png_ptr , error_message ) ;
xd -> dst . y_stride , xd -> predictor , 16 ) ; <START_VULN> distortion = vp8_variance16x16<END_VULN> ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ; rate = x -> mbmode_cost [ xd -> frame_type ] [ mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ;
break ; } <START_VULN> if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) { <END_VULN> ND_PRINT ( ( ndo , " % s" , tstr ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; return ;
loopIndexVar ; if ( indexValue ) { assert ( ! jsvIsName ( indexValue ) && jsvGetRefs ( indexValue ) == 0 ) ; <START_VULN> jsvSetValueOfName ( forStatement , indexValue ) ; <END_VULN> if ( indexValue != loopIndexVar ) jsvUnLock ( indexValue ) ; jsvIteratorNext ( & it ) ;
<START_VULN> static int __perf_event_overflow ( struct perf_event * event , int nmi , <END_VULN> int throttle , struct perf_sample_data * data , struct pt_regs * regs ) {
protected : nsIntSize mLastSize ; nsIntPoint mLastPoint ; HWND mWnd ; WNDPROC mPrevWndProc ; HBRUSH mBrush ; PRPackedBool mIsTopWidgetWindow ; PRPackedBool mHas3DBorder ; <START_VULN> PRPackedBool mIsDestroying ; <END_VULN> PRPackedBool mIsVisible ; PRPackedBool mIsInMouseCapture ; PRPackedBool mInWheelProcessing ; PRPackedBool mUnicodeWidget ; PRPackedBool mIsPluginWindow ; PRPackedBool mPainting ; char mLeadByte ; PRUint32 mBlurSuppressLevel ;
int mif_validate ( jas_stream_t * in ) { <START_VULN> uchar buf [ MIF_MAGICLEN ] ; <END_VULN> uint_fast32_t magic ; int i ; int n ;
while ( filt_val > = min_filter_level ) { <START_VULN> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <END_VULN> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ;
zval * z_still_running ; php_curlm * mh ; int still_running ; <START_VULN> int result ; <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , "rz" , & z_mh , & z_still_running ) == FAILURE ) { return ;
DEBUG ( "success" ) ; <START_VULN> usleep ( 250000 ) ; <END_VULN> return 0 ; err_open :
#include "vp9commonvp9_onyxc_int . h" #include "vp9commonvp9_seg_common . h" <START_VULN> const vp9_prob vp9_kf_y_mode_prob [ INTRA_MODES ] [ INTRA_MODES ] [ INTRA_MODES - 1 ] = { <END_VULN> { { 137 , 30 , 42 , 148 , 151 , 207 , 70 , 52 , 91 } , { 92 , 45 , 102 , 136 , 116 , 180 , 74 , 90 , 100 } ,
} <START_VULN> CWD_API void realpath_cache_del ( const char * path , int path_len ) <END_VULN> { zend_ulong key = realpath_cache_key ( path , path_len ) ; zend_ulong n = key % ( sizeof ( CWDG ( realpath_cache ) ) sizeof ( CWDG ( realpath_cache ) [ 0 ] ) ) ;
{ unsigned int back_alpha ; <START_VULN> if ( output_format & PNG_FORMAT_FLAG_ALPHA ) <END_VULN> back_alpha = 0 ; else
<START_VULN> #define VPX_CODEC_ABI_VERSION ( 2 + VPX_IMAGE_ABI_VERSION ) <END_VULN> typedef enum {
if ( scontains ( value , " = " ) ) { for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { <START_VULN> option = stok ( option , " = , " , & ovalue ) ; <END_VULN> ovalue = strim ( ovalue , ""'" , MPR_TRIM_BOTH ) ; if ( smatch ( option , "methods" ) ) { methods = ovalue ;
} LOG_ERROR ( " % s restarting the bluetooth process . " , __func__ ) ; <START_VULN> usleep ( 10000 ) ; <END_VULN> kill ( getpid ( ) , SIGKILL ) ; }
MprJson * result ; if ( key && ! strpbrk ( key , " . [ ] * " ) ) { <START_VULN> return mprLookupJsonObj ( obj , key ) ; <END_VULN> } if ( ( result = mprQueryJson ( obj , key , 0 , 0 ) ) != 0 && result -> children ) { return result -> children ;
for ( i = 0 ; i < sBlk . s . fragments ; i ++ ) SQUASHFS_INSWAP_FRAGMENT_ENTRY ( & fragment_table [ i ] ) ; <START_VULN> * directory_table_end = fragment_table_index [ 0 ] ; <END_VULN> return TRUE ; }
<START_VULN> class SharedMemory { <END_VULN> public : SharedMemory ( ) ;
default : err = 1 ; } <START_VULN> if ( err ) <END_VULN> png_error ( png_ptr , "Bad IO state or buffer size" ) ; } #endif
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : random psychoacoustics ( not including preecho ) <START_VULN> last mod : $ Id : psy . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_PSY_H_ #define _V_PSY_H_ #include "smallft . h" #include "backends . h"
return 1 ; } <START_VULN> #line 1285 "extstandardvar_unserializer . c"<END_VULN> yy95 : yych = * ++ YYCURSOR ; if ( yych <= ' , ' ) {
static void process_add_smartcard_key ( SocketEntry * e ) { <START_VULN> char * provider = NULL , * pin ; <END_VULN> int r , i , version , count = 0 , success = 0 , confirm = 0 ; u_int seconds ; time_t death = 0 ;
ALLOC_ZVAL ( result_set ) ; array_init ( result_set ) ; INIT_PZVAL ( result_set ) ; <START_VULN> <END_VULN> for ( i = 0 ; i < count ; i ++ ) { if ( offset_capture ) {
int drop_mark = ( int ) ( oxcf -> drop_frames_water_mark * <START_VULN> oxcf -> optimal_buffer_level 100 ) ; <END_VULN> if ( ( rc -> buffer_level > drop_mark ) && ( rc -> decimation_factor > 0 ) ) { -- rc -> decimation_factor ;
d [ i ] = p_src [ i ] ; for ( col = 0 ; col < cols ; col ++ ) { <START_VULN> int kernel = 4 ; <END_VULN> v = p_src [ col ] ; d [ col & 7 ] = v ;
void PageImportanceSignalsChanged ( ) override ; void DidAutoResize ( const blink : : WebSize & newSize ) override ; blink : : WebRect RootWindowRect ( ) override ; <START_VULN> void DidFocus ( ) override ; <END_VULN> #if defined ( OS_ANDROID )
#include < memory> <START_VULN> #include "basemove . h"<END_VULN> #include "dbusdbus_export . h" namespace dbus {
! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) return TEE_ERROR_ACCESS_DENIED ; <START_VULN> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <END_VULN> uint32_t attr ; TEE_Result res ;
if ( * p != xdr_zero ) <START_VULN> * reply = ( struct rpcrdma_write_array * ) p ; <END_VULN> else * reply = NULL ; }
} } <START_VULN> if ( ! ( png_ptr -> color_type & PNG_COLOR_MASK_COLOR ) ) <END_VULN> { png_warning ( png_ptr , "Ignoring request to write a PLTE chunk in grayscale PNG" ) ;
} offsets = ( int * ) safe_emalloc ( size_offsets , sizeof ( int ) , 0 ) ; <START_VULN> <END_VULN> alloc_len = 2 * subject_len + 1 ; result = safe_emalloc ( alloc_len , sizeof ( char ) , 0 ) ;
memcpy ( png_ptr -> prev_row , png_ptr -> row_buf , row_info . rowbytes + 1 ) ; #ifdef PNG_MNG_FEATURES_SUPPORTED <START_VULN> if ( ( png_ptr -> mng_features_permitted & PNG_FLAG_MNG_FILTER_64 ) && <END_VULN> ( png_ptr -> filter_type == PNG_INTRAPIXEL_DIFFERENCING ) ) {
Token currentToken ; unsigned lookahead ; Token lookaheadTokens [ maxLookahead ] ; } ; void advance ( size_t position ) ; void tell ( Position * ) ; void seek ( const Position & pos ) ; <START_VULN> void seek ( const Position & pos , const TokenStream & other ) ; <END_VULN> size_t positionToOffset ( const Position & pos ) const { return pos . buf - userbuf . base ( ) ; } const jschar * rawBase ( ) const { return userbuf . base ( ) ; }
case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS : <START_VULN> isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ; <END_VULN> break ; case NLPID_SNAP :
break ; case EFFECT_CMD_DISABLE : <START_VULN> if ( pReplyData == NULL | | * replySize != sizeof ( int ) ) { <END_VULN> return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_ACTIVE ) {
{ MsgToEventLog ( M_SYSERR , TEXT ( "malformed startup data : 1 byte received" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <START_VULN> goto out ; <END_VULN> } data = malloc ( bytes ) ;
NULL , #endif global_data -> instance_name ) ; <START_VULN> fp = fopen ( file_name , "a" ) ; <END_VULN> FREE ( file_name ) ; set_time_now ( ) ;
} p += tag_len ; <START_VULN> left -= ( p - gdo ) ; <END_VULN> } if ( ! iccsn_found && iccsn_len )
return 1 ; } <START_VULN> #line 1268 "extstandardvar_unserializer . c"<END_VULN> yy95 : yych = * ++ YYCURSOR ; if ( yych <= ' , ' ) {
* <START_VULN> void impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) <END_VULN> { stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_mb_addr_incr ;
if ( all_in ) { unsigned int sad_array [ 4 ] ; <START_VULN> for ( j = 0 ; j < x -> searches_per_step ; j += 4 ) { <END_VULN> unsigned char const * block_offset [ 4 ] ; for ( t = 0 ; t < 4 ; t ++ )
setup_ret = 6 ; goto _XMI_Next_Event ; } <START_VULN> if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) { <END_VULN> goto _xmi_end ; }
number_planes , number_planes_filled , one , <START_VULN> offset , <END_VULN> pixel_info_length ; ssize_t count , y ; unsigned char
if ( exception -> severity != UndefinedException ) goto FINISH_UNL ; if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ; <START_VULN> ( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <END_VULN>
return ( in_cksum ( vec , 2 ) ) ; } <START_VULN> static void<END_VULN> ip_printts ( netdissect_options * ndo , register const u_char * cp , u_int length ) {
@param . . . Other paths to join to the base path . List of other paths must be NULL terminated . @returns Allocated string containing the resolved path . @ingroup MprPath <START_VULN> @stability Evolving<END_VULN> PUBLIC char * mprJoinPaths ( cchar * base , . . . ) ;
} if ( ! silent ) <START_VULN> printf ( "gamma % f : maximum 16 bit error % f" , g , maxerr ) ; <END_VULN> } return 0 ;
} snprintf ( log_name , log_name_len , "tmp % s_mem . % d . log" , prog_name , getpid ( ) ) ; <START_VULN> log_op = fopen ( log_name , "a" ) ; <END_VULN> if ( log_op == NULL ) { log_message ( LOG_INFO , "Unable to open % s for appending" , log_name ) ; log_op = stderr ;
{ if ( row_info -> bit_depth == 8 ) { <START_VULN> if ( at_start ) <END_VULN> ++ sp ; else sp += 4 , dp += 3 ;
Value * array = reinterpret_cast < Value * > ( self ) ; blink : : HeapObjectHeader * header = blink : : HeapObjectHeader : : fromPayload ( self ) ; <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <END_VULN> size_t length = header -> payloadSize ( ) sizeof ( Value ) ;
ind = 2 ; <START_VULN> while ( ibuf [ ind ] == 0x01 ) { <END_VULN> if ( ibuf [ ind + 1 ] == 0xFE ) { gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; sc_log ( card -> ctx , "Key container % d is allocated and uses key_ref % d" ,
while ( c < col_max ) { <START_VULN> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <END_VULN> if ( thissad < bestsad ) {
perf_sample_data_init ( & data , addr ) ; <START_VULN> do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , nmi , & data , regs ) ; <END_VULN> perf_swevent_put_recursion_context ( rctx ) ; preempt_enable_notrace ( ) ;
#include "basemacros . h" #include "mojopubliccppbindingsassociated_binding . h" <START_VULN> #include "third_partyblinkpublicmojomdevtoolsdevtools_frontend . mojom - blink . h"<END_VULN> #include "third_partyblinkrenderercoreinspectorinspector_frontend_client . h" #include "third_partyblinkrendererplatformheaphandle . h" #include "third_partyblinkrendererplatformsupplementable . h"
<START_VULN> struct control * control = png_voidcast ( struct control * , <END_VULN> png_get_error_ptr ( png_ptr ) ) ; return & control -> file ; }
rc = 0 ; if ( formData ) { for ( rc = next = 0 ; rc > = 0 && ( pair = mprGetNextItem ( formData , & next ) ) != 0 ; ) { <START_VULN> key = stok ( sclone ( pair ) , " = " , & value ) ; <END_VULN> rc += httpWrite ( conn -> writeq , " % srContent - Disposition : form - data ; name = " % s" ; r" , conn -> boundary , key ) ; rc += httpWrite ( conn -> writeq , "Content - Type : applicationx - www - form - urlencodedrr % sr" , value ) ; }
else running_avg_y [ c ] = sig [ c ] - adjustment ; <START_VULN> sum_diff -= adjustment ; <END_VULN> } } }
transmit_response_with_date ( p , "200 OK" , req ) ; manager_event ( EVENT_FLAG_SYSTEM , "PeerStatus" , "ChannelType : SIPrPeer : SIP % srPeerStatus : RegisteredrAddress : % sr" , peer -> name , ast_sockaddr_stringify ( addr ) ) ; peer -> lastmsgssent = - 1 ; res = 0 ; break ; } ao2_unlock ( peer ) ; } } <START_VULN> if ( ! peer && sip_cfg . alwaysauthreject ) { <END_VULN> transmit_response ( p , "100 Trying" , req ) ; sched_yield ( ) ; } if ( ! res ) { ast_devstate_changed ( AST_DEVICE_UNKNOWN , "SIP % s" , peer -> name ) ; } if ( res < 0 ) { switch ( res ) {
qsort ( sortpointer , n , sizeof ( * sortpointer ) , icomp ) ; for ( i = 0 ; i < n ; i ++ ) look -> forward_index [ i ] = sortpointer [ i ] - info -> postlist ; for ( i = 0 ; i < n ; i ++ ) look -> reverse_index [ look -> forward_index [ i ] ] = i ; for ( i = 0 ; i < n ; i ++ ) look -> sorted_index [ i ] = info -> postlist [ look -> forward_index [ i ] ] ; <START_VULN> <END_VULN> switch ( info -> mult ) { case 1 : look -> quant_q = 256 ; break ; case 2 : look -> quant_q = 128 ; break ;
conn -> current_result = NULL ; } while ( 0 ) ; <START_VULN> conn -> m -> local_tx_end ( conn , this_func , result == NULL ? FAIL : PASS TSRMLS_CC ) ; <END_VULN> } DBG_RETURN ( result ) ;
#ifdef UNUSED <START_VULN> #elif __GNUC__<END_VULN> #define UNUSED __attribute__ ( ( unused ) ) #else #define UNUSED
goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <START_VULN> if ( p + l > buf + n ) { <END_VULN> syslog ( LOG_WARNING , "bad request ( length encoding ) " ) ; goto error ; }
( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { ext4_msg ( sb , KERN_ERR , "Journal does not support " "requested data journaling mode" ) ; <START_VULN> goto failed_mount4 ; <END_VULN> } default : break ;
* <START_VULN> void impeg2d_dec_p_mb_params ( dec_state_t * ps_dec ) <END_VULN> { stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_mb_addr_incr ;
tptr = tmpbuf ; for ( bit = 0 , byte = 0 ; bit < ( unsigned char ) MagickMin ( 8 , ( ssize_t ) bytes_per_row - x ) ; bit ++ ) { <START_VULN> if ( ( y == 0 ) | | ( lastrow [ x + bit ] != one_row [ x + bit ] ) ) <END_VULN> { byte |= ( 1 << ( 7 - bit ) ) ; * tptr ++ = ( char ) one_row [ x + bit ] ;
MprJson * result ; if ( key && ! strpbrk ( key , " . [ ] * " ) ) { <START_VULN> return mprLookupJson ( obj , key ) ; <END_VULN> } if ( ( result = mprQueryJson ( obj , key , 0 , 0 ) ) != 0 ) { if ( result -> length == 1 && result -> children -> type & MPR_JSON_VALUE ) {
extern const char kEnablePageVisibility [ ] ; extern const char kUseInProcCommandBuffer [ ] ; <START_VULN> extern const char kWebViewSanboxedRenderer [ ] ; <END_VULN> }
if ( row ) { gdFree ( row ) ; } <START_VULN> return ; <END_VULN> } cinfo . err -> emit_message = jpeg_emit_message ;
#ifdef PNG_TEXT_SUPPORTED static void <START_VULN> pngtest_check_text_support ( png_const_structp png_ptr , png_textp text_ptr , <END_VULN> int num_text ) { while ( num_text > 0 )
~ DOMHandler ( ) override ; void Wire ( UberDispatcher * dispatcher ) override ; <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) override ; Response Disable ( ) override ;
#ifndef ChooserOnlyTemporalInputTypeView_h #define ChooserOnlyTemporalInputTypeView_h <START_VULN> #include "corehtmlformsBaseClickableWithKeyInputType . h"<END_VULN> #include "corehtmlformsBaseTemporalInputType . h" #include "corehtmlformsDateTimeChooser . h" #include "corehtmlformsDateTimeChooserClient . h" #include "platformheapHandle . h" namespace blink {
* -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <START_VULN> int Downmix_Reset ( downmix_object_t * pDownmixer , bool init ) { <END_VULN> return 0 ; }
pack_mb_row_tokens ( cpi , & cpi -> bc [ 1 ] ) ; else #endif <START_VULN> pack_tokens ( & cpi -> bc [ 1 ] , cpi -> tok , cpi -> tok_count ) ; <END_VULN> vp8_stop_encode ( & cpi -> bc [ 1 ] ) ;
static std : : vector < TargetHandler * > ForAgentHost ( DevToolsAgentHostImpl * host ) ; void Wire ( UberDispatcher * dispatcher ) override ; <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) override ; Response Disable ( ) override ;
exit ( 1 ) ; case 16 : <START_VULN> value = ( unsigned int ) floor ( 65535 * pow ( value65535 . , conv ) + . 5 ) ; <END_VULN> * row ++ = ( png_byte ) ( value >> 8 ) ; * row = ( png_byte ) value ; return ;
int result = 0 ; char sig_on = btif_hl_signal_select_exit ; BTIF_TRACE_DEBUG ( "btif_hl_signal_select_exit" ) ; <START_VULN> result = send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <END_VULN> if ( btif_is_enabled ( ) ) {
case FILE_LELDATE : case FILE_MELDATE : if ( file_printf ( ms , F ( ms , m , " % s" ) , <START_VULN> file_fmttime ( p -> l , 0 , tbuf ) ) == - 1 ) <END_VULN> return - 1 ; t = ms -> offset + sizeof ( uint32_t ) ; break ;
uint32_t lineIndexToNum ( uint32_t lineIndex ) const { return lineIndex + initialLineNum_ ; } uint32_t lineNumToIndex ( uint32_t lineNum ) const { return lineNum - initialLineNum_ ; } public : SourceCoords ( ExclusiveContext * cx , uint32_t ln ) ; void add ( uint32_t lineNum , uint32_t lineStartOffset ) ; <START_VULN> void fill ( const SourceCoords & other ) ; <END_VULN> bool isOnThisLine ( uint32_t offset , uint32_t lineNum ) const { uint32_t lineIndex = lineNumToIndex ( lineNum ) ; JS_ASSERT ( lineIndex + 1 < lineStartOffsets_ . length ( ) ) ; return lineStartOffsets_ [ lineIndex ] <= offset && offset < lineStartOffsets_ [ lineIndex + 1 ] ; }
* s = '' ; } } <START_VULN> s [ 1 ] = '0' ; <END_VULN> if ( resource -> path && * ( resource -> path ) == '' && * ( resource -> path + 1 ) == '0' ) { snprintf ( loc_path , sizeof ( loc_path ) - 1 , " % s % s" , resource -> path , location ) ; } else {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : code raw packets into framed OggSquish stream and decode Ogg streams back into raw packets <START_VULN> last mod : $ Id : framing . c 16051 2009 - 05 - 27 05 : 00 : 06Z xiphmont $ <END_VULN> note : The CRC code is directly derived from public domain code by Ross Williams ( ross@guest . adelaide . edu . au ) . See docsframing . html for details . #include < stdlib . h>
proto_tree * tree ) { char * mountpoint = NULL ; if ( ( ! pinfo -> fd -> flags . visited ) && nfs_file_name_snooping ) { rpc_call_info_value * civ = pinfo -> private_data ; if ( civ -> request && ( civ -> proc == 1 ) ) { const gchar * host ; unsigned char * name ; <START_VULN> int len ; <END_VULN> unsigned char * ptr ; host = ip_to_str ( pinfo -> dst . data ) ; len = tvb_get_ntohl ( tvb , offset ) ; if ( len > = ITEM_LABEL_LENGTH ) THROW ( ReportedBoundsError ) ; name = g_malloc ( strlen ( host ) + 1 + len + 1 + 200 ) ; ptr = name ; memcpy ( ptr , host , strlen ( host ) ) ;
<START_VULN> if ( transforms & PNG_TRANSFORM_INVERT_MONO ) <END_VULN> #ifdef PNG_WRITE_INVERT_SUPPORTED png_set_invert_mono ( png_ptr ) ; #else
<START_VULN> if ( ctx -> max_sz == 1 && active_map && ! flags ) { <END_VULN> for ( row = 0 ; row < mb_rows ; ++ row ) { col = 0 ;
{ struct xfrm_algo * algo ; struct nlattr * nla ; nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) 8 ) ; if ( ! nla ) return - EMSGSIZE ; algo = nla_data ( nla ) ; <START_VULN> strcpy ( algo -> alg_name , auth -> alg_name ) ; <END_VULN> memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) 8 ) ; algo -> alg_key_len = auth -> alg_key_len ; return 0 ; }
return ; fprintf ( stderr , "Stream % d PSNR ( OverallAvgYUV ) " , stream -> index ) ; <START_VULN> ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , 255 . 0 , <END_VULN> ( double ) stream -> psnr_sse_total ) ; fprintf ( stderr , " % . 3f" , ovpsnr ) ;
#include < utility> #include < vector> <START_VULN> #include "basemove . h"<END_VULN> #include "mojopubliccppbindingslibarray_internal . h" #include "mojopubliccppbindingslibbindings_internal . h" #include "mojopubliccppbindingslibtemplate_util . h"
msg . msg_iovlen = 1 ; do { <START_VULN> ret = sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ; <END_VULN> } while ( ret < 0 && errno == EINTR ) ; if ( ret < 0 ) {
location &= ( PNG_HAVE_IHDR | PNG_HAVE_PLTE | PNG_AFTER_IDAT ) ; <START_VULN> if ( location == 0 && ! ( png_ptr -> mode & PNG_IS_READ_STRUCT ) ) <END_VULN> { png_app_warning ( png_ptr ,
fReserved = false ; } else { fAllocCount = SkTMax ( count , SkTMax ( kMinHeapAllocCount , reserveCount ) ) ; <START_VULN> fMemArray = sk_malloc_throw ( fAllocCount * sizeof ( T ) ) ; <END_VULN> fOwnMemory = true ; fReserved = reserveCount > 0 ; }
wp -> socket_uid = - 1 ; wp -> socket_gid = - 1 ; <START_VULN> wp -> socket_mode = 0666 ; <END_VULN> if ( ! c ) { return 0 ;
T * reset ( size_t count = 0 ) { sk_free ( fPtr ) ; <START_VULN> fPtr = count ? ( T * ) sk_malloc_flags ( count * sizeof ( T ) , SK_MALLOC_THROW ) : nullptr ; <END_VULN> return fPtr ; }
ifr . ifr_hwaddr . sa_data [ 0 ] &= ~ 0x01 ; } <START_VULN> err = ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ; <END_VULN> if ( err < 0 ) { BTIF_TRACE_ERROR ( "Could not set bt address for interface : % s , errno : % s" , devname , strerror ( errno ) ) ;
gfx : : Rect visible_rect ; protected : <START_VULN> friend class base : : RefCounted < VP9Picture> ; <END_VULN> virtual ~ VP9Picture ( ) ; DISALLOW_COPY_AND_ASSIGN ( VP9Picture ) ;
return ; } } <START_VULN> #endif<END_VULN> for ( ; ; )
static void set_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { unsigned int i ; <START_VULN> vpx_active_map_t map = { 0 } ; <END_VULN> map . rows = ( cfg -> g_h + 15 ) 16 ; map . cols = ( cfg -> g_w + 15 ) 16 ;
~ BrowserDevToolsAgentHost ( ) override ; <START_VULN> void AttachSession ( DevToolsSession * session ) override ; <END_VULN> void DetachSession ( DevToolsSession * session ) override ; void DispatchProtocolMessage ( DevToolsSession * session , const std : : string & message ) override ;
kf_group_coded_err += this_frame -> coded_error ; <START_VULN> vpx_memcpy ( & last_frame , this_frame , sizeof ( * this_frame ) ) ; <END_VULN> input_stats ( cpi , this_frame ) ;
AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; const uint8_t * buf_end = buf + buf_size ; MadContext * s = avctx -> priv_data ; int width , height ; int chunk_type ; int inter ; <START_VULN> if ( buf_size < 17 ) { <END_VULN> av_log ( avctx , AV_LOG_ERROR , "Input buffer too small" ) ; * data_size = 0 ; return - 1 ; } chunk_type = AV_RL32 ( & buf [ 0 ] ) ; inter = ( chunk_type == MADm_TAG | | chunk_type == MADe_TAG ) ; buf += 8 ; av_reduce ( & avctx -> time_base . num , & avctx -> time_base . den ,
zend_throw_exception_ex ( spl_ce_DomainException , 0 TSRMLS_CC , "Maximum line length must be greater than or equal zero" ) ; return ; } <START_VULN> <END_VULN> intern -> u . file . max_line_len = max_len ; }
char * delim = NULL , * enclo = NULL , * esc = NULL ; int d_len = 0 , e_len = 0 , esc_len = 0 , ret ; zval * fields = NULL ; <START_VULN> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "a | sss" , & fields , & delim , & d_len , & enclo , & e_len , & esc , & esc_len ) == SUCCESS ) { switch ( ZEND_NUM_ARGS ( ) ) {
#endif #endif <START_VULN> <END_VULN>
if ( errmsg != NULL ) png_chunk_benign_error ( png_ptr , errmsg ) ; } <START_VULN> #endif<END_VULN> #ifdef PNG_READ_sPLT_SUPPORTED void
run_test ( & test2 , test2_result ) ; fprintf ( stderr , "OKDequant test 3 . . . " ) ; run_test ( & test3 , test3_result ) ; fprintf ( stderr , "OKDequant test 4 . . . " ) ; run_test ( & test4 , test4_result ) ; fprintf ( stderr , "OKDequant test 5 . . . " ) ; run_test ( & test5 , test5_result ) ; fprintf ( stderr , "OK" ) ; <START_VULN> <END_VULN> return ( 0 ) ; } #endif
status_t resetPlugin ( ) ; status_t reInitDecoder ( ) ; <START_VULN> void setDecodeArgs ( <END_VULN> ivd_video_decode_ip_t * ps_dec_ip , ivd_video_decode_op_t * ps_dec_op , OMX_BUFFERHEADERTYPE * inHeader ,
virtual ~ NavigatorServiceWorker ( ) ; <START_VULN> static ServiceWorkerContainer * serviceWorker ( Navigator & , ExceptionState & ) ; <END_VULN> DECLARE_VIRTUAL_TRACE ( ) ;
<START_VULN> static bool neuterViews ( JSContext * cx , Handle < ArrayBufferObject * > buffer ) ; <END_VULN> uint8_t * dataPointer ( ) const ;
{ png_uint_32 ig = ( j << ( 8 - shift ) ) + i ; <START_VULN> if ( shift ) <END_VULN> ig = ( ig * 65535U + max_by_2 ) max ; sub_table [ j ] = ( png_uint_16 ) ig ;
int jas_iccprofdata_srgblen = sizeof ( jas_iccprofdata_srgb ) ; <START_VULN> uchar jas_iccprofdata_sgray [ ] = { <END_VULN> 0x00 , 0x00 , 0x01 , 0x8a , 0x00 , 0x00 , 0x00 , 0x00 , 0x02 , 0x20 , 0x00 , 0x00 , 0x73 , 0x63 , 0x6e , 0x72 , 0x47 , 0x52 , 0x41 , 0x59 , 0x58 , 0x59 , 0x5a , 0x20 ,
<START_VULN> #line 182 "hex_grammar . c"<END_VULN> #ifdef short # undef short
#ifndef NDEBUG <START_VULN> class NonThreadSafe : public NonThreadSafeImpl { <END_VULN> } ; #else class NonThreadSafe : public NonThreadSafeDoNothing {
#include "baseoptional . h" #include "third_partyblinkrenderercorepaintobject_paint_properties . h" <START_VULN> #include "third_partyblinkrendererplatformgraphicspaintref_counted_property_tree_state . h"<END_VULN> namespace blink {
void * executableCopy ( ExecutablePool * allocator ) ; #ifndef NDEBUG <START_VULN> unsigned debugOffset ( ) { return m_formatter . debugOffset ( ) ; } <END_VULN> #endif
return mar_fpopen ( fp ) ; } #ifdef XP_WIN MarFile * mar_wopen ( const wchar_t * path ) { FILE * fp ; <START_VULN> fp = _wfopen ( path , L"rb" ) ; <END_VULN> if ( ! fp ) return NULL ; return mar_fpopen ( fp ) ; } #endif void mar_close ( MarFile * mar ) {
float * ath ; long * octave ; long * bark ; long firstoc ; long shiftoc ; int eighth_octave_lines ; <START_VULN> int total_octave_lines ; <END_VULN> long rate ; float m_val ; } vorbis_look_psy ; extern void _vp_psy_init ( vorbis_look_psy * p , vorbis_info_psy * vi , vorbis_info_psy_global * gi , int n , long rate ) ;
#define MODULE_MAGIC_COOKIE 0x41503235UL #ifndef MODULE_MAGIC_NUMBER_MAJOR #define MODULE_MAGIC_NUMBER_MAJOR 20150222 #endif <START_VULN> #define MODULE_MAGIC_NUMBER_MINOR 2<END_VULN>
if ( PASS == ( ret = PACKET_READ ( stats_header , conn ) ) ) { <START_VULN> * message = estrndup ( stats_header -> message , stats_header -> message_len ) ; <END_VULN> * message_len = stats_header -> message_len ; DBG_INF ( * message ) ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic codebook packunpackcodedecode operations <START_VULN> last mod : $ Id : codebook . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h> #include < string . h> #include < math . h> #include < oggogg . h> #include "vorbiscodec . h"
void FreeResources ( ) override ; void CreateSensorInternal ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> const CreateSensorCallback & callback ) override ; private :
IPC : : Message * reply_msg ) ; <START_VULN> void OnCheckForCancel ( const std : : string & preview_ui_addr , <END_VULN> int preview_request_id , bool * cancel ) ;
} if ( discover ) { <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <END_VULN> fprintf ( stdout , "BT adapter is up" ) ; fprintf ( stdout , "Starting to start discovery" ) ;
png_fixed_point result ; if ( ppm <= PNG_UINT_31_MAX && png_muldiv ( & result , ( png_int_32 ) ppm , 127 , <START_VULN> 5000 ) ) <END_VULN> return result ;
const char * vpx_svc_dump_statistics ( SvcContext * svc_ctx ) { <START_VULN> int number_of_frames , number_of_keyframes , encode_frame_count ; <END_VULN> int i , j ; uint32_t bytes_total = 0 ; double scale [ COMPONENTS ] ;
SPL_METHOD ( DirectoryIterator , valid ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
int max_key_size , key_size , iv_size ; php_mcrypt * pm ; int result = 0 ; <START_VULN> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "rss" , & mcryptind , & key , & key_len , & iv , & iv_len ) == FAILURE ) { return ; }
xmlCharEncoding enc ) { xmlParserInputBufferPtr ret ; <START_VULN> if ( size <= 0 ) return ( NULL ) ; <END_VULN> if ( mem == NULL ) return ( NULL ) ; ret = ( xmlParserInputBufferPtr ) xmlMalloc ( sizeof ( xmlParserInputBuffer ) ) ;
lfm -> int_4x4_y &= mask_y ; lfm -> int_4x4_uv &= mask_uv ; <START_VULN> <END_VULN> if ( rows == 1 ) { lfm -> above_uv [ TX_8X8 ] |= lfm -> above_uv [ TX_16X16 ] ;
{ png_color_8p sig_bit ; <START_VULN> if ( png_get_sBIT ( read_ptr , read_info_ptr , & sig_bit ) ) <END_VULN> png_set_sBIT ( write_ptr , write_info_ptr , sig_bit ) ; } #endif
bool GetHitRegionRect ( Element * aElement , nsRect & aRect ) ; protected : nsresult GetImageDataArray ( JSContext * aCx , int32_t aX , int32_t aY , uint32_t aWidth , uint32_t aHeight , JSObject ** aRetval ) ; nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <START_VULN> unsigned char * aData , uint32_t aDataLen , <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , int32_t dirtyWidth , int32_t dirtyHeight ) ; nsresult Initialize ( int32_t width , int32_t height ) ;
tmp = end ; <START_VULN> error = prctl_update_vma_anon_name ( vma , & prev , start , end , <END_VULN> ( const char __user * ) arg ) ; if ( error ) return error ;
ShelfContainerView * shelf_container_view_ = nullptr ; <START_VULN> int space_for_icons_ = 0 ; <END_VULN> ShelfView * shelf_view_ = nullptr ;
if ( ! strncmp ( prop_chunk , "SND " , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels = 0 , chansSpecified , chanMask = 0 ; <START_VULN> uint32_t sampleRate ; <END_VULN> while ( eptr - cptr > = sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ;
int syscall_nr ; syscall_nr = trace_get_syscall_nr ( current , regs ) ; <START_VULN> if ( syscall_nr < 0 ) <END_VULN> return ;
png_warning ( png_ptr , msg ) ; } } <START_VULN> #endif<END_VULN> #ifdef PNG_READ_SUPPORTED #ifdef PNG_BENIGN_ERRORS_SUPPORTED
static void setAppDefaults ( ) { <START_VULN> app -> company = stok ( slower ( ME_COMPANY ) , " " , NULL ) ; <END_VULN> app -> serviceProgram = sclone ( SERVICE_PROGRAM ) ; app -> serviceName = sclone ( SERVICE_NAME ) ; app -> serviceHome = mprGetNativePath ( SERVICE_HOME ) ;
virtual bool UndoScope ( ) MOZ_OVERRIDE ; virtual void SetUndoScope ( bool aUndoScope , mozilla : : ErrorResult & aError ) MOZ_OVERRIDE ; nsresult ClearDataset ( ) ; <START_VULN> nsSize GetWidthHeightForImage ( imgIRequest * aImageRequest ) ; <END_VULN> NS_FORWARD_NSIDOMNODE_TO_NSINODE NS_FORWARD_NSIDOMELEMENT_TO_GENERIC NS_IMETHOD GetId ( nsAString & aId ) MOZ_FINAL { mozilla : : dom : : Element : : GetId ( aId ) ;
RETVAL_BOOL ( phar_open_from_filename ( fname , fname_len , alias , alias_len , REPORT_ERRORS , NULL , & error TSRMLS_CC ) == SUCCESS ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } }
ND_PRINT ( ( ndo , " ( length bogus , should be = 4 ) " ) ) ; return 0 ; } <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <END_VULN> ND_PRINT ( ( ndo , " : 0x % 04x" , EXTRACT_16BITS ( p + 2 ) ) ) ; break ; case LCPOPT_CBACK :
GetNextToken ( q , & q , extent , token ) ; weight = ParseCommandOption ( MagickWeightOptions , MagickFalse , token ) ; if ( weight == - 1 ) <START_VULN> weight = StringToUnsignedLong ( token ) ; <END_VULN> graphic_context [ n ] -> weight = ( size_t ) weight ; break ; }
{ double gamma ; <START_VULN> if ( png_get_gAMA ( read_ptr , read_info_ptr , & gamma ) ) <END_VULN> png_set_gAMA ( write_ptr , write_info_ptr , gamma ) ; } #endif
const_iterator default_match ( ) const { return default_match_ ; } <START_VULN> GURL alternate_nav_url ( ) const { return alternate_nav_url_ ; } <END_VULN> void Reset ( ) ;
struct TypedArrayObjectStorage : AllTypedArraysBase { protected : JSObject * mObj ; <START_VULN> TypedArrayObjectStorage ( ) <END_VULN> { } public : inline void TraceSelf ( JSTracer * trc ) { if ( mObj ) { JS_CallObjectTracer ( trc , & mObj , "TypedArray . mObj" ) ;
#elif SHRT_MIN == - 32768 && SHRT_MAX == 32767 typedef short png_int_16 ; #else <START_VULN> # error "libpng requires a signed 16 bit type"<END_VULN> #endif #if UINT_MAX == 65535
{ struct NntpServer * nserv = data ; struct NntpData * nntp_data = NULL ; <START_VULN> char group [ LONG_STRING ] ; <END_VULN> char desc [ HUGE_STRING ] = "" ; char mod ; anum_t first , last ;
void ScheduleServiceInitialization ( int64 delay_milliseconds ) ; <START_VULN> <END_VULN> void InitializeUserPolicy ( const std : : string & user_name ,
if ( tstate & TSTATE_PRIV ) die_if_kernel ( "lddfmna from kernel" , regs ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , sfar ) ; <END_VULN> if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ; if ( get_user ( insn , ( u32 __user * ) pc ) != - EFAULT ) {
<START_VULN> #define PNG_LIBPNG_VER 10252 <END_VULN> #ifndef PNG_VERSION_INFO_ONLY
for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { count [ i ] = 0 ; for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j ) <START_VULN> count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ; <END_VULN> c += ( count [ i ] > 0 ) ; } if ( c == 1 ) {
unsigned int oom_badness ( struct task_struct * p , struct mem_cgroup * mem , const nodemask_t * nodemask , unsigned long totalpages ) { <START_VULN> int points ; <END_VULN> if ( oom_unkillable_task ( p , mem , nodemask ) ) return 0 ;
fdbname , fmtId ( dbtablespace ) ) ; <START_VULN> appendPQExpBuffer ( buf , "connect % s" , fdbname ) ; <END_VULN> } if ( binary_upgrade )
if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) { free ( ext_fb_list -> ext_fb [ i ] . data ) ; <START_VULN> ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ; <END_VULN> if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ;
static v8 : : Handle < v8 : : Value> throwTypeError ( const char * = 0 ) ; <START_VULN> static v8 : : Handle < v8 : : Value> throwNotEnoughArgumentsError ( ) ; <END_VULN> v8 : : Local < v8 : : Context> context ( ) ; v8 : : Local < v8 : : Context> mainWorldContext ( ) ;
else { vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ; <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <END_VULN> } q += 16 ;
if ( png_muldiv ( & gtest , output_gamma , png_ptr -> colorspace . gamma , <START_VULN> PNG_FP_1 ) && ! png_gamma_significant ( gtest ) ) <END_VULN> do_local_background = 0 ; else if ( mode == PNG_ALPHA_STANDARD )
no_empty = flags & PREG_SPLIT_NO_EMPTY ; delim_capture = flags & PREG_SPLIT_DELIM_CAPTURE ; offset_capture = flags & PREG_SPLIT_OFFSET_CAPTURE ; <START_VULN> <END_VULN> if ( limit_val == 0 ) { limit_val = - 1 ; }
#else <START_VULN> static inline zend_ulong realpath_cache_key ( const char * path , int path_len ) <END_VULN> { register zend_ulong h ; const char * e = path + path_len ;
virtual ~ InputMethod ( ) { } <START_VULN> <END_VULN> virtual void SetDelegate ( internal : : InputMethodDelegate * delegate ) = 0 ;
text . lang = NULL ; text . lang_key = NULL ; <START_VULN> if ( png_set_text_2 ( png_ptr , info_ptr , & text , 1 ) ) <END_VULN> errmsg = "insufficient memory" ; }
zend_module_entry mcrypt_module_entry = { STANDARD_MODULE_HEADER , <START_VULN> "mcrypt" , <END_VULN> mcrypt_functions , PHP_MINIT ( mcrypt ) , PHP_MSHUTDOWN ( mcrypt ) , NULL , NULL ,
xtmp = sk_X509_pop ( ctx -> chain ) ; X509_free ( xtmp ) ; num -- ; <START_VULN> ctx -> last_untrusted -- ; <END_VULN> } retry = 1 ; break ; }
if ( hexadecimal && ( ** buf != '0' ) ) ( * buf ) ++ ; <START_VULN> <END_VULN> if ( ( hexadecimal && ! isxdigit ( ** buf ) ) | |
<START_VULN> TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , <END_VULN> TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) ;
static void <START_VULN> image_transform_ini_end ( PNG_CONST image_transform * this , <END_VULN> transform_display * that ) { UNUSED ( this )
<START_VULN> PNG_CONST double whiteY = e -> red . Y + e -> green . Y + e -> blue . Y ; <END_VULN> data . red_coefficient = e -> red . Y ; data . green_coefficient = e -> green . Y ;
ifr . ifr_flags |= IFF_UP ; ifr . ifr_flags |= IFF_MULTICAST ; <START_VULN> err = ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <END_VULN> if ( err < 0 ) {
#undef DEFINE_EMPTY_PROTOCOL <START_VULN> #endif<END_VULN>
int dst_pitch ) { <START_VULN> DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , FData2 , 16 * 16 ) ; <END_VULN> const short * HFilter , * VFilter ; HFilter = vp8_six_tap_mmx [ xoffset ] ; vp8_filter_block1d_h6_mmx ( src_ptr - ( 2 * src_pixels_per_line ) , FData2 , src_pixels_per_line , 1 , 9 , 8 , HFilter ) ;
int lines ; int compressed_lines ; int starting_line ; signed short line_packets ; int y_ptr ; int byte_run ; int pixel_skip ; int pixel_countdown ; unsigned char * pixels ; <START_VULN> int pixel_limit ; <END_VULN> s -> frame . reference = 1 ; s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ; if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "reget_buffer ( ) failed" ) ; return - 1 ; } pixels = s -> frame . data [ 0 ] ; pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] ;
goto err ; } <START_VULN> if ( cs > CQSPI_MAX_CHIPSELECT ) { <END_VULN> dev_err ( dev , "Chip select % d out of range . " , cs ) ; goto err ; }
com = & enc -> mrk -> parms . com ; com -> len = JAS_CAST ( uint_fast16_t , strlen ( buf ) ) ; com -> regid = JPC_COM_LATIN ; <START_VULN> if ( ! ( com -> data = JAS_CAST ( uchar * , jas_strdup ( buf ) ) ) ) { <END_VULN> abort ( ) ; } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) {
<START_VULN> #line 495 "extstandardvar_unserializer . c"<END_VULN> { YYCTYPE yych ; static const unsigned char yybm [ ] = {
type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <START_VULN> if ( p + l > buf + n ) { <END_VULN> syslog ( LOG_WARNING , "bad request ( length encoding l = % u n = % u ) " , l , ( unsigned ) n ) ; goto error ;
#if defined ( PNG_READ_USER_TRANSFORM_SUPPORTED ) && defined ( PNG_USER_TRANSFORM_PTR_SUPPORTED ) <START_VULN> if ( png_ptr -> transformations & PNG_USER_TRANSFORM ) <END_VULN> { int user_pixel_depth = png_ptr -> user_transform_depth * png_ptr -> user_transform_channels ;
<START_VULN> if ( transforms & PNG_TRANSFORM_STRIP_16 ) <END_VULN> #ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED png_set_strip_16 ( png_ptr ) ; #else
virtual void CreateSensorInternal ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> const CreateSensorCallback & callback ) = 0 ;
<START_VULN> void perf_event_enable ( struct perf_event * event ) <END_VULN> { struct perf_event_context * ctx = event -> ctx ; struct task_struct * task = ctx -> task ;
ufd . fd = fd ; ufd . events = POLLIN ; ufd . revents = 0 ; <START_VULN> if ( poll ( & ufd , 1 , 0 ) <= 0 | | IS_EXCEPTION ( ufd . revents ) ) <END_VULN> break ; }
count ++ ; } } loser : if ( nickname ) { PORT_Free ( nickname ) ; } <START_VULN> nickname = "" ; <END_VULN> done : if ( firstname ) { PORT_Free ( firstname ) ; } if ( org ) { PORT_Free ( org ) ; }
start_pos = cpi -> twopass . stats_in ; <START_VULN> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <END_VULN> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ;
continue ; } <START_VULN> if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) { <END_VULN> continue ; }
for ( ; ; ) { prepare_poll_fds ( h , pfds ) ; <START_VULN> int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ; <END_VULN> if ( ret == - 1 ) { APPL_TRACE_ERROR ( "poll ret - 1 , exit the thread , errno : % d , err : % s" , errno , strerror ( errno ) ) ;
#if ! defined ( LIBXML_STATIC ) #define XMLPUBVAR __declspec ( dllimport ) extern #else <START_VULN> #define XMLPUBVAR<END_VULN> #endif #endif #define XMLCALL __cdecl
} if ( zr_rsrc -> zf ) { <START_VULN> buffer = zend_string_alloc ( len , 0 ) ; <END_VULN> n = zip_fread ( zr_rsrc -> zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ; if ( n > 0 ) { ZSTR_VAL ( buffer ) [ n ] = '0' ;
public : bool init ( uint32_t id , uint32_t offset , uint32_t numSuccessors ) { id_ = id ; offset_ = offset ; numSuccessors_ = numSuccessors ; if ( numSuccessors ) { <START_VULN> successors_ = ( uint32_t * ) js_calloc ( numSuccessors * sizeof ( uint32_t ) ) ; <END_VULN> if ( ! successors_ ) return false ; } return true ; } void destroy ( ) { js_free ( successors_ ) ;
} <START_VULN> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <END_VULN> vp8_decode_mode_mvs ( pbi ) ;
#ifndef imgStatusTracker_h__ #define imgStatusTracker_h__ class imgDecoderObserver ; class imgIContainer ; <START_VULN> class imgRequestProxy ; <END_VULN> class imgStatusNotifyRunnable ; class imgRequestNotifyRunnable ; class imgStatusTrackerObserver ; class imgStatusTrackerNotifyingObserver ; class nsIRunnable ; #include "mozillaRefPtr . h" #include "mozillaWeakPtr . h" #include "nsCOMPtr . h" #include "nsTObserverArray . h" #include "nsThreadUtils . h" #include "nsRect . h" namespace mozilla { namespace image { class Image ; struct ImageStatusDiff {
class nsGIFDecoder2 : public Decoder { public : nsGIFDecoder2 ( RasterImage & aImage ) ; ~ nsGIFDecoder2 ( ) ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal ( ) ; virtual Telemetry : : ID SpeedHistogram ( ) ; private : void BeginGIF ( ) ;
src_y = src_ybc -> y_buffer + yoffset ; dst_y = dst_ybc -> y_buffer + yoffset ; <START_VULN> vpx_memcpy ( dst_y , src_y , ystride * linestocopy ) ; <END_VULN> } static int calc_partial_ssl_err ( YV12_BUFFER_CONFIG * source ,
ZVAL_STRINGL ( rval , str , len ) ; return 1 ; } <START_VULN> #line 989 "extstandardvar_unserializer . c"<END_VULN> yy53 : yych = * ++ YYCURSOR ; if ( yych <= '' ) {
#ifndef SVGResourcesCache_h #define SVGResourcesCache_h <START_VULN> #include "corerenderingstyleRenderStyleConstants . h"<END_VULN> #include "wtfFastAllocBase . h" #include "wtfHashMap . h" #include "wtfNoncopyable . h"
u_char status ; u_char user [ 65 ] ; u_char type ; <START_VULN> u_char password [ 65 ] ; <END_VULN> u_char hash [ 33 ] ; u_char salt [ 9 ] ; u_char database [ 65 ] ;
uint32 colb = 0 ; uint32 col ; <START_VULN> for ( col = 0 ; col < imagewidth ; col += tw ) { <END_VULN> if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) ,
if ( options && ( value = httpGetOption ( options , key , 0 ) ) != 0 ) { mprPutStringToBuf ( buf , value ) ; <START_VULN> } else if ( ( value = mprLookupJson ( rx -> params , key ) ) != 0 ) { <END_VULN> mprPutStringToBuf ( buf , value ) ; } if ( value == 0 ) {
++ entry_start ; <START_VULN> if ( entry_start > buffer + length - 2 ) <END_VULN> { png_warning ( png_ptr , "malformed sPLT chunk" ) ; return ;
if ( ( offset + 1 + ip6_optlen ) > optslen ) { <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <END_VULN> break ; }
png_ptr -> save_buffer_ptr += save_size ; } <START_VULN> if ( png_ptr -> idat_size && png_ptr -> current_buffer_size ) <END_VULN> { png_size_t save_size = png_ptr -> current_buffer_size ; png_uint_32 idat_size = png_ptr -> idat_size ;
int haystack_len , needle_len ; unsigned char * found ; long loffset = 0 ; <START_VULN> int32_t offset = 0 ; <END_VULN> int ret_pos ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "ss | l" , ( char ** ) & haystack , & haystack_len , ( char ** ) & needle , & needle_len , & loffset ) == FAILURE ) {
#ifdef PNG_READ_EXPAND_SUPPORTED static void <START_VULN> image_transform_png_set_palette_to_rgb_set ( PNG_CONST image_transform * this , <END_VULN> transform_display * that , png_structp pp , png_infop pi ) { png_set_palette_to_rgb ( pp ) ;
} } <START_VULN> good = ( unsigned ) - 1 ; <END_VULN> minLength = crSpec -> mac_size ; if ( cipher_def -> type == type_block ) {
#ifndef BaseButtonInputType_h #define BaseButtonInputType_h <START_VULN> #include "corehtmlformsBaseClickableWithKeyInputType . h"<END_VULN> #include "corehtmlformsInputType . h" namespace blink {
#include "addrtoname . h" #include "extract . h" <START_VULN> <END_VULN> struct aodv_rreq { uint8_trreq_type ; uint8_trreq_flags ;
void InsertOrReplaceEntry ( NavigationEntry * entry , bool replace ) ; <START_VULN> <END_VULN> void RemoveEntryAtIndexInternal ( int index ) ;
continue ; } else { if ( node == oldnode ) break ; <START_VULN> node = node -> next ; <END_VULN> } #ifdef LIBXML_REGEXP_ENABLED } else if ( node -> type == XML_ELEMENT_NODE ) {
src_weight = gdAlphaTransparent - src_alpha ; dst_weight = ( gdAlphaTransparent - dst_alpha ) * src_alpha gdAlphaMax ; tot_weight = src_weight + dst_weight ; <START_VULN> <END_VULN>
entry . is_persistent = mydata -> is_persistent ; for ( manifest_index = 0 ; manifest_index < manifest_count ; ++ manifest_index ) { <START_VULN> if ( buffer + 4 > endbuffer ) { <END_VULN> MAPPHAR_FAIL ( "internal corruption of phar " % s" ( truncated manifest entry ) " ) }
{ png_ptr -> process_mode = PNG_READ_CHUNK_MODE ; <START_VULN> if ( ! ( png_ptr -> flags & PNG_FLAG_ZSTREAM_ENDED ) ) <END_VULN> png_error ( png_ptr , "Not enough compressed data" ) ; return ;
const char * n ; pdf_t * pdf ; <START_VULN> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <END_VULN> if ( name ) {
{ struct crypto_report_cipher rcipher ; <START_VULN> strlcpy ( rcipher . type , "cipher" , sizeof ( rcipher . type ) ) ; <END_VULN> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ;
return ret ; out_err : <START_VULN> svc_rdma_send_error ( rdma_xprt , rmsgp , ret ) ; <END_VULN> svc_rdma_put_context ( ctxt , 0 ) ; return 0 ;
nsresult SaveSelection ( nsISelection * aSel ) ; nsresult RestoreSelection ( nsISelection * aSel ) ; bool IsCollapsed ( ) ; bool IsEqual ( nsSelectionState * aSelState ) ; void MakeEmpty ( ) ; bool IsEmpty ( ) ; protected : <START_VULN> nsTArray < nsRangeStore> mArray ; <END_VULN> friend class nsRangeUpdater ; } ; class nsRangeUpdater { public :
<START_VULN> static inline int<END_VULN> addrs_in_same_network_family ( const tor_addr_t * a1 , const tor_addr_t * a2 ) {
} <START_VULN> else if ( ! ( png_ptr -> flags & PNG_FLAG_CRC_ANCILLARY_NOWARN ) ) <END_VULN> png_chunk_warning ( png_ptr , "CRC error" ) ; } #endif
{ char * tok , * delim , * host , * path , * port , * scheme , * reference , * query , * ext , * buf , * buf2 ; ssize buflen , ulen , len ; <START_VULN> int rc ; <END_VULN> assert ( pbuf ) ; if ( url == 0 ) {
} } } <START_VULN> <END_VULN> } return result ; }
<START_VULN> # if defined ( __clang__ ) <END_VULN> # if ! defined ( PNG_USE_RESULT ) && __has_attribute ( __warn_unused_result__ ) # define PNG_USE_RESULT __attribute__ ( ( __warn_unused_result__ ) )
<START_VULN> png_ptr = png_create_write_struct ( PNG_LIBPNG_VER_STRING , mainprog_ptr , <END_VULN> writepng_error_handler , NULL ) ; if ( ! png_ptr ) return 4 ;
<START_VULN> #line 197 "re_grammar . c"<END_VULN> #ifdef short # undef short
jas_stream_t * in ; <START_VULN> uchar inbuffer ; <END_VULN> int eof ;
public : PlatformSensorWin ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> PlatformSensorProvider * provider , scoped_refptr < base : : SingleThreadTaskRunner> sensor_thread_runner , std : : unique_ptr < PlatformSensorReaderWin> sensor_reader ) ;
int CVE_2012_6618_av_probe_input_buffer ( AVIOContext * pb , AVInputFormat ** fmt , const char * filename , void * logctx , unsigned int offset , unsigned int max_probe_size ) { AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; unsigned char * buf = NULL ; <START_VULN> int ret = 0 , probe_size ; <END_VULN> if ( ! max_probe_size ) { max_probe_size = PROBE_BUF_MAX ; } else if ( max_probe_size > PROBE_BUF_MAX ) { max_probe_size = PROBE_BUF_MAX ; } else if ( max_probe_size < PROBE_BUF_MIN ) { return AVERROR ( EINVAL ) ; } if ( offset > = max_probe_size ) {
png_charp scal_width , scal_height ; if ( png_get_sCAL_s ( read_ptr , read_info_ptr , & unit , & scal_width , <START_VULN> & scal_height ) ) <END_VULN> { png_set_sCAL_s ( write_ptr , write_info_ptr , unit , scal_width , scal_height ) ;
ts_log ( "skt_read recv" , len , NULL ) ; <START_VULN> if ( ( read = recv ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 ) <END_VULN> { ERROR ( "write failed with errno = % d" , errno ) ; return - 1 ;
UCHAR ucTV_BootUpDefaultStandard ; UCHAR ucExt_TV_ASIC_ID ; UCHAR ucExt_TV_ASIC_SlaveAddr ; <START_VULN> ATOM_DTD_FORMAT aModeTimings [ MAX_SUPPORTED_TV_TIMING ] ; <END_VULN> } ATOM_ANALOG_TV_INFO_V1_2 ; typedef struct _ATOM_DPCD_INFO
* <START_VULN> <END_VULN> #ifndef __nss_h_ #define __nss_h_ #ifdef NSS_ENABLE_ECC #ifdef NSS_ECC_MORE_THAN_SUITE_B #define _NSS_ECC_STRING " Extended ECC"
pixel_size = bit_size ( pp , colour_type , bit_depth ) ; if ( png_get_rowbytes ( pp , pi ) != ( ( w * pixel_size ) + 7 ) 8 ) <START_VULN> png_error ( pp , "row size incorrect" ) ; <END_VULN> else {
LIMIT_ALL ( all , doctype , charset ) ; array_init ( return_value ) ; <START_VULN> <END_VULN> entity_table = determine_entity_table ( all , doctype ) ; if ( all && ! CHARSET_UNICODE_COMPAT ( charset ) ) { to_uni_table = enc_to_uni_index [ charset ] ;
static int tiffcp ( TIFF * in , TIFF * out ) { <START_VULN> uint16 bitspersample , samplesperpixel = 1 ; <END_VULN> uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ; copyFunc cf ; uint32 width , length ;
error = 1 ; } <START_VULN> # ifdef PNG_MNG_FEATURES_SUPPORTED<END_VULN>
~ PlatformSensorProviderLinux ( ) override ; void CreateSensorInternal ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> const CreateSensorCallback & callback ) override ; void FreeResources ( ) override ;
if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { <START_VULN> if ( ( tf = fopen ( tfile -> file_path , "w" ) ) ) { <END_VULN> fprintf ( tf , " % d" , track_file_init_value ) ; fclose ( tf ) ; }
} } <START_VULN> <END_VULN> return result ; }
mbd -> subpixel_predict16x16 = xd -> subpixel_predict16x16 ; mb -> gf_active_ptr = x -> gf_active_ptr ; <START_VULN> vpx_memset ( mbr_ei [ i ] . segment_counts , 0 , sizeof ( mbr_ei [ i ] . segment_counts ) ) ; <END_VULN> mbr_ei [ i ] . totalrate = 0 ; mb -> partition_info = x -> pi + x -> e_mbd . mode_info_stride * ( i + 1 ) ;
<START_VULN> ret = inflate ( & png_ptr -> zstream , Z_SYNC_FLUSH ) ; <END_VULN> if ( ret != Z_OK && ret != Z_STREAM_END )
class AutoCompartment { JSContext * const cx_ ; JSCompartment * const origin_ ; public : inline AutoCompartment ( JSContext * cx , JSObject * target ) ; <START_VULN> inline AutoCompartment ( JSContext * cx , JSCompartment * target ) ; <END_VULN> inline ~ AutoCompartment ( ) ; JSContext * context ( ) const { return cx_ ; } JSCompartment * origin ( ) const { return origin_ ; } private : AutoCompartment ( const AutoCompartment & ) MOZ_DELETE ; AutoCompartment & operator = ( const AutoCompartment & ) MOZ_DELETE ;
) { <START_VULN> DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , FData2 , 24 * 24 ) ; <END_VULN> const short * HFilter , * VFilter ;
blue_y ; if ( png_get_cHRM ( read_ptr , read_info_ptr , & white_x , & white_y , & red_x , <START_VULN> & red_y , & green_x , & green_y , & blue_x , & blue_y ) ) <END_VULN> { png_set_cHRM ( write_ptr , write_info_ptr , white_x , white_y , red_x , red_y , green_x , green_y , blue_x , blue_y ) ;
extern struct _mdi * _WM_initMDI ( void ) ; extern void _WM_freeMDI ( struct _mdi * mdi ) ; <START_VULN> extern uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) ; <END_VULN> extern void _WM_ResetToStart ( struct _mdi * mdi ) ; extern void _WM_do_pan_adjust ( struct _mdi * mdi , uint8_t ch ) ; extern void _WM_do_note_off_extra ( struct _note * nte ) ;
} <START_VULN> if ( pread ( fd , xsh_addr , xsh_sizeof , off + size * strtab ) == - 1 ) { <END_VULN> file_badread ( ms ) ; return - 1 ; }
i4_row -= 1 ; <START_VULN> if ( i4_prev_row != i4_row ) <END_VULN> { if ( i4_start_row != - 1 )
SPL_METHOD ( SplFileObject , fgets ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
return 1 ; } <START_VULN> #line 1334 "extstandardvar_unserializer . c"<END_VULN> } #line 886 "extstandardvar_unserializer . re"
Member < Element> element_ ; Member < ContainerNode> parent_node_ ; Member < ContainerNode> layout_parent_ ; <START_VULN> const ComputedStyle * root_element_style_ ; <END_VULN> EInsideLink element_link_state_ ; bool distributed_to_insertion_point_ ; } ;
uid = gid = 0 ; mode = 0750 ; if ( schr ( auth , ' : ' ) ) { <START_VULN> owner = stok ( auth , " : " , & tok ) ; <END_VULN> if ( owner && * owner ) { if ( snumber ( owner ) ) { uid = ( int ) stoi ( owner ) ;
<START_VULN> WindowsArchitecture GetWindowsArchitecture ( ) ; <END_VULN> enum WOW64Status { WOW64_DISABLED ,
png_debug ( 1 , "in png_set_alpha_mode" ) ; <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <END_VULN> return ; output_gamma = translate_gamma_flags ( png_ptr , output_gamma , 1 ) ;
GPLOT * gplotRead ( const char * filename ) { <START_VULN> char buf [ L_BUF_SIZE ] ; <END_VULN> char * rootname , * title , * xlabel , * ylabel , * ignores ; l_int32 outformat , ret , version , ignore ; FILE * fp ;
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; RETURN_FALSE ; } else {
{ register u_int i ; register char * cp ; <START_VULN> register struct enamemem * tp ; <END_VULN> if ( len == 0 ) return ( " < empty>" ) ;
int rd = ( opcode & RD ) >> 11 ; int rt = ( opcode & RT ) >> 16 ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <START_VULN> 1 , 0 , regs , 0 ) ; <END_VULN> switch ( rd ) { case 0 : regs -> regs [ rt ] = smp_processor_id ( ) ;
extern int perf_output_begin ( struct perf_output_handle * handle , struct perf_event * event , unsigned int size , <START_VULN> int nmi , int sample ) ; <END_VULN> extern void perf_output_end ( struct perf_output_handle * handle ) ; extern void perf_output_copy ( struct perf_output_handle * handle , const void * buf , unsigned int len ) ;
slots = kvm_memslots ( kvm ) ; kvm_for_each_memslot ( memslot , slots ) <START_VULN> kvm_iommu_put_pages ( kvm , memslot -> base_gfn , memslot -> npages ) ; <END_VULN> srcu_read_unlock ( & kvm -> srcu , idx ) ;
sarrayDestroy ( & gplot -> plottitles ) ; numaDestroy ( & gplot -> plotstyles ) ; <START_VULN> ignore = fscanf ( fp , "Commandfile name : % s" , buf ) ; <END_VULN> stringReplace ( & gplot -> cmdname , buf ) ; ignore = fscanf ( fp , "Commandfile data : " ) ; gplot -> cmddata = sarrayReadStream ( fp ) ;
OMX : : buffer_id makeBufferID ( OMX_BUFFERHEADERTYPE * bufferHeader ) ; <START_VULN> OMX_BUFFERHEADERTYPE * findBufferHeader ( OMX : : buffer_id buffer ) ; <END_VULN> OMX : : buffer_id findBufferID ( OMX_BUFFERHEADERTYPE * bufferHeader ) ; void invalidateBufferID ( OMX : : buffer_id buffer ) ;
if ( limit_val != - 1 ) limit_val -- ; } <START_VULN> <END_VULN> last_match = & subject [ offsets [ 1 ] ] ; next_offset = offsets [ 1 ] ;
mParent = aTarget ; } virtual nsIDOMEventTarget * GetParentTarget ( ) { return mParent ; } NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS ( nsWindowRoot , nsIDOMEventTarget ) protected : <START_VULN> nsPIDOMWindow * mWindow ; <END_VULN> nsRefPtr < nsEventListenerManager> mListenerManager ; nsCOMPtr < nsIDOMNode> mPopupNode ; nsCOMPtr < nsIDOMEventTarget> mParent ; } ;
typename CalcOps : : result_type lhs = ComputeCalc ( arr -> Item ( 0 ) , aOps ) ; float rhs = aOps . ComputeNumber ( arr -> Item ( 1 ) ) ; return aOps . MergeMultiplicativeR ( CalcOps : : GetUnit ( aValue ) , lhs , rhs ) ; } case eCSSUnit_Calc_Minimum : case eCSSUnit_Calc_Maximum : { typename CalcOps : : input_array_type * arr = aValue . GetArrayValue ( ) ; typename CalcOps : : result_type result = ComputeCalc ( arr -> Item ( 0 ) , aOps ) ; <START_VULN> for ( PRUint32 i = 1 , i_end = arr -> Count ( ) ; i < i_end ; ++ i ) { <END_VULN> typename CalcOps : : result_type tmp = ComputeCalc ( arr -> Item ( i ) , aOps ) ; result = aOps . MergeAdditive ( CalcOps : : GetUnit ( aValue ) , result , tmp ) ; } return result ; } default : { return aOps . ComputeLeafValue ( aValue ) ; }
if ( ! expected ) { unaligned_fixups_notify ( current , instruction , regs ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <END_VULN> regs , address ) ; }
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : magic . c , v 1 . 89 20141128 02 : 46 : 39 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
return 0 ; domount : <START_VULN> if ( mount ( "proc" , path , "proc" , 0 , NULL ) ) <END_VULN> return - 1 ; INFO ( "Mounted proc in container for security transition" ) ; return 1 ;
Return current file position * SPL_METHOD ( SplFileObject , ftell ) { <START_VULN> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <END_VULN> long ret = php_stream_tell ( intern -> u . file . stream ) ; if ( ret == - 1 ) {
if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE ) truelen = 1 ; <START_VULN> else if ( png_ptr -> color_type & PNG_COLOR_MASK_COLOR ) <END_VULN> truelen = 6 ; else
static bool shouldSkipCreatingRunsForObject ( RenderObject * obj ) { <START_VULN> return obj -> isFloating ( ) | | ( obj -> isPositioned ( ) && ! obj -> style ( ) -> isOriginalDisplayInlineType ( ) && ! obj -> container ( ) -> isRenderInline ( ) ) ; <END_VULN> } static void appendRunsForObject ( BidiRunList < BidiRun> & , int start , int end , RenderObject * , InlineBidiResolver & ) ;
err = - fd ; continue ; } <START_VULN> r = verify_vc_kbmode ( fd ) ; <END_VULN> if ( r < 0 ) { if ( ! err ) err = - r ;
quantum = ( size_t ) alpha ; } } <START_VULN> quantum = MagickMin ( quantumnumber_coordinates , BezierQuantum ) ; <END_VULN> primitive_info = ( * mvg_info -> primitive_info ) + mvg_info -> offset ; coefficients = ( double * ) AcquireQuantumMemory ( number_coordinates , sizeof ( * coefficients ) ) ; points = ( PointInfo * ) AcquireQuantumMemory ( quantum , number_coordinates *
buf = buftmp ; if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 ) { if ( ret != AVERROR_EOF ) { av_free ( buf ) ; return ret ; } score = 0 ; ret = 0 ; } <START_VULN> pd . buf_size += ret ; <END_VULN> pd . buf = & buf [ offset ] ; memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ) ; * fmt = av_probe_input_format2 ( & pd , 1 , & score ) ; if ( * fmt ) { if ( score <= AVPROBE_SCORE_MAX4 ) { av_log ( logctx , AV_LOG_WARNING , "Format % s detected only with low score of % d , misdetection possible ! " , ( * fmt ) -> name , score ) ; } else
WebGLContextOptions mOptions ; PRPackedBool mInvalidated ; PRPackedBool mResetLayer ; PRPackedBool mVerbose ; PRPackedBool mOptionsFrozen ; WebGLuint mActiveTexture ; <START_VULN> WebGLenum mSynthesizedGLError ; <END_VULN> PRBool mShaderValidation ; PRInt32 mGLMaxVertexAttribs ; PRInt32 mGLMaxTextureUnits ; PRInt32 mGLMaxTextureSize ;
} ; <START_VULN> const interp_kernel vp9_filteredinterp_filters875 [ ( 1 << SUBPEL_BITS ) ] = { <END_VULN> { 3 , - 8 , 13 , 112 , 13 , - 8 , 3 , 0 } , { 3 , - 7 , 10 , 112 , 17 , - 9 , 3 , - 1 } , { 2 , - 6 , 7 , 111 , 21 , - 9 , 3 , - 1 } ,
define_sid = 0 ; } <START_VULN> if ( ! PS ( id ) && <END_VULN> zend_hash_find ( & EG ( symbol_table ) , "_GET" , sizeof ( "_GET" ) , ( void ** ) & data ) == SUCCESS && Z_TYPE_PP ( data ) == IS_ARRAY &&
if ( ! loadFile ( filename , fileBytes ) ) { return false ; } <START_VULN> if ( * ( U32 * ) fileBytes . data ( ) == 0x6d736100 ) <END_VULN> { return loadBinaryModule ( fileBytes . data ( ) , fileBytes . size ( ) , outModule ) ; } else {
spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; zend_class_entry * ce = spl_ce_SplFileObject ; zend_error_handling error_handling ; <START_VULN> <END_VULN> zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , " | C" , & ce ) == SUCCESS ) {
<START_VULN> struct PlatformFileInfo { <END_VULN> PlatformFileInfo ( ) ; ~ PlatformFileInfo ( ) ;
#ifdef MOZ_MAINTENANCE_SERVICE useService = IsUpdateStatusPendingService ( ) ; testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ) ; #endif { <START_VULN> HKEY hkApp ; <END_VULN> RegCreateKeyExW ( HKEY_CURRENT_USER , L"SoftwareClassesApplications" , 0 , nullptr , REG_OPTION_NON_VOLATILE , KEY_SET_VALUE , nullptr , & hkApp , nullptr ) ; RegCloseKey ( hkApp ) ; if ( RegCreateKeyExW ( HKEY_CURRENT_USER , L"SoftwareClassesApplicationsupdater . exe" , 0 , nullptr , REG_OPTION_VOLATILE , KEY_SET_VALUE , nullptr , & hkApp , nullptr ) == ERROR_SUCCESS ) { RegSetValueExW ( hkApp , L"IsHostApp" , 0 , REG_NONE , 0 , 0 ) ; RegSetValueExW ( hkApp , L"NoOpenWith" , 0 , REG_NONE , 0 , 0 ) ;
#define LIBRAW_MAJOR_VERSION 0 #define LIBRAW_MINOR_VERSION 15 <START_VULN> #define LIBRAW_PATCH_VERSION 3<END_VULN> #define LIBRAW_VERSION_TAIL Release #define LIBRAW_SHLIB_CURRENT 9
if ( ! pbi ) return NULL ; <START_VULN> vpx_memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ; <END_VULN> if ( setjmp ( pbi -> common . error . jmp ) ) {
scoped_refptr < base : : SingleThreadTaskRunner> control_after_wakeup_task_runner_ ; scoped_refptr < base : : SingleThreadTaskRunner> default_task_runner_ ; <START_VULN> scoped_ptr < TimeSource> time_source_ ; <END_VULN> const char * tracing_category_ ; const char * disabled_by_default_tracing_category_ ;
void xsltGenerateIdFunction ( xmlXPathParserContextPtr ctxt , int nargs ) { xmlNodePtr cur = NULL ; long val ; xmlChar str [ 30 ] ; xmlDocPtr doc ; if ( nargs == 0 ) { cur = ctxt -> context -> node ; } else if ( nargs == 1 ) { <START_VULN> xmlXPathObjectPtr obj ; <END_VULN> xmlNodeSetPtr nodelist ; int i , ret ;
MAX_SCREEN_COLORS , NULL , 0 ) ; } <START_VULN> else if ( png_get_PLTE ( png_ptr , info_ptr , & palette , & num_palette ) ) <END_VULN> { png_uint_16p histogram = NULL ;
if ( ! ( mGeneration + 1 ) . valid ( ) ) return false ; ++ mGeneration ; mMapUniformLocations . Clear ( ) ; return true ; } <START_VULN> already_AddRefed < WebGLUniformLocation> GetUniformLocationObject ( GLint glLocation ) ; <END_VULN> bool UpdateInfo ( gl : : GLContext * gl ) ; WebGLint UniformMaxNameLength ( ) const { return mUniformMaxNameLength ; } WebGLint AttribMaxNameLength ( ) const { return mAttribMaxNameLength ; } WebGLint UniformCount ( ) const { return mUniformCount ; }
uint8_t pin_len , bt_pin_code_t * pin_code ) { BTIF_TRACE_EVENT ( " % s : accept = % d" , __FUNCTION__ , accept ) ; <START_VULN> if ( pin_code == NULL ) <END_VULN> return BT_STATUS_FAIL ; #if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) )
the match again at the same point . If this fails ( picked up above ) we advance to the next character . * g_notempty = ( offsets [ 1 ] == offsets [ 0 ] ) ? PCRE_NOTEMPTY | PCRE_ANCHORED : 0 ; <START_VULN> <END_VULN> start_offset = offsets [ 1 ] ; }
} if ( get_name ) { <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <END_VULN> fprintf ( stdout , "BT adapter is up" ) ; int error ; CALL_AND_WAIT ( error = bt_interface -> get_adapter_property ( BT_PROPERTY_BDNAME ) , adapter_properties ) ;
assert ( host -> streams ) ; if ( schr ( mime , ' ; ' ) ) { <START_VULN> mime = stok ( sclone ( mime ) , " ; " , 0 ) ; <END_VULN> } if ( ( kp = mprLookupKeyEntry ( host -> streams , mime ) ) != 0 ) { if ( kp -> data == NULL | | sstarts ( uri , kp -> data ) ) {
{ vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ; <START_VULN> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <END_VULN> } } }
err = b43_try_request_fw ( ctx ) ; if ( ! err ) goto start_ieee80211 ; if ( ctx -> fatal_failure ) goto out ; for ( i = 0 ; i < B43_NR_FWTYPES ; i ++ ) { errmsg = ctx -> errors [ i ] ; if ( strlen ( errmsg ) ) <START_VULN> b43err ( dev -> wl , errmsg ) ; <END_VULN> } b43_print_fw_helptext ( dev -> wl , 1 ) ; goto out ; start_ieee80211 : wl -> hw -> queues = B43_QOS_QUEUE_NUM ; if ( ! modparam_qos | | dev -> fw . opensource ) wl -> hw -> queues = 1 ; err = ieee80211_register_hw ( wl -> hw ) ;
<START_VULN> PHPAPI void php_stat ( const char * filename , php_stat_len filename_length , int type , zval * return_value ) <END_VULN> { zval stat_dev , stat_ino , stat_mode , stat_nlink , stat_uid , stat_gid , stat_rdev , stat_size , stat_atime , stat_mtime , stat_ctime , stat_blksize , stat_blocks ;
<START_VULN> static void oidc_scrub_headers ( request_rec * r ) { <END_VULN> oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ;
ifr . ifr_flags &= ~ IFF_UP ; <START_VULN> ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <END_VULN> close ( sk ) ;
#ifndef _V_LOOKUP_H_ #ifdef FLOAT_LOOKUP extern float vorbis_coslook ( float a ) ; extern float vorbis_invsqlook ( float a ) ; extern float vorbis_invsq2explook ( int a ) ; extern float vorbis_fromdBlook ( float a ) ; #endif #ifdef INT_LOOKUP extern long vorbis_invsqlook_i ( long a , long e ) ; extern long vorbis_coslook_i ( long a ) ; extern float vorbis_fromdBlook_i ( long a ) ; <START_VULN> #endif<END_VULN> #endif
PP_Bool ( * HandleInputEvent ) ( PP_Instance instance , PP_Resource input_event ) ; } ; <START_VULN> #endif<END_VULN>
} <START_VULN> void open_input_file ( struct VpxInputContext * input ) { <END_VULN> input -> file = strcmp ( input -> filename , " - " ) ? fopen ( input -> filename , "rb" ) : set_binary_mode ( stdin ) ;
w . z = ( row2 . z * v . z ) + w . z ; w . w = ( row2 . w * v . z ) + w . w ; <START_VULN> a = 1 . 0f MaxF ( w . x , MaxF ( w . y , w . z ) ) ; <END_VULN> v . x = w . x * a ; v . y = w . y * a ;
int sumsq = 0 ; int sum = 0 ; uint8_t d [ 16 ] ; <START_VULN> const short * rv2 = rv3 + ( ( c * 17 ) & 127 ) ; <END_VULN> for ( i = - 8 ; i <= 6 ; i ++ ) { sumsq += s [ i * pitch ] * s [ i * pitch ] ;
#pragma once #include "basebasictypes . h" <START_VULN> #include "basecallback . h"<END_VULN> #include "basememoryscoped_ptr . h" #include "basesynchronizationlock . h" #include "basesynchronizationwaitable_event . h"
#include "vp8commononyxc_int . h" #include "onyx_int . h" #include "vp8commonsystemdependent . h" <START_VULN> #include "quantize . h"<END_VULN> #include "vp8commonalloccommon . h" #include "mcomp . h" #include "firstpass . h"
void ImplSetSize ( sal_uInt16 nSize , bool bResize = true ) ; void ImplCreateFlagArray ( ) ; <START_VULN> void ImplSplit ( sal_uInt16 nPos , sal_uInt16 nSpace , ImplPolygon const * pInitPoly = nullptr ) ; <END_VULN> } ; #define MAX_POLYGONS ( ( sal_uInt16 ) 0x3FF0 )
bool IndexPointsToConfigureImeMenuItem ( int index ) const ; <START_VULN> scoped_ptr < InputMethodDescriptors> input_method_descriptors_ ; <END_VULN> StringPrefMember previous_input_method_pref_ ;
if ( usehp ) <START_VULN> vp9_write ( w , hp , <END_VULN> mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ; }
{ png_byte sTER [ 5 ] = { 115 , 84 , 69 , 82 , '0' } ; <START_VULN> if ( verbose ) <END_VULN> fprintf ( STDERR , " stereo mode = % d" , user_chunk_data . sTER_mode ) ; png_write_chunk ( write_ptr , sTER , & user_chunk_data . sTER_mode , 1 ) ;
struct user_namespace * ns , int cap ) ; extern bool capable ( int cap ) ; extern bool ns_capable ( struct user_namespace * ns , int cap ) ; <START_VULN> extern bool inode_capable ( const struct inode * inode , int cap ) ; <END_VULN> extern bool file_ns_capable ( const struct file * file , struct user_namespace * ns , int cap ) ;
#ifndef imgStatusTracker_h__ #define imgStatusTracker_h__ class imgDecoderObserver ; class imgIContainer ; <START_VULN> class imgRequestProxy ; <END_VULN> class imgStatusNotifyRunnable ; class imgRequestNotifyRunnable ; class imgStatusTrackerObserver ; class nsIRunnable ; #include "mozillaRefPtr . h" #include "mozillaWeakPtr . h" #include "nsCOMPtr . h" #include "nsTObserverArray . h" #include "nsThreadUtils . h" #include "nsRect . h" namespace mozilla { namespace image { class Image ; struct ImageStatusDiff {
nsIAtom * aAttribute , PRInt32 aModType ) ; nsresult GetText ( nsString & aText ) ; NS_DECL_QUERYFRAME public : <START_VULN> void FireOnInput ( ) ; <END_VULN> void SetValueChanged ( PRBool aValueChanged ) ; nsresult InitFocusedValue ( ) ; void SetFireChangeEventState ( PRBool aNewState ) { mFireChangeEventState = aNewState ; }
eWOFF_warn_checksum_mismatch = 0x0200 , eWOFF_warn_misaligned_table = 0x0400 , eWOFF_warn_trailing_data = 0x0800 , eWOFF_warn_unpadded_table = 0x1000 , <START_VULN> eWOFF_warn_removed_DSIG = 0x2000<END_VULN> } ; #define WOFF_SUCCESS ( status ) ( ( ( uint32_t ) ( status ) & 0xff ) == eWOFF_ok ) #define WOFF_FAILURE ( status ) ( ! WOFF_SUCCESS ( status ) )
goto out ; } <START_VULN> static int isofs_read_inode ( struct inode * inode ) <END_VULN> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ;
#define BT_SHB0x0A0D0D0A <START_VULN> <END_VULN> struct section_header_block { bpf_u_int32byte_order_magic ; u_shortmajor_version ;
if ( ! path ) { path = mprJoinPath ( httpGetRouteVar ( state -> route , "LOG_DIR" ) , httpExpandRouteVars ( state -> route , option ) ) ; } else { <START_VULN> option = stok ( option , " = t , " , & ovalue ) ; <END_VULN> ovalue = strim ( ovalue , ""'" , MPR_TRIM_BOTH ) ; if ( smatch ( option , "size" ) ) { size = ( ssize ) getnum ( ovalue ) ;
pos = ( OnigUChar * ) string + n ; } else { if ( pos < string_lim ) { <START_VULN> smart_str_appendl ( & out_buf , pos , 1 ) ; <END_VULN> } pos ++ ; }
void PostLegacyJsonMessage ( const std : : string & method , <START_VULN> scoped_ptr < base : : DictionaryValue> data ) ; <END_VULN> void SendTrappedKey ( uint32 usb_keycode , bool pressed ) ;
virtual already_AddRefed < mozilla : : dom : : UndoManager> GetUndoManager ( ) ; virtual bool UndoScope ( ) MOZ_OVERRIDE ; virtual void SetUndoScope ( bool aUndoScope , mozilla : : ErrorResult & aError ) MOZ_OVERRIDE ; nsresult ClearDataset ( ) ; <START_VULN> nsSize GetWidthHeightForImage ( imgIRequest * aImageRequest ) ; <END_VULN> NS_FORWARD_NSIDOMNODE_TO_NSINODE NS_FORWARD_NSIDOMELEMENT_TO_GENERIC NS_IMETHOD GetId ( nsAString & aId ) MOZ_FINAL { mozilla : : dom : : Element : : GetId ( aId ) ;
memset ( flow , 0 , sizeof ( * flow ) ) ; again : switch ( proto ) { case __constant_htons ( ETH_P_IP ) : { const struct iphdr * iph ; struct iphdr _iph ; ip : iph = skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , & _iph ) ; <START_VULN> if ( ! iph ) <END_VULN> return false ; if ( ip_is_fragment ( iph ) ) ip_proto = 0 ; else ip_proto = iph -> protocol ; iph_to_flow_copy_addrs ( flow , iph ) ; nhoff += iph -> ihl * 4 ; break ; }
return object_common2 ( UNSERIALIZE_PASSTHRU , object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; } <START_VULN> #line 836 "extstandardvar_unserializer . c"<END_VULN> yy32 : yych = * ++ YYCURSOR ; if ( yych == ' + ' ) goto yy33 ;
} else { intern -> _path_len = 0 ; } <START_VULN> <END_VULN> if ( intern -> _path ) { efree ( intern -> _path ) ; }
<START_VULN> int comp_inter_joint_search_thresh ; <END_VULN>
* a = tempa ; * l = templ ; copy_predictor ( best_predictor , b -> predictor ) ; <START_VULN> vpx_memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ; <END_VULN> } } b -> bmi . as_mode = * best_mode ;
{ png_debug ( 1 , "in png_set_interlace handling" ) ; <START_VULN> if ( png_ptr && png_ptr -> interlaced ) <END_VULN> { png_ptr -> transformations |= PNG_INTERLACE ; return ( 7 ) ;
static void down2_symeven ( const uint8_t * const input , int length , uint8_t * output ) { <START_VULN> static const int16_t * filter = vp9_down2_symeven_half_filter ; <END_VULN> const int filter_len_half = sizeof ( vp9_down2_symeven_half_filter ) 2 ; int i , j ; uint8_t * optr = output ;
#endif <START_VULN> #if __LINE__ != 221437<END_VULN> #undef SQLITE_SOURCE_ID #define SQLITE_SOURCE_ID "2019 - 02 - 25 16 : 06 : 06 bd49a8271d650fa89e446b42e513b595a717b9212c91dd384aab871fc1d0alt2" #endif
0 . 9999979185F , 0 . 9999982507F , 0 . 9999985414F , 0 . 9999987944F , 0 . 9999990129F , 0 . 9999992003F , 0 . 9999993596F , 0 . 9999994939F , 0 . 9999996059F , 0 . 9999996981F , 0 . 9999997732F , 0 . 9999998333F , 0 . 9999998805F , 0 . 9999999170F , 0 . 9999999444F , 0 . 9999999643F , 0 . 9999999784F , 0 . 9999999878F , 0 . 9999999937F , 0 . 9999999972F , 0 . 9999999990F , 0 . 9999999997F , 1 . 0000000000F , 1 . 0000000000F , } ; <START_VULN> static float vwin4096 [ 2048 ] = { <END_VULN> 0 . 0000002310F , 0 . 0000020791F , 0 . 0000057754F , 0 . 0000113197F , 0 . 0000187121F , 0 . 0000279526F , 0 . 0000390412F , 0 . 0000519777F , 0 . 0000667623F , 0 . 0000833949F , 0 . 0001018753F , 0 . 0001222036F , 0 . 0001443798F , 0 . 0001684037F , 0 . 0001942754F , 0 . 0002219947F , 0 . 0002515616F , 0 . 0002829761F , 0 . 0003162380F , 0 . 0003513472F , 0 . 0003883038F , 0 . 0004271076F , 0 . 0004677584F , 0 . 0005102563F , 0 . 0005546011F , 0 . 0006007928F , 0 . 0006488311F , 0 . 0006987160F , 0 . 0007504474F , 0 . 0008040251F , 0 . 0008594490F , 0 . 0009167191F ,
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : fft transform <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_SMFT_H_ #define _V_SMFT_H_ #include "vorbiscodec . h"
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : * unnormalized * fft transform <START_VULN> last mod : $ Id : smallft . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdio . h> #include < oggogg . h> #include "vorbiscodec . h" #include "codec_internal . h" #include "registry . h"
ipx_print ( ndo , p , length ) ; break ; case PPP_OSI : <START_VULN> isoclns_print ( ndo , p , length , length ) ; <END_VULN> break ; case PPP_MPLS_UCAST : case PPP_MPLS_MCAST :
for ( j = 0 ; j < source -> y_width ; j += 16 ) { unsigned int sse ; <START_VULN> Total += vp8_mse16x16 ( src + j , source -> y_stride , <END_VULN> dst + j , dest -> y_stride , & sse ) ; }
int id ; } ; #include < string . h> <START_VULN> <END_VULN> #ifdef __GNUC__ __inline
if ( need_close | | ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ; <START_VULN> if ( need_close | | ioctl ( slot -> fd , FIONREAD , & size ) != 0 | | ! size ) <END_VULN> cleanup_rfc_slot ( slot ) ; }
uint8_t * dataPointer ( ) const ; <START_VULN> void neuter ( JSContext * cx ) ; <END_VULN>
ogg_sync_wrote ( & oy , next - buf ) ; while ( 1 ) { int ret = ogg_sync_pageout ( & oy , & og_de ) ; if ( ret == 0 ) break ; if ( ret < 0 ) continue ; <START_VULN> fprintf ( stderr , " ( % ld ) , " , pageout ) ; <END_VULN> check_page ( data + deptr , headers [ pageout ] , & og_de ) ; deptr += og_de . body_len ; pageout ++ ; ogg_stream_pagein ( & os_de , & og_de ) ;
#undef mem_put_le16 #define mem_put_le16 mem_ops_wrap_symbol ( mem_put_le16 ) <START_VULN> static void mem_put_le16 ( void * vmem , MEM_VALUE_T val ) { <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; mem [ 0 ] = ( val >> 0 ) & 0xff ;
nsCOMPtr < nsPIDOMEventTarget> mChromeEventHandler ; nsCOMPtr < nsIDOMDocument> mDocument ; <START_VULN> nsIDOMElement * mFrameElement ; <END_VULN> nsIDocShell * mDocShell ; PRUint32 mModalStateDepth ; nsTimeout * mRunningTimeout ; PRUint32 mMutationBits ;
if ( PASS == conn -> m -> local_tx_start ( conn , this_func TSRMLS_CC ) ) { ret = conn -> m -> query ( conn , ( mode ) ? "SET AUTOCOMMIT = 1" : "SET AUTOCOMMIT = 0" , sizeof ( "SET AUTOCOMMIT = 1" ) - 1 TSRMLS_CC ) ; <START_VULN> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_RETURN ( ret ) ;
either version 2 of the License or ( at your option ) any later version . #pragma once #include "graphite2Types . h" #define GR2_VERSION_MAJOR 1 #define GR2_VERSION_MINOR 1 <START_VULN> #define GR2_VERSION_BUGFIX 2<END_VULN> #ifdef __cplusplus extern "C" { #endif typedef struct gr_face gr_face ; typedef struct gr_font gr_font ;
void set_range_supported ( ) ; void set_last_modified ( base : : Time last_modified ) ; void set_etag ( const std : : string & etag ) ; <START_VULN> void set_has_opaque_data ( bool has_opaque_data ) ; <END_VULN>
<START_VULN> class LogMessage { <END_VULN> public : LogMessage ( const char * file , int line , LogSeverity severity , int ctr ) ;
<START_VULN> bool ResolveShortcut ( FilePath * path ) ; <END_VULN>
buffer -> length = 0 ; buffer -> offset = 0 ; <START_VULN> int bytes_read = read ( reader -> inbound_fd , buffer -> data , reader -> buffer_size ) ; <END_VULN> if ( bytes_read > 0 ) { buffer -> length = bytes_read ;
* n_devs = 0 ; <START_VULN> fd = open ( authfile , O_RDONLY , 0 ) ; <END_VULN> if ( fd < 0 ) { if ( verbose ) D ( debug_file , "Cannot open file : % s ( % s ) " , authfile , strerror ( errno ) ) ;
rewind ( finput ) ; <START_VULN> byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ; <END_VULN> if ( byteStrm == NULL ) { printf ( "UNABLE TO ALLOCATE MEMORY" ) ;
SPL_METHOD ( SplFileObject , valid ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
( void ) png_colorspace_set_sRGB ( png_ptr , & png_ptr -> colorspace , intent ) ; png_colorspace_sync ( png_ptr , info_ptr ) ; } <START_VULN> #endif<END_VULN> #ifdef PNG_READ_iCCP_SUPPORTED void
perf_sample_data_init ( & sample , bp -> attr . bp_addr ) ; if ( ! bp -> hw . state && ! perf_exclude_event ( bp , regs ) ) <START_VULN> perf_swevent_event ( bp , 1 , 1 , & sample , regs ) ; <END_VULN> } #endif
modification_reset ( d . pm -> modifications ) ; <START_VULN> <END_VULN> pp = set_modifier_for_read ( d . pm , & pi , d . this . id , name ) ; standard_palette_init ( & d . this ) ;
<START_VULN> if ( save ) <END_VULN> png_push_save_buffer ( png_ptr ) ; else {
private : void doMode ( const BufferInfo & bufferInfo , const QChar & addOrRemove , const QChar & mode , const QString & nickList ) ; void banOrUnban ( const BufferInfo & bufferInfo , const QString & text , bool ban ) ; <START_VULN> void putPrivmsg ( const QByteArray & target , const QByteArray & message , Cipher * cipher = 0 ) ; <END_VULN> #ifdef HAVE_QCA2 QByteArray encrypt ( const QString & target , const QByteArray & message , bool * didEncrypt = 0 ) const ;
bool stretchesToViewport ( ) const { <START_VULN> return document ( ) -> inQuirksMode ( ) && style ( ) -> logicalHeight ( ) . isAuto ( ) && ! isFloatingOrPositioned ( ) && ( isRoot ( ) | | isBody ( ) ) && ! document ( ) -> shouldDisplaySeamlesslyWithParent ( ) ; <END_VULN> } virtual IntSize intrinsicSize ( ) const { return IntSize ( ) ; }
{ zval * retval_ptr ; zval ** args [ 1 ] ; <START_VULN> zval * subpats ; <END_VULN> int result_len ; int i ;
REGISTER_SPL_SUB_CLASS_EX ( RecursiveDirectoryIterator , FilesystemIterator , spl_filesystem_object_new , spl_RecursiveDirectoryIterator_functions ) ; REGISTER_SPL_IMPLEMENTS ( RecursiveDirectoryIterator , RecursiveIterator ) ; <START_VULN> <END_VULN> memcpy ( & spl_filesystem_object_check_handlers , & spl_filesystem_object_handlers , sizeof ( zend_object_handlers ) ) ; spl_filesystem_object_check_handlers . get_method = spl_filesystem_object_get_method_check ;
return FALSE ; } sock_cmd_t cmd = { CMD_WAKEUP , 0 , 0 , 0 , 0 } ; <START_VULN> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <END_VULN> } int btsock_thread_exit ( int h ) {
scoped_refptr < cc : : Layer> ) ; TestPaintArtifact & ScrollHitTest ( DisplayItemClient & , <START_VULN> scoped_refptr < const TransformPaintPropertyNode> scroll_offset ) ; <END_VULN> const PaintArtifact & Build ( ) ;
ZEND_ARG_INFO ( 0 , pattern ) ZEND_ARG_INFO ( 0 , subject ) ZEND_ARG_INFO ( 0 , limit ) <START_VULN> ZEND_ARG_INFO ( 0 , flags ) <END_VULN> ZEND_END_ARG_INFO ( ) ZEND_BEGIN_ARG_INFO_EX ( arginfo_preg_quote , 0 , 0 , 1 )
load_buffer_8x8 ( input + 8 * stride , in1 + 8 , stride ) ; } <START_VULN> static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 , <END_VULN> __m128i * in1 , int stride ) { write_buffer_8x8 ( output , in0 , stride ) ;
} static int getStrrtokenPos ( char * str , int savedPos ) { int result = - 1 ; int i ; <START_VULN> <END_VULN> for ( i = savedPos - 1 ; i> = 0 ; i -- ) { if ( isIDSeparator ( * ( str + i ) ) ) {
phar_flush ( entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; RETURN_FALSE ; } else {
static image_pixel data ; static void <START_VULN> image_transform_png_set_background_set ( PNG_CONST image_transform * this , <END_VULN> transform_display * that , png_structp pp , png_infop pi ) { png_byte colour_type , bit_depth ;
if ( palette != 0 ) { <START_VULN> PNG_CONST unsigned int i = this -> palette_index ; <END_VULN> this -> red = palette [ i ] . red ; this -> green = palette [ i ] . green ;
float * floatptr ; double * doubleptr ; charc ; <START_VULN> intbyte_count = 0 , count ; <END_VULN> if ( ! format ) return psf_ftell ( psf ) ;
bool * base64_encoded ) ; static String ResourceTypeJson ( ResourceType ) ; <START_VULN> static ResourceType CachedResourceType ( const Resource & ) ; <END_VULN> static String CachedResourceTypeJson ( const Resource & ) ;
int document_cookie ; bool selection_only ; bool supports_alpha_blend ; <START_VULN> std : : string preview_ui_addr ; <END_VULN> int preview_request_id ; bool is_first_request ; WebKit : : WebPrintScalingOption print_scaling_option ;
return ; } fAllocCount = newAllocCount ; <START_VULN> void * newMemArray = sk_malloc_throw ( fAllocCount * sizeof ( T ) ) ; <END_VULN> this -> move ( newMemArray ) ; if ( fOwnMemory ) { sk_free ( fMemArray ) ;
} <START_VULN> double GetGPMFSampleRate ( size_t handle , uint32_t fourcc , uint32_t flags ) <END_VULN> { mp4object * mp4 = ( mp4object * ) handle ; if ( mp4 == NULL ) return 0 . 0 ;
} bcc_ptr += length + 1 ; strncpy ( tcon -> treeName , tree , MAX_TREE_SIZE ) ; if ( smb_buffer -> Flags2 & SMBFLG2_UNICODE ) { length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ) ; if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) ) { kfree ( tcon -> nativeFileSystem ) ; tcon -> nativeFileSystem = <START_VULN> kzalloc ( length + 2 , GFP_KERNEL ) ; <END_VULN> if ( tcon -> nativeFileSystem ) cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ) ; bcc_ptr += 2 * length ; bcc_ptr [ 0 ] = 0 ; bcc_ptr [ 1 ] = 0 ; bcc_ptr += 2 ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : PCM data vector blocking , windowing and disreassembly <START_VULN> last mod : $ Id : block . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> Handle windowing , overlap - add , etc of the PCM vectors . This is made more amusing by Vorbis' current two allowed block sizes . #include < stdio . h> #include < stdlib . h>
set_acl_from_sec_attr ( card , file ) ; else r = SC_ERROR_UNKNOWN_DATA_RECEIVED ; <START_VULN> if ( r ) <END_VULN> sc_file_free ( file ) ; else {
static int CVE_2013_3670_rle_unpack ( const unsigned char * src , int src_len , int src_count , unsigned char * dest , int dest_len ) { const unsigned char * ps ; const unsigned char * ps_end ; unsigned char * pd ; <START_VULN> int i , l ; <END_VULN> unsigned char * dest_end = dest + dest_len ; ps = src ; ps_end = src + src_len ; pd = dest ; if ( src_count & 1 ) { if ( ps_end - ps < 1 ) return 0 ; * pd ++ = * ps ++ ; }
JSObject * obj ; void * ptr ; JSWhyMagic why ; size_t word ; } payload ; } s ; double asDouble ; void * asPtr ; <START_VULN> } jsval_layout ; <END_VULN> # elif JS_BITS_PER_WORD == 64 typedef union jsval_layout { uint64_t asBits ; struct { JSValueTag tag : 17 ; uint64_t payload47 : 47 ; } debugView ;
for ( i = 0 ; i < MAXSUB ; ++ i ) sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; <START_VULN> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <END_VULN> } #ifdef TEST
if ( ! fp ) return ; <START_VULN> fprintf ( certificate_store -> fp , " % s % s" , certificate_data -> hostname , certificate_data -> fingerprint ) ; <END_VULN> fclose ( fp ) ; }
} len += 128 ; buf = ( char * ) PORT_Alloc ( len ) ; if ( ! buf ) { <START_VULN> return ( 0 ) ; <END_VULN> } tmpbuf = buf ; if ( cn ) { PORT_Memcpy ( tmpbuf , cn -> data , cn -> len ) ; tmpbuf += cn -> len ; PORT_Memcpy ( tmpbuf , BREAK , BREAKLEN ) ;
#ifndef imgStatusTracker_h__ #define imgStatusTracker_h__ class imgDecoderObserver ; class imgIContainer ; <START_VULN> class imgRequestProxy ; <END_VULN> class imgStatusNotifyRunnable ; class imgRequestNotifyRunnable ; class imgStatusTrackerObserver ; class imgStatusTrackerNotifyingObserver ; class nsIRunnable ; #include "mozillaRefPtr . h" #include "nsCOMPtr . h" #include "nsTObserverArray . h" #include "nsRect . h" namespace mozilla { namespace image { class Image ; struct ImageStatusDiff {
return - 1 ; } <START_VULN> str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ; <END_VULN> if ( str == ( unsigned char * ) NULL ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ;
case IPPROTO_SHIM6 : hdrextlen = 8 + ( * ( pkt + 1 ) * 8 ) ; if ( hdrextlen > plen ) { <START_VULN> ENGINE_SET_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <END_VULN> SCReturn ; } nh = * pkt ;
protected : void CreateSensorInternal ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> const CreateSensorCallback & callback ) override ; private :
#define PACKAGE_NAME "fontconfig" <START_VULN> #define PACKAGE_STRING "fontconfig 2 . 13 . 0"<END_VULN> #define PACKAGE_TARNAME "fontconfig"
<START_VULN> <END_VULN> void Quit ( ) ;
} else if ( ! strncmp ( token , "asr" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } <START_VULN> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <END_VULN> op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) {
double * blue_Z ) { if ( png_ptr != NULL && info_ptr != NULL && <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) ) <END_VULN> { png_debug1 ( 1 , "in % s retrieval function" , "cHRM_XYZ ( float ) " ) ;
specified via mprCreate will be called to allow global recovery . @remarks Do not mix calls to palloc and malloc . @ingroup MprMem <START_VULN> @stability Evolving<END_VULN> PUBLIC void * palloc ( size_t size ) ;
read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ; <START_VULN> return 0 ; <END_VULN> }
{ BGP_ATTR_AS_PATHLIMIT , "AS_PATHLIMIT" } , { BGP_ATTR_PMSI_TUNNEL , "PMSI_TUNNEL_ATTRIBUTE" } , { BGP_ATTR_ENCAP , "ENCAP" } , <START_VULN> #if ENABLE_BGP_VNC<END_VULN> { BGP_ATTR_VNC , "VNC" } , #endif { BGP_ATTR_LARGE_COMMUNITIES , "LARGE_COMMUNITY" } ,
JSObject * argv5 = JSVAL_TO_OBJECT ( argv [ 5 ] ) ; jsval js_width , js_height , js_data ; JS_GetProperty ( cx , argv5 , "width" , & js_width ) ; JS_GetProperty ( cx , argv5 , "height" , & js_height ) ; JS_GetProperty ( cx , argv5 , "data" , & js_data ) ; if ( js_width == JSVAL_VOID | | js_height == JSVAL_VOID | | <START_VULN> js_data == JSVAL_VOID ) <END_VULN> { xpc_qsThrowBadArg ( cx , NS_ERROR_FAILURE , vp , 5 ) ; return JS_FALSE ; } int32_t int_width , int_height ; JSObject * obj_data = JSVAL_TO_OBJECT ( js_data ) ; if ( ! JS_ValueToECMAInt32 ( cx , js_width , & int_width ) | | ! JS_ValueToECMAInt32 ( cx , js_height , & int_height ) )
strncpy ( ifr . ifr_name , TAP_IF_NAME , IFNAMSIZ ) ; <START_VULN> if ( ( err = ioctl ( fd , TUNSETIFF , ( void * ) & ifr ) ) < 0 ) <END_VULN> { BTIF_TRACE_DEBUG ( "ioctl error : % d , errno : % s" , err , strerror ( errno ) ) ; close ( fd ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : floor backend 0 implementation <START_VULN> last mod : $ Id : floor0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h> #include < string . h> #include < math . h> #include < oggogg . h> #include "vorbiscodec . h"
: 0 ; } bool isNative ( ) const { JS_ASSERT ( ! ( flags & NON_NATIVE ) == getObjectClass ( ) -> isNative ( ) ) ; return ! ( flags & NON_NATIVE ) ; } <START_VULN> const js : : Shape * previous ( ) const { <END_VULN> return parent ; } class Range { protected : friend struct Shape ; const Shape * cursor ;
intl_error_reset ( NULL TSRMLS_CC ) ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "s | s" , <START_VULN> & loc_name , & loc_name_len , <END_VULN> & disp_loc_name , & disp_loc_name_len ) == FAILURE ) { spprintf ( & msg , 0 , "locale_get_display_ % s : unable to parse input params" , tag_name ) ;
if ( cipher_def -> type == type_block ) { <START_VULN> const unsigned int blockSize = cipher_def -> iv_size ; <END_VULN> const unsigned int macSize = crSpec -> mac_size ; if ( crSpec -> version <= SSL_LIBRARY_VERSION_3_0 ) {
if ( elem == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "xmlParseElementMixedContentDecl : Name expected" ) ; <START_VULN> xmlFreeDocElementContent ( ctxt -> myDoc , cur ) ; <END_VULN> return ( NULL ) ; } SKIP_BLANKS ;
png_error ( png_ptr , "internal error handling cHRM -> XYZ" ) ; } } <START_VULN> #endif<END_VULN> #endif
{ cchar * value ; <START_VULN> value = mprLookupJson ( httpGetParams ( conn ) , var ) ; <END_VULN> return ( value ) ? ( int ) stoi ( value ) : defaultValue ; }
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 156 20181019 00 : 33 : 04 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
BuiltInFunctionEmulator builtInFunctionEmulator ; TInfoSink infoSink ;
png_error ( png_ptr , msg ) ; } } <START_VULN> #endif<END_VULN> #ifdef PNG_WARNINGS_SUPPORTED void PNGAPI
stub = phar_create_default_stub ( index , webindex , & stub_len , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; if ( stub ) { efree ( stub ) ;
int size ; syscall_nr = trace_get_syscall_nr ( current , regs ) ; <START_VULN> if ( syscall_nr < 0 ) <END_VULN> return ; if ( ! test_bit ( syscall_nr , enabled_perf_exit_syscalls ) ) return ; commit 086ba77a6db00ed858ff07451bedee197df868c9 Author : Rabin Vincent < rabin@rab . in> Date : Wed Oct 29 23 : 06 : 58 2014 + 0100 tracingsyscalls : Ignore numbers outside NR_syscalls' range ARM has some private syscalls ( for example , set_tls ( 2 ) ) which lie outside the range of NR_syscalls . If any of these are called while syscall tracing is being performed , out - of - bounds array access will occur in the ftrace and perf sys_ { enter , exit } handlers . # trace - cmd record - e raw_syscalls : * true && trace - cmd report . . . true - 653 [ 000 ] 384 . 675777 : sys_enter : NR 192 ( 0 , 1000 , 3 , 4000022 , ffffffff , 0 ) true - 653 [ 000 ] 384 . 675812 : sys_exit : NR 192 = 1995915264 true - 653 [ 000 ] 384 . 675971 : sys_enter : NR 983045 ( 76f74480 , 76f74000 , 76f74b28 , 76f74480 , 76f76f74 , 1 ) true - 653 [ 000 ] 384 . 675988 : sys_exit : NR 983045 = 0 . . . # trace - cmd record - e syscalls : * true [ 17 . 289329 ] Unable to handle kernel paging request at virtual address aaaaaace [ 17 . 289590 ] pgd = 9e71c000 [ 17 . 289696 ] [ aaaaaace ] * pgd = 00000000 [ 17 . 289985 ] Internal error : Oops : 5 [ #1 ] PREEMPT SMP ARM [ 17 . 290169 ] Modules linked in : [ 17 . 290391 ] CPU : 0 PID : 704 Comm : true Not tainted 3 . 18 . 0 - rc2 + #21 [ 17 . 290585 ] task : 9f4dab00 ti : 9e710000 task . ti : 9e710000 [ 17 . 290747 ] PC is at ftrace_syscall_enter + 0x480x1f8 [ 17 . 290866 ] LR is at syscall_trace_enter + 0x1240x184 Fix this by ignoring out - of - NR_syscalls - bounds syscall numbers . Commit cd0980fc8add "tracing : Check invalid syscall nr while tracing syscalls" added the check for less than zero , but it should have also checked for greater than NR_syscalls . Link : http :
if ( plugin_data ) { mnd_efree ( plugin_data ) ; } <START_VULN> <END_VULN> if ( ret == PASS ) { DBG_INF_FMT ( "saving requested_protocol = % s" , requested_protocol ) ; conn -> m -> set_client_option ( conn , MYSQLND_OPT_AUTH_PROTOCOL , requested_protocol TSRMLS_CC ) ;
public : <START_VULN> PlatformSensorAmbientLightMac ( mojo : : ScopedSharedBufferMapping mapping , <END_VULN> PlatformSensorProvider * provider ) ; mojom : : ReportingMode GetReportingMode ( ) override ;
return - 2 ; LOG ( LOG_ERR , ( " % s" , strerror ( errno ) ) ) ; <START_VULN> return - 1 ; <END_VULN> } if ( ret == 0 ) {
this_mv . as_mv . col = bc + neighbors [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <END_VULN> CHECK_BETTER } }
<START_VULN> void UpdateAppState ( content : : WebContents * tab , AppState app_state ) ; <END_VULN> void SetRefocusURLPattern ( ash : : LauncherID id , const GURL & url ) ;
namespace XrayUtils { extern JSClass HolderClass ; bool CloneExpandoChain ( JSContext * cx , JSObject * src , JSObject * dst ) ; bool <START_VULN> IsTransparent ( JSContext * cx , JSObject * wrapper ) ; <END_VULN> JSObject * GetNativePropertiesObject ( JSContext * cx , JSObject * wrapper ) ; } class XrayTraits ; class XPCWrappedNativeXrayTraits ;
char buff [ MAXPATHLEN ] ; char * filename ; zend_error_handling error_handling ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
return is_raw ; } <START_VULN> void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) { <END_VULN> fprintf ( stderr , " % d decoded frames % d showed frames in % "PRId64" us ( % . 2f fps ) r" , frame_in , frame_out , dx_time ,
case OPT_WRITE_BINLOG : add_option = FALSE ; break ; <START_VULN> <END_VULN> case 'h' : case 'W' : case 'P' :
#define IPC_MESSAGE_FORWARD ( msg_class , obj , member_func ) case msg_class : : ID : { <START_VULN> TRACK_RUN_IN_IPC_HANDLER ( member_func ) ; <END_VULN> if ( ! msg_class : : Dispatch ( & ipc_message__ , obj , this , param__ , & member_func ) ) ipc_message__ . set_dispatch_error ( ) ;
} <START_VULN> #endif<END_VULN>
if ( ! lf -> mode_ref_delta_enabled ) { <START_VULN> vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ; <END_VULN> } else { int ref , mode ; const int intra_lvl = lvl_seg + lf -> ref_deltas [ INTRA_FRAME ] * scale ;
void spellCheckingRequestProcessed ( int32_t transactionId , spannable_string_t * ) ; void spellCheckingRequestCancelled ( int32_t transactionId ) ; <START_VULN> bool shouldRequestSpellCheckingOptionsForPoint ( Platform : : IntPoint & , const WebCore : : Element * , imf_sp_text_t & ) ; <END_VULN> void requestSpellingCheckingOptions ( imf_sp_text_t & , WebCore : : IntSize & screenOffset , const bool shouldMoveDialog = false ) ; void clearDidSpellCheckState ( ) { m_didSpellCheckWord = false ; } void redrawSpellCheckDialogIfRequired ( const bool shouldMoveDialog = true ) ;
<START_VULN> static int CVE_2014_5472_isofs_read_inode ( struct inode * inode ) <END_VULN> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ;
<START_VULN> if ( transforms & PNG_TRANSFORM_GRAY_TO_RGB ) <END_VULN> #ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED png_set_gray_to_rgb ( png_ptr ) ; #else
static int CVE_2014_8546_cinepak_decode_vectors ( CinepakContext * s , cvid_strip * strip , int chunk_id , int size , const uint8_t * data ) { const uint8_t * eod = ( data + size ) ; uint32_t flag , mask ; uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; <START_VULN> unsigned int x , y ; <END_VULN> char * ip0 , * ip1 , * ip2 , * ip3 ; flag = 0 ; mask = 0 ; for ( y = strip -> y1 ; y < strip -> y2 ; y += 4 ) { ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ) ;
#define MagickPackageName "ImageMagick" #define MagickCopyright "Copyright ( C ) 1999 - 2015 ImageMagick Studio LLC" <START_VULN> #define MagickSVNRevision "18658 : 18662M"<END_VULN> #define MagickLibVersion 0x700 #define MagickLibVersionText "7 . 0 . 0" #define MagickLibVersionNumber 0 , 0 , 0
<START_VULN> if ( code ) { <END_VULN> if ( toktype == KG_TOK_SEAL_MSG ) gssalloc_free ( token . value ) ; * minor_status = 0 ;
#include < string . h> #include "allheaders . h" <START_VULN> static const l_int32 L_BUF_SIZE = 512 ; <END_VULN> static const char * version = "1 . 5" ;
if ( cpi -> oxcf . auto_key && <START_VULN> rc -> frames_to_key > ( int ) cpi -> key_frame_frequency ) { <END_VULN> FIRSTPASS_STATS tmp_frame = first_frame ; rc -> frames_to_key = 2 ;
break ; case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT : <START_VULN> if ( state & PNG_FP_SAW_DOT ) <END_VULN> png_fp_set ( state , PNG_FP_FRACTION | PNG_FP_SAW_DOT ) ; png_fp_add ( state , type | PNG_FP_WAS_VALID ) ;
png_inforp info_ptr ) , PNG_EMPTY ) ; # endif <START_VULN> #endif<END_VULN> #ifdef PNG_GAMMA_SUPPORTED
if ( i == ch ) return ( 0 ) ; for ( s = 0 ; s < look -> stages ; s ++ ) { for ( i = 0 , l = 0 ; i < partvals ; l ++ ) { if ( s == 0 ) { int temp = vorbis_book_decode ( look -> phrasebook , & vb -> opb ) ; <START_VULN> if ( temp == - 1 ) goto eopbreak ; <END_VULN> partword [ l ] = look -> decodemap [ temp ] ; if ( partword [ l ] == NULL ) goto errout ; } for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) if ( info -> secondstages [ partword [ l ] [ k ] ] & ( 1 << s ) ) { codebook * stagebook = look -> partbooks [ partword [ l ] [ k ] ] [ s ] ;
compact_pixels = ( unsigned char * ) NULL ; if ( next_image -> compression == RLECompression ) { <START_VULN> compact_pixels = AcquireCompactPixels ( image ) ; <END_VULN> if ( compact_pixels == ( unsigned char * ) NULL ) return ( 0 ) ; }
{ 10 , 7 , 6 } , } ; <START_VULN> static const vp9_prob default_inter_mode_probs [ INTER_MODE_CONTEXTS ] <END_VULN> [ INTER_MODES - 1 ] = { { 2 , 173 , 34 } , { 7 , 145 , 85 } ,
tstrip_t s , ns = TIFFNumberOfStrips ( in ) ; uint32 row = 0 ; _TIFFmemset ( buf , 0 , stripsize ) ; <START_VULN> for ( s = 0 ; s < ns ; s ++ ) { <END_VULN> tsize_t cc = ( row + rowsperstrip > imagelength ) ? TIFFVStripSize ( in , imagelength - row ) : stripsize ; if ( TIFFReadEncodedStrip ( in , s , buf , cc ) < 0
<START_VULN> length = ( MagickSizeType ) ReadBlobByte ( image ) ; <END_VULN> combined_length += length + 1 ; if ( length > 0 ) ( void ) ReadBlob ( image , ( size_t ) length ++ , layer_info [ i ] . name ) ;
return intpart ; } <START_VULN> static void<END_VULN> fmtfp ( char ** sbuffer , char ** buffer , size_t * currlen ,
perf_prepare_sample ( & header , data , event , regs ) ; <START_VULN> if ( perf_output_begin ( & handle , event , header . size , nmi , 1 ) ) <END_VULN> goto exit ; perf_output_sample ( & handle , & header , data , event ) ;
png_set_gamma_fixed ( png_ptr , convert_gamma_value ( png_ptr , scrn_gamma ) , convert_gamma_value ( png_ptr , file_gamma ) ) ; } <START_VULN> # endif<END_VULN> #endif #ifdef PNG_READ_EXPAND_SUPPORTED
{ sc_file_t * file ; int r , file_type ; <START_VULN> u8 files [ SC_MAX_APDU_BUFFER_SIZE ] ; <END_VULN> r = sc_lock ( card ) ; if ( r == SC_SUCCESS )
long index ; HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; <START_VULN> if ( ! offset ) { <END_VULN> return & EG ( uninitialized_zval_ptr ) ; }
CHECK_MEM_ERROR ( cpi -> active_map , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , sizeof ( * cpi -> active_map ) ) ) ; <START_VULN> vpx_memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <END_VULN> #if CONFIG_MULTITHREAD if ( width < 640 )
<START_VULN> if ( ! cpi -> dummy_packing && cpi -> sf . auto_mv_step_size ) { <END_VULN> unsigned int maxv = MAX ( abs ( mv -> row ) , abs ( mv -> col ) ) >> 3 ; cpi -> max_mv_magnitude = MAX ( maxv , cpi -> max_mv_magnitude ) ; }
#define yypact_value_is_default ( Yystate ) ( ! ! ( ( Yystate ) == ( - 73 ) ) ) <START_VULN> #define YYTABLE_NINF - 94<END_VULN> #define yytable_value_is_error ( Yytable_value ) 0
<START_VULN> class BASE_API LockImpl { <END_VULN> public : #if defined ( OS_WIN ) typedef CRITICAL_SECTION OSLockType ;
draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : - metrics . bounds . x1 , 0 . 0 ) , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0 . 0 ) ; <START_VULN> draw_info -> geometry = AcquireString ( geometry ) ; <END_VULN> status = AnnotateImage ( image , draw_info ) ; if ( image_info -> pointsize == 0 . 0 ) {
} <START_VULN> static int cost_segmap ( int * segcounts , vp9_prob * probs ) { <END_VULN> const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ; const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ; const int c45 = segcounts [ 4 ] + segcounts [ 5 ] ;
} sc_log_hex ( ctx , "ACL data" , file -> sec_attr , file -> sec_attr_len ) ; <START_VULN> for ( ii = 0 ; ii < file -> sec_attr_len 2 ; ii ++ ) { <END_VULN> unsigned char op = file -> type == SC_FILE_TYPE_DF ? ops_DF [ ii ] : ops_EF [ ii ] ; unsigned char acl = * ( file -> sec_attr + ii * 2 ) ; unsigned char cred_id = * ( file -> sec_attr + ii * 2 + 1 ) ;
return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } <START_VULN> #line 861 "extstandardvar_unserializer . c"<END_VULN> yy39 : yych = * ++ YYCURSOR ; if ( yych == ' + ' ) goto yy40 ;
{ struct n_tty_data * ldata = tty -> disc_data ; <START_VULN> if ( ! old | | ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <END_VULN> bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ; ldata -> line_start = ldata -> read_tail ; if ( ! L_ICANON ( tty ) | | ! read_cnt ( ldata ) ) {
switch ( crev ) { case 1 : tv_info = ( ATOM_ANALOG_TV_INFO * ) ( mode_info -> atom_context -> bios + data_offset ) ; <START_VULN> if ( index > MAX_SUPPORTED_TV_TIMING ) <END_VULN> return false ; mode -> crtc_htotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Total ) ;
else if ( row_info -> bit_depth == 16 ) { <START_VULN> if ( at_start ) <END_VULN> sp += 2 ; else sp += 8 , dp += 6 ;
static int cfm_network_addr_print ( netdissect_options * ndo , <START_VULN> register const u_char * tptr ) <END_VULN> { u_int network_addr_type ; u_int hexdump = FALSE ;
{ struct crypto_report_kpp rkpp ; <START_VULN> strlcpy ( rkpp . type , "kpp" , sizeof ( rkpp . type ) ) ; <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) )
namespace web { class NavigationItem ; <START_VULN> class NavigationManager ; <END_VULN> } @protocol CRWSSLStatusUpdaterDataSource ;
SPL_METHOD ( RecursiveDirectoryIterator , getSubPath ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <START_VULN> <END_VULN> ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; }
return CHANNEL_RC_NO_MEMORY ; } <START_VULN> if ( ! Stream_EnsureRemainingCapacity ( data_in , ( int ) dataLength ) ) <END_VULN> { WLog_Print ( drdynvc -> log , WLOG_ERROR , "Stream_EnsureRemainingCapacity failed ! " ) ; Stream_Free ( drdynvc -> data_in , TRUE ) ;
png_read_data ( png_ptr , crc_bytes , 4 ) ; <START_VULN> if ( need_crc ) <END_VULN> { crc = png_get_uint_32 ( crc_bytes ) ; return ( ( int ) ( crc != png_ptr -> crc ) ) ;
void SetProgressTime ( const base : : string16 & time ) ; void SetDuration ( const base : : string16 & duration ) ; <START_VULN> void HandleSeeking ( const gfx : : Point & location_in_bar ) ; <END_VULN> views : : ProgressBar * progress_bar_ ; views : : Label * progress_time_ ;
hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { if ( perf_swevent_match ( event , type , event_id , data , regs ) ) <START_VULN> perf_swevent_event ( event , nr , nmi , data , regs ) ; <END_VULN> } end : rcu_read_unlock ( ) ;
pthread_mutex_lock ( & client_socket_lock_ ) ; safe_close_ ( & client_socket_ ) ; client_socket_ = client_socket ; <START_VULN> send ( client_socket_ , "btsnoop0000100x3xea" , 16 , 0 ) ; <END_VULN> pthread_mutex_unlock ( & client_socket_lock_ ) ; }
{ int intent ; <START_VULN> if ( png_get_sRGB ( read_ptr , read_info_ptr , & intent ) ) <END_VULN> png_set_sRGB ( write_ptr , write_info_ptr , intent ) ; } #endif
have_shift = 1 ; } <START_VULN> if ( ! have_shift ) <END_VULN> return ; }
ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <START_VULN> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <END_VULN> #ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; #endif commit 9bfab35522301794483f8f9ed60820bdec9be59e Author : Richard Russon < rich@flatcap . org> Date : Thu Jul 5 13 : 32 : 17 2018 + 0100 sanitise cache paths Co - authored - by : JerikoOne < jeriko . one@gmx . us>
" non - zero code is returned ) . " , " 0x10 : The file could not be read , even with corrections . " , " 0x20 : The output file could not be written . " , <START_VULN> " 0x40 : An unexpected , potentially internal , error occured . " , <END_VULN> " If the command line arguments are incorrect the program exits with exit" , " 255 . Some older operating systems only support 7 - bit exit codes , on those" , " systems it is suggested that this program is first tested by supplying" ,
list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) <START_VULN> sas_eh_defer_cmd ( cmd ) ; <END_VULN> } }
{ vp8_dc_only_idct_add_mmx ( q [ 32 ] * dq [ 0 ] , dst + 8 , stride , dst + 8 , stride ) ; <START_VULN> vpx_memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <END_VULN> } if ( eobs [ 3 ] > 1 )
err_out : <START_VULN> qrio_set_gpio ( GPIO_A , CONF_SEL_L , 1 ) ; <END_VULN> toggle_fpga_eeprom_bus ( true ) ; return ret ;
fprintf ( stderr , "Unable to select public key file : % s" , sc_strerror ( r ) ) ; return 2 ; } <START_VULN> bufsize = file -> size ; <END_VULN> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) {
specified via mprCreate will be called to allow global recovery . @remarks Do not mix calls to prealloc and malloc . @ingroup MprMem <START_VULN> @stability Evolving<END_VULN> PUBLIC void * prealloc ( void * ptr , size_t size ) ;
int i , rec_no = 0 ; if ( prkey_info . path . len> = 2 ) prkey_info . path . len -= 2 ; sc_append_file_id ( & prkey_info . path , 0x5349 ) ; <START_VULN> if ( sc_select_file ( card , & prkey_info . path , NULL ) != SC_SUCCESS ) { <END_VULN> sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , "Select ( % s ) failed" , sc_print_path ( & prkey_info . path ) ) ;
bc + candidates [ s ] [ i ] . col } ; thissad = vfp -> sdf ( what -> buf , what -> stride , get_buf_from_mv ( in_what , & this_mv ) , <START_VULN> in_what -> stride , bestsad ) ; <END_VULN> CHECK_BETTER } } else {
<START_VULN> static void get_icu_value_src_php ( char * tag_name , INTERNAL_FUNCTION_PARAMETERS ) <END_VULN> { const char * loc_name = NULL ;
struct mlx5_ib_resources * devr = & dev -> devr ; int inlen = MLX5_ST_SZ_BYTES ( create_qp_in ) ; struct mlx5_core_dev * mdev = dev -> mdev ; <START_VULN> struct mlx5_ib_create_qp_resp resp ; <END_VULN> struct mlx5_ib_cq * send_cq ; struct mlx5_ib_cq * recv_cq ; unsigned long flags ;
mTrans -> mConnection -> SetSecurityCallbacks ( mCallbacks ) ; return NS_OK ; } private : nsRefPtr < nsHttpTransaction> mTrans ; nsCOMPtr < nsIInterfaceRequestor> mCallbacks ; } ; <START_VULN> Mutex mCallbacksLock ; <END_VULN> nsCOMPtr < nsIInterfaceRequestor> mCallbacks ; nsCOMPtr < nsITransportEventSink> mTransportSink ; nsCOMPtr < nsIEventTarget> mConsumerTarget ; nsCOMPtr < nsISupports> mSecurityInfo ; nsCOMPtr < nsIAsyncInputStream> mPipeIn ; nsCOMPtr < nsIAsyncOutputStream> mPipeOut ; nsCOMPtr < nsILoadGroupConnectionInfo> mLoadGroupCI ;
{ char * p1 , * p2 ; <START_VULN> <END_VULN> if ( intern -> file_name ) { efree ( intern -> file_name ) ; }
void removeWrapper ( js : : WrapperMap : : Ptr p ) { crossCompartmentWrappers . remove ( p ) ; } struct WrapperEnum : public js : : WrapperMap : : Enum { WrapperEnum ( JSCompartment * c ) : js : : WrapperMap : : Enum ( c -> crossCompartmentWrappers ) { } } ; <START_VULN> void mark ( JSTracer * trc ) ; <END_VULN> bool isDiscardingJitCode ( JSTracer * trc ) ; void sweep ( js : : FreeOp * fop , bool releaseTypes ) ; void sweepCrossCompartmentWrappers ( ) ; void purge ( ) ; void clearTables ( ) ; bool hasObjectMetadataCallback ( ) const { return objectMetadataCallback ; } void setObjectMetadataCallback ( js : : ObjectMetadataCallback callback ) ;
} ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type , <START_VULN> mntflags , mntdata , optional ) ; <END_VULN> free ( mntdata ) ;
#ifndef MOJO_EDK_EMBEDDER_SCOPED_PLATFORM_HANDLE_H_ #define MOJO_EDK_EMBEDDER_SCOPED_PLATFORM_HANDLE_H_ #include "basemacros . h" <START_VULN> #include "basemove . h"<END_VULN> #include "mojoedkembedderplatform_handle . h" #include "mojoedksystemsystem_impl_export . h" #include "mojopubliccsystemmacros . h"
bool isWritingModeRoot ( ) const { return ! parent ( ) | | parent ( ) -> style ( ) -> writingMode ( ) != style ( ) -> writingMode ( ) ; } <START_VULN> bool isDeprecatedFlexItem ( ) const { return ! isInline ( ) && ! isFloatingOrPositioned ( ) && parent ( ) && parent ( ) -> isDeprecatedFlexibleBox ( ) ; } <END_VULN> virtual LayoutUnit lineHeight ( bool firstLine , LineDirectionMode , LinePositionMode = PositionOnContainingLine ) const ; virtual LayoutUnit baselinePosition ( FontBaseline , bool firstLine , LineDirectionMode , LinePositionMode = PositionOnContainingLine ) const ;
return - 1 ; } <START_VULN> if ( header -> bDescriptorType == type ) { <END_VULN> * ptr = header ; return 0 ; }
int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <START_VULN> int is_rf64 = ! strncmp ( fourcc , "RF64" , 4 ) , got_ds64 = 0 ; <END_VULN> int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ;
return PNG_CHUNK_ANCILLARY ( PNG_U32 ( name [ 0 ] , name [ 1 ] , name [ 2 ] , name [ 3 ] ) ) ; } <START_VULN> #ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED<END_VULN> static int ancillaryb ( const png_byte * name ) {
data_encoding = P_sRGB ; <START_VULN> if ( output_format & PNG_FORMAT_FLAG_ALPHA ) <END_VULN> { if ( PNG_GA_COLORMAP_ENTRIES > image -> colormap_entries ) png_error ( png_ptr , "gray + alpha color - map : too few entries" ) ;
#define IPC_MESSAGE_FORWARD_DELAY_REPLY ( msg_class , obj , member_func ) case msg_class : : ID : { <START_VULN> TRACK_RUN_IN_IPC_HANDLER ( member_func ) ; <END_VULN> if ( ! msg_class : : DispatchDelayReply ( & ipc_message__ , obj , param__ , & member_func ) ) ipc_message__ . set_dispatch_error ( ) ;
imsx = 2048 ; imsy = 2048 ; <START_VULN> imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx * imsy , 1 ) ; <END_VULN> if ( imbuf == NULL ) { return ( MagickFalse ) ;
{ vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstu + 4 , stride , dstu + 4 , stride ) ; <START_VULN> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <END_VULN> } q += 32 ;
forward = sjoin ( forward , def , NULL ) ; for ( i = 0 ; i < fieldCount ; i ++ ) { <START_VULN> field = stok ( sclone ( fields [ i ] ) , " : " , & typeString ) ; <END_VULN> if ( ( type = ediParseTypeString ( typeString ) ) < 0 ) { fail ( "Unknown type ' % s' for field ' % s'" , typeString , field ) ; return ;
typedef ogg_int16_t vorbis_fpu_control ; static inline void vorbis_fpu_setround ( vorbis_fpu_control * fpu ) { ogg_int16_t ret ; ogg_int16_t temp ; __asm__ __volatile__ ( "fnstcw % 0t" "movw % 0 , % % dxt" <START_VULN> "orw $ 62463 , % % dxt"<END_VULN> "movw % % dx , % 1t" "fldcw % 1t" : " = m" ( ret ) : "m" ( temp ) : "dx" ) ; * fpu = ret ; } static inline void vorbis_fpu_restore ( vorbis_fpu_control fpu ) { __asm__ __volatile__ ( "fldcw % 0" : : "m" ( fpu ) ) ; }
nbchars = xmlCharEncFirstLineInput ( input -> buf , len ) ; } if ( nbchars < 0 ) { xmlErrInternal ( ctxt , "switching encoding : encoder error" , NULL ) ; return ( - 1 ) ; } input -> buf -> rawconsumed += use - xmlBufUse ( input -> buf -> raw ) ; <START_VULN> xmlBufResetInput ( input -> buf -> buffer , input ) ; <END_VULN> } return ( 0 ) ; } else if ( input -> length == 0 ) {
} } if ( action ) { <START_VULN> httpSetParam ( conn , "controller" , stok ( sclone ( rx -> target ) , " - " , & actionName ) ) ; <END_VULN> httpSetParam ( conn , "action" , actionName ) ; if ( eroute -> commonController ) { ( eroute -> commonController ) ( conn ) ;
typedef struct { <START_VULN> uchar * buf_ ; <END_VULN> size_t bufsize_ ;
char * msg ; } ; <START_VULN> <END_VULN> struct ikev2_auth { struct isakmp_gen h ; uint8_t auth_method ;
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
bits [ 1 ] = cpu_to_be64 ( sctx -> count [ 0 ] << 3 ) ; <START_VULN> bits [ 0 ] = cpu_to_be64 ( sctx -> count [ 1 ] << 3 ) | sctx -> count [ 0 ] >> 61 ; <END_VULN>
yych = * ++ YYCURSOR ; if ( yych != ' { ' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 678 "extstandardvar_unserializer . re"<END_VULN> { long elements = parse_iv ( start + 2 ) ;
{ void * buf ; <START_VULN> buf = g_malloc ( size ) ; <END_VULN> if ( object ) { g_signal_connect ( object , "postclose" ,
#define BGP_ATTR_ENCAP 23 #define BGP_ATTR_LARGE_COMMUNITIES 32 #define BGP_ATTR_PREFIX_SID 40 <START_VULN> #if ENABLE_BGP_VNC<END_VULN> #define BGP_ATTR_VNC 255 #endif
temp_in [ j ] = input [ j * stride + i ] * 4 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 16 ; ++ j ) <START_VULN> outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ; <END_VULN> }
png_ptr -> background . blue , g ) ; } <START_VULN> if ( gs_sig ) <END_VULN> { png_ptr -> background . red = png_gamma_correct ( png_ptr , png_ptr -> background . red , gs ) ;
<START_VULN> class FidlInterfaceRequest { <END_VULN> public : template < typename Interface> explicit FidlInterfaceRequest ( fidl : : InterfaceRequest < Interface> request )
<START_VULN> if ( ( int ) size > cdigits ) <END_VULN> { while ( cdigits > 0 ) * ascii ++ = exponent [ -- cdigits ] ;
bond_dev -> tx_queue_len = 0 ; bond_dev -> flags |= IFF_MASTER | IFF_MULTICAST ; bond_dev -> priv_flags |= IFF_BONDING ; <START_VULN> bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <END_VULN>
<START_VULN> Copyright ( c ) 2010 - 2014 , The Linux Foundation . All rights reserved . <END_VULN> Redistribution and use in source and binary forms , with or without modification , are permitted provided that the following conditions are
int cipher_len , key_len , data_len , iv_len = 0 ; MCRYPT_GET_CRYPT_ARGS <START_VULN> <END_VULN> convert_to_string_ex ( mode ) ; php_mcrypt_do_crypt ( cipher , key , key_len , data , data_len , Z_STRVAL_PP ( mode ) , iv , iv_len , ZEND_NUM_ARGS ( ) , MCRYPT_DECRYPT , return_value TSRMLS_CC ) ;
png_free ( png_ptr , png_ptr -> big_row_buf ) ; png_free ( png_ptr , png_ptr -> big_prev_row ) ; <START_VULN> if ( png_ptr -> interlaced ) <END_VULN> png_ptr -> big_row_buf = ( png_bytep ) png_calloc ( png_ptr , row_bytes + 48 ) ;
unsigned short bcache = 1 ; <START_VULN> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; <END_VULN> if ( msg -> fp ) return 0 ;
ret = btrfs_insert_dir_item ( trans , root , name , name_len , parent_inode , & key , btrfs_inode_type ( inode ) , index ) ; <START_VULN> if ( ret == - EEXIST ) <END_VULN> goto fail_dir_item ; else if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ;
cap . descr_num = 16 ; cap . descr_type = CA_ECD ; memcpy ( parg , & cap , sizeof ( cap ) ) ; break ; } case CA_GET_SLOT_INFO : { ca_slot_info_t * info = ( ca_slot_info_t * ) parg ; <START_VULN> if ( info -> num > 1 ) <END_VULN> return - EINVAL ; av7110 -> ci_slot [ info -> num ] . num = info -> num ; av7110 -> ci_slot [ info -> num ] . type = FW_CI_LL_SUPPORT ( av7110 -> arm_app ) ? CA_CI_LINK : CA_CI ; memcpy ( info , & av7110 -> ci_slot [ info -> num ] , sizeof ( ca_slot_info_t ) ) ; break ; } case CA_GET_MSG : break ;
retval = * rc ; } out : <START_VULN> return retval ; <END_VULN> }
} } } else { <START_VULN> for ( i = 0 ; i < sec -> size ; i += 8 ) { <END_VULN> ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ;
* <START_VULN> if ( do_local_background ) <END_VULN> { png_fixed_point gtest ;
static int CVE_2012_1183_milliwatt_generate ( struct ast_channel * chan , void * data , int len , int samples ) { unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; <START_VULN> const int maxsamples = ARRAY_LEN ( buf ) ; <END_VULN> int i , * indexp = ( int * ) data ; struct ast_frame wf = { . frametype = AST_FRAME_VOICE , . offset = AST_FRIENDLY_OFFSET , . src = __FUNCTION__ , } ; ast_format_set ( & wf . subclass . format , AST_FORMAT_ULAW , 0 ) ; wf . data . ptr = buf + AST_FRIENDLY_OFFSET ;
uint32 colb = 0 ; uint32 col ; <START_VULN> for ( col = 0 ; col < imagewidth ; col += tw ) { <END_VULN>
variable -> fragment = container ; <START_VULN> container -> psvi = XSLT_RVT_VARIABLE ; <END_VULN> oldOutput = ctxt -> output ; oldInsert = ctxt -> insert ;
( 17 - 126 * mul + 273 * mul2 - 164 * mul3 ) 12096 , } ; <START_VULN> double mat_freq [ 13 ] ; <END_VULN> memcpy ( mat_freq , kernel , sizeof ( kernel ) ) ; memset ( mat_freq + 4 , 0 , sizeof ( mat_freq ) - sizeof ( kernel ) ) ; int n = 6 ;
EVP_MD_CTX_free ( hmac ) ; return - 1 ; } <START_VULN> if ( ! send && ! SSL_USE_ETM ( ssl ) && FIPS_mode ( ) ) <END_VULN> if ( ! tls_fips_digest_extra ( ssl -> enc_read_ctx , mac_ctx , rec -> input , rec -> length , rec -> orig_len ) ) {
} } <START_VULN> intra_pred_var = vp8_get_mb_ss ( x -> src_diff ) ; <END_VULN> return intra_pred_var ; }
int flags = 0 ; Elf32_Ehdr elf32hdr ; Elf64_Ehdr elf64hdr ; <START_VULN> uint16_t type , phnum , shnum ; <END_VULN> if ( ms -> flags & ( MAGIC_MIME | MAGIC_APPLE ) ) return 0 ;
REGISTER_SPL_CLASS_CONST_LONG ( SplFileObject , "READ_AHEAD" , SPL_FILE_OBJECT_READ_AHEAD ) ; REGISTER_SPL_CLASS_CONST_LONG ( SplFileObject , "SKIP_EMPTY" , SPL_FILE_OBJECT_SKIP_EMPTY ) ; REGISTER_SPL_CLASS_CONST_LONG ( SplFileObject , "READ_CSV" , SPL_FILE_OBJECT_READ_CSV ) ; <START_VULN> <END_VULN> REGISTER_SPL_SUB_CLASS_EX ( SplTempFileObject , SplFileObject , spl_filesystem_object_new_check , spl_SplTempFileObject_functions ) ; return SUCCESS ; }
else if ( ! ctx -> iface -> enc . get_glob_hdrs ) ctx -> err = VPX_CODEC_INCAPABLE ; else <START_VULN> buf = ctx -> iface -> enc . get_glob_hdrs ( ctx -> priv -> alg_priv ) ; <END_VULN> } return buf ;
JS_STATIC_ASSERT ( sizeof ( JSValueTag ) == 4 ) ; JS_STATIC_ASSERT ( sizeof ( JSBool ) == 4 ) ; JS_STATIC_ASSERT ( sizeof ( JSWhyMagic ) <= 4 ) ; JS_STATIC_ASSERT ( sizeof ( Value ) == 8 ) ; } friend jsval_layout ( : : JSVAL_TO_IMPL ) ( Value ) ; friend Value ( : : IMPL_TO_JSVAL ) ( jsval_layout l ) ; <START_VULN> } JSVAL_ALIGNMENT ; <END_VULN> inline bool IsPoisonedValue ( const Value & v ) { if ( v . isString ( ) ) return IsPoisonedPtr ( v . toString ( ) ) ; if ( v . isObject ( ) ) return IsPoisonedPtr ( & v . toObject ( ) ) ;
<START_VULN> #define VERSION "2 . 13 . 0"<END_VULN>
#include < new> #include "baselogging . h" <START_VULN> #include "basemove . h"<END_VULN> #include "mojopubliccppbindingstype_converter . h" namespace mojo {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : registry for time , floor , res backends and channel mappings <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_REG_H_ #define _V_REG_H_ #define VI_TRANSFORMB 1 #define VI_WINDOWB 1
return ; } <START_VULN> phar_file_stat ( filename , ( php_stat_len ) filename_len , funcnum , PHAR_G ( orig ) , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; <END_VULN> } }
case DECODE_TUNNEL_ERSPAN : return DecodeERSPAN ( tv , dtv , p , pkt , len , pq ) ; default : <START_VULN> SCLogInfo ( "FIXME : DecodeTunnel : protocol % " PRIu32 " not supported . " , proto ) ; <END_VULN> break ; } return TM_ECODE_OK ;
route = state -> route ; tok = sclone ( value ) ; while ( ( option = maGetNextArg ( tok , & tok ) ) != 0 ) { <START_VULN> option = stok ( option , " = t , " , & ovalue ) ; <END_VULN> ovalue = strim ( ovalue , ""'" , MPR_TRIM_BOTH ) ; if ( scaselessmatch ( option , "origin" ) ) { route -> corsOrigin = sclone ( ovalue ) ;
b ++ ; } if ( lines ) <START_VULN> last = RCAST ( const char * , s ) + nbytes ; <END_VULN> ms -> search . s = buf ; ms -> search . s_len = last - buf ;
fclose ( orig ) ; fclose ( recons ) ; <START_VULN> if ( diffs != 0 ) <END_VULN> { return XD3_INTERNAL ; }
DISALLOW_COPY_AND_ASSIGN ( DevToolsAgentFilter ) ; } ; <START_VULN> #endif<END_VULN>
if ( newbest ) { best_rd = rd ; <START_VULN> * best_filter = mbmi -> interp_filter ; <END_VULN> if ( cm -> interp_filter == SWITCHABLE && i && ! intpel_mv ) best_needs_copy = ! best_needs_copy ; }
NS_DECL_ISUPPORTS NS_DECL_NSIWEBGLPROGRAM protected : WebGLuint mName ; PRPackedBool mDeleted ; PRPackedBool mDeletePending ; PRPackedBool mLinkStatus ; <START_VULN> nsTArray < WebGLShader * > mAttachedShaders ; <END_VULN> CheckedUint32 mGeneration ; nsRefPtrHashtable < nsUint32HashKey , WebGLUniformLocation> mMapUniformLocations ; GLint mUniformMaxNameLength ; GLint mAttribMaxNameLength ; GLint mUniformCount ; GLint mAttribCount ;
#include < jni . h> #include "baseandroidscoped_java_ref . h" <START_VULN> #include "basemove . h"<END_VULN> #include "uiglgl_export . h" namespace gl {
@param lastIndex Pointer to an integer that will hold the last index retrieved . @ingroup MprList @internal <START_VULN> @stability Evolving<END_VULN> PUBLIC void * mprGetNextStableItem ( MprList * list , int * lastIndex ) ;
struct OpenManifestEntryResource { public : <START_VULN> OpenManifestEntryResource ( std : : string target_url , <END_VULN> int32_t * descp , ErrorInfo * infop , bool * portablep ,
#ifdef PNG_16BIT_SUPPORTED #if defined ( PNG_READ_SWAP_SUPPORTED ) | | defined ( PNG_WRITE_SWAP_SUPPORTED ) <START_VULN> <END_VULN> void png_do_swap ( png_row_infop row_info , png_bytep row ) {
#ifdef PPM_SUPPORTED JMESSAGE ( JERR_PPM_COLORSPACE , "PPM output must be grayscale or RGB" ) JMESSAGE ( JERR_PPM_NONNUMERIC , "Nonnumeric data in PPM file" ) <START_VULN> JMESSAGE ( JERR_PPM_TOOLARGE , "Integer value too large in PPM file" ) <END_VULN> JMESSAGE ( JERR_PPM_NOT , "Not a PPMPGM file" ) JMESSAGE ( JTRC_PGM , " % ux % u PGM image" ) JMESSAGE ( JTRC_PGM_TEXT , " % ux % u text PGM image" ) JMESSAGE ( JTRC_PPM , " % ux % u PPM image" )
sslSessionID * sid = ss -> sec . ci . sid ; if ( sid -> peerCert == NULL ) { PORT_Memcpy ( sid -> u . ssl2 . sessionID , s , sizeof ( sid -> u . ssl2 . sessionID ) ) ; sid -> peerCert = CERT_DupCertificate ( ss -> sec . peerCert ) ; } <START_VULN> if ( ! ss -> opt . noCache ) <END_VULN> ( * ss -> sec . cache ) ( sid ) ; } static SECStatus ssl2_TriggerNextMessage ( sslSocket * ss ) { SECStatus rv ;
DISALLOW_COPY_AND_ASSIGN ( FileEnumerator ) ; } ; <START_VULN> class MemoryMappedFile { <END_VULN> public : MemoryMappedFile ( ) ;
offset += 3 ; length -= 3 ; <START_VULN> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <END_VULN> offset += tim . length - 3 ; length -= tim . length - 3 ;
tm -> tm_sec = 0 ; fsec = 0 ; <START_VULN> if ( strlen ( str ) > = sizeof ( lowstr ) ) <END_VULN> { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ;
nsIRunnable * mPendingInstantiateEvent ; nsCString mContentType ; <START_VULN> nsIChannel * mChannel ; <END_VULN> nsCOMPtr < nsIURI> mURI ; ObjectType mType : 16 ;
* <START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 89 ) <END_VULN> extern JSBool js_XDRAtom ( JSXDRState * xdr , JSAtom ** atomp ) ; JS_END_EXTERN_C
InstallNewDocumentReason , ParserSynchronizationPolicy , const KURL & overriding_url ) ; <START_VULN> void DidInstallNewDocument ( Document * ) ; <END_VULN> void WillCommitNavigation ( ) ; void DidCommitNavigation ( WebGlobalObjectReusePolicy ) ;
return 0 ; } for ( option = maGetNextArg ( options , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { <START_VULN> option = stok ( option , " = t , " , & ovalue ) ; <END_VULN> ovalue = strim ( ovalue , ""'" , MPR_TRIM_BOTH ) ; if ( ! ovalue | | * ovalue == '0' ) continue ; if ( smatch ( option , "visible" ) ) {
} <START_VULN> static inline void realpath_cache_add ( const char * path , int path_len , const char * realpath , int realpath_len , int is_dir , time_t t ) <END_VULN> { zend_long size = sizeof ( realpath_cache_bucket ) + path_len + 1 ; int same = 1 ;
void png_reset_crc ( png_structrp png_ptr ) { <START_VULN> <END_VULN> png_ptr -> crc = ( png_uint_32 ) crc32 ( 0 , Z_NULL , 0 ) ; }
static inline Quantum GetPixelChannel ( const Image * magick_restrict image , const PixelChannel channel , const Quantum * magick_restrict pixel ) { <START_VULN> if ( image -> channel_map [ channel ] . traits == UndefinedPixelTrait ) <END_VULN> return ( ( Quantum ) 0 ) ; return ( pixel [ image -> channel_map [ channel ] . offset ] ) ; }
status = QuantizeImage ( quantize_info , image ) ; quantize_info = DestroyQuantizeInfo ( quantize_info ) ; } <START_VULN> image -> colors = 2 ; <END_VULN> image -> matte = MagickFalse ; break ; }
} yy63 : ++ YYCURSOR ; <START_VULN> #line 599 "extstandardvar_unserializer . re"<END_VULN> { #if SIZEOF_LONG == 4 use_double :
} int res_inverse ( vorbis_dsp_state * vd , vorbis_info_residue * info , <START_VULN> ogg_int32_t ** in , int * nonzero , int ch ) { <END_VULN> int i , j , k , s , used = 0 ; codec_setup_info * ci = ( codec_setup_info * ) vd -> vi -> codec_setup ;
* bool NS_FASTCALL SetCapacity ( size_type newCapacity ) ; <START_VULN> void NS_FASTCALL SetLength ( size_type newLength ) ; <END_VULN> void Truncate ( size_type newLength = 0 ) { NS_ASSERTION ( newLength <= mLength , "Truncate cannot make string longer" ) ; SetLength ( newLength ) ; }
} <START_VULN> #endif<END_VULN>
phar_flush ( phar , 0 , 0 , 1 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; efree ( oldpath ) ; return NULL ;
virtual void OnConfigWatcherError ( ) OVERRIDE ; <START_VULN> virtual void OnChannelConnected ( ) OVERRIDE ; <END_VULN> virtual bool OnMessageReceived ( const IPC : : Message & message ) OVERRIDE ; virtual void OnPermanentError ( ) OVERRIDE ;
inflateEnd ( & zip -> stream ) ; #endif <START_VULN> #if HAVA_LZMA_H && HAVE_LIBLZMA<END_VULN> if ( zip -> zipx_lzma_valid ) { lzma_end ( & zip -> zipx_lzma_stream ) ; }
num_new_palette -- ; palette [ png_ptr -> index_to_palette [ j ] ] = palette [ num_new_palette ] ; <START_VULN> if ( ! full_quantize ) <END_VULN> { int k ;
return hdrlen ; } if ( ndo -> ndo_vflag ) <START_VULN> ND_PRINT ( ( ndo , " % 04x : % 04x " , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; <END_VULN> p += 2 ; caplen -= 2 ; hdrlen += 2 ;
{ struct crypto_report_akcipher rakcipher ; <START_VULN> strlcpy ( rakcipher . type , "akcipher" , sizeof ( rakcipher . type ) ) ; <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) )
typedef int16_t interp_kernel [ INTERP_TAPS ] ; <START_VULN> const interp_kernel vp9_filteredinterp_filters500 [ ( 1 << SUBPEL_BITS ) ] = { <END_VULN> { - 3 , 0 , 35 , 64 , 35 , 0 , - 3 , 0 } , { - 3 , - 1 , 34 , 64 , 36 , 1 , - 3 , 0 } , { - 3 , - 1 , 32 , 64 , 38 , 1 , - 3 , 0 } ,
} else { mdecrypt_generic ( td , data_s , data_size ) ; } <START_VULN> <END_VULN> RETVAL_STRINGL ( data_s , data_size , 1 ) ;
LOG ( LOG_INFO , ( "EOF reading packet len" ) ) ; <START_VULN> return - 1 ; <END_VULN> } len_buf_pos += ret ;
unsigned char decrypted [ sizeof ( VP8_BD_VALUE ) + 1 ] ; if ( br -> decrypt_cb ) { <START_VULN> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <END_VULN> br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ; bufptr = decrypted ; }
uid = userToID ( owner ) ; } } <START_VULN> group = stok ( tok , " : " , & perms ) ; <END_VULN> if ( group && * group ) { if ( snumber ( group ) ) { gid = ( int ) stoi ( group ) ;
int type , nparams ; if ( png_get_pCAL ( read_ptr , read_info_ptr , & purpose , & X0 , & X1 , & type , <START_VULN> & nparams , & units , & params ) ) <END_VULN> { png_set_pCAL ( write_ptr , write_info_ptr , purpose , X0 , X1 , type , nparams , units , params ) ;
memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , devname , IFNAMSIZ - 1 ) ; <START_VULN> err = ioctl ( sk , SIOCGIFHWADDR , & ifr ) ; <END_VULN> if ( err < 0 ) { BTIF_TRACE_ERROR ( "Could not get network hardware for interface : % s , errno : % s" , devname , strerror ( errno ) ) ;
int vp9_rc_bits_per_mb ( FRAME_TYPE frame_type , int qindex , <START_VULN> double correction_factor ) ; <END_VULN> int vp9_rc_clamp_iframe_target_size ( const struct VP9_COMP * const cpi ,
public : ObjectElements ( uint32_t capacity , uint32_t length ) <START_VULN> : capacity ( capacity ) , initializedLength ( 0 ) , length ( length ) <END_VULN> { } HeapSlot * elements ( ) { return ( HeapSlot * ) ( uintptr_t ( this ) + sizeof ( ObjectElements ) ) ; }
num_trans = 0 ; output_processing = PNG_CMAP_NONE ; <START_VULN> data_encoding = P_FILE ; <END_VULN> cmap_entries = png_ptr -> num_palette ; if ( cmap_entries > 256 ) cmap_entries = 256 ;
vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; <START_VULN> <END_VULN> snprintf ( str , sizeof ( str ) , " v % i , v % i , 0x % 08"PFMT64x , vA , vB , a -> pc + ( vC * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ;
<START_VULN> if ( ! ( png_ptr -> flags & PNG_FLAG_ROW_INIT ) ) <END_VULN> png_read_start_row ( png_ptr ) ;
register ssize_t i ; <START_VULN> for ( i = 0 ; i < ( ssize_t ) GetPixelChannels ( Cr_image ) ; i ++ ) <END_VULN> { switch ( op ) {
<START_VULN> <END_VULN> * above_y |= above_prediction_mask [ block_size ] << shift_y ; * above_uv |= above_prediction_mask_uv [ block_size ] << shift_uv ;
<START_VULN> if ( full_quantize ) <END_VULN> { int j = num_palette ;
assert ( alarm_timer != NULL ) ; assert ( config != NULL ) ; <START_VULN> alarm_set ( alarm_timer , CONFIG_SETTLE_PERIOD_MS , timer_config_save , NULL ) ; <END_VULN> } void btif_config_flush ( void ) {
ui4_payload_size = 0 ; u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <START_VULN> while ( 0xff == u4_bits ) <END_VULN> { u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; ui4_payload_size += 255 ;
return ; } <START_VULN> static int isofs_read_inode ( struct inode * ) ; <END_VULN> static int isofs_statfs ( struct dentry * , struct kstatfs * ) ; static struct kmem_cache * isofs_inode_cachep ;
static void set_segment_data ( VP8_COMP * cpi , signed char * feature_data , unsigned char abs_delta ) { cpi -> mb . e_mbd . mb_segement_abs_delta = abs_delta ; <START_VULN> vpx_memcpy ( cpi -> segment_feature_data , feature_data , sizeof ( cpi -> segment_feature_data ) ) ; <END_VULN> }
} #endif <START_VULN> #ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED<END_VULN> static png_uint_32 get_unknown ( display * d , png_infop info_ptr , int after_IDAT ) {
static void AcknowledgeBufferPresent ( int32 route_id , int gpu_host_id , <START_VULN> bool presented , <END_VULN> uint32 sync_point ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : bitrate tracking and management <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_BITRATE_H_ #define _V_BITRATE_H_ #include "vorbiscodec . h" #include "codec_internal . h"
} } else { #ifdef DEBUG fprintf ( stderr , "dissect_wtp : ( 4 ) tree was % p" , tree ) ; #endif } if ( fCon ) { unsigned char tCon ; unsigned char tByte ; <START_VULN> unsigned char tpiLen ; <END_VULN> tvbuff_t * tmp_tvb ; vHeader = 0 ; do { tByte = tvb_get_guint8 ( tvb , offCur + cbHeader + vHeader ) ; tCon = tByte & 0x80 ; if ( tByte & 0x04 ) tpiLen = 2 + tvb_get_guint8 ( tvb , offCur + cbHeader + vHeader + 1 ) ;
if ( ( entry -> flags & SC_ASN1_UNSIGNED ) <START_VULN> && obj [ 0 ] == 0x00 && objlen > 1 ) { <END_VULN> objlen -- ; obj ++ ; }
if ( j == - 1 ) { <START_VULN> return ERROR_INV_SPS_PPS_T ; <END_VULN> }
int yy_bs_column ; <START_VULN> <END_VULN>
} <START_VULN> if ( ! preferred ) <END_VULN> return 1 ; }
signal ( SIGTERM , cleanup_handler ) ; nalloc = 0 ; <START_VULN> if ( pledge ( "stdio cpath unix id proc exec" , NULL ) == - 1 ) <END_VULN> fatal ( " % s : pledge : % s" , __progname , strerror ( errno ) ) ; while ( 1 ) {
return FALSE ; } sock_cmd_t cmd = { CMD_EXIT , 0 , 0 , 0 , 0 } ; <START_VULN> if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ) <END_VULN> { pthread_join ( ts [ h ] . thread_id , 0 ) ; pthread_mutex_lock ( & thread_slot_lock ) ;
{ vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dst + 4 , stride , dst + 4 , stride ) ; <START_VULN> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <END_VULN> } if ( eobs [ 2 ] > 1 )
this_offset = base_offset + ( br * ( pre_stride ) ) + bc ; this_mv . as_mv . row = br ; this_mv . as_mv . col = bc ; <START_VULN> bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , UINT_MAX ) <END_VULN> + mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; #if CONFIG_MULTI_RES_ENCODING
JS_BEGIN_EXTERN_C extern JSClass js_MathClass ; extern JSObject * js_InitMathClass ( JSContext * cx , JSObject * obj ) ; extern void <START_VULN> js_InitRandom ( JSThreadData * data ) ; <END_VULN> extern JSBool js_math_ceil ( JSContext * cx , uintN argc , jsval * vp ) ; extern JSBool js_math_floor ( JSContext * cx , uintN argc , jsval * vp ) ; extern JSBool
{ unsigned stage1_idx = ENT_STAGE1_INDEX ( k ) ; const entity_stage3_row * c ; <START_VULN> <END_VULN> if ( stage1_idx > 0x1D ) { * entity = NULL ; * entity_len = 0 ;
if ( offset > = ( size_t ) bufsize ) break ; offset = donote ( ms , nbuf , offset , ( size_t ) bufsize , <START_VULN> clazz , swap , 4 , flags ) ; <END_VULN> if ( offset == 0 ) break ;
void H264SwDecTrace ( char * ) ; <START_VULN> void * H264SwDecMalloc ( u32 size ) ; <END_VULN> void H264SwDecFree ( void * ptr ) ;
<START_VULN> if ( png_colorspace_endpoints_match ( xy , & sRGB_xy , 1000 ) ) <END_VULN> colorspace -> flags |= PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB ; else
<START_VULN> if ( ( length > 0 ) | | ( png_ptr -> mode & PNG_HAVE_CHUNK_AFTER_IDAT ) ) <END_VULN> png_benign_error ( png_ptr , "Too many IDATs found" ) ; png_crc_finish ( png_ptr , length ) ;
"only allowed for add and delete group modifications" ) ; return OFPERR_OFPBPC_BAD_VALUE ; default : <START_VULN> OVS_NOT_REACHED ( ) ; <END_VULN> } if ( payload -> size < sizeof * prop ) {
protected : virtual void InitInternal ( ) ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal ( ) ;
int re_yyget_lineno ( yyscan_t yyscanner ) { struct yyguts_t * yyg = ( struct yyguts_t * ) yyscanner ; <START_VULN> <END_VULN> if ( ! YY_CURRENT_BUFFER ) return 0 ;
@param str String containing white space or comma separated words @return Returns a list of words @ingroup MprList <START_VULN> @stability Evolving<END_VULN> PUBLIC MprList * mprCreateListFromWords ( cchar * str ) ;
} <START_VULN> class ExtensionInfoBar : public InfoBar , <END_VULN> public ExtensionView : : Container , public ImageLoadingTracker : : Observer , public ExtensionInfoBarDelegate : : DelegateObserver ,
JSAMPROW pixrow ; size_t buffer_width ; JSAMPLE * rescale ; <START_VULN> int maxval ; <END_VULN> } ppm_source_struct ; typedef ppm_source_struct * ppm_source_ptr ;
goto err ; } <START_VULN> len = file ? file -> size : 4096 ; <END_VULN> p = realloc ( * data , len ) ; if ( ! p ) { goto err ;
sa = sarrayCreate ( 0 ) ; sarrayAddString ( sa , ( char * ) " * " , L_COPY ) ; <START_VULN> snprintf ( buf , L_BUF_SIZE , <END_VULN> " * These prototypes were autogen'd by xtractprotos , v . % s" , version ) ; sarrayAddString ( sa , buf , L_COPY ) ;
png_write_chunk_data ( png_ptr , new_key , key_len + 1 ) ; <START_VULN> if ( text_len ) <END_VULN> png_write_chunk_data ( png_ptr , ( png_const_bytep ) text , text_len ) ; png_write_chunk_end ( png_ptr ) ;
replace_value = & empty_replace ; } } <START_VULN> <END_VULN> if ( ( result = php_pcre_replace ( Z_STRVAL_PP ( regex_entry ) ,
{ * q ++ = ( unsigned char ) ( GetPixelLuma ( image , p ) > = ( QuantumRange2 . 0 ) ? '0' : '1' ) ; <START_VULN> * q ++ = ' ' ; <END_VULN> if ( ( q - pixels + 1 ) > = ( ssize_t ) sizeof ( pixels ) ) { * q ++ = '' ; ( void ) WriteBlob ( image , q - pixels , pixels ) ; q = pixels ; } p += GetPixelChannels ( image ) ; } * q ++ = '' ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis backend and mapping structures ; needed for static mode headers <START_VULN> last mod : $ Id : backends . h 16326 2009 - 07 - 24 00 : 06 : 53Z xiphmont $ <END_VULN> #ifndef _vorbis_backend_h_
const struct ikev2_n * p ; struct ikev2_n n ; const u_char * cp ; <START_VULN> u_char showspi , showdata , showsomedata ; <END_VULN> const char * notify_name ; uint32_t type ;
} return ; trunc : <START_VULN> ND_PRINT ( ( ndo , "tt packet exceeded snapshot" ) ) ; <END_VULN> }
bool browser_only_ = false ; base : : flat_map < std : : string , std : : unique_ptr < protocol : : DevToolsDomainHandler >> handlers_ ; <START_VULN> RenderProcessHost * process_ ; <END_VULN> RenderFrameHostImpl * host_ ; std : : unique_ptr < protocol : : UberDispatcher> dispatcher_ ;
break ; case 5 : <START_VULN> if ( ( png_ptr -> row_number & 0x01 ) | | png_ptr -> width < 2 ) <END_VULN> { png_write_finish_row ( png_ptr ) ; return ;
# if defined ( PNG_READ_SUPPORTED ) && defined ( PNG_WRITE_SUPPORTED ) <START_VULN> if ( png_ptr -> mode & PNG_IS_READ_STRUCT ) <END_VULN> # endif # ifdef PNG_READ_SUPPORTED
WebsiteSettings ( WebsiteSettingsUI * ui , Profile * profile , TabSpecificContentSettings * tab_specific_content_settings , <START_VULN> InfoBarService * infobar_service , <END_VULN> const GURL & url , const content : : SSLStatus & ssl , content : : CertStore * cert_store ) ;
return 1 ; } } <START_VULN> #endif<END_VULN> void
if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; <START_VULN> return ( ( Image * ) NULL ) ; <END_VULN> } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) ,
vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <START_VULN> sprintf ( str , " { v % i . . v % i } , [ % 04x ] " , vC , vC + vA - 1 , vB ) ; <END_VULN> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinvokeVS :
return ; trunc : <START_VULN> ND_PRINT ( ( ndo , " [ | icmp6 ] " ) ) ; <END_VULN> } static void
virtual void TabInsertedAt ( content : : WebContents * contents , int model_index , bool is_active ) OVERRIDE ; <START_VULN> virtual void TabDetachedAt ( TabContents * contents , <END_VULN> int model_index ) OVERRIDE ; virtual void TabSelectionChanged ( TabStripModel * tab_strip_model ,
size = ( sizeof ( macroblockLayer_t ) + 63 ) & ~ 0x3F ; <START_VULN> pStorage -> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size ) ; <END_VULN> if ( ! pStorage -> mbLayer ) return HANTRO_NOK ;
case ESIS_OPTION_PROTOCOLS : while ( opli>0 ) { <START_VULN> ND_TCHECK ( * pptr ) ; <END_VULN> ND_PRINT ( ( ndo , " % s ( 0x % 02x ) " , tok2str ( nlpid_values , "unknown" ,
si -> w = 0 ; si -> h = 0 ; <START_VULN> res = ctx -> iface -> dec . get_si ( ctx -> priv -> alg_priv , si ) ; <END_VULN> } return SAVE_STATUS ( ctx , res ) ;
this -> sd = - 1 ; this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ; if ( this -> sd < 0 ) { <START_VULN> ERR ( "sockect open failed" ) ; <END_VULN> goto error ; }
static void <START_VULN> store_pool_error ( png_store * ps , png_const_structp pp , PNG_CONST char * msg ) <END_VULN> { if ( pp != NULL ) png_error ( pp , msg ) ;
return ; #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED <START_VULN> if ( png_ptr -> transformations & PNG_USER_TRANSFORM ) <END_VULN> if ( png_ptr -> write_user_transform_fn != NULL ) ( * ( png_ptr -> write_user_transform_fn ) )
rdr : : OutStream * os ; SMsgReader * reader_ ; SMsgWriter * writer_ ; <START_VULN> SecurityServer * security ; <END_VULN> SSecurity * ssecurity ; stateEnum state_ ; rdr : : S32 preferredEncoding ;
png_error ( png_ptr , "ASCII conversion buffer too small" ) ; } # endif <START_VULN> #endif <END_VULN> #if defined ( PNG_FLOATING_POINT_SUPPORTED ) && ! defined ( PNG_FIXED_POINT_MACRO_SUPPORTED ) &&
break ; } <START_VULN> vpx_memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ; <END_VULN> old_boost_score = boost_score ; }
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { <START_VULN> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <END_VULN> } static int mount_entry_on_absolute_rootfs ( struct mntent * mntent ,
"NTLMSSP_NEGOTIATE_UNICODE" } ; <START_VULN> void ntlm_print_negotiate_flags ( UINT32 flags ) <END_VULN> { int i ; const char * str ;
static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( "btif_hl_select_close_connected" ) ; <START_VULN> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <END_VULN> }
REGISTER_LONG_CONSTANT ( "IMG_CROP_SIDES" , GD_CROP_SIDES , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( "IMG_CROP_THRESHOLD" , GD_CROP_THRESHOLD , CONST_CS | CONST_PERSISTENT ) ; <START_VULN> <END_VULN> REGISTER_LONG_CONSTANT ( "IMG_BELL" , GD_BELL , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( "IMG_BESSEL" , GD_BESSEL , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( "IMG_BILINEAR_FIXED" , GD_BILINEAR_FIXED , CONST_CS | CONST_PERSISTENT ) ;
( channel == xmlParserValidityError ) | | ( channel == xmlParserValidityWarning ) ) xmlReportError ( to , ctxt , str , NULL , NULL ) ; <START_VULN> else if ( ( channel == ( xmlGenericErrorFunc ) fprintf ) | | <END_VULN> ( channel == xmlGenericErrorDefaultFunc ) ) xmlReportError ( to , ctxt , str , channel , data ) ; else
#if CONFIG_DECODERS if ( global -> test_decode != TEST_DECODE_OFF ) { const VpxInterface * decoder = get_vpx_decoder_by_name ( global -> codec -> name ) ; <START_VULN> vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ; <END_VULN> } #endif }
{ vp8_dc_only_idct_add_mmx ( q [ 48 ] * dq [ 0 ] , dst + 12 , stride , dst + 12 , stride ) ; <START_VULN> vpx_memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <END_VULN> } q += 64 ;
ND_PRINT ( ( ndo , " ( length bogus , should be = 6 ) " ) ) ; return 0 ; } <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <END_VULN> ND_PRINT ( ( ndo , " : 0x % 08x" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; case LCPOPT_PFC :
virtual : : ppapi : : thunk : : PPB_URLLoader_API * AsPPB_URLLoader_API ( ) OVERRIDE ; <START_VULN> virtual void LastPluginRefWasDeleted ( bool instance_destroyed ) OVERRIDE ; <END_VULN> virtual int32_t Open ( PP_Resource request_id ,
DISALLOW_COPY_AND_ASSIGN ( DevToolsAgent ) ; } ; <START_VULN> #endif<END_VULN>
if ( ! slot ) goto out ; <START_VULN> if ( ioctl ( slot -> fd , FIONREAD , size ) == 0 ) { <END_VULN> ret = true ; } else { LOG_ERROR ( " % s unable to determine bytes remaining to be read on fd % d : % s" , __func__ , slot -> fd , strerror ( errno ) ) ;
#define PPAPI_C_PPB_FILE_REF_H_ #include "ppapicpp_bool . h" #include "ppapicpp_file_info . h" <START_VULN> #include "ppapicpp_instance . h"<END_VULN> #include "ppapicpp_resource . h" #include "ppapicpp_var . h"
if ( code == ( clear_code + 1 ) ) { return ( mGIFStruct . rows_remaining == 0 ) ; } if ( oldcode == - 1 ) { if ( code > = MAX_BITS ) return false ; <START_VULN> * rowp ++ = suffix [ code ] ; <END_VULN> if ( rowp == rowend ) OUTPUT_ROW ( ) ; firstchar = oldcode = code ; continue ; } int incode = code ; if ( code > = avail ) { * stackp ++ = firstchar ;
} ; <START_VULN> const interp_kernel vp9_filteredinterp_filters750 [ ( 1 << SUBPEL_BITS ) ] = { <END_VULN> { 2 , - 11 , 25 , 96 , 25 , - 11 , 2 , 0 } , { 2 , - 11 , 22 , 96 , 28 , - 11 , 2 , 0 } , { 2 , - 10 , 19 , 95 , 31 , - 11 , 2 , 0 } ,
return - 1 ; } <START_VULN> if ( mount ( console -> name , path , "none" , MS_BIND , 0 ) ) { <END_VULN> ERROR ( "failed to mount ' % s' on ' % s'" , console -> name , path ) ; return - 1 ; }
weight = ParseCommandOption ( MagickWeightOptions , MagickFalse , option ) ; if ( weight == - 1 ) <START_VULN> weight = StringToUnsignedLong ( option ) ; <END_VULN> draw_info -> weight = ( size_t ) weight ; } exception = DestroyExceptionInfo ( exception ) ;
namespace WebCore { <START_VULN> class MediaStreamSource : public RefCounted < MediaStreamSource> { <END_VULN> public : class Observer { public :
PositionForPoint ( const LayoutPoint & frame_point ) ; Document * DocumentAtPoint ( const LayoutPoint & ) ; <START_VULN> bool ShouldReuseDefaultView ( const KURL & ) const ; <END_VULN> void RemoveSpellingMarkersUnderWords ( const Vector < String> & words ) ; bool ShouldThrottleRendering ( ) const ;
#define BT_SHB0x0A0D0D0A <START_VULN> #define BT_SHB_INSANE_MAX 1024 * 1024 * 1<END_VULN> struct section_header_block { bpf_u_int32byte_order_magic ; u_shortmajor_version ;
<START_VULN> PHPAPI void php_clear_stat_cache ( zend_bool clear_realpath_cache , const char * filename , int filename_len ) <END_VULN> {
#include "md5_utils . h" <START_VULN> void<END_VULN> byteSwap ( UWORD32 * buf , unsigned words ) { md5byte * p ;
{ png_debug ( 1 , "in png_set_gamma_fixed" ) ; <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <END_VULN> return ;
public : PlatformSensorLinux ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> PlatformSensorProvider * provider , const SensorInfoLinux * sensor_device , scoped_refptr < base : : SingleThreadTaskRunner> polling_thread_task_runner ) ;
hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { if ( perf_tp_event_match ( event , & data , regs ) ) <START_VULN> perf_swevent_event ( event , count , 1 , & data , regs ) ; <END_VULN> } perf_swevent_put_recursion_context ( rctx ) ;
#define BASE_PROCESS_PROCESS_H_ #include "basebase_export . h" <START_VULN> #include "basemove . h"<END_VULN> #include "baseprocessprocess_handle . h" #include "basetimetime . h" #include "buildbuild_config . h"
const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; <START_VULN> int hexdump ; <END_VULN> u_int offset ; u_int link_type ;
using Value = typename Table : : ValueType ; ASSERT ( ! WTF : : IsTriviallyDestructible < Value> : : value ) ; HeapObjectHeader * header = HeapObjectHeader : : fromPayload ( pointer ) ; <START_VULN> ASSERT ( header -> checkHeader ( ) ) ; <END_VULN> size_t length = header -> payloadSize ( ) sizeof ( Value ) ;
int ip6_find_1stfragopt ( struct sk_buff * skb , u8 ** nexthdr ) { <START_VULN> u16 offset = sizeof ( struct ipv6hdr ) ; <END_VULN> unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ;
size = 1 ; } <START_VULN> if ( color_type & PNG_COLOR_MASK_ALPHA ) <END_VULN> { if ( sbit -> alpha == 0 | | sbit -> alpha > png_ptr -> usr_bit_depth ) {
#ifdef PNG_READ_GAMMA_SUPPORTED png_color_16 background_1 ; #endif <START_VULN> #endif<END_VULN> #ifdef PNG_WRITE_FLUSH_SUPPORTED png_flush_ptr output_flush_fn ;
ND_PRINT ( ( ndo , " ( length bogus , should be > = 3 ) " ) ) ; return len ; } <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <END_VULN> ND_PRINT ( ( ndo , " : Version : % u , Dictionary Bits : % u" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ; break ;
void GetAppController ( mojom : : AppControllerRequest request ) override ; private : mojo : : BindingSet < mojom : : KioskNextHomeInterfaceBroker> bindings_ ; std : : unique_ptr < service_manager : : Connector> connector_ ; <START_VULN> std : : unique_ptr < AppControllerImpl> app_controller_ ; <END_VULN> DISALLOW_COPY_AND_ASSIGN ( KioskNextHomeInterfaceBrokerImpl ) ; } ;
<START_VULN> if ( mprGetJson ( route -> config , sfmt ( "app . http . content . compress [ @ = ' % s' ] " , child -> value ) ) == 0 ) { <END_VULN> httpAddRouteMapping ( route , child -> value , "min . $ { 1 } " ) ; } }
int vp8dx_start_decode ( BOOL_DECODER * br , const unsigned char * source , unsigned int source_sz , <START_VULN> vp8_decrypt_cb * decrypt_cb , <END_VULN> void * decrypt_state ) ; void vp8dx_bool_decoder_fill ( BOOL_DECODER * br ) ;
return FALSE ; } } <START_VULN> return send ( ts [ h ] . cmd_fdw , cmd_send , size_send , 0 ) == size_send ; <END_VULN> } int btsock_thread_wakeup ( int h ) {
#include "third_partyblinkpubliccommonuser_agentuser_agent_metadata . h" #include "third_partyblinkpublicmojomrenderer_preference_watcher . mojom - forward . h" #include "third_partyblinkpublicmojomweb_featureweb_feature . mojom - forward . h" <START_VULN> #include "third_partyblinkpublicmojomwindow_featureswindow_features . mojom - forward . h"<END_VULN> #include "uiaccessibilityax_mode . h" #include "uibasepage_transition_types . h" #include "uibasewindow_open_disposition . h"
{ png_debug ( 1 , "in png_set_strip_16" ) ; <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <END_VULN> return ; png_ptr -> transformations |= PNG_16_TO_8 ;
inline unsigned blend ( unsigned from , unsigned to , double progress ) { <START_VULN> return static_cast < unsigned> ( lround ( static_cast < double> ( from ) + static_cast < double> ( to - from ) * progress ) ) ; <END_VULN> } inline double blend ( double from , double to , double progress )
} ; template < > struct APIClientTraits < WKPageLoaderClient> { <START_VULN> static const size_t interfaceSizesByVersion [ 2 ] ; <END_VULN> } ; template < > struct APIClientTraits < WKPageUIClient> {
{ 0x0000a7b1 , FC_CASE_FOLD_RANGE , 0x0001 , 23254 } , { 0x0000a7b2 , FC_CASE_FOLD_RANGE , 0x0001 , 23275 } , { 0x0000a7b3 , FC_CASE_FOLD_RANGE , 0x0001 , 928 } , <START_VULN> { 0x0000a7b4 , FC_CASE_FOLD_EVEN_ODD , 0x0005 , 1 } , <END_VULN> { 0x0000ab70 , FC_CASE_FOLD_RANGE , 0x0050 , 26672 } , { 0x0000fb00 , FC_CASE_FOLD_FULL , 0x0002 , 435 } , { 0x0000fb01 , FC_CASE_FOLD_FULL , 0x0002 , 437 } ,
png_ptr -> flags &= ~ ( PNG_FLAG_BENIGN_ERRORS_WARN | PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN ) ; } <START_VULN> #endif <END_VULN> #ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
size_t extent ; <START_VULN> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <END_VULN> return ( ( MemoryInfo * ) NULL ) ; memory_info = ( MemoryInfo * ) MagickAssumeAligned ( AcquireAlignedMemory ( 1 , sizeof ( * memory_info ) ) ) ;
"tlb_flush_pending % d" "def_flags : % #lx ( % pGv ) " , <START_VULN> mm , mm -> mmap , mm -> vmacache_seqnum , mm -> task_size , <END_VULN> #ifdef CONFIG_MMU mm -> get_unmapped_area , #endif
memcpy ( packet + sizeof ( tETH_HDR ) , buf , len ) ; <START_VULN> int ret = write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ; <END_VULN> BTIF_TRACE_DEBUG ( "ret : % d" , ret ) ; return ret ; }
<START_VULN> ZEND_BEGIN_ARG_INFO ( arginfo_info___construct , 0 ) <END_VULN> ZEND_ARG_INFO ( 0 , file_name ) ZEND_END_ARG_INFO ( )
{ HttpConn * conn ; MprBuf * buf ; <START_VULN> char * endHeaders , * headers , * key , * value , * junk ; <END_VULN> ssize blen ; int len ;
#ifdef ZEND_WIN32 <START_VULN> static inline zend_ulong realpath_cache_key ( const char * path , int path_len ) <END_VULN> { register zend_ulong h ; char * bucket_key_start = tsrm_win32_get_path_sid_key ( path ) ;
if ( fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { zend_throw_error ( exception_ce , message ) ; } else { <START_VULN> zend_error ( E_ERROR , message ) ; <END_VULN> } efree ( message ) ;
break ; } printstr ( & pp , " < h3>Please be careful editing config file remotely < h3>" ) ; <START_VULN> printstr ( & pp , " < form method = "POST" action = "U"> < textarea cols = "80" rows = "30" name = "conffile">" ) ; <END_VULN> while ( fgets ( buf , 256 , fp ) ) { printstr ( & pp , buf ) ; }
} if ( j > = ISDN_MSNLEN ) break ; } if ( ++ i > 9 ) break ; } } else { p = ( char __user * ) iocts . arg ; for ( i = 0 ; i < 10 ; i ++ ) { <START_VULN> sprintf ( bname , " % s % s" , <END_VULN> strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? " , " : "0" ) ; if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) ) return - EFAULT ; p += strlen ( bname ) ; } } return 0 ; } else
( void ) flags ; stream = get_stream ( session , frame -> hd . stream_id ) ; if ( ! stream ) { <START_VULN> ap_log_cerror ( APLOG_MARK , APLOG_ERR , 0 , session -> c , <END_VULN> APLOGNO ( 02920 ) "h2_session : stream ( % ld - % d ) : on_header unknown stream" , session -> id , ( int ) frame -> hd . stream_id ) ;
static PRUint32 GetWorkerCloseHandlerTimeoutMS ( ) ; PRBool QueueSuspendedWorker ( nsDOMWorkerRunnable * aRunnable ) ; nsCOMPtr < nsIThreadPool> mThreadPool ; <START_VULN> nsRefPtrHashtable < nsISupportsHashKey , nsDOMWorkerPool> mPools ; <END_VULN> PRMonitor * mMonitor ; nsRefPtrHashtable < nsVoidPtrHashKey , nsDOMWorkerRunnable> mWorkersInProgress ;
png_debug ( 1 , "in png_do_gray_to_rgb" ) ; if ( row_info -> bit_depth > = 8 && <START_VULN> ! ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) ) <END_VULN> { if ( row_info -> color_type == PNG_COLOR_TYPE_GRAY ) {
const MB_MODE_INFO * mbmi = & mi -> mbmi ; const BLOCK_SIZE block_size = mbmi -> sb_type ; const TX_SIZE tx_size_y = mbmi -> tx_size ; <START_VULN> const TX_SIZE tx_size_uv = get_uv_tx_size ( mbmi ) ; <END_VULN> const int filter_level = get_filter_level ( lfi_n , mbmi ) ; uint64_t * const left_y = & lfm -> left_y [ tx_size_y ] ; uint64_t * const above_y = & lfm -> above_y [ tx_size_y ] ;
) { <START_VULN> DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , FData2 , 24 * 24 ) ; <END_VULN> const short * HFilter , * VFilter ;
int compression_type ; if ( png_get_iCCP ( read_ptr , read_info_ptr , & name , & compression_type , <START_VULN> & profile , & proflen ) ) <END_VULN> { png_set_iCCP ( write_ptr , write_info_ptr , name , compression_type , profile , proflen ) ;
BTIF_TRACE_DEBUG ( " % s : % x % x % x" , __FUNCTION__ , hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ; <START_VULN> usleep ( 200000 ) ; <END_VULN> memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; BTIF_TRACE_DEBUG ( "Writing hidreport #2 to os : "
if ( pszFileName [ 0 ] == '' ) { <START_VULN> strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ; <END_VULN> } else {
yych = * ++ YYCURSOR ; if ( yych != '"' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 610 "extstandardvar_unserializer . re"<END_VULN> { size_t len , maxlen ; char * str ;
void OnDestroy ( ) ; <START_VULN> void OnTexturesCreated ( std : : vector < int> textures ) ; <END_VULN> GpuChannel * channel_ ; IPC : : Message : : Sender * sender_ ;
{ int i ; for ( i = 0 ; i <= 31 ; i ++ ) { <START_VULN> if ( x & ( 1 << i ) ) return i ; <END_VULN> } return 0 ; }
return ( tlv_len + 4 ) ; trunc : <START_VULN> ND_PRINT ( ( ndo , "tt packet exceeded snapshot" ) ) ; <END_VULN> return 0 ; badtlv :
<START_VULN> std : : ostream & operator << ( std : : ostream & out , const wchar_t * wstr ) ; <END_VULN> inline std : : ostream & operator << ( std : : ostream & out , const std : : wstring & wstr ) { return out << wstr . c_str ( ) ; }
if ( threshold < x -> encode_breakout ) threshold = x -> encode_breakout ; <START_VULN> var = vp8_variance16x16<END_VULN> ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : toplevel libogg include <START_VULN> last mod : $ Id : ogg . h 16051 2009 - 05 - 27 05 : 00 : 06Z xiphmont $ <END_VULN> #ifndef _OGG_H #define _OGG_H #ifdef __cplusplus extern "C" { #endif
bytes & ( SQUASHFS_METADATA_SIZE - 1 ) ; int length = read_block ( fd , index [ i ] , NULL , expected , ( ( unsigned char * ) xattr_ids ) + <START_VULN> ( i * SQUASHFS_METADATA_SIZE ) ) ; <END_VULN> TRACE ( "Read xattr id table block % d , from 0x % llx , length " " % d" , i , index [ i ] , length ) ; if ( length == 0 ) {
#define PROGNAME "rpng - x" #define LONGNAME "Simple PNG Viewer for X" <START_VULN> #define VERSION "2 . 01 of 16 March 2008"<END_VULN> #define RESNAME "rpng" #define RESCLASS "Rpng"
return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } <START_VULN> #line 881 "extstandardvar_unserializer . c"<END_VULN> yy39 : yych = * ++ YYCURSOR ; if ( yych == ' + ' ) goto yy40 ;
#include "baseobserver_list . h" #include "basetime . h" #include "basetimer . h" <START_VULN> #include "third_partycroschromeos_input_method . h"<END_VULN> namespace chromeos {
for ( uv = 4 ; uv < 6 ; uv ++ ) { s -> above_block_idx [ uv ] += 1 ; s -> block_offset [ uv ] += 8 ; } } } next : if ( p -> key_frame | | golden_frame ) { <START_VULN> if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && <END_VULN> s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] ) avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ) ; s -> framep [ VP56_FRAME_GOLDEN ] = p ; } if ( s -> has_alpha ) { FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_GOLDEN ] , s -> framep [ VP56_FRAME_GOLDEN2 ] ) ; buf += alpha_offset ; remaining_buf_size -= alpha_offset ;
if ( r == 0 ) { num_records = oggplay_callback_info_prepare ( me , & info ) ; for ( i = 0 ; i < me -> num_tracks ; i ++ ) { me -> decode_data [ i ] -> active = 0 ; <START_VULN> me -> active_tracks = 0 ; <END_VULN> } if ( info != NULL ) { me -> callback ( me , num_records , info , me -> callback_user_ptr ) ; oggplay_callback_info_destroy ( me , info ) ; } decoder -> stream_info = OGGPLAY_STREAM_UNINITIALISED ;
if ( ua ) { efree ( ua ) ; } <START_VULN> } <END_VULN> } if ( user_headers ) {
temp = UCH ( * bufferptr ++ ) << 8 ; temp |= UCH ( * bufferptr ++ ) ; if ( temp > maxval ) <START_VULN> ERREXIT ( cinfo , JERR_PPM_TOOLARGE ) ; <END_VULN> * ptr ++ = rescale [ temp ] ; } return 1 ;
class SuccessCallbackImpl FINAL : public SuccessCallback { public : <START_VULN> static PassOwnPtr < SuccessCallbackImpl> create ( PassRefPtr < HelperType> helper ) <END_VULN> { return adoptPtr ( new SuccessCallbackImpl ( helper ) ) ; }
#endif entry = SetMagickInfo ( "MNG" ) ; <START_VULN> entry -> seekable_stream = MagickTrue ; <END_VULN> #if defined ( MAGICKCORE_PNG_DELEGATE ) entry -> decoder = ( DecodeImageHandler * ) ReadMNGImage ;
{ if ( new_size == * newlength ) { <START_VULN> if ( terminate ) <END_VULN> text [ prefix_size + * newlength ] = 0 ; if ( prefix_size > 0 )
return png_icc_profile_error ( png_ptr , colorspace , name , temp , "invalid embedded Abstract ICC profile" ) ; <START_VULN> case 0x6C696E6B : <END_VULN>
{ U32 max = MaxML ; size_t const mostFrequent = HIST_countFast_wksp ( count , & max , mlCodeTable , nbSeq , workspace , wkspSize ) ; <START_VULN> DEBUGLOG ( 5 , "Building ML table" ) ; <END_VULN> nextEntropy -> fse . matchlength_repeatMode = prevEntropy -> fse . matchlength_repeatMode ; MLtype = ZSTD_selectEncodingType ( & nextEntropy -> fse . matchlength_repeatMode , count , max , mostFrequent , nbSeq , MLFSELog , prevEntropy -> fse . matchlengthCTable , ML_defaultNorm , ML_defaultNormLog , ZSTD_defaultAllowed , strategy ) ; assert ( ! ( MLtype < set_compressed && nextEntropy -> fse . matchlength_repeatMode != FSE_repeat_none ) ) ;
const char * extractMetadata ( int keyCode ) ; private : <START_VULN> static const sp < IMediaPlayerService> & getService ( ) ; <END_VULN> class DeathNotifier : public IBinder : : DeathRecipient {
for ( y = 0 ; y < h ; ++ y ) { <START_VULN> png_const_bytep PNG_CONST pRow = store_image_row ( ps , pp , 0 , y ) ; <END_VULN> png_uint_32 x ;
<START_VULN> static void appendToHeader ( HeaderString & header , absl : : string_view data ) ; <END_VULN> HeaderMapImpl ( ) ; explicit HeaderMapImpl (
unsigned int first_corrupt ) { int mb_row , mb_col ; <START_VULN> vpx_memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ; <END_VULN> for ( mb_row = 0 ; mb_row < mb_rows ; ++ mb_row ) {
err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) , <START_VULN> USB_DT_OTG , ( void ** ) & desc ) ; <END_VULN> if ( err | | ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ;
} void vp9_end_first_pass ( VP9_COMP * cpi ) { <START_VULN> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { <END_VULN> int i ; for ( i = 0 ; i < cpi -> svc . number_spatial_layers ; ++ i ) { output_stats ( & cpi -> svc . layer_context [ i ] . twopass . total_stats ,
ma_mov ( c , lr ) ; ma_str ( lr , dest ) ; } BufferOffset ma_BoundsCheck ( Register bounded ) { return as_cmp ( bounded , Imm8 ( 0 ) ) ; } void moveFloat32 ( FloatRegister src , FloatRegister dest ) { <START_VULN> as_vmov ( VFPRegister ( src ) . singleOverlay ( ) , VFPRegister ( dest ) . singleOverlay ( ) ) ; <END_VULN> } #ifdef JSGC_GENERATIONAL void branchPtrInNurseryRange ( Condition cond , Register ptr , Register temp , Label * label ) ; void branchValueIsNurseryObject ( Condition cond , ValueOperand value , Register temp , Label * label ) ; #endif } ;
if ( one_entry_in_sg ) { if ( unlikely ( req -> src != req -> dst ) ) { scatterwalk_unmap ( dst ) ; scatterwalk_done ( & dst_sg_walk , 0 , 0 ) ; } scatterwalk_unmap ( src ) ; scatterwalk_unmap ( assoc ) ; scatterwalk_done ( & src_sg_walk , 0 , 0 ) ; scatterwalk_done ( & assoc_sg_walk , 0 , 0 ) ; } else { <START_VULN> scatterwalk_map_and_copy ( dst , req -> dst , 0 , req -> cryptlen , 1 ) ; <END_VULN> kfree ( src ) ; } return retval ; }
~ EmulationHandler ( ) override ; void Wire ( UberDispatcher * dispatcher ) override ; <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) override ; Response Disable ( ) override ;
memcpy ( curconn -> terminal_type , cpkt . data , act_size = ( cpkt . length > 30 - 1 ? 30 - 1 : cpkt . length ) ) ; curconn -> terminal_type [ act_size ] = 0 ; <START_VULN> } else if ( cpkt . cptype == MT_CPTYPE_PASSWORD ) { <END_VULN> #if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( curconn -> trypassword , 17 ) ;
} <START_VULN> const PRUint8 * <END_VULN> PrepareOpenTypeData ( const PRUint8 * aData , PRUint32 * aLength ) { switch ( gfxFontUtils : : DetermineFontDataType ( aData , * aLength ) ) { case GFX_USERFONT_OPENTYPE : return aData ;
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : apprentice . c , v 1 . 226 20141128 02 : 35 : 05 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : 0 . 0 , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0 . 0 ) ; <START_VULN> draw_info -> geometry = AcquireString ( geometry ) ; <END_VULN> status = AnnotateImage ( image , draw_info ) ; if ( image_info -> pointsize == 0 . 0 ) {
static std : : vector < InputHandler * > ForAgentHost ( DevToolsAgentHostImpl * host ) ; void Wire ( UberDispatcher * dispatcher ) override ; <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) override ; void OnSwapCompositorFrame (
} close ( fd ) ; <START_VULN> continue ; <END_VULN> }
{ 0 , 1024 } , { - 1024 , 1024 } , { - 1024 , 0 } } , } ; return vp9_pattern_search ( x , ref_mv , search_param , sad_per_bit , <START_VULN> do_init_search , 0 , vfp , use_mvcost , <END_VULN> center_mv , best_mv , square_num_candidates , square_candidates ) ; }
void GetSettings ( bool ask_user_for_settings , <START_VULN> gfx : : NativeWindow parent_window , <END_VULN> int document_page_count , bool has_selection , bool use_overlays ) ;
#pragma once #include "basebasictypes . h" <START_VULN> #include "basecallback . h"<END_VULN> #include "basememoryref_counted . h" #include "basememoryscoped_ptr . h" #include "basemessage_loop_proxy . h"
if ( out == NULL ) { return ; } <START_VULN> gdImageWebpCtx ( im , out , - 1 ) ; <END_VULN> out -> gd_free ( out ) ; }
static int pgx_gethdr ( jas_stream_t * in , pgx_hdr_t * hdr ) { int c ; <START_VULN> uchar buf [ 2 ] ; <END_VULN> if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ;
#ifdef PNG_READ_SUPPORTED static void <START_VULN> store_image_check ( PNG_CONST png_store * ps , png_const_structp pp , int iImage ) <END_VULN> { png_const_bytep image = ps -> image ;
else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ; <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <END_VULN> } if ( eobs [ 1 ] > 1 )
ZVAL_RESOURCE ( & intern -> u . file . zresource , php_stream_get_resource_id ( intern -> u . file . stream ) ) ; Z_SET_REFCOUNT ( intern -> u . file . zresource , 1 ) ; <START_VULN> <END_VULN> intern -> u . file . delimiter = ' , ' ; intern -> u . file . enclosure = '"' ; intern -> u . file . escape = '' ;
static const int search_param_to_steps [ MAX_MVSEARCH_STEPS ] = { 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 , } ; <START_VULN> int i , j , s , t ; <END_VULN> const struct buf_2d * const what = & x -> plane [ 0 ] . src ; const struct buf_2d * const in_what = & xd -> plane [ 0 ] . pre [ 0 ] ; int br , bc ;
{ one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <START_VULN> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <END_VULN> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ )
static void CVE_2014_5163_decode_apn ( tvbuff_t * tvb , int offset , guint16 length , proto_tree * tree , proto_item * item ) { guint8str [ MAX_APN_LENGTH + 1 ] ; guintcurr_len ; <START_VULN> memset ( str , 0 , MAX_APN_LENGTH ) ; <END_VULN> tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ) ; curr_len = 0 ; while ( ( curr_len < length ) && ( curr_len < MAX_APN_LENGTH ) ) { guint step = str [ curr_len ] ; str [ curr_len ] = ' . ' ; curr_len += step + 1 ; }
idev = __in_dev_get_rcu ( dev ) ; if ( idev ) { if ( idev -> ifa_list ) network = ntohl ( idev -> ifa_list -> ifa_address ) & 0xffffff00 ; } rcu_read_unlock ( ) ; udpdest . sin_addr . s_addr = htonl ( network | addr . station ) ; } ah . port = port ; ah . cb = cb & 0x7f ; ah . code = 2 ; <START_VULN> ah . pad = 0 ; <END_VULN> size = sizeof ( struct aunhdr ) ; iov [ 0 ] . iov_base = ( void * ) & ah ; iov [ 0 ] . iov_len = size ; for ( i = 0 ; i < msg -> msg_iovlen ; i ++ ) { void __user * base = msg -> msg_iov [ i ] . iov_base ; size_t iov_len = msg -> msg_iov [ i ] . iov_len ;
"menu" , "p" , "head" , "ul" , NULL , "p" , "p" , "head" , "h1" , "h2" , "h3" , "h4" , "h5" , "h6" , FONTSTYLE , NULL , "div" , "p" , "head" , NULL , <START_VULN> "noscript" , "p" , NULL , <END_VULN> "center" , "font" , "b" , "i" , "p" , "head" , NULL , "a" , "a" , "head" , NULL , "caption" , "p" , NULL ,
# endif #else PNG_UNUSED ( output_flush_fn ) <START_VULN> #endif<END_VULN> #ifdef PNG_READ_SUPPORTED
const int mi_dc = hbs * ( n & 1 ) ; const int mi_dr = hbs * ( n >> 1 ) ; <START_VULN> count_segs_sb ( cpi , tile , & mi_8x8 [ mi_dr * mis + mi_dc ] , <END_VULN> no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row + mi_dr , mi_col + mi_dc , subsize ) ;
} } PRInt32 FindMaxUshortElement ( ) { if ( mHasCachedMaxUshortElement ) { return mCachedMaxUshortElement ; } else { mHasCachedMaxUshortElement = true ; <START_VULN> mCachedMaxUshortElement = FindMaxElementInSubArray < GLshort> ( mByteLength >> 1 , 0 ) ; <END_VULN> return mCachedMaxUshortElement ; } } NS_DECL_ISUPPORTS NS_DECL_NSIWEBGLBUFFER protected :
Find pathnames matching a pattern * PHP_FUNCTION ( glob ) { <START_VULN> int cwd_skip = 0 ; <END_VULN> #ifdef ZTS char cwd [ MAXPATHLEN ] ; char work_pattern [ MAXPATHLEN ] ;
NS_IMETHOD ResetInputState ( ) ; NS_IMETHOD_ ( void ) SetInputContext ( const InputContext & aContext , const InputContextAction & aAction ) ; NS_IMETHOD_ ( InputContext ) GetInputContext ( ) ; NS_IMETHOD CancelIMEComposition ( ) ; NS_IMETHOD OnIMEFocusChange ( bool aFocus ) ; NS_IMETHOD GetToggledKeyState ( uint32_t aKeyCode , bool * aLEDState ) ; <START_VULN> void ResizeTransparencyBitmap ( int32_t aNewWidth , int32_t aNewHeight ) ; <END_VULN> void ApplyTransparencyBitmap ( ) ; virtual void SetTransparencyMode ( nsTransparencyMode aMode ) ; virtual nsTransparencyMode GetTransparencyMode ( ) ; virtual nsresult ConfigureChildren ( const nsTArray < Configuration> & aConfigurations ) ; nsresult UpdateTranslucentWindowAlphaInternal ( const nsIntRect & aRect , uint8_t * aAlphas , int32_t aStride ) ; #if defined ( MOZ_WIDGET_GTK2 )
NS_IMETHODIMP CVE_2012_3979_nsFrameMessageManager : : Dump ( const nsAString & aStr ) { #ifdef ANDROID <START_VULN> __android_log_print ( ANDROID_LOG_INFO , "Gecko" , NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) ) ; <END_VULN> #endif fputs ( NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) , stdout ) ; fflush ( stdout ) ; return NS_OK ; }
image -> rows * sizeof ( * runlength ) ) ; if ( runlength == ( unsigned char * ) NULL ) ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <START_VULN> buffer = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * buffer ) ) ; <END_VULN> if ( buffer == ( unsigned char * ) NULL ) ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; packet_size = ( size_t ) ( image -> depth > 8 ? 2 : 1 ) ;
unsigned height , GLenum format , GLenum type , <START_VULN> unsigned unpack_alignment , <END_VULN> bool flip_y , bool premultiply_alpha , const void * pixels ,
if ( bufsize > QMFB_SPLITBUFSIZE ) { <START_VULN> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <END_VULN> abort ( ) ; }
* ( -- dp ) = * ( -- sp ) ; * ( -- dp ) = * ( -- sp ) ; * ( -- dp ) = * ( -- sp ) ; <START_VULN> * ( -- dp ) = hi_filler ; <END_VULN> * ( -- dp ) = lo_filler ; } row_info -> channels = 4 ;
vp8_short_idct4x4llm_dspr2 ( input , dest , stride , dest , stride ) ; <START_VULN> vpx_memset ( input , 0 , 32 ) ; <END_VULN> }
PRBool HasLoadFlag ( PRUint32 flag ) { return ( mLoadFlags & flag ) != 0 ; } PRBool IsPending ( ) const { <START_VULN> return ( mPump != nsnull ) ; <END_VULN> } void SetContentLength64 ( PRInt64 len ) ; PRInt64 ContentLength64 ( ) ;
if ( entry -> location . rva + entry -> location . data_size > obj -> b -> length ) { <START_VULN> eprintf ( " [ ERROR ] Size Mismatch - Stream data is larger than file size ! " ) ; <END_VULN> return false ; }
#define UserMediaRequest_h #include "coredomActiveDOMObject . h" <START_VULN> #include "coreplatformmediastreamMediaStreamSource . h"<END_VULN> #include "modulesmediastreamNavigatorUserMediaErrorCallback . h" #include "modulesmediastreamNavigatorUserMediaSuccessCallback . h" #include "wtfPassRefPtr . h" #include "wtfRefCounted . h" #include "wtftextWTFString . h"
void SetWindowRect ( const IntRect & , LocalFrame & ) override ; IntRect RootWindowRect ( ) override ; IntRect PageRect ( ) override ; <START_VULN> void Focus ( ) override ; <END_VULN> bool CanTakeFocus ( WebFocusType ) override ; void TakeFocus ( WebFocusType ) override ; void FocusedNodeChanged ( Node * from_node , Node * to_node ) override ;
i1_is_end_of_poc = 1 ; ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; <START_VULN> if ( ps_dec -> u4_first_slice_in_pic != 2 ) <END_VULN> { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc ,
. index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , <START_VULN> . match_data . cmp = type -> match , <END_VULN> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK ,
static void copyIPv6IfDifferent ( void * dest , const void * src ) { <START_VULN> if ( dest != src ) { <END_VULN> memcpy ( dest , src , sizeof ( struct in6_addr ) ) ; } }
sptr = ( * ( be -> base_src ) + be -> src ) ; dptr = b -> predictor ; <START_VULN> return vp8_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ; <END_VULN> }
case BAG_IF_ELSE : { <START_VULN> int cond_len , then_len , jump_len ; <END_VULN> Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ;
break ; case BSD_AFNUM_ISO : <START_VULN> isoclns_print ( ndo , p , length , caplen ) ; <END_VULN> break ; case BSD_AFNUM_APPLETALK :
<START_VULN> int test_main ( int argc , char * argv [ ] ) ; <END_VULN> No newline at end of file
UIPC_LOCK ( ) ; <START_VULN> if ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) < 0 ) <END_VULN> { BTIF_TRACE_ERROR ( "failed to write ( % s ) " , strerror ( errno ) ) ; }
} } } <START_VULN> <END_VULN> if ( context && php_stream_context_get_option ( context , "http" , "protocol_version" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ;
( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , " Copying JDAT chunk data to color_blob . " ) ; <START_VULN> if ( length != 0 ) <END_VULN> { ( void ) WriteBlob ( color_image , length , chunk ) ; chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ;
string16 GetDialogTitle ( const Extension * extension ) const ; <START_VULN> string16 GetHeading ( std : : string extension_name ) const ; <END_VULN> string16 GetAcceptButtonLabel ( ) const ; bool HasAbortButtonLabel ( ) const ; string16 GetAbortButtonLabel ( ) const ;
else running_avg_y [ c ] = sig [ c ] + adjustment ; <START_VULN> sum_diff += adjustment ; <END_VULN> } else {
public Page : : Backend , public RenderWidgetHostObserver { public : <START_VULN> explicit PageHandler ( EmulationHandler * handler ) ; <END_VULN> ~ PageHandler ( ) override ; static std : : vector < PageHandler * > EnabledForWebContents (
int ret ; perf_event_header__init_id ( & read_event . header , & sample , event ) ; <START_VULN> ret = perf_output_begin ( & handle , event , read_event . header . size , 0 , 0 ) ; <END_VULN> if ( ret ) return ;
class RawData ; class SecurityOrigin ; <START_VULN> class ThreadableBlobRegistry { <END_VULN> public : static void registerBlobURL ( const KURL & , PassOwnPtr < BlobData> ) ; static void registerStreamURL ( const KURL & , const String & ) ;
{ if ( file != NULL ) { <START_VULN> if ( png_image_write_init ( image ) ) <END_VULN> { png_image_write_control display ; int result ;
void * memory ; <START_VULN> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <END_VULN> return ( ( void * ) NULL ) ; memory = NULL ; alignment = CACHE_LINE_SIZE ;
} #endif <START_VULN> #endif<END_VULN>
case cs_cp866 : table = unimap_cp866 ; table_size = sizeof ( unimap_cp866 ) sizeof ( * unimap_cp866 ) ; <START_VULN> <END_VULN> table_over_7F : if ( code <= 0x7F ) { * res = code ;
ZVAL_LONG ( rval , parse_iv ( start + 2 ) ) ; return 1 ; } <START_VULN> #line 1214 "extstandardvar_unserializer . c"<END_VULN> yy83 : yych = * ++ YYCURSOR ; if ( yych <= '' ) goto yy18 ;
if ( ! TRC ) return NULL ; gamma_table = malloc ( sizeof ( float ) * 256 ) ; if ( gamma_table ) { if ( TRC -> type == PARAMETRIC_CURVE_TYPE ) { compute_curve_gamma_table_type_parametric ( gamma_table , TRC -> parameter , TRC -> count ) ; } else { if ( TRC -> count == 0 ) { compute_curve_gamma_table_type0 ( gamma_table ) ; } else if ( TRC -> count == 1 ) { <START_VULN> compute_curve_gamma_table_type1 ( gamma_table , u8Fixed8Number_to_float ( TRC -> data [ 0 ] ) ) ; <END_VULN> } else { compute_curve_gamma_table_type2 ( gamma_table , TRC -> data , TRC -> count ) ; } } } return gamma_table ; }
static inline int btif_hl_select_wakeup ( void ) { char sig_on = btif_hl_signal_select_wakeup ; BTIF_TRACE_DEBUG ( "btif_hl_select_wakeup" ) ; <START_VULN> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <END_VULN> }
int main ( int argc , char * argv [ ] ) { <START_VULN> char * p , * q , * r ; <END_VULN> Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) sizeof ( options [ 0 ] ) , options ) ;
do { UWORD32 u4_x_offset , u4_y_offset ; <START_VULN> <END_VULN> UWORD32 u4_x_dst_offset = 0 ;
Address addressForDataRemat ( const FrameEntry * fe ) const ; <START_VULN> Address addressForInlineReturn ( ) const ; <END_VULN> inline StateRemat dataRematInfo ( const FrameEntry * fe ) const ;
* <START_VULN> <END_VULN> #include "cert . h" #include "secitem . h" #include "keyhi . h" #include "ssl . h" #include "sslimpl . h" #include "sslproto . h" #include "secoid . h" #include "pk11func . h"
Enable use of SSL if we are using any ssl option One can disable SSL later by using -- skip - ssl or -- ssl = 0 <START_VULN> opt_use_ssl = 1 ; <END_VULN> #ifdef HAVE_YASSL opt_ssl_crl = NULL ;
class FakePlatformSensor : public PlatformSensor { public : FakePlatformSensor ( mojom : : SensorType type , <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> PlatformSensorProvider * provider ) ;
if ( src -> interpolation_id == GD_BILINEAR_FIXED | | src -> interpolation_id == GD_BICUBIC_FIXED | | src -> interpolation_id == GD_NEAREST_NEIGHBOUR ) { interpolation_id_bak = src -> interpolation_id ; interpolation_bak = src -> interpolation ; <START_VULN> <END_VULN> gdImageSetInterpolationMethod ( src , GD_BICUBIC ) ; }
* cp ++ = hex [ * ep ++ & 0xf ] ; } * cp = '0' ; <START_VULN> return ( tp -> e_name ) ; <END_VULN> } const char *
virtual scoped_refptr < ui : : Texture> CreateTransportClient ( const gfx : : Size & size , float device_scale_factor , <START_VULN> uint64 transport_handle ) = 0 ; <END_VULN>
sid = j_id -> valueint ; bytes_transferred = j_bytes -> valueint ; retransmits = j_retransmits -> valueint ; <START_VULN> jitter = j_jitter -> valuefloat ; <END_VULN> cerror = j_errors -> valueint ; pcount = j_packets -> valueint ; SLIST_FOREACH ( sp , & test -> streams , streams )
if ( ! mode_excluded ) { int max_plane = MAX_MB_PLANE ; <START_VULN> best_mode_index = mode_index ; <END_VULN> if ( ref_frame == INTRA_FRAME ) {
dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { <START_VULN> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <END_VULN> src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; }
ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } <START_VULN> <END_VULN> if ( prev_slice_err == 1 ) {
return put_user ( tty_chars_in_buffer ( tty ) , ( int __user * ) arg ) ; case TIOCINQ : down_write ( & tty -> termios_rwsem ) ; <START_VULN> if ( L_ICANON ( tty ) ) <END_VULN> retval = inq_canon ( ldata ) ; else retval = read_cnt ( ldata ) ;
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : softmagic . c , v 1 . 188 20140514 23 : 15 : 42 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
#include < windows . h> #elif defined ( ANGLE_OS_POSIX ) #include < pthread . h> #include < semaphore . h> #include < errno . h> #endif <START_VULN> #include "compilerdebug . h"<END_VULN> #if defined ( ANGLE_USE_NSPR ) typedef PRUintn OS_TLSIndex ; #define OS_INVALID_TLS_INDEX 0xFFFFFFFF #elif defined ( ANGLE_OS_WIN )
chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) 4 ; <START_VULN> if ( numChannels < chansSpecified | | numChannels < 1 ) { <END_VULN> error_line ( " % s is not a valid . DFF file ! " , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ;
FLOATING_POINT_INIT ( ) ; if ( num_enc == 1 ) <START_VULN> res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <END_VULN> duration , flags , deadline ) ; else {
static u32 challenge_timestamp ; static unsigned int challenge_count ; struct tcp_sock * tp = tcp_sk ( sk ) ; <START_VULN> u32 now ; <END_VULN> if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb ,
#define VMACACHE_MASK ( VMACACHE_SIZE - 1 ) struct vmacache { <START_VULN> u32 seqnum ; <END_VULN> struct vm_area_struct * vmas [ VMACACHE_SIZE ] ; } ;
return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } <START_VULN> #line 860 "extstandardvar_unserializer . c"<END_VULN> yy39 : yych = * ++ YYCURSOR ; if ( yych == ' + ' ) goto yy40 ;
static char * getPreferredTag ( const char * gf_tag ) <START_VULN> { <END_VULN> char * result = NULL ; int grOffset = 0 ;
} } <START_VULN> #endif<END_VULN>
socket_t * socket_accept ( const socket_t * socket ) { assert ( socket != NULL ) ; <START_VULN> int fd = accept ( socket -> fd , NULL , NULL ) ; <END_VULN> if ( fd == INVALID_FD ) { LOG_ERROR ( " % s unable to accept socket : % s" , __func__ , strerror ( errno ) ) ; return NULL ;
* <START_VULN> <END_VULN> #include "lowkeyi . h" #include "secasn1 . h" #include "secder . h" #include "secoid . h" #include "blapi . h" #include "secitem . h" #include "pcert . h"
void png_app_error ( png_const_structrp png_ptr , png_const_charp error_message ) { <START_VULN> if ( png_ptr -> flags & PNG_FLAG_APP_ERRORS_WARN ) <END_VULN> png_warning ( png_ptr , error_message ) ; else png_error ( png_ptr , error_message ) ;
struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; const MODE_INFO * mi = xd -> mi [ 0 ] ; const int is_compound = has_second_ref ( & mi -> mbmi ) ; <START_VULN> const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ; <END_VULN> int ref ; for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) {
<START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 85 ) <END_VULN>
if ( yych <= '9' ) goto yy91 ; if ( yych != ' ; ' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 520 "extstandardvar_unserializer . re"<END_VULN> { long id ;
void png_push_save_buffer ( png_structrp png_ptr ) { <START_VULN> if ( png_ptr -> save_buffer_size ) <END_VULN> { if ( png_ptr -> save_buffer_ptr != png_ptr -> save_buffer ) {
buffer [ nbchars ++ ] = ' & ' ; if ( nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE ) { <START_VULN> growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; <END_VULN> } for ( ; i > 0 ; i -- ) buffer [ nbchars ++ ] = * cur ++ ;
<START_VULN> if ( transforms & PNG_TRANSFORM_STRIP_ALPHA ) <END_VULN> #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED png_set_strip_alpha ( png_ptr ) ; #else
while ( 0x80 != plaintext [ cipher_len - 2 ] && ( cipher_len - 2 > 0 ) ) cipher_len -- ; <START_VULN> if ( 2 == cipher_len ) <END_VULN> return - 1 ; memcpy ( out , plaintext , cipher_len - 2 ) ;
<START_VULN> vpx_memset ( ybf , 0 , sizeof ( YV12_BUFFER_CONFIG ) ) ; <END_VULN> } else { return - 1 ; }
