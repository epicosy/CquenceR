break ; case SIP_UPDATE : res = handle_request_update(p , req ) ; break ; case SIP_ACK : if (seqno == p -> pendinginvite ) { p -> invitestate = INV_TERMINATED ; p -> pendinginvite = 0 ; acked = __sip_ack(p , seqno , 1 , 0 ) ; <START_VULN> if (find_sdp(req ) ) { <END_VULN> if (process_sdp(p , req , SDP_T38_NONE ) ) { return - 1 ; } if (ast_test_flag( & p -> flags [ 0 ] , SIP_DIRECT_MEDIA ) ) { ast_queue_control(p -> owner , AST_CONTROL_SRCCHANGE ) ; } } check_pendings(p ) ; } else if (p -> glareinvite == seqno ) {
INIT_LIST_HEAD( & tasks ) ; do_smart_update(sma , NULL , 0 , 1 , & tasks ) ; <START_VULN> sem_unlock(sma ) ; <END_VULN> wake_up_sem_queue_do( & tasks ) ; kfree_rcu(un , rcu ) ;
#define CEPH_MSGR_TAG_SEQ 13 #define CEPH_MSGR_TAG_KEEPALIVE2 14 #define CEPH_MSGR_TAG_KEEPALIVE2_ACK 15 <START_VULN> <END_VULN>
if (options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size(stream , 1 ) ; <START_VULN> <END_VULN> eol_detect = stream -> flags & (PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;
char * password = * passptr ; <START_VULN> if ( ! (mask & KADM5_ATTRIBUTES ) || <END_VULN> ! (entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ;
{ public : static JSBool GetCallingLocation(JSContext * aContext , const char * * aFilename , <START_VULN> PRUint32 * aLineno ) ; <END_VULN> static jsval ConvertStringToJSVal(const nsString & aProp , JSContext * aContext ) ;
} <START_VULN> sctp_add_cmd_sf(commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC(new_asoc ) ) ; <END_VULN> sctp_add_cmd_sf(commands , SCTP_CMD_DELETE_TCB , SCTP_NULL( ) ) ;
sub_str_end_pos = ustr_len ; } } <START_VULN> <END_VULN> if(sub_str_start_pos > sub_str_end_pos ) { intl_error_set( NULL , U_ILLEGAL_ARGUMENT_ERROR , "grapheme_substr : length is beyond start" , 1 TSRMLS_CC ) ;
} } else { if (state -> object_nl ) ruby_xfree(state -> object_nl ) ; <START_VULN> state -> object_nl = strdup(RSTRING_PTR(object_nl ) ) ; <END_VULN> state -> object_nl_len = len ; } return Qnil ;
extern int rose_validate_nr(struct sock * , unsigned short ) ; extern void rose_write_internal(struct sock * , int ) ; extern int rose_decode(struct sk_buff * , int * , int * , int * , int * , int * ) ; <START_VULN> extern int rose_parse_facilities(unsigned char * , struct rose_facilities_struct * ) ; <END_VULN> extern void rose_disconnect(struct sock * , int , int , int ) ;
int post , err ; char headers [ HTTP_HEADERS_SIZE ] = "" ; char * authstr = NULL , * proxyauthstr = NULL ; <START_VULN> int64_t off = s -> off ; <END_VULN> int len = 0 ; const char * method ; int send_expect_100 = 0 ;
& yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf(line , <START_VULN> " % 4d - % 2d - % 2d , % 2d : % 2d : % 2d . % 9d : % 5s ( % 127 [ A - Za - z0 - 9 : ] ) , Length : % 9u , Pro : % 9d , Off : % 9d , Pri : % 9d , RM : % 9d , Err : % 9d [ % 8x , % 8x ] " , <END_VULN> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error ,
for (x = 0 ; x < hdr -> width ; x + + ) { while (nz < hdr -> depth ) { if ((c = jas_stream_getc(in ) ) == EOF ) { <START_VULN> return - 1 ; <END_VULN> } z = (z << 8 ) | c ; nz + = 8 ;
static const struct net_offload sit_offload = { . callbacks = { . gso_segment = ipv6_gso_segment , <START_VULN> . gro_receive = ipv6_gro_receive , <END_VULN> . gro_complete = sit_gro_complete , } , } ;
int mi_repair_by_sort(MI_CHECK * param , register MI_INFO * info , <START_VULN> const char * name , int rep_quick ) <END_VULN> { int got_error ; uint i ;
} ctx = (krb5_gss_ctx_id_rec * ) context_handle ; <START_VULN> if ( ! ctx -> established ) { <END_VULN> * minor_status = KG_CTX_INCOMPLETE ; return(GSS_S_NO_CONTEXT ) ; }
tidx = i ; break ; } } } if (src_end - src < 2 ) return 0 ; zsize = (src [ 0 ] << 8 ) | src [ 1 ] ; src + = 2 ; <START_VULN> if (src_end - src < zsize ) <END_VULN> return AVERROR_INVALIDDATA ; ret = uncompress(c -> kempf_buf , & dlen , src , zsize ) ; if (ret ) return AVERROR_INVALIDDATA ; src + = zsize ; if (sub_type == 2 ) { kempf_restore_buf(c -> kempf_buf , dlen , dst , c -> framebuf_stride , NULL , 0 , width , height , pal , npal , tidx ) ;
key_addrs -> tipcaddrs . srcnode = hdr -> srcnode ; key_control -> addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS ; } <START_VULN> return true ; <END_VULN> } case htons(ETH_P_MPLS_UC ) :
} if (half_horiz ) run_length *= 2 ; if (run_length > s -> avctx -> width - x ) return AVERROR_INVALIDDATA ; if (color ) { memset(s -> frame -> data [ 0 ] + y * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; <START_VULN> if (half_vert ) <END_VULN> memset(s -> frame -> data [ 0 ] + (y + 1 ) * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; } x + = run_length ; if (x >= s -> avctx -> width ) { x = 0 ; y + = 1 + half_vert ; } }
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : cdf . c , v 1 . 58 20140513 16 : 41 : 06 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
} offsets = (int * ) safe_emalloc(size_offsets , sizeof(int ) , 0 ) ; <START_VULN> <END_VULN> alloc_len = 2 * subject_len + 1 ; result = safe_emalloc(alloc_len , sizeof(char ) , 0 ) ;
size_t count ) { struct o2nm_node * node = to_o2nm_node(item ) ; <START_VULN> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node(node ) ; <END_VULN> int ret , i ; struct rb_node ** p , * parent ; unsigned int octets [ 4 ] ;
} <START_VULN> struct inet_peer * inet_getpeer(struct inetpeer_addr * daddr , int create ) ; <END_VULN> static inline struct inet_peer * inet_getpeer_v4(__be32 v4daddr , int create ) {
} out_unlock : <START_VULN> sem_unlock(sma ) ; <END_VULN> out_wakeup : wake_up_sem_queue_do( & tasks ) ; out_free :
cli_dbgmsg("messageFindArgument : no ' = ' sign found in MIME header ' % s' ( % s ) " , variable , messageGetArgument(m , i ) ) ; return NULL ; } <START_VULN> if(( * + + ptr == '"' ) && (strchr( & ptr [ 1 ] , '"' ) != NULL ) ) { <END_VULN> char * ret = cli_strdup( + + ptr ) ; char * p ;
. data = & ipv6_devconf . mtu6 , . maxlen = sizeof(int ) , . mode = 0644 , <START_VULN> . proc_handler = proc_dointvec , <END_VULN> } , { . procname = "accept_ra" ,
timr -> it_interval = timespec64_to_ktime(new_setting -> it_interval ) ; expires = timespec64_to_ktime(new_setting -> it_value ) ; <START_VULN> sigev_none = (timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <END_VULN> kc -> timer_arm(timr , expires , flags & TIMER_ABSTIME , sigev_none ) ; timr -> it_active = ! sigev_none ;
} phar_flush(phar_obj -> arc . archive , (char * ) & zstub , len , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; } RETURN_TRUE ;
return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; <START_VULN> if (shdr -> sh_size < 1 ) { <END_VULN> return false ; } Elf_(Verdef ) * defs = calloc (shdr -> sh_size , sizeof (char ) ) ;
va_start(ap , files ) ; while (files != NULL ) { _cleanup_free_ char * path = strappend(tmp_dir , files ) ; <START_VULN> assert_se(touch_file(path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) == 0 ) ; <END_VULN> files = va_arg(ap , const char * ) ; } va_end(ap ) ;
{ void ** ptrptr = ptr ; * ptrptr = av_realloc_f( * ptrptr , nmemb , size ) ; <START_VULN> if ( ! * ptrptr && ! (nmemb && size ) ) <END_VULN> return AVERROR(ENOMEM ) ; return 0 ; }
err = sock_do_ioctl(net , sock , cmd , (unsigned long ) & kts ) ; set_fs(old_fs ) ; if ( ! err ) <START_VULN> err = compat_put_timespec(up , & kts ) ; <END_VULN> return err ; }
bool isVector( ) const { return size > 1 && ! matrix ; } bool isScalar( ) const { return size == 1 && ! matrix && ! structure ; } TTypeList * getStruct( ) const { return structure ; } void setStruct(TTypeList * s ) { structure = s ; computeDeepestStructNesting( ) ; } const TString & getTypeName( ) const { <START_VULN> assert(typeName ) ; <END_VULN> return * typeName ; } void setTypeName(const TString & n ) { typeName = NewPoolTString(n . c_str( ) ) ; } bool isField( ) const { return fieldName != 0 ; }
dual_timestamp_get( & t -> last_trigger ) ; if (t -> stamp_path ) <START_VULN> touch_file(t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ; <END_VULN> timer_set_state(t , TIMER_RUNNING ) ; return ;
decoder_info -> bit_count . super_mode [ decoder_info -> bit_count . stat_frame_type ] + = (stream -> bitcnt - bit_start ) ; <START_VULN> if (split_flag ) { <END_VULN> int new_size = size2 ; TEMPLATE(process_block_dec ) (decoder_info , new_size , yposY + 0 * new_size , xposY + 0 * new_size , sub ) ; TEMPLATE(process_block_dec ) (decoder_info , new_size , yposY + 1 * new_size , xposY + 0 * new_size , sub ) ;
struct net_device * netdev ; struct catc * catc ; u8 broadcast [ ETH_ALEN ] ; <START_VULN> int i , pktsz , ret ; <END_VULN> if (usb_set_interface(usbdev , intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) {
BuiltInFunctionEmulator builtInFunctionEmulator ; TInfoSink infoSink ; Output sink . TVariableInfoList attribs ; Active attributes in the compiled shader . TVariableInfoList uniforms ; Active uniforms in the compiled shader . <START_VULN> TMap < TString , TString > varyingLongNameMap ; <END_VULN> } ;
* <START_VULN> <END_VULN> #include "ssl . h" #include "sslimpl . h" #include "sslproto . h" static const char * ssl_GetCompressionMethodName(SSLCompressionMethod compression ) { switch (compression ) {
parse_profile_level_id(s , h264_data , value ) ; } else if ( ! strcmp(attr , "sprop - parameter - sets" ) ) { int ret ; <START_VULN> if (value [ strlen(value ) - 1 ] == ' , ' ) { <END_VULN> av_log(s , AV_LOG_WARNING , "Missing PPS in sprop - parameter - sets , ignoring" ) ; return 0 ; }
} } ; <START_VULN> MODULE_ALIAS("sha384" ) ; <END_VULN> static int __init init(void ) {
} fseek(f , 0 , SEEK_SET ) ; <START_VULN> if (fscanf(f , "PG % [ t ] % c % c % [ t + - ] % d % [ t ] % d % [ t ] % d" , temp , & endian1 , <END_VULN> & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) { fclose(f ) ; fprintf(stderr ,
count + + ; } } loser : if ( nickname ) { PORT_Free(nickname ) ; } <START_VULN> nickname = "" ; <END_VULN> done : if ( firstname ) { PORT_Free(firstname ) ; } if ( org ) { PORT_Free(org ) ; }
ulong flags ; TRACE2(("CVE_2009_3080_gdth_read_event( ) handle % d" , handle ) ) ; spin_lock_irqsave( & ha -> smp_lock , flags ) ; if (handle == - 1 ) eindex = eoldidx ; else eindex = handle ; estr -> event_source = 0 ; <START_VULN> if (eindex >= MAX_EVENTS ) { <END_VULN> spin_unlock_irqrestore( & ha -> smp_lock , flags ) ; return eindex ; } e = & ebuffer [ eindex ] ; if (e -> event_source != 0 ) { if (eindex != elastidx ) { if ( + + eindex == MAX_EVENTS ) eindex = 0 ; } else { eindex = - 1 ;
<START_VULN> struct dump_dir * dd = dd_create(path , client_uid , DEFAULT_DUMP_DIR_MODE ) ; <END_VULN> if ( ! dd ) { error_msg_and_die("Error creating problem directory ' % s'" , path ) ;
if (PASS == conn -> m -> local_tx_start(conn , this_func TSRMLS_CC ) ) { ret = conn -> m -> query(conn , "ROLLBACK" , sizeof("ROLLBACK" ) - 1 TSRMLS_CC ) ; <START_VULN> conn -> m -> local_tx_end(conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_RETURN(ret ) ;
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm" ) ; <START_VULN> MODULE_ALIAS("sha1" ) ; <END_VULN>
nfca_poll -> sens_res = __le16_to_cpu( * ((__u16 * ) data ) ) ; data + = 2 ; <START_VULN> nfca_poll -> nfcid1_len = * data + + ; <END_VULN> pr_debug("sens_res 0x % x , nfcid1_len % d" , nfca_poll -> sens_res , nfca_poll -> nfcid1_len ) ;
s -> line_count = 0 ; s -> off = 0 ; s -> icy_data_read = 0 ; <START_VULN> s -> filesize = - 1 ; <END_VULN> s -> willclose = 0 ; s -> end_chunked_post = 0 ; s -> end_header = 0 ;
* + + p2 = 0 ; if (hdr ) * hdr = atom ; if (val ) * val = p ; <START_VULN> SetHeader(atom , nsDependentCString(p , p2 - p ) , PR_TRUE ) ; <END_VULN> }
command_success_nodata(si , _("Cleared flags in 2 % s2 . " ) , mc -> name ) ; return ; } <START_VULN> else if ( ! strcasecmp(target , "MODIFY" ) && myentity_find_ext(target ) == NULL ) <END_VULN> { free(target ) ;
void user_describe(const struct key * key , struct seq_file * m ) { seq_puts(m , key -> description ) ; <START_VULN> if (key_is_instantiated(key ) ) <END_VULN> seq_printf(m , " : % u" , key -> datalen ) ; }
MediaByteRange const & aByteRange ) ; virtual nsresult Close( ) ; virtual void Suspend(bool aCloseImmediately ) ; virtual void Resume( ) ; virtual already_AddRefed < nsIPrincipal > GetCurrentPrincipal( ) ; bool IsClosed( ) const { return mCacheStream . IsClosed( ) ; } virtual bool CanClone( ) ; <START_VULN> virtual MediaResource * CloneData(MediaDecoder * aDecoder ) ; <END_VULN> void RecordStatisticsTo(MediaChannelStatistics * aStatistics ) MOZ_OVERRIDE { NS_ASSERTION(aStatistics , "Statistics param cannot be null ! " ) ; MutexAutoLock lock(mLock ) ; if ( ! mChannelStatistics ) { mChannelStatistics = aStatistics ; }
err = do_remount_sb(sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash( ) ; <START_VULN> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <END_VULN> mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace(mnt -> mnt_ns ) ; unlock_mount_hash( ) ;
for (j = 0 ; j < 2 ; j + + ) band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv(band -> coord [ 1 ] [ j ] , dy ) ; <START_VULN> band -> prec = av_malloc_array(reslevel -> num_precincts_x * <END_VULN> (uint64_t ) reslevel -> num_precincts_y , sizeof( * band -> prec ) ) ; if ( ! band -> prec )
} } while (base_was_tested ) ; mpz_init_set (tested [ i ] , a ) ; <START_VULN> mpz_powm (z , a , m , n ) ; <END_VULN> if ((mpz_cmp_ui (z , 1 ) == 0 ) || (mpz_cmp (z , n_1 ) == 0 ) ) continue ; composite = 1 ;
krb5_free_error_message(handle -> context , errmsg ) ; } gss_release_buffer( & minor_stat , & client_name ) ; gss_release_buffer( & minor_stat , & service_name ) ; <START_VULN> exit_func : <END_VULN> free_server_handle(handle ) ; return & ret ; }
if (size > batadv_frag_size_limit( ) ) goto free ; entry = hlist_entry(chain -> first , struct batadv_frag_list_entry , list ) ; hlist_del( & entry -> list ) ; skb_out = entry -> skb ; kfree(entry ) ; <START_VULN> if (pskb_expand_head(skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { <END_VULN> kfree_skb(skb_out ) ; skb_out = NULL ; goto free ; } skb_pull_rcsum(skb_out , hdr_size ) ; memmove(skb_out -> data - ETH_HLEN , skb_mac_header(skb_out ) , ETH_HLEN ) ; skb_set_mac_header(skb_out , - ETH_HLEN ) ; skb_reset_network_header(skb_out ) ;
if (errmsg != NULL ) krb5_free_error_message(handle -> context , errmsg ) ; gss_release_buffer( & minor_stat , & client_name ) ; gss_release_buffer( & minor_stat , & service_name ) ; <START_VULN> exit_func : <END_VULN> free_server_handle(handle ) ; return & ret ; }
. fsync = exofs_file_fsync , . flush = exofs_flush , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> } ; const struct inode_operations exofs_file_inode_operations = {
returnNULL ; } ; <START_VULN> if ((psf = calloc (1 , sizeof (SF_PRIVATE ) ) ) == NULL ) <END_VULN> { sf_errno = SFE_MALLOC_FAILED ; returnNULL ; } ;
struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; <START_VULN> int count , i ; <END_VULN> count = be32_to_cpu(aclp -> acl_cnt ) ; if (count > XFS_ACL_MAX_ENTRIES )
"picture will move % s one line" , s -> dst_tff ? "up" : "down" ) ; h = frame -> height ; <START_VULN> for (plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane + + ) { <END_VULN> line_step = frame -> linesize [ plane ] ; line_size = s -> line_size [ plane ] ; data = frame -> data [ plane ] ;
} <START_VULN> CWD_API realpath_cache_bucket * realpath_cache_lookup(const char * path , int path_len , time_t t ) <END_VULN> { return realpath_cache_find(path , path_len , t ) ; }
<START_VULN> <END_VULN> % lld" , st -> st_size ) ;
avpriv_request_sample(pb , "Primer pack item length % d" , item_len ) ; return AVERROR_PATCHWELCOME ; } <START_VULN> if (item_num > 65536 ) { <END_VULN> av_log(mxf -> fc , AV_LOG_ERROR , "item_num % d is too large" , item_num ) ; return AVERROR_INVALIDDATA ; }
TrackTicks inputEndTicks = TimeToTicksRoundUp(rate , inputEnd ) ; TrackTicks inputStartTicks = inputEndTicks - ticks ; <START_VULN> segment -> AppendSlice( * inputTrack -> GetSegment( ) , <END_VULN> NS_MIN(inputTrackEndPoint , inputStartTicks ) , NS_MIN(inputTrackEndPoint , inputEndTicks ) ) ; LOG(PR_LOG_DEBUG , ("TrackUnionStream % p appending % lld ticks of input data to track % d" , this , (long long ) (NS_MIN(inputTrackEndPoint , inputEndTicks ) - NS_MIN(inputTrackEndPoint , inputStartTicks ) ) , outputTrack -> GetID( ) ) ) ; } for (uint32_t j = 0 ; j < mListeners . Length( ) ; + + j ) { MediaStreamListener * l = mListeners [ j ] ;
if (s -> s3 -> tmp . message_type != SSL3_MT_CERTIFICATE_VERIFY ) { s -> s3 -> tmp . reuse_message = 1 ; <START_VULN> if ((peer != NULL ) && (type & EVP_PKT_SIGN ) ) <END_VULN> { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_MISSING_VERIFY_MESSAGE ) ;
int fd = - 1 ; struct xar_header hdr ; fmap_t * map = * ctx -> fmap ; <START_VULN> long length , offset , size , at ; <END_VULN> int encoding ; z_stream strm ; char * toc , * tmpname ;
int php_optind = 1 , use_extended_info = 0 ; char * ini_path_override = NULL ; char * ini_entries = NULL ; <START_VULN> int ini_entries_len = 0 ; <END_VULN> int ini_ignore = 0 ; sapi_module_struct * sapi_module = & cli_sapi_module ;
nsresult SharedOutputString(uint32_t aFlags , bool * aIsCollapsed , nsAString & aResult ) ; bool IsModifiable( ) ; bool CanCutOrCopy( ) ; <START_VULN> bool FireClipboardEvent(int32_t aType ) ; <END_VULN> bool UpdateMetaCharset(nsIDOMDocument * aDocument , const nsACString & aCharacterSet ) ; protected : nsCOMPtr < nsIEditRules > mRules ;
bool mListenerEnabled ; bool mReturnInEmptyLIKillsList ; bool mDidDeleteSelection ; bool mDidRangedDelete ; bool mRestoreContentEditableCount ; nsRefPtr < nsRange > mUtilRange ; PRUint32 mJoinOffset ; nsCOMPtr < nsIDOMNode > mNewBlock ; <START_VULN> nsRangeStore mRangeItem ; <END_VULN> StyleCache mCachedStyles [ SIZE_STYLE_TABLE ] ; } ; #endif
if ( ! dev -> in_out_buffer ) return - ENOMEM ; <START_VULN> spin_lock_init( & dev -> lock ) ; <END_VULN> ret = hid_parse(hdev ) ; if (ret ) {
jsval * rval ) ; JS_REQUIRES_STACK JSRecordingStatus newString(JSObject * ctor , uint32 argc , jsval * argv , jsval * rval ) ; JS_REQUIRES_STACK JSRecordingStatus interpretedFunctionCall(jsval & fval , JSFunction * fun , uintN argc , bool constructing ) ; JS_REQUIRES_STACK void propagateFailureToBuiltinStatus(nanojit : : LIns * ok_ins , nanojit : : LIns * & status_ins ) ; JS_REQUIRES_STACK JSRecordingStatus emitNativeCall(JSSpecializedNative * sn , uintN argc , <START_VULN> nanojit : : LIns * args [ ] ) ; <END_VULN> JS_REQUIRES_STACK void emitNativePropertyOp(JSScope * scope , JSScopeProperty * sprop , nanojit : : LIns * obj_ins , bool setflag , nanojit : : LIns * boxed_ins ) ; JS_REQUIRES_STACK JSRecordingStatus callSpecializedNative(JSNativeTraceInfo * trcinfo , uintN argc , bool constructing ) ; JS_REQUIRES_STACK JSRecordingStatus callNative(uintN argc , JSOp mode ) ;
if (shdr -> sh_link > bin -> ehdr . e_shnum ) { return NULL ; } <START_VULN> if (shdr -> sh_size < 1 ) { <END_VULN> return NULL ; } sdb = sdb_new0 ( ) ;
. open = ftrace_notrace_open , . read = seq_read , . write = ftrace_notrace_write , <START_VULN> . llseek = ftrace_regex_lseek , <END_VULN> . release = ftrace_regex_release , } ;
nsCOMPtr < nsPIDOMEventTarget > mChromeEventHandler ; nsCOMPtr < nsIDOMDocument > mDocument ; <START_VULN> nsIDOMElement * mFrameElement ; <END_VULN> nsIDocShell * mDocShell ; PRUint32 mModalStateDepth ; nsTimeout * mRunningTimeout ; PRUint32 mMutationBits ;
! jas_safe_size_mul(size , cmpt -> cps_ , & size ) ) { goto error ; } <START_VULN> cmpt -> stream_ = (inmem ) ? jas_stream_memopen(0 , size ) : <END_VULN> jas_stream_tmpfile( ) ; if ( ! cmpt -> stream_ ) { goto error ;
if (FAILURE == phar_copy_entry_fp(oldentry , & newentry , & error TSRMLS_CC ) ) { efree(newentry . filename ) ; php_stream_close(newentry . fp ) ; <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; return ; }
(sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { ext4_msg(sb , KERN_ERR , "Journal does not support " "requested data journaling mode" ) ; <START_VULN> goto failed_mount4 ; <END_VULN> } default : break ;
oggpack_write(opb , ci -> mode_param [ i ] -> transformtype , 16 ) ; oggpack_write(opb , ci -> mode_param [ i ] -> mapping , 8 ) ; } oggpack_write(opb , 1 , 1 ) ; return(0 ) ; err_out : return( - 1 ) ; <START_VULN> } <END_VULN> int vorbis_commentheader_out(vorbis_comment * vc , ogg_packet * op ) { oggpack_buffer opb ; oggpack_writeinit( & opb ) ; if(_vorbis_pack_comment( & opb , vc ) ) return OV_EIMPL ;
& _vq_book_res0a_13 , NULL } ; float * testvec [ ] = { test1 , test3 } ; int main( ) { oggpack_buffer write ; oggpack_buffer read ; long ptr = 0 , i ; oggpack_writeinit( & write ) ; <START_VULN> <END_VULN> fprintf(stderr , "Testing codebook abstraction . . . : " ) ; while(testlist [ ptr ] ) { codebook c ; static_codebook s ; float * qv = alloca(sizeof( * qv ) * TESTSIZE ) ; float * iv = alloca(sizeof( * iv ) * TESTSIZE ) ; memcpy(qv , testvec [ ptr ] , sizeof( * qv ) * TESTSIZE ) ;
phar_flush(phar , 0 , 0 , 1 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; efree(oldpath ) ; return NULL ;
<START_VULN> found = (unsigned char * ) php_memnstr((char * ) haystack + offset , (char * ) needle , needle_len , (char * ) haystack + haystack_len ) ; <END_VULN> if ( ! found ) {
tcph = (struct tcphdr * ) (skb_network_header(skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ; <START_VULN> if (len < tcp_hdrlen ) <END_VULN> return - 1 ; if (info -> mss == XT_TCPMSS_CLAMP_PMTU ) {
<START_VULN> if ((ctxt -> mode == X86EMUL_MODE_PROT32 ) && (efer & EFER_LMA ) <END_VULN> && ! vendor_intel(ctxt ) ) return emulate_ud(ctxt ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : toplevel libogg include <START_VULN> last mod : $ Id : ogg . h 16051 2009 - 05 - 27 05 : 00 : 06Z xiphmont $ <END_VULN> #ifndef _OGG_H #define _OGG_H #ifdef __cplusplus extern "C" { #endif
struct rad_handle ; <START_VULN> intrad_get_vendor_attr(u_int32_t * , const void ** , size_t * ) ; <END_VULN> intrad_put_vendor_addr(struct rad_handle * , int , int , struct in_addr ) ; intrad_put_vendor_attr(struct rad_handle * , int , int , const void * , size_t ) ;
{ STATE_MAIN_R0 , STATE_MAIN_R1 , SMF_ALL_AUTH | SMF_REPLY , P(SA ) , P(VID ) | P(CR ) , PT(NONE ) , <START_VULN> EVENT_v1_RETRANSMIT , main_inI1_outR1 } , <END_VULN>
mt -> mt_buffer_ [ i ] = <START_VULN> (1812433253UL * (mt -> mt_buffer_ [ i - 1 ] ^ <END_VULN> (mt -> mt_buffer_ [ i - 1 ] >> 30 ) ) + i ) ; } }
merge : <START_VULN> if (flag != EXT4_GET_BLOCKS_PRE_IO ) <END_VULN> ext4_ext_try_to_merge(inode , path , nearex ) ;
MODULE_AUTHOR("Tim Chen < tim . c . chen@linux . intel . com > " ) ; MODULE_DESCRIPTION("T10 DIF CRC calculation . " ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("crct10dif" ) ; <END_VULN>
_vp_offset_and_mix(psy_look , noise , tone , 1 , logmask , mdct , logmdct ) ; <START_VULN> <END_VULN> #if 0 if(vi -> channels == 2 ) { if(i == 0 ) _analysis_output("aotuvM1_L" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ; else _analysis_output("aotuvM1_R" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ; } else { _analysis_output("aotuvM1" , seq , aotuv , psy_look -> n , 1 , 1 , 0 ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : window functions <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_WINDOW_ #define _V_WINDOW_ extern float * _vorbis_window_get(int n ) ; extern void _vorbis_apply_window(float * d , int * winno , long * blocksizes ,
( * JSGCCallback ) (JSRuntime * rt , JSGCStatus status ) ; typedef enum JSFinalizeStatus { JSFINALIZE_START , JSFINALIZE_END } JSFinalizeStatus ; typedef void <START_VULN> ( * JSFinalizeCallback ) (JSFreeOp * fop , JSFinalizeStatus status ) ; <END_VULN> typedef void ( * JSTraceDataOp ) (JSTracer * trc , void * data ) ;
} if (j >= ISDN_MSNLEN ) break ; } if ( + + i > 9 ) break ; } } else { p = (char __user * ) iocts . arg ; for (i = 0 ; i < 10 ; i + + ) { <START_VULN> sprintf(bname , " % s % s" , <END_VULN> strlen(dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , (i < 9 ) ? " , " : "0" ) ; if (copy_to_user(p , bname , strlen(bname ) + 1 ) ) return - EFAULT ; p + = strlen(bname ) ; } } return 0 ; } else
bodyLength = pntoh16(data + offset + 2 ) ; <START_VULN> if ((tot_len - offset - 4 ) < bodyLength ) { <END_VULN> AIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys" , "EAPOL body too short" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; }
size = 1 ; for (i = 0 ; i < cpp ; i + + ) <START_VULN> size *= 94 ; <END_VULN> if (ncolors <= 0 || ncolors > size ) { av_log(avctx , AV_LOG_ERROR , "invalid number of colors : % d" , ncolors ) ;
static inline void set_pte_at(struct mm_struct * mm , unsigned long addr , pte_t * ptep , pte_t pte ) { <START_VULN> if (pte_valid_ng(pte ) ) { <END_VULN> if ( ! pte_special(pte ) && pte_exec(pte ) ) __sync_icache_dcache(pte , addr ) ; if (pte_dirty(pte ) && pte_write(pte ) )
# define SSL_ST_BEFORE 0x4000 # define SSL_ST_OK 0x03 # define SSL_ST_RENEGOTIATE (0x04 | SSL_ST_INIT ) <START_VULN> # define SSL_ST_ERR 0x05<END_VULN> # define SSL_CB_LOOP 0x01 # define SSL_CB_EXIT 0x02
<START_VULN> if( * p + 2 > end ) <END_VULN> { MBEDTLS_SSL_DEBUG_MSG( 1 , ( "bad client key exchange message" ) ) ; return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : LPC low level routines <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_LPC_H_ #define _V_LPC_H_ #include "vorbiscodec . h"
if ( ! TRC ) return NULL ; gamma_table = malloc(sizeof(float ) * 256 ) ; if (gamma_table ) { if (TRC -> type == PARAMETRIC_CURVE_TYPE ) { compute_curve_gamma_table_type_parametric(gamma_table , TRC -> parameter , TRC -> count ) ; } else { if (TRC -> count == 0 ) { compute_curve_gamma_table_type0(gamma_table ) ; } else if (TRC -> count == 1 ) { <START_VULN> compute_curve_gamma_table_type1(gamma_table , u8Fixed8Number_to_float(TRC -> data [ 0 ] ) ) ; <END_VULN> } else { compute_curve_gamma_table_type2(gamma_table , TRC -> data , TRC -> count ) ; } } } return gamma_table ; }
&& iso9660 -> seenJoliet ) { vd = & (iso9660 -> joliet ) ; <START_VULN> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <END_VULN> skipsize -= iso9660 -> current_position ; skipsize = __archive_read_consume(a , skipsize ) ; if (skipsize < 0 )
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID("@(# ) $ File : softmagic . c , v 1 . 187 20140513 16 : 42 : 17 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
0 . 9919389832F , 0 . 9931929973F , 0 . 9942985174F , 0 . 9952667537F , 0 . 9961087037F , 0 . 9968351119F , 0 . 9974564312F , 0 . 9979827858F , 0 . 9984239359F , 0 . 9987892441F , 0 . 9990876435F , 0 . 9993276081F , 0 . 9995171241F , 0 . 9996636648F , 0 . 9997741654F , 0 . 9998550016F , 0 . 9999119692F , 0 . 9999502656F , 0 . 9999744742F , 0 . 9999885497F , 0 . 9999958064F , 0 . 9999989077F , 0 . 9999998584F , 0 . 9999999983F , } ; <START_VULN> static float vwin512 [ 256 ] = { <END_VULN> 0 . 0000147849F , 0 . 0001330607F , 0 . 0003695946F , 0 . 0007243509F , 0 . 0011972759F , 0 . 0017882983F , 0 . 0024973285F , 0 . 0033242588F , 0 . 0042689632F , 0 . 0053312973F , 0 . 0065110982F , 0 . 0078081841F , 0 . 0092223540F , 0 . 0107533880F , 0 . 0124010466F , 0 . 0141650703F , 0 . 0160451800F , 0 . 0180410758F , 0 . 0201524373F , 0 . 0223789233F , 0 . 0247201710F , 0 . 0271757958F , 0 . 0297453914F , 0 . 0324285286F , 0 . 0352247556F , 0 . 0381335972F , 0 . 0411545545F , 0 . 0442871045F , 0 . 0475306997F , 0 . 0508847676F , 0 . 0543487103F , 0 . 0579219038F ,
printf(" ] ( % llu ) " , ddword_tmp ) ; break ; case PT_LONG : <START_VULN> printf(" Value : % li" , * ((long * ) mapidata -> data ) ) ; <END_VULN> break ; case PT_I2 : printf(" Value : % hi" , * ((short int * ) mapidata -> data ) ) ;
<START_VULN> remaining = tvb_captured_length_remaining(tvb , offset ) ; <END_VULN> if (remaining <= 0 ) { if (data ) * data = g_strdup("" ) ;
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm (ARM ) " ) ; <START_VULN> MODULE_ALIAS("sha1" ) ; <END_VULN> MODULE_AUTHOR("David McCullough < ucdevel@gmail . com > " ) ;
{ unsigned short array_size = buf [ 2 ] | (buf [ 3 ] << 8 ) ; int first_key = buf [ 4 ] | (buf [ 5 ] << 8 ) | (buf [ 6 ] << 16 ) | (buf [ 7 ] << 24 ) ; <START_VULN> sprintf (op -> buf_asm , "packed - switch - payload % d , % d" , array_size , first_key ) ; <END_VULN> size = 8 ; payload = 2 * (array_size * 2 ) ; len = 0 ;
} ret = 1 ; <START_VULN> if ( ! SSL_USE_ETM(s ) && EVP_MD_CTX_md(s -> read_hash ) != NULL ) <END_VULN> mac_size = EVP_MD_CTX_size(s -> read_hash ) ; if ((bs != 1 ) && ! send ) { int tmpret ;
umount_mnt(p ) ; } } <START_VULN> else umount_tree(mnt , 0 ) ; <END_VULN> } unlock_mount_hash( ) ; put_mountpoint(mp ) ;
if (context && php_stream_context_get_option(context , "http" , "header" , & tmpzval ) == SUCCESS ) { tmp = NULL ; <START_VULN> <END_VULN> if (Z_TYPE_PP(tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval ** tmpheader = NULL ;
TraceMonitor * tm = & JS_THREAD_DATA(cx ) -> traceMonitor ; JS_ASSERT(tm -> codeAlloc && tm -> dataAlloc && tm -> traceAlloc ) ; if (bytes > 1 G ) bytes = 1 G ; if (bytes < 128 K ) bytes = 128 K ; tm -> maxCodeCacheBytes = bytes ; } <START_VULN> void<END_VULN> InitJIT(TraceMonitor * tm ) { #if defined JS_JIT_SPEW tm -> profAlloc = NULL ; if ( ! did_we_set_up_debug_logging ) { InitJITLogController( ) ; did_we_set_up_debug_logging = true ; }
char * vorbis_comment_query(vorbis_comment * vc , const char * tag , int count ) { long i ; int found = 0 ; int taglen = strlen(tag ) + 1 ; char * fulltag = alloca(taglen + 1 ) ; strcpy(fulltag , tag ) ; strcat(fulltag , " = " ) ; <START_VULN> <END_VULN> for(i = 0 ; i < vc -> comments ; i + + ) { if( ! tagcompare(vc -> user_comments [ i ] , fulltag , taglen ) ) { if(count == found ) return vc -> user_comments [ i ] + taglen ; else found + + ; }
* <START_VULN> #include < k5 - platform . h > <END_VULN> #include < gssrpcrpc . h > #include < gssapigssapi_krb5 . h > #include < syslog . h >
} else if (ret == - EINPROGRESS ) { ret = 0 ; } else { <START_VULN> goto couldnt_alloc_key ; <END_VULN> } key_put(dest_keyring ) ;
size = sizeof( * dl ) + dev_num * sizeof( * di ) ; <START_VULN> dl = kmalloc(size , GFP_KERNEL ) ; <END_VULN> if ( ! dl ) return - ENOMEM ;
frag -> len -= len ; } <START_VULN> if (vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { <END_VULN> vcpu -> mmio_needed = 0 ;
le16_to_cpu(entry -> e_value_offs ) + size > inode -> i_sb -> s_blocksize ) goto bad_block ; <START_VULN> if (ext2_xattr_cache_insert(bh ) ) <END_VULN> ea_idebug(inode , "cache insert failed" ) ; if (buffer ) { error = - ERANGE ;
if (one_entry_in_sg ) { if (unlikely(req -> src != req -> dst ) ) { scatterwalk_unmap(dst ) ; scatterwalk_done( & dst_sg_walk , 0 , 0 ) ; } scatterwalk_unmap(src ) ; scatterwalk_unmap(assoc ) ; scatterwalk_done( & src_sg_walk , 0 , 0 ) ; scatterwalk_done( & assoc_sg_walk , 0 , 0 ) ; } else { <START_VULN> scatterwalk_map_and_copy(dst , req -> dst , 0 , req -> cryptlen , 1 ) ; <END_VULN> kfree(src ) ; } return retval ; }
#define __S001 PAGE_READONLY #define __S010 PAGE_SHARED #define __S011 PAGE_SHARED <START_VULN> #define __S100 PAGE_EXECONLY<END_VULN> #define __S101 PAGE_READONLY_EXEC #define __S110 PAGE_SHARED_EXEC #define __S111 PAGE_SHARED_EXEC
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : LPC low level routines <START_VULN> last mod : $ Id : lpc . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN>
typedef struct { int nfats ; off_t fat_start ; <START_VULN> unsigned int fat_size ; <END_VULN> unsigned int fat_bits ; unsigned int eff_fat_bits ; uint32_t root_cluster ;
<START_VULN> if(offset > pkt_len ) { <END_VULN> * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup("netscreen : too much hex - data" ) ; return FALSE ;
address = address & huge_page_mask(h ) ; pgoff = vma_hugecache_offset(h , vma , address ) ; <START_VULN> mapping = (struct address_space * ) page_private(page ) ; <END_VULN> if (vm_flags & VM_NORESERVE ) return 0 ;
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID("@(# ) $ File : softmagic . c , v 1 . 195 20140924 19 : 49 : 07 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
{ uint32_t length ; uint32_t flags ; <START_VULN> <END_VULN> char c_string [ 1 ] ; } SIZED_STRING ;
l_current_pi -> include = 00 ; if (l_step_l <= (SIZE_MAX (l_tcp -> numlayers + 1U ) ) ) { <START_VULN> l_current_pi -> include = (OPJ_INT16 * ) opj_calloc((l_tcp -> numlayers + 1 ) * l_step_l , sizeof(OPJ_INT16 ) ) ; <END_VULN> } if
#include < stdlib . h > #include < stdio . h > #include < string . h > <START_VULN> #include "compilerdebug . h"<END_VULN> #include "compilerpreprocessorslglobals . h" #undef malloc #undef realloc #undef free
int haystack_len , needle_len ; unsigned char * found ; long loffset = 0 ; <START_VULN> int32_t offset = 0 ; <END_VULN> int ret_pos ; if (zend_parse_parameters(ZEND_NUM_ARGS( ) TSRMLS_CC , "ss | l" , (char ** ) & haystack , & haystack_len , (char ** ) & needle , & needle_len , & loffset ) == FAILURE ) {
void SetDirectionFromNewTextNode(nsIContent * aTextNode ) ; <START_VULN> void ResetDirectionSetByTextNode(nsTextNode * aTextNode ) ; <END_VULN> void SetDirectionalityFromValue(mozilla : : dom : : Element * aElement , const nsAString & aValue , bool aNotify ) ;
oggpack_write(opb , 1 , 1 ) ; return(0 ) ; err_out : return( - 1 ) ; } int vorbis_commentheader_out(vorbis_comment * vc , <START_VULN> ogg_packet * op ) { <END_VULN> oggpack_buffer opb ; oggpack_writeinit( & opb ) ; if(_vorbis_pack_comment( & opb , vc ) ) return OV_EIMPL ; op -> packet = _ogg_malloc(oggpack_bytes( & opb ) ) ; memcpy(op -> packet , opb . buffer , oggpack_bytes( & opb ) ) ;
if ( ! timr ) return - EINVAL ; <START_VULN> overrun = timr -> it_overrun_last ; <END_VULN> unlock_timer(timr , flags ) ; return overrun ;
static void TraceBlackJS(JSTracer * trc , void * data ) ; static void TraceGrayJS(JSTracer * trc , void * data ) ; void TraceXPConnectRoots(JSTracer * trc ) ; void AddXPConnectRoots(nsCycleCollectionTraversalCallback & cb ) ; void UnmarkSkippableJSHolders( ) ; static void GCCallback(JSRuntime * rt , JSGCStatus status ) ; <START_VULN> static void FinalizeCallback(JSFreeOp * fop , JSFinalizeStatus status ) ; <END_VULN> inline void AddVariantRoot(XPCTraceableVariant * variant ) ; inline void AddWrappedJSRoot(nsXPCWrappedJS * wrappedJS ) ; inline void AddObjectHolderRoot(XPCJSObjectHolder * holder ) ; nsresult AddJSHolder(void * aHolder , nsScriptObjectTracer * aTracer ) ; nsresult RemoveJSHolder(void * aHolder ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : fft transform <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_SMFT_H_ #define _V_SMFT_H_ #include "vorbiscodec . h"
int2store(buffer , (unsigned int ) option ) ; ret = conn -> m -> simple_command(conn , COM_SET_OPTION , buffer , sizeof(buffer ) , PROT_EOF_PACKET , FALSE , TRUE TSRMLS_CC ) ; <START_VULN> <END_VULN> conn -> m -> local_tx_end(conn , this_func , ret TSRMLS_CC ) ; } DBG_RETURN(ret ) ;
if ( ! p -> leave_spinning ) btrfs_set_path_blocking(p ) ; <START_VULN> if (ret < 0 ) <END_VULN> btrfs_release_path(p ) ; return ret ; }
{ if ((opcode & OPCODE ) == SPEC0 && (opcode & FUNC ) == SYNC ) { perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS , <START_VULN> 1 , 0 , regs , 0 ) ; <END_VULN> return 0 ; }
return 0 ; fail : <START_VULN> spin_unlock_irqrestore( & dev -> lock , flags ) ; <END_VULN> return ret < 0 ? ret : - EIO ; }
{ unsigned short array_size = buf [ 2 ] | (buf [ 3 ] << 8 ) ; <START_VULN> sprintf (op -> buf_asm , "sparse - switch - payload % d" , array_size ) ; <END_VULN> size = 4 ; payload = 2 * (array_size * 4 ) ; len = 0 ;
synchronize_rcu( ) ; <START_VULN> <END_VULN> mutex_unlock( & memcg -> thresholds_lock ) ; }
bool is_checkpointed_data(struct f2fs_sb_info * sbi , block_t blkaddr ) ; void refresh_sit_entry(struct f2fs_sb_info * sbi , block_t old , block_t new ) ; void stop_discard_thread(struct f2fs_sb_info * sbi ) ; <START_VULN> void f2fs_wait_discard_bios(struct f2fs_sb_info * sbi ) ; <END_VULN> void clear_prefree_segments(struct f2fs_sb_info * sbi , struct cp_control * cpc ) ; void release_discard_addrs(struct f2fs_sb_info * sbi ) ; int npages_for_summary_flush(struct f2fs_sb_info * sbi , bool for_ra ) ;
return res ; } <START_VULN> mp_err<END_VULN> ec_GFp_pt_add_jm_aff(const mp_int * px , const mp_int * py , const mp_int * pz , const mp_int * paz4 , const mp_int * qx , const mp_int * qy , mp_int * rx , mp_int * ry , mp_int * rz , mp_int * raz4 , mp_int scratch [ ] , const ECGroup * group ) { mp_err res = MP_OKAY ; mp_int * A , * B , * C , * D , * C2 , * C3 ;
<START_VULN> Packet * p = BuildTestPacket(99 , 0 , 1 , 'A' + i , 16 ) ; <END_VULN> if (p == NULL ) goto end ;
unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; <START_VULN> int index , count , i ; <END_VULN> if (get_user(index , & c -> index ) || __get_user(count , & c -> count ) ||
key -> expiry = prep -> expiry ; <START_VULN> if ( ! test_bit(KEY_FLAG_NEGATIVE , & key -> flags ) ) <END_VULN> zap = dereference_key_locked(key ) ; rcu_assign_keypointer(key , prep -> payload . data [ 0 ] ) ; prep -> payload . data [ 0 ] = NULL ;
} if (strncasecmp(resource -> scheme , "http" , sizeof("http" ) ) && strncasecmp(resource -> scheme , "https" , sizeof("https" ) ) ) { <START_VULN> if ( ! context || <END_VULN> php_stream_context_get_option(context , wrapper -> wops -> label , "proxy" , & tmpzval ) == FAILURE || Z_TYPE_PP(tmpzval ) != IS_STRING || Z_STRLEN_PP(tmpzval ) <= 0 ) {
goto bad_block ; entry = next ; } <START_VULN> if (ext2_xattr_cache_insert(bh ) ) <END_VULN> ea_idebug(inode , "cache insert failed" ) ;
HDC mMemoryDC ; nsTransparencyMode mTransparencyMode ; #endif PRPackedBool mIsTopWidgetWindow ; PRPackedBool mHas3DBorder ; PRPackedBool mIsShiftDown ; PRPackedBool mIsControlDown ; PRPackedBool mIsAltDown ; <START_VULN> PRPackedBool mIsDestroying ; <END_VULN> PRPackedBool mIsVisible ; PRPackedBool mIsInMouseCapture ; PRPackedBool mIsInMouseWheelProcessing ; PRPackedBool mUnicodeWidget ; PRPackedBool mIsPluginWindow ; PRPackedBool mPainting ; char mLeadByte ;
} and 40 , replicate the 100dB curve to 110 * for(j = 0 ; j < 6 ; j + + ) memcpy(workc [ i ] [ j + 2 ] , tonemasks [ i ] [ j ] , EHMER_MAX * sizeof( * tonemasks [ i ] [ j ] ) ) ; memcpy(workc [ i ] [ 0 ] , tonemasks [ i ] [ 0 ] , EHMER_MAX * sizeof( * tonemasks [ i ] [ 0 ] ) ) ; memcpy(workc [ i ] [ 1 ] , tonemasks [ i ] [ 0 ] , EHMER_MAX * sizeof( * tonemasks [ i ] [ 0 ] ) ) ; <START_VULN> <END_VULN> for(j = 0 ; j < P_LEVELS ; j + + ) { for(k = 0 ; k < EHMER_MAX ; k + + ) { float adj = center_boost + abs(EHMER_OFFSET - k ) * center_decay_rate ; if(adj < 0 . && center_boost > 0 ) adj = 0 . ; if(adj > 0 . && center_boost < 0 ) adj = 0 . ; workc [ i ] [ j ] [ k ] + = adj ; }
phar_flush(entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; }
rc = decode_operand(ctxt , & ctxt -> dst , (ctxt -> d >> DstShift ) & OpMask ) ; <START_VULN> done : <END_VULN> if (ctxt -> rip_relative ) ctxt -> memopp -> addr . mem . ea + = ctxt -> _eip ; return (rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ; }
inline void JSObject : : initCall(JSContext * cx , const js : : Bindings & bindings , JSObject * parent ) { init(cx , & js : : CallClass , & js : : types : : emptyTypeObject , parent , NULL , false ) ; <START_VULN> lastProp = bindings . lastShape( ) ; <END_VULN> if (bindings . extensibleParents( ) ) setOwnShape(js_GenerateShape(cx ) ) ; else
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) { <START_VULN> c -> tile_stride = FFALIGN(c -> tile_width * 3 , 16 ) ; <END_VULN> aligned_height = FFALIGN(c -> tile_height , 16 ) ; av_free(c -> synth_tile ) ; av_free(c -> jpeg_tile ) ;
hwc -> event_base = 0 ; } else if (hwc -> idx >= X86_PMC_IDX_FIXED ) { hwc -> config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL ; <START_VULN> hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ; <END_VULN> } else { hwc -> config_base = x86_pmu_config_addr(hwc -> idx ) ; hwc -> event_base = x86_pmu_event_addr(hwc -> idx ) ;
} } * q = '0' ; <START_VULN> <END_VULN> RETVAL_STRINGL(erealloc(out_str , q - out_str + 1 ) , q - out_str , 0 ) ; }
* bool NS_FASTCALL SetCapacity( size_type newCapacity ) ; <START_VULN> void NS_FASTCALL SetLength( size_type newLength ) ; <END_VULN> void Truncate( size_type newLength = 0 ) { NS_ASSERTION(newLength <= mLength , "Truncate cannot make string longer" ) ; SetLength(newLength ) ; }
#ifndef _LINUX_JIFFIES_H #define _LINUX_JIFFIES_H <START_VULN> #include < linuxcalc64 . h > <END_VULN> #include < linuxkernel . h > #include < linuxtypes . h > #include < linuxtime . h >
memset(flow , 0 , sizeof( * flow ) ) ; again : switch (proto ) { case __constant_htons(ETH_P_IP ) : { const struct iphdr * iph ; struct iphdr _iph ; ip : iph = skb_header_pointer(skb , nhoff , sizeof(_iph ) , & _iph ) ; <START_VULN> if ( ! iph ) <END_VULN> return false ; if (ip_is_fragment(iph ) ) ip_proto = 0 ; else ip_proto = iph -> protocol ; iph_to_flow_copy_addrs(flow , iph ) ; nhoff + = iph -> ihl * 4 ; break ; }
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("CTR Counter block mode" ) ; <START_VULN> MODULE_ALIAS("rfc3686" ) ; <END_VULN>
if ( ! err ) { map_bh(bh , inode -> i_sb , map . m_pblk ) ; bh -> b_state = (bh -> b_state & ~ F2FS_MAP_FLAGS ) | map . m_flags ; <START_VULN> bh -> b_size = map . m_len << inode -> i_blkbits ; <END_VULN> } return err ; }
char * fn = rpmfilesFN(files , firsthardlink ) ; <START_VULN> rc = expandRegular(fi , fn , psm , nodigest , 0 ) ; <END_VULN> firsthardlink = - 1 ; free(fn ) ; }
} atomic_dec( & key -> user -> nkeys ) ; <START_VULN> if (test_bit(KEY_FLAG_INSTANTIATED , & key -> flags ) ) <END_VULN> atomic_dec( & key -> user -> nikeys ) ; key_user_put(key -> user ) ;
void * regs ; gpa_t vapic_addr ; <START_VULN> struct page * vapic_page ; <END_VULN> unsigned long pending_events ; unsigned int sipi_vector ; } ;
run_test( & test2 , test2_result ) ; fprintf(stderr , "OKDequant test 3 . . . " ) ; run_test( & test3 , test3_result ) ; fprintf(stderr , "OKDequant test 4 . . . " ) ; run_test( & test4 , test4_result ) ; fprintf(stderr , "OKDequant test 5 . . . " ) ; run_test( & test5 , test5_result ) ; fprintf(stderr , "OK" ) ; <START_VULN> <END_VULN> return(0 ) ; } #endif
{ . node = { . next = NULL , <START_VULN> . pprev = & init_struct_pid . tasks [ type ] . first , <END_VULN> } , . pid = & init_struct_pid , }
static inline bool kvm_apic_has_events(struct kvm_vcpu * vcpu ) { <START_VULN> return vcpu -> arch . apic -> pending_events ; <END_VULN> } static inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq * irq )
lblkno = args -> rmtblkno ; blkcnt = args -> rmtblkcnt ; <START_VULN> valuelen = args -> valuelen ; <END_VULN> while (valuelen > 0 ) { struct xfs_buf * bp ; xfs_daddr_tdblkno ;
int SSL_get_fd(SSL * ) ; void _SSL_close (SSL * ssl ) ; <START_VULN> <END_VULN> int _SSL_get_cert_info (struct cert_info * cert_info , SSL * ssl ) ; struct chiper_info * _SSL_get_cipher_info (SSL * ssl ) ;
goto end ; <START_VULN> p = BuildTestPacket(id , 1 , 0 , 'A' , 0 ) ; <END_VULN> if (p == NULL ) goto end ;
class nsJPEGDecoder : public Decoder { public : nsJPEGDecoder(RasterImage & aImage , Decoder : : DecodeStyle aDecodeStyle ) ; virtual ~ nsJPEGDecoder( ) ; virtual void InitInternal( ) ; <START_VULN> virtual void WriteInternal(const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal( ) ; virtual Telemetry : : ID SpeedHistogram( ) ; void NotifyDone( ) ; protected : Orientation ReadOrientationFromEXIF( ) ; void OutputScanlines(bool * suspend ) ;
TEST_MSG("Expected : % zu" , exp ) ; TEST_MSG("Actual : % zu" , enclen ) ; } <START_VULN> declen = mutt_b64_decode(out2 , out1 ) ; <END_VULN> if ( ! TEST_CHECK(declen == i ) ) { TEST_MSG("Expected : % zu" , i ) ;
if (ast_test_flag( & p -> flags [ 1 ] , SIP_PAGE2_PREFERRED_CODEC ) ) { ast_codec_choose( & p -> prefs , p -> jointcaps , 1 , & tmp_fmt ) ; ast_format_cap_set(p -> jointcaps , & tmp_fmt ) ; } } if (p -> rtp ) { <START_VULN> if (portno > 0 ) { <END_VULN> ast_sockaddr_set_port(sa , portno ) ; ast_rtp_instance_set_remote_address(p -> rtp , sa ) ; if (debug ) { ast_verbose("Peer audio RTP is at port % s" , ast_sockaddr_stringify(sa ) ) ; } ast_rtp_codecs_payloads_copy( & newaudiortp , ast_rtp_instance_get_codecs(p -> rtp ) , p -> rtp ) ; ast_rtp_instance_set_prop(p -> rtp , AST_RTP_PROPERTY_RTCP , 1 ) ;
s + = 11 ; SKIPWS(s ) ; ptmp = tmp ; <START_VULN> while (isdigit((unsigned char ) * s ) ) <END_VULN> * ptmp + + = * s + + ; * ptmp = '0' ; if (mutt_str_atol(tmp , & h -> content_length ) < 0 )
assert (sizeof (sf_count_t ) == 8 ) ; <START_VULN> if ((psf = calloc (1 , sizeof (SF_PRIVATE ) ) ) == NULL ) <END_VULN> { sf_errno = SFE_MALLOC_FAILED ; returnNULL ; } ;
{ struct nfs4_opendata * opendata ; <START_VULN> opendata = nfs4_opendata_alloc( & ctx -> path , state -> owner , 0 , NULL ) ; <END_VULN> if (opendata == NULL ) return ERR_PTR( - ENOMEM ) ; opendata -> state = state ;
t = plaintext -> len ; t -= paddingLength + overhead ; <START_VULN> <END_VULN> good = DUPLICATE_MSB_TO_ALL( ~ t ) ; t = blockSize - (paddingLength + 1 ) ;
if (PASS == (ret = PACKET_READ(stats_header , conn ) ) ) { <START_VULN> * message = estrndup(stats_header -> message , stats_header -> message_len ) ; <END_VULN> * message_len = stats_header -> message_len ; DBG_INF( * message ) ; }
{ int i ; for(i = 0 ; i <= 31 ; i + + ) { <START_VULN> if(x & (1 << i ) ) return i ; <END_VULN> } return 0 ; }
case CIPSO_V4_TAG_LOCAL : <START_VULN> if ( ! (skb -> dev -> flags & IFF_LOOPBACK ) ) { <END_VULN> err_offset = opt_iter ; goto validate_return_locked ; }
} fname = Z_STRVAL_P(value ) ; <START_VULN> fname_len = (php_stat_len ) Z_STRLEN_P(value ) ; <END_VULN> phar_spl_fileinfo : if (base_len ) {
phar_flush(phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; } break ;
strlcpy( psz_server , psz_path , sizeof( psz_server ) ) ; psz_share [ 0 ] = 0 ; psz_parser = strchr( psz_path , '' ) ; if( psz_parser ) { char * psz_parser2 = strchr( + + psz_parser , '' ) ; if( psz_parser2 ) strlcpy( psz_share , psz_parser , sizeof( psz_share ) ) ; } <START_VULN> sprintf( psz_remote , " % s % s" , psz_server , psz_share ) ; <END_VULN> net_resource . lpRemoteName = psz_remote ; i_result = OurWNetAddConnection2( & net_resource , psz_pwd , psz_user , 0 ) ; if( i_result != NO_ERROR ) { msg_Dbg( p_access , "connected to % s" , psz_remote ) ; } else if( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )
phar_flush(entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; RETURN_FALSE ; } else {
long dim ; long entries ; long used_entries ; const static_codebook * c ; <START_VULN> float * valuelist ; <END_VULN> ogg_uint32_t * codelist ; int * dec_index ; char * dec_codelengths ; ogg_uint32_t * dec_firsttable ; int dec_firsttablen ; int dec_maxlength ;
} spin_unlock( & sk -> sk_receive_queue . lock ) ; <START_VULN> if (po -> has_vnet_hdr ) { <END_VULN> if (virtio_net_hdr_from_skb(skb , h . raw + macoff - sizeof(struct virtio_net_hdr ) , vio_le( ) , true ) ) {
struct nfs_fh * fh ; nfs4_stateid * stateid ; struct nfs_seqid * seqid ; <START_VULN> intopen_flags ; <END_VULN> const u32 * bitmask ; } ;
unsigned char * p ; size_t l ; int r ; <START_VULN> int ffmax , parent_len ; <END_VULN> static const struct archive_rb_tree_ops rb_ops = { isoent_cmp_node_joliet , isoent_cmp_key_joliet } ;
<START_VULN> static int udp_push_pending_frames(struct sock * sk ) <END_VULN> { struct udp_sock * up = udp_sk(sk ) ; struct inet_sock * inet = inet_sk(sk ) ;
static int CVE_2013_4516_mp_get_count(struct sb_uart_state * state , struct serial_icounter_struct * icnt ) { <START_VULN> struct serial_icounter_struct icount ; <END_VULN> struct sb_uart_icount cnow ; struct sb_uart_port * port = state -> port ; spin_lock_irq( & port -> lock ) ; memcpy( & cnow , & port -> icount , sizeof(struct sb_uart_icount ) ) ; spin_unlock_irq( & port -> lock ) ; icount . cts = cnow . cts ; icount . dsr = cnow . dsr ; icount . rng = cnow . rng ;
} <START_VULN> err = __video_do_ioctl(file , cmd , parg ) ; <END_VULN> if (err == - ENOIOCTLCMD ) err = - EINVAL ;
* <START_VULN> <END_VULN> #ifndef __SSL_ERR_H_ #define __SSL_ERR_H_ #define SSL_ERROR_BASE( - 0x3000 ) #define SSL_ERROR_LIMIT(SSL_ERROR_BASE + 1000 ) #define IS_SSL_ERROR(code )
<START_VULN> Copyright (c ) 2000 , 2010 , Oracle andor its affiliates<END_VULN> This program is free software ; you can redistribute it andor modify it under the terms of the GNU General Public License as published by
kenter(" % p { % u } " , user , uid ) ; <START_VULN> if (user -> uid_keyring ) { <END_VULN> kleave(" = 0 [ exist ] " ) ; return 0 ; }
if (code == (clear_code + 1 ) ) { return (mGIFStruct . rows_remaining == 0 ) ; } if (oldcode == - 1 ) { if (code >= MAX_BITS ) return false ; <START_VULN> * rowp + + = suffix [ code ] ; <END_VULN> if (rowp == rowend ) OUTPUT_ROW( ) ; firstchar = oldcode = code ; continue ; } int incode = code ; if (code >= avail ) { * stackp + + = firstchar ;
} else { unsigned char * out ; <START_VULN> unsigned long outlen , loid [ 16 ] ; <END_VULN> int decoded ; ltc_asn1_list digestinfo [ 2 ] , siginfo [ 2 ] ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : maintain the info structure , info < -> header packets <START_VULN> last mod : $ Id : info . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h >
ZEND_ARG_INFO(0 , pattern ) ZEND_ARG_INFO(0 , subject ) ZEND_ARG_INFO(0 , limit ) <START_VULN> ZEND_ARG_INFO(0 , flags ) <END_VULN> ZEND_END_ARG_INFO( ) ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_quote , 0 , 0 , 1 )
struct snd_hrtimer * stime = t -> private_data ; atomic_set( & stime -> running , 0 ) ; <START_VULN> hrtimer_cancel( & stime -> hrt ) ; <END_VULN> hrtimer_start( & stime -> hrt , ns_to_ktime(t -> sticks * resolution ) , HRTIMER_MODE_REL ) ; atomic_set( & stime -> running , 1 ) ;
end : if (TRUE == local_tx_started ) { <START_VULN> conn -> m -> local_tx_end(conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_INF(ret == PASS ? "PASS" : "FAIL" ) ; DBG_RETURN(ret ) ;
phar_flush(phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; } }
AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; const uint8_t * buf_end = buf + buf_size ; MadContext * s = avctx -> priv_data ; int width , height ; int chunk_type ; int inter ; <START_VULN> if (buf_size < 17 ) { <END_VULN> av_log(avctx , AV_LOG_ERROR , "Input buffer too small" ) ; * data_size = 0 ; return - 1 ; } chunk_type = AV_RL32( & buf [ 0 ] ) ; inter = (chunk_type == MADm_TAG || chunk_type == MADe_TAG ) ; buf + = 8 ; av_reduce( & avctx -> time_base . num , & avctx -> time_base . den ,
spin_unlock_irqrestore( & i8042_lock , flags ) ; <START_VULN> if (likely(port -> exists && ! filtered ) ) <END_VULN> serio_interrupt(serio , data , dfl ) ; out :
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm" ) ; <START_VULN> MODULE_ALIAS("sha1 - powerpc" ) ; <END_VULN>
<START_VULN> <END_VULN> #define MY_HOLD_ORIGINAL_MODES 128 #define MY_REDEL_MAKE_BACKUP 256 #define MY_SEEK_NOT_DONE 32 #define MY_DONT_WAIT64 #define MY_ZEROFILL32
<START_VULN> if (dest == a -> name ) { <END_VULN>
swoole_string_release(fname ) ; zval_ptr_dtor( & ret ) ; } <START_VULN> <END_VULN> return buffer ; }
skip_bits_long( & s -> gb , offset ) ; } <START_VULN> if ( ! nblocks || nblocks > INT_MAX ) { <END_VULN> av_log(avctx , AV_LOG_ERROR , "Invalid sample count : % "PRIu32" . " , nblocks ) ; return AVERROR_INVALIDDATA ;
n = e -> band [ j ] . end ; e -> band [ j ] . window = _ogg_malloc(n * sizeof( * e -> band [ 0 ] . window ) ) ; for(i = 0 ; i < n ; i + + ) { e -> band [ j ] . window [ i ] = sin((i + . 5 ) n * M_PI ) ; e -> band [ j ] . total + = e -> band [ j ] . window [ i ] ; } e -> band [ j ] . total = 1 . e -> band [ j ] . total ; } <START_VULN> <END_VULN> e -> filter = _ogg_calloc(VE_BANDS * ch , sizeof( * e -> filter ) ) ; e -> mark = _ogg_calloc(e -> storage , sizeof( * e -> mark ) ) ; } void _ve_envelope_clear(envelope_lookup * e ) { int i ; mdct_clear( & e -> mdct ) ;
psf_binheader_readf (psf , "j" , dword - bytesread ) ; if (map_info -> channel_map != NULL ) <START_VULN> { size_t chanmap_size = psf -> sf . channels * sizeof (psf -> channel_map [ 0 ] ) ; <END_VULN> free (psf -> channel_map ) ;
if ( ! CDROM_CAN(CDC_SELECT_DISC ) || (arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status(cdi , CDSL_CURRENT ) ; <START_VULN> if (((int ) arg >= cdi -> capacity ) ) <END_VULN> return - EINVAL ; return cdrom_slot_status(cdi , arg ) ; }
if (hdr -> substreamid == info -> num_ind_sub + 1 ) { <START_VULN> avpriv_request_sample(track -> par , "Multiple independent substreams" ) ; <END_VULN> ret = AVERROR_PATCHWELCOME ; goto end ; } else if (hdr -> substreamid < info -> num_ind_sub ||
{ MsgToEventLog(M_ERR , TEXT("Startup data ends at working directory" ) ) ; ReturnError(pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <START_VULN> goto out ; <END_VULN> } sud -> options = sud -> directory + len ;
} extra -> match_limit = PCRE_G(backtrack_limit ) ; extra -> match_limit_recursion = PCRE_G(recursion_limit ) ; <START_VULN> <END_VULN> array_init(return_value ) ;
} bcc_ptr + = length + 1 ; strncpy(tcon -> treeName , tree , MAX_TREE_SIZE ) ; if (smb_buffer -> Flags2 & SMBFLG2_UNICODE ) { length = UniStrnlen((wchar_t * ) bcc_ptr , 512 ) ; if ((bcc_ptr + (2 * length ) ) - pByteArea(smb_buffer_response ) <= BCC(smb_buffer_response ) ) { kfree(tcon -> nativeFileSystem ) ; tcon -> nativeFileSystem = <START_VULN> kzalloc(length + 2 , GFP_KERNEL ) ; <END_VULN> if (tcon -> nativeFileSystem ) cifs_strfromUCS_le( tcon -> nativeFileSystem , (__le16 * ) bcc_ptr , length , nls_codepage ) ; bcc_ptr + = 2 * length ; bcc_ptr [ 0 ] = 0 ; bcc_ptr [ 1 ] = 0 ; bcc_ptr + = 2 ; }
size_t noff , size_t doff , int * flags ) { if (namesz == 4 && strcmp((char * ) & nbuf [ noff ] , "GNU" ) == 0 && <START_VULN> type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20 ) ) { <END_VULN> uint8_t desc [ 20 ] ; const char * btype ; uint32_t i ;
static int CVE_2009_2844_cmp_ies(u8 num , u8 * ies1 , size_t len1 , u8 * ies2 , size_t len2 ) { const u8 * ie1 = find_ie(num , ies1 , len1 ) ; const u8 * ie2 = find_ie(num , ies2 , len2 ) ; int r ; if ( ! ie1 && ! ie2 ) return 0 ; <START_VULN> if ( ! ie1 ) <END_VULN> return - 1 ; r = memcmp(ie1 + 2 , ie2 + 2 , min(ie1 [ 1 ] , ie2 [ 1 ] ) ) ; if (r == 0 && ie1 [ 1 ] != ie2 [ 1 ] ) return ie2 [ 1 ] - ie1 [ 1 ] ; return r ; }
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("MD4 Message Digest Algorithm" ) ; <START_VULN> <END_VULN>
zval_dtor( * zcount ) ; ZVAL_LONG( * zcount , replace_count ) ; } <START_VULN> <END_VULN> }
goto out_wakeup ; } <START_VULN> spin_lock( & sma -> sem_perm . lock ) ; <END_VULN> curr = & sma -> sem_base [ semnum ] ; switch (cmd ) {
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("Cast5 Cipher Algorithm" ) ; <START_VULN> MODULE_ALIAS("cast5" ) ; <END_VULN>
<START_VULN> snprintf(buf , sizeof(buf ) , filename , dec_ctx -> frame_number ) ; <END_VULN> pgm_save(frame -> data [ 0 ] , frame -> linesize [ 0 ] , frame -> width , frame -> height , buf ) ; }
if ( ! in_group_p((ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && <START_VULN> ! inode_capable(inode , CAP_FSETID ) ) <END_VULN> attr -> ia_mode &= ~ S_ISGID ; }
c -> interfaces_offset < bin -> header . data_offset + bin -> header . data_size ) { p = r_buf_get_at (binfile -> buf , c -> interfaces_offset , NULL ) ; <START_VULN> int types_list_size = r_read_le32(p ) ; <END_VULN> if (types_list_size < 0 || types_list_size >= bin -> header . types_size ) { return ; }
struct xfs_buf * bp ; xfs_dablk_tlblkno = args -> rmtblkno ; __uint8_t * dst = args -> value ; <START_VULN> intvaluelen = args -> valuelen ; <END_VULN> intnmap ; interror ; intblkcnt = args -> rmtblkcnt ;
return - 1 ; } * delim = '0' ; <START_VULN> imap_quote_string(term , sizeof(term ) , pat -> p . str ) ; <END_VULN> mutt_buffer_addstr(buf , term ) ; mutt_buffer_addch(buf , ' ' ) ;
if ( ! unifilename ) goto out1 ; <START_VULN> if (udf_build_ustr_exact(unifilename , sname , flen ) ) <END_VULN> goto out2 ; if (UDF_QUERY_FLAG(sb , UDF_FLAG_UTF8 ) ) {
void RequestDecode(RasterImage * aImg ) ; <START_VULN> void DecodeABitOf(RasterImage * aImg ) ; <END_VULN>
g_free(strmbuf ) ; g_free(compr ) ; g_free(uncompr ) ; return NULL ; } } else { inflateEnd(strm ) ; g_free(strm ) ; g_free(strmbuf ) ; <START_VULN> g_free(compr ) ; <END_VULN> if (uncompr == NULL ) { return NULL ; } break ; } } #ifdef TVB_Z_DEBUG printf("inflate( ) total passes : % u" , inflate_passes ) ; printf("bytes in : % ubytes out : % u" , bytes_in , bytes_out ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis backend and mapping structures ; needed for static mode headers <START_VULN> last mod : $ Id : backends . h 16326 2009 - 07 - 24 00 : 06 : 53Z xiphmont $ <END_VULN> #ifndef _vorbis_backend_h_
struct TypedArrayObjectStorage : AllTypedArraysBase { protected : JSObject * mObj ; <START_VULN> TypedArrayObjectStorage( ) <END_VULN> { } TypedArrayObjectStorage(TypedArrayObjectStorage && aOther ) : mObj(aOther . mObj ) { aOther . mObj = nullptr ; }
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : readelf . c , v 1 . 103 20140502 02 : 25 : 10 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
while(v ) { ret + + ; v >> = 1 ; } return(ret ) ; } static void mapping0_pack(vorbis_info * vi , vorbis_info_mapping * vm , <START_VULN> oggpack_buffer * opb ) { <END_VULN> int i ; vorbis_info_mapping0 * info = (vorbis_info_mapping0 * ) vm ; if(info -> submaps > 1 ) { for(i = 0 ; i < vi -> channels ; i + + ) {
err = b43_try_request_fw(ctx ) ; if ( ! err ) goto start_ieee80211 ; if(ctx -> fatal_failure ) goto out ; for (i = 0 ; i < B43_NR_FWTYPES ; i + + ) { errmsg = ctx -> errors [ i ] ; if (strlen(errmsg ) ) <START_VULN> b43err(dev -> wl , errmsg ) ; <END_VULN> } b43_print_fw_helptext(dev -> wl , 1 ) ; goto out ; start_ieee80211 : wl -> hw -> queues = B43_QOS_QUEUE_NUM ; if ( ! modparam_qos || dev -> fw . opensource ) wl -> hw -> queues = 1 ; err = ieee80211_register_hw(wl -> hw ) ;
unregister_inetaddr_notifier( & sctp_inetaddr_notifier ) ; } <START_VULN> static int __net_init sctp_net_init(struct net * net ) <END_VULN> { int status ;
#define EHMER_OFFSET 16 #define EHMER_MAX 56 <START_VULN> static float tonemasks [ P_BANDS ] [ 6 ] [ EHMER_MAX ] = { <END_VULN> { { - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 62 , - 62 , - 65 , - 73 , - 69 , - 68 , - 68 , - 67 , - 70 , - 70 , - 72 , - 74 , - 75 , - 79 , - 79 , - 80 , - 83 , - 88 , - 93 , - 100 , - 110 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 } ,
down_read( & uts_sem ) ; res = sysinfo_table [ offset ] ; len = strlen(res ) + 1 ; <START_VULN> if (len > count ) <END_VULN> len = count ; if (copy_to_user(buf , res , len ) ) err = - EFAULT ;
{ if (params -> buffer . fragment_size == 0 || <START_VULN> params -> buffer . fragments > SIZE_MAX params -> buffer . fragment_size ) <END_VULN> return - EINVAL ;
<START_VULN> if ( * rsize >= 74 && <END_VULN> rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f &&
bool startedFromUnelevatedUpdater = GetFileAttributesW(elevatedLockFilePath ) != INVALID_FILE_ATTRIBUTES ; <START_VULN> if(startedFromUnelevatedUpdater ) { <END_VULN> UACHelper : : DisablePrivileges(nullptr ) ; } if (updateLockFileHandle == INVALID_HANDLE_VALUE || (useService && testOnlyFallbackKeyExists && noServiceFallback ) ) { if ( ! _waccess(elevatedLockFilePath , F_OK ) && NS_tremove(elevatedLockFilePath ) != 0 ) { fprintf(stderr , "Unable to create elevated lock file ! Exiting" ) ;
struct rpc_cred * cred ; struct nfs4_state * state ; fl_owner_t lockowner ; <START_VULN> int mode ; <END_VULN> unsigned long flags ; #define NFS_CONTEXT_ERROR_WRITE(0 )
mrb_field_write_barrier(mrb , (struct RBasic * ) p , (struct RBasic * ) p -> c ) ; clone = mrb_obj_value(p ) ; init_copy(mrb , clone , self ) ; <START_VULN> p -> flags = mrb_obj_ptr(self ) -> flags ; <END_VULN> return clone ; }
* <START_VULN> <END_VULN> #include "cert . h" #include "secitem . h" #include "keyhi . h" #include "ssl . h" #include "sslimpl . h" #include "sslproto . h" #include "secoid . h" #include "pk11func . h"
#endif if ( ! is_anonymous ) { <START_VULN> if (s && s > filename ) { <END_VULN> safe_php_register_variable(lbuf , s + 1 , strlen(s + 1 ) , NULL , 0 TSRMLS_CC ) ; } else { safe_php_register_variable(lbuf , filename , strlen(filename ) , NULL , 0 TSRMLS_CC ) ;
NS_IMETHOD ResetInputState( ) ; NS_IMETHOD_(void ) SetInputContext(const InputContext & aContext , const InputContextAction & aAction ) ; NS_IMETHOD_(InputContext ) GetInputContext( ) ; NS_IMETHOD CancelIMEComposition( ) ; NS_IMETHOD OnIMEFocusChange(bool aFocus ) ; NS_IMETHOD GetToggledKeyState(uint32_t aKeyCode , bool * aLEDState ) ; <START_VULN> void ResizeTransparencyBitmap(int32_t aNewWidth , int32_t aNewHeight ) ; <END_VULN> void ApplyTransparencyBitmap( ) ; virtual void SetTransparencyMode(nsTransparencyMode aMode ) ; virtual nsTransparencyMode GetTransparencyMode( ) ; virtual nsresult ConfigureChildren(const nsTArray < Configuration > & aConfigurations ) ; nsresult UpdateTranslucentWindowAlphaInternal(const nsIntRect & aRect , uint8_t * aAlphas , int32_t aStride ) ; #if defined(MOZ_WIDGET_GTK2 )
return intpart ; } <START_VULN> static void<END_VULN> fmtfp(char ** sbuffer , char ** buffer , size_t * currlen ,
} ; class nsDocShell final : public nsDocLoader <START_VULN> , public nsIDocShell_ESR38<END_VULN> , public nsIWebNavigation , public nsIBaseWindow , public nsIScrollable , public nsITextScroll , public nsIDocCharset , public nsIContentViewerContainer , public nsIRefreshURI , public nsIWebProgressListener
node = blk -> bp -> b_addr ; dp -> d_ops -> node_hdr_from_disk( & nodehdr , node ) ; btree = dp -> d_ops -> node_tree_p(node ) ; <START_VULN> if (be32_to_cpu(btree -> hashval ) == lasthash ) <END_VULN> break ; blk -> hashval = lasthash ; btree [ blk -> index ] . hashval = cpu_to_be32(lasthash ) ;
} } ; <START_VULN> static OM_uint32 KRB5_CALLCONV<END_VULN> krb5_gss_inquire_sec_context_by_oid (OM_uint32 * minor_status , const gss_ctx_id_t context_handle , const gss_OID desired_object ,
virtual bool UndoScope( ) MOZ_OVERRIDE ; virtual void SetUndoScope(bool aUndoScope , mozilla : : ErrorResult & aError ) MOZ_OVERRIDE ; nsresult ClearDataset( ) ; <START_VULN> nsSize GetWidthHeightForImage(imgIRequest * aImageRequest ) ; <END_VULN> NS_FORWARD_NSIDOMNODE_TO_NSINODE NS_FORWARD_NSIDOMELEMENT_TO_GENERIC NS_IMETHOD GetId(nsAString & aId ) MOZ_FINAL { mozilla : : dom : : Element : : GetId(aId ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : * unnormalized * fft transform <START_VULN> last mod : $ Id : smallft . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdio . h > #include < oggogg . h > #include "vorbiscodec . h" #include "codec_internal . h" #include "registry . h"
<START_VULN> if ( ! SSL_USE_ETM(s ) && mac_size != 0 ) { <END_VULN> if (s -> method -> ssl3_enc -> mac(s , & wr [ j ] , & (outbuf [ j ] [ wr [ j ] . length + eivlen ] ) , 1 ) < 0 )
snprintf_func (recmd , TESTBUFSIZE , " % s recode % s - f % s % s % s % s % s" , program_name , test_softcfg_str , recoded_adler32 ? "" : " - n " , <START_VULN> ! change_apphead ? "" : <END_VULN> (recoded_apphead ? " - A = recode_apphead " : " - A = " ) , recoded_secondary ? " - S djw " : " - S none " , TEST_DELTA_FILE ,
skb_shinfo(skb ) -> gso_size = (mtu - fragheaderlen - sizeof(struct frag_hdr ) ) & ~ 7 ; skb_shinfo(skb ) -> gso_type = SKB_GSO_UDP ; <START_VULN> ipv6_select_ident( & fhdr ) ; <END_VULN> skb_shinfo(skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail( & sk -> sk_write_queue , skb ) ;
return true ; if ((uint64_t ) capacity * elemSize > size_type( - 1 ) 2 ) { <START_VULN> NS_ERROR("Attempting to allocate excessively large array" ) ; <END_VULN> return false ; } if (mHdr == EmptyHdr( ) ) { Header * header = static_cast < Header * > (Alloc : : Malloc(sizeof(Header ) + capacity * elemSize ) ) ; if ( ! header )
size_t cnt , loff_t * ppos ) ; ssize_t ftrace_notrace_write(struct file * file , const char __user * ubuf , size_t cnt , loff_t * ppos ) ; <START_VULN> loff_t ftrace_regex_lseek(struct file * file , loff_t offset , int whence ) ; <END_VULN> int ftrace_regex_release(struct inode * inode , struct file * file ) ; void __init
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : cdf . c , v 1 . 45 20110828 08 : 38 : 48 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
const cdf_sat_t * ssat , const cdf_stream_t * sst , cdf_secid_t sid , size_t len , cdf_stream_t * scn ) { <START_VULN> size_t ss = CDF_SEC_SIZE(h ) , i , j ; <END_VULN> scn -> sst_len = cdf_count_chain(ssat , sid , CDF_SEC_SIZE(h ) ) ; scn -> sst_dirlen = len ;
<START_VULN> struct nfs_open_context * nfs_find_open_context(struct inode * inode , struct rpc_cred * cred , int mode ) <END_VULN> { struct nfs_inode * nfsi = NFS_I(inode ) ; struct nfs_open_context * pos , * ctx = NULL ;
list_add_tail( & new_port -> list , & p -> list ) ; client -> num_ports + + ; new_port -> addr . port = num ; write_unlock_irqrestore( & client -> ports_lock , flags ) ; mutex_unlock( & client -> ports_mutex ) ; <START_VULN> sprintf(new_port -> name , "port - % d" , num ) ; <END_VULN> return new_port ; }
class AutoCompartment { JSContext * const cx_ ; JSCompartment * const origin_ ; public : inline AutoCompartment(JSContext * cx , JSObject * target ) ; <START_VULN> inline AutoCompartment(JSContext * cx , JSCompartment * target ) ; <END_VULN> inline ~ AutoCompartment( ) ; JSContext * context( ) const { return cx_ ; } JSCompartment * origin( ) const { return origin_ ; } private : AutoCompartment(const AutoCompartment & ) MOZ_DELETE ; AutoCompartment & operator = (const AutoCompartment & ) MOZ_DELETE ;
} <START_VULN> f2fs_wait_discard_bios(sbi ) ; <END_VULN> if (f2fs_discard_en(sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = {
{ const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; <START_VULN> u64 msr_data ; <END_VULN> int usermode ; u16 cs_sel = 0 , ss_sel = 0 ;
static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic * ioapic ) { ioapic -> rtc_status . pending_eoi = 0 ; <START_VULN> bitmap_zero(ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ; <END_VULN> } static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic * ioapic ) ;
return - EINVAL ; if (get_user(val , (int __user * ) optval ) ) return - EFAULT ; lock_sock(sk ) ; switch (optname ) { case TCP_MAXSEG : <START_VULN> if (val < 8 || val > MAX_TCP_WINDOW ) { <END_VULN> err = - EINVAL ; break ; } tp -> rx_opt . user_mss = val ; break ; case TCP_NODELAY : if (val ) { tp -> nonagle |= TCP_NAGLE_OFF | TCP_NAGLE_PUSH ;
int buf_size = avpkt -> size ; MP3On4DecodeContext * s = avctx -> priv_data ; MPADecodeContext * m ; int fsize , len = buf_size , out_size = 0 ; uint32_t header ; OUT_INT * out_samples ; OUT_INT * outptr , * bp ; int fr , j , n , ch , ret ; <START_VULN> s -> frame -> nb_samples = MPA_FRAME_SIZE ; <END_VULN> if ((ret = avctx -> get_buffer(avctx , s -> frame ) ) < 0 ) { av_log(avctx , AV_LOG_ERROR , "get_buffer( ) failed" ) ; return ret ; } out_samples = (OUT_INT * ) s -> frame -> data [ 0 ] ; if (buf_size < HEADER_SIZE ) return AVERROR_INVALIDDATA ;
ret = 0 ; exit : <START_VULN> spin_unlock_irqrestore( & dev -> lock , flags ) ; <END_VULN> return ret <= 0 ? ret : - EIO ; }
else ffmax = 128 ; <START_VULN> r = idr_start(a , idr , isoent -> children . cnt , ffmax , 6 , 2 , & rb_ops ) ; <END_VULN> if (r < 0 ) return (r ) ;
for (bit = find_first_bit( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit( & bm -> word , bm -> depth , bit + 1 ) ) { <START_VULN> rq = blk_mq_tag_to_rq(tags , off + bit ) ; <END_VULN> fn(rq , data , reserved ) ; }
return - ENETUNREACH ; } <START_VULN> if ( ! inet -> opt || ! inet -> opt -> srr ) <END_VULN> daddr = rt -> rt_dst ; if ( ! inet -> inet_saddr )
<START_VULN> PHPAPI ulong<END_VULN> mysqlnd_old_escape_string(char * newstr , const char * escapestr , size_t escapestr_len TSRMLS_DC ) { DBG_ENTER("mysqlnd_old_escape_string" ) ;
osa_princ_ent_rec adb ; krb5_int32 now ; kadm5_policy_ent_rec pol ; <START_VULN> int ret , last_pwd ; <END_VULN> krb5_boolean have_pol = FALSE ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ;
} <START_VULN> const PRUint8 * <END_VULN> PrepareOpenTypeData(const PRUint8 * aData , PRUint32 * aLength ) { switch(gfxFontUtils : : DetermineFontDataType(aData , * aLength ) ) { case GFX_USERFONT_OPENTYPE : return aData ;
return err ; } <START_VULN> if (s -> chunksize >= 0 ) { <END_VULN> if ( ! s -> chunksize ) { char line [ 32 ] ;
static bool dump_fd_info(const char * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid ) { <START_VULN> FILE * fp = fopen(dest_filename , "w" ) ; <END_VULN> if ( ! fp ) return false ;
for (i = 0 ; i < size ; i + + ) { ch = buffer [ i ] ; <START_VULN> Huff_transmit( & huff , ch , seq ) ; <END_VULN> Huff_addRef( & huff , (byte ) ch ) ; }
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : cdf . c , v 1 . 54 20140225 20 : 52 : 02 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
STACK_OF(X509_CRL ) * crls = NULL ; X509 * signer ; int i , scount = 0 , ret = 0 ; <START_VULN> BIO * cmsbio = NULL , * tmpin = NULL ; <END_VULN> if ( ! dcont && ! check_content(cms ) ) return 0 ;
if (is_machine_check(intr_info ) ) return handle_machine_check(vcpu ) ; <START_VULN> if ((intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) <END_VULN> return 1 ; if (is_no_device(intr_info ) ) {
for (i = 0 ; i < numcmpts ; + + i ) { if (jas_image_readcmpt(image , cmpts [ i ] , 0 , y , jas_image_width(image ) , 1 , data [ i ] ) ) { <START_VULN> return - 1 ; <END_VULN> } } z = 0 ;
} efree(match_sets ) ; } <START_VULN> <END_VULN> efree(offsets ) ; efree(subpat_names ) ;
class nsIconDecoder : public Decoder { public : nsIconDecoder(RasterImage & aImage ) ; virtual ~ nsIconDecoder( ) ; <START_VULN> virtual void WriteInternal(const char * aBuffer , uint32_t aCount ) ; <END_VULN> uint8_t mWidth ; uint8_t mHeight ; uint32_t mPixBytesRead ; uint32_t mState ; } ; enum {
SimpleStringList tableNames ; intuseDB ; <START_VULN> char * dbname ; <END_VULN> char * pgport ; char * pghost ; char * username ;
Com_Printf( " -- -- - Initializing Renderer -- -- " ) ; #ifdef USE_RENDERER_DLOPEN <START_VULN> cl_renderer = Cvar_Get("cl_renderer" , "opengl2" , CVAR_ARCHIVE | CVAR_LATCH ) ; <END_VULN> Com_sprintf(dllName , sizeof(dllName ) , "renderer_ % s_" ARCH_STRING DLL_EXT , cl_renderer -> string ) ;
fclose (orig ) ; fclose (recons ) ; <START_VULN> if (diffs != 0 ) <END_VULN> { return XD3_INTERNAL ; }
return - ENOMEM ; for (i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <START_VULN> unix_inflight(scm -> fp -> fp [ i ] ) ; <END_VULN> return max_level ; }
file -> path = * in_path ; for(i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i + = 2 + apdu . resp [ i + 1 ] ) { <START_VULN> int j , len = apdu . resp [ i + 1 ] ; <END_VULN> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; switch (type ) {
unsigned long now ; getnstimeofday( & n ) ; <START_VULN> now = timespec_to_ns(n ) ; <END_VULN> if (when > now ) when -= now ; else
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : residue backend 0 , 1 and 2 implementation <START_VULN> last mod : $ Id : res0 . c 16327 2009 - 07 - 24 00 : 49 : 25Z xiphmont $ <END_VULN>
. release = ext3_release_file , . fsync = ext3_sync_file , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> } ; const struct inode_operations ext3_file_inode_operations = {
int initialContextToken = ( * context_handle == GSS_C_NO_CONTEXT ) ; if (initialContextToken ) { <START_VULN> code = iakerb_alloc_context( & ctx ) ; <END_VULN> if (code != 0 ) { * minor_status = code ; goto cleanup ;
num = (rem_sz > scatter_elem_sz_prev ) ? scatter_elem_sz_prev : rem_sz ; <START_VULN> schp -> pages [ k ] = alloc_pages(gfp_mask , order ) ; <END_VULN> if ( ! schp -> pages [ k ] ) goto out ;
phar_flush(phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; RETURN_FALSE ; } else {
MODULE_DESCRIPTION("Rijndael (AES ) Cipher Algorithm , Intel AES - NI instructions optimized" ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("aes" ) ; <END_VULN>
} static int _vorbis_pack_info(oggpack_buffer * opb , vorbis_info * vi ) { codec_setup_info * ci = vi -> codec_setup ; if( ! ci ) return(OV_EFAULT ) ; <START_VULN> <END_VULN> oggpack_write(opb , 0x01 , 8 ) ; _v_writestring(opb , "vorbis" , 6 ) ; oggpack_write(opb , 0x00 , 32 ) ; oggpack_write(opb , vi -> channels , 8 ) ; oggpack_write(opb , vi -> rate , 32 ) ;
del_timer( & p -> timer ) ; call_rcu_bh( & p -> rcu , br_multicast_free_pg ) ; <START_VULN> if ( ! mp -> ports && ! mp -> mglist && <END_VULN> netif_running(br -> dev ) ) mod_timer( & mp -> timer , jiffies ) ;
PORT_ZFree(slotPw . data , PL_strlen(slotPw . data ) ) ; if (p12FilePw . data != NULL ) PORT_ZFree(p12FilePw . data , PL_strlen(p12FilePw . data ) ) ; if (slot ) PK11_FreeSlot(slot ) ; if (NSS_Shutdown( ) != SECSuccess ) { pk12uErrno = 1 ; } PR_Cleanup( ) ; <START_VULN> PL_ArenaFinish( ) ; <END_VULN> return pk12uErrno ; }
uint32_t lineIndexToNum(uint32_t lineIndex ) const { return lineIndex + initialLineNum_ ; } uint32_t lineNumToIndex(uint32_t lineNum ) const { return lineNum - initialLineNum_ ; } public : SourceCoords(JSContext * cx , uint32_t ln ) ; void add(uint32_t lineNum , uint32_t lineStartOffset ) ; <START_VULN> void fill(const SourceCoords & other ) ; <END_VULN> bool isOnThisLine(uint32_t offset , uint32_t lineNum ) const { uint32_t lineIndex = lineNumToIndex(lineNum ) ; JS_ASSERT(lineIndex + 1 < lineStartOffsets_ . length( ) ) ; return lineStartOffsets_ [ lineIndex ] <= offset && offset < lineStartOffsets_ [ lineIndex + 1 ] ; }
cwd [ 2 ] = '0' ; } #endif <START_VULN> cwd_skip = (int ) strlen(cwd ) + 1 ; <END_VULN> snprintf(work_pattern , MAXPATHLEN , " % s % c % s" , cwd , DEFAULT_SLASH , pattern ) ; pattern = work_pattern ;
vb -> pcm = _vorbis_block_alloc(vb , sizeof( * vb -> pcm ) * vi -> channels ) ; for(i = 0 ; i < vi -> channels ; i + + ) vb -> pcm [ i ] = _vorbis_block_alloc(vb , vb -> pcmend * sizeof( * vb -> pcm [ i ] ) ) ; type = ci -> map_type [ ci -> mode_param [ mode ] -> mapping ] ; return(_mapping_P [ type ] -> inverse(vb , ci -> map_param [ ci -> mode_param [ mode ] -> <START_VULN> mapping ] ) ) ; <END_VULN> } int vorbis_synthesis_trackonly(vorbis_block * vb , ogg_packet * op ) { vorbis_dsp_state * vd = vb -> vd ; private_state * b = vd -> backend_state ; vorbis_info * vi = vd -> vi ;
data [ 1 ] = new >> 4 ; } else { FAT_ENTRY subseqEntry ; <START_VULN> if (cluster != fs -> clusters - 1 ) <END_VULN> get_fat( & subseqEntry , fs -> fat , cluster + 1 , fs ) ; else subseqEntry . value = 0 ;
{ int len = strlen(buffer ) ; <START_VULN> if((len + * stringlen ) > * stralloc ) { <END_VULN> char * newptr = realloc(string , * stralloc * 2 ) ; if(newptr ) { string = newptr ;
int size ; syscall_nr = trace_get_syscall_nr(current , regs ) ; <START_VULN> if (syscall_nr < 0 ) <END_VULN> return ; if ( ! test_bit(syscall_nr , enabled_perf_exit_syscalls ) ) return ;
struct sembuf fast_sops [ SEMOPM_FAST ] ; struct sembuf * sops = fast_sops , * sop ; struct sem_undo * un ; <START_VULN> int undos = 0 , alter = 0 , max ; <END_VULN> struct sem_queue queue ; unsigned long jiffies_left = 0 ; struct ipc_namespace * ns ;
typedef ogg_int16_t vorbis_fpu_control ; static inline void vorbis_fpu_setround(vorbis_fpu_control * fpu ) { ogg_int16_t ret ; ogg_int16_t temp ; __asm__ __volatile__("fnstcw % 0t" "movw % 0 , % % dxt" <START_VULN> "orw $ 62463 , % % dxt"<END_VULN> "movw % % dx , % 1t" "fldcw % 1t" : " = m"(ret ) : "m"(temp ) : "dx" ) ; * fpu = ret ; } static inline void vorbis_fpu_restore(vorbis_fpu_control fpu ) { __asm__ __volatile__("fldcw % 0" : : "m"(fpu ) ) ; }
<START_VULN> mp_err<END_VULN> ec_GFp_pt_dbl_jm(const mp_int * px , const mp_int * py , const mp_int * pz , const mp_int * paz4 , mp_int * rx , mp_int * ry , mp_int * rz , mp_int * raz4 , mp_int scratch [ ] , const ECGroup * group ) { mp_err res = MP_OKAY ; mp_int * t0 , * t1 , * M , * S ; t0 = & scratch [ 0 ] ;
#include < windows . h > #include "nscore . h" #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN #include < dwmapi . h > #endif <START_VULN> #if defined(WINCE ) || (MOZ_WINSDK_TARGETVER == MOZ_NTDDI_WS03 ) <END_VULN> struct MARGINS { int cxLeftWidth ; int cxRightWidth ; int cyTopHeight ; int cyBottomHeight ; } ; #endif
while (0x80 != plaintext [ cipher_len - 2 ] && (cipher_len - 2 > 0 ) ) cipher_len -- ; <START_VULN> if (2 == cipher_len ) <END_VULN> return - 1 ; memcpy(out , plaintext , cipher_len - 2 ) ;
if (ret < 0 ) hid_err(hdev , "error setting GPIO values : % d" , ret ) ; <START_VULN> spin_unlock_irqrestore( & dev -> lock , flags ) ; <END_VULN> } static int cp2112_gpio_get_all(struct gpio_chip * chip )
compact_pixels = (unsigned char * ) NULL ; if (next_image -> compression == RLECompression ) { <START_VULN> compact_pixels = AcquireCompactPixels(image , exception ) ; <END_VULN> if (compact_pixels == (unsigned char * ) NULL ) return(0 ) ; }
js : : gc : : MarkStringUnbarriered(trc , & d . u1 . left , "left child" ) ; js : : gc : : MarkStringUnbarriered(trc , & d . s . u2 . right , "right child" ) ; } JS_ALWAYS_INLINE void JSDependentString : : init(JSLinearString * base , const jschar * chars , size_t length ) { JS_ASSERT( ! js : : IsPoisonedPtr(base ) ) ; <START_VULN> d . lengthAndFlags = buildLengthAndFlags(length , DEPENDENT_BIT ) ; <END_VULN> d . u1 . chars = chars ; d . s . u2 . base = base ; JSString : : writeBarrierPost(d . s . u2 . base , & d . s . u2 . base ) ; } JS_ALWAYS_INLINE JSDependentString * JSDependentString : : new_(JSContext * cx , JSLinearString * base_ , const jschar * chars , size_t length ) {
if (error ) return error ; <START_VULN> old_name = fsnotify_oldname_init(old_dentry -> d_name . name ) ; <END_VULN> dget(new_dentry ) ; if ( ! is_dir || (flags & RENAME_EXCHANGE ) ) lock_two_nondirectories(source , target ) ;
<START_VULN> void * sys_call_table [ __NR_syscalls ] __aligned(4096 ) = { <END_VULN> [ 0 . . . __NR_syscalls - 1 ] = sys_ni_syscall , #include < asmunistd . h > } ;
#include < linuxbuffer_head . h > #include < linuxinit . h > #include < linuxslab . h > <START_VULN> #include < linuxmbcache . h > <END_VULN> #include < linuxquotaops . h > #include < linuxrwsem . h > #include < linuxsecurity . h >
} <START_VULN> if (i > (int ) rec -> length ) <END_VULN> {
long i ; int ret ; <START_VULN> if (rs -> rs_bound_addr == 0 ) { <END_VULN> ret = - ENOTCONN ; goto out ; }
IPV6_SET_RAW_VER(p -> ip6h , 6 ) ; IPV6FragHdr * fh = (IPV6FragHdr * ) (GET_PKT_DATA(p ) + sizeof(IPV6Hdr ) ) ; <START_VULN> fh -> ip6fh_nxt = IPPROTO_ICMP ; <END_VULN> fh -> ip6fh_ident = htonl(id ) ; fh -> ip6fh_offlg = htons((off << 3 ) | mf ) ;
mutex_unlock( & vq -> mutex ) ; if (oldubufs ) { <START_VULN> vhost_net_ubuf_put_and_wait(oldubufs ) ; <END_VULN> mutex_lock( & vq -> mutex ) ; vhost_zerocopy_signal_used(n , vq ) ; mutex_unlock( & vq -> mutex ) ;
static __u8 * ch_report_fixup(struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <START_VULN> if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) { <END_VULN> hid_info(hdev , "fixing up Cherry Cymotion report descriptor" ) ; rdesc [ 11 ] = rdesc [ 16 ] = 0xff ; rdesc [ 12 ] = rdesc [ 17 ] = 0x03 ;
if ( ! has_header(s -> headers , "rRange : " ) && ! post && (s -> off > 0 || s -> end_off || s -> seekable == - 1 ) ) { len + = av_strlcatf(headers + len , sizeof(headers ) - len , <START_VULN> "Range : bytes = % "PRId64" - " , s -> off ) ; <END_VULN> if (s -> end_off ) len + = av_strlcatf(headers + len , sizeof(headers ) - len , " % "PRId64 , s -> end_off - 1 ) ;
} bool __net_get_random_once(void * buf , int nbytes , bool * done , <START_VULN> struct static_key * done_key ) <END_VULN> { static DEFINE_SPINLOCK(lock ) ; unsigned long flags ;
mutt_debug(1 , "#2 Error receiving server response . " ) ; goto bail ; } <START_VULN> request_buf . length = mutt_b64_decode(buf2 , idata -> buf + 2 ) ; <END_VULN> request_buf . value = buf2 ; maj_stat = gss_unwrap( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ;
if(i + 1 < P_BANDS ) { int l = 0 ; k = i + 1 ; for(j = 0 ; j < EHMER_MAX ; j + + ) { int lo_bin = fromOC(j * . 125 + i * . 5 - 2 . 0625 ) binHz ; int hi_bin = fromOC(j * . 125 + i * . 5 - 1 . 9375 ) binHz + 1 ; <START_VULN> <END_VULN> if(lo_bin < 0 ) lo_bin = 0 ; if(lo_bin > n ) lo_bin = n ; if(lo_bin < l ) l = lo_bin ; if(hi_bin < 0 ) hi_bin = 0 ; if(hi_bin > n ) hi_bin = n ; for( ; l < hi_bin && l < n ; l + + ) if(brute_buffer [ l ] > workc [ k ] [ m ] [ j ] )
rec_hdr . hdr . ts_sec = (guint32 ) phdr -> ts . secs ; if(wdh -> tsprecision == WTAP_FILE_TSPREC_NSEC ) { rec_hdr . hdr . ts_usec = phdr -> ts . nsecs ; } else { rec_hdr . hdr . ts_usec = phdr -> ts . nsecs 1000 ; } rec_hdr . hdr . incl_len = phdr -> caplen + phdrsize ; rec_hdr . hdr . orig_len = phdr -> len + phdrsize ; <START_VULN> if (rec_hdr . hdr . incl_len > WTAP_MAX_PACKET_SIZE || rec_hdr . hdr . orig_len > WTAP_MAX_PACKET_SIZE ) { <END_VULN> * err = WTAP_ERR_BAD_FILE ; return FALSE ; } switch (wdh -> file_type ) { case WTAP_FILE_PCAP : case WTAP_FILE_PCAP_NSEC : hdr_size = sizeof (struct pcaprec_hdr ) ; break ;
len -- ; int l = 0 ; <START_VULN> while ( * s && l < len ) { <END_VULN> str [ l ] = s [ l ] ; l + + ; }
exit(1 ) ; } struct stat sb ; <START_VULN> char * pathname = RUNTIME_PATH "locklxcvarliblxc" ; <END_VULN> ret = stat(pathname , & sb ) ; if (ret != 0 ) { fprintf(stderr , " % d : filename % s not created" , __LINE__ ,
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm , NEON accelerated" ) ; <START_VULN> MODULE_ALIAS("sha1" ) ; <END_VULN>
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("DES & Triple DES EDE Cipher Algorithms , sparc64 des opcode accelerated" ) ; <START_VULN> MODULE_ALIAS("des" ) ; <END_VULN> #include "crop_devid . c"
#else crm_notice("Starting a tls listener on port % d . " , port ) ; gnutls_global_init( ) ; <START_VULN> <END_VULN> gnutls_global_set_log_function(debug_log ) ; gnutls_dh_params_init( & dh_params ) ; gnutls_dh_params_generate2(dh_params , DH_BITS ) ;
friend struct nsTreeRange ; protected : nsresult FireOnSelectHandler( ) ; static void SelectCallback(nsITimer * aTimer , void * aClosure ) ; protected : <START_VULN> nsITreeBoxObject * mTree ; <END_VULN> PRBool mSuppressed ; PRInt32 mCurrentIndex ; nsCOMPtr < nsITreeColumn > mCurrentColumn ; PRInt32 mShiftSelectPivot ; nsTreeRange * mFirstRange ;
iocb -> private = NULL ; EXT4_I(inode ) -> cur_aio_dio = NULL ; if ( ! is_sync_kiocb(iocb ) ) { <START_VULN> iocb -> private = ext4_init_io_end(inode ) ; <END_VULN> if ( ! iocb -> private ) return - ENOMEM ;
% % DefineImageProperty( ) associates an assignment string of the form % "key = value" with an artifact or options . It is equivelent to <START_VULN> % SetImageProperty( ) <END_VULN> % % The format of the DefineImageProperty method is : %
if (in_atomic( ) || ! mm ) goto no_context ; <START_VULN> perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> down_read( & mm -> mmap_sem ) ;
if (ua ) { efree(ua ) ; } <START_VULN> } <END_VULN> } if (user_headers ) {
static PRUint32 GetWorkerCloseHandlerTimeoutMS( ) ; PRBool QueueSuspendedWorker(nsDOMWorkerRunnable * aRunnable ) ; nsCOMPtr < nsIThreadPool > mThreadPool ; <START_VULN> nsRefPtrHashtable < nsISupportsHashKey , nsDOMWorkerPool > mPools ; <END_VULN> PRMonitor * mMonitor ; nsRefPtrHashtable < nsVoidPtrHashKey , nsDOMWorkerRunnable > mWorkersInProgress ;
} sem_lock_and_putref(sma ) ; if (sma -> sem_perm . deleted ) { <START_VULN> sem_unlock(sma ) ; <END_VULN> err = - EIDRM ; goto out_free ; }
MODULE_DESCRIPTION("Cast6 Cipher Algorithm , AVX optimized" ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("cast6" ) ; <END_VULN>
WARN_ON(sk -> sk_wmem_queued ) ; WARN_ON(sk -> sk_forward_alloc ) ; <START_VULN> kfree(inet -> opt ) ; <END_VULN> dst_release(rcu_dereference_check(sk -> sk_dst_cache , 1 ) ) ; sk_refcnt_debug_dec(sk ) ; }
{ if (obuf [ i ] != rbuf [ i ] ) { <START_VULN> XPR(NT "byte % u (read % u @ % "Q"u ) % d != % d" , <END_VULN> (int ) i , (int ) oc , offset , obuf [ i ] , rbuf [ i ] ) ; diffs + + ; return XD3_INTERNAL ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : cdf . c , v 1 . 60 20140521 13 : 04 : 38 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
int lines ; int compressed_lines ; signed short line_packets ; int y_ptr ; int byte_run ; int pixel_skip ; int pixel_countdown ; unsigned char * pixels ; int pixel ; <START_VULN> int pixel_limit ; <END_VULN> s -> frame . reference = 1 ; s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ; if (avctx -> reget_buffer(avctx , & s -> frame ) < 0 ) { av_log(avctx , AV_LOG_ERROR , "reget_buffer( ) failed" ) ; return - 1 ; } pixels = s -> frame . data [ 0 ] ; pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] ;
} len + = 128 ; buf = (char * ) PORT_Alloc(len ) ; if ( ! buf ) { <START_VULN> return(0 ) ; <END_VULN> } tmpbuf = buf ; if ( cn ) { PORT_Memcpy(tmpbuf , cn -> data , cn -> len ) ; tmpbuf + = cn -> len ; PORT_Memcpy(tmpbuf , BREAK , BREAKLEN ) ;
evt -> event . lun [ 0 ] = 0x01 ; <START_VULN> evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ; <END_VULN> if (lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ; evt -> event . lun [ 3 ] = lun -> unpacked_lun & 0xFF ;
Compatible Regular Expression library . It defines the things POSIX says should be there . I hope . <START_VULN> Copyright (c ) 1997 - 2007 University of Cambridge<END_VULN> -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - Redistribution and use in source and binary forms , with or without
__be16inet_sport ; __u16inet_id ; <START_VULN> struct ip_options * opt ; <END_VULN> __u8tos ; __u8min_ttl ; __u8mc_ttl ;
reslevel -> log2_prec_height ) - (reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ) ; <START_VULN> reslevel -> band = av_malloc_array(reslevel -> nbands , sizeof( * reslevel -> band ) ) ; <END_VULN> if ( ! reslevel -> band ) return AVERROR(ENOMEM ) ;
float * ath ; long * octave ; long * bark ; long firstoc ; long shiftoc ; int eighth_octave_lines ; <START_VULN> int total_octave_lines ; <END_VULN> long rate ; float m_val ; } vorbis_look_psy ; extern void _vp_psy_init(vorbis_look_psy * p , vorbis_info_psy * vi , vorbis_info_psy_global * gi , int n , long rate ) ;
#endif #ifndef M_PI # define M_PI (3 . 1415926536f ) #endif #if defined(_WIN32 ) && ! defined(__SYMBIAN32__ ) # include < malloc . h > <START_VULN> # define rint(x ) (floor((x ) + 0 . 5f ) ) <END_VULN> # define NO_FLOAT_MATH_LIB # define FAST_HYPOT(a , b ) sqrt((a ) * (a ) + (b ) * (b ) ) #endif #if defined(__SYMBIAN32__ ) && defined(__WINS__ ) void * _alloca(size_t size ) ; # define alloca _alloca #endif
typename CalcOps : : result_type lhs = ComputeCalc(arr -> Item(0 ) , aOps ) ; float rhs = aOps . ComputeNumber(arr -> Item(1 ) ) ; return aOps . MergeMultiplicativeR(CalcOps : : GetUnit(aValue ) , lhs , rhs ) ; } case eCSSUnit_Calc_Minimum : case eCSSUnit_Calc_Maximum : { typename CalcOps : : input_array_type * arr = aValue . GetArrayValue( ) ; typename CalcOps : : result_type result = ComputeCalc(arr -> Item(0 ) , aOps ) ; <START_VULN> for (PRUint32 i = 1 , i_end = arr -> Count( ) ; i < i_end ; + + i ) { <END_VULN> typename CalcOps : : result_type tmp = ComputeCalc(arr -> Item(i ) , aOps ) ; result = aOps . MergeAdditive(CalcOps : : GetUnit(aValue ) , result , tmp ) ; } return result ; } default : { return aOps . ComputeLeafValue(aValue ) ; }
* elem_rtrn = NULL ; * field_rtrn = xkb_atom_text(ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; <START_VULN> return true ; <END_VULN> case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text(ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text(ctx , expr -> field_ref . field ) ;
if (get_vmx_mem_address(vcpu , exit_qualification , vmx_instruction_info , true , & vmcs_gva ) ) return 1 ; <START_VULN> <END_VULN> if (kvm_write_guest_virt_system( & vcpu -> arch . emulate_ctxt , vmcs_gva , (void * ) & to_vmx(vcpu ) -> nested . current_vmptr , sizeof(u64 ) , & e ) ) {
{ static char * message = NULL ; <START_VULN> static unsigned short len = 0 ; <END_VULN> char buff [ 13 ] , * ret_msg = NULL ; register unsigned char i ; unsigned char blen ;
MODULE_DESCRIPTION("Serpent Cipher Algorithm , SSE2 optimized" ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("serpent" ) ; <END_VULN>
goto do_confirm ; back_from_confirm : <START_VULN> if (inet -> hdrincl ) <END_VULN> err = raw_send_hdrinc(sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ;
0 . 8928678298F , 0 . 9080153310F , 0 . 9217306608F , 0 . 9340480615F , 0 . 9450138200F , 0 . 9546851041F , 0 . 9631286621F , 0 . 9704194171F , 0 . 9766389810F , 0 . 9818741197F , 0 . 9862151938F , 0 . 9897546035F , 0 . 9925852598F , 0 . 9947991032F , 0 . 9964856900F , 0 . 9977308602F , 0 . 9986155015F , 0 . 9992144193F , 0 . 9995953200F , 0 . 9998179155F , 0 . 9999331503F , 0 . 9999825563F , 0 . 9999977357F , 0 . 9999999720F , } ; <START_VULN> static float vwin256 [ 128 ] = { <END_VULN> 0 . 0000591390F , 0 . 0005321979F , 0 . 0014780301F , 0 . 0028960636F , 0 . 0047854363F , 0 . 0071449926F , 0 . 0099732775F , 0 . 0132685298F , 0 . 0170286741F , 0 . 0212513119F , 0 . 0259337111F , 0 . 0310727950F , 0 . 0366651302F , 0 . 0427069140F , 0 . 0491939614F , 0 . 0561216907F , 0 . 0634851102F , 0 . 0712788035F , 0 . 0794969160F , 0 . 0881331402F , 0 . 0971807028F , 0 . 1066323515F , 0 . 1164803426F , 0 . 1267164297F , 0 . 1373318534F , 0 . 1483173323F , 0 . 1596630553F , 0 . 1713586755F , 0 . 1833933062F , 0 . 1957555184F , 0 . 2084333404F , 0 . 2214142599F ,
if (likely(atomic_inc_not_zero( & sk -> sk_refcnt ) ) ) { * skb_hwtstamps(skb ) = * hwtstamps ; <START_VULN> __skb_complete_tx_timestamp(skb , sk , SCM_TSTAMP_SND ) ; <END_VULN> sock_put(sk ) ; } }
parent_inode , & key , BTRFS_FT_DIR , index ) ; <START_VULN> BUG_ON(ret == - EEXIST ) ; <END_VULN> if (ret ) { btrfs_abort_transaction(trans , root , ret ) ; goto fail ;
<START_VULN> if (tsk != current ) <END_VULN> return ; if (MSR_TM_SUSPENDED(mfmsr( ) ) ) {
char errbuff [ 128 ] ; cli_strerror(errno , errbuff , sizeof(errbuff ) ) ; cli_dbgmsg("cli_scanxar : Can't read % li bytes @ % li , errno : % s . " , <START_VULN> length , at , errbuff ) ; <END_VULN> rc = CL_EREAD ; __lzma_wrap_free(NULL , buff ) ; cli_LzmaShutdown( & lz ) ;
} } <START_VULN> static void follow_dotdot(struct nameidata * nd ) <END_VULN> { if ( ! nd -> root . mnt ) set_root(nd ) ;
return - ENETUNREACH ; } <START_VULN> if (inet -> opt == NULL || ! inet -> opt -> srr ) <END_VULN> daddr = rt -> rt_dst ; if (inet -> inet_saddr == 0 )
XPCCompartmentSet & GetCompartmentSet( ) { return mCompartmentSet ; } XPCLock * GetMapLock( ) const { return mMapLock ; } JSBool OnJSContextNew(JSContext * cx ) ; <START_VULN> JSBool DeferredRelease(nsISupports * obj ) ; <END_VULN> JSBool GetDoingFinalization( ) const { return mDoingFinalization ; } enum {
- 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 62 , - 1 , - 1 , - 1 , 63 , <START_VULN> 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , <END_VULN> - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 ,
<START_VULN> if (strchr(page , '' ) ) <END_VULN> { http_response_set_status(res , 404 , "Not Found" ) ; http_response_printf(res , " < html > < body > 404 Not Found < body > < html > " ) ;
<START_VULN> ** Copyright (C ) 2002 - 2013 Erik de Castro Lopo < erikd@mega - nerd . com > <END_VULN> ** Copyright (C ) 2003 Ross Bencina < rbencina@iprimus . com . au > ** ** This program is free software ; you can redistribute it andor modify
* If the given username exists in the passwd file , the entry is * replaced with the given entry . <START_VULN> int setpwnam(struct passwd * pwd ) <END_VULN> { FILE * fp = NULL , * pwf = NULL ; int save_errno ;
uint length , counter = 0 ; ulong rowcount = 0L ; char tables [ NAME_LEN + 1 ] , rows [ NAME_LEN + 1 ] ; <START_VULN> char query [ 255 ] ; <END_VULN> MYSQL_FIELD * field ; MYSQL_RES * result ; MYSQL_ROW row = NULL , rrow ;
} * hdr , _hdr ; hdr = __skb_header_pointer(skb , nhoff , sizeof(_hdr ) , data , hlen , & _hdr ) ; if ( ! hdr ) <START_VULN> return false ; <END_VULN> proto = hdr -> proto ; nhoff + = PPPOE_SES_HLEN ; switch (proto ) {
* #ifdef DEBUG <START_VULN> static const char CVS_ID [ ] = "@(# ) $ RCSfile : certdata . c , v $ $ Revision : 1 . 67 $ $ Date : 20100408 14 : 28 : 58 $ "" ; @(# ) $ RCSfile : certdata . c , v $ $ Revision : 1 . 67 $ $ Date : 20100408 14 : 28 : 58 $ " ; <END_VULN> #endif #ifndef BUILTINS_H #include "builtins . h" #endif static const CK_BBOOL ck_false = CK_FALSE ; static const CK_BBOOL ck_true = CK_TRUE ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : readelf . c , v 1 . 104 20141017 15 : 49 : 00 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
<START_VULN> length = (MagickSizeType ) ReadBlobByte(image ) ; <END_VULN> combined_length + = length + 1 ; if (length > 0 ) (void ) ReadBlob(image , (size_t ) length + + , layer_info [ i ] . name ) ;
. release = gfs2_release , . fsync = gfs2_fsync , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . setlease = generic_setlease , . fallocate = gfs2_fallocate , } ;
if ( ! (mGeneration + 1 ) . valid( ) ) return false ; + + mGeneration ; mMapUniformLocations . Clear( ) ; return true ; } <START_VULN> already_AddRefed < WebGLUniformLocation > GetUniformLocationObject(GLint glLocation ) ; <END_VULN> bool UpdateInfo(gl : : GLContext * gl ) ; WebGLint UniformMaxNameLength( ) const { return mUniformMaxNameLength ; } WebGLint AttribMaxNameLength( ) const { return mAttribMaxNameLength ; } WebGLint UniformCount( ) const { return mUniformCount ; }
return AVERROR_INVALIDDATA ; frame + = v ; } else { <START_VULN> if (frame_end - frame < width + 3 ) <END_VULN> return AVERROR_INVALIDDATA ; frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte(gb ) ;
ret = buf [ 1 ] ; exit : <START_VULN> spin_unlock_irqrestore( & dev -> lock , flags ) ; <END_VULN> return ret ; }
static struct user_namespace * user_ns ; <START_VULN> static struct mount * last_dest , * last_source , * dest_master ; <END_VULN> static struct mountpoint * mp ; static struct hlist_head * list ;
return error ; } <START_VULN> perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> destreg = (opcode >> 4 ) & 0x3f ; if (user_mode(regs ) ) {
private : nsGfxScrollFrameInner * mInner ; } ; void FinishReflowForScrollbar(nsIContent * aContent , nscoord aMinXY , nscoord aMaxXY , nscoord aCurPosXY , nscoord aPageIncrement , nscoord aIncrement ) ; <START_VULN> static void SetScrollbarEnabled(nsIContent * aContent , nscoord aMaxPos ) ; <END_VULN> void SetCoordAttribute(nsIContent * aContent , nsIAtom * aAtom , nscoord aSize ) ; nscoord GetCoordAttribute(nsIFrame * aFrame , nsIAtom * aAtom , nscoord aDefaultValue , nscoord * aRangeStart , nscoord * aRangeLength ) ; void UpdateScrollbarPosition( ) ; nsRect GetScrollPortRect( ) const { return mScrollPort ; }
* result_len = 0 ; start_offset = 0 ; PCRE_G(error_code ) = PHP_PCRE_NO_ERROR ; <START_VULN> <END_VULN> while (1 ) { count = pcre_exec(pce -> re , extra , subject , subject_len , start_offset ,
tsk -> flags |= PF_EXITPIDONE ; if (tsk -> io_context ) <START_VULN> exit_io_context( ) ; <END_VULN> if (tsk -> splice_pipe ) __free_pipe_info(tsk -> splice_pipe ) ;
PUNFETCH ; prev = p ; num = scan_unsigned_octal_number( & p , end , 3 , enc ) ; <START_VULN> if (num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <END_VULN> if (p == prev ) { num = 0 ; }
<START_VULN> if (inet -> hdrincl ) <END_VULN> goto done ; if (ipc . opt -> opt . srr ) { if ( ! daddr )
<START_VULN> struct key * find_keyring_by_name(const char * name , bool skip_perm_check ) <END_VULN> { struct key * keyring ; int bucket ;
} int install_process_keyring_to_cred(struct cred * new ) { struct key * keyring ; if (new -> process_keyring ) <START_VULN> return - EEXIST ; <END_VULN> keyring = keyring_alloc("_pid" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW ,
* <START_VULN> <END_VULN> #include "lowkeyi . h" #include "secasn1 . h" #include "secder . h" #include "secoid . h" #include "blapi . h" #include "secitem . h" #include "pcert . h"
} else { fit_valueB [ ln ] = ly0 ; if(ln == 0 ) fit_valueA [ ln ] = ly0 ; fit_valueA [ i ] = ly1 ; fit_valueB [ i ] = hy0 ; fit_valueA [ hn ] = hy1 ; if(hn == 1 ) fit_valueB [ hn ] = hy1 ; <START_VULN> <END_VULN> if(ly1 >= 0 || hy0 >= 0 ) { for(j = sortpos - 1 ; j >= 0 ; j -- ) if(hineighbor [ j ] == hn ) hineighbor [ j ] = i ; else break ; for(j = sortpos + 1 ; j < posts ; j + + )
zrtpPacket -> messageData = (void * ) messageData ; <START_VULN> <END_VULN> zrtpPacket -> packetString = (uint8_t * ) malloc(inputLength * sizeof(uint8_t ) ) ; memcpy(zrtpPacket -> packetString , input , inputLength ) ; }
const AVFrame * src , int field ) { int plane ; <START_VULN> for (plane = 0 ; plane < 4 && src -> data [ plane ] ; plane + + ) <END_VULN> av_image_copy_plane(dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width(fm , src , plane ) , get_height(fm , src , plane ) 2 ) ;
vorbis_info * vi = v -> vi ; codec_setup_info * ci = vi -> codec_setup ; int hs = ci -> halfrate_flag ; private_state * b = v -> backend_state ; if(b -> window [ W ] - 1 < 0 ) return NULL ; return _vorbis_window_get(b -> window [ W ] - hs ) ; } <START_VULN> <END_VULN>
<START_VULN> <END_VULN> #ifndef COMPILER_DEBUG_H_ #define COMPILER_DEBUG_H_ #include < assert . h > #ifdef _DEBUG #define TRACE_ENABLED
if (iv && (timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) <START_VULN> timr -> it_overrun + = (int ) kc -> timer_forward(timr , now ) ; <END_VULN> remaining = kc -> timer_remaining(timr , now ) ;
the match again at the same point . If this fails (picked up above ) we advance to the next character . * g_notempty = (offsets [ 1 ] == offsets [ 0 ] ) ? PCRE_NOTEMPTY | PCRE_ANCHORED : 0 ; <START_VULN> <END_VULN> start_offset = offsets [ 1 ] ; }
public : bool init(uint32_t id , uint32_t offset , uint32_t numSuccessors ) { id_ = id ; offset_ = offset ; numSuccessors_ = numSuccessors ; if (numSuccessors ) { <START_VULN> successors_ = (uint32_t * ) js_calloc(numSuccessors * sizeof(uint32_t ) ) ; <END_VULN> if ( ! successors_ ) return false ; } return true ; } void destroy( ) { js_free(successors_ ) ;
cap . descr_num = 16 ; cap . descr_type = CA_ECD ; memcpy(parg , & cap , sizeof(cap ) ) ; break ; } case CA_GET_SLOT_INFO : { ca_slot_info_t * info = (ca_slot_info_t * ) parg ; <START_VULN> if (info -> num > 1 ) <END_VULN> return - EINVAL ; av7110 -> ci_slot [ info -> num ] . num = info -> num ; av7110 -> ci_slot [ info -> num ] . type = FW_CI_LL_SUPPORT(av7110 -> arm_app ) ? CA_CI_LINK : CA_CI ; memcpy(info , & av7110 -> ci_slot [ info -> num ] , sizeof(ca_slot_info_t ) ) ; break ; } case CA_GET_MSG : break ;
MODULE_DESCRIPTION("Rijndael (AES ) Cipher Algorithm" ) ; MODULE_LICENSE("Dual BSDGPL" ) ; <START_VULN> MODULE_ALIAS("aes" ) ; <END_VULN>
struct net_device * dev ; struct sock * sk = sock -> sk ; if (peer ) return - EOPNOTSUPP ; uaddr -> sa_family = AF_PACKET ; rcu_read_lock( ) ; dev = dev_get_by_index_rcu(sock_net(sk ) , pkt_sk(sk ) -> ifindex ) ; if (dev ) <START_VULN> strlcpy(uaddr -> sa_data , dev -> name , 15 ) ; <END_VULN> else memset(uaddr -> sa_data , 0 , 14 ) ; rcu_read_unlock( ) ; * uaddr_len = sizeof( * uaddr ) ; return 0 ; }
sdb_num_set (sdb , "link" , shdr -> sh_link , 0 ) ; sdb_set (sdb , "link_section_name" , link_section_name , 0 ) ; <START_VULN> for (cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ((char * ) defs + i < end ) ; + + cnt ) { <END_VULN> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ((char * ) defs ) + i ; char key [ 32 ] = { 0 } ;
struct TypedArrayObjectStorage : AllTypedArraysBase { protected : JSObject * mObj ; <START_VULN> TypedArrayObjectStorage( ) <END_VULN> { } explicit TypedArrayObjectStorage(TypedArrayObjectStorage && aOther ) : mObj(aOther . mObj ) { aOther . mObj = nullptr ; }
m_pos + = 8 ; } while (op < oe ) ; op = oe ; <START_VULN> if (HAVE_IP(6 ) ) { <END_VULN> state = next ; COPY4(op , ip ) ; op + = next ;
acked : 1 , no_srccheck : 1 ; kmemcheck_bitfield_end(flags ) ; <START_VULN> struct ip_options * opt ; <END_VULN> } ; static inline struct inet_request_sock * inet_rsk(const struct request_sock * sk )
static int kvm_set_guest_paused(struct kvm_vcpu * vcpu ) { <START_VULN> if ( ! vcpu -> arch . time_page ) <END_VULN> return - EINVAL ; vcpu -> arch . pvclock_set_guest_stopped_request = true ; kvm_make_request(KVM_REQ_CLOCK_UPDATE , vcpu ) ;
MarFile * CVE_2013_1726_mar_wopen(const wchar_t * path ) { FILE * fp ; <START_VULN> fp = _wfopen(path , L"rb" ) ; <END_VULN> if ( ! fp ) return NULL ; return mar_fpopen(fp ) ; }
PHPAPI pcre * pcre_get_compiled_regex_ex(char * regex , pcre_extra ** extra , int * preg_options , int * compile_options TSRMLS_DC ) { pcre_cache_entry * pce = pcre_get_compiled_regex_cache(regex , strlen(regex ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if (extra ) { * extra = pce ? pce -> extra : NULL ; }
} size_offsets = (size_offsets + 1 ) * 3 ; offsets = (int * ) safe_emalloc(size_offsets , sizeof(int ) , 0 ) ; <START_VULN> <END_VULN> array_init(return_value ) ;
const wbxml_decoding * map ) { guint32 tvb_len = tvb_reported_length (tvb ) ; <START_VULN> guint32 off = offset ; <END_VULN> guint32 len ; guint str_len ; guint32 ent ;
{ STATE_AGGR_R0 , STATE_AGGR_R1 , SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY , P(SA ) | P(KE ) | P(NONCE ) | P(ID ) , P(VID ) | P(NATD_RFC ) , PT(NONE ) , <START_VULN> EVENT_v1_RETRANSMIT , aggr_inI1_outR1 } , <END_VULN>
list_for_each_entry_safe(cmd , n , error_q , eh_entry ) { if (cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) <START_VULN> sas_eh_defer_cmd(cmd ) ; <END_VULN> } }
uint32_t * GetImageData( ) ; int32_t GetCompressedImageSize( ) const ; bool HasAlphaData( ) const ; <START_VULN> virtual void WriteInternal(const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal( ) ; private : NS_METHOD CalcBitShift( ) ;
module_init(sha1_s390_init ) ; module_exit(sha1_s390_fini ) ; <START_VULN> MODULE_ALIAS("sha1" ) ; <END_VULN> MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm" ) ;
walkbuf = result + * result_len ; <START_VULN> <END_VULN> if (eval || is_callable_replace ) {
. open = ftrace_pid_open , . write = ftrace_pid_write , . read = seq_read , <START_VULN> . llseek = seq_lseek , <END_VULN> . release = ftrace_pid_release , } ;
stat = yajl_parse_complete(hand ) ; if (stat != yajl_status_ok && <START_VULN> stat != yajl_status_insufficient_data ) <END_VULN> { unsigned char * str = yajl_get_error(hand , 1 , data , dataSize ) ; fprintf(stderr , (const char * ) str ) ;
const struct xt_entry_target * t ; unsigned int verdict ; <START_VULN> if ( ! unconditional( & e -> ipv6 ) ) <END_VULN> return false ; t = ip6t_get_target_c(e ) ; if (strcmp(t -> u . user . name , XT_STANDARD_TARGET ) != 0 )
. open = stack_trace_filter_open , . read = seq_read , . write = ftrace_filter_write , <START_VULN> . llseek = ftrace_regex_lseek , <END_VULN> . release = ftrace_regex_release , } ;
static int _vds_shared_init(vorbis_dsp_state * v , vorbis_info * vi , int encp ) { int i ; codec_setup_info * ci = vi -> codec_setup ; private_state * b = NULL ; int hs ; if(ci == NULL ) return 1 ; <START_VULN> hs = ci -> halfrate_flag ; <END_VULN> memset(v , 0 , sizeof( * v ) ) ; b = v -> backend_state = _ogg_calloc(1 , sizeof( * b ) ) ; v -> vi = vi ; b -> modebits = ilog2(ci -> modes ) ; b -> transform [ 0 ] = _ogg_calloc(VI_TRANSFORMB , sizeof( * b -> transform [ 0 ] ) ) ;
namespace XrayUtils { extern JSClass HolderClass ; bool CloneExpandoChain(JSContext * cx , JSObject * src , JSObject * dst ) ; bool <START_VULN> IsTransparent(JSContext * cx , JSObject * wrapper ) ; <END_VULN> JSObject * GetNativePropertiesObject(JSContext * cx , JSObject * wrapper ) ; } class XrayTraits ; class XPCWrappedNativeXrayTraits ;
#ifndef _V_LSP_H_ #define _V_LSP_H_ extern int vorbis_lpc_to_lsp(float * lpc , float * lsp , int m ) ; extern void vorbis_lsp_to_curve(float * curve , int * map , int n , int ln , float * lsp , int m , float amp , float ampoffset ) ; <START_VULN> <END_VULN> #endif
for (uv = 4 ; uv < 6 ; uv + + ) { s -> above_block_idx [ uv ] + = 1 ; s -> block_offset [ uv ] + = 8 ; } } } next : if (p -> key_frame || golden_frame ) { <START_VULN> if (s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && <END_VULN> s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] ) avctx -> release_buffer(avctx , s -> framep [ VP56_FRAME_GOLDEN ] ) ; s -> framep [ VP56_FRAME_GOLDEN ] = p ; } if (s -> has_alpha ) { FFSWAP(AVFrame * , s -> framep [ VP56_FRAME_GOLDEN ] , s -> framep [ VP56_FRAME_GOLDEN2 ] ) ; buf + = alpha_offset ; remaining_buf_size -= alpha_offset ;
tag = data [ dp + + ] ; <START_VULN> if (tag == 0 ) { <END_VULN> if (data [ dp + + ] != 0 ) goto invalid_eoc ;
UNIXCB(skb ) . fp = NULL ; for (i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <START_VULN> unix_notinflight(scm -> fp -> fp [ i ] ) ; <END_VULN> } static void unix_destruct_scm(struct sk_buff * skb )
perf_prepare_sample( & header , & data , event , & regs ) ; <START_VULN> if (perf_output_begin( & handle , event , header . size * (top - at ) , 1 , 1 ) ) <END_VULN> return 1 ; for ( ; at < top ; at + + ) {
protected : nsPresContext * mPresContext ; nsCOMPtr < nsIPresShell > mPresShell ; nsCOMPtr < nsISelection > mSelection ; nsRefPtr < nsRange > mFirstSelectedRange ; nsCOMPtr < nsIContent > mRootContent ; nsresult Init(WidgetQueryContentEvent * aEvent ) ; nsresult Init(WidgetSelectionEvent * aEvent ) ; <START_VULN> <END_VULN> nsresult InitCommon( ) ; public : static nsresult GetFlatTextOffsetOfRange(nsIContent * aRootContent , nsINode * aNode , int32_t aNodeOffset ,
static bool generic_new(struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { <START_VULN> return true ; <END_VULN> } #if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT )
} else { newmap = malloc(sizeof(int ) * size ) ; newrev = malloc(sizeof(int ) * size ) ; atable -> size = 0 ; } if ( ! newmap || ! newrev ) { if (newmap ) atable -> amap = newmap ; if (newrev ) <START_VULN> atable -> amap = newrev ; <END_VULN> return - 1 ; } memset( & newmap [ atable -> size ] , 0 , (size - atable -> size ) * sizeof(int ) ) ; memset( & newrev [ atable -> size ] , 0 , (size - atable -> size ) * sizeof(int ) ) ; atable -> amap = newmap ; atable -> arev = newrev ; atable -> size = size ; } return 0 ; }
} if (ntohs(uh -> uh_dport ) == TFTP_SERVER ) { tftp_input(m ) ; goto bad ; } so = slirp -> udp_last_so ; <START_VULN> if (so -> so_lport != uh -> uh_sport || <END_VULN> so -> so_laddr . s_addr != ip -> ip_src . s_addr ) { struct socket * tmp ; for (tmp = slirp -> udb . so_next ; tmp != & slirp -> udb ; tmp = tmp -> so_next ) { if (tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr ) { so = tmp ; break ; }
{ GF_HandlerBox * p = (GF_HandlerBox * ) a ; gf_isom_box_dump_start(a , "HandlerBox" , trace ) ; <START_VULN> if (p -> nameUTF8 && (u32 ) p -> nameUTF8 [ 0 ] == strlen(p -> nameUTF8 + 1 ) ) { <END_VULN> fprintf(trace , "hdlrType = " % s" Name = " % s" " , gf_4cc_to_str(p -> handlerType ) , p -> nameUTF8 + 1 ) ; } else { fprintf(trace , "hdlrType = " % s" Name = " % s" " , gf_4cc_to_str(p -> handlerType ) , p -> nameUTF8 ) ;
static int CVE_2012_1183_milliwatt_generate(struct ast_channel * chan , void * data , int len , int samples ) { unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; <START_VULN> const int maxsamples = ARRAY_LEN(buf ) ; <END_VULN> int i , * indexp = (int * ) data ; struct ast_frame wf = { . frametype = AST_FRAME_VOICE , . offset = AST_FRIENDLY_OFFSET , . src = __FUNCTION__ , } ; ast_format_set( & wf . subclass . format , AST_FORMAT_ULAW , 0 ) ; wf . data . ptr = buf + AST_FRIENDLY_OFFSET ;
switch (ntf -> activation_rf_tech_and_mode ) { case NCI_NFC_A_PASSIVE_POLL_MODE : nfca_poll = & ntf -> activation_params . nfca_poll_iso_dep ; <START_VULN> nfca_poll -> rats_res_len = * data + + ; <END_VULN> pr_debug("rats_res_len % d" , nfca_poll -> rats_res_len ) ; if (nfca_poll -> rats_res_len > 0 ) { memcpy(nfca_poll -> rats_res ,
vA = (int ) buf [ 1 ] ; vB = (buf [ 3 ] << 8 ) | buf [ 2 ] ; vC = (buf [ 5 ] << 8 ) | buf [ 4 ] ; <START_VULN> sprintf (str , " { v % i . . v % i } , [ % 04x ] " , vC , vC + vA - 1 , vB ) ; <END_VULN> strasm = r_str_concat (strasm , str ) ; break ; case fmtoptinvokeVS :
friend class CanvasRenderingContext2DUserData ; protected : nsresult GetImageDataArray(JSContext * aCx , int32_t aX , int32_t aY , uint32_t aWidth , uint32_t aHeight , JSObject ** aRetval ) ; nsresult PutImageData_explicit(int32_t x , int32_t y , uint32_t w , uint32_t h , <START_VULN> unsigned char * aData , uint32_t aDataLen , <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , int32_t dirtyWidth , int32_t dirtyHeight ) ; nsresult Initialize(int32_t width , int32_t height ) ;
if ( * firsthardlink < 0 ) { * firsthardlink = rpmfiFX(fi ) ; <START_VULN> rc = expandRegular(fi , dest , psm , nodigest , 1 ) ; <END_VULN> } else { char * fn = rpmfilesFN(files , * firsthardlink ) ;
if ((edges & 8 ) && s -> mb_y == ((s -> mb_height >> v -> field_mode ) - 1 ) ) mquant = - v -> altpq ; <START_VULN> if ( ! mquant || mquant > 31 ) { <END_VULN> av_log(v -> s . avctx , AV_LOG_ERROR , "Overriding invalid mquant % d" , mquant ) ; mquant = 1 ;
seq_puts(m , "key : " ) ; seq_puts(m , key -> description ) ; <START_VULN> if (key_is_instantiated(key ) ) <END_VULN> seq_printf(m , " pid : % d ci : % zu" , rka -> pid , rka -> callout_len ) ; }
int initialContextToken = ( * context_handle == GSS_C_NO_CONTEXT ) ; if (initialContextToken ) { <START_VULN> code = iakerb_alloc_context( & ctx ) ; <END_VULN> if (code != 0 ) goto cleanup ;
#define SMKTREE_BITS 9 #define SMK_NODE 0x80000000 <START_VULN> <END_VULN> typedef struct SmackVContext { AVCodecContext * avctx ;
static int CVE_2013_3670_rle_unpack(const unsigned char * src , int src_len , int src_count , unsigned char * dest , int dest_len ) { const unsigned char * ps ; const unsigned char * ps_end ; unsigned char * pd ; <START_VULN> int i , l ; <END_VULN> unsigned char * dest_end = dest + dest_len ; ps = src ; ps_end = src + src_len ; pd = dest ; if (src_count & 1 ) { if (ps_end - ps < 1 ) return 0 ; * pd + + = * ps + + ; }
IPTOS_PREC_INTERNETCONTROL ) : iph -> tos ; <START_VULN> if (ip_options_echo( & icmp_param . replyopts , skb_in ) ) <END_VULN> goto out_unlock ;
we can write * vorbis_staticbook_pack(testlist [ ptr ] , & write ) ; fprintf(stderr , "Codebook size % ld bytes . . . " , oggpack_bytes( & write ) ) ; for(i = 0 ; i < TESTSIZE ; i + = c . dim ) { int best = _best( & c , qv + i , 1 ) ; vorbis_book_encodev( & c , best , qv + i , & write ) ; } vorbis_book_clear( & c ) ; <START_VULN> <END_VULN> fprintf(stderr , "OK . " ) ; fprintf(stderr , "tunpackingdecoding % ld . . . " , ptr ) ; oggpack_readinit( & read , oggpack_get_buffer( & write ) , oggpack_bytes( & write ) ) ; if(vorbis_staticbook_unpack( & read , & s ) ) { fprintf(stderr , "Error unpacking codebook . " ) ; exit(1 ) ;
scatterwalk_done( & src_sg_walk , 0 , 0 ) ; scatterwalk_done( & assoc_sg_walk , 0 , 0 ) ; } else { <START_VULN> scatterwalk_map_and_copy(dst , req -> dst , 0 , req -> cryptlen , 1 ) ; <END_VULN> kfree(src ) ; } return retval ;
} } else { #ifdef DEBUG fprintf(stderr , "dissect_wtp : (4 ) tree was % p" , tree ) ; #endif } if (fCon ) { unsigned char tCon ; unsigned char tByte ; <START_VULN> unsigned char tpiLen ; <END_VULN> tvbuff_t * tmp_tvb ; vHeader = 0 ; do { tByte = tvb_get_guint8(tvb , offCur + cbHeader + vHeader ) ; tCon = tByte & 0x80 ; if (tByte & 0x04 ) tpiLen = 2 + tvb_get_guint8(tvb , offCur + cbHeader + vHeader + 1 ) ;
{ gchar * absolute_filename ; <START_VULN> if (g_file_test (filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute (filename ) ) { <END_VULN> absolute_filename = g_strdup (filename ) ; } else { gchar * tmpcdir ;
void ImplSetSize( sal_uInt16 nSize , bool bResize = true ) ; void ImplCreateFlagArray( ) ; <START_VULN> void ImplSplit( sal_uInt16 nPos , sal_uInt16 nSpace , ImplPolygon const * pInitPoly = nullptr ) ; <END_VULN> } ; #define MAX_POLYGONS ((sal_uInt16 ) 0x3FF0 )
return ret ; } <START_VULN> static struct fsnotify_group * inotify_new_group(struct user_struct * user , unsigned int max_events ) <END_VULN> { struct fsnotify_group * group ;
if (compile_options ) { * compile_options = pce ? pce -> compile_options : 0 ; } <START_VULN> <END_VULN> return pce ? pce -> re : NULL ; }
void vorbis_dsp_clear(vorbis_dsp_state * v ) { int i ; if(v ) { vorbis_info * vi = v -> vi ; codec_setup_info * ci = (vi ? vi -> codec_setup : NULL ) ; private_state * b = v -> backend_state ; if(b ) { <START_VULN> <END_VULN> if(b -> ve ) { _ve_envelope_clear(b -> ve ) ; _ogg_free(b -> ve ) ; } if(b -> transform [ 0 ] ) { mdct_clear(b -> transform [ 0 ] [ 0 ] ) ; _ogg_free(b -> transform [ 0 ] [ 0 ] ) ;
unsigned int * size ) ; int xt_compat_target_to_user(const struct xt_entry_target * t , void __user ** dstptr , unsigned int * size ) ; <START_VULN> int xt_compat_check_entry_offsets(const void * base , <END_VULN> unsigned int target_offset , unsigned int next_offset ) ;
int CVE_2012_6618_av_probe_input_buffer(AVIOContext * pb , AVInputFormat ** fmt , const char * filename , void * logctx , unsigned int offset , unsigned int max_probe_size ) { AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; unsigned char * buf = NULL ; <START_VULN> int ret = 0 , probe_size ; <END_VULN> if ( ! max_probe_size ) { max_probe_size = PROBE_BUF_MAX ; } else if (max_probe_size > PROBE_BUF_MAX ) { max_probe_size = PROBE_BUF_MAX ; } else if (max_probe_size < PROBE_BUF_MIN ) { return AVERROR(EINVAL ) ; } if (offset >= max_probe_size ) {
<START_VULN> #define JSXDR_BYTECODE_VERSION (0xb973c0de - 85 ) <END_VULN>
int CVE_2013_1726_mar_read_product_info_block(MarFile * mar , struct ProductInformationBlock * infoBlock ) { <START_VULN> int i , hasAdditionalBlocks , offset , <END_VULN> offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; char buf [ 97 ] = { '0' } ; int ret = get_mar_file_info_fp(mar -> fp , NULL , NULL , & hasAdditionalBlocks , & offsetAdditionalBlocks , & numAdditionalBlocks ) ; for (i = 0 ; i < numAdditionalBlocks ; + + i ) {
return mar_fpopen(fp ) ; } #ifdef XP_WIN MarFile * mar_wopen(const wchar_t * path ) { FILE * fp ; <START_VULN> fp = _wfopen(path , L"rb" ) ; <END_VULN> if ( ! fp ) return NULL ; return mar_fpopen(fp ) ; } #endif void mar_close(MarFile * mar ) {
} } mutt_buffer_addstr(buf , "X - GM - RAW " ) ; <START_VULN> imap_quote_string(term , sizeof(term ) , pat -> p . str ) ; <END_VULN> mutt_buffer_addstr(buf , term ) ; break ; }
if (opt_count ) { <START_VULN> sprintf(query , "select count( * ) from ` % s`" , table ) ; <END_VULN> if (mysql_query(mysql , query ) || ! (result = mysql_store_result(mysql ) ) ) { fprintf(stderr , " % s : Cannot get record count for db : % s , table : % s : % s" ,
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("AES Secure Hash Algorithm , sparc64 aes opcode accelerated" ) ; <START_VULN> MODULE_ALIAS("aes" ) ; <END_VULN> #include "crop_devid . c"
length = (size_t ) (GetQuantumRange(info . depth ) + 1 ) ; if (length > (size_t ) GetBlobSize(image ) ) ThrowDCMException(CorruptImageError , "InsufficientImageDataInFile" ) ; <START_VULN> if (info . scale != (Quantum * ) NULL ) <END_VULN> info . scale = (Quantum * ) RelinquishMagickMemory(info . scale ) ; info . scale = (Quantum * ) AcquireQuantumMemory(MagickMax(length , 256 ) , sizeof( * info . scale ) ) ;
avctx -> pix_fmt = AV_PIX_FMT_GRAY16BE ; } else if (s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB ) { avctx -> pix_fmt = AV_PIX_FMT_RGB48BE ; } else if (s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA ) { avctx -> pix_fmt = AV_PIX_FMT_RGBA64BE ; } else if ((s -> bits_per_pixel == 1 || s -> bits_per_pixel == 2 || s -> bits_per_pixel == 4 || s -> bits_per_pixel == 8 ) && s -> color_type == PNG_COLOR_TYPE_PALETTE ) { avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; <START_VULN> } else if (s -> bit_depth == 1 ) { <END_VULN> avctx -> pix_fmt = AV_PIX_FMT_MONOBLACK ; } else if (s -> bit_depth == 8 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA ) { avctx -> pix_fmt = AV_PIX_FMT_YA8 ; } else if (s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA ) { avctx -> pix_fmt = AV_PIX_FMT_YA16BE ; } else { av_log(avctx , AV_LOG_ERROR , "unsupported bit depth % d " "and color type % d" ,
NULL , 0 , 0 , 0 , 0 , 0 , NULL , NULL , NULL , NULL , 0 } ; static float * test1_result = NULL ; <START_VULN> <END_VULN> static_codebook test2 = { 4 , 3 , NULL , 2 , - 533200896 , 1611661312 , 4 , 0 , full_quantlist1 , NULL , NULL , NULL ,
Token currentToken ; unsigned lookahead ; Token lookaheadTokens [ maxLookahead ] ; } ; void advance(size_t position ) ; void tell(Position * ) ; void seek(const Position & pos ) ; <START_VULN> void seek(const Position & pos , const TokenStream & other ) ; <END_VULN> size_t positionToOffset(const Position & pos ) const { return pos . buf - userbuf . base( ) ; } const jschar * rawBase( ) const { return userbuf . base( ) ; }
tp [ 0 ] = '0' ; add_assoc_string( * subarray , "ipv6" , name , 1 ) ; if (cp < p + dlen ) { <START_VULN> n = dn_expand(answer -> qb2 , answer -> qb2 + 65536 , cp , name , (sizeof name ) - 2 ) ; <END_VULN> if (n < 0 ) { return NULL ; }
addr = gfn_to_hva(kvm , gfn ) ; if (kvm_is_error_hva(addr ) ) return - EFAULT ; <START_VULN> r = copy_from_user(data , (void __user * ) addr + offset , len ) ; <END_VULN> if (r ) return - EFAULT ; return 0 ;
len = ( * p ) [ 0 ] << 8 | ( * p ) [ 1 ] ; * p + = 2 ; <START_VULN> if( ( * p ) + len > end ) <END_VULN> { MBEDTLS_SSL_DEBUG_MSG( 1 , ( "bad server key exchange message " "(psk_identity_hint length ) " ) ) ;
const char * msg ; u_int8_t state ; <START_VULN> dh = skb_header_pointer(skb , dataoff , sizeof(_dh ) , & dh ) ; <END_VULN> BUG_ON(dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ;
static const struct driver_info wwan_noarp_info = { . description = "Mobile Broadband Network Device (NO ARP ) " , . flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET <START_VULN> | FLAG_WWAN | FLAG_NOARP , <END_VULN> . bind = cdc_ncm_bind , . unbind = cdc_ncm_unbind , . manage_power = usbnet_manage_power ,
#ifndef MODULE_MAGIC_NUMBER_MAJOR #define MODULE_MAGIC_NUMBER_MAJOR 20150222 #endif <START_VULN> #define MODULE_MAGIC_NUMBER_MINOR 2<END_VULN> AP_DECLARE(int ) ap_some_auth_required(request_rec * r ) ;
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm , sparc64 sha1 opcode accelerated" ) ; <START_VULN> MODULE_ALIAS("sha1" ) ; <END_VULN> #include "crop_devid . c"
<START_VULN> p1 = BuildTestPacket(id , 0 , 0 , 'A' , 8 ) ; <END_VULN> if (p1 == NULL ) { goto end ; }
break ; case SO_PASSCRED : <START_VULN> v . val = test_bit(SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ; <END_VULN> break ; case SO_PEERCRED :
MODULE_LICENSE("Dual BSDGPL" ) ; MODULE_AUTHOR("Intel" ) ; MODULE_DESCRIPTION("Intel(R ) QuickAssist Technology" ) ; <START_VULN> MODULE_ALIAS("intel_qat" ) ; <END_VULN>
j = m + 1 ; while(j -- ) { double d = 0 ; for(i = j ; i < n ; i + + ) d += ( double ) data [ i ] * data [ i - j ] ; aut [ j ] = d ; } <START_VULN> <END_VULN> error = aut [ 0 ] * (1 . + 1e - 10 ) ; epsilon = 1e - 9 * aut [ 0 ] + 1e - 10 ; for(i = 0 ; i < m ; i + + ) { double r = - aut [ i + 1 ] ;
JSObject * obj ; void * ptr ; JSWhyMagic why ; size_t word ; } payload ; } s ; double asDouble ; void * asPtr ; <START_VULN> } jsval_layout ; <END_VULN> # elif JS_BITS_PER_WORD == 64 typedef union jsval_layout { uint64_t asBits ; struct { JSValueTag tag : 17 ; uint64_t payload47 : 47 ; } debugView ;
MAKE_STD_ZVAL(http_header ) ; ZVAL_STRINGL(http_header , http_header_line , http_header_line_length , 1 ) ; <START_VULN> <END_VULN> zend_hash_next_index_insert(Z_ARRVAL_P(response_header ) , & http_header , sizeof(zval * ) , NULL ) ; } } else {
hid -> version = req -> version ; hid -> country = req -> country ; <START_VULN> strncpy(hid -> name , req -> name , 128 ) ; <END_VULN> snprintf(hid -> phys , sizeof(hid -> phys ) , " % pMR" , & bt_sk(session -> ctrl_sock -> sk ) -> src ) ;
struct qeth_cmd_buffer * iob ; struct qeth_ipa_cmd * cmd ; struct qeth_snmp_ureq * ureq ; <START_VULN> int req_len ; <END_VULN> struct qeth_arp_query_info qinfo = { 0 , } ; int rc = 0 ;
if (R - offset < noise [ i ] ) noise [ i ] = R - offset ; } for ( ; i < n ; i + + , x + = 1 . f ) { R = (A + x * B ) D ; if (R - offset < noise [ i ] ) noise [ i ] = R - offset ; } } <START_VULN> static float FLOOR1_fromdB_INV_LOOKUP [ 256 ] = { <END_VULN> 0 . F , 8 . 81683e + 06F , 8 . 27882e + 06F , 7 . 77365e + 06F , 7 . 29930e + 06F , 6 . 85389e + 06F , 6 . 43567e + 06F , 6 . 04296e + 06F , 5 . 67422e + 06F , 5 . 32798e + 06F , 5 . 00286e + 06F , 4 . 69759e + 06F , 4 . 41094e + 06F , 4 . 14178e + 06F , 3 . 88905e + 06F , 3 . 65174e + 06F , 3 . 42891e + 06F , 3 . 21968e + 06F , 3 . 02321e + 06F , 2 . 83873e + 06F , 2 . 66551e + 06F , 2 . 50286e + 06F , 2 . 35014e + 06F , 2 . 20673e + 06F , 2 . 07208e + 06F , 1 . 94564e + 06F , 1 . 82692e + 06F , 1 . 71544e + 06F , 1 . 61076e + 06F , 1 . 51247e + 06F , 1 . 42018e + 06F , 1 . 33352e + 06F ,
ASSERT((entry1 -> flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote(leaf1 , args -> index ) ; name_rmt -> valueblk = cpu_to_be32(args -> rmtblkno ) ; <START_VULN> name_rmt -> valuelen = cpu_to_be32(args -> valuelen ) ; <END_VULN> xfs_trans_log_buf(args -> trans , bp1 , XFS_DA_LOGRANGE(leaf1 , name_rmt , sizeof( * name_rmt ) ) ) ; }
assert(h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; <START_VULN> if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) { <END_VULN> ff_thread_report_progress( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ; }
seq_puts(m , key -> description ) ; <START_VULN> if (key_is_instantiated(key ) ) <END_VULN> seq_printf(m , " : % zu [ % s ] " , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? "file" : "buff" ) ;
xid = GetXid( ) ; <START_VULN> ses = cifs_find_smb_ses(server , volume_info -> username ) ; <END_VULN> if (ses ) { cFYI(1 , "Existing smb sess found (status = % d ) " , ses -> status ) ;
} <START_VULN> static inline void realpath_cache_add(const char * path , int path_len , const char * realpath , int realpath_len , int is_dir , time_t t ) <END_VULN> { zend_long size = sizeof(realpath_cache_bucket ) + path_len + 1 ; int same = 1 ;
ret = - EIO ; if ( ! (lflags & KEY_LOOKUP_PARTIAL ) && <START_VULN> ! test_bit(KEY_FLAG_INSTANTIATED , & key -> flags ) ) <END_VULN> goto invalid_key ;
REG("coredump_filter" , S_IRUGO | S_IWUSR , proc_coredump_filter_operations ) , #endif #ifdef CONFIG_TASK_IO_ACCOUNTING <START_VULN> INF("io" , S_IRUGO , proc_tgid_io_accounting ) , <END_VULN> #endif #ifdef CONFIG_HARDWALL INF("hardwall" , S_IRUGO , proc_pid_hardwall ) ,
char * buf = mutt_str_strdup(src ) ; imap_utf_encode(idata , & buf ) ; <START_VULN> imap_quote_string(dest , dlen , buf ) ; <END_VULN> FREE( & buf ) ; }
umode_t mode = attr -> ia_mode ; if ( ! in_group_p(inode -> i_gid ) && <START_VULN> ! inode_capable(inode , CAP_FSETID ) ) <END_VULN> mode &= ~ S_ISGID ; inode -> i_mode = mode ; }
if (h -> slice_type_nos == AV_PICTURE_TYPE_B ) h -> direct_spatial_mv_pred = get_bits1( & s -> gb ) ; num_ref_idx_active_override_flag = get_bits1( & s -> gb ) ; if (num_ref_idx_active_override_flag ) { h -> ref_count [ 0 ] = get_ue_golomb( & s -> gb ) + 1 ; if (h -> slice_type_nos == AV_PICTURE_TYPE_B ) h -> ref_count [ 1 ] = get_ue_golomb( & s -> gb ) + 1 ; else <START_VULN> max [ 1 ] = 31 ; <END_VULN> } if (h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] ) { av_log(h -> s . avctx , AV_LOG_ERROR , "reference overflow % u > % u or % u > % u" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ) ; h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1 ; return AVERROR_INVALIDDATA ; } if (h -> slice_type_nos == AV_PICTURE_TYPE_B ) h -> list_count = 2 ;
q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; <START_VULN> <END_VULN> ret = futex_wait_setup(uaddr , val , fshared , & q , & hb ) ; if (ret ) goto out_key2 ;
{ return 2 ; } <START_VULN> mpz_powm (b , b , key -> e , key -> n ) ; <END_VULN> mpz_mul (v , v , b ) ; mpz_mod (v , v , key -> n ) ; return 0 ;
reserve = (end - start ) - region_count( & reservations -> regions , start , end ) ; <START_VULN> kref_put( & reservations -> refs , resv_map_release ) ; <END_VULN> if (reserve ) { hugetlb_acct_memory(h , - reserve ) ;
char * result ; if (len <= 0 ) return NULL ; result = ALLOC_N(char , len ) ; <START_VULN> memccpy(result , ptr , 0 , len ) ; <END_VULN> return result ; }
module_init(ipip_init ) ; module_exit(ipip_fini ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("tunl0" ) ; <END_VULN>
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID("@(# ) $ File : funcs . c , v 1 . 72 20140514 23 : 15 : 42 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
void init(JSContext * cx ) ; ~ TypeCompartment( ) ; inline JSCompartment * compartment( ) ; inline void addPending(JSContext * cx , TypeConstraint * constraint , TypeSet * source , Type type ) ; <START_VULN> void growPendingArray(JSContext * cx ) ; <END_VULN> inline void resolvePending(JSContext * cx ) ; void print(JSContext * cx , bool force ) ;
pkiDebug("pkinit_verify_padata : entered ! " ) ; if (data == NULL || data -> length <= 0 || data -> contents == NULL ) { <START_VULN> ( * respond ) (arg , 0 , NULL , NULL , NULL ) ; <END_VULN> return ; }
} if (need_dev ) { <START_VULN> if (kern_path(dev_name , LOOKUP_FOLLOW , & path ) ) { <END_VULN> error = - ENOENT ; goto out ; }
int size ; syscall_nr = trace_get_syscall_nr(current , regs ) ; <START_VULN> if (syscall_nr < 0 ) <END_VULN> return ; if ( ! test_bit(syscall_nr , enabled_perf_exit_syscalls ) ) return ; commit 086ba77a6db00ed858ff07451bedee197df868c9 Author : Rabin Vincent < rabin@rab . in > Date : Wed Oct 29 23 : 06 : 58 2014 + 0100 tracingsyscalls : Ignore numbers outside NR_syscalls' range ARM has some private syscalls (for example , set_tls(2 ) ) which lie outside the range of NR_syscalls . If any of these are called while syscall tracing is being performed , out - of - bounds array access will occur in the ftrace and perf sys_ { enter , exit } handlers . # trace - cmd record - e raw_syscalls : * true && trace - cmd report . . . true - 653 [ 000 ] 384 . 675777 : sys_enter : NR 192 (0 , 1000 , 3 , 4000022 , ffffffff , 0 ) true - 653 [ 000 ] 384 . 675812 : sys_exit : NR 192 = 1995915264 true - 653 [ 000 ] 384 . 675971 : sys_enter : NR 983045 (76f74480 , 76f74000 , 76f74b28 , 76f74480 , 76f76f74 , 1 ) true - 653 [ 000 ] 384 . 675988 : sys_exit : NR 983045 = 0 . . . # trace - cmd record - e syscalls : * true [ 17 . 289329 ] Unable to handle kernel paging request at virtual address aaaaaace [ 17 . 289590 ] pgd = 9e71c000 [ 17 . 289696 ] [ aaaaaace ] * pgd = 00000000 [ 17 . 289985 ] Internal error : Oops : 5 [ #1 ] PREEMPT SMP ARM [ 17 . 290169 ] Modules linked in : [ 17 . 290391 ] CPU : 0 PID : 704 Comm : true Not tainted 3 . 18 . 0 - rc2 + #21 [ 17 . 290585 ] task : 9f4dab00 ti : 9e710000 task . ti : 9e710000 [ 17 . 290747 ] PC is at ftrace_syscall_enter + 0x480x1f8 [ 17 . 290866 ] LR is at syscall_trace_enter + 0x1240x184 Fix this by ignoring out - of - NR_syscalls - bounds syscall numbers . Commit cd0980fc8add "tracing : Check invalid syscall nr while tracing syscalls" added the check for less than zero , but it should have also checked for greater than NR_syscalls . Link : http : lkml . kernel . orgp1414620418 - 29472 - 1 - git - send - email - rabin@rab . in Fixes : cd0980fc8add "tracing : Check invalid syscall nr while tracing syscalls" Cc : stable@vger . kernel . org # 2 . 6 . 33 + Signed - off - by : Rabin Vincent < rabin@rab . in > Signed - off - by : Steven Rostedt < rostedt@goodmis . org >
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("Camellia Cipher Algorithm , sparc64 camellia opcode accelerated" ) ; <START_VULN> MODULE_ALIAS("aes" ) ; <END_VULN> #include "crop_devid . c"
either version 2 of the License or (at your option ) any later version . #pragma once #include "graphite2Types . h" #define GR2_VERSION_MAJOR 1 #define GR2_VERSION_MINOR 1 <START_VULN> #define GR2_VERSION_BUGFIX 2<END_VULN> #ifdef __cplusplus extern "C" { #endif typedef struct gr_face gr_face ; typedef struct gr_font gr_font ;
rcu_read_unlock( ) ; } <START_VULN> static void timerfd_remove_cancel(struct timerfd_ctx * ctx ) <END_VULN> { if (ctx -> might_cancel ) { ctx -> might_cancel = false ;
ipaddr_string(ndo , & ps -> page . p_sid ) , EXTRACT_32BITS( & ps -> page . p_uid ) ) ) ; io = (struct id_off * ) (ps + 1 ) ; <START_VULN> for (ie = io + ps -> nid ; io < ie && ! ND_TTEST( * io ) ; + + io ) { <END_VULN> ND_PRINT((ndo , " % c % s : % u" , c , ipaddr_string(ndo , & io -> id ) , EXTRACT_32BITS( & io -> off ) ) ) ; c = ' , ' ;
nsIRunnable * mPendingInstantiateEvent ; nsCString mContentType ; <START_VULN> nsIChannel * mChannel ; <END_VULN> nsCOMPtr < nsIURI > mURI ; ObjectType mType : 16 ;
if ( ! fp ) return ; <START_VULN> fprintf(certificate_store -> fp , " % s % s" , certificate_data -> hostname , certificate_data -> fingerprint ) ; <END_VULN> fclose(fp ) ; }
if (type == SSL3_RT_APPLICATION_DATA && u_len >= 4 * (max_send_fragment = s -> max_send_fragment ) && s -> compress == NULL && s -> msg_callback == NULL && <START_VULN> ! SSL_USE_ETM(s ) && SSL_USE_EXPLICIT_IV(s ) && <END_VULN> EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) { unsigned char aad [ 13 ] ;
int badop = 0 , bugs = 0 ; int ret = 1 ; int off = 0 ; <START_VULN> int no_tmp_rsa = 0 , nocert = 0 ; <END_VULN> int state = 0 ; SSL_METHOD * meth = NULL ; #ifndef NO_DH
} ret = PTR_ERR(filp ) ; out_close : <START_VULN> nfs4_close_sync(path , state , nd -> intent . open . flags ) ; <END_VULN> return ret ; }
spin_lock_bh( & net -> nsid_lock ) ; peer = idr_find( & net -> netns_ids , id ) ; if (peer ) <START_VULN> get_net(peer ) ; <END_VULN> spin_unlock_bh( & net -> nsid_lock ) ; rcu_read_unlock( ) ;
darray_append(expr -> keysym_list . symsNumEntries , numEntries ) ; darray_concat(expr -> keysym_list . syms , append -> keysym_list . syms ) ; <START_VULN> FreeStmt((ParseCommon * ) & append ) ; <END_VULN> return expr ; }
bool IsIMEDoingKakuteiUndo( ) const ; <START_VULN> void RemoveMessageAndDispatchPluginEvent(UINT aFirstMsg , UINT aLastMsg ) const ; <END_VULN> bool IsKeyDownMessage( ) const { return (mMsg . message == WM_KEYDOWN || mMsg . message == WM_SYSKEYDOWN ) ; } bool IsFollowedByCharMessage( ) const { MOZ_ASSERT(mMsg . message == WM_KEYDOWN || mMsg . message == WM_SYSKEYDOWN ) ;
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("GHASH Message Digest Algorithm" ) ; <START_VULN> MODULE_ALIAS("ghash" ) ; <END_VULN>
err = - EIO ; <START_VULN> netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; <END_VULN> netdev -> features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ;
m_pos -= t >> 2 ; m_pos -= * ip + + << 2 ; TEST_LB(m_pos ) ; <START_VULN> NEED_OP(2 ) ; <END_VULN> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op + = 2 ;
<START_VULN> if (SSL_USE_ETM(s ) && s -> read_hash ) { <END_VULN> unsigned char * mac ; mac_size = EVP_MD_CTX_size(s -> read_hash ) ; OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE ) ;
err_locked : if (move_group ) <START_VULN> mutex_unlock( & gctx -> mutex ) ; <END_VULN> mutex_unlock( & ctx -> mutex ) ; fput(event_file ) ;
key_payload_reserve(key , 0 ) ; <START_VULN> if (key_is_instantiated(key ) && <END_VULN> (size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate(path , 0 ) ; }
int hns_ppe_get_sset_count(int stringset ) { <START_VULN> if (stringset == ETH_SS_STATS ) <END_VULN> return ETH_PPE_STATIC_NUM ; return 0 ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic codebook packunpackcodedecode operations <START_VULN> last mod : $ Id : codebook . c 16227 2009 - 07 - 08 06 : 58 : 46Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
struct bpf_map * map_ptr ; } ; int ctx_field_size ; <START_VULN> int converted_op_size ; <END_VULN> } ; #define MAX_USED_MAPS 64
<START_VULN> if ( ! asoc -> temp ) { <END_VULN> list_del( & asoc -> asocs ) ;
walk + + ; } else return 0 ; <START_VULN> <END_VULN> if ( * walk && * walk >= '0' && * walk <= '9' ) { * backref = * backref * 10 + * walk - '0' ; walk + + ;
JSIdArray * ida ; jschar * chars , * ochars , * vsharp ; const jschar * idstrchars , * vchars ; <START_VULN> size_t nchars , idstrlength , gsoplength , vlength , vsharplength ; <END_VULN> char * comma ; jsint i , j , length , valcnt ; jsid id ;
cleanup : if (ce ) <START_VULN> mb_cache_entry_release(ce ) ; <END_VULN> brelse(new_bh ) ; if ( ! (bs -> bh && s -> base == bs -> bh -> b_data ) ) kfree(s -> base ) ;
struct ipv6_opt_hdr * dst0opt ; struct ipv6_rt_hdr * srcrt ; struct ipv6_opt_hdr * dst1opt ; <START_VULN> <END_VULN> } ;
This is how the time string is formatted : snprintf(p , sizeof(p ) , " % 02d % 02d % 02d % 02d % 02d % 02dZ" , ts -> tm_year % 100 , <START_VULN> ts -> tm_mon + 1 , ts -> tm_mday , ts -> tm_hour , ts -> tm_min , ts -> tm_sec ) ; <END_VULN> time_t ret ;
if (NULL == siocb -> scm ) siocb -> scm = & scm ; <START_VULN> err = scm_send(sock , msg , siocb -> scm ) ; <END_VULN> if (err < 0 ) return err ;
{ struct nfs_delegation * delegation ; struct nfs4_opendata * opendata ; <START_VULN> int delegation_type = 0 ; <END_VULN> int status ; opendata = nfs4_open_recoverdata_alloc(ctx , state ) ;
struct inode ; * To make gcc happy * <START_VULN> extern int parse_rock_ridge_inode(struct iso_directory_record * , struct inode * ) ; <END_VULN> extern int get_rock_ridge_filename(struct iso_directory_record * , char * , struct inode * ) ; extern int isofs_name_translate(struct iso_directory_record * , char * , struct inode * ) ;
<START_VULN> void unix_inflight(struct file * fp ) <END_VULN> { struct sock * s = unix_get_socket(fp ) ;
unsigned short * pixels = (unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ; <START_VULN> int pixel_ptr = 0 ; <END_VULN> int block_ptr ; int pixel_x , pixel_y ; int total_blocks ;
<START_VULN> void ip_options_build(struct sk_buff * skb , struct ip_options * opt , <END_VULN> __be32 daddr , struct rtable * rt , int is_frag ) { unsigned char * iph = skb_network_header(skb ) ;
payload = NULL ; <START_VULN> if (_payload ) { <END_VULN> ret = - ENOMEM ; payload = kvmalloc(plen , GFP_KERNEL ) ; if ( ! payload )
sig_len = ( p [ 0 ] << 8 ) | p [ 1 ] ; p + = 2 ; <START_VULN> if( end != p + sig_len ) <END_VULN> { MBEDTLS_SSL_DEBUG_MSG( 1 , ( "bad server key exchange message" ) ) ; mbedtls_ssl_send_alert_message( ssl , MBEDTLS_SSL_ALERT_LEVEL_FATAL ,
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : readelf . c , v 1 . 142 20180524 18 : 08 : 01 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
0 . 9994740570F , 0 . 9995575079F , 0 . 9996306699F , 0 . 9996944099F , 0 . 9997495605F , 0 . 9997969190F , 0 . 9998372465F , 0 . 9998712678F , 0 . 9998996704F , 0 . 9999231041F , 0 . 9999421807F , 0 . 9999574732F , 0 . 9999695157F , 0 . 9999788026F , 0 . 9999857885F , 0 . 9999908879F , 0 . 9999944746F , 0 . 9999968817F , 0 . 9999984010F , 0 . 9999992833F , 0 . 9999997377F , 0 . 9999999317F , 0 . 9999999911F , 0 . 9999999999F , } ; <START_VULN> static float vwin1024 [ 512 ] = { <END_VULN> 0 . 0000036962F , 0 . 0000332659F , 0 . 0000924041F , 0 . 0001811086F , 0 . 0002993761F , 0 . 0004472021F , 0 . 0006245811F , 0 . 0008315063F , 0 . 0010679699F , 0 . 0013339631F , 0 . 0016294757F , 0 . 0019544965F , 0 . 0023090133F , 0 . 0026930125F , 0 . 0031064797F , 0 . 0035493989F , 0 . 0040217533F , 0 . 0045235250F , 0 . 0050546946F , 0 . 0056152418F , 0 . 0062051451F , 0 . 0068243817F , 0 . 0074729278F , 0 . 0081507582F , 0 . 0088578466F , 0 . 0095941655F , 0 . 0103596863F , 0 . 0111543789F , 0 . 0119782122F , 0 . 0128311538F , 0 . 0137131701F , 0 . 0146242260F ,
assert_true(prof_output_exact("unencrypted" ) ) ; stbbr_send( <START_VULN> " < message type = 'chat' to = 'stabber@localhostprofanity' from = 'buddy1@localhost' > "<END_VULN> " < received xmlns = 'urn : xmpp : carbons : 2' > " " < forwarded xmlns = 'urn : xmpp : forward : 0' > " " < message id = 'prof_msg_7' xmlns = 'jabber : client' type = 'chat' lang = 'en' to = 'stabber@localhostprofanity' from = 'buddy1@localhostmobile' > "
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION ("Salsa20 stream cipher algorithm" ) ; <START_VULN> MODULE_ALIAS("salsa20" ) ; <END_VULN>
break ; case SO_PASSSEC : <START_VULN> v . val = test_bit(SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ; <END_VULN> break ; case SO_PEERSEC :
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID("@(# ) $ File : funcs . c , v 1 . 80 20150102 21 : 29 : 39 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
for (i = 1 ; i < view -> n ; + + i ) { const struct user_regset * regset = & view -> regsets [ i ] ; do_thread_regset_writeback(t -> task , regset ) ; <START_VULN> if (regset -> core_note_type && <END_VULN> ( ! regset -> active || regset -> active(t -> task , regset ) ) ) { int ret ; size_t size = regset -> n * regset -> size ;
goto err ; for (j = 0 ; j < numpipes ; j + + ) { <START_VULN> if (SSL_USE_ETM(s ) && mac_size != 0 ) { <END_VULN> if (s -> method -> ssl3_enc -> mac(s , & wr [ j ] , outbuf [ j ] + wr [ j ] . length , 1 ) < 0 ) goto err ;
Foundation , Inc . , 675 Mass Ave , Cambridge , MA 02139 , USA . <START_VULN> #include < cryptoskcipher . h > <END_VULN> #include < linuxmodule . h > #include < linuxslab . h > #include < linuxfs . h >
Address addressForDataRemat(const FrameEntry * fe ) const ; <START_VULN> Address addressForInlineReturn( ) const ; <END_VULN> inline StateRemat dataRematInfo(const FrameEntry * fe ) const ;
atomic_t xfer_avail ; struct gpio_chip gc ; u8 * in_out_buffer ; <START_VULN> spinlock_t lock ; <END_VULN> struct gpio_desc * desc [ 8 ] ; bool gpio_poll ;
<START_VULN> int mutt_b64_decode(char * out , const char * in ) <END_VULN> { int len = 0 ; unsigned char digit4 ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : lookup data ; generated by lookups . pl ; edit there <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_LOOKUP_DATA_H_ #ifdef FLOAT_LOOKUP #define COS_LOOKUP_SZ 128 static const float COS_LOOKUP [ COS_LOOKUP_SZ + 1 ] = {
private : already_AddRefed < nsIAtom > GetNameAtom(nsIContent * aContent ) ; void EnsureChildState( ) ; <START_VULN> void doRemoveChild( ) ; <END_VULN> nsString mValue ; nsIContent * mChild ; mozilla : : dom : : Element * GetContentInternal( ) const
PRBool HasLoadFlag(PRUint32 flag ) { return (mLoadFlags & flag ) != 0 ; } PRBool IsPending( ) const { <START_VULN> return (mPump != nsnull ) ; <END_VULN> } void SetContentLength64(PRInt64 len ) ; PRInt64 ContentLength64( ) ;
if (get_vmx_mem_address(vcpu , exit_qualification , vmx_instruction_info , true , & gva ) ) return 1 ; <START_VULN> <END_VULN> kvm_write_guest_virt_system( & vcpu -> arch . emulate_ctxt , gva , & field_value , (is_long_mode(vcpu ) ? 8 : 4 ) , NULL ) ; }
while (ar -- > 0 && cp && cp < end ) { zval * retval = NULL ; <START_VULN> cp = php_parserr(cp , & answer , DNS_T_ANY , 1 , raw , & retval ) ; <END_VULN> if (retval != NULL ) { add_next_index_zval(addtl , retval ) ; }
while (an -- && cp && cp < end ) { zval * retval ; <START_VULN> cp = php_parserr(cp , & answer , type_to_fetch , store_results , raw , & retval ) ; <END_VULN> if (retval != NULL && store_results ) { add_next_index_zval(return_value , retval ) ; }
. release = ext4_release_file , . fsync = ext4_sync_file , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . fallocate = ext4_fallocate , } ;
void * arm_dma_alloc(struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { <START_VULN> pgprot_t prot = __get_dma_pgprot(attrs , pgprot_kernel ) ; <END_VULN> void * memory ; if (dma_alloc_from_coherent(dev , size , handle , & memory ) )
: clasp(clasp ) , proto(proto ) , parent(parent ) , nfixed(nfixed ) , baseFlags(baseFlags ) { } } ; inline InitialShapeEntry( ) ; inline InitialShapeEntry(const ReadBarriered < Shape > & shape , TaggedProto proto ) ; <START_VULN> inline Lookup getLookup( ) ; <END_VULN> static inline HashNumber hash(const Lookup & lookup ) ; static inline bool match(const InitialShapeEntry & key , const Lookup & lookup ) ; } ; typedef HashSet < InitialShapeEntry , InitialShapeEntry , SystemAllocPolicy > InitialShapeSet ; struct StackShape
success : spin_unlock( & ulp -> lock ) ; rcu_read_lock( ) ; <START_VULN> sem_unlock(sma ) ; <END_VULN> out : return un ; }
code FAR * next ; const unsigned short FAR * base ; const unsigned short FAR * extra ; <START_VULN> int end ; <END_VULN> unsigned short count [ MAXBITS + 1 ] ; unsigned short offs [ MAXBITS + 1 ] ; static const unsigned short lbase [ 31 ] = {
status = decode_putfh(xdr ) ; if (status ) goto out ; <START_VULN> status = decode_getacl(xdr , rqstp , & res -> acl_len ) ; <END_VULN> out : return status ;
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("Kernel Random Number Generator" ) ; <START_VULN> MODULE_ALIAS("stdrng" ) ; <END_VULN>
struct inode ; <START_VULN> extern int parse_rock_ridge_inode(struct iso_directory_record * , struct inode * ) ; <END_VULN> extern int get_rock_ridge_filename(struct iso_directory_record * , char * , struct inode * ) ; extern int isofs_name_translate(struct iso_directory_record * , char * , struct inode * ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : window functions <START_VULN> last mod : $ Id : window . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_WINDOW_ #define _V_WINDOW_ extern float * _vorbis_window_get(int n ) ; extern void _vorbis_apply_window(float * d , int * winno , long * blocksizes ,
dir == - 1 -> result <= off dir == 0 -> result == off dir == 1 -> result >= off * <START_VULN> static RFlagsAtOffset * r_flag_get_nearest_list(RFlag * f , ut64 off , int dir ) { <END_VULN> RFlagsAtOffset * flags = NULL ; RFlagsAtOffset key ; key . off = off ;
__u8 * data ) { nfcf_poll -> bit_rate = * data + + ; <START_VULN> nfcf_poll -> sensf_res_len = * data + + ; <END_VULN> pr_debug("bit_rate % d , sensf_res_len % d" , nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ;
} static struct nfs4_opendata * nfs4_opendata_alloc(struct path * path , <START_VULN> struct nfs4_state_owner * sp , int flags , <END_VULN> const struct iattr * attrs ) { struct dentry * parent = dget_parent(path -> dentry ) ;
static void cheby(float * g , int ord ) { int i , j ; g [ 0 ] *= . 5f ; for(i = 2 ; i <= ord ; i + + ) { for(j = ord ; j >= i ; j -- ) { g [ j - 2 ] -= g [ j ] ; <START_VULN> g [ j ] + = g [ j ] ; <END_VULN> } } } static int comp(const void * a , const void * b ) { return ( * (float * ) a < * (float * ) b ) - ( * (float * ) a > * (float * ) b ) ; }
fdbname , fmtId(dbtablespace ) ) ; <START_VULN> appendPQExpBuffer(buf , "connect % s" , fdbname ) ; <END_VULN> } if (binary_upgrade )
} <START_VULN> if ( ! npages ) { <END_VULN> struct kvm_memory_slot * slot ; r = - ENOMEM ;
nsCycleCollectionParticipant * helper ) = 0 ; NS_IMETHOD_(void ) NoteNextEdgeName(const char * name ) = 0 ; <START_VULN> NS_IMETHOD_(void ) NoteWeakMapping(void * map , void * key , void * val ) = 0 ; <END_VULN> enum { WANT_DEBUG_INFO = (1 << 0 ) ,
size_t datalen = prep -> datalen ; int ret = 0 ; <START_VULN> if (test_bit(KEY_FLAG_NEGATIVE , & key -> flags ) ) <END_VULN> return - ENOKEY ; if (datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ;
if (i < pos && i + insn -> off + 1 > pos ) insn -> off + = delta ; <START_VULN> else if (i > pos && i + insn -> off + 1 < pos ) <END_VULN> insn -> off -= delta ; } }
transmit_response_with_date(p , "200 OK" , req ) ; manager_event(EVENT_FLAG_SYSTEM , "PeerStatus" , "ChannelType : SIPrPeer : SIP % srPeerStatus : RegisteredrAddress : % sr" , peer -> name , ast_sockaddr_stringify(addr ) ) ; peer -> lastmsgssent = - 1 ; res = 0 ; break ; } ao2_unlock(peer ) ; } } <START_VULN> if ( ! peer && sip_cfg . alwaysauthreject ) { <END_VULN> transmit_response(p , "100 Trying" , req ) ; sched_yield( ) ; } if ( ! res ) { ast_devstate_changed(AST_DEVICE_UNKNOWN , "SIP % s" , peer -> name ) ; } if (res < 0 ) { switch (res ) {
if (reserve ) { hugetlb_acct_memory(h , - reserve ) ; <START_VULN> hugetlb_put_quota(vma -> vm_file -> f_mapping , reserve ) ; <END_VULN> } } }
1 , - 533200896 , 1611661312 , 4 , 0 , partial_quantlist1 , NULL , NULL , NULL , 0 } ; static float test4_result [ ] = { - 3 , - 3 , - 3 , 4 , - 3 , - 3 , - 1 , - 3 , - 3 , - 3 , 4 , - 3 , 4 , 4 , - 3 , - 1 , 4 , - 3 , <START_VULN> - 3 , - 1 , - 3 , 4 , - 1 , - 3 , - 1 , - 1 , - 3 , <END_VULN> - 3 , - 3 , 4 , 4 , - 3 , 4 , - 1 , - 3 , 4 , - 3 , 4 , 4 , 4 , 4 , 4 , - 1 , 4 , 4 , - 3 , - 1 , 4 , 4 , - 1 , 4 , - 1 , - 1 , 4 , - 3 , - 3 , - 1 , 4 , - 3 , - 1 , - 1 , - 3 , - 1 , - 3 , 4 , - 1 , 4 , 4 , - 1 , - 1 , 4 , - 1 , - 3 , - 1 , - 1 , 4 , - 1 , - 1 , - 1 , - 1 , - 1 } ;
nsLayoutUtils : : SurfaceFromElementResult SurfaceFromElement(const dom : : NonNull < ElementType > & aElement ) { return SurfaceFromElement(aElement . get( ) ) ; } nsresult SurfaceFromElementResultToImageSurface(nsLayoutUtils : : SurfaceFromElementResult & res , gfxImageSurface ** imageOut , WebGLTexelFormat * format ) ; <START_VULN> void CopyTexSubImage2D_base(WebGLenum target , <END_VULN> WebGLint level , WebGLenum internalformat , WebGLint xoffset , WebGLint yoffset , WebGLint x , WebGLint y , WebGLsizei width , WebGLsizei height ,
#ifdef ZEND_WIN32 <START_VULN> static inline zend_ulong realpath_cache_key(const char * path , int path_len ) <END_VULN> { register zend_ulong h ; char * bucket_key_start = tsrm_win32_get_path_sid_key(path ) ;
} } else { <START_VULN> for (plane = 0 ; plane < 4 && in -> data [ plane ] ; plane + + ) { <END_VULN> int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ; int hsub = plane == 1 || plane == 2 ? s -> hsub : 0 ; int h = FF_CEIL_RSHIFT(inlink -> h , vsub ) ;
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION ("Twofish Cipher Algorithm" ) ; <START_VULN> MODULE_ALIAS("twofish" ) ; <END_VULN>
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic shared codebook operations <START_VULN> last mod : $ Id : sharedbook . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < math . h > #include < string . h > #include < oggogg . h > #include "os . h"
#ifndef imgStatusTracker_h__ #define imgStatusTracker_h__ class imgDecoderObserver ; class imgIContainer ; <START_VULN> class imgRequestProxy ; <END_VULN> class imgStatusNotifyRunnable ; class imgRequestNotifyRunnable ; class imgStatusTrackerObserver ; class nsIRunnable ; #include "mozillaRefPtr . h" #include "mozillaWeakPtr . h" #include "nsCOMPtr . h" #include "nsTObserverArray . h" #include "nsThreadUtils . h" #include "nsRect . h" namespace mozilla { namespace image { class Image ; struct ImageStatusDiff {
ASSERT((entry -> flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote(leaf , args -> index ) ; name_rmt -> valueblk = cpu_to_be32(args -> rmtblkno ) ; <START_VULN> name_rmt -> valuelen = cpu_to_be32(args -> valuelen ) ; <END_VULN> xfs_trans_log_buf(args -> trans , bp , XFS_DA_LOGRANGE(leaf , name_rmt , sizeof( * name_rmt ) ) ) ; }
Z_PARAM_PATH(filename , filename_len ) ZEND_PARSE_PARAMETERS_END( ) ; <START_VULN> php_stat(filename , (php_stat_len ) filename_len , funcnum , return_value ) ; <END_VULN> }
a -> y2a = y2a * weight + y2b ; a -> xya = xya * weight + xyb ; a -> an = na * weight + nb ; } return(na ) ; } <START_VULN> static void fit_line(lsfit_acc * a , int fits , int * y0 , int * y1 ) { <END_VULN> long x = 0 , y = 0 , x2 = 0 , y2 = 0 , xy = 0 , an = 0 , i ; long x0 = a [ 0 ] . x0 ; long x1 = a [ fits - 1 ] . x1 ; for(i = 0 ; i < fits ; i + + ) { x + = a [ i ] . xa ; y + = a [ i ] . ya ; x2 + = a [ i ] . x2a ;
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("Deflate Compression Algorithm for IPCOMP" ) ; MODULE_AUTHOR("James Morris < jmorris@intercode . com . au > " ) ; <START_VULN> <END_VULN>
struct list_headlist ; struct inode * inode ; unsigned intflag ; <START_VULN> interror ; <END_VULN> loff_toffset ; ssize_tsize ; struct work_structwork ;
efree(result ) ; } } <START_VULN> <END_VULN> zend_hash_move_forward(Z_ARRVAL_PP(subject ) ) ; } } else {
return - EINVAL ; if ((creds -> pid == task_tgid_vnr(current ) || <START_VULN> ns_capable(current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && <END_VULN> ((uid_eq(uid , cred -> uid ) || uid_eq(uid , cred -> euid ) || uid_eq(uid , cred -> suid ) ) || nsown_capable(CAP_SETUID ) ) && ((gid_eq(gid , cred -> gid ) || gid_eq(gid , cred -> egid ) ||
#include "vmRegExpObject . h" #include "jsscopeinlines . h" namespace js { inline Bindings : : Bindings(JSContext * cx ) <START_VULN> : lastBinding(NULL ) , nargs(0 ) , nvars(0 ) , nupvars(0 ) <END_VULN> { } inline void Bindings : : transfer(JSContext * cx , Bindings * bindings ) { JS_ASSERT( ! lastBinding ) ; JS_ASSERT( ! bindings -> lastBinding || ! bindings -> lastBinding -> inDictionary( ) ) ;
int mi_repair(MI_CHECK * param , register MI_INFO * info , <START_VULN> char * name , int rep_quick ) <END_VULN> { int error , got_error ; ha_rows start_records , new_header_length ;
static inline size_t GetPSDRowSize(Image * image ) { if (image -> depth == 1 ) <START_VULN> return((image -> columns + 7 ) 8 ) ; <END_VULN> else return(image -> columns * GetPSDPacketSize(image ) ) ; }
private int cdf_file_summary_info(struct magic_set * ms , const cdf_header_t * h , <START_VULN> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <END_VULN> { cdf_summary_info_header_t si ; cdf_property_info_t * info ;
if (nb_components <= 0 || nb_components > MAX_COMPONENTS ) return - 1 ; if (s -> interlaced && (s -> bottom_field == ! s -> interlace_polarity ) ) { if (nb_components != s -> nb_components ) { av_log(s -> avctx , AV_LOG_ERROR , "nb_components changing in interlaced picture" ) ; return AVERROR_INVALIDDATA ; } } <START_VULN> if (s -> ls && ! (s -> bits <= 8 || nb_components == 1 ) ) { <END_VULN> avpriv_report_missing_feature(s -> avctx , "JPEG - LS that is not <= 8 " "bitscomponent or 16 - bit gray" ) ; return AVERROR_PATCHWELCOME ; } s -> nb_components = nb_components ; s -> h_max = 1 ; s -> v_max = 1 ; memset(h_count , 0 , sizeof(h_count ) ) ; memset(v_count , 0 , sizeof(v_count ) ) ;
ioc -> aic -> exit(ioc -> aic ) ; cfq_exit(ioc ) ; <START_VULN> put_io_context(ioc ) ; <END_VULN> } } struct io_context * alloc_io_context(gfp_t gfp_flags , int node )
0 . 9999667820F , 0 . 9999720773F , 0 . 9999767136F , 0 . 9999807479F , 0 . 9999842344F , 0 . 9999872249F , 0 . 9999897688F , 0 . 9999919127F , 0 . 9999937009F , 0 . 9999951749F , 0 . 9999963738F , 0 . 9999973342F , 0 . 9999980900F , 0 . 9999986724F , 0 . 9999991103F , 0 . 9999994297F , 0 . 9999996543F , 0 . 9999998049F , 0 . 9999999000F , 0 . 9999999552F , 0 . 9999999836F , 0 . 9999999957F , 0 . 9999999994F , 1 . 0000000000F , } ; <START_VULN> static float vwin2048 [ 1024 ] = { <END_VULN> 0 . 0000009241F , 0 . 0000083165F , 0 . 0000231014F , 0 . 0000452785F , 0 . 0000748476F , 0 . 0001118085F , 0 . 0001561608F , 0 . 0002079041F , 0 . 0002670379F , 0 . 0003335617F , 0 . 0004074748F , 0 . 0004887765F , 0 . 0005774661F , 0 . 0006735427F , 0 . 0007770054F , 0 . 0008878533F , 0 . 0010060853F , 0 . 0011317002F , 0 . 0012646969F , 0 . 0014050742F , 0 . 0015528307F , 0 . 0017079650F , 0 . 0018704756F , 0 . 0020403610F , 0 . 0022176196F , 0 . 0024022497F , 0 . 0025942495F , 0 . 0027936173F , 0 . 0030003511F , 0 . 0032144490F , 0 . 0034359088F , 0 . 0036647286F ,
ogg_sync_wrote( & oy , next - buf ) ; while(1 ) { int ret = ogg_sync_pageout( & oy , & og_de ) ; if(ret == 0 ) break ; if(ret < 0 ) continue ; <START_VULN> fprintf(stderr , "( % ld ) , " , pageout ) ; <END_VULN> check_page(data + deptr , headers [ pageout ] , & og_de ) ; deptr + = og_de . body_len ; pageout + + ; ogg_stream_pagein( & os_de , & og_de ) ;
mutt_str_strfcpy(buf , "mailboxes "" , sizeof(buf ) ) ; mutt_account_tourl( & idata -> conn -> account , & url ) ; <START_VULN> imap_quote_string(errstr , sizeof(errstr ) , list . name ) ; <END_VULN> url . path = errstr + 1 ; url . path [ strlen(url . path ) - 1 ] = '0' ; if (mutt_str_strcmp(url . user , ImapUser ) == 0 )
int do_adjtimex(struct timex * txc ) { <START_VULN> long mtemp , save_adjust , rem ; <END_VULN> s64 freq_adj ; int result ;
static int hns_gmac_get_sset_count(int stringset ) { <START_VULN> if (stringset == ETH_SS_STATS ) <END_VULN> return ARRAY_SIZE(g_gmac_stats_string ) ; return 0 ;
#define MAJOR_VERSION 0 #define MINOR_VERSION 0 #define BUILD_VERSION 0 <START_VULN> #define BUILD_REVISION 740<END_VULN> #define STRINGIFY(x ) #x #define MACRO_STRINGIFY(x ) STRINGIFY(x ) #define REVISION_STRING MACRO_STRINGIFY(BUILD_REVISION ) #define VERSION_STRING MACRO_STRINGIFY(MAJOR_VERSION ) " . " MACRO_STRINGIFY(MINOR_VERSION ) " . " MACRO_STRINGIFY(BUILD_VERSION ) " . " MACRO_STRINGIFY(BUILD_REVISION )
idx = ((r -> CRm & 3 ) << 3 ) | (r -> Op2 & 7 ) ; } else { <START_VULN> BUG( ) ; <END_VULN> } if ( ! pmu_counter_idx_valid(vcpu , idx ) )
extern intip_build_and_send_pkt(struct sk_buff * skb , struct sock * sk , __be32 saddr , __be32 daddr , <START_VULN> struct ip_options * opt ) ; <END_VULN> extern intip_rcv(struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) ; extern intip_local_deliver(struct sk_buff * skb ) ;
static char efbuf [ 100 ] ; my_regex_t re ; <START_VULN> sprintf(efbuf , "REG_ % s" , name ) ; <END_VULN> assert(strlen(efbuf ) < sizeof(efbuf ) ) ; re . re_endp = efbuf ; (void ) my_regerror(REG_ATOI , & re , efbuf , sizeof(efbuf ) ) ;
#define OFFT_MAX ~ ((off_t ) 1 << (sizeof(off_t ) * 8 - 1 ) ) #define LINELEN 256 <START_VULN> #define BUFSIZE (1024 * 1024 ) <END_VULN> #define DIFFPAGESIZE 4096 #define F_READONLY 1 #define F_MULTIFILE 2
if (msr -> request_content_length == - 1 ) { char * transfer_encoding = (char * ) apr_table_get(msr -> request_headers , "Transfer - Encoding" ) ; <START_VULN> if ((transfer_encoding != NULL ) && (strstr(transfer_encoding , "chunked" ) != NULL ) ) { <END_VULN> msr -> reqbody_should_exist = 1 ; msr -> reqbody_chunked = 1 ; }
h -> is_streamed = 0 ; } else if ( ! av_strcasecmp(tag , "Transfer - Encoding" ) && ! av_strncasecmp(p , "chunked" , 7 ) ) { <START_VULN> s -> filesize = - 1 ; <END_VULN> s -> chunksize = 0 ; } else if ( ! av_strcasecmp(tag , "WWW - Authenticate" ) ) { ff_http_auth_handle_header( & s -> auth_state , tag , p ) ;
. open = ftrace_graph_open , . read = seq_read , . write = ftrace_graph_write , . release = ftrace_graph_release , <START_VULN> . llseek = seq_lseek , <END_VULN> } ; #endif
nsTextFrame * nextContinuation = static_cast < nsTextFrame * > (aPrevInFlow -> GetNextContinuation( ) ) ; #endif SetPrevInFlow(aPrevInFlow ) ; aPrevInFlow -> SetNextInFlow(this ) ; nsTextFrame * prev = static_cast < nsTextFrame * > (aPrevInFlow ) ; mContentOffset = prev -> GetContentOffset( ) + prev -> GetContentLengthHint( ) ; <START_VULN> NS_ASSERTION(mContentOffset < aContent -> GetText( ) -> GetLength( ) , <END_VULN> "Creating ContinuingTextFrame , but there is no more content" ) ; if (prev -> GetStyleContext( ) != GetStyleContext( ) ) { prev -> ClearTextRun( ) ; } else { mTextRun = prev -> GetTextRun( ) ; }
#define base64val(c ) Index64 [ (unsigned int ) (c ) ] size_t mutt_b64_encode(char * out , const char * cin , size_t len , size_t olen ) ; <START_VULN> int mutt_b64_decode(char * out , const char * in ) ; <END_VULN> #endif
unsigned char cmd = * delta + + ; if (cmd & 0x80 ) { <START_VULN> size_t off = 0 , len = 0 ; <END_VULN> #define ADD_DELTA(o , shift ) { if (delta < delta_end ) (o ) |= ((unsigned ) * delta + + << shift ) ; else goto fail ; } if (cmd & 0x01 ) ADD_DELTA(off , 0UL ) ;
if (current -> flags & PF_RANDOMIZE ) random_factor = arch_mmap_rnd( ) ; <START_VULN> mm -> mmap_legacy_base = mmap_legacy_base(random_factor ) ; <END_VULN> if (mmap_is_legacy( ) ) { mm -> mmap_base = mm -> mmap_legacy_base ;
if (r == 0 ) { num_records = oggplay_callback_info_prepare(me , & info ) ; for (i = 0 ; i < me -> num_tracks ; i + + ) { me -> decode_data [ i ] -> active = 0 ; <START_VULN> me -> active_tracks = 0 ; <END_VULN> } if (info != NULL ) { me -> callback (me , num_records , info , me -> callback_user_ptr ) ; oggplay_callback_info_destroy(me , info ) ; } decoder -> stream_info = OGGPLAY_STREAM_UNINITIALISED ;
struct rf_tech_specific_params_nfcb_poll * nfcb_poll , __u8 * data ) { <START_VULN> nfcb_poll -> sensb_res_len = * data + + ; <END_VULN> pr_debug("sensb_res_len % d" , nfcb_poll -> sensb_res_len ) ;
} if ((flags & EXT4_GET_BLOCKS_CONVERT ) ) { <START_VULN> ret = ext4_convert_unwritten_extents_endio(handle , inode , <END_VULN> path ) ; if (ret >= 0 ) { ext4_update_inode_fsync_trans(handle , inode , 1 ) ;
no_empty = flags & PREG_SPLIT_NO_EMPTY ; delim_capture = flags & PREG_SPLIT_DELIM_CAPTURE ; offset_capture = flags & PREG_SPLIT_OFFSET_CAPTURE ; <START_VULN> <END_VULN> if (limit_val == 0 ) { limit_val = - 1 ; }
gss_cred_usage_t , gss_OID_set * ) ; static void release_spnego_ctx(spnego_gss_ctx_id_t * ) ; static void check_spnego_options(spnego_gss_ctx_id_t ) ; <START_VULN> static spnego_gss_ctx_id_t create_spnego_ctx(void ) ; <END_VULN> static int put_mech_set(gss_OID_set mechSet , gss_buffer_t buf ) ; static int put_input_token(unsigned char ** , gss_buffer_t , unsigned int ) ; static int put_mech_oid(unsigned char ** , gss_OID_const , unsigned int ) ;
} <START_VULN> snprintf_func (ecmd , TESTBUFSIZE , " % s % s - f % s % s % s % s % s % s % s" , <END_VULN> program_name , test_softcfg_str , has_adler32 ? "" : " - n " , has_apphead ? " - A = encode_apphead " : " - A = " ,
} n = EXTRACT_32BITS( & prep -> pp_n ) ; ps = (const struct pgstate * ) (prep + 1 ) ; <START_VULN> while ( -- n >= 0 && ! ND_TTEST( * ps ) ) { <END_VULN> const struct id_off * io , * ie ; char c = ' < ' ;
EXT4_HAS_INCOMPAT_FEATURE(sb , EXT4_FEATURE_INCOMPAT_RECOVER ) ) { ext4_msg(sb , KERN_ERR , "required journal recovery " "suppressed and not mounted read - only" ) ; <START_VULN> goto failed_mount4 ; <END_VULN> } else { clear_opt(sbi -> s_mount_opt , DATA_FLAGS ) ; set_opt(sbi -> s_mount_opt , WRITEBACK_DATA ) ;
init_side (client , & client -> client_side ) ; init_side (client , & client -> bus_side ) ; <START_VULN> client -> auth_end_offset = AUTH_END_INIT_OFFSET ; <END_VULN> client -> rewrite_reply = g_hash_table_new_full (g_direct_hash , g_direct_equal , NULL , g_object_unref ) ; client -> get_owner_reply = g_hash_table_new_full (g_direct_hash , g_direct_equal , NULL , g_free ) ; client -> unique_id_policy = g_hash_table_new_full (g_str_hash , g_str_equal , g_free , NULL ) ;
pkiDebug("found kdcPkId in AS REQ" ) ; is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL , & p , (int ) pkid_len ) ; if (is == NULL ) <START_VULN> goto cleanup ; <END_VULN> status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert ) , is -> issuer ) ; if ( ! status ) {
} } } <START_VULN> gdCtxPrintf(out , " } ; " ) ; <END_VULN> }
case LC_LOAD_WEAK_DYLIB : sdb_set (bin -> kv , sdb_fmt (0 , "mach0_cmd_ % d . cmd" , i ) , "load_dylib" , 0 ) ; bin -> nlibs + + ; <START_VULN> if ( ! parse_dylib(bin , off ) ) { <END_VULN> bprintf ("Cannot parse dylib" ) ; bin -> nlibs -- ; return false ;
void CVE_2011_3003_CopySubDataIfElementArray(GLuint byteOffset , GLuint byteLength , const void * data ) { <START_VULN> if (mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER ) { <END_VULN> memcpy((void * ) (size_t(mData ) + byteOffset ) , data , byteLength ) ; } }
} else { int plane ; <START_VULN> for (plane = 0 ; plane < 4 && in -> data [ plane ] ; plane + + ) { <END_VULN> uint8_t * dst = out -> data [ plane ] ; const uint8_t * src = in -> data [ plane ] ; const float * fmap = s -> fmap ;
REG("make - it - fail" , S_IRUGO | S_IWUSR , proc_fault_inject_operations ) , #endif #ifdef CONFIG_TASK_IO_ACCOUNTING <START_VULN> INF("io" , S_IRUGO , proc_tid_io_accounting ) , <END_VULN> #endif #ifdef CONFIG_HARDWALL INF("hardwall" , S_IRUGO , proc_pid_hardwall ) ,
MODULE_AUTHOR("Clay Haapala < chaapala@cisco . com > " ) ; MODULE_DESCRIPTION("CRC32c (Castagnoli ) calculations wrapper for libcrc32c" ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("crc32c" ) ; <END_VULN> MODULE_SOFTDEP("pre : crc32c" ) ;
NULL , #else iakerb_gss_export_sec_context , <START_VULN> NULL , <END_VULN> #endif krb5_gss_inquire_cred_by_mech , krb5_gss_inquire_names_for_mech ,
define_sid = 0 ; } <START_VULN> if ( ! PS(id ) && <END_VULN> zend_hash_find( & EG(symbol_table ) , "_GET" , sizeof("_GET" ) , (void ** ) & data ) == SUCCESS && Z_TYPE_PP(data ) == IS_ARRAY &&
PRUint32 mPreferredWidth ; PRUint32 mPreferredHeight ; private : PRBool IsVisible( ) ; void GetToplevelWidget(GtkWidget ** aWidget ) ; GtkWidget * GetMozContainerWidget( ) ; <START_VULN> void GetContainerWindow(nsWindow ** aWindow ) ; <END_VULN> void SetUrgencyHint(GtkWidget * top_window , PRBool state ) ; void * SetupPluginPort(void ) ; nsresult SetWindowIconList(const nsTArray < nsCString > & aIconList ) ; void SetDefaultIcon(void ) ; void InitButtonEvent(nsMouseEvent & aEvent , GdkEventButton * aGdkEvent ) ; PRBool DispatchCommandEvent(nsIAtom * aCommand ) ; GtkWidget * mShell ;
atomic_dec( & key -> user -> nkeys ) ; atomic_inc( & newowner -> nkeys ) ; <START_VULN> if (test_bit(KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <END_VULN> atomic_dec( & key -> user -> nikeys ) ; atomic_inc( & newowner -> nikeys ) ; }
<START_VULN> static int CVE_2014_5472_isofs_read_inode(struct inode * inode ) <END_VULN> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB(sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE(inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ;
{ const char * header ; uint head_length , counter = 0 ; <START_VULN> char query [ 255 ] , rows [ NAME_LEN ] , fields [ 16 ] ; <END_VULN> MYSQL_FIELD * field ; MYSQL_RES * result ; MYSQL_ROW row , rrow ;
get_page(netbk -> mmap_pages [ pending_idx ] ) ; <START_VULN> xen_netbk_idx_release(netbk , pending_idx ) ; <END_VULN> } }
mParent = aTarget ; } virtual nsIDOMEventTarget * GetParentTarget( ) { return mParent ; } NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsWindowRoot , nsIDOMEventTarget ) protected : <START_VULN> nsPIDOMWindow * mWindow ; <END_VULN> nsRefPtr < nsEventListenerManager > mListenerManager ; nsCOMPtr < nsIDOMNode > mPopupNode ; nsCOMPtr < nsIDOMEventTarget > mParent ; } ;
dopt -> optlen + = optlen ; } if (sopt -> srr ) { <START_VULN> unsigned char * start = sptr + sopt -> srr ; <END_VULN> __be32 faddr ; optlen = start [ 1 ] ;
if ( ! FIELD_PICTURE(h ) || h -> picture_structure == last_pic_structure ) { <START_VULN> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <END_VULN> ff_thread_report_progress( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; }
#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if (op - m_pos >= 8 ) { unsigned char * oe = op + t ; <START_VULN> if (likely(HAVE_OP(t + 15 ) ) ) { <END_VULN> do { COPY8(op , m_pos ) ; op + = 8 ;
mTrans -> mConnection -> SetSecurityCallbacks(mCallbacks ) ; return NS_OK ; } private : nsRefPtr < nsHttpTransaction > mTrans ; nsCOMPtr < nsIInterfaceRequestor > mCallbacks ; } ; <START_VULN> Mutex mCallbacksLock ; <END_VULN> nsCOMPtr < nsIInterfaceRequestor > mCallbacks ; nsCOMPtr < nsITransportEventSink > mTransportSink ; nsCOMPtr < nsIEventTarget > mConsumerTarget ; nsCOMPtr < nsISupports > mSecurityInfo ; nsCOMPtr < nsIAsyncInputStream > mPipeIn ; nsCOMPtr < nsIAsyncOutputStream > mPipeOut ; nsCOMPtr < nsILoadGroupConnectionInfo > mLoadGroupCI ;
get_trust_val(trust , valstr , sizeof valstr ) ; PR_LOG(modlog , 4 , (fmt_s_s_d , atype , valstr , attr -> ulValueLen ) ) ; break ; } case CKA_KEY_TYPE : if (attr -> ulValueLen > 0 && attr -> pValue ) { CK_KEY_TYPE keyType = * ((CK_KEY_TYPE * ) attr -> pValue ) ; <START_VULN> get_obj_class(keyType , valstr , sizeof valstr ) ; <END_VULN> PR_LOG(modlog , 4 , (fmt_s_s_d , atype , valstr , attr -> ulValueLen ) ) ; break ; } case CKA_LABEL : case CKA_NETSCAPE_EMAIL : case CKA_NETSCAPE_URL : if (attr -> ulValueLen > 0 && attr -> pValue ) {
break ; case 0xe9 : case 0xeb : <START_VULN> jmp_rel(ctxt , ctxt -> src . val ) ; <END_VULN> ctxt -> dst . type = OP_NONE ; break ; case 0xf4 :
return cnt ; } <START_VULN> struct inet_peer * inet_getpeer(struct inetpeer_addr * daddr , int create ) <END_VULN> { struct inet_peer __rcu ** stack [ PEER_MAXDEPTH ] , ** * stackptr ; struct inet_peer_base * base = family_to_base(daddr -> family ) ;
mode_t curumsk = umask(022 ) ; umask(curumsk ) ; <START_VULN> if (fchmod(fileno(fp ) , 0666 - curumsk ) < 0 ) { <END_VULN> err_status = "create_chmod" ; return - 1 ; }
nsIPrincipal * originPrincipal , nsISupports * context , const nsACString & mimeType , nsISupports * extra , int16_t * decision , nsIContentPolicy * policyService = nullptr , nsIScriptSecurityManager * aSecMan = nullptr ) { <START_VULN> CHECK_PRINCIPAL ; <END_VULN> if (policyService ) { CHECK_CONTENT_POLICY_WITH_SERVICE(ShouldLoad , policyService ) ; } CHECK_CONTENT_POLICY(ShouldLoad ) ; }
SCM_TIMESTAMPING , sizeof(tss ) , & tss ) ; if (skb_is_err_queue(skb ) && skb -> len && <START_VULN> (sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <END_VULN> put_cmsg(msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; }
if (err == - EINPROGRESS ) return NF_STOLEN ; <START_VULN> return NF_ACCEPT ; <END_VULN> } static struct nf_hook_ops ipv6_defrag_ops [ ] = {
First : no IPv4 options . <START_VULN> newinet -> opt = NULL ; <END_VULN> newnp -> ipv6_fl_list = NULL ;
} if ( ! dump ) return CL_CLEAN ; <START_VULN> cli_dbgmsg("cli_pdf : dumping obj % u % u" , obj -> id >> 8 , obj -> id ) ; <END_VULN> snprintf(fullname , sizeof(fullname ) , " % s"PATHSEP"pdf % 02u" , pdf -> dir , pdf -> files + + ) ; fout = open(fullname , O_RDWR | O_CREAT | O_EXCL | O_TRUNC | O_BINARY , 0600 ) ; if (fout < 0 ) {
if (IsUnpromptedElevation(unpromptedElevation ) ) { useService = ! unpromptedElevation ; } } if (useService ) { WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; if (CalculateRegistryPathFromFilePath(gInstallDirPath , maintenanceServiceKey ) ) { <START_VULN> HKEY baseKey ; <END_VULN> if (RegOpenKeyExW(HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS ) { RegCloseKey(baseKey ) ; } else { useService = testOnlyFallbackKeyExists ; if ( ! useService ) { lastFallbackError = FALLBACKKEY_NOKEY_ERROR ; }
void * ipc_rcu_alloc(int size ) ; <START_VULN> void ipc_rcu_getref(void * ptr ) ; <END_VULN> void ipc_rcu_putref(void * ptr ) ; struct kern_ipc_perm * ipc_lock(struct ipc_ids * , int ) ;
boolneedquotes ; <START_VULN> needquotes = false ; <END_VULN> for (s = str ; * s ; s + + ) { if ( ! (( * s >= 'a' && * s <= 'z' ) || ( * s >= 'A' && * s <= 'Z' ) ||
return bdev ; fail : <START_VULN> ext3_msg(sb , "error : failed to open journal device % s : % ld" , <END_VULN> __bdevname(dev , b ) , PTR_ERR(bdev ) ) ; return NULL ;
int midi_synth_load_patch(int dev , int format , const char __user * addr , <START_VULN> int offs , int count , int pmgr_flag ) <END_VULN> { int orig_dev = synth_devs [ dev ] -> midi_dev ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : random psychoacoustics (not including preecho ) <START_VULN> last mod : $ Id : psy . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_PSY_H_ #define _V_PSY_H_ #include "smallft . h" #include "backends . h"
if (event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr(regs , & data . addr ) ; <START_VULN> if (perf_event_overflow(event , nmi , & data , regs ) ) <END_VULN> power_pmu_stop(event , 0 ) ; } }
goto err ; } <START_VULN> len = file ? file -> size : 4096 ; <END_VULN> p = realloc( * data , len ) ; if ( ! p ) { goto err ;
__be32 spi ; spi = xfrm6_tunnel_spi_lookup((xfrm_address_t * ) & iph -> saddr ) ; <START_VULN> return xfrm6_rcv_spi(skb , spi ) ; <END_VULN> } static int xfrm6_tunnel_err(struct sk_buff * skb , struct inet6_skb_parm * opt ,
<START_VULN> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <END_VULN> ff_thread_report_progress( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; }
oggpack_write(opb , 0 , 32 ) ; } } } oggpack_write(opb , 1 , 1 ) ; return(0 ) ; } <START_VULN> <END_VULN> static int _vorbis_pack_books(oggpack_buffer * opb , vorbis_info * vi ) { codec_setup_info * ci = vi -> codec_setup ; int i ; if( ! ci ) return(OV_EFAULT ) ; oggpack_write(opb , 0x05 , 8 ) ; _v_writestring(opb , "vorbis" , 6 ) ;
cdf_unpack_summary_info(const cdf_stream_t * sst , const cdf_header_t * h , cdf_summary_info_header_t * ssi , cdf_property_info_t ** info , size_t * count ) { <START_VULN> size_t i , maxcount ; <END_VULN> const cdf_summary_info_header_t * si = CAST(const cdf_summary_info_header_t * , sst -> sst_tab ) ; const cdf_section_declaration_t * sd =
RETVAL_BOOL(phar_open_from_filename(fname , fname_len , alias , alias_len , REPORT_ERRORS , NULL , & error TSRMLS_CC ) == SUCCESS ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; } }
int ip6_find_1stfragopt(struct sk_buff * skb , u8 ** nexthdr ) { <START_VULN> u16 offset = sizeof(struct ipv6hdr ) ; <END_VULN> unsigned int packet_len = skb_tail_pointer(skb ) - skb_network_header(skb ) ; int found_rhdr = 0 ;
efree(error ) ; goto valid_alias ; } <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; RETURN_FALSE ; }
MODULE_PARM_DESC(ksym , "Kernel symbol to monitor ; this module will report any" " write operations on the kernel symbol" ) ; <START_VULN> static void sample_hbp_handler(struct perf_event * bp , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) {
virtual bool IsTransportSeekable( ) = 0 ; <START_VULN> static MediaResource * Create(MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <END_VULN> virtual nsresult Open(nsIStreamListener ** aStreamListener ) = 0 ;
size_t len ; if (level >= ms -> c . len ) { <START_VULN> len = (ms -> c . len + = 20 ) * sizeof( * ms -> c . li ) ; <END_VULN> ms -> c . li = CAST(struct level_info * , (ms -> c . li == NULL ) ? malloc(len ) : realloc(ms -> c . li , len ) ) ;
parent_inode , & key , BTRFS_FT_DIR , index ) ; <START_VULN> BUG_ON(ret == - EEXIST ) ; <END_VULN> if (ret ) { btrfs_abort_transaction(trans , root , ret ) ; goto fail ; commit 9c52057c698fb96f8f07e7a4bcf4801a092bda89 Author : Chris Mason < chris . mason@fusionio . com > Date : Mon Dec 17 14 : 26 : 57 2012 - 0500 Btrfs : fix hash overflow handling The handling for directory crc hash overflows was fairly obscure , split_leaf returns EOVERFLOW when we try to extend the item and that is supposed to bubble up to userland . For a while it did so , but along the way we added better handling of errors and forced the FS readonly if we hit IO errors during the directory insertion . Along the way , we started testing only for EEXIST and the EOVERFLOW case was dropped . The end result is that we may force the FS readonly if we catch a directory hash bucket overflow . This fixes a few problem spots . First I add tests for EOVERFLOW in the places where we can safely just return the error up the chain . btrfs_rename is harder though , because it tries to insert the new directory item only after it has already unlinked anything the rename was going to overwrite . Rather than adding very complex logic , I added a helper to test for the hash overflow case early while it is still safe to bail out . Snapshot and subvolume creation had a similar problem , so they are using the new helper now too . Signed - off - by : Chris Mason < chris . mason@fusionio . com > Reported - by : Pascal Junod < pascal@junod . info >
regs -> loadrs = 0 ; regs -> r8 = get_dumpable(current -> mm ) ; regs -> r12 = new_sp - 16 ; <START_VULN> if (unlikely( ! get_dumpable(current -> mm ) ) ) { <END_VULN> int get_dumpable(struct mm_struct * mm ) { return __get_dumpable(mm -> flags ) ;
MODULE_PARM_DESC(dbg , "Boolean to enable debugging (01 == offon ) " ) ; module_init(prng_mod_init ) ; module_exit(prng_mod_fini ) ; <START_VULN> MODULE_ALIAS("stdrng" ) ; <END_VULN>
sp = regs -> gpr [ 1 ] ; perf_callchain_store(entry , next_ip ) ; <START_VULN> for ( ; ; ) { <END_VULN> fp = (unsigned long __user * ) sp ; if ( ! valid_user_sp(sp , 1 ) || read_user_stack_64(fp , & next_sp ) ) return ;
less strict that the _ve_envelope_search , the search is not run if we only use one block size * } <START_VULN> <END_VULN> _vorbis_block_ripcord(vb ) ; vb -> lW = v -> lW ; vb -> W = v -> W ; vb -> nW = v -> nW ;
void mdct_clear(mdct_lookup * l ) { if(l ) { if(l -> trig ) _ogg_free(l -> trig ) ; if(l -> bitrev ) _ogg_free(l -> bitrev ) ; memset(l , 0 , sizeof( * l ) ) ; } } <START_VULN> STIN void mdct_bitreverse(mdct_lookup * init , <END_VULN> DATA_TYPE * x ) { int n = init -> n ; int * bit = init -> bitrev ; DATA_TYPE * w0 = x ; DATA_TYPE * w1 = x = w0 + (n >> 1 ) ; DATA_TYPE * T = init -> trig + n ; do {
} } else { if (state -> space ) ruby_xfree(state -> space ) ; <START_VULN> state -> space = strdup(RSTRING_PTR(space ) ) ; <END_VULN> state -> space_len = len ; } return Qnil ;
{ FT_ASSERT( cur [ 0 ] -> clazz ) ; <START_VULN> if ( cur [ 0 ] -> clazz -> get_interface ) <END_VULN> { result = cur [ 0 ] -> clazz -> get_interface( cur [ 0 ] , service_id ) ; if ( result != NULL )
{ void * pointer ; <START_VULN> if ( ! handle ) <END_VULN> return NULL ; pointer = (void * ) ~ ((size_t ) handle -> dwLower ) ;
JSObject * argv6 = JSVAL_TO_OBJECT(argv [ 6 ] ) ; jsval js_width , js_height , js_data ; JS_GetProperty(cx , argv6 , "width" , & js_width ) ; JS_GetProperty(cx , argv6 , "height" , & js_height ) ; JS_GetProperty(cx , argv6 , "data" , & js_data ) ; if (js_width == JSVAL_VOID || js_height == JSVAL_VOID || <START_VULN> js_data == JSVAL_VOID ) <END_VULN> { xpc_qsThrowBadArg(cx , NS_ERROR_FAILURE , vp , 6 ) ; return JS_FALSE ; } int32_t int_width , int_height ; JSObject * obj_data = JSVAL_TO_OBJECT(js_data ) ; if ( ! JS_ValueToECMAInt32(cx , js_width , & int_width ) || ! JS_ValueToECMAInt32(cx , js_height , & int_height ) )
. read_iter = xfs_file_read_iter , . write_iter = xfs_file_write_iter , . splice_read = xfs_file_splice_read , <START_VULN> . splice_write = xfs_file_splice_write , <END_VULN> . unlocked_ioctl = xfs_file_ioctl , #ifdef CONFIG_COMPAT . compat_ioctl = xfs_file_compat_ioctl ,
alternative_input( "1 : " XRSTOR , <START_VULN> "1 : " XRSTORS , <END_VULN> X86_FEATURE_XSAVES , "D" (fx ) , "m" ( * fx ) , "a" (lmask ) , "d" (hmask ) : "memory" ) ;
static JS_ALWAYS_INLINE REMatchState * CVE_2011_2998_ExecuteREBytecode(REGlobalData * gData , REMatchState * x ) { REMatchState * result = NULL ; REBackTrackData * backTrackData ; jsbytecode * nextpc , * testpc ; REOp nextop ; RECapture * cap ; <START_VULN> REProgState * curState ; <END_VULN> const jschar * startcp ; size_t parenIndex , k ; size_t parenSoFar = 0 ; jschar matchCh1 , matchCh2 ; RECharSet * charSet ; JSBool anchor ; jsbytecode * pc = gData -> regexp -> program ; REOp op = (REOp ) * pc + + ;
static int CVE_2010_3875_ax25_getname(struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) { struct full_sockaddr_ax25 * fsa = (struct full_sockaddr_ax25 * ) uaddr ; struct sock * sk = sock -> sk ; unsigned char ndigi , i ; ax25_cb * ax25 ; int err = 0 ; lock_sock(sk ) ; ax25 = ax25_sk(sk ) ; if (peer != 0 ) { if (sk -> sk_state != TCP_ESTABLISHED ) { err = - ENOTCONN ; goto out ; } fsa -> fsa_ax25 . sax25_family = AF_AX25 ; fsa -> fsa_ax25 . sax25_call = ax25 -> dest_addr ; <START_VULN> fsa -> fsa_ax25 . sax25_ndigis = 0 ; <END_VULN> if (ax25 -> digipeat != NULL ) { ndigi = ax25 -> digipeat -> ndigi ; fsa -> fsa_ax25 . sax25_ndigis = ndigi ; for (i = 0 ; i < ndigi ; i + + ) fsa -> fsa_digipeater [ i ] = ax25 -> digipeat -> calls [ i ] ; } } else { fsa -> fsa_ax25 . sax25_family = AF_AX25 ;
MODULE_LICENSE("GPL" ) ; MODULE_AUTHOR("Michal Ludvig" ) ; <START_VULN> MODULE_ALIAS("aes" ) ; <END_VULN>
int err ; if (level != SOL_PPPOL2TP ) <START_VULN> return udp_prot . setsockopt(sk , level , optname , optval , optlen ) ; <END_VULN> if (optlen < sizeof(int ) ) return - EINVAL ;
js : : InitialShapeSet initialShapes ; void sweepInitialShapeTable( ) ; js : : types : : TypeObjectSet newTypeObjects ; js : : types : : TypeObjectSet lazyTypeObjects ; void sweepNewTypeObjectTable(js : : types : : TypeObjectSet & table ) ; <START_VULN> js : : types : : TypeObject * emptyTypeObject ; <END_VULN> inline js : : types : : TypeObject * getEmptyType(JSContext * cx ) ; js : : types : : TypeObject * getLazyType(JSContext * cx , JSObject * proto ) ;
icmp_param . offset = skb_network_offset(skb_in ) ; inet_sk(sk ) -> tos = tos ; ipc . addr = iph -> saddr ; <START_VULN> ipc . opt = & icmp_param . replyopts ; <END_VULN> ipc . tx_flags = 0 ; rt = icmp_route_lookup(net , skb_in , iph , saddr , tos ,
module_init(ghash_mod_init ) ; module_exit(ghash_mod_exit ) ; <START_VULN> MODULE_ALIAS("ghash" ) ; <END_VULN> MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("GHASH Message Digest Algorithm , s390 implementation" ) ;
protected : virtual void InitInternal( ) ; <START_VULN> virtual void WriteInternal(const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal( ) ;
payload = NULL ; <START_VULN> if (_payload ) { <END_VULN> ret = - ENOMEM ; payload = kmalloc(plen , GFP_KERNEL ) ; if ( ! payload )
return - ENXIO ; fmt = ( * (short * ) & event_rec [ 0 ] ) & 0xffff ; <START_VULN> err = synth_devs [ dev ] -> load_patch(dev , fmt , buf , p + 4 , c , 0 ) ; <END_VULN> if (err < 0 ) return err ;
} } <START_VULN> <END_VULN> efree(offsets ) ; }
if (subpats != NULL ) { <START_VULN> if (pcre_get_substring_list(subject , offsets , count , & stringlist ) < 0 ) { <END_VULN> efree(subpat_names ) ; efree(offsets ) ; if (match_sets ) efree(match_sets ) ;
MODULE_DESCRIPTION("Serpent Cipher Algorithm , AVX optimized" ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("serpent" ) ; <END_VULN>
void test_base64_decode(void ) { char buffer [ 16 ] ; <START_VULN> int len = mutt_b64_decode(buffer , encoded ) ; <END_VULN> if ( ! TEST_CHECK(len == sizeof(clear ) - 1 ) ) { TEST_MSG("Expected : % zu" , sizeof(clear ) - 1 ) ;
NAPI_GRO_CB(skb ) -> same_flow = 0 ; NAPI_GRO_CB(skb ) -> flush = 0 ; NAPI_GRO_CB(skb ) -> free = 0 ; <START_VULN> NAPI_GRO_CB(skb ) -> udp_mark = 0 ; <END_VULN> NAPI_GRO_CB(skb ) -> gro_remcsum_start = 0 ;
} <START_VULN> if (pread(fd , xsh_addr , xsh_sizeof , off + size * strtab ) == - 1 ) { <END_VULN> file_badread(ms ) ; return - 1 ; }
break ; tag_value = (ssize_t ) ReadProfileShort(endian , q ) ; format = (ssize_t ) ReadProfileShort(endian , q + 2 ) ; <START_VULN> if ((format - 1 ) >= EXIF_NUM_FORMATS ) <END_VULN> break ; components = (ssize_t ) ReadProfileLong(endian , q + 4 ) ; if (components < 0 )
OD( nsExtEntityLogo , SEC_OID_NS_CERT_EXT_ENTITY_LOGO , "Certificate Entity Logo" , CKM_INVALID_MECHANISM , UNSUPPORTED_CERT_EXTENSION ) , OD( nsExtUserPicture , SEC_OID_NS_CERT_EXT_USER_PICTURE , "Certificate User Picture" , CKM_INVALID_MECHANISM , UNSUPPORTED_CERT_EXTENSION ) , OD( nsExtSSLServerName , SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME , "Certificate SSL Server Name" , <START_VULN> CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , <END_VULN> OD( nsExtComment , SEC_OID_NS_CERT_EXT_COMMENT , "Certificate Comment" , CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , OD( nsExtLostPasswordURL , SEC_OID_NS_CERT_EXT_LOST_PASSWORD_URL , "Lost Password URL" , CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , OD( nsExtCertRenewalTime , SEC_OID_NS_CERT_EXT_CERT_RENEWAL_TIME , "Certificate Renewal Time" ,
guint16 CVE_2014_5163_de_sm_apn(tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) { guint32curr_offset ; guintcurr_len ; guint8str [ MAX_APN_LENGTH + 1 ] ; curr_offset = offset ; <START_VULN> memset(str , 0 , MAX_APN_LENGTH ) ; <END_VULN> tvb_memcpy(tvb , str , offset , len < MAX_APN_LENGTH ? len : MAX_APN_LENGTH ) ; curr_len = 0 ; while ((curr_len < len ) && (curr_len < MAX_APN_LENGTH ) ) { guint step = str [ curr_len ] ; str [ curr_len ] = ' . ' ; curr_len + = step + 1 ; }
static int mem_read(jas_stream_obj_t * obj , char * buf , int cnt ) { <START_VULN> int n ; <END_VULN> assert(cnt >= 0 ) ; assert(buf ) ;
mutex_unlock( & key_construction_mutex ) ; <START_VULN> if (keyring ) <END_VULN> __key_link_end(keyring , & key -> index_key , edit ) ;
int b = buf [ 0 ] & 0x7 ; int r = ((buf [ 0 ] >> 4 ) & 0xf ) | ((buf [ 1 ] & 0x01 ) << 4 ) ; <START_VULN> RAnalOp next_op ; <END_VULN>
extern void nfs_setattr_update_inode(struct inode * inode , struct iattr * attr ) ; extern struct nfs_open_context * get_nfs_open_context(struct nfs_open_context * ctx ) ; extern void put_nfs_open_context(struct nfs_open_context * ctx ) ; <START_VULN> extern struct nfs_open_context * nfs_find_open_context(struct inode * inode , struct rpc_cred * cred , int mode ) ; <END_VULN> extern u64 nfs_compat_user_ino64(u64 fileid ) ; extern void nfs_fattr_init(struct nfs_fattr * fattr ) ;
static __u8 * mr_report_fixup(struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <START_VULN> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <END_VULN> hid_info(hdev , "fixing up buttonconsumer in HID report descriptor" ) ; rdesc [ 30 ] = 0x0c ; }
zend_vspprintf( & message , 0 , format , va ) ; if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { <START_VULN> zend_throw_error(exception_ce , message ) ; <END_VULN> } else { zend_error(E_ERROR , " % s" , message ) ; }
virtual already_AddRefed < mozilla : : dom : : UndoManager > GetUndoManager( ) ; virtual bool UndoScope( ) MOZ_OVERRIDE ; virtual void SetUndoScope(bool aUndoScope , mozilla : : ErrorResult & aError ) MOZ_OVERRIDE ; nsresult ClearDataset( ) ; <START_VULN> nsSize GetWidthHeightForImage(imgIRequest * aImageRequest ) ; <END_VULN> NS_FORWARD_NSIDOMNODE_TO_NSINODE NS_FORWARD_NSIDOMELEMENT_TO_GENERIC NS_IMETHOD GetId(nsAString & aId ) MOZ_FINAL { mozilla : : dom : : Element : : GetId(aId ) ;
ipv6 : iph = __skb_header_pointer(skb , nhoff , sizeof(_iph ) , data , hlen , & _iph ) ; if ( ! iph ) <START_VULN> return false ; <END_VULN> ip_proto = iph -> nexthdr ; nhoff + = sizeof(struct ipv6hdr ) ;
} else { mag <<= bgshift ; <START_VULN> mask = (1 << numbps ) - 1 ; <END_VULN> most - significant bit planes introduced by ROI shifting .
bool mFullScreen ; void * mJavaView ; #endif nsPluginNativeWindow * mPluginWindow ; nsRefPtr < nsNPAPIPluginInstance > mInstance ; nsObjectFrame * mObjectFrame ; <START_VULN> nsIContent * mContent ; <END_VULN> nsCString mDocumentBase ; bool mWidgetCreationComplete ; nsCOMPtr < nsIWidget > mWidget ; nsRefPtr < nsPluginHost > mPluginHost ; #ifdef XP_MACOSX NP_CGContext mCGPluginPortCopy ; int32_t mInCGPaintLevel ;
. cia_decrypt = des3_ede_decrypt } } } } ; <START_VULN> MODULE_ALIAS("des3_ede" ) ; <END_VULN> static int __init des_generic_mod_init(void ) {
{ Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ; int qps_changed = 0 , i , err ; #define copy_fields(to , from , start_field , end_field ) memcpy( & to -> start_field , & from -> start_field , (char * ) & to -> end_field - (char * ) & to -> start_field ) if ( ! s1 -> current_frame . data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height ) { if (s != s1 ) <START_VULN> copy_fields(s , s1 , golden_frame , current_frame ) ; <END_VULN> return - 1 ; } if (s != s1 ) { if ( ! s -> current_frame . data [ 0 ] ) { int y_fragment_count , c_fragment_count ; s -> avctx = dst ; err = allocate_tables(dst ) ; if (err )
unsigned char __user * ugreen ; unsigned char __user * ublue ; struct fb_cmap * cmap = & info -> cmap ; <START_VULN> int index , count , i ; <END_VULN> u8 red , green , blue ; if (get_user(index , & c -> index ) ||
skb_queue_walk(queue , skb ) { * peeked = skb -> peeked ; if (flags & MSG_PEEK ) { <START_VULN> if ( * off >= skb -> len ) { <END_VULN> * off -= skb -> len ; continue ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : psychoacoustics not including preecho <START_VULN> last mod : $ Id : psy . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < math . h > #include < string . h > #include "vorbiscodec . h" #include "codec_internal . h"
phar_flush(phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; }
found = 0 ; while ((box = jp2_box_get(in ) ) ) { if (jas_getdbglevel( ) >= 1 ) { <START_VULN> jas_eprintf("box type % s" , box -> info -> name ) ; <END_VULN> } switch (box -> type ) { case JP2_BOX_JP2C :
matched = 0 ; PCRE_G(error_code ) = PHP_PCRE_NO_ERROR ; <START_VULN> <END_VULN> do { count = pcre_exec(pce -> re , extra , subject , subject_len , start_offset ,
fprintf(fdest , " % c" , (OPJ_UINT8 ) r ) ; if ((i + 1 ) % w == 0 ) { <START_VULN> for ((pad = w % 4 ) ? (4 - w % 4 ) : 0 ; pad > 0 ; pad -- ) <END_VULN> fprintf(fdest , " % c" , 0 ) ; } }
static __u8 * CVE_2012_3364_nci_extract_rf_params_nfca_passive_poll(struct nci_dev * ndev , struct rf_tech_specific_params_nfca_poll * nfca_poll , __u8 * data ) { nfca_poll -> sens_res = __le16_to_cpu( * ((__u16 * ) data ) ) ; data + = 2 ; <START_VULN> nfca_poll -> nfcid1_len = * data + + ; <END_VULN> pr_debug("sens_res 0x % x , nfcid1_len % d" , nfca_poll -> sens_res , nfca_poll -> nfcid1_len ) ; memcpy(nfca_poll -> nfcid1 , data , nfca_poll -> nfcid1_len ) ; data + = nfca_poll -> nfcid1_len ; nfca_poll -> sel_res_len = * data + + ; if (nfca_poll -> sel_res_len != 0 )
if ( ! sar . num ) sar . num = sar . den = 1 ; <START_VULN> for (plane = 0 ; plane < 4 && in -> data [ plane ] ; plane + + ) { <END_VULN> int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ; int vsub = plane == 1 || plane == 2 ? vsub0 : 0 ;
data . period = event -> hw . last_period ; <START_VULN> if (perf_event_overflow(event , 1 , & data , regs ) ) <END_VULN> x86_pmu_stop(event , 0 ) ; }
} static int opl3_load_patch(int dev , int format , const char __user * addr , <START_VULN> int offs , int count , int pmgr_flag ) <END_VULN> { struct sbi_instrument ins ;
case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <START_VULN> case EXIT_REASON_INVEPT : <END_VULN>
perf_unpin_context(ctx ) ; if (move_group ) <START_VULN> mutex_unlock( & gctx -> mutex ) ; <END_VULN> mutex_unlock( & ctx -> mutex ) ; if (task ) {
kfree(entry ) ; <START_VULN> if (pskb_expand_head(skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { <END_VULN> kfree_skb(skb_out ) ; skb_out = NULL ; goto free ;
sleep_again : current -> state = TASK_INTERRUPTIBLE ; <START_VULN> sem_unlock(sma ) ; <END_VULN> if (timeout ) jiffies_left = schedule_timeout(jiffies_left ) ;
err = ip6_ufo_append_data(sk , getfrag , from , length , hh_len , fragheaderlen , <START_VULN> transhdrlen , mtu , flags ) ; <END_VULN> if (err ) goto error ; return 0 ;
static int perf_swevent_init(struct perf_event * event ) { <START_VULN> int event_id = event -> attr . config ; <END_VULN> if (event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ;
ret = GSS_S_FAILURE ; goto cleanup ; } <START_VULN> <END_VULN> sc -> ctx_handle = GSS_C_NO_CONTEXT ; * ctx = (gss_ctx_id_t ) sc ; sc = NULL ;
if ( ! arp_checkentry( & e -> arp ) ) return - EINVAL ; <START_VULN> ret = xt_compat_check_entry_offsets(e , e -> target_offset , <END_VULN> e -> next_offset ) ; if (ret ) return ret ;
error = l2t_send(tdev , skb , l2e ) ; if (error < 0 ) kfree_skb(skb ) ; <START_VULN> return error ; <END_VULN> } int iwch_cxgb3_ofld_send(struct t3cdev * tdev , struct sk_buff * skb )
if (len ) len -- ; if ( ! strncmp(rock -> namespace -> prefix [ NAMESPACE_USER ] , commonpat , MIN(len , prefixlen ) ) ) { <START_VULN> if (prefixlen < len ) { <END_VULN> strlcpy(domainpat + domainlen , "user . " , sizeof(domainpat ) - domainlen ) ; }
void mdct_init(mdct_lookup * lookup , int n ) { int * bitrev = _ogg_malloc(sizeof( * bitrev ) * (n4 ) ) ; DATA_TYPE * T = _ogg_malloc(sizeof( * T ) * (n + n4 ) ) ; <START_VULN> <END_VULN> int i ; int n2 = n >> 1 ; int log2n = lookup -> log2n = rint(log((float ) n ) log(2 . f ) ) ; lookup -> n = n ; lookup -> trig = T ; lookup -> bitrev = bitrev ;
if (pal ) { s -> frame -> palette_has_changed = 1 ; memcpy(s -> pal , pal , AVPALETTE_SIZE ) ; } memcpy(s -> frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ; } if (avctx -> height * istride == avpkt -> size ) { <START_VULN> int linesize = (avctx -> width * avctx -> bits_per_coded_sample + 7 ) 8 ; <END_VULN> uint8_t * ptr = s -> frame -> data [ 0 ] ; uint8_t * buf = avpkt -> data + (avctx -> height - 1 ) * istride ; int i , j ; for (i = 0 ; i < avctx -> height ; i + + ) { if (avctx -> bits_per_coded_sample == 4 ) { for (j = 0 ; j < avctx -> width - 1 ; j + = 2 ) { ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ; ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF ; }
fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; if ( ! frag_id ) { <START_VULN> ipv6_select_ident(fh ) ; <END_VULN> frag_id = fh -> identification ; } else fh -> identification = frag_id ;
<START_VULN> <END_VULN> #define D0 if(1 ) #define D1 if(1 )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis codec headers <START_VULN> last mod : $ Id : codec_internal . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_CODECI_H_ #define _V_CODECI_H_ #include "envelope . h" #include "codebook . h"
<START_VULN> if(n == - 1 ) { <END_VULN> * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup("netscreen : cannot parse hex - data" ) ; return FALSE ;
return 1 ; } mpz_init (temp ) ; <START_VULN> mpz_powm (r , key -> g , k , key -> p ) ; <END_VULN> mpz_mod (r , r , key -> q ) ; mpz_invert (s , k , key -> q ) ; mpz_mul (temp , key -> x , r ) ;
if ( ! is_irq_none(vdev ) ) return - EINVAL ; <START_VULN> vdev -> ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <END_VULN> if ( ! vdev -> ctx ) return - ENOMEM ; commit 05692d7005a364add85c6e25a6c4447ce08f913a Author : Vlad Tsyrklevich < vlad@tsyrklevich . net > Date : Wed Oct 12 18 : 51 : 24 2016 + 0200 vfiopci : Fix integer overflows , bitmask check The VFIO_DEVICE_SET_IRQS ioctl did not sufficiently sanitize user - supplied integers , potentially allowing memory corruption . This patch adds appropriate integer overflow checks , checks the range bounds for VFIO_IRQ_SET_DATA_NONE , and also verifies that only single element in the VFIO_IRQ_SET_DATA_TYPE_MASK bitmask is set . VFIO_IRQ_SET_ACTION_TYPE_MASK is already correctly checked later in vfio_pci_set_irqs_ioctl( ) . Furthermore , a kzalloc is changed to a kcalloc because the use of a kzalloc with an integer multiplication allowed an integer overflow condition to be reached without this patch . kcalloc checks for overflow and should prevent a similar occurrence . Signed - off - by : Vlad Tsyrklevich < vlad@tsyrklevich . net > Signed - off - by : Alex Williamson < alex . williamson@redhat . com >
} mark_discard_range_all(sbi ) ; <START_VULN> f2fs_wait_discard_bios(sbi ) ; <END_VULN> out : range -> len = F2FS_BLK_TO_BYTES(cpc . trimmed ) ; return err ;
if ((ret & VM_FAULT_WRITE ) && ! (vma -> vm_flags & VM_WRITE ) ) <START_VULN> * flags &= ~ FOLL_WRITE ; <END_VULN> return 0 ; }
val = min_t(u32 , val , sysctl_wmem_max ) ; set_sndbuf : sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; <START_VULN> sk -> sk_sndbuf = max_t(u32 , val * 2 , SOCK_MIN_SNDBUF ) ; <END_VULN> sk -> sk_write_space(sk ) ; break ;
* * NET_RX_SUCCESS(no congestion ) <START_VULN> * NET_RX_DROP (packet was dropped ) <END_VULN> *
<START_VULN> static int ocfs2_dio_get_block(struct inode * inode , sector_t iblock , <END_VULN> struct buffer_head * bh_result , int create ) { struct ocfs2_super * osb = OCFS2_SB(inode -> i_sb ) ;
} (void ) r_buf_read_at (bf -> buf , sec -> paddr , buf , sec -> size ) ; if (bits == 32 ) { <START_VULN> for (i = 0 ; i < sec -> size ; i + = 4 ) { <END_VULN> ut32 addr32 = r_read_le32 (buf + i ) ; if (addr32 ) { RBinAddr * ba = newEntry (sec -> paddr + i , (ut64 ) addr32 , type , bits ) ;
void removeWrapper(js : : WrapperMap : : Ptr p ) { crossCompartmentWrappers . remove(p ) ; } struct WrapperEnum : public js : : WrapperMap : : Enum { WrapperEnum(JSCompartment * c ) : js : : WrapperMap : : Enum(c -> crossCompartmentWrappers ) { } } ; <START_VULN> void mark(JSTracer * trc ) ; <END_VULN> bool isDiscardingJitCode(JSTracer * trc ) ; void sweep(js : : FreeOp * fop , bool releaseTypes ) ; void sweepCrossCompartmentWrappers( ) ; void purge( ) ; void clearTables( ) ; bool hasObjectMetadataCallback( ) const { return objectMetadataCallback ; } void setObjectMetadataCallback(js : : ObjectMetadataCallback callback ) ;
void usb_serial_console_disconnect(struct usb_serial * serial ) { <START_VULN> if (serial -> port [ 0 ] == usbcons_info . port ) { <END_VULN> usb_serial_console_exit( ) ; usb_serial_put(serial ) ; }
. index_key . type = type , . index_key . description = description , . cred = current_cred( ) , <START_VULN> . match_data . cmp = type -> match , <END_VULN> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ;
register const struct in6_addr * addr ; dp = (const struct ip6_rthdr * ) bp ; <START_VULN> len = dp -> ip6r_len ; <END_VULN> ep = ndo -> ndo_snapend ; ND_TCHECK(dp -> ip6r_segleft ) ; ND_PRINT((ndo , "srcrt (len = % d" , dp -> ip6r_len ) ) ; ND_PRINT((ndo , " , type = % d" , dp -> ip6r_type ) ) ; ND_PRINT((ndo , " , segleft = % d" , dp -> ip6r_segleft ) ) ;
return NULL ; } ; <START_VULN> if ((psf = calloc (1 , sizeof (SF_PRIVATE ) ) ) == NULL ) <END_VULN> { sf_errno = SFE_MALLOC_FAILED ; returnNULL ; } ;
u32 __user * optval , int __user * optlen ) { int rc = - ENOPROTOOPT ; <START_VULN> if (ccid -> ccid_ops -> ccid_hc_tx_getsockopt != NULL ) <END_VULN> rc = ccid -> ccid_ops -> ccid_hc_tx_getsockopt(sk , optname , len , optval , optlen ) ; return rc ;
ip : iph = __skb_header_pointer(skb , nhoff , sizeof(_iph ) , data , hlen , & _iph ) ; if ( ! iph || iph -> ihl < 5 ) <START_VULN> return false ; <END_VULN> nhoff + = iph -> ihl * 4 ; ip_proto = iph -> protocol ;
ret = hugetlb_acct_memory(h , chg ) ; if (ret < 0 ) { hugepage_subpool_put_pages(spool , chg ) ; <START_VULN> return ret ; <END_VULN> }
for(i = 0 ; i < vi -> channels ; i + + ) { int submap = info -> chmuxlist [ i ] ; float * mdct = gmdct [ i ] ; float * res = vb -> pcm [ i ] ; int * ilogmask = ilogmaskch [ i ] = _vorbis_block_alloc(vb , n2 * sizeof( ** gmdct ) ) ; <START_VULN> <END_VULN> nonzero [ i ] = floor1_encode(opb , vb , b -> flr [ info -> floorsubmap [ submap ] ] , floor_posts [ i ] [ k ] , ilogmask ) ; #if 0 { char buf [ 80 ] ; sprintf(buf , "maskI % c % d" , i ? 'R' : 'L' , k ) ; float work [ n2 ] ;
return - EMSGSIZE ; algo = nla_data(nla ) ; <START_VULN> strcpy(algo -> alg_name , auth -> alg_name ) ; <END_VULN> memcpy(algo -> alg_key , auth -> alg_key , (auth -> alg_key_len + 7 ) 8 ) ; algo -> alg_key_len = auth -> alg_key_len ;
{ HTTPContext * s = h -> priv_data ; URLContext * old_hd = s -> hd ; <START_VULN> int64_t old_off = s -> off ; <END_VULN> uint8_t old_buf [ BUFFER_SIZE ] ; int old_buf_size , ret ; AVDictionary * options = NULL ;
ret = - EPERM ; <START_VULN> if ( ! new_idmap_permitted(ns , cap_setid , & new_map ) ) <END_VULN> goto out ;
#define free(ptr ) hunspell_free(ptr ) inline void * hunspell_realloc(void * ptr , size_t size ) { HunspellReportMemoryDeallocation(ptr ) ; void * result = moz_realloc(ptr , size ) ; if (result ) { HunspellReportMemoryAllocation(result ) ; <START_VULN> } else { <END_VULN> HunspellReportMemoryAllocation(ptr ) ; } return result ; } #define realloc(ptr , size ) hunspell_realloc(ptr , size ) inline char * hunspell_strdup(const char * str )
{ int i ; for(i = 31 ; i >= 0 ; i -- ) { <START_VULN> if(x & (1 << i ) ) return i ; <END_VULN> } return 0 ; }
struct inode * inode = d_inode(dentry ) ; struct buffer_head * bh = NULL ; int error ; <START_VULN> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE(inode ) ; <END_VULN> ea_idebug(inode , "buffer = % p , buffer_size = % ld" , buffer , (long ) buffer_size ) ;
XPCWrappedNativeScope * GetScope( ) const { return mScope ; } XPCJSRuntime * GetRuntime( ) const { return mScope -> GetRuntime( ) ; } JSObject * <START_VULN> GetJSProtoObject( ) const { return mJSProtoObject ; } <END_VULN> nsIClassInfo * GetClassInfo( ) const { return mClassInfo ; } XPCNativeSet * GetSet( ) const { return mSet ; } XPCNativeScriptableInfo *
fn = fib6_add_1(root , & rt -> rt6i_dst . addr , rt -> rt6i_dst . plen , offsetof(struct rt6_info , rt6i_dst ) , allow_create , replace_required ) ; <START_VULN> <END_VULN> if (IS_ERR(fn ) ) { err = PTR_ERR(fn ) ; goto out ; }
ask -> private = ctx ; <START_VULN> skcipher_request_set_tfm( & ctx -> req , private ) ; <END_VULN> skcipher_request_set_callback( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx -> completion ) ;
<START_VULN> <END_VULN> xasprintf( & userstyle , " % s % s % s" , authctxt -> user , authctxt -> style ? " : " : "" ,
struct ipc_rcu_hdr { <START_VULN> int refcount ; <END_VULN> int is_vmalloc ; void * data [ 0 ] ; } ;
{ FILE * f ; char * tmpname ; <START_VULN> f = xfmkstemp( & tmpname , NULL ) ; <END_VULN> unlink(tmpname ) ; free(tmpname ) ; fclose(f ) ;
#else <START_VULN> static inline zend_ulong realpath_cache_key(const char * path , int path_len ) <END_VULN> { register zend_ulong h ; const char * e = path + path_len ;
static int sock_close(struct inode * inode , struct file * filp ) { <START_VULN> sock_release(SOCKET_I(inode ) ) ; <END_VULN> return 0 ; }
#define MAX_SHARE_SIZE 64 #define MAX_USERNAME_SIZE 32 <START_VULN> #define MAX_PASSWORD_SIZE 16<END_VULN> #define CIFS_MIN_RCV_POOL 4
} loff_t <START_VULN> ftrace_regex_lseek(struct file * file , loff_t offset , int whence ) <END_VULN> { loff_t ret ;
fp = skb_shinfo(head ) -> frag_list ; <START_VULN> if (NFCT_FRAG6_CB(fp ) -> orig == NULL ) <END_VULN> fp = fp -> next ;
} static void <START_VULN> build_config(char * prefix , struct server * server ) <END_VULN> { char * path = NULL ; int path_size = strlen(prefix ) + strlen(server -> port ) + 20 ;
int mi_repair_parallel(MI_CHECK * param , register MI_INFO * info , <START_VULN> const char * name , int rep_quick ) <END_VULN> { int got_error ; uint i , key , total_key_length , istep ;
: 0 ; } bool isNative( ) const { JS_ASSERT( ! (flags & NON_NATIVE ) == getObjectClass( ) -> isNative( ) ) ; return ! (flags & NON_NATIVE ) ; } <START_VULN> const js : : Shape * previous( ) const { <END_VULN> return parent ; } class Range { protected : friend struct Shape ; const Shape * cursor ;
return AVERROR_INVALIDDATA ; if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) { avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; <START_VULN> } else if (encoding == 1 && (c -> bpp == 6 || c -> bpp == 8 ) ) { <END_VULN> if (c -> palette_size != (1 << (c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ; avctx -> pix_fmt = AV_PIX_FMT_BGR24 ;
return ZEND_HASH_APPLY_STOP ; } <START_VULN> fname_len = (php_stat_len ) strlen(fname ) ; <END_VULN> save = fname ; goto phar_spl_fileinfo ; }
oggpack_write(opb , 1 , 1 ) ; return(0 ) ; } static int _vorbis_pack_comment(oggpack_buffer * opb , vorbis_comment * vc ) { int bytes = strlen(ENCODE_VENDOR_STRING ) ; <START_VULN> <END_VULN> oggpack_write(opb , 0x03 , 8 ) ; _v_writestring(opb , "vorbis" , 6 ) ; oggpack_write(opb , bytes , 32 ) ; _v_writestring(opb , ENCODE_VENDOR_STRING , bytes ) ;
while ( strncmp( file , " . " , 2 ) == 0 ) (void ) memmove( file , file + 2 , strlen( file ) - 1 ) ; while ( ( cp = strstr( file , " . " ) ) != (char * ) 0 ) <START_VULN> (void ) memmove( cp , cp + 2 , strlen( file ) - 1 ) ; <END_VULN> for ( ; ; )
public : inline void setDefaultCompartmentObject(JSObject * obj ) ; inline void setDefaultCompartmentObjectIfUnset(JSObject * obj ) ; JSObject * maybeDefaultCompartmentObject( ) const { return defaultCompartmentObject_ ; } js : : ContextStack stack ; <START_VULN> <END_VULN> inline js : : Handle < js : : GlobalObject * > global( ) const ; inline bool hasfp( ) const { return stack . hasfp( ) ; } inline js : : StackFrame * fp( ) const { return stack . fp( ) ; } inline js : : StackFrame * maybefp( ) const { return stack . maybefp( ) ; } inline js : : FrameRegs & regs( ) const { return stack . regs( ) ; } inline js : : FrameRegs * maybeRegs( ) const { return stack . maybeRegs( ) ; }
<START_VULN> static int _nfs4_do_open(struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state ** res ) <END_VULN> { struct nfs4_state_owner * sp ; struct nfs4_state * state = NULL ;
struct inet_sock * inet ; __be32 daddr ; <START_VULN> if (ip_options_echo( & icmp_param -> replyopts , skb ) ) <END_VULN> return ; sk = icmp_xmit_lock(net ) ;
((whence == SEEK_CUR && off == 0 ) || (whence == SEEK_SET && off == s -> off ) ) ) return s -> off ; <START_VULN> else if ((s -> filesize == - 1 && whence == SEEK_END ) ) <END_VULN> return AVERROR(ENOSYS ) ; if (whence == SEEK_CUR )
struct videobuf_queue * q = map -> q ; int i ; <START_VULN> dprintk(2 , "vm_close % p [ count = % d , vma = % 08lx - % 08lx ] " , map , <END_VULN> map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count -- ;
{ inti ; u_entry_T * uep ; <START_VULN> char_u ** array ; <END_VULN> char_u * line ; intline_len ;
* <START_VULN> #define JSXDR_BYTECODE_VERSION (0xb973c0de - 89 ) <END_VULN> extern JSBool js_XDRAtom(JSXDRState * xdr , JSAtom ** atomp ) ; JS_END_EXTERN_C
else size = offsetof(struct fxregs_state , xmm_space [ 0 ] ) ; <START_VULN> return segmented_write(ctxt , ctxt -> memop . addr . mem , & fx_state , size ) ; <END_VULN> } static int fxrstor_fixup(struct x86_emulate_ctxt * ctxt ,
JS_STATIC_ASSERT(sizeof(JSValueTag ) == 4 ) ; JS_STATIC_ASSERT(sizeof(JSBool ) == 4 ) ; JS_STATIC_ASSERT(sizeof(JSWhyMagic ) <= 4 ) ; JS_STATIC_ASSERT(sizeof(Value ) == 8 ) ; } friend jsval_layout ( : : JSVAL_TO_IMPL ) (Value ) ; friend Value ( : : IMPL_TO_JSVAL ) (jsval_layout l ) ; <START_VULN> } JSVAL_ALIGNMENT ; <END_VULN> inline bool IsPoisonedValue(const Value & v ) { if (v . isString( ) ) return IsPoisonedPtr(v . toString( ) ) ; if (v . isObject( ) ) return IsPoisonedPtr( & v . toObject( ) ) ;
SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T' , 0x23 ) , } ; <START_VULN> static long snd_timer_user_ioctl(struct file * file , unsigned int cmd , <END_VULN> unsigned long arg ) { struct snd_timer_user * tu ;
module_init(sit_init ) ; module_exit(sit_cleanup ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("sit0" ) ; <END_VULN>
return ; } <START_VULN> phar_file_stat(filename , (php_stat_len ) filename_len , funcnum , PHAR_G(orig ) , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; <END_VULN> } }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : modified discrete cosine transform prototypes <START_VULN> last mod : $ Id : mdct . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _OGG_mdct_H_ #define _OGG_mdct_H_ #include "vorbiscodec . h"
PHPAPI char * xml_utf8_decode(const XML_Char * s , int len , int * newlen , const XML_Char * encoding ) { <START_VULN> int pos = len ; <END_VULN> char * newbuf = emalloc(len + 1 ) ; unsigned int c ; char ( * decoder ) (unsigned short ) = NULL ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : residue backend 0 , 1 and 2 implementation <START_VULN> last mod : $ Id : res0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN>
return - EFAULT ; len = namelen ; <START_VULN> if (namelen > 32 ) <END_VULN> len = 32 ; down_read( & uts_sem ) ;
ret = FAIL ; break ; } <START_VULN> <END_VULN> new_charset_name = mnd_pestrdup(value , conn -> persistent ) ; if ( ! new_charset_name ) { goto oom ;
js_AtomizeString(JSContext * cx , JSString * str , uintN flags ) ; extern JSAtom * <START_VULN> js_Atomize(JSContext * cx , const char * bytes , size_t length , uintN flags , bool useCESU8 = false ) ; <END_VULN> extern JSAtom * js_AtomizeChars(JSContext * cx , const jschar * chars , size_t length , uintN flags ) ;
return - EBUSY ; } <START_VULN> chip -> data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8 ) , GFP_KERNEL ) ; <END_VULN> if (chip -> data_buffer == NULL ) { clear_bit(0 , & chip -> is_open ) ; put_device(chip -> dev ) ;
0 . 9999979185F , 0 . 9999982507F , 0 . 9999985414F , 0 . 9999987944F , 0 . 9999990129F , 0 . 9999992003F , 0 . 9999993596F , 0 . 9999994939F , 0 . 9999996059F , 0 . 9999996981F , 0 . 9999997732F , 0 . 9999998333F , 0 . 9999998805F , 0 . 9999999170F , 0 . 9999999444F , 0 . 9999999643F , 0 . 9999999784F , 0 . 9999999878F , 0 . 9999999937F , 0 . 9999999972F , 0 . 9999999990F , 0 . 9999999997F , 1 . 0000000000F , 1 . 0000000000F , } ; <START_VULN> static float vwin4096 [ 2048 ] = { <END_VULN> 0 . 0000002310F , 0 . 0000020791F , 0 . 0000057754F , 0 . 0000113197F , 0 . 0000187121F , 0 . 0000279526F , 0 . 0000390412F , 0 . 0000519777F , 0 . 0000667623F , 0 . 0000833949F , 0 . 0001018753F , 0 . 0001222036F , 0 . 0001443798F , 0 . 0001684037F , 0 . 0001942754F , 0 . 0002219947F , 0 . 0002515616F , 0 . 0002829761F , 0 . 0003162380F , 0 . 0003513472F , 0 . 0003883038F , 0 . 0004271076F , 0 . 0004677584F , 0 . 0005102563F , 0 . 0005546011F , 0 . 0006007928F , 0 . 0006488311F , 0 . 0006987160F , 0 . 0007504474F , 0 . 0008040251F , 0 . 0008594490F , 0 . 0009167191F ,
sdb_num_set (sdb , "link" , shdr -> sh_link , 0 ) ; sdb_set (sdb , "link_section_name" , link_section_name , 0 ) ; <START_VULN> for (cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ((char * ) defs + i < end ) ; + + cnt ) { <END_VULN> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ((char * ) defs ) + i ; char key [ 32 ] = { 0 } ;
BIO_push(out , etmp ) ; etmp = NULL ; } <START_VULN> if (PKCS7_is_detached(p7 ) || (in_bio != NULL ) ) { <END_VULN> bio = in_bio ; } else { if (data_body -> length > 0 )
} static spnego_gss_ctx_id_t <START_VULN> create_spnego_ctx(void ) <END_VULN> { spnego_gss_ctx_id_t spnego_ctx = NULL ; spnego_ctx = (spnego_gss_ctx_id_t )
EXPORT_SYMBOL(sysctl_tcp_adv_win_scale ) ; <START_VULN> int sysctl_tcp_challenge_ack_limit = 100 ; <END_VULN> int sysctl_tcp_stdurg __read_mostly ; int sysctl_tcp_rfc1337 __read_mostly ;
if (argc < 2 || ! WriteStatusFailure(argv [ 1 ] , SERVICE_NOT_ENOUGH_COMMAND_LINE_ARGS ) ) { LOG_WARN(("Could not write update . status service update failure . ( % d ) " , GetLastError( ) ) ) ; } return FALSE ; } <START_VULN> WCHAR installDir [ MAX_PATH ] = { L'0' } ; <END_VULN> if ( ! GetInstallationDir(argc , argv , installDir ) ) { LOG_WARN(("Could not get the installation directory" ) ) ; if ( ! WriteStatusFailure(argv [ 1 ] , SERVICE_INSTALLDIR_ERROR ) ) { LOG_WARN(("Could not write update . status for GetInstallationDir failure . " ) ) ; } return FALSE ; }
static __u8 * sp_report_fixup(struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <START_VULN> if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && <END_VULN> rdesc [ 106 ] == 0x03 ) { hid_info(hdev , "fixing up Sunplus Wireless Desktop report descriptor" ) ; rdesc [ 105 ] = rdesc [ 110 ] = 0x03 ;
ALLOC_ZVAL(result_set ) ; array_init(result_set ) ; INIT_PZVAL(result_set ) ; <START_VULN> <END_VULN> for (i = 0 ; i < count ; i + + ) { if (offset_capture ) {
status = PTR_ERR(cred ) ; goto out ; } <START_VULN> state = nfs4_do_open(dir , & path , flags , sattr , cred ) ; <END_VULN> d_drop(dentry ) ; if (IS_ERR(state ) ) { status = PTR_ERR(state ) ;
static __u8 * pl_report_fixup(struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <START_VULN> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <END_VULN> rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) { hid_info(hdev , "fixing up Petalynx Maxter Remote report descriptor" ) ;
} offset = skb -> csum_start - skb_headroom(skb ) ; csum = skb_checksum(skb , offset , skb -> len - offset , 0 ) ; offset + = skb -> csum_offset ; * (__sum16 * ) (skb -> data + offset ) = csum_fold(csum ) ; skb -> ip_summed = CHECKSUM_NONE ; <START_VULN> if ((skb_headroom(skb ) < frag_hdr_sz ) && <END_VULN> pskb_expand_head(skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt(skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header(skb ) - skb_mac_header(skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header(skb ) ;
phar_flush(entry_obj -> ent . entry -> phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; } RETURN_TRUE ;
static void gdCtxPrintf(gdIOCtx * out , const char * format , . . . ) { <START_VULN> char buf [ 4096 ] ; <END_VULN> int len ; va_list args ;
xattr_value_len , calc . digest ) ; if (rc ) break ; <START_VULN> rc = memcmp(xattr_data -> digest , calc . digest , <END_VULN> sizeof(calc . digest ) ) ; if (rc ) rc = - EINVAL ;
return register_die_notifier( & kgdb_notifier ) ; } <START_VULN> static void kgdb_hw_overflow_handler(struct perf_event * event , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) { struct task_struct * tsk = current ;
phar_flush(phar_obj -> arc . archive , stub , stub_len , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; }
void ipc_rcu_putref(void * ptr ) { <START_VULN> if ( -- container_of(ptr , struct ipc_rcu_hdr , data ) -> refcount > 0 ) <END_VULN> return ; if (container_of(ptr , struct ipc_rcu_hdr , data ) -> is_vmalloc ) {
int32_t i32 ; uint32_t u32 ; JSWhyMagic why ; } payload ; } s ; double asDouble ; void * asPtr ; size_t asWord ; <START_VULN> } jsval_layout ; <END_VULN> # endif #endif JS_STATIC_ASSERT(sizeof(jsval_layout ) == 8 ) ; #if JS_BITS_PER_WORD == 32
log_unauth(funcname , prime_arg , & client_name , & service_name , rqstp ) ; } gss_release_buffer( & minor_stat , & client_name ) ; gss_release_buffer( & minor_stat , & service_name ) ; <START_VULN> exit_func : <END_VULN> free_server_handle(handle ) ; return & ret ;
nsIFile ** aDirectory ) const ; nsresult EnsureOriginIsInitialized(const nsACString & aOrigin , bool aTrackQuota , nsIFile ** aDirectory ) ; void <START_VULN> UninitializeOriginsByPattern(const nsACString & aPattern ) ; <END_VULN> nsIThread * IOThread( ) { NS_ASSERTION(mIOThread , "This should never be null ! " ) ; return mIOThread ; }
if (PASS == conn -> m -> local_tx_start(conn , this_func TSRMLS_CC ) ) { ret = conn -> m -> query(conn , (mode ) ? "SET AUTOCOMMIT = 1" : "SET AUTOCOMMIT = 0" , sizeof("SET AUTOCOMMIT = 1" ) - 1 TSRMLS_CC ) ; <START_VULN> conn -> m -> local_tx_end(conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_RETURN(ret ) ;
TFunctionSign3 , vec3 sign(vec3 ) ; TFunctionSign4 , vec4 sign(vec4 ) ; TFunctionUnknown } ; TBuiltInFunction IdentifyFunction(TOperator op , const TType & returnType ) ; <START_VULN> TVector < TBuiltInFunction > mFunctions ; <END_VULN> unsigned int mFunctionGroupMask ; a bitmap of TBuiltInFunctionGroup . } ; #endif COMPILIER_BUILT_IN_FUNCTION_EMULATOR_H_
queue_unlock(struct futex_q * q , struct futex_hash_bucket * hb ) { spin_unlock( & hb -> lock ) ; <START_VULN> drop_futex_key_refs( & q -> key ) ; <END_VULN> } ret = futex_wait_setup(uaddr , val , fshared , & q , & hb ) ; if (ret ) goto out ;
for ( ; num ; num -- ) { <START_VULN> if (pread(fd , xph_addr , xph_sizeof , off ) == - 1 ) { <END_VULN> file_badread(ms ) ; return - 1 ; }
continue ; timer -> it . cpu . expires + = incr ; <START_VULN> timer -> it_overrun + = 1 << i ; <END_VULN> delta -= incr ; } }
<START_VULN> PHPAPI void php_stat(const char * filename , php_stat_len filename_length , int type , zval * return_value ) <END_VULN> { zval stat_dev , stat_ino , stat_mode , stat_nlink , stat_uid , stat_gid , stat_rdev , stat_size , stat_atime , stat_mtime , stat_ctime , stat_blksize , stat_blocks ;
} if (priv -> cac_id_len ) { serial -> len = MIN(priv -> cac_id_len , SC_MAX_SERIALNR ) ; <START_VULN> memcpy(serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <END_VULN> SC_FUNC_RETURN(card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN(card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ;
zend_throw_exception_ex(NULL , 0 , "can not find class % s" , class_name -> val TSRMLS_CC ) ; return NULL ; } <START_VULN> <END_VULN> zend_string * fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func ) ) ) ; Z_STR(user_func ) = fname ; Z_TYPE_INFO(user_func ) = IS_STRING_EX ;
} else { for(i = 0 ; i < s -> entries ; i + + ) { long num = oggpack_read(opb , 5 ) ; if(num == - 1 ) goto _eofout ; s -> lengthlist [ i ] = num + 1 ; } } <START_VULN> <END_VULN> break ; case 1 : { long length = oggpack_read(opb , 5 ) + 1 ; s -> lengthlist = _ogg_malloc(sizeof( * s -> lengthlist ) * s -> entries ) ; for(i = 0 ; i < s -> entries ; ) {
if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { zend_throw_error(exception_ce , message ) ; } else { <START_VULN> zend_error(E_ERROR , message ) ; <END_VULN> } efree(message ) ;
#endif virtual nsresult Close( ) ; virtual void Suspend(bool aCloseImmediately ) ; virtual void Resume( ) ; virtual already_AddRefed < nsIPrincipal > GetCurrentPrincipal( ) ; bool IsClosed( ) const { return mCacheStream . IsClosed( ) ; } virtual bool CanClone( ) ; <START_VULN> virtual MediaResource * CloneData(MediaDecoder * aDecoder ) ; <END_VULN> void RecordStatisticsTo(MediaChannelStatistics * aStatistics ) MOZ_OVERRIDE { NS_ASSERTION(aStatistics , "Statistics param cannot be null ! " ) ; MutexAutoLock lock(mLock ) ; if ( ! mChannelStatistics ) { mChannelStatistics = aStatistics ; }
#ifndef WOFF_H_ #define WOFF_H_ #ifdef _MSC_VER <START_VULN> typedef char int8_t ; <END_VULN> typedef short int16_t ; typedef int int32_t ; typedef unsigned char uint8_t ; typedef unsigned short uint16_t ; typedef unsigned int uint32_t ; typedef unsigned __int64 uint64_t ; #else #include < inttypes . h >
msg_tmp . size = le16_to_cpu((__force __le16 ) msg_tmp . size ) ; msg_tmp . command = le32_to_cpu((__force __le32 ) msg_tmp . command ) ; msg_tmp . controlselector = le16_to_cpu((__force __le16 ) msg_tmp . controlselector ) ; if (peekonly ) { <START_VULN> memcpy(msg , & msg_tmp , sizeof( * msg ) ) ; <END_VULN> goto peekout ; }
if (preg_options ) { * preg_options = pce ? pce -> preg_options : 0 ; } <START_VULN> <END_VULN> return pce ? pce -> re : NULL ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : fft transform <START_VULN> last mod : $ Id : smallft . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_SMFT_H_ #define _V_SMFT_H_ #include "vorbiscodec . h"
attr -> size = usize ; } <START_VULN> ret = copy_to_user(uattr , attr , usize ) ; <END_VULN> if (ret ) return - EFAULT ;
. data = & kptr_restrict , . maxlen = sizeof(int ) , . mode = 0644 , <START_VULN> . proc_handler = proc_dointvec_minmax , <END_VULN> . extra1 = & zero , . extra2 = & two , } ,
<START_VULN> static bool neuterViews(JSContext * cx , Handle < ArrayBufferObject * > buffer ) ; <END_VULN> uint8_t * dataPointer( ) const ;
{ struct videobuf_mapping * map = vma -> vm_private_data ; <START_VULN> dprintk(2 , "vm_open % p [ count = % d , vma = % 08lx - % 08lx ] " , map , <END_VULN> map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count + + ;
uint_fast32_t tmpxend ; uint_fast32_t tmpyend ; jpc_dec_cp_t * cp ; <START_VULN> jpc_tsfb_band_t bnds [ 64 ] ; <END_VULN> jpc_pchg_t * pchg ; int pchgno ; jpc_dec_cmpt_t * cmpt ;
int length ; length = strlen (filename ) ; <START_VULN> if (length > 0 ) <END_VULN> { if ((filename [ 0 ] == '"' ) && (filename [ length - 1 ] == '"' ) ) return weechat_strndup (filename + 1 , length - 2 ) ;
char buf [ 20 ] ; int ret ; uid_t uid ; cred = current_cred( ) ; user = cred -> user ; uid = from_kuid(cred -> user_ns , user -> uid ) ; kenter(" % p { % u } " , user , uid ) ; <START_VULN> if (user -> uid_keyring ) { <END_VULN> kleave(" = 0 [ exist ] " ) ; return 0 ; } mutex_lock( & key_user_keyring_mutex ) ; ret = 0 ; if ( ! user -> uid_keyring ) { sprintf(buf , "_uid . % u" , uid ) ;
uint32_t str_key_len , base_len = p_obj -> l ; phar_entry_data * data ; php_stream * fp ; <START_VULN> php_stat_len fname_len ; <END_VULN> size_t contents_len ; char * fname , * error = NULL , * base = p_obj -> b , * save = NULL , * temp = NULL ; zend_string * opened ;
#include < windows . h > #elif defined(ANGLE_OS_POSIX ) #include < pthread . h > #include < semaphore . h > #include < errno . h > #endif <START_VULN> #include "compilerdebug . h"<END_VULN> #if defined(ANGLE_USE_NSPR ) typedef PRUintn OS_TLSIndex ; #define OS_INVALID_TLS_INDEX 0xFFFFFFFF #elif defined(ANGLE_OS_WIN )
s + = 11 ; SKIPWS(s ) ; ptmp = tmp ; <START_VULN> while (isdigit((unsigned char ) * s ) ) <END_VULN> * ptmp + + = * s + + ; * ptmp = '0' ; if (mutt_str_atol(tmp , & h -> content_length ) < 0 ) commit 1b0f0d0988e6df4e32e9f4bf8780846ea95d4485 Author : JerikoOne < jeriko . one@gmx . us > Date : Sat Jul 7 14 : 03 : 46 2018 - 0500 Don't overflow stack buffer in msg_parse_fetch
txp -> size -= data_len ; } else { <START_VULN> xen_netbk_idx_release(netbk , pending_idx ) ; <END_VULN> } if (txp -> flags & XEN_NETTXF_csum_blank )
} * tail = vp ; <START_VULN> while ( * tail ) tail = & vp -> next ; <END_VULN> p + = alen ; } }
gss_release_buffer( & tmpmin , & sc -> DER_mechTypes ) ; assert(mech_wanted != GSS_C_NO_OID ) ; } else <START_VULN> sc = create_spnego_ctx( ) ; <END_VULN> if (sc == NULL ) { ret = GSS_S_FAILURE ; * return_token = NO_TOKEN_SEND ;
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID("@(# ) $ File : softmagic . c , v 1 . 189 20140530 16 : 47 : 44 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
else skb -> tstamp = ktime_get_real( ) ; <START_VULN> __skb_complete_tx_timestamp(skb , sk , tstype ) ; <END_VULN> } EXPORT_SYMBOL_GPL(__skb_tstamp_tx ) ;
send_cookie = 0 ; } <START_VULN> if ( ! PS(id ) && <END_VULN> zend_hash_find( & EG(symbol_table ) , "_POST" , sizeof("_POST" ) , (void ** ) & data ) == SUCCESS && Z_TYPE_PP(data ) == IS_ARRAY &&
<START_VULN> image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : <END_VULN> UndefinedPixelTrait ; image -> storage_class = (viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;
value -> encoding . address = READ (buf , ut64 ) ; break ; default : <START_VULN> eprintf("DWARF : Unexpected pointer size : % u" , (unsigned ) hdr -> pointer_size ) ; <END_VULN> return NULL ; } break ;
idev = __in_dev_get_rcu(dev ) ; if (idev ) { if (idev -> ifa_list ) network = ntohl(idev -> ifa_list -> ifa_address ) & 0xffffff00 ; } rcu_read_unlock( ) ; udpdest . sin_addr . s_addr = htonl(network | addr . station ) ; } ah . port = port ; ah . cb = cb & 0x7f ; ah . code = 2 ; <START_VULN> ah . pad = 0 ; <END_VULN> size = sizeof(struct aunhdr ) ; iov [ 0 ] . iov_base = (void * ) & ah ; iov [ 0 ] . iov_len = size ; for (i = 0 ; i < msg -> msg_iovlen ; i + + ) { void __user * base = msg -> msg_iov [ i ] . iov_base ; size_t iov_len = msg -> msg_iov [ i ] . iov_len ;
data , hlen , & _keyid ) ; if ( ! keyid ) <START_VULN> return false ; <END_VULN> if (skb_flow_dissector_uses_key(flow_dissector , FLOW_DISSECTOR_KEY_GRE_KEYID ) ) {
_preextrapolate_helper(v ) ; [ at least ] a few full blocks of zeroes at the end . * <START_VULN> vorbis_analysis_buffer(v , ci -> blocksizes [ 1 ] * 3 ) ; <END_VULN> v -> eofflag = v -> pcm_current ; v -> pcm_current + = ci -> blocksizes [ 1 ] * 3 ; for(i = 0 ; i < vi -> channels ; i + + ) { if(v -> eofflag > order * 2 ) { long n ;
{ stream -> msg = "abnormal command termination" ; } <START_VULN> return XD3_INTERNAL ; <END_VULN> } return 0 ; }
. open = ftrace_filter_open , . read = seq_read , . write = ftrace_filter_write , <START_VULN> . llseek = ftrace_regex_lseek , <END_VULN> . release = ftrace_regex_release , } ;
* dptr + + = ROSE_GFI | lci1 ; * dptr + + = lci2 ; * dptr + + = frametype ; <START_VULN> * dptr + + = 0xAA ; <END_VULN> memcpy(dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr + = ROSE_ADDR_LEN ; memcpy(dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ;
qsort(sortpointer , n , sizeof( * sortpointer ) , icomp ) ; for(i = 0 ; i < n ; i + + ) look -> forward_index [ i ] = sortpointer [ i ] - info -> postlist ; for(i = 0 ; i < n ; i + + ) look -> reverse_index [ look -> forward_index [ i ] ] = i ; for(i = 0 ; i < n ; i + + ) look -> sorted_index [ i ] = info -> postlist [ look -> forward_index [ i ] ] ; <START_VULN> <END_VULN> switch(info -> mult ) { case 1 : look -> quant_q = 256 ; break ; case 2 : look -> quant_q = 128 ; break ;
if ( ! ip6_checkentry( & e -> ipv6 ) ) return - EINVAL ; <START_VULN> ret = xt_compat_check_entry_offsets(e , <END_VULN> e -> target_offset , e -> next_offset ) ; if (ret ) return ret ;
if (IS_ERR(prog ) ) return prog ; <START_VULN> atomic_inc( & prog -> aux -> refcnt ) ; <END_VULN> fdput(f ) ; return prog ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : normalized modified discrete cosine transform power of two length transform only [ 64 <= n ] <START_VULN> last mod : $ Id : mdct . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> Original algorithm adapted long ago from _The use of multirate filter banks for coding of high quality digital audio_ , by T . Sporer , K . Brandenburg and B . Edler , collection of the European Signal Processing Conference (EUSIPCO ) , Amsterdam , June 1992 , Vol . 1 , pp 211 - 214 The below code implements an algorithm that no longer looks much like
rkey = s2s_route_key(NULL , to -> domain , from -> domain ) ; attr = nad_find_attr(nad , 0 , - 1 , "type" , "valid" ) ; <START_VULN> if(attr >= 0 ) { <END_VULN> xhash_put(in -> states , pstrdup(xhash_pool(in -> states ) , rkey ) , (void * ) conn_VALID ) ; log_write(in -> s2s -> log , LOG_NOTICE , " [ % d ] [ % s , port = % d ] incoming route ' % s' is now valid % s % s" , in -> fd -> fd , in -> ip , in -> port , rkey , (in -> s -> flags & SX_SSL_WRAPPER ) ? " , TLS negotiated" : "" , in -> s -> compressed ? " , ZLIB compression enabled" : "" ) ; valid = 1 ;
goto fail ; } <START_VULN> spin_unlock_irqrestore( & dev -> lock , flags ) ; <END_VULN>
for (bit = find_first_bit( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit( & bm -> word , bm -> depth , bit + 1 ) ) { <START_VULN> rq = blk_mq_tag_to_rq(hctx -> tags , off + bit ) ; <END_VULN> if (rq -> q == hctx -> queue ) fn(hctx , rq , data , reserved ) ; }
static void tokenadd(struct jv_parser * p , char c ) { assert(p -> tokenpos <= p -> tokenlen ) ; <START_VULN> if (p -> tokenpos == p -> tokenlen ) { <END_VULN> p -> tokenlen = p -> tokenlen * 2 + 256 ; p -> tokenbuf = jv_mem_realloc(p -> tokenbuf , p -> tokenlen ) ; }
0 . 9999998698F , 0 . 9999998906F , 0 . 9999999088F , 0 . 9999999246F , 0 . 9999999383F , 0 . 9999999500F , 0 . 9999999600F , 0 . 9999999684F , 0 . 9999999754F , 0 . 9999999811F , 0 . 9999999858F , 0 . 9999999896F , 0 . 9999999925F , 0 . 9999999948F , 0 . 9999999965F , 0 . 9999999978F , 0 . 9999999986F , 0 . 9999999992F , 0 . 9999999996F , 0 . 9999999998F , 0 . 9999999999F , 1 . 0000000000F , 1 . 0000000000F , 1 . 0000000000F , } ; <START_VULN> static float vwin8192 [ 4096 ] = { <END_VULN> 0 . 0000000578F , 0 . 0000005198F , 0 . 0000014438F , 0 . 0000028299F , 0 . 0000046780F , 0 . 0000069882F , 0 . 0000097604F , 0 . 0000129945F , 0 . 0000166908F , 0 . 0000208490F , 0 . 0000254692F , 0 . 0000305515F , 0 . 0000360958F , 0 . 0000421021F , 0 . 0000485704F , 0 . 0000555006F , 0 . 0000628929F , 0 . 0000707472F , 0 . 0000790635F , 0 . 0000878417F , 0 . 0000970820F , 0 . 0001067842F , 0 . 0001169483F , 0 . 0001275744F , 0 . 0001386625F , 0 . 0001502126F , 0 . 0001622245F , 0 . 0001746984F , 0 . 0001876343F , 0 . 0002010320F , 0 . 0002148917F , 0 . 0002292132F ,
for(i = 0 , l = 0 ; i < partvals ; l + + ) { if(s == 0 ) { for(j = 0 ; j < ch ; j + + ) { int temp = vorbis_book_decode(look -> phrasebook , & vb -> opb ) ; <START_VULN> if(temp == - 1 ) goto eopbreak ; <END_VULN> partword [ j ] [ l ] = look -> decodemap [ temp ] ; if(partword [ j ] [ l ] == NULL ) goto errout ; } } for(k = 0 ; k < partitions_per_word && i < partvals ; k + + , i + + ) for(j = 0 ; j < ch ; j + + ) {
rcu_assign_pointer(vq -> private_data , oldsock ) ; vhost_net_enable_vq(n , vq ) ; if (ubufs ) <START_VULN> vhost_net_ubuf_put_and_wait(ubufs ) ; <END_VULN> err_ubufs : fput(sock -> file ) ; err_vq :
next_image -> depth = 16 ; monochrome = IsImageMonochrome(image ) && (image -> depth == 1 ) ? MagickTrue : MagickFalse ; <START_VULN> quantum_info = AcquireQuantumInfo(image_info , image ) ; <END_VULN> if (quantum_info == (QuantumInfo * ) NULL ) return(0 ) ; pixels = (unsigned char * ) GetQuantumPixels(quantum_info ) ;
size_t mjitDataSize ; #endif <START_VULN> bool inOOMReport ; <END_VULN> #if defined(MOZ_GCTIMER ) || defined(JSGC_TESTPILOT ) struct GCData { uint64 firstEnter ; bool firstEnterValid ;
fprintf(stderr , "Unable to select public key file : % s" , sc_strerror(r ) ) ; return 2 ; } <START_VULN> bufsize = file -> size ; <END_VULN> sc_file_free(file ) ; r = sc_read_binary(card , 0 , buf , bufsize , 0 ) ; if (r < 0 ) {
if ( ! str ) return false ; size_t length ; const jschar * chars = JS_GetStringCharsAndLength(cx , str , & length ) ; if ( ! chars ) return false ; NS_ConvertUTF16toUTF8 utf8str(reinterpret_cast < const PRUnichar * > (chars ) ) ; #ifdef ANDROID <START_VULN> __android_log_print(ANDROID_LOG_INFO , "Gecko" , utf8str . get( ) ) ; <END_VULN> #endif fputs(utf8str . get( ) , stdout ) ; fflush(stdout ) ; return true ; }
} } ; <START_VULN> MODULE_ALIAS("sha512" ) ; <END_VULN> static int sha384_init(struct shash_desc * desc ) {
return NULL ; } <START_VULN> ret = snprintf(dest , len , " % slocklxc % s" , rundir , p ) ; <END_VULN> if (ret < 0 || ret >= len ) { free(dest ) ; free(rundir ) ;
JS_BEGIN_EXTERN_C extern JSClass js_MathClass ; extern JSObject * js_InitMathClass(JSContext * cx , JSObject * obj ) ; extern void <START_VULN> js_InitRandom(JSThreadData * data ) ; <END_VULN> extern JSBool js_math_ceil(JSContext * cx , uintN argc , jsval * vp ) ; extern JSBool js_math_floor(JSContext * cx , uintN argc , jsval * vp ) ; extern JSBool
CVE_2011_1495__ctl_diag_read_buffer(void __user * arg , enum block_state state ) { struct mpt2_diag_read_buffer karg ; struct mpt2_diag_read_buffer __user * uarg = arg ; struct MPT2SAS_ADAPTER * ioc ; void * request_data , * diag_data ; Mpi2DiagBufferPostRequest_t * mpi_request ; Mpi2DiagBufferPostReply_t * mpi_reply ; int rc , i ; u8 buffer_type ; <START_VULN> unsigned long timeleft ; <END_VULN> u16 smid ; u16 ioc_status ; u8 issue_reset = 0 ; if (copy_from_user( & karg , arg , sizeof(karg ) ) ) { printk(KERN_ERR "failure at % s : % d % s( ) ! " , __FILE__ , __LINE__ , __func__ ) ; return - EFAULT ; } if (_ctl_verify_adapter(karg . hdr . ioc_number , & ioc ) == - 1 || ! ioc )
vlan = __skb_header_pointer(skb , nhoff , sizeof(_vlan ) , data , hlen , & _vlan ) ; if ( ! vlan ) <START_VULN> return false ; <END_VULN> if (skb_flow_dissector_uses_key(flow_dissector , FLOW_DISSECTOR_KEY_VLANID ) ) {
if (is_limited_pmc(i + 1 ) ) continue ; val = read_pmc(i + 1 ) ; <START_VULN> if ((int ) val < 0 ) <END_VULN> write_pmc(i + 1 , 0 ) ; } }
share -> kfile = - 1 ; (void ) mysql_file_close(new_file , MYF(MY_WME ) ) ; if (change_to_newfile(share -> index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT , <START_VULN> MYF(0 ) ) || <END_VULN> mi_open_keyfile(share ) ) goto err2 ; info -> lock_type = F_UNLCK ;
nsIAtom * aAttribute , PRInt32 aModType ) ; nsresult GetText(nsString & aText ) ; NS_DECL_QUERYFRAME public : <START_VULN> void FireOnInput( ) ; <END_VULN> void SetValueChanged(PRBool aValueChanged ) ; nsresult InitFocusedValue( ) ; void SetFireChangeEventState(PRBool aNewState ) { mFireChangeEventState = aNewState ; }
return 1 ; case GSI_GET_HWRPB : <START_VULN> if (nbytes < sizeof( * hwrpb ) ) <END_VULN> return - EINVAL ; if (copy_to_user(buffer , hwrpb , nbytes ) != 0 ) return - EFAULT ;
phar_flush(phar_obj -> arc . archive , NULL , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; }
static int hns_xgmac_get_sset_count(int stringset ) { <START_VULN> if (stringset == ETH_SS_STATS ) <END_VULN> return ARRAY_SIZE(g_xgmac_stats_string ) ; return 0 ;
char * src ; char * dest = RUN_XAUTHORITY_FILE ; <START_VULN> <END_VULN> FILE * fp = fopen(dest , "w" ) ; if (fp ) { fprintf(fp , "" ) ;
flags |= IS_RDONLY(d_inode(lower_dentry ) ) ? O_RDONLY : O_RDWR ; ( * lower_file ) = dentry_open( & req . path , flags , cred ) ; if ( ! IS_ERR( * lower_file ) ) <START_VULN> goto out ; <END_VULN> if ((flags & O_ACCMODE ) == O_RDONLY ) { rc = PTR_ERR(( * lower_file ) ) ; goto out ;
if (unlikely(req -> src != req -> dst ) ) { scatterwalk_start( & dst_sg_walk , req -> dst ) ; dst = scatterwalk_map( & dst_sg_walk ) ; } } else { src = kmalloc(req -> cryptlen + req -> assoclen , GFP_ATOMIC ) ; if ( ! src ) return - ENOMEM ; <START_VULN> assoc = (src + req -> cryptlen + auth_tag_len ) ; <END_VULN> scatterwalk_map_and_copy(src , req -> src , 0 , req -> cryptlen , 0 ) ; scatterwalk_map_and_copy(assoc , req -> assoc , 0 , req -> assoclen , 0 ) ; dst = src ; } aesni_gcm_dec(aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , (unsigned long ) req -> assoclen , authTag , auth_tag_len ) ;
remote_path_check : <START_VULN> if ( ! rc && cifs_sb -> prepathlen && tcon ) { <END_VULN> full_path = cifs_build_path_to_root(cifs_sb , tcon ) ; if (full_path == NULL ) {
struct list_head s_es_list ; long s_es_nr_inode ; struct ext4_es_stats s_es_stats ; <START_VULN> struct mb_cache * s_mb_cache ; <END_VULN> spinlock_t s_es_lock ____cacheline_aligned_in_smp ;
if (type == DNS_T_PTR ) { add_assoc_string( * subarray , "type" , "PTR" , 1 ) ; } <START_VULN> n = dn_expand(answer -> qb2 , answer -> qb2 + 65536 , cp , name , (sizeof name ) - 2 ) ; <END_VULN> if (n < 0 ) { return NULL ; }
skb -> ip_summed = CHECKSUM_NONE ; <START_VULN> if ((skb_headroom(skb ) < frag_hdr_sz ) && <END_VULN> pskb_expand_head(skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ;
. index_key . type = type , . index_key . description = description , . cred = current_cred( ) , <START_VULN> . match_data . cmp = type -> match , <END_VULN> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK ,
char line [ MAX_URL_SIZE ] ; int err = 0 ; <START_VULN> s -> chunksize = - 1 ; <END_VULN> for ( ; ; ) { if ((err = http_get_line(s , line , sizeof(line ) ) ) < 0 )
proto_tree_add_text(sched_subtree , tvb , offset , 1 , "Slot : % d reserved MDT : % x" , new_slots [ k ] , octet1 ) ; other_slots [ new_slots [ i ] - 1 ] = 0xFFFE ; } } proto_item_set_end(item , tvb , offset ) ; item = proto_tree_add_text(sched_tree , tvb , offset , 0 , "Other message slots in this schedule" ) ; sched_subtree = proto_item_add_subtree(item , ett_schedule_new_msg ) ; <START_VULN> for (k = 0 ; offset < len ; j + + ) <END_VULN> { while ((other_slots [ k ] != 0xFFFF ) && (k < sched_end ) ) { k + + ; } if (k >= sched_end ) break ; octet1 = tvb_get_guint8(tvb , offset ) ; if ((octet1 & 0x80 ) == 0x80 )
cli_dbgmsg("cli_scanxar : can't scan xar files , need libxml2 . " ) ; #endif if (cksum_fails + extract_errors != 0 ) { <START_VULN> cli_warnmsg("cli_scanxar : % u checksum errors and % u extraction errors , use -- debug for more info . " , <END_VULN> cksum_fails , extract_errors ) ; }
NSS_CMSSignerInfo_Sign(NSSCMSSignerInfo * signerinfo , SECItem * digest , SECItem * contentType ) { CERTCertificate * cert ; SECKEYPrivateKey * privkey = NULL ; SECOidTag digestalgtag ; SECOidTag pubkAlgTag ; SECItem signature = { 0 } ; SECStatus rv ; <START_VULN> PLArenaPool * poolp , * tmppoolp ; <END_VULN> SECAlgorithmID * algID , freeAlgID ; CERTSubjectPublicKeyInfo * spki ; PORT_Assert (digest != NULL ) ; poolp = signerinfo -> cmsg -> poolp ; switch (signerinfo -> signerIdentifier . identifierType ) {
char * ptr ; int err ; <START_VULN> file = kmalloc(sizeof( * file ) , GFP_NOIO ) ; <END_VULN> if ( ! file ) return - ENOMEM ;
{ struct sock * sk = skb -> sk ; struct inet_sock * inet = inet_sk(sk ) ; <START_VULN> struct ip_options * opt = inet -> opt ; <END_VULN> struct rtable * rt ; struct iphdr * iph ; int res ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : PCM data envelope analysis and manipulation <START_VULN> last mod : $ Id : envelope . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_ENVELOPE_ #define _V_ENVELOPE_ #include "mdct . h"
data . period = event -> hw . last_period ; if (alpha_perf_event_set_period(event , hwc , idx ) ) { <START_VULN> if (perf_event_overflow(event , 1 , & data , regs ) ) { <END_VULN>
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : readcdf . c , v 1 . 39 20140227 23 : 26 : 18 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
newExtIndex = newIndex ; } } <START_VULN> if (newIndex < 256 ) <END_VULN> newName [ newIndex + + ] = curr ; else needsCRC = 1 ;
nsCOMPtr < nsIPrincipal > mSystemPrincipal ; nsCOMPtr < nsIXPConnectJSObjectHolder > mLoaderGlobal ; JSRuntime * mRuntime ; JSContext * mContext ; class ModuleEntry : public mozilla : : Module { public : <START_VULN> ModuleEntry( ) : mozilla : : Module( ) { <END_VULN> mVersion = mozilla : : Module : : kVersion ; mCIDs = nullptr ; mContractIDs = nullptr ; mCategoryEntries = nullptr ; getFactoryProc = GetFactory ; loadProc = nullptr ; unloadProc = nullptr ;
void __user * buffer , size_t * lenp , loff_t * ppos ) { <START_VULN> int ret = proc_dointvec(table , write , buffer , lenp , ppos ) ; <END_VULN> if (ret || ! write ) return ret ;
i = 0 ; <START_VULN> while ( (tmpName [ i ] != 0 ) && (i < to_read ) ) { <END_VULN> i + + ; }
dev -> udev = interface_to_usbdev(intf ) ; for (i = 0 ; i < icount ; i + + ) { <START_VULN> dev -> canch [ i ] = gs_make_candev(i , intf , & dconf ) ; <END_VULN> if (IS_ERR_OR_NULL(dev -> canch [ i ] ) ) { rc = PTR_ERR(dev -> canch [ i ] ) ;
inp = buf -> base ; max = buf -> base + buf -> next - trunto ; <START_VULN> if ((ret = xd3_read_uint32_t (stream , & inp , max , & rval ) ) != <END_VULN> XD3_INVALID_INPUT || ! MSG_IS (msg ) ) {
} _iov = iov + ret ; size = reg -> memory_size - addr + reg -> guest_phys_addr ; <START_VULN> _iov -> iov_len = min((u64 ) len , size ) ; <END_VULN> _iov -> iov_base = (void __user * ) (unsigned long ) (reg -> userspace_addr + addr - reg -> guest_phys_addr ) ; s + = size ;
#define AUDITSC_SUCCESS 1 #define AUDITSC_FAILURE 2 <START_VULN> <END_VULN> #define MAX_EXECVE_AUDIT_LEN 7500
if (plugin_data ) { mnd_efree(plugin_data ) ; } <START_VULN> <END_VULN> if (ret == PASS ) { DBG_INF_FMT("saving requested_protocol = % s" , requested_protocol ) ; conn -> m -> set_client_option(conn , MYSQLND_OPT_AUTH_PROTOCOL , requested_protocol TSRMLS_CC ) ;
Sdb * sdb_parent = sdb_new0 ( ) ; isum + = aux . vda_next ; vstart + = aux . vda_next ; <START_VULN> if (vstart > end || vstart + sizeof(Elf_(Verdaux ) ) > end ) { <END_VULN> sdb_free (sdb_verdef ) ; sdb_free (sdb_parent ) ; goto out_error ;
list_del_init( & u -> link ) ; unix_tot_inflight -- ; } <START_VULN> fp -> f_cred -> user -> unix_inflight -- ; <END_VULN> spin_unlock( & unix_gc_lock ) ; }
int xt_register_matches(struct xt_match * match , unsigned int n ) ; void xt_unregister_matches(struct xt_match * match , unsigned int n ) ; <START_VULN> int xt_check_entry_offsets(const void * base , <END_VULN> unsigned int target_offset , unsigned int next_offset ) ;
void * jas_malloc(size_t size ) { void * result ; <START_VULN> JAS_DBGLOG(101 , ("jas_malloc called with % zu" , size ) ) ; <END_VULN> result = malloc(size ) ; JAS_DBGLOG(100 , ("jas_malloc( % zu ) -> % p" , size , result ) ) ; return result ;
int hns_rcb_get_ring_sset_count(int stringset ) { <START_VULN> if (stringset == ETH_SS_STATS ) <END_VULN> return HNS_RING_STATIC_REG_NUM ; return 0 ;
} <START_VULN> CWD_API void realpath_cache_del(const char * path , int path_len ) <END_VULN> { zend_ulong key = realpath_cache_key(path , path_len ) ; zend_ulong n = key % (sizeof(CWDG(realpath_cache ) ) sizeof(CWDG(realpath_cache ) [ 0 ] ) ) ;
FlatpakProxy * proxy ; gboolean authenticated ; <START_VULN> int auth_end_offset ; <END_VULN> ProxySide client_side ; ProxySide bus_side ;
if (verbose ) appendPQExpBuffer( & sql , " (VERBOSE ) " ) ; <START_VULN> appendPQExpBuffer( & sql , " SYSTEM % s ; " , PQdb(conn ) ) ; <END_VULN> if ( ! executeMaintenanceCommand(conn , sql . data , echo ) ) {
} <START_VULN> if (i > (sizeof(outbuff ) - 20 ) ) { <END_VULN> outbuff [ i ] = '0' ; fprintf(f , " % s" , outbuff ) ; i = 0 ;
nsIPrincipal * originPrincipal , nsISupports * context , const nsACString & mimeType , nsISupports * extra , int16_t * decision , nsIContentPolicy * policyService = nullptr , nsIScriptSecurityManager * aSecMan = nullptr ) { <START_VULN> CHECK_PRINCIPAL ; <END_VULN> if (policyService ) { CHECK_CONTENT_POLICY_WITH_SERVICE(ShouldProcess , policyService ) ; } CHECK_CONTENT_POLICY(ShouldProcess ) ; } #undef CHECK_CONTENT_POLICY #undef CHECK_CONTENT_POLICY_WITH_SERVICE
error = cxgb3_ofld_send(tdev , skb ) ; if (error < 0 ) kfree_skb(skb ) ; <START_VULN> return error ; <END_VULN> } static void release_tid(struct t3cdev * tdev , u32 hwtid , struct sk_buff * skb )
} <START_VULN> if (buf -> pts == AV_NOPTS_VALUE ) { <END_VULN> return write_to_fifo(s -> fifo , buf ) ; }
static void * arm_coherent_dma_alloc(struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { <START_VULN> pgprot_t prot = __get_dma_pgprot(attrs , pgprot_kernel ) ; <END_VULN> void * memory ; if (dma_alloc_from_coherent(dev , size , handle , & memory ) )
typedef void vorbis_info_residue ; typedef void vorbis_info_mapping ; #include "psy . h" #include "bitrate . h" typedef struct private_state { <START_VULN> envelope_lookup * ve ; <END_VULN> int window [ 2 ] ; vorbis_look_transform ** transform [ 2 ] ; drft_lookup fft_look [ 2 ] ; int modebits ; vorbis_look_floor ** flr ; vorbis_look_residue ** residue ; vorbis_look_psy * psy ;
} if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; RETURN_FALSE ; }
plgctx = pkinit_find_realm_context(context , moddata , request -> server ) ; if (plgctx == NULL ) { <START_VULN> ( * respond ) (arg , 0 , NULL , NULL , NULL ) ; <END_VULN> return ; }
NS_DECL_ISUPPORTS NS_DECL_NSIWEBGLPROGRAM protected : WebGLuint mName ; PRPackedBool mDeleted ; PRPackedBool mDeletePending ; PRPackedBool mLinkStatus ; <START_VULN> nsTArray < WebGLShader * > mAttachedShaders ; <END_VULN> CheckedUint32 mGeneration ; nsRefPtrHashtable < nsUint32HashKey , WebGLUniformLocation > mMapUniformLocations ; GLint mUniformMaxNameLength ; GLint mAttribMaxNameLength ; GLint mUniformCount ; GLint mAttribCount ;
if (PASS == conn -> m -> local_tx_start(conn , this_func TSRMLS_CC ) ) { ret = conn -> m -> query(conn , "COMMIT" , sizeof("COMMIT" ) - 1 TSRMLS_CC ) ; <START_VULN> conn -> m -> local_tx_end(conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_RETURN(ret ) ;
ide_set_irq(s -> bus ) ; return false ; case SMART_EXECUTE_OFFLINE : switch (s -> sector ) { case 0 : case 1 : case 2 : s -> smart_selftest_count + + ; if (s -> smart_selftest_count > 21 ) { <START_VULN> s -> smart_selftest_count = 0 ; <END_VULN> } n = 2 + (s -> smart_selftest_count - 1 ) * 24 ; s -> smart_selftest_data [ n ] = s -> sector ; s -> smart_selftest_data [ n + 1 ] = 0x00 ; s -> smart_selftest_data [ n + 2 ] = 0x34 ; s -> smart_selftest_data [ n + 3 ] = 0x12 ; break ; default : goto abort_cmd ; }
skb_reset_network_header(skb ) ; memcpy(skb_network_header(skb ) , tmp_hdr , hlen ) ; <START_VULN> ipv6_select_ident(fh ) ; <END_VULN> fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons(IP6_MF ) ;
if (haveQuote ) { cmd + + ; <START_VULN> p = find_eoq (cmd + 1 ) ; <END_VULN> if ( ! p || ! * p ) { eprintf ("Missing " in ( % s ) . " , cmd ) ; return false ;
memset(state , 128 , sizeof(state ) ) ; if (f -> version < 2 ) { <START_VULN> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <END_VULN> unsigned v = get_symbol(c , state , 0 ) ; if (v >= 2 ) { av_log(f -> avctx , AV_LOG_ERROR , "invalid version % d in ver01 header" , v ) ;
MODULE_LICENSE("GPL" ) ; MODULE_ALIAS_RTNL_LINK("gre" ) ; MODULE_ALIAS_RTNL_LINK("gretap" ) ; <START_VULN> MODULE_ALIAS("gre0" ) ; <END_VULN>
unsigned int mc_saved_count = mc_saved_data -> mc_saved_count ; int i ; <START_VULN> while (leftover ) { <END_VULN> mc_header = (struct microcode_header_intel * ) ucode_ptr ; mc_size = get_totalsize(mc_header ) ;
if(i == ch ) return(0 ) ; for(s = 0 ; s < look -> stages ; s + + ) { for(i = 0 , l = 0 ; i < partvals ; l + + ) { if(s == 0 ) { int temp = vorbis_book_decode(look -> phrasebook , & vb -> opb ) ; <START_VULN> if(temp == - 1 ) goto eopbreak ; <END_VULN> partword [ l ] = look -> decodemap [ temp ] ; if(partword [ l ] == NULL ) goto errout ; } for(k = 0 ; k < partitions_per_word && i < partvals ; k + + , i + + ) if(info -> secondstages [ partword [ l ] [ k ] ] & (1 << s ) ) { codebook * stagebook = look -> partbooks [ partword [ l ] [ k ] ] [ s ] ;
SSL_TRC(3 , (" % d : SSL3 [ % d ] : handle certificate_verify handshake" , SSL_GETPID( ) , ss -> fd ) ) ; PORT_Assert( ss -> opt . noLocks || ssl_HaveRecvBufLock(ss ) ) ; PORT_Assert( ss -> opt . noLocks || ssl_HaveSSL3HandshakeLock(ss ) ) ; isTLS = (PRBool ) (ss -> ssl3 . prSpec -> version > SSL_LIBRARY_VERSION_3_0 ) ; isTLS12 = (PRBool ) (ss -> ssl3 . prSpec -> version >= SSL_LIBRARY_VERSION_TLS_1_2 ) ; <START_VULN> if (ss -> ssl3 . hs . ws != wait_cert_verify || ss -> sec . peerCert == NULL ) { <END_VULN> desc = unexpected_message ; errCode = SSL_ERROR_RX_UNEXPECTED_CERT_VERIFY ; goto alert_loser ; } if (isTLS12 ) { rv = ssl3_ConsumeSignatureAndHashAlgorithm(ss , & b , & length , & sigAndHash ) ;
} } else #endif <START_VULN> for(i = 0 ; i <= w - sizeof(long ) ; i + = sizeof(long ) ) { <END_VULN> long a = * (long * ) (src1 + i ) ; long b = * (long * ) (src2 + i ) ; * (long * ) (dst + i ) = ((a | pb_80 ) - (b & pb_7f ) ) ^ ((a ^ b ^ pb_80 ) & pb_80 ) ;
} } } <START_VULN> <END_VULN> if (context && php_stream_context_get_option(context , "http" , "protocol_version" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL(tmpzval ) ; convert_to_double_ex(tmpzval ) ;
#if defined(MSDOS ) || defined(WIN32 ) <START_VULN> char * sanitize_dos_name(char * file_name ) ; <END_VULN> #if defined(MSDOS ) && (defined(__DJGPP__ ) || defined(__GO32__ ) )
* out = NULL ; * out_len = 0 ; <START_VULN> <END_VULN> if ((hdr_sz( & base_sz , & delta , delta_end ) < 0 ) || (base_sz != base_len ) ) { giterr_set(GITERR_INVALID , "failed to apply delta : base size does not match given data" ) ; return - 1 ;
} } <START_VULN> if (context && <END_VULN> php_stream_context_get_option(context , "http" , "user_agent" , & ua_zval ) == SUCCESS && Z_TYPE_PP(ua_zval ) == IS_STRING ) { ua_str = Z_STRVAL_PP(ua_zval ) ;
SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext ) { <START_VULN> char * Name ; <END_VULN> SECURITY_STATUS status ; SecurityFunctionTableA * table ;
phar_flush(phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; }
extern key_ref_t search_my_process_keyrings(struct keyring_search_context * ctx ) ; extern key_ref_t search_process_keyrings(struct keyring_search_context * ctx ) ; <START_VULN> extern struct key * find_keyring_by_name(const char * name , bool skip_perm_check ) ; <END_VULN> extern int install_user_keyrings(void ) ; extern int install_thread_keyring_to_cred(struct cred * ) ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : readelf . c , v 1 . 137 20170813 00 : 21 : 47 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
return ret ; } <START_VULN> static void ptrace_triggered(struct perf_event * bp , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) {
tmp -> dev = skb -> dev ; memcpy(skb_put(tmp , hdrlen ) , skb -> data , hdrlen ) ; memcpy(skb_put(tmp , fraglen ) , skb -> data + pos , fraglen ) ; pos + = fraglen ; } <START_VULN> skb -> len = hdrlen + per_fragm ; <END_VULN> return 0 ; }
pch -> ppp = NULL ; pch -> chan = chan ; <START_VULN> pch -> chan_net = net ; <END_VULN> chan -> ppp = pch ; init_ppp_file( & pch -> file , CHANNEL ) ; pch -> file . hdrlen = chan -> hdrlen ;
gss_ctx_id_t * context_handle , gss_buffer_t output_token ) { <START_VULN> OM_uint32 major_status = GSS_S_COMPLETE ; <END_VULN> if (output_token != GSS_C_NO_BUFFER ) { output_token -> length = 0 ;
#ifdef FLOAT_LOOKUP #include "vorbis_lookup . c" void vorbis_lsp_to_curve(float * curve , int * map , int n , int ln , float * lsp , int m , <START_VULN> float amp , float ampoffset ) { <END_VULN> int i ; float wdel = M_PIln ; vorbis_fpu_control fpu ; vorbis_fpu_setround( & fpu ) ; for(i = 0 ; i < m ; i + + ) lsp [ i ] = vorbis_coslook(lsp [ i ] ) ; i = 0 ;
msr . host_initiated = false ; svm -> next_rip = kvm_rip_read( & svm -> vcpu ) + 2 ; <START_VULN> if (svm_set_msr( & svm -> vcpu , & msr ) ) { <END_VULN> trace_kvm_msr_write_ex(ecx , data ) ; kvm_inject_gp( & svm -> vcpu , 0 ) ; } else {
bool mListenerEnabled ; bool mReturnInEmptyLIKillsList ; bool mDidDeleteSelection ; bool mDidRangedDelete ; bool mRestoreContentEditableCount ; nsCOMPtr < nsIDOMRange > mUtilRange ; PRUint32 mJoinOffset ; nsCOMPtr < nsIDOMNode > mNewBlock ; <START_VULN> nsRangeStore mRangeItem ; <END_VULN> StyleCache mCachedStyles [ SIZE_STYLE_TABLE ] ; } ; #endif
. release = ext2_release_file , . fsync = ext2_fsync , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> } ; #ifdef CONFIG_EXT2_FS_XIP
e . endian = d [ 0 ] == 'I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG ; <START_VULN> ifd = iw_get_ui32_e( & d [ 4 ] , e . endian ) ; <END_VULN> iwjpeg_scan_exif_ifd(rctx , & e , ifd ) ; }
msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; <START_VULN> if (vmx_set_msr(vcpu , & msr ) != 0 ) { <END_VULN> trace_kvm_msr_write_ex(ecx , data ) ; kvm_inject_gp(vcpu , 0 ) ; return 1 ;
Com_Printf( " -- -- - Initializing Renderer -- -- " ) ; #ifdef USE_RENDERER_DLOPEN <START_VULN> cl_renderer = Cvar_Get("cl_renderer" , "opengl1" , CVAR_ARCHIVE | CVAR_LATCH ) ; <END_VULN> Com_sprintf(dllName , sizeof(dllName ) , "renderer_sp_ % s_" ARCH_STRING DLL_EXT , cl_renderer -> string ) ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : cdf . c , v 1 . 55 20140227 23 : 26 : 17 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
static void l2tp_eth_dev_setup(struct net_device * dev ) { ether_setup(dev ) ; <START_VULN> <END_VULN> dev -> netdev_ops = & l2tp_eth_netdev_ops ; dev -> destructor = free_netdev ; }
goto error ; if (IPV4_GET_IPTTL(p ) != ttl ) goto error ; <START_VULN> if (IPV4_GET_IPPROTO(p ) != IPPROTO_ICMP ) <END_VULN> goto error ; return p ;
fprintf(trace , "" KID = "" ) ; } dump_data_hex(trace , (char * ) ptr -> KID , 16 ) ; <START_VULN> if (ptr -> version ) <END_VULN> fprintf(trace , "" crypt_byte_block = " % d" skip_byte_block = " % d" , ptr -> crypt_byte_block , ptr -> skip_byte_block ) ; fprintf(trace , "" > " ) ; gf_isom_box_dump_done("TrackEncryptionBox" , a , trace ) ;
if (lpc_order == 31 ) { for (i = 1 ; i < nb_samples ; i + + ) { buffer_out [ i ] = sign_extend(buffer_out [ i - 1 ] + error_buffer [ i ] , bps ) ; } return ; } <START_VULN> for (i = 1 ; i <= lpc_order ; i + + ) <END_VULN> buffer_out [ i ] = sign_extend(buffer_out [ i - 1 ] + error_buffer [ i ] , bps ) ; for ( ; i < nb_samples ; i + + ) { int j ; int val = 0 ; int error_val = error_buffer [ i ] ; int error_sign ; int d = * pred + + ;
opthdr = __skb_header_pointer(skb , nhoff , sizeof(_opthdr ) , data , hlen , & _opthdr ) ; if ( ! opthdr ) <START_VULN> return false ; <END_VULN> ip_proto = opthdr [ 0 ] ; nhoff + = (opthdr [ 1 ] + 1 ) << 3 ;
struct task_struct * tsk = current ; struct sh_fpu_soft_struct * fpu = & (tsk -> thread . xstate -> softfpu ) ; <START_VULN> perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <END_VULN> if ( ! (task_thread_info(tsk ) -> status & TS_USEDFPU ) ) {
ether_setup(dev ) ; dev -> priv_flags |= IFF_802_1Q_VLAN ; <START_VULN> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <END_VULN> dev -> tx_queue_len = 0 ; dev -> netdev_ops = & vlan_netdev_ops ;
struct ext4_xattr_entry * entry ; size_t size ; int error ; <START_VULN> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE(inode ) ; <END_VULN> ea_idebug(inode , "name = % d . % s , buffer = % p , buffer_size = % ld" , name_index , name , buffer , (long ) buffer_size ) ;
{ DATA_TYPE * oX1 = out + n2 + n4 ; DATA_TYPE * oX2 = out + n2 + n4 ; DATA_TYPE * iX = out ; T = init -> trig + n2 ; <START_VULN> <END_VULN> do { oX1 -= 4 ; oX1 [ 3 ] = MULT_NORM (iX [ 0 ] * T [ 1 ] - iX [ 1 ] * T [ 0 ] ) ; oX2 [ 0 ] = - MULT_NORM (iX [ 0 ] * T [ 0 ] + iX [ 1 ] * T [ 1 ] ) ; oX1 [ 2 ] = MULT_NORM (iX [ 2 ] * T [ 3 ] - iX [ 3 ] * T [ 2 ] ) ; oX2 [ 1 ] = - MULT_NORM (iX [ 2 ] * T [ 2 ] + iX [ 3 ] * T [ 3 ] ) ;
#endif #ifdef HAVE_GNUTLS_GNUTLS_H <START_VULN> const int tls_kx_order [ ] = { <END_VULN> GNUTLS_KX_ANON_DH , GNUTLS_KX_DHE_RSA , GNUTLS_KX_DHE_DSS ,
seq_printf(m , "seedsize : % u" , seedsize(alg ) ) ; } <START_VULN> const struct crypto_type crypto_rng_type = { <END_VULN> . extsize = crypto_alg_extsize , . init_tfm = crypto_rng_init_tfm , #ifdef CONFIG_PROC_FS
case CSN_PADDING_BITS : { if (remaining_bits_len > 0 ) { proto_item * ti = proto_tree_add_text(tree , tvb , bit_offset >> 3 , - 1 , "Padding Bits" ) ; proto_tree * padding_tree = proto_item_add_subtree(ti , ett_csn1 ) ; while (remaining_bits_len > 0 ) { <START_VULN> guint8 bits_to_handle = remaining_bits_len + (bit_offset % 8 ) ; <END_VULN> if (bits_to_handle > 32 ) { bits_to_handle = 32 - (bit_offset % 8 ) ; } else { bits_to_handle -= (bit_offset % 8 ) ; } proto_tree_add_text(padding_tree , tvb , bit_offset >> 3 , ((bit_offset + bits_to_handle - 1 ) >> 3 ) - (bit_offset >> 3 ) + 1 , " % s % s" , decode_bits_in_field(bit_offset , bits_to_handle , tvb_get_bits(tvb , bit_offset , bits_to_handle , ENC_BIG_ENDIAN ) ) ,
e_hash - pointer to int for returning extracted checksum algorithm . returns - CL_FORMAT , CL_SUCCESS , CL_BREAK . CL_BREAK indicates no more < data > < ea > element . <START_VULN> static int xar_get_toc_data_values(xmlTextReaderPtr reader , long * length , long * offset , long * size , int * encoding , <END_VULN> unsigned char ** a_cksum , int * a_hash , unsigned char ** e_cksum , int * e_hash ) { const xmlChar * name ;
buf = buftmp ; if ((ret = avio_read(pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 ) { if (ret != AVERROR_EOF ) { av_free(buf ) ; return ret ; } score = 0 ; ret = 0 ; } <START_VULN> pd . buf_size + = ret ; <END_VULN> pd . buf = & buf [ offset ] ; memset(pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ) ; * fmt = av_probe_input_format2( & pd , 1 , & score ) ; if( * fmt ) { if(score <= AVPROBE_SCORE_MAX4 ) { av_log(logctx , AV_LOG_WARNING , "Format % s detected only with low score of % d , misdetection possible ! " , ( * fmt ) -> name , score ) ; } else
hdr = __skb_header_pointer(skb , nhoff , sizeof(_hdr ) , data , hlen , & _hdr ) ; if ( ! hdr ) <START_VULN> return false ; <END_VULN> if ((ntohl(hdr [ 0 ] . entry ) & MPLS_LS_LABEL_MASK ) >> MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY ) {
sem_rmid(ns , sma ) ; <START_VULN> sem_unlock(sma ) ; <END_VULN> wake_up_sem_queue_do( & tasks ) ; ns -> used_sems -= sma -> sem_nsems ;
uint32_t lineIndexToNum(uint32_t lineIndex ) const { return lineIndex + initialLineNum_ ; } uint32_t lineNumToIndex(uint32_t lineNum ) const { return lineNum - initialLineNum_ ; } public : SourceCoords(ExclusiveContext * cx , uint32_t ln ) ; void add(uint32_t lineNum , uint32_t lineStartOffset ) ; <START_VULN> void fill(const SourceCoords & other ) ; <END_VULN> bool isOnThisLine(uint32_t offset , uint32_t lineNum ) const { uint32_t lineIndex = lineNumToIndex(lineNum ) ; JS_ASSERT(lineIndex + 1 < lineStartOffsets_ . length( ) ) ; return lineStartOffsets_ [ lineIndex ] <= offset && offset < lineStartOffsets_ [ lineIndex + 1 ] ; }
goto out ; } <START_VULN> rc = ecryptfs_parse_options(sbi , raw_data ) ; <END_VULN> if (rc ) { err = "Error parsing options" ; goto out ;
rc = decode_operand(ctxt , & ctxt -> dst , (ctxt -> d >> DstShift ) & OpMask ) ; <START_VULN> if (ctxt -> rip_relative ) <END_VULN> ctxt -> memopp -> addr . mem . ea = address_mask(ctxt , ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ;
if (page == NULL ) page = http_request_get_query_string(req ) ; <START_VULN> if (page && (access(page , R_OK ) == 0 ) ) <END_VULN> { http_response_printf(res , "success" ) ; http_response_send(res ) ;
err = blkdev_issue_discard(bdev , req -> u . discard . sector_number , req -> u . discard . nr_sectors , GFP_KERNEL , secure ) ; <START_VULN> <END_VULN> if (err == - EOPNOTSUPP ) { pr_debug(DRV_PFX "discard op failed , not supported" ) ; status = BLKIF_RSP_EOPNOTSUPP ;
if (tstate & TSTATE_PRIV ) die_if_kernel("unfinishedunimplemented FPop from kernel" , regs ) ; <START_VULN> perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <END_VULN> if (test_thread_flag(TIF_32BIT ) ) pc = (u32 ) pc ; if (get_user(insn , (u32 __user * ) pc ) != - EFAULT ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis codec headers <START_VULN> last mod : $ Id : codec . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _vorbis_codec_h_ #define _vorbis_codec_h_ #ifdef __cplusplus extern "C"
} <START_VULN> static void phar_file_stat(const char * filename , php_stat_len filename_length , int type , void ( * orig_stat_func ) (INTERNAL_FUNCTION_PARAMETERS ) , INTERNAL_FUNCTION_PARAMETERS ) <END_VULN> { if ( ! filename_length ) { RETURN_FALSE ;
#include < stdlib . h > #include < stdio . h > #include < string . h > #include < ctype . h > <START_VULN> #include "compilerdebug . h"<END_VULN> #include "compilerpreprocessorslglobals . h" #include "compilerutil . h"
char * src ; char * dest = RUN_ASOUNDRC_FILE ; <START_VULN> <END_VULN> FILE * fp = fopen(dest , "w" ) ; if (fp ) { fprintf(fp , "" ) ;
. compat_ioctl = compat_blkdev_ioctl , #endif . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> } ; int ioctl_by_bdev(struct block_device * bdev , unsigned cmd , unsigned long arg )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : #ifdef jail to whip a few platforms into the UNIX ideal . <START_VULN> last mod : $ Id : os . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifdef HAVE_CONFIG_H #include "config . h" #endif #include < math . h >
hdr = __skb_header_pointer(skb , nhoff , sizeof(_hdr ) , data , hlen , & _hdr ) ; if ( ! hdr ) <START_VULN> return false ; <END_VULN>
newstate = nfs4_opendata_to_nfs4_state(opendata ) ; if (IS_ERR(newstate ) ) return PTR_ERR(newstate ) ; <START_VULN> nfs4_close_state( & opendata -> path , newstate , openflags ) ; <END_VULN> * res = newstate ; return 0 ; }
if ( ! (type -> fs_flags & FS_USERNS_DEV_MOUNT ) ) { flags |= MS_NODEV ; <START_VULN> mnt_flags |= MNT_NODEV ; <END_VULN> } }
module_init(aes_s390_init ) ; module_exit(aes_s390_fini ) ; <START_VULN> MODULE_ALIAS("aes - all" ) ; <END_VULN> MODULE_DESCRIPTION("Rijndael (AES ) Cipher Algorithm" ) ; MODULE_LICENSE("GPL" ) ;
* y0 = rint(a + b * x0 ) ; * y1 = rint(a + b * x1 ) ; if( * y0 > 1023 ) * y0 = 1023 ; if( * y1 > 1023 ) * y1 = 1023 ; if( * y0 < 0 ) * y0 = 0 ; if( * y1 < 0 ) * y1 = 0 ; <START_VULN> <END_VULN> return 0 ; } else { * y0 = 0 ; * y1 = 0 ; return 1 ; } } }
if ((int ) val < 0 ) { found = 1 ; <START_VULN> record_and_restart(event , val , regs , nmi ) ; <END_VULN> } }
void prependToViews(ArrayBufferViewObject * viewsHead ) ; <START_VULN> void neuter(JSContext * cx ) ; <END_VULN> static void trace(JSTracer * trc , JSObject * obj ) ; } ;
} } else { if (state -> array_nl ) ruby_xfree(state -> array_nl ) ; <START_VULN> state -> array_nl = strdup(RSTRING_PTR(array_nl ) ) ; <END_VULN> state -> array_nl_len = len ; } return Qnil ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : channel mapping 0 implementation <START_VULN> last mod : $ Id : mapping0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < stdio . h > #include < string . h > #include < math . h > #include < oggogg . h >
offset = skb_checksum_start_offset(skb ) ; csum = skb_checksum(skb , offset , skb -> len - offset , 0 ) ; offset + = skb -> csum_offset ; * (__sum16 * ) (skb -> data + offset ) = csum_fold(csum ) ; skb -> ip_summed = CHECKSUM_NONE ; tnl_hlen = skb_tnl_header_len(skb ) ; <START_VULN> if (skb_headroom(skb ) < (tnl_hlen + frag_hdr_sz ) ) { <END_VULN> if (gso_pskb_expand_head(skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt(skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = (skb_network_header(skb ) - skb_mac_header(skb ) ) + unfrag_ip6hlen + tnl_hlen ;
if (test ) { fname = test ; <START_VULN> fname_len = (php_stat_len ) strlen(fname ) ; <END_VULN> } else { zend_throw_exception_ex(spl_ce_UnexpectedValueException , 0 , "Could not resolve file path" ) ; return ZEND_HASH_APPLY_STOP ;
. write_iter = generic_file_write_iter , . fsync = noop_fsync , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . llseek = generic_file_llseek , } ;
const char * aPropertyName , const char * anInterfaceName , PRBool aForceReport ) ; private : nsXPCWrappedJSClass( ) ; not implemented nsXPCWrappedJSClass(XPCCallContext & ccx , REFNSIID aIID , nsIInterfaceInfo * aInfo ) ; <START_VULN> JSObject * NewOutObject(JSContext * cx ) ; <END_VULN> JSBool IsReflectable(uint16 i ) const { return (JSBool ) (mDescriptors [ i32 ] & (1 << (i % 32 ) ) ) ; } void SetReflectable(uint16 i , JSBool b ) { if(b ) mDescriptors [ i32 ] |= (1 << (i % 32 ) ) ; else mDescriptors [ i32 ] &= ~ (1 << (i % 32 ) ) ; } enum SizeMode { GET_SIZE , GET_LENGTH } ;
<START_VULN> <END_VULN> #define MEDIATYPE_TYPEMAX64
ctx = (krb5_gss_ctx_id_rec * ) context_handle ; <START_VULN> if ( ! ctx -> established ) <END_VULN> return GSS_S_NO_CONTEXT ; for (i = 0 ; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops )
vqc . id = control -> id ; rval = si4713_queryctrl( & sdev -> sd , & vqc ) ; if (rval < 0 ) goto exit ; switch (control -> id ) { case V4L2_CID_RDS_TX_PS_NAME : { char ps_name [ MAX_RDS_PS_NAME + 1 ] ; len = control -> size - 1 ; <START_VULN> if (len > MAX_RDS_PS_NAME ) { <END_VULN> rval = - ERANGE ; goto exit ; } rval = copy_from_user(ps_name , control -> string , len ) ; if (rval < 0 ) goto exit ; ps_name [ len ] = '0' ; if (strlen(ps_name ) % vqc . step ) { rval = - ERANGE ;
for (i = 0 ; i < 16 ; i + + ) { <START_VULN> Packet * p = BuildTestPacket(i , 0 , 1 , 'A' + i , 16 ) ; <END_VULN> if (p == NULL ) goto end ;
size2 = avio_rb32(pb ) ; ret = ff_rm_read_mdpr_codecdata(s , s -> pb , st2 , st2 -> priv_data , <START_VULN> size2 , mime ) ; <END_VULN> if (ret < 0 ) return ret ; }
WRITE32(OP_OPEN_DOWNGRADE ) ; WRITEMEM(arg -> stateid -> data , NFS4_STATEID_SIZE ) ; WRITE32(arg -> seqid -> sequence -> counter ) ; <START_VULN> encode_share_access(xdr , arg -> open_flags ) ; <END_VULN> return 0 ; }
fit_value [ i ] = val + predicted ; fit_value [ look -> loneighbor [ i - 2 ] ] &= 0x7fff ; fit_value [ look -> hineighbor [ i - 2 ] ] &= 0x7fff ; } else { fit_value [ i ] = predicted | 0x8000 ; } <START_VULN> <END_VULN> } return(fit_value ) ; } eop : return(NULL ) ; }
ext4_ext_show_leaf(inode , path ) ; <START_VULN> if (flags == EXT4_GET_BLOCKS_PRE_IO ) { <END_VULN> ret = ext4_split_unwritten_extents(handle , inode , path , iblock , max_blocks , flags ) ;
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID("@(# ) $ File : softmagic . c , v 1 . 196 20141107 15 : 24 : 14 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
} } else { if (state -> indent ) ruby_xfree(state -> indent ) ; <START_VULN> state -> indent = strdup(RSTRING_PTR(indent ) ) ; <END_VULN> state -> indent_len = len ; } return Qnil ;
{ ldblk = (ssize_t ) ((bpp * image -> columns + 7 ) 8 ) ; BImgBuff = (unsigned char * ) AcquireQuantumMemory((size_t ) <START_VULN> ldblk , sizeof( * BImgBuff ) ) ; <END_VULN> if (BImgBuff == (unsigned char * ) NULL ) goto NoMemory ;
asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; out_unlock : <START_VULN> bh_unlock_sock(asoc -> base . sk ) ; <END_VULN> sctp_association_put(asoc ) ; }
const char * last ; const char * buf ; const char * end ; <START_VULN> size_t lines , linecnt , bytecnt ; <END_VULN> if (s == NULL ) { ms -> search . s_len = 0 ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : lookup based functions <START_VULN> last mod : $ Id : lookup . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < math . h > #include "lookup . h" #include "lookup_data . h" #include "os . h" #include "misc . h"
<START_VULN> sk -> sk_rcvbuf = max_t(u32 , val * 2 , SOCK_MIN_RCVBUF ) ; <END_VULN> break ; case SO_RCVBUFFORCE :
bool GetHitRegionRect(Element * aElement , nsRect & aRect ) ; protected : nsresult GetImageDataArray(JSContext * aCx , int32_t aX , int32_t aY , uint32_t aWidth , uint32_t aHeight , JSObject ** aRetval ) ; nsresult PutImageData_explicit(int32_t x , int32_t y , uint32_t w , uint32_t h , <START_VULN> unsigned char * aData , uint32_t aDataLen , <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , int32_t dirtyWidth , int32_t dirtyHeight ) ; nsresult Initialize(int32_t width , int32_t height ) ;
password_empty = 1 ; } <START_VULN> } else { <END_VULN> cli_md5_init( & md5 ) ;
errx(EXIT_FAILURE , _("Shell * NOT * changed . Try again later . " ) ) ; #else pw -> pw_shell = info . shell ; <START_VULN> if (setpwnam(pw ) < 0 ) <END_VULN> err(EXIT_FAILURE , _("setpwnam failed" "Shell * NOT * changed . Try again later . " ) ) ; #endif
static long mem_seek(jas_stream_obj_t * obj , long offset , int origin ) { jas_stream_memobj_t * m = (jas_stream_memobj_t * ) obj ; <START_VULN> long newpos ; <END_VULN> JAS_DBGLOG(100 , ("mem_seek( % p , % ld , % d ) " , obj , offset , origin ) ) ; switch (origin ) {
cl_allowDownload = Cvar_Get ("cl_allowDownload" , "0" , CVAR_ARCHIVE ) ; #ifdef USE_CURL_DLOPEN <START_VULN> cl_cURLLib = Cvar_Get("cl_cURLLib" , DEFAULT_CURL_LIB , CVAR_ARCHIVE ) ; <END_VULN> #endif cl_conXOffset = Cvar_Get ("cl_conXOffset" , "0" , 0 ) ;
. fsync = ubifs_fsync , . unlocked_ioctl = ubifs_ioctl , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> #ifdef CONFIG_COMPAT . compat_ioctl = ubifs_compat_ioctl , #endif
struct pppol2tp_session * ps ; if (level != SOL_PPPOL2TP ) <START_VULN> return udp_prot . getsockopt(sk , level , optname , optval , optlen ) ; <END_VULN> if (get_user(len , optlen ) ) return - EFAULT ;
if(mech != NULL ) { _sx_debug(ZONE , "auth request from client (mechanism = % s ) " , mech ) ; <START_VULN> if( ! gsasl_server_support_p(ctx -> gsasl_ctx , mech ) ) { <END_VULN> _sx_debug(ZONE , "client requested mechanism ( % s ) that we didn't offer" , mech ) ; _sx_nad_write(s , _sx_sasl_failure(s , _sasl_err_INVALID_MECHANISM , NULL ) , 0 ) ; return ;
mutt_debug(2 , "Handling untagged NO" ) ; <START_VULN> mutt_error(" % s" , s + 3 ) ; <END_VULN> } return 0 ;
static void dns_resolver_describe(const struct key * key , struct seq_file * m ) { seq_puts(m , key -> description ) ; <START_VULN> if (key_is_instantiated(key ) ) { <END_VULN> int err = PTR_ERR(key -> payload . data [ dns_key_error ] ) ; if (err )
const struct xt_entry_target * t ; unsigned int verdict ; <START_VULN> if ( ! unconditional( & e -> arp ) ) <END_VULN> return false ; t = arpt_get_target_c(e ) ; if (strcmp(t -> u . user . name , XT_STANDARD_TARGET ) != 0 )
{ rtnl_link_unregister( & ipgre_tap_ops ) ; rtnl_link_unregister( & ipgre_link_ops ) ; <START_VULN> unregister_pernet_device( & ipgre_net_ops ) ; <END_VULN> if (inet_del_protocol( & ipgre_protocol , IPPROTO_GRE ) < 0 ) printk(KERN_INFO "ipgre close : can't remove protocol" ) ; } module_init(ipgre_init ) ;
memset( & fl6 , 0 , sizeof(fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_TCP ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; <START_VULN> final_p = fl6_update_dst( & fl6 , np -> opt , & final ) ; <END_VULN> fl6 . saddr = ireq -> ir_v6_loc_addr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = ireq -> ir_mark ;
} LOCAL(boolean ) get_sos (j_decompress_ptr cinfo ) { INT32 length ; <START_VULN> int i , ci , n , c , cc ; <END_VULN> jpeg_component_info * compptr ; INPUT_VARS(cinfo ) ; if ( ! cinfo -> marker -> saw_SOF ) ERREXIT(cinfo , JERR_SOS_NO_SOF ) ; INPUT_2BYTES(cinfo , length , return FALSE ) ;
if (ret != GSS_S_COMPLETE ) goto cleanup ; <START_VULN> sc = create_spnego_ctx( ) ; <END_VULN> if (sc == NULL ) { ret = GSS_S_FAILURE ; goto cleanup ;
guint8 * codepage_stag , guint8 * codepage_attr ) { guint32 tvb_len = tvb_reported_length (tvb ) ; <START_VULN> guint32 off = offset ; <END_VULN> guint32 len ; guint str_len ; guint32 ent ;
phar_flush(phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; }
} tmp = (char * ) php_base64_encode((unsigned char * ) scratch , strlen(scratch ) , NULL ) ; <START_VULN> <END_VULN> if (snprintf(scratch , scratch_len , "Authorization : Basic % sr" , tmp ) > 0 ) { php_stream_write(stream , scratch , strlen(scratch ) ) ; php_stream_notify_info(context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ;
if ( ! CDROM_CAN(CDC_SELECT_DISC ) || arg == CDSL_CURRENT ) return media_changed(cdi , 1 ) ; <START_VULN> if ((unsigned int ) arg >= cdi -> capacity ) <END_VULN> return - EINVAL ; info = kmalloc(sizeof( * info ) , GFP_KERNEL ) ;
if ((c = jas_stream_getc(in ) ) == EOF ) { return - 1 ; } <START_VULN> v |= (c << 24 ) ; <END_VULN> if ( -- n <= 0 ) { break ; }
u32 __user * optval , int __user * optlen ) { int rc = - ENOPROTOOPT ; <START_VULN> if (ccid -> ccid_ops -> ccid_hc_rx_getsockopt != NULL ) <END_VULN> rc = ccid -> ccid_ops -> ccid_hc_rx_getsockopt(sk , optname , len , optval , optlen ) ; return rc ;
int vorbis_synthesis_headerin(vorbis_info * vi , vorbis_comment * vc , ogg_packet * op ) { oggpack_buffer opb ; <START_VULN> <END_VULN> if(op ) { oggpack_readinit( & opb , op -> packet , op -> bytes ) ; { char buffer [ 6 ] ; int packtype = oggpack_read( & opb , 8 ) ;
Token currentToken ; unsigned lookahead ; Token lookaheadTokens [ maxLookahead ] ; } ; void advance(size_t position ) ; void tell(Position * ) ; void seek(const Position & pos ) ; <START_VULN> void seek(const Position & pos , const TokenStream & other ) ; <END_VULN> void positionAfterLastFunctionKeyword(Position & pos ) ; size_t positionToOffset(const Position & pos ) const { return pos . buf - userbuf . base( ) ; } bool hasSourceMap( ) const { return sourceMap != NULL ;
if (GC_IS_RECURSIVE(ht ) ) { <START_VULN> ((SBucketType * ) (buffer -> buffer + p ) ) -> data_type = IS_NULL ; <END_VULN> php_error_docref(NULL TSRMLS_CC , E_NOTICE , "the array has cycle ref" ) ; } else
<START_VULN> if (client -> type == USER_CLIENT ) <END_VULN> snd_seq_fifo_clear(client -> data . user . fifo ) ; }
} ; #endif <START_VULN> static OM_uint32 KRB5_CALLCONV<END_VULN> krb5_gss_set_sec_context_option (OM_uint32 * minor_status , gss_ctx_id_t * context_handle , const gss_OID desired_object ,
struct timespec64 ts64 ; bool sig_none ; <START_VULN> sig_none = (timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <END_VULN> iv = timr -> it_interval ;
} } PRInt32 FindMaxUshortElement( ) { if (mHasCachedMaxUshortElement ) { return mCachedMaxUshortElement ; } else { mHasCachedMaxUshortElement = true ; <START_VULN> mCachedMaxUshortElement = FindMaxElementInSubArray < GLshort > (mByteLength >> 1 , 0 ) ; <END_VULN> return mCachedMaxUshortElement ; } } NS_DECL_ISUPPORTS NS_DECL_NSIWEBGLBUFFER protected :
private int cdf_file_property_info(struct magic_set * ms , const cdf_property_info_t * info , <START_VULN> size_t count , const uint64_t clsid [ 2 ] ) <END_VULN> { size_t i ; cdf_timestamp_t tp ;
static int CVE_2014_8546_cinepak_decode_vectors (CinepakContext * s , cvid_strip * strip , int chunk_id , int size , const uint8_t * data ) { const uint8_t * eod = (data + size ) ; uint32_t flag , mask ; uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; <START_VULN> unsigned int x , y ; <END_VULN> char * ip0 , * ip1 , * ip2 , * ip3 ; flag = 0 ; mask = 0 ; for (y = strip -> y1 ; y < strip -> y2 ; y + = 4 ) { ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + (s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + (y * s -> frame -> linesize [ 0 ] ) ;
if (c -> argc >= 4 ) { robj * o = lookupKeyWriteOrReply(c , c -> argv [ 2 ] , shared . nokeyerr ) ; <START_VULN> if (o == NULL ) return ; <END_VULN> s = o -> ptr ; grpname = c -> argv [ 3 ] -> ptr ;
phar_obj -> arc . archive -> ufp = pass . fp ; phar_flush(phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; } } else {
break ; } } <START_VULN> q [ i ] = ClampToQuantum(pixel ) ; <END_VULN> } p + = GetPixelChannels(composite_image ) ; channels = GetPixelChannels(composite_image ) ;
<START_VULN> #define JSXDR_BYTECODE_VERSION (0xb973c0de - 85 ) <END_VULN>
stub = phar_create_default_stub(index , webindex , & stub_len , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(spl_ce_UnexpectedValueException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; if (stub ) { efree(stub ) ;
n = ( ( * p ) [ 0 ] << 8 ) | ( * p ) [ 1 ] ; * p + = 2 ; <START_VULN> if( n < 1 || n > 65535 || * p + n > end ) <END_VULN> { MBEDTLS_SSL_DEBUG_MSG( 1 , ( "bad client key exchange message" ) ) ; return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE ) ;
| Sara Golemon < pollita@php . net > | + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- + <START_VULN> <END_VULN> #include "php . h" #include "php_globals . h"
static inline unsigned int __xfrm4_daddr_saddr_hash(xfrm_address_t * daddr , xfrm_address_t * saddr ) { <START_VULN> return ntohl(daddr -> a4 ^ saddr -> a4 ) ; <END_VULN> } static inline unsigned int __xfrm6_daddr_saddr_hash(xfrm_address_t * daddr , xfrm_address_t * saddr )
} } <START_VULN> good = (unsigned ) - 1 ; <END_VULN> minLength = crSpec -> mac_size ; if (cipher_def -> type == type_block ) {
struct sock * sk , int tstype ) { struct sk_buff * skb ; <START_VULN> bool tsonly ; <END_VULN> if ( ! sk ) return ;
#include "WrapperFactory . h" class nsIPrincipal ; namespace xpc { class AccessCheck { public : <START_VULN> static bool isSameOrigin(JSCompartment * a , JSCompartment * b ) ; <END_VULN> static bool isChrome(JSCompartment * compartment ) ; static bool callerIsChrome( ) ; static nsIPrincipal * getPrincipal(JSCompartment * compartment ) ; static bool isCrossOriginAccessPermitted(JSContext * cx , JSObject * obj , jsid id , js : : Wrapper : : Action act ) ; static bool isSystemOnlyAccessPermitted(JSContext * cx ) ; static bool isLocationObjectSameOrigin(JSContext * cx , JSObject * wrapper ) ; static bool documentDomainMakesSameOrigin(JSContext * cx , JSObject * obj ) ;
} ; static const struct gprefix pfx_0f_ae_7 = { <START_VULN> I(0 , em_clflush ) , N , N , N , <END_VULN> } ; static const struct group_dual group15 = { {
uint32_t length( ) const { JS_ASSERT(hasSourceData( ) ) ; return length_ ; } bool argumentsNotIncluded( ) const { JS_ASSERT(hasSourceData( ) ) ; return argumentsNotIncluded_ ; } <START_VULN> const jschar * chars(JSContext * cx , const SourceDataCache : : AutoSuppressPurge & asp ) ; <END_VULN> JSFlatString * substring(JSContext * cx , uint32_t start , uint32_t stop ) ; void addSizeOfIncludingThis(mozilla : : MallocSizeOf mallocSizeOf , JS : : ScriptSourceInfo * info ) const ; template < XDRMode mode > bool performXDR(XDRState < mode > * xdr ) ;
int * sortpointer [ VIF_POSIT + 2 ] ; vorbis_info_floor1 * info = (vorbis_info_floor1 * ) in ; vorbis_look_floor1 * look = _ogg_calloc(1 , sizeof( * look ) ) ; int i , j , n = 0 ; look -> vi = info ; look -> n = info -> postlist [ 1 ] ; <START_VULN> <END_VULN> for(i = 0 ; i < info -> partitions ; i + + ) n + = info -> class_dim [ info -> partitionclass [ i ] ] ;
} key_ref = ERR_PTR( - EINVAL ) ; <START_VULN> if ( ! index_key . type -> match || ! index_key . type -> instantiate || <END_VULN> ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ;
#ifndef imgStatusTracker_h__ #define imgStatusTracker_h__ class imgDecoderObserver ; class imgIContainer ; <START_VULN> class imgRequestProxy ; <END_VULN> class imgStatusNotifyRunnable ; class imgRequestNotifyRunnable ; class imgStatusTrackerObserver ; class imgStatusTrackerNotifyingObserver ; class nsIRunnable ; #include "mozillaRefPtr . h" #include "mozillaWeakPtr . h" #include "nsCOMPtr . h" #include "nsTObserverArray . h" #include "nsThreadUtils . h" #include "nsRect . h" namespace mozilla { namespace image { class Image ; struct ImageStatusDiff {
} break ; case rsaKey : { SECItem digest ; digest . data = final ; digest . len = part ; if (sig ) { PORT_Assert(cx -> hashAlg != SEC_OID_UNKNOWN ) ; <START_VULN> SECOidTag hashid ; <END_VULN> rv = recoverPKCS1DigestInfo(cx -> hashAlg , & hashid , & cx -> pkcs1RSADigestInfo , & cx -> pkcs1RSADigestInfoLen , cx -> key , sig , cx -> wincx ) ; PORT_Assert(cx -> hashAlg == hashid ) ; if (rv != SECSuccess ) { return SECFailure ;
header [ 11 ] = (rec -> length ) >> 8 ; header [ 12 ] = (rec -> length ) & 0xff ; <START_VULN> if ( ! send && ! SSL_USE_ETM(ssl ) && <END_VULN> EVP_CIPHER_CTX_mode(ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && ssl3_cbc_record_digest_supported(mac_ctx ) ) { # define SSL_PKEY_RSA_ENC 0
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("Cast6 Cipher Algorithm" ) ; <START_VULN> MODULE_ALIAS("cast6" ) ; <END_VULN>
if( ! b_xiph ) { void * p_org = p_stream -> p_headers ; p_stream -> i_headers + = p_oggpacket -> bytes ; p_stream -> p_headers = realloc( p_stream -> p_headers , p_stream -> i_headers ) ; if( p_stream -> p_headers ) { memcpy( (unsigned char * ) p_stream -> p_headers + p_stream -> i_headers - p_oggpacket -> bytes , <START_VULN> p_oggpacket -> packet , p_stream -> i_headers ) ; <END_VULN> } else { #warning Memory leak p_stream -> i_headers = 0 ; p_stream -> p_headers = NULL ; free( p_org ) ; } } else if( xiph_AppendHeaders( & p_stream -> i_headers , & p_stream -> p_headers ,
void kvm_apic_write_nodecode(struct kvm_vcpu * vcpu , u32 offset ) ; void kvm_apic_set_eoi_accelerated(struct kvm_vcpu * vcpu , int vector ) ; <START_VULN> void kvm_lapic_set_vapic_addr(struct kvm_vcpu * vcpu , gpa_t vapic_addr ) ; <END_VULN> void kvm_lapic_sync_from_vapic(struct kvm_vcpu * vcpu ) ; void kvm_lapic_sync_to_vapic(struct kvm_vcpu * vcpu ) ;
} } else { if (state -> space_before ) ruby_xfree(state -> space_before ) ; <START_VULN> state -> space_before = strdup(RSTRING_PTR(space_before ) ) ; <END_VULN> state -> space_before_len = len ; } return Qnil ;
} n = xmalloc(len ) ; m = n + len - (nlen + 1 ) ; <START_VULN> strcpy(m , name ) ; <END_VULN> for (p = path ; p ; p = p -> up ) { if (p -> elem_len ) { m -= p -> elem_len + 1 ;
} if (sax != NULL ) { <START_VULN> memset(sax , 0 , sizeof(sax ) ) ; <END_VULN> sax -> sax25_family = AF_NETROM ; skb_copy_from_linear_data_offset(skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ;
static void mpeg4_encode_gop_header(MpegEncContext * s ) { <START_VULN> int hours , minutes , seconds ; <END_VULN> int64_t time ; put_bits( & s -> pb , 16 , 0 ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic shared codebook operations <START_VULN> last mod : $ Id : codebook . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_CODEBOOK_H_ #define _V_CODEBOOK_H_ #include < oggogg . h >
tnl_hlen = skb_tnl_header_len(skb ) ; <START_VULN> if (skb_headroom(skb ) < (tnl_hlen + frag_hdr_sz ) ) { <END_VULN> if (gso_pskb_expand_head(skb , tnl_hlen + frag_hdr_sz ) ) goto out ; }
char * tmp_path = NULL ; if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size ) <START_VULN> return 0 ; <END_VULN> memcpy( & source , buffer , sizeof(struct entry_short ) ) ;
struct inode * inode , const char * name , const void * value , size_t size , int flags ) { <START_VULN> struct btrfs_dir_item * di ; <END_VULN> struct btrfs_root * root = BTRFS_I(inode ) -> root ; struct btrfs_path * path ; size_t name_len = strlen(name ) ;
{ struct xfrm_algo * algo ; struct nlattr * nla ; nla = nla_reserve(skb , XFRMA_ALG_AUTH , sizeof( * algo ) + (auth -> alg_key_len + 7 ) 8 ) ; if ( ! nla ) return - EMSGSIZE ; algo = nla_data(nla ) ; <START_VULN> strcpy(algo -> alg_name , auth -> alg_name ) ; <END_VULN> memcpy(algo -> alg_key , auth -> alg_key , (auth -> alg_key_len + 7 ) 8 ) ; algo -> alg_key_len = auth -> alg_key_len ; return 0 ; }
{ void * pointer ; <START_VULN> if ( ! handle ) <END_VULN> return NULL ; pointer = (void * ) ~ ((size_t ) handle -> dwUpper ) ;
<START_VULN> blkcnt = xfs_attr3_rmt_blocks(mp , args -> valuelen ) ; <END_VULN> error = xfs_bmap_first_unused(args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ; if (error )
INIT_LIST_HEAD( & sm_info -> sit_entry_set ) ; <START_VULN> if (test_opt(sbi , FLUSH_MERGE ) && ! f2fs_readonly(sbi -> sb ) ) { <END_VULN> err = create_flush_cmd_control(sbi ) ; if (err ) return err ;
" for note" ) ; return - 1 ; } <START_VULN> if (pread(fd , nbuf , xsh_size , xsh_offset ) == - 1 ) { <END_VULN> file_badread(ms ) ; free(nbuf ) ; return - 1 ;
init_rock_state( & rs , inode ) ; setup_rock_ridge(de , inode , & rs ) ; <START_VULN> if (regard_xa ) { <END_VULN> rs . chr + = 14 ; rs . len -= 14 ; if (rs . len < 0 )
inline void setNextView(ArrayBufferViewObject * view ) ; <START_VULN> void neuter(JSContext * cx ) ; <END_VULN> static void trace(JSTracer * trc , JSObject * obj ) ;
if ( ! out_buf ) return - ENOMEM ; <START_VULN> if (count < DJREPORT_SHORT_LENGTH - 2 ) <END_VULN> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ;
gso = & extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] ; if (netbk_set_skb_gso(vif , skb , gso ) ) { kfree_skb(skb ) ; <START_VULN> netbk_tx_err(vif , & txreq , idx ) ; <END_VULN> continue ; } }
bool mSuppressEOF ; bool mReadingFromStage ; nsTArray < nsHtml5TreeOperation > mOpQueue ; nsTArray < nsIContentPtr > mElementsSeenInThisAppendBatch ; nsTArray < nsHtml5PendingNotification > mPendingNotifications ; nsHtml5StreamParser * mStreamParser ; <START_VULN> nsCOMArray < nsIContent > mOwnedElements ; <END_VULN> nsTHashtable < nsCStringHashKey > mPreloadedURLs ; nsCOMPtr < nsIURI > mSpeculationBaseURI ;
path_end = memchr(path_ptr , '0' , buffer_size ) ; if (path_end == NULL ) <START_VULN> return 0 ; <END_VULN> path_length = path_end - path_ptr ; }
if (r ) { printk(KERN_ERR "kvm_iommu_map_address : " "iommu failed to map pfn = % llx" , pfn ) ; <START_VULN> kvm_unpin_pages(kvm , pfn , page_size ) ; <END_VULN> goto unmap_pages ; }
switch (exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : <START_VULN> if ( ! is_exception(intr_info ) ) <END_VULN> return false ; else if (is_page_fault(intr_info ) ) return enable_ept ;
if (unlikely(file -> f_flags & __O_TMPFILE ) ) { error = do_tmpfile(dfd , pathname , nd , flags , op , file , & opened ) ; <START_VULN> goto out ; <END_VULN> } error = path_init(dfd , pathname , flags , nd ) ;
MODULE_DESCRIPTION("Synchronous AES in CCM mode using ARMv8 Crypto Extensions" ) ; MODULE_AUTHOR("Ard Biesheuvel < ard . biesheuvel@linaro . org > " ) ; MODULE_LICENSE("GPL v2" ) ; <START_VULN> MODULE_ALIAS("ccm(aes ) " ) ; <END_VULN>
rtadv_event (zvrf , RTADV_READ , sock ) ; <START_VULN> len = rtadv_recv_packet (sock , buf , BUFSIZ , & from , & ifindex , & hoplimit ) ; <END_VULN> if (len < 0 ) {
return 0 ; zsize = (src [ 0 ] << 8 ) | src [ 1 ] ; src + = 2 ; <START_VULN> if (src_end - src < zsize ) <END_VULN> return AVERROR_INVALIDDATA ; ret = uncompress(c -> kempf_buf , & dlen , src , zsize ) ;
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID("@(# ) $ File : softmagic . c , v 1 . 170 20140106 02 : 25 : 32 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
int i ; out = in ; <START_VULN> for (i = 0 ; i < 4 && out -> data [ i ] ; i + + ) { <END_VULN> int hsub = s -> draw . hsub [ i ] ; int vsub = s -> draw . vsub [ i ] ; out -> data [ i ] -= (s -> x >> hsub ) * s -> draw . pixelstep [ i ] +
<START_VULN> static int CVE_2014_5471_isofs_read_inode(struct inode * inode ) <END_VULN> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB(sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE(inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ;
xtmp = sk_X509_pop(ctx -> chain ) ; X509_free(xtmp ) ; num -- ; <START_VULN> ctx -> last_untrusted -- ; <END_VULN> } retry = 1 ; break ; }
if ( ! tx_ring ) prb_shutdown_retire_blk_timer(po , rb_queue ) ; } <START_VULN> release_sock(sk ) ; <END_VULN> if (pg_vec ) free_pg_vec(pg_vec , order , req -> tp_block_nr ) ; out : return err ; }
BIO_free(f ) ; f = tbio ; } <START_VULN> while (f != upto ) ; <END_VULN> } else BIO_free_all(f ) ;
struct ext4_iloc iloc ; int err = 0 , rc ; <START_VULN> if ( ! ext4_handle_valid(handle ) ) <END_VULN> return 0 ; mutex_lock( & EXT4_SB(sb ) -> s_orphan_lock ) ;
long n = look -> n ; long posts = look -> posts ; long nonzero = 0 ; lsfit_acc fits [ VIF_POSIT + 1 ] ; int fit_valueA [ VIF_POSIT + 2 ] ; int fit_valueB [ VIF_POSIT + 2 ] ; int loneighbor [ VIF_POSIT + 2 ] ; <START_VULN> int hineighbor [ VIF_POSIT + 2 ] ; <END_VULN> int * output = NULL ; int memo [ VIF_POSIT + 2 ] ; for(i = 0 ; i < posts ; i + + ) fit_valueA [ i ] = - 200 ; for(i = 0 ; i < posts ; i + + ) fit_valueB [ i ] = - 200 ; for(i = 0 ; i < posts ; i + + ) loneighbor [ i ] = 0 ; for(i = 0 ; i < posts ; i + + ) hineighbor [ i ] = 1 ; for(i = 0 ; i < posts ; i + + ) memo [ i ] = - 1 ;
for (size_t i = 0 ; i < numBlocks_ ; i + + ) blocks_ [ i ] . destroy( ) ; js_free(blocks_ ) ; js_delete(previous_ ) ; } bool init(size_t numBlocks ) { numBlocks_ = numBlocks ; <START_VULN> blocks_ = (IonBlockCounts * ) js_calloc(numBlocks * sizeof(IonBlockCounts ) ) ; <END_VULN> return blocks_ != NULL ; } size_t numBlocks( ) const { return numBlocks_ ; } IonBlockCounts & block(size_t i ) {
ret = pop_query(pop_data , buf , sizeof(buf ) ) ; if (ret == 0 ) { <START_VULN> mutt_bcache_del(pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <END_VULN> #ifdef USE_HCACHE mutt_hcache_delete(hc , ctx -> hdrs [ i ] -> data , strlen(ctx -> hdrs [ i ] -> data ) ) ; #endif commit 9bfab35522301794483f8f9ed60820bdec9be59e Author : Richard Russon < rich@flatcap . org > Date : Thu Jul 5 13 : 32 : 17 2018 + 0100 sanitise cache paths Co - authored - by : JerikoOne < jeriko . one@gmx . us >
} for ( ; num ; num -- ) { <START_VULN> if (pread(fd , xph_addr , xph_sizeof , off ) == - 1 ) { <END_VULN> file_badread(ms ) ; return - 1 ; }
zval * z_still_running ; php_curlm * mh ; int still_running ; <START_VULN> int result ; <END_VULN> if (zend_parse_parameters(ZEND_NUM_ARGS( ) , "rz" , & z_mh , & z_still_running ) == FAILURE ) { return ;
float secs = (float ) nvi -> rate ; amp + = secs * gi -> ampmax_att_per_sec ; if(amp < - 9999 ) amp = - 9999 ; return(amp ) ; } static void couple_lossless(float A , float B , <START_VULN> float * qA , float * qB ) { <END_VULN> int test1 = fabs( * qA ) > fabs( * qB ) ; test1 -= fabs( * qA ) < fabs( * qB ) ; if( ! test1 ) test1 = ((fabs(A ) > fabs(B ) ) << 1 ) - 1 ; if(test1 == 1 ) { * qB = ( * qA > 0 . f ? * qA - * qB : * qB - * qA ) ; } else { float temp = * qB ;
static void add_bytes_c(uint8_t * dst , uint8_t * src , int w ) { long i ; <START_VULN> for(i = 0 ; i <= w - sizeof(long ) ; i + = sizeof(long ) ) { <END_VULN> long a = * (long * ) (src + i ) ; long b = * (long * ) (dst + i ) ; * (long * ) (dst + i ) = ((a & pb_7f ) + (b & pb_7f ) ) ^ ((a ^ b ) & pb_80 ) ;
#define char_to_int(p ) (p - '0' ) #define OSSL_MAX(p , q ) ((p >= q ) ? p : q ) <START_VULN> static void<END_VULN> _dopr(char ** sbuffer , char ** buffer , size_t * maxlen ,
break ; } } <START_VULN> jas_tvparser_destroy(tvp ) ; <END_VULN> if ( ! cmpt -> sampperx || ! cmpt -> samppery ) { goto error ; } if (mif_hdr_addcmpt(hdr , hdr -> numcmpts , cmpt ) ) { goto error ; } return 0 ; error :
default : CHECK(0 ) ; } <START_VULN> snprintf_func (rptr , rbuf + TESTBUFSIZE - rptr , " % d % d" , <END_VULN> inst -> pos , inst -> size ) ; rptr + = strlen (rptr ) ;
if (nd -> flags & LOOKUP_RCU ) { return follow_dotdot_rcu(nd ) ; } else <START_VULN> follow_dotdot(nd ) ; <END_VULN> } return 0 ; }
cl_allowDownload = Cvar_Get( "cl_allowDownload" , "0" , CVAR_ARCHIVE ) ; #ifdef USE_CURL_DLOPEN <START_VULN> cl_cURLLib = Cvar_Get("cl_cURLLib" , DEFAULT_CURL_LIB , CVAR_ARCHIVE ) ; <END_VULN> #endif
if (page == NULL ) page = http_request_get_query_string(req ) ; <START_VULN> if (page && (unlink(page ) > 0 ) ) <END_VULN> { http_response_printf(res , "success" ) ; http_response_send(res ) ;
Vector < CFGState , 8 , IonAllocPolicy > cfgStack_ ; Vector < ControlFlowInfo , 4 , IonAllocPolicy > loops_ ; Vector < ControlFlowInfo , 0 , IonAllocPolicy > switches_ ; Vector < ControlFlowInfo , 2 , IonAllocPolicy > labels_ ; Vector < MInstruction * , 2 , IonAllocPolicy > iterators_ ; TypeOracle * oracle ; <START_VULN> size_t inliningDepth ; <END_VULN> Vector < MDefinition * , 0 , IonAllocPolicy > inlinedArguments_ ; bool failedBoundsCheck_ ;
goto found ; entry = next ; } <START_VULN> if (ext2_xattr_cache_insert(bh ) ) <END_VULN> ea_idebug(inode , "cache insert failed" ) ; error = - ENODATA ; goto cleanup ;
vif = pending_tx_info -> vif ; <START_VULN> make_tx_response(vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ; <END_VULN>
phar_flush(phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if (error ) { <START_VULN> zend_throw_exception_ex(spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <END_VULN> efree(error ) ; }
struct sock * make ; struct rose_sock * make_rose ; struct rose_facilities_struct facilities ; <START_VULN> int n , len ; <END_VULN> skb -> sk = NULL ;
} uint32_t numInstructions( ) const { return numInstructions_ ; } void setLocalSlotCount(uint32_t localSlotCount ) { localSlotCount_ = localSlotCount ; } uint32_t localSlotCount( ) const { <START_VULN> return localSlotCount_ ; <END_VULN> } void setArgumentSlotCount(uint32_t argumentSlotCount ) { argumentSlotCount_ = argumentSlotCount ; } uint32_t argumentSlotCount( ) const { return argumentSlotCount_ ; } uint32_t totalSlotCount( ) const {
} else { ti -> flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; if ( -- timer -> running ) <START_VULN> list_del( & ti -> active_list ) ; <END_VULN> } if ((timer -> hw . flags & SNDRV_TIMER_HW_TASKLET ) || (ti -> flags & SNDRV_TIMER_IFLG_FAST ) )
void WalkRules(nsIStyleRuleProcessor : : EnumFunc aFunc , void * aData ) ; nsINodeList * GetAnonymousNodes( ) ; static nsresult DoInitJSClass(JSContext * cx , JSObject * global , JSObject * obj , const nsAFlatCString & aClassName , nsXBLPrototypeBinding * aProtoBinding , <START_VULN> JSObject ** aClassObject ) ; <END_VULN> bool AllowScripts( ) ; void RemoveInsertionParent(nsIContent * aParent ) ; bool HasInsertionParent(nsIContent * aParent ) ; protected :
sslSessionID * sid = ss -> sec . ci . sid ; if (sid -> peerCert == NULL ) { PORT_Memcpy(sid -> u . ssl2 . sessionID , s , sizeof(sid -> u . ssl2 . sessionID ) ) ; sid -> peerCert = CERT_DupCertificate(ss -> sec . peerCert ) ; } <START_VULN> if ( ! ss -> opt . noCache ) <END_VULN> ( * ss -> sec . cache ) (sid ) ; } static SECStatus ssl2_TriggerNextMessage(sslSocket * ss ) { SECStatus rv ;
struct SParser * p = cast(struct SParser * , ud ) ; int c = luaZ_lookahead(p -> z ) ; luaC_checkGC(L ) ; <START_VULN> tf = ((c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) (L , p -> z , <END_VULN> & p -> buff , p -> name ) ; cl = luaF_newLclosure(L , tf -> nups , hvalue(gt(L ) ) ) ; cl -> l . p = tf ;
if (av_image_check_size(s -> width , s -> height , 0 , avctx ) < 0 ) return - 1 ; <START_VULN> if (s -> width != avctx -> width && s -> height != avctx -> height ) { <END_VULN> ret = ff_set_dimensions(avctx , s -> width , s -> height ) ; if (ret < 0 ) return ret ;
* * * <START_VULN> void Write(const char * aBuffer , uint32_t aCount ) ; <END_VULN> void Finish(RasterImage : : eShutdownIntent aShutdownIntent ) ;
} <START_VULN> skb -> len = hdrlen + per_fragm ; <END_VULN> return 0 ; }
void PopulateJSClass(JSBool isGlobal ) ; void Mark( ) { mFlags . Mark( ) ; } void Unmark( ) { mFlags . Unmark( ) ; } JSBool IsMarked( ) const { return mFlags . IsMarked( ) ; } private : XPCNativeScriptableFlags mFlags ; <START_VULN> XPCNativeScriptableSharedJSClass mJSClass ; <END_VULN> JSBool mCanBeSlim ; } ; class XPCNativeScriptableInfo
call_rcu_bh( & p -> rcu , br_multicast_free_pg ) ; err = 0 ; <START_VULN> if ( ! mp -> ports && ! mp -> mglist && <END_VULN> netif_running(br -> dev ) ) mod_timer( & mp -> timer , jiffies ) ; break ;
} else { num_items_scanned = sscanf(line , <START_VULN> " % 5s ( % 127 [ A - Za - z0 - 9 : ] ) , Length : % 9u , Pro : % 9d , Off : % 9d , Pri : % 9d , RM : % 9d , Err : % 9d [ % 8x , % 8x ] " , <END_VULN> direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;
BUG_ON(path [ depth ] . p_hdr == NULL ) ; <START_VULN> if (ex && (flag != EXT4_GET_BLOCKS_PRE_IO ) <END_VULN> && ext4_can_extents_be_merged(inode , ex , newext ) ) { ext_debug("append [ % d ] % d block to % d : [ % d ] % d (from % llu ) " , ext4_ext_is_uninitialized(newext ) ,
! jbd2_journal_set_features(EXT4_SB(sb ) -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_64BIT ) ) { ext4_msg(sb , KERN_ERR , "Failed to set 64 - bit journal feature" ) ; <START_VULN> goto failed_mount4 ; <END_VULN> } if (test_opt(sb , JOURNAL_ASYNC_COMMIT ) ) {
copy_flags = CL_COPY_ALL | CL_EXPIRE ; if (user_ns != mnt_ns -> user_ns ) <START_VULN> copy_flags |= CL_SHARED_TO_SLAVE ; <END_VULN> new = copy_tree(old , old -> mnt . mnt_root , copy_flags ) ; if (IS_ERR(new ) ) { up_write( & namespace_sem ) ;
static uint32_t sanityCheck(const uint8_t * woffData , uint32_t woffLen ) { const woffHeader * header ; uint16_t numTables , i ; const woffDirEntry * dirEntry ; <START_VULN> uint32_t tableTotal = 0 ; <END_VULN> if ( ! woffData || ! woffLen ) { return eWOFF_bad_parameter ; } if (woffLen < sizeof(woffHeader ) ) { return eWOFF_invalid ; }
void * jas_realloc(void * ptr , size_t size ) { void * result ; <START_VULN> JAS_DBGLOG(101 , ("jas_realloc called with % x , % zu" , ptr , size ) ) ; <END_VULN> result = realloc(ptr , size ) ; JAS_DBGLOG(100 , ("jas_realloc( % p , % zu ) -> % p" , ptr , size , result ) ) ; return result ;
. vcpu_load = svm_vcpu_load , . vcpu_put = svm_vcpu_put , <START_VULN> . update_db_bp_intercept = update_db_bp_intercept , <END_VULN> . get_msr = svm_get_msr , . set_msr = svm_set_msr , . get_segment_base = svm_get_segment_base ,
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : bitrate tracking and management <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_BITRATE_H_ #define _V_BITRATE_H_ #include "vorbiscodec . h" #include "codec_internal . h"
no_journal : if (ext4_mballoc_ready ) { <START_VULN> sbi -> s_mb_cache = ext4_xattr_create_cache(sb -> s_id ) ; <END_VULN> if ( ! sbi -> s_mb_cache ) { ext4_msg(sb , KERN_ERR , "Failed to create an mb_cache" ) ; goto failed_mount_wq ;
parent = dentry -> d_parent ; nfs_block_sillyrename(parent ) ; <START_VULN> state = nfs4_do_open(dir , & path , nd -> intent . open . flags , & attr , cred ) ; <END_VULN> put_rpccred(cred ) ; if (IS_ERR(state ) ) { if (PTR_ERR(state ) == - ENOENT ) {
TRY(value(p , v ) ) ; } else { <START_VULN> p -> tokenbuf [ p -> tokenpos ] = 0 ; <END_VULN> char * end = 0 ; double d = jvp_strtod( & p -> dtoa , p -> tokenbuf , & end ) ; if (end == 0 || * end != 0 )
#endif { unsigned char * oe = op + t ; <START_VULN> NEED_OP(t ) ; <END_VULN> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op + = 2 ;
if ( ! (plen <= * len ) ) printf("PLEN % d type % d len % d" , plen , nh . nh_type , * len ) ; <START_VULN> assert(plen <= * len ) ; <END_VULN> * len = plen ; if (( * len ) && (net_read_exact(s , arg , * len ) == - 1 ) )
#include < ft2build . h > #include FT_CONFIG_CONFIG_H #include FT_INTERNAL_OBJECTS_H #include FT_INTERNAL_DEBUG_H #include FT_MODULE_H #include "basepic . h" <START_VULN> <END_VULN> #undef FT_COMPONENT #define FT_COMPONENT trace_init
static int CVE_2008_3915_init_state(struct posix_acl_state * state , int cnt ) { int alloc ; memset(state , 0 , sizeof(struct posix_acl_state ) ) ; state -> empty = 1 ; alloc = sizeof(struct posix_ace_state_array ) <START_VULN> + cnt * sizeof(struct posix_ace_state ) ; <END_VULN> state -> users = kzalloc(alloc , GFP_KERNEL ) ; if ( ! state -> users ) return - ENOMEM ; state -> groups = kzalloc(alloc , GFP_KERNEL ) ; if ( ! state -> groups ) { kfree(state -> users ) ; return - ENOMEM ; } return 0 ; }
. read_iter = generic_file_read_iter , . write_iter = generic_file_write_iter , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . llseek = generic_file_llseek , } ;
conn -> m -> local_tx_end(conn , this_func , ret TSRMLS_CC ) ; } <START_VULN> DBG_RETURN(ret ) ; <END_VULN> }
_analysis_output("mask0" , seq , logmask , n2 , 1 , 0 , 0 ) ; } #endif floor_posts [ i ] [ 0 ] = floor1_fit(vb , b -> flr [ info -> floorsubmap [ submap ] ] , logmdct , logmask ) ; <START_VULN> <END_VULN> for(k = 1 ; k < PACKETBLOBS2 ; k + + ) floor_posts [ i ] [ k ] = floor1_interpolate_fit(vb , b -> flr [ info -> floorsubmap [ submap ] ] , floor_posts [ i ] [ 0 ] , floor_posts [ i ] [ PACKETBLOBS2 ] , k * 65536(PACKETBLOBS2 ) ) ;
extern void _vp_remove_floor(vorbis_look_psy * p , float * mdct , int * icodedflr , float * residue , int sliding_lowpass ) ; extern void _vp_noisemask(vorbis_look_psy * p , <START_VULN> float * logmdct , <END_VULN> float * logmask ) ; extern void _vp_tonemask(vorbis_look_psy * p , float * logfft , float * logmask , float global_specmax , float local_specmax ) ;
const wbxml_decoding * map ) { guint32 tvb_len = tvb_reported_length (tvb ) ; <START_VULN> guint32 off = offset ; <END_VULN> guint32 len ; guint str_len ; guint32 ent ;
av_frame_copy_props(outpic , inpic ) ; outpic -> interlaced_frame = 0 ; <START_VULN> for (plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane + + ) { <END_VULN> h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT(inlink -> h , kerndeint -> vsub ) ; bwidth = kerndeint -> tmp_bwidth [ plane ] ;
bool mDroppedDown ; bool mInRedisplayText ; bool mDelayedShowDropDown ; <START_VULN> static nsComboboxControlFrame * mFocused ; <END_VULN> #ifdef DO_REFLOW_COUNTER PRInt32 mReflowId ; #endif } ; #endif
+ + vcpu -> stat . insn_emulation_fail ; trace_kvm_emulate_insn_failed(vcpu ) ; <START_VULN> if ( ! is_guest_mode(vcpu ) ) { <END_VULN> vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_EMULATION ; vcpu -> run -> internal . ndata = 0 ;
#else ctl -> pw -> pw_gecos = gecos ; <START_VULN> if (setpwnam(ctl -> pw ) < 0 ) { <END_VULN> warn("setpwnam failed" ) ; #endif printf(_
#endif <START_VULN> cmd = zend_string_alloc(2 * l , 0 ) ; <END_VULN> for (x = 0 , y = 0 ; x < l ; x + + ) { int mb_len = php_mblen(str + x , (l - x ) ) ;
} rval = si4713_set_rds_ps_name(sdev , ps_name ) ; } break ; case V4L2_CID_RDS_TX_RADIO_TEXT : { char radio_text [ MAX_RDS_RADIO_TEXT + 1 ] ; len = control -> size - 1 ; <START_VULN> if (len > MAX_RDS_RADIO_TEXT ) { <END_VULN> rval = - ERANGE ; goto exit ; } rval = copy_from_user(radio_text , control -> string , len ) ; if (rval < 0 ) goto exit ; radio_text [ len ] = '0' ; if (strlen(radio_text ) % vqc . step ) { rval = - ERANGE ;
int rc ; int param_num = SvIV(param ) ; int idx = param_num - 1 ; <START_VULN> char err_msg [ 64 ] ; <END_VULN> D_imp_xxh(sth ) ; #if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
if (blocks == (unsigned char * ) NULL ) ThrowReaderException(ResourceLimitError , "MemoryAllocationFailed" ) ; count = ReadBlob(image , (size_t ) length , blocks ) ; <START_VULN> if ((count != (ssize_t ) length ) || <END_VULN> (LocaleNCompare((char * ) blocks , "8BIM" , 4 ) != 0 ) ) { blocks = (unsigned char * ) RelinquishMagickMemory(blocks ) ;
port_number = edge_port -> port -> port_number ; <START_VULN> if (edge_port -> lsr_event ) { <END_VULN> edge_port -> lsr_event = 0 ; dev_dbg(dev , " % s == == = Port % u LSR Status = % 02x , Data = % 02x == == == " , __func__ , port_number , edge_port -> lsr_mask , * data ) ;
void ( * reset ) (int dev ) ; void ( * hw_control ) (int dev , unsigned char * event ) ; int ( * load_patch ) (int dev , int format , const char __user * addr , <START_VULN> int offs , int count , int pmgr_flag ) ; <END_VULN> void ( * aftertouch ) (int dev , int voice , int pressure ) ; void ( * controller ) (int dev , int voice , int ctrl_num , int value ) ; void ( * panning ) (int dev , int voice , int value ) ;
shader -> DecrementAttachCount( ) ; return PR_TRUE ; } return PR_FALSE ; } PRBool HasAttachedShaderOfType(GLenum shaderType ) { for (PRUint32 i = 0 ; i < mAttachedShaders . Length( ) ; + + i ) { <START_VULN> if (mAttachedShaders [ i ] -> ShaderType( ) == shaderType ) { <END_VULN> return PR_TRUE ; } } return PR_FALSE ; } PRBool HasBothShaderTypesAttached( ) { return
. compat_ioctl = f2fs_compat_ioctl , #endif . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> } ;
if (((avail & codemask ) == 0 ) && (avail < 4096 ) ) { codesize + + ; codemask + = avail ; } } oldcode = incode ; do { <START_VULN> * rowp + + = * -- stackp ; <END_VULN> if (rowp == rowend ) OUTPUT_ROW( ) ; } while (stackp > stack ) ; } } END : mGIFStruct . avail = avail ;
if ( ! is_irq_none(vdev ) ) return - EINVAL ; <START_VULN> vdev -> ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <END_VULN> if ( ! vdev -> ctx ) return - ENOMEM ;
i = 0 ; if (info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { nla_for_each_nested(attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { if (request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy(request -> ssids [ i ] . ssid , nla_data(attr ) , nla_len(attr ) ) ; <START_VULN> request -> ssids [ i ] . ssid_len = nla_len(attr ) ; <END_VULN> i + + ; } }
return(DestroyImageList(image ) ) ; if ((sun_info . length * sizeof( * sun_data ) ) sizeof( * sun_data ) != sun_info . length || ! sun_info . length ) <START_VULN> ThrowReaderException(ResourceLimitError , "MemoryAllocationFailed" ) ; <END_VULN> number_pixels = (MagickSizeType ) image -> columns * image -> rows ; if ((sun_info . type != RT_ENCODED ) && ((number_pixels * sun_info . depth ) > (8 * sun_info . length ) ) )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic codebook packunpackcodedecode operations <START_VULN> last mod : $ Id : codebook . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
typedef struct { void ( * pack ) (vorbis_info_floor * , oggpack_buffer * ) ; vorbis_info_floor * ( * unpack ) (vorbis_info * , oggpack_buffer * ) ; vorbis_look_floor * ( * look ) (vorbis_dsp_state * , vorbis_info_floor * ) ; void ( * free_info ) (vorbis_info_floor * ) ; void ( * free_look ) (vorbis_look_floor * ) ; void * ( * inverse1 ) (struct vorbis_block * , vorbis_look_floor * ) ; int ( * inverse2 ) (struct vorbis_block * , vorbis_look_floor * , <START_VULN> void * buffer , float * ) ; <END_VULN> } vorbis_func_floor ; typedef struct { int order ; long rate ; long barkmap ; int ampbits ;
ret = install_process_keyring_to_cred(new ) ; if (ret < 0 ) { abort_creds(new ) ; <START_VULN> return ret != - EEXIST ? ret : 0 ; <END_VULN> } return commit_creds(new ) ; } int install_session_keyring_to_cred(struct cred * cred , struct key * keyring ) {
exit : mutex_unlock( & dev -> lock ) ; <START_VULN> return ret <= 0 ? ret : - EIO ; <END_VULN> } static void cp2112_gpio_set(struct gpio_chip * chip , unsigned offset , int value )
protected : nsPresContext * mPresContext ; nsCOMPtr < nsIPresShell > mPresShell ; nsCOMPtr < nsISelection > mSelection ; nsRefPtr < nsRange > mFirstSelectedRange ; nsCOMPtr < nsIContent > mRootContent ; nsresult Init(nsQueryContentEvent * aEvent ) ; nsresult Init(nsSelectionEvent * aEvent ) ; <START_VULN> <END_VULN> nsresult InitCommon( ) ; public : static nsresult GetFlatTextOffsetOfRange(nsIContent * aRootContent , nsINode * aNode , int32_t aNodeOffset ,
{ char * rootdir = get_rootdir(pid ) ; <START_VULN> dd_create_basic_files(dd , fsuid , (rootdir && strcmp(rootdir , "" ) != 0 ) ? rootdir : NULL ) ; <END_VULN> char source_filename [ sizeof("proc % lusomewhat_long_name" ) + sizeof(long ) * 3 ] ; int source_base_ofs = sprintf(source_filename , "proc % lusmaps" , (long ) pid ) ;
if ( ! page ) { ret = - ENOMEM ; page = page_cache_alloc_cold(mapping ) ; if (unlikely( ! page ) ) goto out_ret ; ret = add_to_page_cache_lru(page , mapping , index , GFP_KERNEL ) ; if (unlikely(ret ) ) <START_VULN> goto out ; <END_VULN> } ret = mapping -> a_ops -> prepare_write(file , page , offset , offset + this_len ) ; if (unlikely(ret ) ) { loff_t isize = i_size_read(mapping -> host ) ; if (ret != AOP_TRUNCATED_PAGE ) unlock_page(page ) ; page_cache_release(page ) ; if (ret == AOP_TRUNCATED_PAGE )
src = kmalloc(req -> cryptlen + req -> assoclen , GFP_ATOMIC ) ; if ( ! src ) return - ENOMEM ; <START_VULN> assoc = (src + req -> cryptlen + auth_tag_len ) ; <END_VULN> scatterwalk_map_and_copy(src , req -> src , 0 , req -> cryptlen , 0 ) ; scatterwalk_map_and_copy(assoc , req -> assoc , 0 , req -> assoclen , 0 ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis codec headers <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _vorbis_codec_h_ #define _vorbis_codec_h_ #ifdef __cplusplus extern "C"
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : PCM data vector blocking , windowing and disreassembly <START_VULN> last mod : $ Id : block . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> Handle windowing , overlap - add , etc of the PCM vectors . This is made more amusing by Vorbis' current two allowed block sizes . #include < stdio . h > #include < stdlib . h >
unsigned long end , long adjust_next ) { <START_VULN> if ( ! vma -> anon_vma || vma -> vm_ops || vma -> vm_file ) <END_VULN> return ; __vma_adjust_trans_huge(vma , start , end , adjust_next ) ; }
add_assoc_long( * subarray , "weight" , n ) ; GETSHORT(n , cp ) ; add_assoc_long( * subarray , "port" , n ) ; <START_VULN> n = dn_expand(answer -> qb2 , answer -> qb2 + 65536 , cp , name , (sizeof name ) - 2 ) ; <END_VULN> if (n < 0 ) { return NULL ; }
msg [ 0 ] -> msg_style == PAM_PROMPT_ECHO_ON ) ) { * resp = malloc(sizeof(struct pam_response ) ) ; assert( * resp ) ; <START_VULN> ( * resp ) -> resp = calloc(1024 , 0 ) ; <END_VULN> struct termios termios = old_termios ; if (msg [ 0 ] -> msg_style == PAM_PROMPT_ECHO_OFF ) { termios . c_lflag &= ~ (ECHO | ECHONL ) ;
u8 * out_buf ; int ret ; if (buf [ 0 ] != REPORT_TYPE_LEDS ) return - EINVAL ; out_buf = kzalloc(DJREPORT_SHORT_LENGTH , GFP_ATOMIC ) ; if ( ! out_buf ) return - ENOMEM ; <START_VULN> if (count < DJREPORT_SHORT_LENGTH - 2 ) <END_VULN> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ; out_buf [ 1 ] = djdev -> device_index ; memcpy(out_buf + 2 , buf , count ) ; ret = hid_hw_raw_request(djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ) ; kfree(out_buf ) ;
bytes_per_pixel + + ; if (bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; <START_VULN> length = image -> rows * (bytes_per_line + image -> columns % 2 ) ; <END_VULN> if (((sun_info . type == RT_ENCODED ) && (length > (bytes_per_line * image -> rows ) ) ) || ((sun_info . type != RT_ENCODED ) && (length > sun_info . length ) ) )
} #endif void RunScript(nsIContent * aScriptElement ) ; void Reset( ) ; inline void HoldElement(nsIContent * aContent ) { <START_VULN> mOwnedElements . AppendObject(aContent ) ; <END_VULN> } void DropHeldElements( ) ;
add_next_index_stringl(match_pair , str , len , 1 ) ; add_next_index_long(match_pair , offset ) ; <START_VULN> <END_VULN> if (name ) { zval_add_ref( & match_pair ) ; zend_hash_update(Z_ARRVAL_P(result ) , name , strlen(name ) + 1 , & match_pair , sizeof(zval * ) , NULL ) ;
io -> flag = 0 ; io -> offset = 0 ; io -> size = 0 ; <START_VULN> io -> error = 0 ; <END_VULN> INIT_WORK( & io -> work , ext4_end_io_work ) ; INIT_LIST_HEAD( & io -> list ) ; }
struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; <START_VULN> int idx , ret = - EINVAL ; <END_VULN> if ( ! kvm_arch_has_assigned_device(kvm ) || ! irq_remapping_cap(IRQ_POSTING_CAP ) ||
if (fd < 0 ) return - errno ; <START_VULN> if (mode > 0 ) { <END_VULN> r = fchmod(fd , mode ) ; if (r < 0 ) return - errno ;
} <START_VULN> static inline realpath_cache_bucket * realpath_cache_find(const char * path , int path_len , time_t t ) <END_VULN> { zend_ulong key = realpath_cache_key(path , path_len ) ; zend_ulong n = key % (sizeof(CWDG(realpath_cache ) ) sizeof(CWDG(realpath_cache ) [ 0 ] ) ) ;
} case PHP_MODE_REFLECTION_EXT_INFO : { <START_VULN> int len = (int ) strlen(reflection_what ) ; <END_VULN> char * lcname = zend_str_tolower_dup(reflection_what , len ) ; zend_module_entry * module ;
MODULE_DESCRIPTION("Twofish Cipher Algorithm , AVX optimized" ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("twofish" ) ; <END_VULN>
} ctx = (krb5_gss_ctx_id_rec * ) context_handle ; <START_VULN> if ( ! ctx -> established ) { <END_VULN> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
for(i = 0 ; i < PACKETBLOBS ; i + + ) { if(i == PACKETBLOBS2 ) { vbi -> packetblob [ i ] = & vb -> opb ; } else { vbi -> packetblob [ i ] = _ogg_calloc(1 , sizeof(oggpack_buffer ) ) ; } oggpack_writeinit(vbi -> packetblob [ i ] ) ; <START_VULN> } <END_VULN> } return(0 ) ; } void * _vorbis_block_alloc(vorbis_block * vb , long bytes ) { bytes = (bytes + (WORD_ALIGN - 1 ) ) & ~ (WORD_ALIGN - 1 ) ; if(bytes + vb -> localtop > vb -> localalloc ) {
size_t count ) { struct o2nm_node * node = to_o2nm_node(item ) ; <START_VULN> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node(node ) ; <END_VULN> unsigned long tmp ; char * p = (char * ) page ; int ret = 0 ;
size_t count ) { struct o2nm_node * node = to_o2nm_node(item ) ; <START_VULN> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node(node ) ; <END_VULN> unsigned long tmp ; char * p = (char * ) page ; ssize_t ret ;
static int open_unix_listener(h2o_configurator_command_t * cmd , yoml_t * node , struct sockaddr_un * sa ) { struct stat st ; <START_VULN> int fd ; <END_VULN> struct passwd * owner = NULL , pwbuf ; char pwbuf_buf [ 65536 ] ; unsigned mode = UINT_MAX ;
INST_HANDLER (cpse ) { int r = (buf [ 0 ] & 0xf ) | ((buf [ 1 ] & 0x2 ) << 3 ) ; int d = ((buf [ 0 ] >> 4 ) & 0xf ) | ((buf [ 1 ] & 0x1 ) << 4 ) ; <START_VULN> RAnalOp next_op ; <END_VULN>
struct task_struct * tsk ; struct mm_struct * mm ; int fault , sig , code ; <START_VULN> unsigned long vm_flags = VM_READ | VM_WRITE ; <END_VULN> unsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE ; tsk = current ;
if ( ! ip_checkentry( & e -> ip ) ) return - EINVAL ; <START_VULN> ret = xt_compat_check_entry_offsets(e , <END_VULN> e -> target_offset , e -> next_offset ) ; if (ret ) return ret ;
return ERR_PTR( - ENOBUFS ) ; memset(opt2 , 0 , tot_len ) ; <START_VULN> <END_VULN> opt2 -> tot_len = tot_len ; p = (char * ) (opt2 + 1 ) ;
* done = true ; spin_unlock_irqrestore( & lock , flags ) ; <START_VULN> __net_random_once_disable_jump(done_key ) ; <END_VULN> return true ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : code raw packets into framed OggSquish stream and decode Ogg streams back into raw packets <START_VULN> last mod : $ Id : framing . c 16051 2009 - 05 - 27 05 : 00 : 06Z xiphmont $ <END_VULN> note : The CRC code is directly derived from public domain code by Ross Williams (ross@guest . adelaide . edu . au ) . See docsframing . html for details . #include < stdlib . h >
if (cipher_def -> type == type_block ) { <START_VULN> const unsigned int blockSize = cipher_def -> iv_size ; <END_VULN> const unsigned int macSize = crSpec -> mac_size ; if (crSpec -> version <= SSL_LIBRARY_VERSION_3_0 ) {
protected : nsIntSize mLastSize ; nsIntPoint mLastPoint ; HWND mWnd ; WNDPROC mPrevWndProc ; HBRUSH mBrush ; PRPackedBool mIsTopWidgetWindow ; PRPackedBool mHas3DBorder ; <START_VULN> PRPackedBool mIsDestroying ; <END_VULN> PRPackedBool mIsVisible ; PRPackedBool mIsInMouseCapture ; PRPackedBool mInWheelProcessing ; PRPackedBool mUnicodeWidget ; PRPackedBool mIsPluginWindow ; PRPackedBool mPainting ; char mLeadByte ; PRUint32 mBlurSuppressLevel ;
} int touch(const char * path ) { <START_VULN> return touch_file(path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <END_VULN> } int symlink_idempotent(const char * from , const char * to ) {
} } } else { <START_VULN> for (i = 0 ; i < sec -> size ; i + = 8 ) { <END_VULN> ut64 addr64 = r_read_le64 (buf + i ) ; if (addr64 ) { RBinAddr * ba = newEntry (sec -> paddr + i , addr64 , type , bits ) ;
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("CRC32c (Castagnoli ) , sparc64 crc32c opcode accelerated" ) ; <START_VULN> MODULE_ALIAS("crc32c" ) ; <END_VULN> #include "crop_devid . c"
new -> ns = ns ; new -> uid = uid ; <START_VULN> atomic_set( & new -> count , 0 ) ; <END_VULN> spin_lock_irq( & ucounts_lock ) ; ucounts = find_ucounts(ns , uid , hashent ) ;
return - ENOMEM ; spin_lock_init( & tu -> qlock ) ; init_waitqueue_head( & tu -> qchange_sleep ) ; <START_VULN> mutex_init( & tu -> tread_sem ) ; <END_VULN> tu -> ticks = 1 ; tu -> queue_size = 128 ; tu -> queue = kmalloc(tu -> queue_size * sizeof(struct snd_timer_read ) ,
case TIOCGSID : return tiocgsid(tty , real_tty , p ) ; case TIOCGETD : <START_VULN> return put_user(tty -> ldisc -> ops -> num , (int __user * ) p ) ; <END_VULN> case TIOCSETD : return tiocsetd(tty , p ) ; case TIOCVHANGUP :
sizeof(_eth ) , data , hlen , & _eth ) ; if ( ! eth ) <START_VULN> return false ; <END_VULN> proto = eth -> h_proto ; nhoff + = sizeof( * eth ) ; }
static krb5_error_code <START_VULN> iakerb_alloc_context(iakerb_ctx_id_t * pctx ) <END_VULN> { iakerb_ctx_id_t ctx ; krb5_error_code code ;
DeletionConfirmationDlg(QWidget * parent , const int & size , const QString & name , bool defaultDeleteFiles ) : QDialog(parent ) { setupUi(this ) ; if (size == 1 ) <START_VULN> label -> setText(tr("Are you sure you want to delete ' % 1' from the transfer list ? " , "Are you sure you want to delete 'ubuntu - linux - iso' from the transfer list ? " ) . arg(name ) ) ; <END_VULN> else label -> setText(tr("Are you sure you want to delete these % 1 torrents from the transfer list ? " , "Are you sure you want to delete these 5 torrents from the transfer list ? " ) . arg(QString : : number(size ) ) ) ;
static PHP_MINIT_FUNCTION(pcre ) { REGISTER_INI_ENTRIES( ) ; <START_VULN> <END_VULN> REGISTER_LONG_CONSTANT("PREG_PATTERN_ORDER" , PREG_PATTERN_ORDER , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT("PREG_SET_ORDER" , PREG_SET_ORDER , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT("PREG_OFFSET_CAPTURE" , PREG_OFFSET_CAPTURE , CONST_CS | CONST_PERSISTENT ) ;
this -> sd = - 1 ; this -> sd = socket(AF_INET6 , SOCK_STREAM , 0 ) ; if (this -> sd < 0 ) { <START_VULN> ERR("sockect open failed" ) ; <END_VULN> goto error ; }
return CONNECTION_PREFACE . len ; } <START_VULN> static void parse_input(h2o_http2_conn_t * conn ) <END_VULN> { size_t http2_max_concurrent_requests_per_connection = conn -> super . ctx -> globalconf -> http2 . max_concurrent_requests_per_connection ; int perform_early_exit = 0 ;
else seq_puts(m , " [ anon ] " ) ; <START_VULN> if (key_is_instantiated(keyring ) ) { <END_VULN> if (keyring -> keys . nr_leaves_on_tree != 0 ) seq_printf(m , " : % lu" , keyring -> keys . nr_leaves_on_tree ) ; else
we're * not * floor1 . This won't happen unless someone has broken the encode setup lib . Guard it anyway . * if(ci -> floor_type [ info -> floorsubmap [ submap ] ] != 1 ) return( - 1 ) ; floor_posts [ i ] [ PACKETBLOBS2 ] = floor1_fit(vb , b -> flr [ info -> floorsubmap [ submap ] ] , logmdct , logmask ) ; <START_VULN> <END_VULN> if(vorbis_bitrate_managed(vb ) && floor_posts [ i ] [ PACKETBLOBS2 ] ) { _vp_offset_and_mix(psy_look , noise , tone ,
struct boot_sector b ; unsigned total_sectors ; unsigned short logical_sector_size , sectors ; <START_VULN> unsigned fat_length ; <END_VULN> unsigned total_fat_entries ; off_t data_size ;
. preparse = dns_resolver_preparse , . free_preparse = dns_resolver_free_preparse , . instantiate = generic_key_instantiate , <START_VULN> . match = dns_resolver_match , <END_VULN> . revoke = user_revoke , . destroy = user_destroy , . describe = dns_resolver_describe ,
} <START_VULN> map = q -> bufs [ first ] -> map = kmalloc(sizeof(struct videobuf_mapping ) , GFP_KERNEL ) ; <END_VULN> if (NULL == map ) return - ENOMEM ;
if (av_pix_fmt_desc_get(inlink -> format ) -> flags & AV_PIX_FMT_FLAG_PAL ) memcpy(out -> data [ 1 ] , in -> data [ 1 ] , AVPALETTE_SIZE ) ; <START_VULN> for (plane = 0 ; plane < 4 && in -> data [ plane ] ; plane + + ) { <END_VULN> const int width = (plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT(inlink -> w , s -> hsub ) : inlink -> w ; const int height = (plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT(inlink -> h , s -> vsub ) : inlink -> h ; step = s -> max_step [ plane ] ;
struct ipv6_ac_socklist * ipv6_ac_list ; struct ipv6_fl_socklist __rcu * ipv6_fl_list ; <START_VULN> struct ipv6_txoptions * opt ; <END_VULN> struct sk_buff * pktoptions ; struct sk_buff * rxpmtu ; struct inet6_corkcork ;
return NULL ; mutex_lock( & mut ) ; <START_VULN> mc -> id = idr_alloc( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ; <END_VULN> mutex_unlock( & mut ) ; if (mc -> id < 0 ) goto error ;
eWOFF_warn_checksum_mismatch = 0x0200 , eWOFF_warn_misaligned_table = 0x0400 , eWOFF_warn_trailing_data = 0x0800 , eWOFF_warn_unpadded_table = 0x1000 , <START_VULN> eWOFF_warn_removed_DSIG = 0x2000<END_VULN> } ; #define WOFF_SUCCESS(status ) (((uint32_t ) (status ) & 0xff ) == eWOFF_ok ) #define WOFF_FAILURE(status ) ( ! WOFF_SUCCESS(status ) )
JSObject * argv5 = JSVAL_TO_OBJECT(argv [ 5 ] ) ; jsval js_width , js_height , js_data ; JS_GetProperty(cx , argv5 , "width" , & js_width ) ; JS_GetProperty(cx , argv5 , "height" , & js_height ) ; JS_GetProperty(cx , argv5 , "data" , & js_data ) ; if (js_width == JSVAL_VOID || js_height == JSVAL_VOID || <START_VULN> js_data == JSVAL_VOID ) <END_VULN> { xpc_qsThrowBadArg(cx , NS_ERROR_FAILURE , vp , 5 ) ; return JS_FALSE ; } int32_t int_width , int_height ; JSObject * obj_data = JSVAL_TO_OBJECT(js_data ) ; if ( ! JS_ValueToECMAInt32(cx , js_width , & int_width ) || ! JS_ValueToECMAInt32(cx , js_height , & int_height ) )
} long vorbis_coslook_i(long a ) { int i = a >> COS_LOOKUP_I_SHIFT ; int d = a & COS_LOOKUP_I_MASK ; return COS_LOOKUP_I [ i ] - ((d * (COS_LOOKUP_I [ i ] - COS_LOOKUP_I [ i + 1 ] ) ) >> <START_VULN> COS_LOOKUP_I_SHIFT ) ; <END_VULN> } #endif
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : registry for time , floor , res backends and channel mappings <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_REG_H_ #define _V_REG_H_ #define VI_TRANSFORMB 1 #define VI_WINDOWB 1
krb5_free_error_message(handle -> context , errmsg ) ; } free(prime_arg1 ) ; free(prime_arg2 ) ; gss_release_buffer( & minor_stat , & client_name ) ; gss_release_buffer( & minor_stat , & service_name ) ; <START_VULN> exit_func : <END_VULN> free_server_handle(handle ) ; return & ret ; }
if (skb -> protocol == htons(ETH_P_IP ) ) return tcp_v4_do_rcv(sk , skb ) ; <START_VULN> if (sk_filter(sk , skb ) ) <END_VULN> goto discard ;
CRM_CHECK(client != NULL , return TRUE ) ; CRM_CHECK(update_msg != NULL , return TRUE ) ; <START_VULN> if (client -> ipc == NULL ) { <END_VULN> crm_warn("Skipping client with NULL channel" ) ; return FALSE ; }
<START_VULN> PHPAPI void php_clear_stat_cache(zend_bool clear_realpath_cache , const char * filename , int filename_len ) <END_VULN> {
BOOL updaterIsCorrect ; if (result && ! VerifySameFiles(argv [ 0 ] , installDirUpdater , updaterIsCorrect ) ) { LOG_WARN(("Error checking if the updaters are the same . " "Path 1 : % lsPath 2 : % ls" , argv [ 0 ] , installDirUpdater ) ) ; result = FALSE ; } if (result && ! updaterIsCorrect ) { <START_VULN> LOG_WARN(("The updaters do not match , udpater will not run . " ) ) ; <END_VULN> result = FALSE ; } if (result ) { LOG(("updater . exe was compared successfully to the installation directory" " updater . exe . " ) ) ; } else { if ( ! WriteStatusFailure(argv [ 1 ] , SERVICE_UPDATER_COMPARE_ERROR ) ) { LOG_WARN(("Could not write update . status updater compare failure . " ) ) ;
kSqrt = (12 << 8 ) + 26 , kDup = (12 << 8 ) + 27 , kExch = (12 << 8 ) + 28 , kIndex = (12 << 8 ) + 29 , kRoll = (12 << 8 ) + 30 , kHFlex = (12 << 8 ) + 34 , kFlex = (12 << 8 ) + 35 , kHFlex1 = (12 << 8 ) + 36 , <START_VULN> kFlex1 = (12 << 8 ) + 37 , <END_VULN> } ; } #endif
const char * buf , size_t count ) { struct platform_device * pdev = to_platform_device(dev ) ; <START_VULN> char * driver_override , * old = pdev -> driver_override , * cp ; <END_VULN> if (count > PATH_MAX ) return - EINVAL ;
uchar * buf_ ; <START_VULN> int bufsize_ ; <END_VULN> int_fast32_t len_ ;
return error ; } <START_VULN> perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> destreg = (opcode >> 4 ) & 0x3f ; if (user_mode(regs ) ) {
snd_timer_interrupt(substream -> timer , 1 ) ; #endif _end : <START_VULN> snd_pcm_stream_unlock_irqrestore(substream , flags ) ; <END_VULN> kill_fasync( & runtime -> fasync , SIGIO , POLL_IN ) ; } EXPORT_SYMBOL(snd_pcm_period_elapsed ) ;
perf_sample_data_init( & data , 0 ) ; data . period = event -> hw . last_period ; <START_VULN> if (perf_event_overflow(event , nmi , & data , regs ) ) <END_VULN> fsl_emb_pmu_stop(event , 0 ) ; } }
if(remain >= len ) { rlen = len ; } else { <START_VULN> if(remain == 0 ) { <END_VULN>
unsigned int address , destreg , data , type ; unsigned int res = 0 ; <START_VULN> perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <END_VULN> if (current -> pid != previous_pid ) { pr_debug("" % s" ( % ld ) uses deprecated SWP { B } instruction" ,
OM_uint32 code ; ctx = (krb5_gss_ctx_id_rec * ) context_handle ; <START_VULN> if ( ! ctx -> established ) { <END_VULN> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
} ptep_user = (pt_element_t __user * ) ((void * ) host_addr + offset ) ; <START_VULN> if (unlikely(copy_from_user( & pte , ptep_user , sizeof(pte ) ) ) ) { <END_VULN> present = false ; break ; }
} const nsCString & ClassName( ) const { return mImplementation ? mImplementation -> mClassName : EmptyCString( ) ; } nsresult InitClass(const nsCString & aClassName , JSContext * aContext , JSObject * aGlobal , JSObject * aScriptObject , <START_VULN> JSObject ** aClassObject ) ; <END_VULN> nsresult ConstructInterfaceTable(const nsAString & aImpls ) ; void SetImplementation(nsXBLProtoImpl * aImpl ) { mImplementation = aImpl ; } nsresult InstallImplementation(nsXBLBinding * aBinding ) ; bool HasImplementation( ) const { return mImplementation != nullptr ; } void AttributeChanged(nsIAtom * aAttribute , int32_t aNameSpaceID ,
return 0 ; unmap_pages : <START_VULN> kvm_iommu_put_pages(kvm , slot -> base_gfn , gfn ) ; <END_VULN> return r ; }
} <START_VULN> <END_VULN> struct snd_seq_client_port * snd_seq_create_port(struct snd_seq_client * client , int port ) {
if (log_level ) { verbose(" % d : " , insn_idx ) ; <START_VULN> print_bpf_insn(insn ) ; <END_VULN> } err = ext_analyzer_insn_hook(env , insn_idx , prev_insn_idx ) ;
vA = buf [ 1 ] & 0x0f ; vB = (buf [ 1 ] & 0xf0 ) >> 4 ; vC = (int ) (buf [ 3 ] << 8 | buf [ 2 ] ) ; <START_VULN> <END_VULN> snprintf (str , sizeof (str ) , " v % i , v % i , 0x % 08"PFMT64x , vA , vB , a -> pc + (vC * 2 ) ) ; strasm = r_str_concat (strasm , str ) ; break ;
Com_Printf( " -- -- - Initializing Renderer -- -- " ) ; #ifdef USE_RENDERER_DLOPEN <START_VULN> cl_renderer = Cvar_Get("cl_renderer" , "opengl1" , CVAR_ARCHIVE | CVAR_LATCH ) ; <END_VULN> Com_sprintf(dllName , sizeof(dllName ) , "renderer_mp_ % s_" ARCH_STRING DLL_EXT , cl_renderer -> string ) ;
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm , Supplemental SSE3 accelerated" ) ; <START_VULN> MODULE_ALIAS("sha1" ) ; <END_VULN>
public : bool Equals(const nsSMILInstanceTime * aElem1 , const nsSMILInstanceTime * aElem2 ) const ; bool LessThan(const nsSMILInstanceTime * aElem1 , const nsSMILInstanceTime * aElem2 ) const ; } ; struct NotifyTimeDependentsParams { <START_VULN> nsSMILInterval * mCurrentInterval ; <END_VULN> nsSMILTimeContainer * mTimeContainer ; } ; template < class TestFunctor > void RemoveInstanceTimes(InstanceTimeList & aArray , TestFunctor & aTest ) ;
if ( ! fstype ) { error = - ENODEV ; goto out ; } if (fstype -> fs_flags & FS_REQUIRES_DEV ) need_dev = 1 ; } if (need_dev ) { <START_VULN> if (kern_path(dev_name , LOOKUP_FOLLOW , & path ) ) { <END_VULN> error = - ENOENT ; goto out ; } requested_dev_name = tomoyo_realpath_from_path( & path ) ; if ( ! requested_dev_name ) { error = - ENOENT ; goto out ; } } else {
nsresult InitClass(const nsCString & aClassName , JSContext * aContext , JSObject * aGlobal , JSObject * aScriptObject , JSObject ** aClassObject ) ; nsresult ConstructInterfaceTable(const nsAString & aImpls ) ; void SetImplementation(nsXBLProtoImpl * aImpl ) { mImplementation = aImpl ; } <START_VULN> nsresult InstallImplementation(nsIContent * aBoundElement ) ; <END_VULN> bool HasImplementation( ) const { return mImplementation != nullptr ; } void AttributeChanged(nsIAtom * aAttribute , int32_t aNameSpaceID , bool aRemoveFlag , nsIContent * aChangedElement , nsIContent * aAnonymousContent , bool aNotify ) ; void SetBasePrototype(nsXBLPrototypeBinding * aBinding ) ; nsXBLPrototypeBinding * GetBasePrototype( ) { return mBaseBinding ; }
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("GHASH Message Digest Algorithm , " "acclerated by PCLMULQDQ - NI" ) ; <START_VULN> MODULE_ALIAS("ghash" ) ; <END_VULN>
static u32 challenge_timestamp ; static unsigned int challenge_count ; struct tcp_sock * tp = tcp_sk(sk ) ; <START_VULN> u32 now ; <END_VULN> if (tcp_oow_rate_limited(sock_net(sk ) , skb ,
#ifndef imgStatusTracker_h__ #define imgStatusTracker_h__ class imgDecoderObserver ; class imgIContainer ; <START_VULN> class imgRequestProxy ; <END_VULN> class imgStatusNotifyRunnable ; class imgRequestNotifyRunnable ; class imgStatusTrackerObserver ; class imgStatusTrackerNotifyingObserver ; class nsIRunnable ; #include "mozillaRefPtr . h" #include "nsCOMPtr . h" #include "nsTObserverArray . h" #include "nsRect . h" namespace mozilla { namespace image { class Image ; struct ImageStatusDiff {
if (request . magic != htonl(NBD_REQUEST_MAGIC ) ) err("Not enough magic . " ) ; <START_VULN> if (len > BUFSIZE + sizeof(struct nbd_reply ) ) <END_VULN> err("Request too big ! " ) ; #ifdef DODBG printf(" % s from % llu ( % llu ) len % d , " , request . type ? "WRITE" :
{ SFE_BAD_CHUNK_MARKER , "Error : Bad chunk marker . " } , { SFE_BAD_CHUNK_DATA_PTR , "Error : Bad data pointer in SF_CHUNK_INFO struct . " } , { SFE_FILENAME_TOO_LONG , "Error : Supplied filename too long . " } , <START_VULN> <END_VULN> { SFE_MAX_ERROR , "Maximum error number . " } , { SFE_MAX_ERROR + 1 , NULL }
out_cleanup : ovl_cleanup(wdir , newdentry ) ; <START_VULN> goto out ; <END_VULN> }
return error ; } <START_VULN> perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> srcreg = (opcode >> 4 ) & 0x3f ; if (user_mode(regs ) ) {
uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; int i , plane , vsub = desc -> log2_chroma_h ; <START_VULN> for (plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane + + ) { <END_VULN> int64_t linesize = av_image_get_linesize(frame -> format , frame -> width , plane ) ; uint8_t * data = frame -> data [ plane ] ; int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(inlink -> h , vsub ) : inlink -> h ;
virtual bool IsTransportSeekable( ) = 0 ; <START_VULN> static MediaResource * Create(MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <END_VULN> virtual nsresult Open(nsIStreamListener ** aStreamListener ) = 0 ; #ifdef MOZ_DASH
case NCI_NFC_B_PASSIVE_POLL_MODE : nfcb_poll = & ntf -> activation_params . nfcb_poll_iso_dep ; <START_VULN> nfcb_poll -> attrib_res_len = * data + + ; <END_VULN> pr_debug("attrib_res_len % d" , nfcb_poll -> attrib_res_len ) ; if (nfcb_poll -> attrib_res_len > 0 ) { memcpy(nfcb_poll -> attrib_res ,
#include < linuxinit . h > #include < linuxfs . h > #include < linuxslab . h > <START_VULN> #include < linuxmbcache . h > <END_VULN> #include < linuxquotaops . h > #include "ext4_jbd2 . h" #include "ext4 . h"
uint8_t * dataPointer( ) const ; <START_VULN> void neuter(JSContext * cx ) ; <END_VULN>
switch (intern -> type ) { case SPL_FS_DIR : test = spl_filesystem_object_get_path(intern , NULL ) ; <START_VULN> fname_len = (php_stat_len ) spprintf( & fname , 0 , " % s % c % s" , test , DEFAULT_SLASH , intern -> u . dir . entry . d_name ) ; <END_VULN> php_stat(fname , fname_len , FS_IS_DIR , & dummy ) ; if (Z_TYPE(dummy ) == IS_TRUE ) {
free( devices ) ; devices = NULL ; } <START_VULN> return 1 ; <END_VULN> }
print_res_top(result ) ; if (opt_show_keys ) { <START_VULN> end = strmov(strmov(strmov(query , "show keys from `" ) , table ) , "`" ) ; <END_VULN> if (mysql_query(mysql , query ) || ! (result = mysql_store_result(mysql ) ) ) { fprintf(stderr , " % s : Cannot list keys in db : % s , table : % s : % s" ,
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : cdf . c , v 1 . 48 20120217 05 : 27 : 45 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
{ case MGT_FRAME : dissect_ieee80211_mgt (fcf , next_tvb , pinfo , tree ) ; break ; case DATA_FRAME : if (is_amsdu && tvb_reported_length_remaining(next_tvb , 0 ) > 4 ) { tvbuff_t * volatile msdu_tvb = NULL ; guint32 msdu_offset = 0 ; <START_VULN> guint16 i = 1 ; <END_VULN> const guint8 * lcl_src = NULL ; const guint8 * lcl_dst = NULL ; guint16 msdu_length ; proto_item * parent_item ; proto_tree * mpdu_tree ; proto_tree * subframe_tree ; parent_item = proto_tree_add_protocol_format(tree , proto_aggregate , next_tvb , 0 , tvb_reported_length_remaining(next_tvb , 0 ) , "IEEE 802 . 11 Aggregate MSDU" ) ; mpdu_tree = proto_item_add_subtree(parent_item , ett_msdu_aggregation_parent_tree ) ;
struct ipcm_cookie { __be32addr ; intoif ; <START_VULN> struct ip_options * opt ; <END_VULN> __u8tx_flags ; } ;
goto bail ; } <START_VULN> request_buf . length = mutt_b64_decode(buf2 , idata -> buf + 2 ) ; <END_VULN> request_buf . value = buf2 ; sec_token = & request_buf ;
if (page == NULL ) page = http_request_get_query_string(req ) ; <START_VULN> if (page && (access(page , R_OK ) == 0 ) ) <END_VULN> { http_response_printf(res , " % s" , file_read(page ) ) ; http_response_send(res ) ;
struct ttm_object_file * tfile = vmw_fpriv(file_priv ) -> tfile ; int ret ; uint32_t size ; <START_VULN> uint32_t backup_handle ; <END_VULN> if (req -> multisample_count != 0 ) return - EINVAL ;
av_get_picture_type_char(frame -> pict_type ) , checksum , plane_checksum [ 0 ] ) ; <START_VULN> for (plane = 1 ; plane < 4 && frame -> data [ plane ] ; plane + + ) <END_VULN> av_log(ctx , AV_LOG_INFO , " % 08X" , plane_checksum [ plane ] ) ; av_log(ctx , AV_LOG_INFO , " ] " ) ;
return error ; } <START_VULN> perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> srcreg = (opcode >> 4 ) & 0x3f ; if (user_mode(regs ) ) {
1 , - 533200896 , 1611661312 , 4 , 1 , partial_quantlist1 , NULL , NULL , NULL , 0 } ; static float test5_result [ ] = { - 3 , - 6 , - 9 , 4 , 1 , - 2 , - 1 , - 4 , - 7 , - 3 , 1 , - 2 , 4 , 8 , 5 , - 1 , 3 , 0 , <START_VULN> - 3 , - 4 , - 7 , 4 , 3 , 0 , - 1 , - 2 , - 5 , <END_VULN> - 3 , - 6 , - 2 , 4 , 1 , 5 , - 1 , - 4 , 0 , - 3 , 1 , 5 , 4 , 8 , 12 , - 1 , 3 , 7 , - 3 , - 4 , 0 , 4 , 3 , 7 , - 1 , - 2 , 2 , - 3 , - 6 , - 7 , 4 , 1 , 0 , - 1 , - 4 , - 5 , - 3 , 1 , 0 , 4 , 8 , 7 , - 1 , 3 , 2 , - 3 , - 4 , - 5 , 4 , 3 , 2 , - 1 , - 2 , - 3 } ; void run_test(static_codebook * b , float * comp ) {
sock -> _wreq . bufs = sock -> _wreq . smallbufs ; } else { sock -> _wreq . bufs = h2o_mem_alloc(sizeof(h2o_iovec_t ) * bufcnt ) ; <START_VULN> sock -> _wreq . alloced_ptr = sock -> _wreq . bufs = sock -> _wreq . bufs ; <END_VULN> } memcpy(sock -> _wreq . bufs , bufs , sizeof(h2o_iovec_t ) * bufcnt ) ; sock -> _wreq . cnt = bufcnt ;
float * floatptr ; double * doubleptr ; charc ; <START_VULN> intbyte_count = 0 , count ; <END_VULN> if ( ! format ) return psf_ftell (psf ) ;
room = dst_mtu( & rt -> dst ) ; if (room > 576 ) room = 576 ; <START_VULN> room -= sizeof(struct iphdr ) + icmp_param . replyopts . optlen ; <END_VULN> room -= sizeof(struct icmphdr ) ; icmp_param . data_len = skb_in -> len - icmp_param . offset ;
#define base64val ( c ) Index64 [ ( unsigned int ) ( c ) ] size_t mutt_b64_encode ( char * out , const char * cin , size_t len , size_t olen ) ; <START_VULN> int mutt_b64_decode ( char * out , const char * in ) ; <END_VULN> #endif
int size ; syscall_nr = trace_get_syscall_nr ( current , regs ) ; <START_VULN> if ( syscall_nr < 0 ) <END_VULN> return ; if ( ! test_bit ( syscall_nr , enabled_perf_exit_syscalls ) ) return ;
if ( * firsthardlink < 0 ) { * firsthardlink = rpmfiFX ( fi ) ; <START_VULN> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <END_VULN> } else { char * fn = rpmfilesFN ( files , * firsthardlink ) ;
reserve = ( end - start ) - region_count ( & reservations - > regions , start , end ) ; <START_VULN> kref_put ( & reservations - > refs , resv_map_release ) ; <END_VULN> if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ;
} LOCAL ( boolean ) get_sos ( j_decompress_ptr cinfo ) { INT32 length ; <START_VULN> int i , ci , n , c , cc ; <END_VULN> jpeg_component_info * compptr ; INPUT_VARS ( cinfo ) ; if ( ! cinfo - > marker - > saw_SOF ) ERREXIT ( cinfo , JERR_SOS_NO_SOF ) ; INPUT_2BYTES ( cinfo , length , return FALSE ) ;
cl_allowDownload = Cvar_Get ( "cl_allowDownload" , "0" , CVAR_ARCHIVE ) ; #ifdef USE_CURL_DLOPEN <START_VULN> cl_cURLLib = Cvar_Get ( "cl_cURLLib" , DEFAULT_CURL_LIB , CVAR_ARCHIVE ) ; <END_VULN> #endif
struct inode ; <START_VULN> extern int parse_rock_ridge_inode ( struct iso_directory_record * , struct inode * ) ; <END_VULN> extern int get_rock_ridge_filename ( struct iso_directory_record * , char * , struct inode * ) ; extern int isofs_name_translate ( struct iso_directory_record * , char * , struct inode * ) ;
#define AUDITSC_SUCCESS 1 #define AUDITSC_FAILURE 2 <START_VULN> <END_VULN> #define MAX_EXECVE_AUDIT_LEN 7500
hwc - > event_base = 0 ; } else if ( hwc - > idx >= X86_PMC_IDX_FIXED ) { hwc - > config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL ; <START_VULN> hwc - > event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ; <END_VULN> } else { hwc - > config_base = x86_pmu_config_addr ( hwc - > idx ) ; hwc - > event_base = x86_pmu_event_addr ( hwc - > idx ) ;
struct task_struct * tsk ; struct mm_struct * mm ; int fault , sig , code ; <START_VULN> unsigned long vm_flags = VM_READ | VM_WRITE ; <END_VULN> unsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE ; tsk = current ;
REG ( "coredump_filter" , S_IRUGO | S_IWUSR , proc_coredump_filter_operations ) , #endif #ifdef CONFIG_TASK_IO_ACCOUNTING <START_VULN> INF ( "io" , S_IRUGO , proc_tgid_io_accounting ) , <END_VULN> #endif #ifdef CONFIG_HARDWALL INF ( "hardwall" , S_IRUGO , proc_pid_hardwall ) ,
unsigned long nr_segs , loff_t * poffset ) { unsigned long nr_pages , i ; <START_VULN> size_t copied , len , cur_len ; <END_VULN> ssize_t total_written = 0 ; loff_t offset ; struct iov_iter it ;
case LC_LOAD_WEAK_DYLIB : sdb_set ( bin - > kv , sdb_fmt ( 0 , "mach0_cmd_ % d . cmd" , i ) , "load_dylib" , 0 ) ; bin - > nlibs ++ ; <START_VULN> if ( ! parse_dylib ( bin , off ) ) { <END_VULN> bprintf ( "Cannot parse dylib" ) ; bin - > nlibs -- ; return false ;
if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } <START_VULN> v |= ( c << 24 ) ; <END_VULN> if ( -- n <= 0 ) { break ; }
goto end ; <START_VULN> p = BuildTestPacket ( id , 1 , 0 , 'A' , 0 ) ; <END_VULN> if ( p == NULL ) goto end ;
} <START_VULN> if ( i > ( sizeof ( outbuff ) - 20 ) ) { <END_VULN> outbuff [ i ] = '0' ; fprintf ( f , " % s" , outbuff ) ; i = 0 ;
struct qeth_cmd_buffer * iob ; struct qeth_ipa_cmd * cmd ; struct qeth_snmp_ureq * ureq ; <START_VULN> int req_len ; <END_VULN> struct qeth_arp_query_info qinfo = { 0 , } ; int rc = 0 ;
{ rtnl_link_unregister ( & ipgre_tap_ops ) ; rtnl_link_unregister ( & ipgre_link_ops ) ; <START_VULN> unregister_pernet_device ( & ipgre_net_ops ) ; <END_VULN> if ( inet_del_protocol ( & ipgre_protocol , IPPROTO_GRE ) < 0 ) printk ( KERN_INFO "ipgre close : can't remove protocol" ) ; } module_init ( ipgre_init ) ;
phar_flush ( phar , 0 , 0 , 1 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; efree ( oldpath ) ; return NULL ;
rcu_read_lock ( ) ; indev = __in_dev_get_rcu ( skb - > dev ) ; <START_VULN> if ( indev != NULL ) { <END_VULN> ifa = indev - > ifa_list ; newdst = ifa - > ifa_local ; }
} int install_process_keyring_to_cred ( struct cred * new ) { struct key * keyring ; if ( new - > process_keyring ) <START_VULN> return - EEXIST ; <END_VULN> keyring = keyring_alloc ( "_pid" , new - > uid , new - > gid , new , KEY_POS_ALL | KEY_USR_VIEW ,
. open = ftrace_pid_open , . write = ftrace_pid_write , . read = seq_read , <START_VULN> . llseek = seq_lseek , <END_VULN> . release = ftrace_pid_release , } ;
Sdb * sdb_parent = sdb_new0 ( ) ; isum + = aux . vda_next ; vstart + = aux . vda_next ; <START_VULN> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <END_VULN> sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ;
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : softmagic . c , v 1 . 170 20140106 02 : 25 : 32 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
. index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , <START_VULN> . match_data . cmp = type - > match , <END_VULN> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK ,
{ MsgToEventLog ( M_SYSERR , TEXT ( "malformed startup data : 1 byte received" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <START_VULN> goto out ; <END_VULN> } data = malloc ( bytes ) ;
_vp_offset_and_mix ( psy_look , noise , tone , 1 , logmask , mdct , logmdct ) ; <START_VULN> <END_VULN> #if 0 if ( vi - > channels == 2 ) { if ( i == 0 ) _analysis_output ( "aotuvM1_L" , seq , aotuv , psy_look - > n , 1 , 1 , 0 ) ; else _analysis_output ( "aotuvM1_R" , seq , aotuv , psy_look - > n , 1 , 1 , 0 ) ; } else { _analysis_output ( "aotuvM1" , seq , aotuv , psy_look - > n , 1 , 1 , 0 ) ;
n = e - > band [ j ] . end ; e - > band [ j ] . window = _ogg_malloc ( n * sizeof ( * e - > band [ 0 ] . window ) ) ; for ( i = 0 ; i < n ; i ++ ) { e - > band [ j ] . window [ i ] = sin ( ( i+ . 5 ) n * M_PI ) ; e - > band [ j ] . total+ = e - > band [ j ] . window [ i ] ; } e - > band [ j ] . total = 1 . e - > band [ j ] . total ; } <START_VULN> <END_VULN> e - > filter = _ogg_calloc ( VE_BANDS * ch , sizeof ( * e - > filter ) ) ; e - > mark = _ogg_calloc ( e - > storage , sizeof ( * e - > mark ) ) ; } void _ve_envelope_clear ( envelope_lookup * e ) { int i ; mdct_clear ( & e - > mdct ) ;
unsigned long now ; getnstimeofday ( & n ) ; <START_VULN> now = timespec_to_ns ( n ) ; <END_VULN> if ( when > now ) when -= now ; else
while ( 0x80 != plaintext [ cipher_len - 2 ] && ( cipher_len - 2 > 0 ) ) cipher_len -- ; <START_VULN> if ( 2 == cipher_len ) <END_VULN> return - 1 ; memcpy ( out , plaintext , cipher_len - 2 ) ;
{ uint32_t length ; uint32_t flags ; <START_VULN> <END_VULN> char c_string [ 1 ] ; } SIZED_STRING ;
if ( size > batadv_frag_size_limit ( ) ) goto free ; entry = hlist_entry ( chain - > first , struct batadv_frag_list_entry , list ) ; hlist_del ( & entry - > list ) ; skb_out = entry - > skb ; kfree ( entry ) ; <START_VULN> if ( pskb_expand_head ( skb_out , 0 , size - skb - > len , GFP_ATOMIC ) < 0 ) { <END_VULN> kfree_skb ( skb_out ) ; skb_out = NULL ; goto free ; } skb_pull_rcsum ( skb_out , hdr_size ) ; memmove ( skb_out - > data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ) ; skb_set_mac_header ( skb_out , - ETH_HLEN ) ; skb_reset_network_header ( skb_out ) ;
* bool NS_FASTCALL SetCapacity ( size_type newCapacity ) ; <START_VULN> void NS_FASTCALL SetLength ( size_type newLength ) ; <END_VULN> void Truncate ( size_type newLength = 0 ) { NS_ASSERTION ( newLength <= mLength , "Truncate cannot make string longer" ) ; SetLength ( newLength ) ; }
hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; if ( ! hdr ) <START_VULN> return false ; <END_VULN>
extern void nfs_setattr_update_inode ( struct inode * inode , struct iattr * attr ) ; extern struct nfs_open_context * get_nfs_open_context ( struct nfs_open_context * ctx ) ; extern void put_nfs_open_context ( struct nfs_open_context * ctx ) ; <START_VULN> extern struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode ) ; <END_VULN> extern u64 nfs_compat_user_ino64 ( u64 fileid ) ; extern void nfs_fattr_init ( struct nfs_fattr * fattr ) ;
XPCWrappedNativeScope * GetScope ( ) const { return mScope ; } XPCJSRuntime * GetRuntime ( ) const { return mScope - > GetRuntime ( ) ; } JSObject * <START_VULN> GetJSProtoObject ( ) const { return mJSProtoObject ; } <END_VULN> nsIClassInfo * GetClassInfo ( ) const { return mClassInfo ; } XPCNativeSet * GetSet ( ) const { return mSet ; } XPCNativeScriptableInfo *
const char * aPropertyName , const char * anInterfaceName , PRBool aForceReport ) ; private : nsXPCWrappedJSClass ( ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : lookup data ; generated by lookups . pl ; edit there <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_LOOKUP_DATA_H_ #ifdef FLOAT_LOOKUP #define COS_LOOKUP_SZ 128 static const float COS_LOOKUP [ COS_LOOKUP_SZ+1 ] = {
if ( nd - > flags & LOOKUP_RCU ) { return follow_dotdot_rcu ( nd ) ; } else <START_VULN> follow_dotdot ( nd ) ; <END_VULN> } return 0 ; }
} <START_VULN> f2fs_wait_discard_bios ( sbi ) ; <END_VULN> if ( f2fs_discard_en ( sbi ) && ! sbi - > discard_blks ) { struct cp_control cpc = {
break ; } } <START_VULN> q [ i ] = ClampToQuantum ( pixel ) ; <END_VULN> } p+ = GetPixelChannels ( composite_image ) ; channels = GetPixelChannels ( composite_image ) ;
- 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 62 , - 1 , - 1 , - 1 , 63 , <START_VULN> 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , <END_VULN> - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 ,
else ffmax = 128 ; <START_VULN> r = idr_start ( a , idr , isoent - > children . cnt , ffmax , 6 , 2 , & rb_ops ) ; <END_VULN> if ( r < 0 ) return ( r ) ;
if ( fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { zend_throw_error ( exception_ce , message ) ; } else { <START_VULN> zend_error ( E_ERROR , message ) ; <END_VULN> } efree ( message ) ;
ide_set_irq ( s - > bus ) ; return false ; case SMART_EXECUTE_OFFLINE : switch ( s - > sector ) { case 0 : case 1 : case 2 : s - > smart_selftest_count ++ ; if ( s - > smart_selftest_count > 21 ) { <START_VULN> s - > smart_selftest_count = 0 ; <END_VULN> } n = 2 + ( s - > smart_selftest_count - 1 ) * 24 ; s - > smart_selftest_data [ n ] = s - > sector ; s - > smart_selftest_data [ n + 1 ] = 0x00 ; s - > smart_selftest_data [ n + 2 ] = 0x34 ; s - > smart_selftest_data [ n + 3 ] = 0x12 ; break ; default : goto abort_cmd ; }
static void TraceBlackJS ( JSTracer * trc , void * data ) ; static void TraceGrayJS ( JSTracer * trc , void * data ) ; void TraceXPConnectRoots ( JSTracer * trc ) ; void AddXPConnectRoots ( nsCycleCollectionTraversalCallback & cb ) ; void UnmarkSkippableJSHolders ( ) ; static void GCCallback ( JSRuntime * rt , JSGCStatus status ) ; <START_VULN> static void FinalizeCallback ( JSFreeOp * fop , JSFinalizeStatus status ) ; <END_VULN> inline void AddVariantRoot ( XPCTraceableVariant * variant ) ; inline void AddWrappedJSRoot ( nsXPCWrappedJS * wrappedJS ) ; inline void AddObjectHolderRoot ( XPCJSObjectHolder * holder ) ; nsresult AddJSHolder ( void * aHolder , nsScriptObjectTracer * aTracer ) ; nsresult RemoveJSHolder ( void * aHolder ) ;
av_get_picture_type_char ( frame - > pict_type ) , checksum , plane_checksum [ 0 ] ) ; <START_VULN> for ( plane = 1 ; plane < 4 && frame - > data [ plane ] ; plane ++ ) <END_VULN> av_log ( ctx , AV_LOG_INFO , " % 08X" , plane_checksum [ plane ] ) ; av_log ( ctx , AV_LOG_INFO , " ] " ) ;
return error ; } <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) {
else seq_puts ( m , " [ anon ] " ) ; <START_VULN> if ( key_is_instantiated ( keyring ) ) { <END_VULN> if ( keyring - > keys . nr_leaves_on_tree != 0 ) seq_printf ( m , " : % lu" , keyring - > keys . nr_leaves_on_tree ) ; else
vif = pending_tx_info - > vif ; <START_VULN> make_tx_response ( vif , & pending_tx_info - > req , XEN_NETIF_RSP_OKAY ) ; <END_VULN>
break ; case SO_PASSCRED : <START_VULN> v . val = test_bit ( SOCK_PASSCRED , & sock - > flags ) ? 1 : 0 ; <END_VULN> break ; case SO_PEERCRED :
{ int i ; for ( i = 31 ; i >= 0 ; i -- ) { <START_VULN> if ( x & ( 1 << i ) ) return i ; <END_VULN> } return 0 ; }
case CIPSO_V4_TAG_LOCAL : <START_VULN> if ( ! ( skb - > dev - > flags & IFF_LOOPBACK ) ) { <END_VULN> err_offset = opt_iter ; goto validate_return_locked ; }
int xt_register_matches ( struct xt_match * match , unsigned int n ) ; void xt_unregister_matches ( struct xt_match * match , unsigned int n ) ; <START_VULN> int xt_check_entry_offsets ( const void * base , <END_VULN> unsigned int target_offset , unsigned int next_offset ) ;
ret = - EIO ; if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) && <START_VULN> ! test_bit ( KEY_FLAG_INSTANTIATED , & key - > flags ) ) <END_VULN> goto invalid_key ;
struct ext4_iloc iloc ; int err = 0 , rc ; <START_VULN> if ( ! ext4_handle_valid ( handle ) ) <END_VULN> return 0 ; mutex_lock ( & EXT4_SB ( sb ) - > s_orphan_lock ) ;
FlatpakProxy * proxy ; gboolean authenticated ; <START_VULN> int auth_end_offset ; <END_VULN> ProxySide client_side ; ProxySide bus_side ;
class AutoCompartment { JSContext * const cx_ ; JSCompartment * const origin_ ; public : inline AutoCompartment ( JSContext * cx , JSObject * target ) ; <START_VULN> inline AutoCompartment ( JSContext * cx , JSCompartment * target ) ; <END_VULN> inline ~ AutoCompartment ( ) ; JSContext * context ( ) const { return cx_ ; } JSCompartment * origin ( ) const { return origin_ ; } private : AutoCompartment ( const AutoCompartment & ) MOZ_DELETE ; AutoCompartment & operator = ( const AutoCompartment & ) MOZ_DELETE ;
* <START_VULN> <END_VULN> #include "cert . h" #include "ssl . h" #include "cryptohi . h" #include "keyhi . h" #include "secder . h" #include "secitem . h"
if ( data - > state != NULL ) { struct nfs_delegation * delegation ; <START_VULN> if ( can_open_cached ( data - > state , data - > o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) ) <END_VULN> goto out_no_action ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( data - > state - > inode ) - > delegation ) ;
} size_offsets = ( size_offsets + 1 ) * 3 ; offsets = ( int * ) safe_emalloc ( size_offsets , sizeof ( int ) , 0 ) ; <START_VULN> <END_VULN> array_init ( return_value ) ;
xtmp = sk_X509_pop ( ctx - > chain ) ; X509_free ( xtmp ) ; num -- ; <START_VULN> ctx - > last_untrusted -- ; <END_VULN> } retry = 1 ; break ; }
} offsets = ( int * ) safe_emalloc ( size_offsets , sizeof ( int ) , 0 ) ; <START_VULN> <END_VULN> alloc_len = 2 * subject_len + 1 ; result = safe_emalloc ( alloc_len , sizeof ( char ) , 0 ) ;
bool mListenerEnabled ; bool mReturnInEmptyLIKillsList ; bool mDidDeleteSelection ; bool mDidRangedDelete ; bool mRestoreContentEditableCount ; nsCOMPtr < nsIDOMRange > mUtilRange ; PRUint32 mJoinOffset ; nsCOMPtr < nsIDOMNode > mNewBlock ; <START_VULN> nsRangeStore mRangeItem ; <END_VULN> StyleCache mCachedStyles [ SIZE_STYLE_TABLE ] ; } ; #endif
NS_IMETHOD ResetInputState ( ) ; NS_IMETHOD_ ( void ) SetInputContext ( const InputContext & aContext , const InputContextAction & aAction ) ; NS_IMETHOD_ ( InputContext ) GetInputContext ( ) ; NS_IMETHOD CancelIMEComposition ( ) ; NS_IMETHOD OnIMEFocusChange ( bool aFocus ) ; NS_IMETHOD GetToggledKeyState ( uint32_t aKeyCode , bool * aLEDState ) ; <START_VULN> void ResizeTransparencyBitmap ( int32_t aNewWidth , int32_t aNewHeight ) ; <END_VULN> void ApplyTransparencyBitmap ( ) ; virtual void SetTransparencyMode ( nsTransparencyMode aMode ) ; virtual nsTransparencyMode GetTransparencyMode ( ) ; virtual nsresult ConfigureChildren ( const nsTArray < Configuration > & aConfigurations ) ; nsresult UpdateTranslucentWindowAlphaInternal ( const nsIntRect & aRect , uint8_t * aAlphas , int32_t aStride ) ; #if defined ( MOZ_WIDGET_GTK2 )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : window functions <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_WINDOW_ #define _V_WINDOW_ extern float * _vorbis_window_get ( int n ) ; extern void _vorbis_apply_window ( float * d , int * winno , long * blocksizes ,
nsIRunnable * mPendingInstantiateEvent ; nsCString mContentType ; <START_VULN> nsIChannel * mChannel ; <END_VULN> nsCOMPtr < nsIURI > mURI ; ObjectType mType : 16 ;
key_addrs - > tipcaddrs . srcnode = hdr - > srcnode ; key_control - > addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS ; } <START_VULN> return true ; <END_VULN> } case htons ( ETH_P_MPLS_UC ) :
. write_iter = generic_file_write_iter , . mmap = generic_file_mmap , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . fsync = jfs_fsync , . release = jfs_release , . unlocked_ioctl = jfs_ioctl ,
size_t mjitDataSize ; #endif <START_VULN> bool inOOMReport ; <END_VULN> #if defined ( MOZ_GCTIMER ) || defined ( JSGC_TESTPILOT ) struct GCData { uint64 firstEnter ; bool firstEnterValid ;
if ( blocks == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ReadBlob ( image , ( size_t ) length , blocks ) ; <START_VULN> if ( ( count != ( ssize_t ) length ) || <END_VULN> ( LocaleNCompare ( ( char * ) blocks , "8BIM" , 4 ) != 0 ) ) { blocks = ( unsigned char * ) RelinquishMagickMemory ( blocks ) ;
HDC mMemoryDC ; nsTransparencyMode mTransparencyMode ; #endif PRPackedBool mIsTopWidgetWindow ; PRPackedBool mHas3DBorder ; PRPackedBool mIsShiftDown ; PRPackedBool mIsControlDown ; PRPackedBool mIsAltDown ; <START_VULN> PRPackedBool mIsDestroying ; <END_VULN> PRPackedBool mIsVisible ; PRPackedBool mIsInMouseCapture ; PRPackedBool mIsInMouseWheelProcessing ; PRPackedBool mUnicodeWidget ; PRPackedBool mIsPluginWindow ; PRPackedBool mPainting ; char mLeadByte ;
static int sock_close ( struct inode * inode , struct file * filp ) { <START_VULN> sock_release ( SOCKET_I ( inode ) ) ; <END_VULN> return 0 ; }
password_empty = 1 ; } <START_VULN> } else { <END_VULN> cli_md5_init ( & md5 ) ;
} else { unsigned char * out ; <START_VULN> unsigned long outlen , loid [ 16 ] ; <END_VULN> int decoded ; ltc_asn1_list digestinfo [ 2 ] , siginfo [ 2 ] ;
if ( ! sar . num ) sar . num = sar . den = 1 ; <START_VULN> for ( plane = 0 ; plane < 4 && in - > data [ plane ] ; plane ++ ) { <END_VULN> int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ; int vsub = plane == 1 || plane == 2 ? vsub0 : 0 ;
#endif #ifdef HAVE_GNUTLS_GNUTLS_H <START_VULN> const int tls_kx_order [ ] = { <END_VULN> GNUTLS_KX_ANON_DH , GNUTLS_KX_DHE_RSA , GNUTLS_KX_DHE_DSS ,
<START_VULN> <END_VULN> #define MEDIATYPE_TYPEMAX64
avpriv_request_sample ( pb , "Primer pack item length % d" , item_len ) ; return AVERROR_PATCHWELCOME ; } <START_VULN> if ( item_num > 65536 ) { <END_VULN> av_log ( mxf - > fc , AV_LOG_ERROR , "item_num % d is too large" , item_num ) ; return AVERROR_INVALIDDATA ; }
fprintf ( trace , "" KID = "" ) ; } dump_data_hex ( trace , ( char * ) ptr - > KID , 16 ) ; <START_VULN> if ( ptr - > version ) <END_VULN> fprintf ( trace , "" crypt_byte_block = " % d" skip_byte_block = " % d" , ptr - > crypt_byte_block , ptr - > skip_byte_block ) ; fprintf ( trace , "" > " ) ; gf_isom_box_dump_done ( "TrackEncryptionBox" , a , trace ) ;
void * jas_realloc ( void * ptr , size_t size ) { void * result ; <START_VULN> JAS_DBGLOG ( 101 , ( "jas_realloc called with % x , % zu" , ptr , size ) ) ; <END_VULN> result = realloc ( ptr , size ) ; JAS_DBGLOG ( 100 , ( "jas_realloc ( % p , % zu ) - > % p" , ptr , size , result ) ) ; return result ;
if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ; <START_VULN> <END_VULN> eol_detect = stream - > flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;
<START_VULN> <END_VULN> % lld" , st - > st_size ) ;
<START_VULN> uintdblocks = XFS_B_TO_FSB ( mp , valuelen ) ; <END_VULN> nblks + = dblocks ; nblks + = XFS_NEXTENTADD_SPACE_RES ( mp , dblocks , XFS_ATTR_FORK ) ; }
payload = NULL ; <START_VULN> if ( _payload ) { <END_VULN> ret = - ENOMEM ; payload = kmalloc ( plen , GFP_KERNEL ) ; if ( ! payload )
#ifndef imgStatusTracker_h__ #define imgStatusTracker_h__ class imgDecoderObserver ; class imgIContainer ; <START_VULN> class imgRequestProxy ; <END_VULN> class imgStatusNotifyRunnable ; class imgRequestNotifyRunnable ; class imgStatusTrackerObserver ; class imgStatusTrackerNotifyingObserver ; class nsIRunnable ; #include "mozillaRefPtr . h" #include "mozillaWeakPtr . h" #include "nsCOMPtr . h" #include "nsTObserverArray . h" #include "nsThreadUtils . h" #include "nsRect . h" namespace mozilla { namespace image { class Image ; struct ImageStatusDiff {
verdef - > vd_aux = READ32 ( dfs , j ) verdef - > vd_next = READ32 ( dfs , j ) int vdaux = verdef - > vd_aux ; <START_VULN> if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) { <END_VULN> sdb_free ( sdb_verdef ) ; goto out_error ; }
case CSN_PADDING_BITS : { if ( remaining_bits_len > 0 ) { proto_item * ti = proto_tree_add_text ( tree , tvb , bit_offset >> 3 , - 1 , "Padding Bits" ) ; proto_tree * padding_tree = proto_item_add_subtree ( ti , ett_csn1 ) ; while ( remaining_bits_len > 0 ) { <START_VULN> guint8 bits_to_handle = remaining_bits_len + ( bit_offset % 8 ) ; <END_VULN> if ( bits_to_handle > 32 ) { bits_to_handle = 32 - ( bit_offset % 8 ) ; } else { bits_to_handle -= ( bit_offset % 8 ) ; } proto_tree_add_text ( padding_tree , tvb , bit_offset >> 3 , ( ( bit_offset+bits_to_handle - 1 ) >> 3 ) - ( bit_offset >> 3 ) +1 , " % s % s" , decode_bits_in_field ( bit_offset , bits_to_handle , tvb_get_bits ( tvb , bit_offset , bits_to_handle , ENC_BIG_ENDIAN ) ) ,
int post , err ; char headers [ HTTP_HEADERS_SIZE ] = "" ; char * authstr = NULL , * proxyauthstr = NULL ; <START_VULN> int64_t off = s - > off ; <END_VULN> int len = 0 ; const char * method ; int send_expect_100 = 0 ;
perf_sample_data_init ( & data , 0 ) ; data . period = event - > hw . last_period ; <START_VULN> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <END_VULN> fsl_emb_pmu_stop ( event , 0 ) ; } }
msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; <START_VULN> if ( vmx_set_msr ( vcpu , & msr ) != 0 ) { <END_VULN> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( vcpu , 0 ) ; return 1 ;
struct ipv6_opt_hdr * dst0opt ; struct ipv6_rt_hdr * srcrt ; struct ipv6_opt_hdr * dst1opt ; <START_VULN> <END_VULN> } ;
MXFEssenceContainerData * essence_data ; if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf - > essence_container_data_refs [ k ] , EssenceContainerData ) ) ) { <START_VULN> av_log ( mxf , AV_LOG_TRACE , "could not resolve essence container data strong ref" ) ; <END_VULN> continue ; } if ( ! memcmp ( component - > source_package_ul , essence_data - > package_ul , sizeof ( UID ) ) && ! memcmp ( component - > source_package_uid , essence_data - > package_uid , sizeof ( UID ) ) ) {
TraceMonitor * tm = & JS_THREAD_DATA ( cx ) - > traceMonitor ; JS_ASSERT ( tm - > codeAlloc && tm - > dataAlloc && tm - > traceAlloc ) ; if ( bytes > 1 G ) bytes = 1 G ; if ( bytes < 128 K ) bytes = 128 K ; tm - > maxCodeCacheBytes = bytes ; } <START_VULN> void<END_VULN> InitJIT ( TraceMonitor * tm ) { #if defined JS_JIT_SPEW tm - > profAlloc = NULL ; if ( ! did_we_set_up_debug_logging ) { InitJITLogController ( ) ; did_we_set_up_debug_logging = true ; }
q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; <START_VULN> <END_VULN> ret = futex_wait_setup ( uaddr , val , fshared , & q , & hb ) ; if ( ret ) goto out_key2 ;
int CVE_2013_1726_mar_read_product_info_block ( MarFile * mar , struct ProductInformationBlock * infoBlock ) { <START_VULN> int i , hasAdditionalBlocks , offset , <END_VULN> offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; char buf [ 97 ] = { '0' } ; int ret = get_mar_file_info_fp ( mar - > fp , NULL , NULL , & hasAdditionalBlocks , & offsetAdditionalBlocks , & numAdditionalBlocks ) ; for ( i = 0 ; i < numAdditionalBlocks ; ++ i ) {
if ( fd < 0 ) return - errno ; <START_VULN> if ( mode > 0 ) { <END_VULN> r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ;
dev - > udev = interface_to_usbdev ( intf ) ; for ( i = 0 ; i < icount ; i ++ ) { <START_VULN> dev - > canch [ i ] = gs_make_candev ( i , intf , & dconf ) ; <END_VULN> if ( IS_ERR_OR_NULL ( dev - > canch [ i ] ) ) { rc = PTR_ERR ( dev - > canch [ i ] ) ;
linenr_Tline_lnum ; colnr_Tline_colnr ; linenr_Tline_count ; <START_VULN> intnum_head = 0 ; <END_VULN> longold_header_seq , new_header_seq , cur_header_seq ; longseq_last , seq_cur ; longlast_save_nr = 0 ;
if ( i+1 < P_BANDS ) { int l = 0 ; k = i+1 ; for ( j = 0 ; j < EHMER_MAX ; j ++ ) { int lo_bin = fromOC ( j * . 125+i * . 5 - 2 . 0625 ) binHz ; int hi_bin = fromOC ( j * . 125+i * . 5 - 1 . 9375 ) binHz+1 ; <START_VULN> <END_VULN> if ( lo_bin < 0 ) lo_bin = 0 ; if ( lo_bin > n ) lo_bin = n ; if ( lo_bin < l ) l = lo_bin ; if ( hi_bin < 0 ) hi_bin = 0 ; if ( hi_bin > n ) hi_bin = n ; for ( ; l < hi_bin && l < n ; l ++ ) if ( brute_buffer [ l ] > workc [ k ] [ m ] [ j ] )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic shared codebook operations <START_VULN> last mod : $ Id : codebook . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_CODEBOOK_H_ #define _V_CODEBOOK_H_ #include < oggogg . h >
umode_t mode = attr - > ia_mode ; if ( ! in_group_p ( inode - > i_gid ) && <START_VULN> ! inode_capable ( inode , CAP_FSETID ) ) <END_VULN> mode &= ~ S_ISGID ; inode - > i_mode = mode ; }
if ( ! page ) { ret = - ENOMEM ; page = page_cache_alloc_cold ( mapping ) ; if ( unlikely ( ! page ) ) goto out_ret ; ret = add_to_page_cache_lru ( page , mapping , index , GFP_KERNEL ) ; if ( unlikely ( ret ) ) <START_VULN> goto out ; <END_VULN> } ret = mapping - > a_ops - > prepare_write ( file , page , offset , offset+this_len ) ; if ( unlikely ( ret ) ) { loff_t isize = i_size_read ( mapping - > host ) ; if ( ret != AOP_TRUNCATED_PAGE ) unlock_page ( page ) ; page_cache_release ( page ) ; if ( ret == AOP_TRUNCATED_PAGE )
mutt_debug ( 2 , "Handling untagged NO" ) ; <START_VULN> mutt_error ( " % s" , s + 3 ) ; <END_VULN> } return 0 ;
#ifndef _V_LOOKUP_H_ #ifdef FLOAT_LOOKUP extern float vorbis_coslook ( float a ) ; extern float vorbis_invsqlook ( float a ) ; extern float vorbis_invsq2explook ( int a ) ; extern float vorbis_fromdBlook ( float a ) ; #endif #ifdef INT_LOOKUP extern long vorbis_invsqlook_i ( long a , long e ) ; extern long vorbis_coslook_i ( long a ) ; extern float vorbis_fromdBlook_i ( long a ) ; <START_VULN> #endif<END_VULN> #endif
unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { <START_VULN> size_t off = 0 , len = 0 ; <END_VULN> #define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) * delta ++ << shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ;
<START_VULN> if ( * rsize >= 74 && <END_VULN> rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f &&
cwd [ 2 ] = '0' ; } #endif <START_VULN> cwd_skip = ( int ) strlen ( cwd ) +1 ; <END_VULN> snprintf ( work_pattern , MAXPATHLEN , " % s % c % s" , cwd , DEFAULT_SLASH , pattern ) ; pattern = work_pattern ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : LPC low level routines <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_LPC_H_ #define _V_LPC_H_ #include "vorbiscodec . h"
{ if ( ( opcode & OPCODE ) == SPEC0 && ( opcode & FUNC ) == SYNC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <START_VULN> 1 , 0 , regs , 0 ) ; <END_VULN> return 0 ; }
else status = 1 ; <START_VULN> if ( caught_signal ) <END_VULN> { fprintf ( stderr , _ ( "Session terminated , killing shell . . . " ) ) ; kill ( child , SIGTERM ) ;
void usb_serial_console_disconnect ( struct usb_serial * serial ) { <START_VULN> if ( serial - > port [ 0 ] == usbcons_info . port ) { <END_VULN> usb_serial_console_exit ( ) ; usb_serial_put ( serial ) ; }
<START_VULN> if ( offset > pkt_len ) { <END_VULN> * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen : too much hex - data" ) ; return FALSE ;
class nsPNGDecoder : public Decoder { public : nsPNGDecoder ( RasterImage & aImage ) ; virtual ~ nsPNGDecoder ( ) ; virtual void InitInternal ( ) ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual Telemetry : : ID SpeedHistogram ( ) ; void CreateFrame ( png_uint_32 x_offset , png_uint_32 y_offset , int32_t width , int32_t height , gfxImageFormat format ) ; void EndImageFrame ( ) ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm , Supplemental SSE3 accelerated" ) ; <START_VULN> MODULE_ALIAS ( "sha1" ) ; <END_VULN>
evt - > event . lun [ 0 ] = 0x01 ; <START_VULN> evt - > event . lun [ 1 ] = tpg - > tport_tpgt & 0xFF ; <END_VULN> if ( lun - > unpacked_lun >= 256 ) evt - > event . lun [ 2 ] = lun - > unpacked_lun >> 8 | 0x40 ; evt - > event . lun [ 3 ] = lun - > unpacked_lun & 0xFF ;
js : : gc : : MarkStringUnbarriered ( trc , & d . u1 . left , "left child" ) ; js : : gc : : MarkStringUnbarriered ( trc , & d . s . u2 . right , "right child" ) ; } JS_ALWAYS_INLINE void JSDependentString : : init ( JSLinearString * base , const jschar * chars , size_t length ) { JS_ASSERT ( ! js : : IsPoisonedPtr ( base ) ) ; <START_VULN> d . lengthAndFlags = buildLengthAndFlags ( length , DEPENDENT_BIT ) ; <END_VULN> d . u1 . chars = chars ; d . s . u2 . base = base ; JSString : : writeBarrierPost ( d . s . u2 . base , & d . s . u2 . base ) ; } JS_ALWAYS_INLINE JSDependentString * JSDependentString : : new_ ( JSContext * cx , JSLinearString * base_ , const jschar * chars , size_t length ) {
less strict that the _ve_envelope_search , the search is not run if we only use one block size * } <START_VULN> <END_VULN> _vorbis_block_ripcord ( vb ) ; vb - > lW = v - > lW ; vb - > W = v - > W ; vb - > nW = v - > nW ;
PORT_ZFree ( slotPw . data , PL_strlen ( slotPw . data ) ) ; if ( p12FilePw . data != NULL ) PORT_ZFree ( p12FilePw . data , PL_strlen ( p12FilePw . data ) ) ; if ( slot ) PK11_FreeSlot ( slot ) ; if ( NSS_Shutdown ( ) != SECSuccess ) { pk12uErrno = 1 ; } PR_Cleanup ( ) ; <START_VULN> PL_ArenaFinish ( ) ; <END_VULN> return pk12uErrno ; }
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 115 20141216 20 : 53 : 05 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
. data = & kptr_restrict , . maxlen = sizeof ( int ) , . mode = 0644 , <START_VULN> . proc_handler = proc_dointvec_minmax , <END_VULN> . extra1 = & zero , . extra2 = & two , } ,
if ( err == - EINPROGRESS ) return NF_STOLEN ; <START_VULN> return NF_ACCEPT ; <END_VULN> } static struct nf_hook_ops ipv6_defrag_ops [ ] = {
spin_lock_bh ( & net - > nsid_lock ) ; peer = idr_find ( & net - > netns_ids , id ) ; if ( peer ) <START_VULN> get_net ( peer ) ; <END_VULN> spin_unlock_bh ( & net - > nsid_lock ) ; rcu_read_unlock ( ) ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 55 20140227 23 : 26 : 17 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
newstate = nfs4_opendata_to_nfs4_state ( opendata ) ; if ( IS_ERR ( newstate ) ) return PTR_ERR ( newstate ) ; <START_VULN> nfs4_close_state ( & opendata - > path , newstate , openflags ) ; <END_VULN> * res = newstate ; return 0 ; }
ret = hugetlb_acct_memory ( h , chg ) ; if ( ret < 0 ) { hugepage_subpool_put_pages ( spool , chg ) ; <START_VULN> return ret ; <END_VULN> }
int lines ; int compressed_lines ; signed short line_packets ; int y_ptr ; int byte_run ; int pixel_skip ; int pixel_countdown ; unsigned char * pixels ; int pixel ; <START_VULN> int pixel_limit ; <END_VULN> s - > frame . reference = 1 ; s - > frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ; if ( avctx - > reget_buffer ( avctx , & s - > frame ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "reget_buffer ( ) failed" ) ; return - 1 ; } pixels = s - > frame . data [ 0 ] ; pixel_limit = s - > avctx - > height * s - > frame . linesize [ 0 ] ;
const wbxml_decoding * map ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; <START_VULN> guint32 off = offset ; <END_VULN> guint32 len ; guint str_len ; guint32 ent ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis backend and mapping structures ; needed for static mode headers <START_VULN> last mod : $ Id : backends . h 16326 2009 - 07 - 24 00 : 06 : 53Z xiphmont $ <END_VULN> #ifndef _vorbis_backend_h_
log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; } gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <START_VULN> exit_func : <END_VULN> free_server_handle ( handle ) ; return & ret ;
static int mp_get_count ( struct sb_uart_state * state , struct serial_icounter_struct * icnt ) { <START_VULN> struct serial_icounter_struct icount ; <END_VULN> struct sb_uart_icount cnow ; struct sb_uart_port * port = state - > port ;
parent = dentry - > d_parent ; nfs_block_sillyrename ( parent ) ; <START_VULN> state = nfs4_do_open ( dir , & path , nd - > intent . open . flags , & attr , cred ) ; <END_VULN> put_rpccred ( cred ) ; if ( IS_ERR ( state ) ) { if ( PTR_ERR ( state ) == - ENOENT ) {
Token currentToken ; unsigned lookahead ; Token lookaheadTokens [ maxLookahead ] ; } ; void advance ( size_t position ) ; void tell ( Position * ) ; void seek ( const Position & pos ) ; <START_VULN> void seek ( const Position & pos , const TokenStream & other ) ; <END_VULN> size_t positionToOffset ( const Position & pos ) const { return pos . buf - userbuf . base ( ) ; } const jschar * rawBase ( ) const { return userbuf . base ( ) ; }
static __u8 * mr_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <START_VULN> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <END_VULN> hid_info ( hdev , "fixing up buttonconsumer in HID report descriptor" ) ; rdesc [ 30 ] = 0x0c ; }
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "MD4 Message Digest Algorithm" ) ; <START_VULN> <END_VULN>
<START_VULN> int mutt_b64_decode ( char * out , const char * in ) <END_VULN> { int len = 0 ; unsigned char digit4 ;
{ inti ; u_entry_T * uep ; <START_VULN> char_u ** array ; <END_VULN> char_u * line ; intline_len ;
static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { long i ; <START_VULN> for ( i = 0 ; i <= w - sizeof ( long ) ; i + = sizeof ( long ) ) { <END_VULN> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ;
if ( ! TRC ) return NULL ; gamma_table = malloc ( sizeof ( float ) * 256 ) ; if ( gamma_table ) { if ( TRC - > type == PARAMETRIC_CURVE_TYPE ) { compute_curve_gamma_table_type_parametric ( gamma_table , TRC - > parameter , TRC - > count ) ; } else { if ( TRC - > count == 0 ) { compute_curve_gamma_table_type0 ( gamma_table ) ; } else if ( TRC - > count == 1 ) { <START_VULN> compute_curve_gamma_table_type1 ( gamma_table , u8Fixed8Number_to_float ( TRC - > data [ 0 ] ) ) ; <END_VULN> } else { compute_curve_gamma_table_type2 ( gamma_table , TRC - > data , TRC - > count ) ; } } } return gamma_table ; }
{ const struct x86_emulate_ops * ops = ctxt - > ops ; struct desc_struct cs , ss ; <START_VULN> u64 msr_data ; <END_VULN> int usermode ; u16 cs_sel = 0 , ss_sel = 0 ;
return error ; } <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) {
: clasp ( clasp ) , proto ( proto ) , parent ( parent ) , nfixed ( nfixed ) , baseFlags ( baseFlags ) { } } ; inline InitialShapeEntry ( ) ; inline InitialShapeEntry ( const ReadBarriered < Shape > & shape , TaggedProto proto ) ; <START_VULN> inline Lookup getLookup ( ) ; <END_VULN> static inline HashNumber hash ( const Lookup & lookup ) ; static inline bool match ( const InitialShapeEntry & key , const Lookup & lookup ) ; } ; typedef HashSet < InitialShapeEntry , InitialShapeEntry , SystemAllocPolicy > InitialShapeSet ; struct StackShape
n = ( ( * p ) [ 0 ] << 8 ) | ( * p ) [ 1 ] ; * p + = 2 ; <START_VULN> if ( n < 1 || n > 65535 || * p + n > end ) <END_VULN> { MBEDTLS_SSL_DEBUG_MSG ( 1 , ( "bad client key exchange message" ) ) ; return ( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE ) ;
#define CEPH_MSGR_TAG_SEQ 13 #define CEPH_MSGR_TAG_KEEPALIVE2 14 #define CEPH_MSGR_TAG_KEEPALIVE2_ACK 15 <START_VULN> <END_VULN>
#include "WrapperFactory . h" class nsIPrincipal ; namespace xpc { class AccessCheck { public : <START_VULN> static bool isSameOrigin ( JSCompartment * a , JSCompartment * b ) ; <END_VULN> static bool isChrome ( JSCompartment * compartment ) ; static bool callerIsChrome ( ) ; static nsIPrincipal * getPrincipal ( JSCompartment * compartment ) ; static bool isCrossOriginAccessPermitted ( JSContext * cx , JSObject * obj , jsid id , js : : Wrapper : : Action act ) ; static bool isSystemOnlyAccessPermitted ( JSContext * cx ) ; static bool isLocationObjectSameOrigin ( JSContext * cx , JSObject * wrapper ) ; static bool documentDomainMakesSameOrigin ( JSContext * cx , JSObject * obj ) ;
else size = offsetof ( struct fxregs_state , xmm_space [ 0 ] ) ; <START_VULN> return segmented_write ( ctxt , ctxt - > memop . addr . mem , & fx_state , size ) ; <END_VULN> } static int fxrstor_fixup ( struct x86_emulate_ctxt * ctxt ,
{ struct xfrm_algo * algo ; struct nlattr * nla ; nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth - > alg_key_len + 7 ) 8 ) ; if ( ! nla ) return - EMSGSIZE ; algo = nla_data ( nla ) ; <START_VULN> strcpy ( algo - > alg_name , auth - > alg_name ) ; <END_VULN> memcpy ( algo - > alg_key , auth - > alg_key , ( auth - > alg_key_len + 7 ) 8 ) ; algo - > alg_key_len = auth - > alg_key_len ; return 0 ; }
} uint32_t numInstructions ( ) const { return numInstructions_ ; } void setLocalSlotCount ( uint32_t localSlotCount ) { localSlotCount_ = localSlotCount ; } uint32_t localSlotCount ( ) const { <START_VULN> return localSlotCount_ ; <END_VULN> } void setArgumentSlotCount ( uint32_t argumentSlotCount ) { argumentSlotCount_ = argumentSlotCount ; } uint32_t argumentSlotCount ( ) const { return argumentSlotCount_ ; } uint32_t totalSlotCount ( ) const {
. read_iter = generic_file_read_iter , . write_iter = generic_file_write_iter , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . llseek = generic_file_llseek , } ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : maintain the info structure , info < - > header packets <START_VULN> last mod : $ Id : info . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h >
perf_prepare_sample ( & header , & data , event , & regs ) ; <START_VULN> if ( perf_output_begin ( & handle , event , header . size * ( top - at ) , 1 , 1 ) ) <END_VULN> return 1 ; for ( ; at < top ; at ++ ) {
#else crm_notice ( "Starting a tls listener on port % d . " , port ) ; gnutls_global_init ( ) ; <START_VULN> <END_VULN> gnutls_global_set_log_function ( debug_log ) ; gnutls_dh_params_init ( & dh_params ) ; gnutls_dh_params_generate2 ( dh_params , DH_BITS ) ;
addr = gfn_to_hva ( kvm , gfn ) ; if ( kvm_is_error_hva ( addr ) ) return - EFAULT ; <START_VULN> r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ; <END_VULN> if ( r ) return - EFAULT ; return 0 ;
} if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; RETURN_FALSE ; }
flags |= IS_RDONLY ( d_inode ( lower_dentry ) ) ? O_RDONLY : O_RDWR ; ( * lower_file ) = dentry_open ( & req . path , flags , cred ) ; if ( ! IS_ERR ( * lower_file ) ) <START_VULN> goto out ; <END_VULN> if ( ( flags & O_ACCMODE ) == O_RDONLY ) { rc = PTR_ERR ( ( * lower_file ) ) ; goto out ;
} <START_VULN> map = q - > bufs [ first ] - > map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ; <END_VULN> if ( NULL == map ) return - ENOMEM ;
errx ( EXIT_FAILURE , _ ( "Shell * NOT * changed . Try again later . " ) ) ; #else pw - > pw_shell = info . shell ; <START_VULN> if ( setpwnam ( pw ) < 0 ) <END_VULN> err ( EXIT_FAILURE , _ ( "setpwnam failed" "Shell * NOT * changed . Try again later . " ) ) ; #endif
{ case MGT_FRAME : dissect_ieee80211_mgt ( fcf , next_tvb , pinfo , tree ) ; break ; case DATA_FRAME : if ( is_amsdu && tvb_reported_length_remaining ( next_tvb , 0 ) > 4 ) { tvbuff_t * volatile msdu_tvb = NULL ; guint32 msdu_offset = 0 ; <START_VULN> guint16 i = 1 ; <END_VULN> const guint8 * lcl_src = NULL ; const guint8 * lcl_dst = NULL ; guint16 msdu_length ; proto_item * parent_item ; proto_tree * mpdu_tree ; proto_tree * subframe_tree ; parent_item = proto_tree_add_protocol_format ( tree , proto_aggregate , next_tvb , 0 , tvb_reported_length_remaining ( next_tvb , 0 ) , "IEEE 802 . 11 Aggregate MSDU" ) ; mpdu_tree = proto_item_add_subtree ( parent_item , ett_msdu_aggregation_parent_tree ) ;
if ( NULL == siocb - > scm ) siocb - > scm = & scm ; <START_VULN> err = scm_send ( sock , msg , siocb - > scm ) ; <END_VULN> if ( err < 0 ) return err ;
n = 0 ; quantum = 0 ; <START_VULN> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x+ = 2 ) <END_VULN> { for ( i = 0 ; i < 4 ; i ++ ) {
{ public : static JSBool GetCallingLocation ( JSContext * aContext , const char * * aFilename , <START_VULN> PRUint32 * aLineno ) ; <END_VULN> static jsval ConvertStringToJSVal ( const nsString & aProp , JSContext * aContext ) ;
int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , <START_VULN> const char * name , int rep_quick ) <END_VULN> { int got_error ; uint i , key , total_key_length , istep ;
. open = ftrace_filter_open , . read = seq_read , . write = ftrace_filter_write , <START_VULN> . llseek = ftrace_regex_lseek , <END_VULN> . release = ftrace_regex_release , } ;
char * datablob ; int ret = 0 ; <START_VULN> if ( test_bit ( KEY_FLAG_NEGATIVE , & key - > flags ) ) <END_VULN> return - ENOKEY ; p = key - > payload . data [ 0 ] ; if ( ! p - > migratable )
Foundation , Inc . , 675 Mass Ave , Cambridge , MA 02139 , USA . <START_VULN> #include < cryptoskcipher . h > <END_VULN> #include < linuxmodule . h > #include < linuxslab . h > #include < linuxfs . h >
kSqrt = ( 12 << 8 ) + 26 , kDup = ( 12 << 8 ) + 27 , kExch = ( 12 << 8 ) + 28 , kIndex = ( 12 << 8 ) + 29 , kRoll = ( 12 << 8 ) + 30 , kHFlex = ( 12 << 8 ) + 34 , kFlex = ( 12 << 8 ) + 35 , kHFlex1 = ( 12 << 8 ) + 36 , <START_VULN> kFlex1 = ( 12 << 8 ) + 37 , <END_VULN> } ; } #endif
{ int error ; struct dentry * dentry = NULL , * trap ; <START_VULN> const char * old_name ; <END_VULN> trap = lock_rename ( new_dir , old_dir ) ;
if ( remain >= len ) { rlen = len ; } else { <START_VULN> if ( remain == 0 ) { <END_VULN>
sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; ++ cb ; ++ cr ; } <START_VULN> if ( j < maxw ) <END_VULN> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ;
sp = regs - > gpr [ 1 ] ; perf_callchain_store ( entry , next_ip ) ; <START_VULN> for ( ; ; ) { <END_VULN> fp = ( unsigned long __user * ) sp ; if ( ! valid_user_sp ( sp , 1 ) || read_user_stack_64 ( fp , & next_sp ) ) return ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : psychoacoustics not including preecho <START_VULN> last mod : $ Id : psy . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < math . h > #include < string . h > #include "vorbiscodec . h" #include "codec_internal . h"
size_t cnt , loff_t * ppos ) ; ssize_t ftrace_notrace_write ( struct file * file , const char __user * ubuf , size_t cnt , loff_t * ppos ) ; <START_VULN> loff_t ftrace_regex_lseek ( struct file * file , loff_t offset , int whence ) ; <END_VULN> int ftrace_regex_release ( struct inode * inode , struct file * file ) ; void __init
int initialContextToken = ( * context_handle == GSS_C_NO_CONTEXT ) ; if ( initialContextToken ) { <START_VULN> code = iakerb_alloc_context ( & ctx ) ; <END_VULN> if ( code != 0 ) { * minor_status = code ; goto cleanup ;
return NULL ; } <START_VULN> ret = snprintf ( dest , len , " % slocklxc % s" , rundir , p ) ; <END_VULN> if ( ret < 0 || ret >= len ) { free ( dest ) ; free ( rundir ) ;
} } <START_VULN> good = ( unsigned ) - 1 ; <END_VULN> minLength = crSpec - > mac_size ; if ( cipher_def - > type == type_block ) {
bool mListenerEnabled ; bool mReturnInEmptyLIKillsList ; bool mDidDeleteSelection ; bool mDidRangedDelete ; bool mRestoreContentEditableCount ; nsRefPtr < nsRange > mUtilRange ; PRUint32 mJoinOffset ; nsCOMPtr < nsIDOMNode > mNewBlock ; <START_VULN> nsRangeStore mRangeItem ; <END_VULN> StyleCache mCachedStyles [ SIZE_STYLE_TABLE ] ; } ; #endif
ask - > private = ctx ; <START_VULN> skcipher_request_set_tfm ( & ctx - > req , private ) ; <END_VULN> skcipher_request_set_callback ( & ctx - > req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx - > completion ) ;
phar_flush ( phar_obj - > arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
0 . 9999998698F , 0 . 9999998906F , 0 . 9999999088F , 0 . 9999999246F , 0 . 9999999383F , 0 . 9999999500F , 0 . 9999999600F , 0 . 9999999684F , 0 . 9999999754F , 0 . 9999999811F , 0 . 9999999858F , 0 . 9999999896F , 0 . 9999999925F , 0 . 9999999948F , 0 . 9999999965F , 0 . 9999999978F , 0 . 9999999986F , 0 . 9999999992F , 0 . 9999999996F , 0 . 9999999998F , 0 . 9999999999F , 1 . 0000000000F , 1 . 0000000000F , 1 . 0000000000F , } ; <START_VULN> static float vwin8192 [ 4096 ] = { <END_VULN> 0 . 0000000578F , 0 . 0000005198F , 0 . 0000014438F , 0 . 0000028299F , 0 . 0000046780F , 0 . 0000069882F , 0 . 0000097604F , 0 . 0000129945F , 0 . 0000166908F , 0 . 0000208490F , 0 . 0000254692F , 0 . 0000305515F , 0 . 0000360958F , 0 . 0000421021F , 0 . 0000485704F , 0 . 0000555006F , 0 . 0000628929F , 0 . 0000707472F , 0 . 0000790635F , 0 . 0000878417F , 0 . 0000970820F , 0 . 0001067842F , 0 . 0001169483F , 0 . 0001275744F , 0 . 0001386625F , 0 . 0001502126F , 0 . 0001622245F , 0 . 0001746984F , 0 . 0001876343F , 0 . 0002010320F , 0 . 0002148917F , 0 . 0002292132F ,
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : fft transform <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_SMFT_H_ #define _V_SMFT_H_ #include "vorbiscodec . h"
bits [ 1 ] = cpu_to_be64 ( sctx - > count [ 0 ] << 3 ) ; <START_VULN> bits [ 0 ] = cpu_to_be64 ( sctx - > count [ 1 ] << 3 ) | sctx - > count [ 0 ] >> 61 ; <END_VULN>
#endif <START_VULN> cmd = zend_string_alloc ( 2 * l , 0 ) ; <END_VULN> for ( x = 0 , y = 0 ; x < l ; x ++ ) { int mb_len = php_mblen ( str + x , ( l - x ) ) ;
#endif if ( ! is_anonymous ) { <START_VULN> if ( s && s > filename ) { <END_VULN> safe_php_register_variable ( lbuf , s+1 , strlen ( s+1 ) , NULL , 0 TSRMLS_CC ) ; } else { safe_php_register_variable ( lbuf , filename , strlen ( filename ) , NULL , 0 TSRMLS_CC ) ;
ctl_dir = container_of ( head , struct ctl_dir , header ) ; if ( ! dir_emit_dots ( file , ctx ) ) <START_VULN> return 0 ; <END_VULN> pos = 2 ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : random psychoacoustics ( not including preecho ) <START_VULN> last mod : $ Id : psy . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_PSY_H_ #define _V_PSY_H_ #include "smallft . h" #include "backends . h"
uint8_t * dataPointer ( ) const ; <START_VULN> void neuter ( JSContext * cx ) ; <END_VULN>
protected : nsPresContext * mPresContext ; nsCOMPtr < nsIPresShell > mPresShell ; nsCOMPtr < nsISelection > mSelection ; nsRefPtr < nsRange > mFirstSelectedRange ; nsCOMPtr < nsIContent > mRootContent ; nsresult Init ( WidgetQueryContentEvent * aEvent ) ; nsresult Init ( WidgetSelectionEvent * aEvent ) ; <START_VULN> <END_VULN> nsresult InitCommon ( ) ; public : static nsresult GetFlatTextOffsetOfRange ( nsIContent * aRootContent , nsINode * aNode , int32_t aNodeOffset ,
int size ; syscall_nr = trace_get_syscall_nr ( current , regs ) ; <START_VULN> if ( syscall_nr < 0 ) <END_VULN> return ; if ( ! test_bit ( syscall_nr , enabled_perf_exit_syscalls ) ) return ; commit 086ba77a6db00ed858ff07451bedee197df868c9 Author : Rabin Vincent < rabin@rab . in > Date : Wed Oct 29 23 : 06 : 58 2014 +0100 tracingsyscalls : Ignore numbers outside NR_syscalls' range ARM has some private syscalls ( for example , set_tls ( 2 ) ) which lie outside the range of NR_syscalls . If any of these are called while syscall tracing is being performed , out - of - bounds array access will occur in the ftrace and perf sys_ { enter , exit } handlers . # trace - cmd record - e raw_syscalls : * true && trace - cmd report . . . true - 653 [ 000 ] 384 . 675777 : sys_enter : NR 192 ( 0 , 1000 , 3 , 4000022 , ffffffff , 0 ) true - 653 [ 000 ] 384 . 675812 : sys_exit : NR 192 = 1995915264 true - 653 [ 000 ] 384 . 675971 : sys_enter : NR 983045 ( 76f74480 , 76f74000 , 76f74b28 , 76f74480 , 76f76f74 , 1 ) true - 653 [ 000 ] 384 . 675988 : sys_exit : NR 983045 = 0 . . . # trace - cmd record - e syscalls : * true [ 17 . 289329 ] Unable to handle kernel paging request at virtual address aaaaaace [ 17 . 289590 ] pgd = 9e71c000 [ 17 . 289696 ] [ aaaaaace ] * pgd = 00000000 [ 17 . 289985 ] Internal error : Oops : 5 [ #1 ] PREEMPT SMP ARM [ 17 . 290169 ] Modules linked in : [ 17 . 290391 ] CPU : 0 PID : 704 Comm : true Not tainted 3 . 18 . 0 - rc2+ #21 [ 17 . 290585 ] task : 9f4dab00 ti : 9e710000 task . ti : 9e710000 [ 17 . 290747 ] PC is at ftrace_syscall_enter+0x480x1f8 [ 17 . 290866 ] LR is at syscall_trace_enter+0x1240x184 Fix this by ignoring out - of - NR_syscalls - bounds syscall numbers . Commit cd0980fc8add "tracing : Check invalid syscall nr while tracing syscalls" added the check for less than zero , but it should have also checked for greater than NR_syscalls . Link : http :
if ( av_pix_fmt_desc_get ( inlink - > format ) - > flags & AV_PIX_FMT_FLAG_PAL ) memcpy ( out - > data [ 1 ] , in - > data [ 1 ] , AVPALETTE_SIZE ) ; <START_VULN> for ( plane = 0 ; plane < 4 && in - > data [ plane ] ; plane ++ ) { <END_VULN> const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink - > w , s - > hsub ) : inlink - > w ; const int height = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink - > h , s - > vsub ) : inlink - > h ; step = s - > max_step [ plane ] ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 58 20140513 16 : 41 : 06 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
snd_timer_interrupt ( substream - > timer , 1 ) ; #endif _end : <START_VULN> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; <END_VULN> kill_fasync ( & runtime - > fasync , SIGIO , POLL_IN ) ; } EXPORT_SYMBOL ( snd_pcm_period_elapsed ) ;
SimpleStringList tableNames ; intuseDB ; <START_VULN> char * dbname ; <END_VULN> char * pgport ; char * pghost ; char * username ;
if ( IS_ERR ( map ) ) return map ; <START_VULN> bpf_map_inc ( map , true ) ; <END_VULN> fdput ( f ) ; return map ;
ASSERT ( ( entry1 - > flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args - > index ) ; name_rmt - > valueblk = cpu_to_be32 ( args - > rmtblkno ) ; <START_VULN> name_rmt - > valuelen = cpu_to_be32 ( args - > valuelen ) ; <END_VULN> xfs_trans_log_buf ( args - > trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , name_rmt , sizeof ( * name_rmt ) ) ) ; }
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "CTR Counter block mode" ) ; <START_VULN> MODULE_ALIAS ( "rfc3686" ) ; <END_VULN>
err = sock_do_ioctl ( net , sock , cmd , ( unsigned long ) & ktv ) ; set_fs ( old_fs ) ; if ( ! err ) <START_VULN> err = compat_put_timeval ( up , & ktv ) ; <END_VULN> return err ; }
} n = EXTRACT_32BITS ( & prep - > pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; <START_VULN> while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) { <END_VULN> const struct id_off * io , * ie ; char c = ' < ' ;
skb - > ip_summed = CHECKSUM_NONE ; <START_VULN> if ( ( skb_headroom ( skb ) < frag_hdr_sz ) && <END_VULN> pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ;
} if ( priv - > cac_id_len ) { serial - > len = MIN ( priv - > cac_id_len , SC_MAX_SERIALNR ) ; <START_VULN> memcpy ( serial - > value , priv - > cac_id , priv - > cac_id_len ) ; <END_VULN> SC_FUNC_RETURN ( card - > ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card - > ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ;
friend class CanvasRenderingContext2DUserData ; protected : nsresult GetImageDataArray ( JSContext * aCx , int32_t aX , int32_t aY , uint32_t aWidth , uint32_t aHeight , JSObject ** aRetval ) ; nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <START_VULN> unsigned char * aData , uint32_t aDataLen , <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , int32_t dirtyWidth , int32_t dirtyHeight ) ; nsresult Initialize ( int32_t width , int32_t height ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : normalized modified discrete cosine transform power of two length transform only [ 64 <= n ] <START_VULN> last mod : $ Id : mdct . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> Original algorithm adapted long ago from _The use of multirate filter banks for coding of high quality digital audio_ , by T . Sporer , K . Brandenburg and B . Edler , collection of the European Signal Processing Conference ( EUSIPCO ) , Amsterdam , June 1992 , Vol . 1 , pp 211 - 214 The below code implements an algorithm that no longer looks much like
} <START_VULN> mpz_powm ( v , v , key - > d , key - > n ) ; <END_VULN> return 0 ; }
struct ext4_xattr_entry * entry ; size_t size ; int error ; <START_VULN> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <END_VULN> ea_idebug ( inode , "name = % d . % s , buffer = % p , buffer_size = % ld" , name_index , name , buffer , ( long ) buffer_size ) ;
#endif #ifndef M_PI # define M_PI ( 3 . 1415926536f ) #endif #if defined ( _WIN32 ) && ! defined ( __SYMBIAN32__ ) # include < malloc . h > <START_VULN> # define rint ( x ) ( floor ( ( x ) +0 . 5f ) ) <END_VULN> # define NO_FLOAT_MATH_LIB # define FAST_HYPOT ( a , b ) sqrt ( ( a ) * ( a ) + ( b ) * ( b ) ) #endif #if defined ( __SYMBIAN32__ ) && defined ( __WINS__ ) void * _alloca ( size_t size ) ; # define alloca _alloca #endif
} <START_VULN> skb - > len = hdrlen + per_fragm ; <END_VULN> return 0 ; }
} if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) { <START_VULN> ret = ext4_convert_unwritten_extents_endio ( handle , inode , <END_VULN> path ) ; if ( ret >= 0 ) { ext4_update_inode_fsync_trans ( handle , inode , 1 ) ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm" ) ; <START_VULN> MODULE_ALIAS ( "sha1" ) ; <END_VULN>
RESERVE_SPACE ( 8 ) ; WRITE32 ( OP_OPEN ) ; WRITE32 ( arg - > seqid - > sequence - > counter ) ; <START_VULN> encode_share_access ( xdr , arg - > open_flags ) ; <END_VULN> RESERVE_SPACE ( 28 ) ; WRITE64 ( arg - > clientid ) ; WRITE32 ( 16 ) ;
bool mSuppressEOF ; bool mReadingFromStage ; nsTArray < nsHtml5TreeOperation > mOpQueue ; nsTArray < nsIContentPtr > mElementsSeenInThisAppendBatch ; nsTArray < nsHtml5PendingNotification > mPendingNotifications ; nsHtml5StreamParser * mStreamParser ; <START_VULN> nsCOMArray < nsIContent > mOwnedElements ; <END_VULN> nsTHashtable < nsCStringHashKey > mPreloadedURLs ; nsCOMPtr < nsIURI > mSpeculationBaseURI ;
protected : nsIntSize mLastSize ; nsIntPoint mLastPoint ; HWND mWnd ; WNDPROC mPrevWndProc ; HBRUSH mBrush ; PRPackedBool mIsTopWidgetWindow ; PRPackedBool mHas3DBorder ; <START_VULN> PRPackedBool mIsDestroying ; <END_VULN> PRPackedBool mIsVisible ; PRPackedBool mIsInMouseCapture ; PRPackedBool mInWheelProcessing ; PRPackedBool mUnicodeWidget ; PRPackedBool mIsPluginWindow ; PRPackedBool mPainting ; char mLeadByte ; PRUint32 mBlurSuppressLevel ;
if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; <START_VULN> if ( ( int ) val < 0 ) <END_VULN> write_pmc ( i + 1 , 0 ) ; } }
int haystack_len , needle_len ; unsigned char * found ; long loffset = 0 ; <START_VULN> int32_t offset = 0 ; <END_VULN> int ret_pos ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "ss | l" , ( char ** ) & haystack , & haystack_len , ( char ** ) & needle , & needle_len , & loffset ) == FAILURE ) {
* <START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 89 ) <END_VULN> extern JSBool js_XDRAtom ( JSXDRState * xdr , JSAtom ** atomp ) ; JS_END_EXTERN_C
av_frame_copy_props ( outpic , inpic ) ; outpic - > interlaced_frame = 0 ; <START_VULN> for ( plane = 0 ; inpic - > data [ plane ] && plane < 4 ; plane ++ ) { <END_VULN> h = plane == 0 ? inlink - > h : FF_CEIL_RSHIFT ( inlink - > h , kerndeint - > vsub ) ; bwidth = kerndeint - > tmp_bwidth [ plane ] ;
static int do_tkill ( pid_t tgid , pid_t pid , int sig ) { <START_VULN> struct siginfo info ; <END_VULN> info . si_signo = sig ; info . si_errno = 0 ;
REG ( "make - it - fail" , S_IRUGO | S_IWUSR , proc_fault_inject_operations ) , #endif #ifdef CONFIG_TASK_IO_ACCOUNTING <START_VULN> INF ( "io" , S_IRUGO , proc_tid_io_accounting ) , <END_VULN> #endif #ifdef CONFIG_HARDWALL INF ( "hardwall" , S_IRUGO , proc_pid_hardwall ) ,
#include < stdlib . h > #include < stdio . h > #include < string . h > #include < ctype . h > <START_VULN> #include "compilerdebug . h"<END_VULN> #include "compilerpreprocessorslglobals . h" #include "compilerutil . h"
TrackTicks inputEndTicks = TimeToTicksRoundUp ( rate , inputEnd ) ; TrackTicks inputStartTicks = inputEndTicks - ticks ; <START_VULN> segment - > AppendSlice ( * inputTrack - > GetSegment ( ) , <END_VULN> NS_MIN ( inputTrackEndPoint , inputStartTicks ) , NS_MIN ( inputTrackEndPoint , inputEndTicks ) ) ; LOG ( PR_LOG_DEBUG , ( "TrackUnionStream % p appending % lld ticks of input data to track % d" , this , ( long long ) ( NS_MIN ( inputTrackEndPoint , inputEndTicks ) - NS_MIN ( inputTrackEndPoint , inputStartTicks ) ) , outputTrack - > GetID ( ) ) ) ; } for ( uint32_t j = 0 ; j < mListeners . Length ( ) ; ++ j ) { MediaStreamListener * l = mListeners [ j ] ;
Vector < CFGState , 8 , IonAllocPolicy > cfgStack_ ; Vector < ControlFlowInfo , 4 , IonAllocPolicy > loops_ ; Vector < ControlFlowInfo , 0 , IonAllocPolicy > switches_ ; Vector < ControlFlowInfo , 2 , IonAllocPolicy > labels_ ; Vector < MInstruction * , 2 , IonAllocPolicy > iterators_ ; TypeOracle * oracle ; <START_VULN> size_t inliningDepth ; <END_VULN> Vector < MDefinition * , 0 , IonAllocPolicy > inlinedArguments_ ; bool failedBoundsCheck_ ;
<START_VULN> if ( SSL_USE_ETM ( s ) && s - > read_hash ) { <END_VULN> unsigned char * mac ; mac_size = EVP_MD_CTX_size ( s - > read_hash ) ; OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ;
struct pppol2tp_session * ps ; if ( level != SOL_PPPOL2TP ) <START_VULN> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <END_VULN> if ( get_user ( len , optlen ) ) return - EFAULT ;
static void CVE_2012_4298_vwr_read_rec_data_ethernet ( wtap * wth , guint8 * data_ptr , guint8 * rec , int rec_size , int IS_TX ) { vwr_t * vwr = ( vwr_t * ) wth - > priv ; int bytes_written = 0 ; register int i ; register guint8 * s_ptr , * m_ptr ; <START_VULN> gint16 msdu_length , actual_octets ; <END_VULN> guint8 flow_seq ; guint64 s_time = LL_ZERO , e_time = LL_ZERO ; guint32 latency = 0 ; guint64 start_time , s_sec , s_usec = LL_ZERO ; guint64 end_time ; guint16 l4id , info , validityBits ; guint32 errors ; guint16 vc_id ; guint32 flow_id , d_time ;
static krb5_error_code <START_VULN> iakerb_alloc_context ( iakerb_ctx_id_t * pctx ) <END_VULN> { iakerb_ctx_id_t ctx ; krb5_error_code code ;
for ( i = 0 ; i < vi - > channels ; i ++ ) { int submap = info - > chmuxlist [ i ] ; float * mdct = gmdct [ i ] ; float * res = vb - > pcm [ i ] ; int * ilogmask = ilogmaskch [ i ] = _vorbis_block_alloc ( vb , n2 * sizeof ( ** gmdct ) ) ; <START_VULN> <END_VULN> nonzero [ i ] = floor1_encode ( opb , vb , b - > flr [ info - > floorsubmap [ submap ] ] , floor_posts [ i ] [ k ] , ilogmask ) ; #if 0 { char buf [ 80 ] ; sprintf ( buf , "maskI % c % d" , i ? 'R' : 'L' , k ) ; float work [ n2 ] ;
0 . 9999667820F , 0 . 9999720773F , 0 . 9999767136F , 0 . 9999807479F , 0 . 9999842344F , 0 . 9999872249F , 0 . 9999897688F , 0 . 9999919127F , 0 . 9999937009F , 0 . 9999951749F , 0 . 9999963738F , 0 . 9999973342F , 0 . 9999980900F , 0 . 9999986724F , 0 . 9999991103F , 0 . 9999994297F , 0 . 9999996543F , 0 . 9999998049F , 0 . 9999999000F , 0 . 9999999552F , 0 . 9999999836F , 0 . 9999999957F , 0 . 9999999994F , 1 . 0000000000F , } ; <START_VULN> static float vwin2048 [ 1024 ] = { <END_VULN> 0 . 0000009241F , 0 . 0000083165F , 0 . 0000231014F , 0 . 0000452785F , 0 . 0000748476F , 0 . 0001118085F , 0 . 0001561608F , 0 . 0002079041F , 0 . 0002670379F , 0 . 0003335617F , 0 . 0004074748F , 0 . 0004887765F , 0 . 0005774661F , 0 . 0006735427F , 0 . 0007770054F , 0 . 0008878533F , 0 . 0010060853F , 0 . 0011317002F , 0 . 0012646969F , 0 . 0014050742F , 0 . 0015528307F , 0 . 0017079650F , 0 . 0018704756F , 0 . 0020403610F , 0 . 0022176196F , 0 . 0024022497F , 0 . 0025942495F , 0 . 0027936173F , 0 . 0030003511F , 0 . 0032144490F , 0 . 0034359088F , 0 . 0036647286F ,
reslevel - > log2_prec_height ) - ( reslevel - > coord [ 1 ] [ 0 ] >> reslevel - > log2_prec_height ) ; <START_VULN> reslevel - > band = av_malloc_array ( reslevel - > nbands , sizeof ( * reslevel - > band ) ) ; <END_VULN> if ( ! reslevel - > band ) return AVERROR ( ENOMEM ) ;
int hns_ppe_get_sset_count ( int stringset ) { <START_VULN> if ( stringset == ETH_SS_STATS ) <END_VULN> return ETH_PPE_STATIC_NUM ; return 0 ; }
sem_lock_and_putref ( sma ) ; if ( sma - > sem_perm . deleted ) { <START_VULN> sem_unlock ( sma ) ; <END_VULN> kfree ( new ) ; un = ERR_PTR ( - EIDRM ) ; goto out ;
typedef ogg_int16_t vorbis_fpu_control ; static inline void vorbis_fpu_setround ( vorbis_fpu_control * fpu ) { ogg_int16_t ret ; ogg_int16_t temp ; __asm__ __volatile__ ( "fnstcw % 0t" "movw % 0 , % % dxt" <START_VULN> "orw $ 62463 , % % dxt"<END_VULN> "movw % % dx , % 1t" "fldcw % 1t" : " = m" ( ret ) : "m" ( temp ) : "dx" ) ; * fpu = ret ; } static inline void vorbis_fpu_restore ( vorbis_fpu_control fpu ) { __asm__ __volatile__ ( "fldcw % 0" : : "m" ( fpu ) ) ; }
. fsync = exofs_file_fsync , . flush = exofs_flush , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> } ; const struct inode_operations exofs_file_inode_operations = {
u16 selector , int seg ) { u8 cpl = ctxt - > ops - > cpl ( ctxt ) ; <START_VULN> return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ; <END_VULN> } static void write_register_operand ( struct operand * op )
tsk - > flags |= PF_EXITPIDONE ; if ( tsk - > io_context ) <START_VULN> exit_io_context ( ) ; <END_VULN> if ( tsk - > splice_pipe ) __free_pipe_info ( tsk - > splice_pipe ) ;
struct videobuf_queue * q = map - > q ; int i ; <START_VULN> dprintk ( 2 , "vm_close % p [ count = % d , vma = % 08lx - % 08lx ] " , map , <END_VULN> map - > count , vma - > vm_start , vma - > vm_end ) ; map - > count -- ;
class nsJPEGDecoder : public Decoder { public : nsJPEGDecoder ( RasterImage & aImage , Decoder : : DecodeStyle aDecodeStyle ) ; virtual ~ nsJPEGDecoder ( ) ; virtual void InitInternal ( ) ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal ( ) ; virtual Telemetry : : ID SpeedHistogram ( ) ; void NotifyDone ( ) ; protected : Orientation ReadOrientationFromEXIF ( ) ; void OutputScanlines ( bool * suspend ) ;
if ( in_atomic ( ) || ! mm ) goto intr_or_no_mm ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> if ( ! down_read_trylock ( & mm - > mmap_sem ) ) { if ( ( regs - > tstate & TSTATE_PRIV ) &&
u32 __user * optval , int __user * optlen ) { int rc = - ENOPROTOOPT ; <START_VULN> if ( ccid - > ccid_ops - > ccid_hc_tx_getsockopt != NULL ) <END_VULN> rc = ccid - > ccid_ops - > ccid_hc_tx_getsockopt ( sk , optname , len , optval , optlen ) ; return rc ;
#include < ft2build . h > #include FT_CONFIG_CONFIG_H #include FT_INTERNAL_OBJECTS_H #include FT_INTERNAL_DEBUG_H #include FT_MODULE_H #include "basepic . h" <START_VULN> <END_VULN> #undef FT_COMPONENT #define FT_COMPONENT trace_init
{ struct NntpServer * nserv = data ; struct NntpData * nntp_data = NULL ; <START_VULN> char group [ LONG_STRING ] ; <END_VULN> char desc [ HUGE_STRING ] = "" ; char mod ; anum_t first , last ;
if ( r == 0 ) { num_records = oggplay_callback_info_prepare ( me , & info ) ; for ( i = 0 ; i < me - > num_tracks ; i ++ ) { me - > decode_data [ i ] - > active = 0 ; <START_VULN> me - > active_tracks = 0 ; <END_VULN> } if ( info != NULL ) { me - > callback ( me , num_records , info , me - > callback_user_ptr ) ; oggplay_callback_info_destroy ( me , info ) ; } decoder - > stream_info = OGGPLAY_STREAM_UNINITIALISED ;
ret = 0 ; exit : <START_VULN> spin_unlock_irqrestore ( & dev - > lock , flags ) ; <END_VULN> return ret <= 0 ? ret : - EIO ; }
for ( ; num ; num -- ) { <START_VULN> if ( pread ( fd , xph_addr , xph_sizeof , off ) == - 1 ) { <END_VULN> file_badread ( ms ) ; return - 1 ; }
address = address & huge_page_mask ( h ) ; pgoff = vma_hugecache_offset ( h , vma , address ) ; <START_VULN> mapping = ( struct address_space * ) page_private ( page ) ; <END_VULN> if ( vm_flags & VM_NORESERVE ) return 0 ;
for ( i = 0 ; i < size ; i ++ ) { ch = buffer [ i ] ; <START_VULN> Huff_transmit ( & huff , ch , seq ) ; <END_VULN> Huff_addRef ( & huff , ( byte ) ch ) ; }
. vcpu_load = svm_vcpu_load , . vcpu_put = svm_vcpu_put , <START_VULN> . update_db_bp_intercept = update_db_bp_intercept , <END_VULN> . get_msr = svm_get_msr , . set_msr = svm_set_msr , . get_segment_base = svm_get_segment_base ,
char errbuff [ 128 ] ; cli_strerror ( errno , errbuff , sizeof ( errbuff ) ) ; cli_dbgmsg ( "cli_scanxar : Can't read % li bytes @ % li , errno : % s . " , <START_VULN> length , at , errbuff ) ; <END_VULN> rc = CL_EREAD ; __lzma_wrap_free ( NULL , buff ) ; cli_LzmaShutdown ( & lz ) ;
if ( PASS == conn - > m - > local_tx_start ( conn , this_func TSRMLS_CC ) ) { ret = conn - > m - > query ( conn , "COMMIT" , sizeof ( "COMMIT" ) - 1 TSRMLS_CC ) ; <START_VULN> conn - > m - > local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_RETURN ( ret ) ;
uint32_t lineIndexToNum ( uint32_t lineIndex ) const { return lineIndex + initialLineNum_ ; } uint32_t lineNumToIndex ( uint32_t lineNum ) const { return lineNum - initialLineNum_ ; } public : SourceCoords ( JSContext * cx , uint32_t ln ) ; void add ( uint32_t lineNum , uint32_t lineStartOffset ) ; <START_VULN> void fill ( const SourceCoords & other ) ; <END_VULN> bool isOnThisLine ( uint32_t offset , uint32_t lineNum ) const { uint32_t lineIndex = lineNumToIndex ( lineNum ) ; JS_ASSERT ( lineIndex + 1 < lineStartOffsets_ . length ( ) ) ; return lineStartOffsets_ [ lineIndex ] <= offset && offset < lineStartOffsets_ [ lineIndex + 1 ] ; }
<START_VULN> <END_VULN> #define MY_HOLD_ORIGINAL_MODES 128 #define MY_REDEL_MAKE_BACKUP 256 #define MY_SEEK_NOT_DONE 32 #define MY_DONT_WAIT64 #define MY_ZEROFILL32
t = plaintext - > len ; t -= paddingLength+overhead ; <START_VULN> <END_VULN> good = DUPLICATE_MSB_TO_ALL ( ~ t ) ; t = blockSize - ( paddingLength+1 ) ;
err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , <START_VULN> transhdrlen , mtu , flags ) ; <END_VULN> if ( err ) goto error ; return 0 ;
phar_flush ( entry_obj - > ent . entry - > phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } RETURN_TRUE ;
MODULE_DESCRIPTION ( "Rijndael ( AES ) Cipher Algorithm , Intel AES - NI instructions optimized" ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "aes" ) ; <END_VULN>
} static void <START_VULN> build_config ( char * prefix , struct server * server ) <END_VULN> { char * path = NULL ; int path_size = strlen ( prefix ) + strlen ( server - > port ) + 20 ;
if ( ( edges & 8 ) && s - > mb_y == ( ( s - > mb_height >> v - > field_mode ) - 1 ) ) mquant = - v - > altpq ; <START_VULN> if ( ! mquant || mquant > 31 ) { <END_VULN> av_log ( v - > s . avctx , AV_LOG_ERROR , "Overriding invalid mquant % d" , mquant ) ; mquant = 1 ;
sleep_again : current - > state = TASK_INTERRUPTIBLE ; <START_VULN> sem_unlock ( sma ) ; <END_VULN> if ( timeout ) jiffies_left = schedule_timeout ( jiffies_left ) ;
nsIPrincipal * originPrincipal , nsISupports * context , const nsACString & mimeType , nsISupports * extra , int16_t * decision , nsIContentPolicy * policyService = nullptr , nsIScriptSecurityManager * aSecMan = nullptr ) { <START_VULN> CHECK_PRINCIPAL ; <END_VULN> if ( policyService ) { CHECK_CONTENT_POLICY_WITH_SERVICE ( ShouldLoad , policyService ) ; } CHECK_CONTENT_POLICY ( ShouldLoad ) ; }
goto bail ; } <START_VULN> len = mutt_b64_decode ( obuf , idata - > buf + 2 ) ; <END_VULN> if ( len == - 1 ) { mutt_debug ( 1 , "Error decoding base64 response . " ) ;
s - > buf_ptr = s - > buffer ; s - > buf_end = s - > buffer ; s - > line_count = 0 ; <START_VULN> s - > filesize = - 1 ; <END_VULN> cur_auth_type = s - > proxy_auth_state . auth_type ;
kenter ( " % p { % u } " , user , uid ) ; <START_VULN> if ( user - > uid_keyring ) { <END_VULN> kleave ( " = 0 [ exist ] " ) ; return 0 ; }
} extra - > match_limit = PCRE_G ( backtrack_limit ) ; extra - > match_limit_recursion = PCRE_G ( recursion_limit ) ; <START_VULN> <END_VULN> array_init ( return_value ) ;
} static int opl3_load_patch ( int dev , int format , const char __user * addr , <START_VULN> int offs , int count , int pmgr_flag ) <END_VULN> { struct sbi_instrument ins ;
phar_flush ( phar_obj - > arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } }
OM_uint32 ret ; spnego_gss_ctx_id_t sc = NULL ; <START_VULN> sc = create_spnego_ctx ( ) ; <END_VULN> if ( sc == NULL ) return GSS_S_FAILURE ;
goto out ; } <START_VULN> rc = ecryptfs_parse_options ( sbi , raw_data ) ; <END_VULN> if ( rc ) { err = "Error parsing options" ; goto out ;
* elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr - > ident . ident ) ; * index_rtrn = NULL ; <START_VULN> return true ; <END_VULN> case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr - > field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr - > field_ref . field ) ;
if ( ! md - > chain [ ISAKMP_NEXT_v2E ] ) { libreswan_log ( "R2 state should receive an encrypted payload" ) ; <START_VULN> reset_globals ( ) ; <END_VULN> return STF_FATAL ; }
} } else { if ( state - > object_nl ) ruby_xfree ( state - > object_nl ) ; <START_VULN> state - > object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ; <END_VULN> state - > object_nl_len = len ; } return Qnil ;
return - EFAULT ; len = namelen ; <START_VULN> if ( namelen > 32 ) <END_VULN> len = 32 ; down_read ( & uts_sem ) ;
rkeylen = strlen ( rkey ) ; <START_VULN> if ( nad_find_attr ( nad , 0 , - 1 , "type" , "valid" ) >= 0 ) { <END_VULN> log_write ( out - > s2s - > log , LOG_NOTICE , " [ % d ] [ % s , port = % d ] outgoing route ' % s' is now valid % s % s" , out - > fd - > fd , out - > ip , out - > port , rkey , ( out - > s - > flags & SX_SSL_WRAPPER ) ? " , TLS negotiated" : "" , out - > s - > compressed ? " , ZLIB compression enabled" : "" ) ; xhash_put ( out - > states , pstrdup ( xhash_pool ( out - > states ) , rkey ) , ( void * ) conn_VALID ) ;
unsigned int address , destreg , data , type ; unsigned int res = 0 ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs - > ARM_pc ) ; <END_VULN> if ( current - > pid != previous_pid ) { pr_debug ( "" % s" ( % ld ) uses deprecated SWP { B } instruction" ,
void midi_synth_close ( int dev ) ; void midi_synth_hw_control ( int dev , unsigned char * event ) ; int midi_synth_load_patch ( int dev , int format , const char __user * addr , <START_VULN> int offs , int count , int pmgr_flag ) ; <END_VULN> void midi_synth_panning ( int dev , int channel , int pressure ) ; void midi_synth_aftertouch ( int dev , int channel , int pressure ) ; void midi_synth_controller ( int dev , int channel , int ctrl_num , int value ) ;
efree ( ustr ) ; } ubrk_close ( bi ) ; <START_VULN> RETURN_EMPTY_STRING ( ) ; <END_VULN> }
char line [ MAX_URL_SIZE ] ; int err = 0 ; <START_VULN> s - > chunksize = - 1 ; <END_VULN> for ( ; ; ) { if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 )
if ( FAILURE == phar_copy_entry_fp ( oldentry , & newentry , & error TSRMLS_CC ) ) { efree ( newentry . filename ) ; php_stream_close ( newentry . fp ) ; <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; return ; }
struct boot_sector b ; unsigned total_sectors ; unsigned short logical_sector_size , sectors ; <START_VULN> unsigned fat_length ; <END_VULN> unsigned total_fat_entries ; off_t data_size ;
if ( ! err ) { map_bh ( bh , inode - > i_sb , map . m_pblk ) ; bh - > b_state = ( bh - > b_state & ~ F2FS_MAP_FLAGS ) | map . m_flags ; <START_VULN> bh - > b_size = map . m_len << inode - > i_blkbits ; <END_VULN> } return err ; }
} static spnego_gss_ctx_id_t <START_VULN> create_spnego_ctx ( void ) <END_VULN> { spnego_gss_ctx_id_t spnego_ctx = NULL ; spnego_ctx = ( spnego_gss_ctx_id_t )
struct SParser * p = cast ( struct SParser * , ud ) ; int c = luaZ_lookahead ( p - > z ) ; luaC_checkGC ( L ) ; <START_VULN> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p - > z , <END_VULN> & p - > buff , p - > name ) ; cl = luaF_newLclosure ( L , tf - > nups , hvalue ( gt ( L ) ) ) ; cl - > l . p = tf ;
#ifdef MOZ_MAINTENANCE_SERVICE useService = IsUpdateStatusPendingService ( ) ; testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ) ; #endif { <START_VULN> HKEY hkApp ; <END_VULN> RegCreateKeyExW ( HKEY_CURRENT_USER , L"SoftwareClassesApplications" , 0 , nullptr , REG_OPTION_NON_VOLATILE , KEY_SET_VALUE , nullptr , & hkApp , nullptr ) ; RegCloseKey ( hkApp ) ; if ( RegCreateKeyExW ( HKEY_CURRENT_USER , L"SoftwareClassesApplicationsupdater . exe" , 0 , nullptr , REG_OPTION_VOLATILE , KEY_SET_VALUE , nullptr , & hkApp , nullptr ) == ERROR_SUCCESS ) { RegSetValueExW ( hkApp , L"IsHostApp" , 0 , REG_NONE , 0 , 0 ) ; RegSetValueExW ( hkApp , L"NoOpenWith" , 0 , REG_NONE , 0 , 0 ) ;
ipv6 : iph = __skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , data , hlen , & _iph ) ; if ( ! iph ) <START_VULN> return false ; <END_VULN> ip_proto = iph - > nexthdr ; nhoff + = sizeof ( struct ipv6hdr ) ;
int CVE_2012_6618_av_probe_input_buffer ( AVIOContext * pb , AVInputFormat ** fmt , const char * filename , void * logctx , unsigned int offset , unsigned int max_probe_size ) { AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; unsigned char * buf = NULL ; <START_VULN> int ret = 0 , probe_size ; <END_VULN> if ( ! max_probe_size ) { max_probe_size = PROBE_BUF_MAX ; } else if ( max_probe_size > PROBE_BUF_MAX ) { max_probe_size = PROBE_BUF_MAX ; } else if ( max_probe_size < PROBE_BUF_MIN ) { return AVERROR ( EINVAL ) ; } if ( offset >= max_probe_size ) {
static void tokenadd ( struct jv_parser * p , char c ) { assert ( p - > tokenpos <= p - > tokenlen ) ; <START_VULN> if ( p - > tokenpos == p - > tokenlen ) { <END_VULN> p - > tokenlen = p - > tokenlen * 2 + 256 ; p - > tokenbuf = jv_mem_realloc ( p - > tokenbuf , p - > tokenlen ) ; }
c - > padded_bits = aligned_width - c - > avctx - > width ; if ( c - > video_size < aligned_width * avctx - > height * ( int64_t ) c - > bpp 8 ) return AVERROR_INVALIDDATA ; <START_VULN> if ( ! encoding && c - > palette_size && c - > bpp <= 8 ) { <END_VULN> avctx - > pix_fmt = AV_PIX_FMT_PAL8 ; } else if ( encoding == 1 && ( c - > bpp == 6 || c - > bpp == 8 ) ) { if ( c - > palette_size != ( 1 << ( c - > bpp - 1 ) ) )
idx = ( ( r - > CRm & 3 ) << 3 ) | ( r - > Op2 & 7 ) ; } else { <START_VULN> BUG ( ) ; <END_VULN> } if ( ! pmu_counter_idx_valid ( vcpu , idx ) )
acked : 1 , no_srccheck : 1 ; kmemcheck_bitfield_end ( flags ) ; <START_VULN> struct ip_options * opt ; <END_VULN> } ; static inline struct inet_request_sock * inet_rsk ( const struct request_sock * sk )
typedef struct { void ( * pack ) ( vorbis_info_floor * , oggpack_buffer * ) ; vorbis_info_floor * ( * unpack ) ( vorbis_info * , oggpack_buffer * ) ; vorbis_look_floor * ( * look ) ( vorbis_dsp_state * , vorbis_info_floor * ) ; void ( * free_info ) ( vorbis_info_floor * ) ; void ( * free_look ) ( vorbis_look_floor * ) ; void * ( * inverse1 ) ( struct vorbis_block * , vorbis_look_floor * ) ; int ( * inverse2 ) ( struct vorbis_block * , vorbis_look_floor * , <START_VULN> void * buffer , float * ) ; <END_VULN> } vorbis_func_floor ; typedef struct { int order ; long rate ; long barkmap ; int ampbits ;
STACK_OF ( X509_CRL ) * crls = NULL ; X509 * signer ; int i , scount = 0 , ret = 0 ; <START_VULN> BIO * cmsbio = NULL , * tmpin = NULL ; <END_VULN> if ( ! dcont && ! check_content ( cms ) ) return 0 ;
return ERR_PTR ( - ENOBUFS ) ; memset ( opt2 , 0 , tot_len ) ; <START_VULN> <END_VULN> opt2 - > tot_len = tot_len ; p = ( char * ) ( opt2 + 1 ) ;
pch - > ppp = NULL ; pch - > chan = chan ; <START_VULN> pch - > chan_net = net ; <END_VULN> chan - > ppp = pch ; init_ppp_file ( & pch - > file , CHANNEL ) ; pch - > file . hdrlen = chan - > hdrlen ;
if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; <START_VULN> hugetlb_put_quota ( vma - > vm_file - > f_mapping , reserve ) ; <END_VULN> } } }
if ( IsUnpromptedElevation ( unpromptedElevation ) ) { useService = ! unpromptedElevation ; } } if ( useService ) { WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) ) { <START_VULN> HKEY baseKey ; <END_VULN> if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS ) { RegCloseKey ( baseKey ) ; } else { useService = testOnlyFallbackKeyExists ; if ( ! useService ) { lastFallbackError = FALLBACKKEY_NOKEY_ERROR ; }
struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; <START_VULN> int count , i ; <END_VULN> count = be32_to_cpu ( aclp - > acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES )
return SC_ERROR_INVALID_ARGUMENTS ; } <START_VULN> if ( sec_attr == NULL ) { <END_VULN> if ( file - > sec_attr != NULL ) free ( file - > sec_attr ) ; file - > sec_attr = NULL ;
if ( type == SSL3_RT_APPLICATION_DATA && u_len >= 4 * ( max_send_fragment = s - > max_send_fragment ) && s - > compress == NULL && s - > msg_callback == NULL && <START_VULN> ! SSL_USE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) && <END_VULN> EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s - > enc_write_ctx ) ) & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) { unsigned char aad [ 13 ] ;
EXPORT_SYMBOL ( sysctl_tcp_adv_win_scale ) ; <START_VULN> int sysctl_tcp_challenge_ack_limit = 100 ; <END_VULN> int sysctl_tcp_stdurg __read_mostly ; int sysctl_tcp_rfc1337 __read_mostly ;
static void gdCtxPrintf ( gdIOCtx * out , const char * format , . . . ) { <START_VULN> char buf [ 4096 ] ; <END_VULN> int len ; va_list args ;
<START_VULN> touch_file ( t - > stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <END_VULN> } t - > result = TIMER_SUCCESS ;
nsCycleCollectionParticipant * helper ) = 0 ; NS_IMETHOD_ ( void ) NoteNextEdgeName ( const char * name ) = 0 ; <START_VULN> NS_IMETHOD_ ( void ) NoteWeakMapping ( void * map , void * key , void * val ) = 0 ; <END_VULN> enum { WANT_DEBUG_INFO = ( 1 << 0 ) ,
static int CVE_2014_8546_cinepak_decode_vectors ( CinepakContext * s , cvid_strip * strip , int chunk_id , int size , const uint8_t * data ) { const uint8_t * eod = ( data + size ) ; uint32_t flag , mask ; uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; <START_VULN> unsigned int x , y ; <END_VULN> char * ip0 , * ip1 , * ip2 , * ip3 ; flag = 0 ; mask = 0 ; for ( y = strip - > y1 ; y < strip - > y2 ; y+ = 4 ) { ip0 = ip1 = ip2 = ip3 = s - > frame - > data [ 0 ] + ( s - > palette_video ? strip - > x1 : strip - > x1 * 3 ) + ( y * s - > frame - > linesize [ 0 ] ) ;
struct nfs_fh * fh ; nfs4_stateid * stateid ; struct nfs_seqid * seqid ; <START_VULN> intopen_flags ; <END_VULN> const u32 * bitmask ; } ;
nsIFile ** aDirectory ) const ; nsresult EnsureOriginIsInitialized ( const nsACString & aOrigin , bool aTrackQuota , nsIFile ** aDirectory ) ; void <START_VULN> UninitializeOriginsByPattern ( const nsACString & aPattern ) ; <END_VULN> nsIThread * IOThread ( ) { NS_ASSERTION ( mIOThread , "This should never be null ! " ) ; return mIOThread ; }
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 61 20140604 17 : 23 : 19 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
js : : InitialShapeSet initialShapes ; void sweepInitialShapeTable ( ) ; js : : types : : TypeObjectSet newTypeObjects ; js : : types : : TypeObjectSet lazyTypeObjects ; void sweepNewTypeObjectTable ( js : : types : : TypeObjectSet & table ) ; <START_VULN> js : : types : : TypeObject * emptyTypeObject ; <END_VULN> inline js : : types : : TypeObject * getEmptyType ( JSContext * cx ) ; js : : types : : TypeObject * getLazyType ( JSContext * cx , JSObject * proto ) ;
<START_VULN> <END_VULN> xasprintf ( & userstyle , " % s % s % s" , authctxt - > user , authctxt - > style ? " : " : "" ,
"picture will move % s one line" , s - > dst_tff ? "up" : "down" ) ; h = frame - > height ; <START_VULN> for ( plane = 0 ; plane < 4 && frame - > data [ plane ] ; plane ++ ) { <END_VULN> line_step = frame - > linesize [ plane ] ; line_size = s - > line_size [ plane ] ; data = frame - > data [ plane ] ;
<START_VULN> Packet * p = BuildTestPacket ( 99 , 0 , 1 , 'A' + i , 16 ) ; <END_VULN> if ( p == NULL ) goto end ;
decoder_info - > bit_count . super_mode [ decoder_info - > bit_count . stat_frame_type ] + = ( stream - > bitcnt - bit_start ) ; <START_VULN> if ( split_flag ) { <END_VULN> int new_size = size2 ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY+0 * new_size , xposY+0 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY+1 * new_size , xposY+0 * new_size , sub ) ;
#include < windows . h > #include "nscore . h" #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN #include < dwmapi . h > #endif <START_VULN> #if defined ( WINCE ) || ( MOZ_WINSDK_TARGETVER == MOZ_NTDDI_WS03 ) <END_VULN> struct MARGINS { int cxLeftWidth ; int cxRightWidth ; int cyTopHeight ; int cyBottomHeight ; } ; #endif
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : PCM data envelope analysis and manipulation <START_VULN> last mod : $ Id : envelope . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_ENVELOPE_ #define _V_ENVELOPE_ #include "mdct . h"
MODULE_AUTHOR ( "Tim Chen < tim . c . chen@linux . intel . com > " ) ; MODULE_DESCRIPTION ( "T10 DIF CRC calculation . " ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "crct10dif" ) ; <END_VULN>
<START_VULN> struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode ) <END_VULN> { struct nfs_inode * nfsi = NFS_I ( inode ) ; struct nfs_open_context * pos , * ctx = NULL ;
path_end = memchr ( path_ptr , '0' , buffer_size ) ; if ( path_end == NULL ) <START_VULN> return 0 ; <END_VULN> path_length = path_end - path_ptr ; }
{ if ( obuf [ i ] != rbuf [ i ] ) { <START_VULN> XPR ( NT "byte % u ( read % u @ % "Q"u ) % d != % d" , <END_VULN> ( int ) i , ( int ) oc , offset , obuf [ i ] , rbuf [ i ] ) ; diffs ++ ; return XD3_INTERNAL ;
size_t len ; if ( level >= ms - > c . len ) { <START_VULN> len = ( ms - > c . len + = 20 ) * sizeof ( * ms - > c . li ) ; <END_VULN> ms - > c . li = CAST ( struct level_info * , ( ms - > c . li == NULL ) ? malloc ( len ) : realloc ( ms - > c . li , len ) ) ;
* int mar_read_product_info_block ( MarFile * mar , struct ProductInformationBlock * infoBlock ) { <START_VULN> int i , hasAdditionalBlocks , offset , <END_VULN> offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; char buf [ 97 ] = { '0' } ; int ret = get_mar_file_info_fp ( mar - > fp , NULL , NULL , & hasAdditionalBlocks , & offsetAdditionalBlocks ,
} } PRInt32 FindMaxUshortElement ( ) { if ( mHasCachedMaxUshortElement ) { return mCachedMaxUshortElement ; } else { mHasCachedMaxUshortElement = true ; <START_VULN> mCachedMaxUshortElement = FindMaxElementInSubArray < GLshort > ( mByteLength >> 1 , 0 ) ; <END_VULN> return mCachedMaxUshortElement ; } } NS_DECL_ISUPPORTS NS_DECL_NSIWEBGLBUFFER protected :
void ipc_rcu_putref ( void * ptr ) { <START_VULN> if ( -- container_of ( ptr , struct ipc_rcu_hdr , data ) - > refcount > 0 ) <END_VULN> return ; if ( container_of ( ptr , struct ipc_rcu_hdr , data ) - > is_vmalloc ) {
} } <START_VULN> if ( context && <END_VULN> php_stream_context_get_option ( context , "http" , "user_agent" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) { ua_str = Z_STRVAL_PP ( ua_zval ) ;
strcmp ( f - > file , "cgroup . procs" ) == 0 || strcmp ( f - > file , "cgroup . procs" ) == 0 ) <START_VULN> r = do_write_pids ( fc - > pid , f - > controller , f - > cgroup , f - > file , localbuf ) ; <END_VULN> else r = cgfs_set_value ( f - > controller , f - > cgroup , f - > file , localbuf ) ;
{ gchar * absolute_filename ; <START_VULN> if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) { <END_VULN> absolute_filename = g_strdup ( filename ) ; } else { gchar * tmpcdir ;
{ . node = { . next = NULL , <START_VULN> . pprev = & init_struct_pid . tasks [ type ] . first , <END_VULN> } , . pid = & init_struct_pid , }
pkiDebug ( "pkinit_verify_padata : entered ! " ) ; if ( data == NULL || data - > length <= 0 || data - > contents == NULL ) { <START_VULN> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <END_VULN> return ; }
. mmap = generic_file_mmap , . fsync = noop_fsync , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . llseek = generic_file_llseek , } ;
hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; if ( ! hdr ) <START_VULN> return false ; <END_VULN> if ( ( ntohl ( hdr [ 0 ] . entry ) & MPLS_LS_LABEL_MASK ) >> MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY ) {
} else { ti - > flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; if ( -- timer - > running ) <START_VULN> list_del ( & ti - > active_list ) ; <END_VULN> } if ( ( timer - > hw . flags & SNDRV_TIMER_HW_TASKLET ) || ( ti - > flags & SNDRV_TIMER_IFLG_FAST ) )
inline void JSObject : : initCall ( JSContext * cx , const js : : Bindings & bindings , JSObject * parent ) { init ( cx , & js : : CallClass , & js : : types : : emptyTypeObject , parent , NULL , false ) ; <START_VULN> lastProp = bindings . lastShape ( ) ; <END_VULN> if ( bindings . extensibleParents ( ) ) setOwnShape ( js_GenerateShape ( cx ) ) ; else
rc = decode_operand ( ctxt , & ctxt - > dst , ( ctxt - > d >> DstShift ) & OpMask ) ; <START_VULN> done : <END_VULN> if ( ctxt - > rip_relative ) ctxt - > memopp - > addr . mem . ea + = ctxt - > _eip ; return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ; }
Address addressForDataRemat ( const FrameEntry * fe ) const ; <START_VULN> Address addressForInlineReturn ( ) const ; <END_VULN> inline StateRemat dataRematInfo ( const FrameEntry * fe ) const ;
if ( tstate & TSTATE_PRIV ) die_if_kernel ( "unfinishedunimplemented FPop from kernel" , regs ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <END_VULN> if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ; if ( get_user ( insn , ( u32 __user * ) pc ) != - EFAULT ) {
return CONNECTION_PREFACE . len ; } <START_VULN> static void parse_input ( h2o_http2_conn_t * conn ) <END_VULN> { size_t http2_max_concurrent_requests_per_connection = conn - > super . ctx - > globalconf - > http2 . max_concurrent_requests_per_connection ; int perform_early_exit = 0 ;
status = PTR_ERR ( cred ) ; goto out ; } <START_VULN> state = nfs4_do_open ( dir , & path , flags , sattr , cred ) ; <END_VULN> d_drop ( dentry ) ; if ( IS_ERR ( state ) ) { status = PTR_ERR ( state ) ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm" ) ; <START_VULN> MODULE_ALIAS ( "sha1 - powerpc" ) ; <END_VULN>
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 137 20170813 00 : 21 : 47 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
0 . 9994740570F , 0 . 9995575079F , 0 . 9996306699F , 0 . 9996944099F , 0 . 9997495605F , 0 . 9997969190F , 0 . 9998372465F , 0 . 9998712678F , 0 . 9998996704F , 0 . 9999231041F , 0 . 9999421807F , 0 . 9999574732F , 0 . 9999695157F , 0 . 9999788026F , 0 . 9999857885F , 0 . 9999908879F , 0 . 9999944746F , 0 . 9999968817F , 0 . 9999984010F , 0 . 9999992833F , 0 . 9999997377F , 0 . 9999999317F , 0 . 9999999911F , 0 . 9999999999F , } ; <START_VULN> static float vwin1024 [ 512 ] = { <END_VULN> 0 . 0000036962F , 0 . 0000332659F , 0 . 0000924041F , 0 . 0001811086F , 0 . 0002993761F , 0 . 0004472021F , 0 . 0006245811F , 0 . 0008315063F , 0 . 0010679699F , 0 . 0013339631F , 0 . 0016294757F , 0 . 0019544965F , 0 . 0023090133F , 0 . 0026930125F , 0 . 0031064797F , 0 . 0035493989F , 0 . 0040217533F , 0 . 0045235250F , 0 . 0050546946F , 0 . 0056152418F , 0 . 0062051451F , 0 . 0068243817F , 0 . 0074729278F , 0 . 0081507582F , 0 . 0088578466F , 0 . 0095941655F , 0 . 0103596863F , 0 . 0111543789F , 0 . 0119782122F , 0 . 0128311538F , 0 . 0137131701F , 0 . 0146242260F ,
virtual bool IsTransportSeekable ( ) = 0 ; <START_VULN> static MediaResource * Create ( MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <END_VULN> virtual nsresult Open ( nsIStreamListener ** aStreamListener ) = 0 ;
phar_flush ( entry_obj - > ent . entry - > phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
a - > y2a = y2a * weight+y2b ; a - > xya = xya * weight+xyb ; a - > an = na * weight+nb ; } return ( na ) ; } <START_VULN> static void fit_line ( lsfit_acc * a , int fits , int * y0 , int * y1 ) { <END_VULN> long x = 0 , y = 0 , x2 = 0 , y2 = 0 , xy = 0 , an = 0 , i ; long x0 = a [ 0 ] . x0 ; long x1 = a [ fits - 1 ] . x1 ; for ( i = 0 ; i < fits ; i ++ ) { x+ = a [ i ] . xa ; y+ = a [ i ] . ya ; x2+ = a [ i ] . x2a ;
MarFile * CVE_2013_1726_mar_wopen ( const wchar_t * path ) { FILE * fp ; <START_VULN> fp = _wfopen ( path , L"rb" ) ; <END_VULN> if ( ! fp ) return NULL ; return mar_fpopen ( fp ) ; }
xid = GetXid ( ) ; <START_VULN> ses = cifs_find_smb_ses ( server , volume_info - > username ) ; <END_VULN> if ( ses ) { cFYI ( 1 , "Existing smb sess found ( status = % d ) " , ses - > status ) ;
NS_DECL_ISUPPORTS NS_DECL_NSIWEBGLPROGRAM protected : WebGLuint mName ; PRPackedBool mDeleted ; PRPackedBool mDeletePending ; PRPackedBool mLinkStatus ; <START_VULN> nsTArray < WebGLShader * > mAttachedShaders ; <END_VULN> CheckedUint32 mGeneration ; nsRefPtrHashtable < nsUint32HashKey , WebGLUniformLocation > mMapUniformLocations ; GLint mUniformMaxNameLength ; GLint mAttribMaxNameLength ; GLint mUniformCount ; GLint mAttribCount ;
void __user * buffer , size_t * lenp , loff_t * ppos ) { <START_VULN> int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ; <END_VULN> if ( ret || ! write ) return ret ;
WARN_ON ( sk - > sk_wmem_queued ) ; WARN_ON ( sk - > sk_forward_alloc ) ; <START_VULN> kfree ( inet - > opt ) ; <END_VULN> dst_release ( rcu_dereference_check ( sk - > sk_dst_cache , 1 ) ) ; sk_refcnt_debug_dec ( sk ) ; }
size2 = avio_rb32 ( pb ) ; ret = ff_rm_read_mdpr_codecdata ( s , s - > pb , st2 , st2 - > priv_data , <START_VULN> size2 , mime ) ; <END_VULN> if ( ret < 0 ) return ret ; }
remote_path_check : <START_VULN> if ( ! rc && cifs_sb - > prepathlen && tcon ) { <END_VULN> full_path = cifs_build_path_to_root ( cifs_sb , tcon ) ; if ( full_path == NULL ) {
} case PHP_MODE_REFLECTION_EXT_INFO : { <START_VULN> int len = ( int ) strlen ( reflection_what ) ; <END_VULN> char * lcname = zend_str_tolower_dup ( reflection_what , len ) ; zend_module_entry * module ;
int2store ( buffer , ( unsigned int ) option ) ; ret = conn - > m - > simple_command ( conn , COM_SET_OPTION , buffer , sizeof ( buffer ) , PROT_EOF_PACKET , FALSE , TRUE TSRMLS_CC ) ; <START_VULN> <END_VULN> conn - > m - > local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; } DBG_RETURN ( ret ) ;
rc = decode_operand ( ctxt , & ctxt - > dst , ( ctxt - > d >> DstShift ) & OpMask ) ; <START_VULN> if ( ctxt - > rip_relative ) <END_VULN> ctxt - > memopp - > addr . mem . ea = address_mask ( ctxt , ctxt - > memopp - > addr . mem . ea + ctxt - > _eip ) ;
<START_VULN> length = ( MagickSizeType ) ReadBlobByte ( image ) ; <END_VULN> combined_length+ = length+1 ; if ( length > 0 ) ( void ) ReadBlob ( image , ( size_t ) length ++ , layer_info [ i ] . name ) ;
int buf_size = avpkt - > size ; MP3On4DecodeContext * s = avctx - > priv_data ; MPADecodeContext * m ; int fsize , len = buf_size , out_size = 0 ; uint32_t header ; OUT_INT * out_samples ; OUT_INT * outptr , * bp ; int fr , j , n , ch , ret ; <START_VULN> s - > frame - > nb_samples = MPA_FRAME_SIZE ; <END_VULN> if ( ( ret = avctx - > get_buffer ( avctx , s - > frame ) ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "get_buffer ( ) failed" ) ; return ret ; } out_samples = ( OUT_INT * ) s - > frame - > data [ 0 ] ; if ( buf_size < HEADER_SIZE ) return AVERROR_INVALIDDATA ;
new_timer - > it_id = ( timer_t ) new_timer_id ; new_timer - > it_clock = which_clock ; new_timer - > kclock = kc ; <START_VULN> new_timer - > it_overrun = - 1 ; <END_VULN> if ( event ) { rcu_read_lock ( ) ;
} long vorbis_coslook_i ( long a ) { int i = a >> COS_LOOKUP_I_SHIFT ; int d = a & COS_LOOKUP_I_MASK ; return COS_LOOKUP_I [ i ] - ( ( d * ( COS_LOOKUP_I [ i ] - COS_LOOKUP_I [ i+1 ] ) ) >> <START_VULN> COS_LOOKUP_I_SHIFT ) ; <END_VULN> } #endif
#ifndef _LINUX_JIFFIES_H #define _LINUX_JIFFIES_H <START_VULN> #include < linuxcalc64 . h > <END_VULN> #include < linuxkernel . h > #include < linuxtypes . h > #include < linuxtime . h >
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : floor backend 0 implementation <START_VULN> last mod : $ Id : floor0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
} } else { if ( state - > space_before ) ruby_xfree ( state - > space_before ) ; <START_VULN> state - > space_before = strdup ( RSTRING_PTR ( space_before ) ) ; <END_VULN> state - > space_before_len = len ; } return Qnil ;
} if ( sax != NULL ) { <START_VULN> memset ( sax , 0 , sizeof ( sax ) ) ; <END_VULN> sax - > sax25_family = AF_NETROM ; skb_copy_from_linear_data_offset ( skb , 7 , sax - > sax25_call . ax25_call , AX25_ADDR_LEN ) ;
avctx - > pix_fmt = AV_PIX_FMT_GRAY16BE ; } else if ( s - > bit_depth == 16 && s - > color_type == PNG_COLOR_TYPE_RGB ) { avctx - > pix_fmt = AV_PIX_FMT_RGB48BE ; } else if ( s - > bit_depth == 16 && s - > color_type == PNG_COLOR_TYPE_RGB_ALPHA ) { avctx - > pix_fmt = AV_PIX_FMT_RGBA64BE ; } else if ( ( s - > bits_per_pixel == 1 || s - > bits_per_pixel == 2 || s - > bits_per_pixel == 4 || s - > bits_per_pixel == 8 ) && s - > color_type == PNG_COLOR_TYPE_PALETTE ) { avctx - > pix_fmt = AV_PIX_FMT_PAL8 ; <START_VULN> } else if ( s - > bit_depth == 1 ) { <END_VULN> avctx - > pix_fmt = AV_PIX_FMT_MONOBLACK ; } else if ( s - > bit_depth == 8 && s - > color_type == PNG_COLOR_TYPE_GRAY_ALPHA ) { avctx - > pix_fmt = AV_PIX_FMT_YA8 ; } else if ( s - > bit_depth == 16 && s - > color_type == PNG_COLOR_TYPE_GRAY_ALPHA ) { avctx - > pix_fmt = AV_PIX_FMT_YA16BE ; } else { av_log ( avctx , AV_LOG_ERROR , "unsupported bit depth % d " "and color type % d" ,
static __u8 * CVE_2012_3364_nci_extract_rf_params_nfca_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfca_poll * nfca_poll , __u8 * data ) { nfca_poll - > sens_res = __le16_to_cpu ( * ( ( __u16 * ) data ) ) ; data + = 2 ; <START_VULN> nfca_poll - > nfcid1_len = * data ++ ; <END_VULN> pr_debug ( "sens_res 0x % x , nfcid1_len % d" , nfca_poll - > sens_res , nfca_poll - > nfcid1_len ) ; memcpy ( nfca_poll - > nfcid1 , data , nfca_poll - > nfcid1_len ) ; data + = nfca_poll - > nfcid1_len ; nfca_poll - > sel_res_len = * data ++ ; if ( nfca_poll - > sel_res_len != 0 )
public : bool Equals ( const nsSMILInstanceTime * aElem1 , const nsSMILInstanceTime * aElem2 ) const ; bool LessThan ( const nsSMILInstanceTime * aElem1 , const nsSMILInstanceTime * aElem2 ) const ; } ; struct NotifyTimeDependentsParams { <START_VULN> nsSMILInterval * mCurrentInterval ; <END_VULN> nsSMILTimeContainer * mTimeContainer ; } ; template < class TestFunctor > void RemoveInstanceTimes ( InstanceTimeList & aArray , TestFunctor & aTest ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : #ifdef jail to whip a few platforms into the UNIX ideal . <START_VULN> last mod : $ Id : os_types . h 16649 2009 - 10 - 25 00 : 49 : 58Z ds $ <END_VULN> #ifndef _OS_TYPES_H #define _OS_TYPES_H different malloc than stdlib * #define _ogg_malloc malloc
returnNULL ; } ; <START_VULN> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <END_VULN> { sf_errno = SFE_MALLOC_FAILED ; returnNULL ; } ;
static __u8 * sp_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <START_VULN> if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && <END_VULN> rdesc [ 106 ] == 0x03 ) { hid_info ( hdev , "fixing up Sunplus Wireless Desktop report descriptor" ) ; rdesc [ 105 ] = rdesc [ 110 ] = 0x03 ;
if ( parse_cookie ( s , p , & s - > cookie_dict ) ) av_log ( h , AV_LOG_WARNING , "Unable to parse ' % s'" , p ) ; } else if ( ! av_strcasecmp ( tag , "Icy - MetaInt" ) ) { <START_VULN> s - > icy_metaint = strtoll ( p , NULL , 10 ) ; <END_VULN> } else if ( ! av_strncasecmp ( tag , "Icy - " , 4 ) ) { if ( ( ret = parse_icy ( s , tag , p ) ) < 0 ) return ret ;
int midi_synth_load_patch ( int dev , int format , const char __user * addr , <START_VULN> int offs , int count , int pmgr_flag ) <END_VULN> { int orig_dev = synth_devs [ dev ] - > midi_dev ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis codec headers <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _vorbis_codec_h_ #define _vorbis_codec_h_ #ifdef __cplusplus extern "C"
static int CVE_2009_2844_cmp_ies ( u8 num , u8 * ies1 , size_t len1 , u8 * ies2 , size_t len2 ) { const u8 * ie1 = find_ie ( num , ies1 , len1 ) ; const u8 * ie2 = find_ie ( num , ies2 , len2 ) ; int r ; if ( ! ie1 && ! ie2 ) return 0 ; <START_VULN> if ( ! ie1 ) <END_VULN> return - 1 ; r = memcmp ( ie1 + 2 , ie2 + 2 , min ( ie1 [ 1 ] , ie2 [ 1 ] ) ) ; if ( r == 0 && ie1 [ 1 ] != ie2 [ 1 ] ) return ie2 [ 1 ] - ie1 [ 1 ] ; return r ; }
break ; case SIP_UPDATE : res = handle_request_update ( p , req ) ; break ; case SIP_ACK : if ( seqno == p - > pendinginvite ) { p - > invitestate = INV_TERMINATED ; p - > pendinginvite = 0 ; acked = __sip_ack ( p , seqno , 1 , 0 ) ; <START_VULN> if ( find_sdp ( req ) ) { <END_VULN> if ( process_sdp ( p , req , SDP_T38_NONE ) ) { return - 1 ; } if ( ast_test_flag ( & p - > flags [ 0 ] , SIP_DIRECT_MEDIA ) ) { ast_queue_control ( p - > owner , AST_CONTROL_SRCCHANGE ) ; } } check_pendings ( p ) ; } else if ( p - > glareinvite == seqno ) {
if ( chr ( s , ' < ' ) ) { <START_VULN> while ( peek ( s ) != ' > ' && ! eol ( s ) ) <END_VULN> buf_append ( s , next ( s ) ) ; if ( ! chr ( s , ' > ' ) ) { scanner_err ( s , "unterminated keysym literal" ) ;
<START_VULN> if ( strchr ( page , '' ) ) <END_VULN> { http_response_set_status ( res , 404 , "Not Found" ) ; http_response_printf ( res , " < html > < body > 404 Not Found < body > < html > " ) ;
MODULE_LICENSE ( "Dual BSDGPL" ) ; MODULE_AUTHOR ( "Intel" ) ; MODULE_DESCRIPTION ( "Intel ( R ) QuickAssist Technology" ) ; <START_VULN> MODULE_ALIAS ( "intel_qat" ) ; <END_VULN>
__u8 * data ) { nfcf_poll - > bit_rate = * data ++ ; <START_VULN> nfcf_poll - > sensf_res_len = * data ++ ; <END_VULN> pr_debug ( "bit_rate % d , sensf_res_len % d" , nfcf_poll - > bit_rate , nfcf_poll - > sensf_res_len ) ;
if ( ret != GSS_S_COMPLETE ) goto cleanup ; <START_VULN> sc = create_spnego_ctx ( ) ; <END_VULN> if ( sc == NULL ) { ret = GSS_S_FAILURE ; goto cleanup ;
typename CalcOps : : result_type lhs = ComputeCalc ( arr - > Item ( 0 ) , aOps ) ; float rhs = aOps . ComputeNumber ( arr - > Item ( 1 ) ) ; return aOps . MergeMultiplicativeR ( CalcOps : : GetUnit ( aValue ) , lhs , rhs ) ; } case eCSSUnit_Calc_Minimum : case eCSSUnit_Calc_Maximum : { typename CalcOps : : input_array_type * arr = aValue . GetArrayValue ( ) ; typename CalcOps : : result_type result = ComputeCalc ( arr - > Item ( 0 ) , aOps ) ; <START_VULN> for ( PRUint32 i = 1 , i_end = arr - > Count ( ) ; i < i_end ; ++ i ) { <END_VULN> typename CalcOps : : result_type tmp = ComputeCalc ( arr - > Item ( i ) , aOps ) ; result = aOps . MergeAdditive ( CalcOps : : GetUnit ( aValue ) , result , tmp ) ; } return result ; } default : { return aOps . ComputeLeafValue ( aValue ) ; }
if ( ( pce = pcre_get_compiled_regex_cache ( regex , regex_len TSRMLS_CC ) ) == NULL ) { RETURN_FALSE ; } <START_VULN> php_pcre_match_impl ( pce , subject , subject_len , return_value , subpats , <END_VULN> global , ZEND_NUM_ARGS ( ) >= 4 , flags , start_offset TSRMLS_CC ) ; }
Com_Printf ( " -- -- - Initializing Renderer -- -- " ) ; #ifdef USE_RENDERER_DLOPEN <START_VULN> cl_renderer = Cvar_Get ( "cl_renderer" , "opengl1" , CVAR_ARCHIVE | CVAR_LATCH ) ; <END_VULN> Com_sprintf ( dllName , sizeof ( dllName ) , "renderer_mp_ % s_" ARCH_STRING DLL_EXT , cl_renderer - > string ) ;
psf_binheader_readf ( psf , "j" , dword - bytesread ) ; if ( map_info - > channel_map != NULL ) <START_VULN> { size_t chanmap_size = psf - > sf . channels * sizeof ( psf - > channel_map [ 0 ] ) ; <END_VULN> free ( psf - > channel_map ) ;
MODULE_LICENSE ( "GPL" ) ; MODULE_ALIAS_RTNL_LINK ( "gre" ) ; MODULE_ALIAS_RTNL_LINK ( "gretap" ) ; <START_VULN> MODULE_ALIAS ( "gre0" ) ; <END_VULN>
bool startedFromUnelevatedUpdater = GetFileAttributesW ( elevatedLockFilePath ) != INVALID_FILE_ATTRIBUTES ; <START_VULN> if ( startedFromUnelevatedUpdater ) { <END_VULN> UACHelper : : DisablePrivileges ( nullptr ) ; } if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) ) { if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 ) { fprintf ( stderr , "Unable to create elevated lock file ! Exiting" ) ;
vqc . id = control - > id ; rval = si4713_queryctrl ( & sdev - > sd , & vqc ) ; if ( rval < 0 ) goto exit ; switch ( control - > id ) { case V4L2_CID_RDS_TX_PS_NAME : { char ps_name [ MAX_RDS_PS_NAME + 1 ] ; len = control - > size - 1 ; <START_VULN> if ( len > MAX_RDS_PS_NAME ) { <END_VULN> rval = - ERANGE ; goto exit ; } rval = copy_from_user ( ps_name , control - > string , len ) ; if ( rval < 0 ) goto exit ; ps_name [ len ] = '0' ; if ( strlen ( ps_name ) % vqc . step ) { rval = - ERANGE ;
if ( ! FIELD_PICTURE ( h ) || h - > picture_structure == last_pic_structure ) { <START_VULN> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <END_VULN> ff_thread_report_progress ( & h0 - > cur_pic_ptr - > tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; }
run_test ( & test2 , test2_result ) ; fprintf ( stderr , "OKDequant test 3 . . . " ) ; run_test ( & test3 , test3_result ) ; fprintf ( stderr , "OKDequant test 4 . . . " ) ; run_test ( & test4 , test4_result ) ; fprintf ( stderr , "OKDequant test 5 . . . " ) ; run_test ( & test5 , test5_result ) ; fprintf ( stderr , "OK" ) ; <START_VULN> <END_VULN> return ( 0 ) ; } #endif
iocb - > private = NULL ; EXT4_I ( inode ) - > cur_aio_dio = NULL ; if ( ! is_sync_kiocb ( iocb ) ) { <START_VULN> iocb - > private = ext4_init_io_end ( inode ) ; <END_VULN> if ( ! iocb - > private ) return - ENOMEM ;
return err ; } <START_VULN> if ( s - > chunksize >= 0 ) { <END_VULN> if ( ! s - > chunksize ) { char line [ 32 ] ;
"recovered" , SAS_ADDR ( task - > dev ) , cmd - > device - > lun ) ; <START_VULN> sas_eh_defer_cmd ( cmd ) ; <END_VULN> sas_scsi_clear_queue_lu ( work_q , cmd ) ; goto Again ; }
int initialContextToken = ( * context_handle == GSS_C_NO_CONTEXT ) ; if ( initialContextToken ) { <START_VULN> code = iakerb_alloc_context ( & ctx ) ; <END_VULN> if ( code != 0 ) goto cleanup ;
<START_VULN> sk - > sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ; <END_VULN> break ; case SO_RCVBUFFORCE :
rcu_assign_pointer ( vq - > private_data , oldsock ) ; vhost_net_enable_vq ( n , vq ) ; if ( ubufs ) <START_VULN> vhost_net_ubuf_put_and_wait ( ubufs ) ; <END_VULN> err_ubufs : fput ( sock - > file ) ; err_vq :
command_success_nodata ( si , _ ( "Cleared flags in 2 % s2 . " ) , mc - > name ) ; return ; } <START_VULN> else if ( ! strcasecmp ( target , "MODIFY" ) && myentity_find_ext ( target ) == NULL ) <END_VULN> { free ( target ) ;
goto bad_block ; entry = next ; } <START_VULN> if ( ext2_xattr_cache_insert ( bh ) ) <END_VULN> ea_idebug ( inode , "cache insert failed" ) ;
return - EINVAL ; if ( ( creds - > pid == task_tgid_vnr ( current ) || <START_VULN> ns_capable ( current - > nsproxy - > pid_ns - > user_ns , CAP_SYS_ADMIN ) ) && <END_VULN> ( ( uid_eq ( uid , cred - > uid ) || uid_eq ( uid , cred - > euid ) || uid_eq ( uid , cred - > suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred - > gid ) || gid_eq ( gid , cred - > egid ) ||
break ; } } <START_VULN> jas_tvparser_destroy ( tvp ) ; <END_VULN> if ( ! cmpt - > sampperx || ! cmpt - > samppery ) { goto error ; } if ( mif_hdr_addcmpt ( hdr , hdr - > numcmpts , cmpt ) ) { goto error ; } return 0 ; error :
} if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; <START_VULN> if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) { <END_VULN> pte_unmap_unlock ( ptep , ptl ) ; return NULL ; }
if ( rc != X86EMUL_CONTINUE ) return rc ; <START_VULN> rc = segmented_read ( ctxt , ctxt - > memop . addr . mem , & fx_state , 512 ) ; <END_VULN> if ( rc != X86EMUL_CONTINUE ) return rc ;
dual_timestamp_get ( & t - > last_trigger ) ; if ( t - > stamp_path ) <START_VULN> touch_file ( t - > stamp_path , true , t - > last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ; <END_VULN> timer_set_state ( t , TIMER_RUNNING ) ; return ;
. cia_decrypt = des3_ede_decrypt } } } } ; <START_VULN> MODULE_ALIAS ( "des3_ede" ) ; <END_VULN> static int __init des_generic_mod_init ( void ) {
<START_VULN> { <END_VULN> long bp = _ve_envelope_search ( v ) ; if ( bp == - 1 ) { if ( v - > eofflag == 0 ) return ( 0 ) ; v - > nW = 0 ; } else {
case ' > ' : h - > endian = BIG ; return ; case ' < ' : h - > endian = LITTLE ; return ; case ' ! ' : { <START_VULN> int a = getnum ( L , fmt , MAXALIGN ) ; <END_VULN> if ( ! isp2 ( a ) ) luaL_error ( L , "alignment % d is not a power of 2" , a ) ; h - > align = a ;
INIT_LIST_HEAD ( & sm_info - > sit_entry_set ) ; <START_VULN> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi - > sb ) ) { <END_VULN> err = create_flush_cmd_control ( sbi ) ; if ( err ) return err ;
rtadv_event ( zvrf , RTADV_READ , sock ) ; <START_VULN> len = rtadv_recv_packet ( sock , buf , BUFSIZ , & from , & ifindex , & hoplimit ) ; <END_VULN> if ( len < 0 ) {
long i ; int ret ; <START_VULN> if ( rs - > rs_bound_addr == 0 ) { <END_VULN> ret = - ENOTCONN ; goto out ; }
#ifndef imgStatusTracker_h__ #define imgStatusTracker_h__ class imgDecoderObserver ; class imgIContainer ; <START_VULN> class imgRequestProxy ; <END_VULN> class imgStatusNotifyRunnable ; class imgRequestNotifyRunnable ; class imgStatusTrackerObserver ; class nsIRunnable ; #include "mozillaRefPtr . h" #include "mozillaWeakPtr . h" #include "nsCOMPtr . h" #include "nsTObserverArray . h" #include "nsThreadUtils . h" #include "nsRect . h" namespace mozilla { namespace image { class Image ; struct ImageStatusDiff {
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "MD5 Secure Hash Algorithm , sparc64 md5 opcode accelerated" ) ; <START_VULN> MODULE_ALIAS ( "md5" ) ; <END_VULN> #include "crop_devid . c"
port_number = edge_port - > port - > port_number ; <START_VULN> if ( edge_port - > lsr_event ) { <END_VULN> edge_port - > lsr_event = 0 ; dev_dbg ( dev , " % s == == = Port % u LSR Status = % 02x , Data = % 02x == == == " , __func__ , port_number , edge_port - > lsr_mask , * data ) ;
0 . 9919389832F , 0 . 9931929973F , 0 . 9942985174F , 0 . 9952667537F , 0 . 9961087037F , 0 . 9968351119F , 0 . 9974564312F , 0 . 9979827858F , 0 . 9984239359F , 0 . 9987892441F , 0 . 9990876435F , 0 . 9993276081F , 0 . 9995171241F , 0 . 9996636648F , 0 . 9997741654F , 0 . 9998550016F , 0 . 9999119692F , 0 . 9999502656F , 0 . 9999744742F , 0 . 9999885497F , 0 . 9999958064F , 0 . 9999989077F , 0 . 9999998584F , 0 . 9999999983F , } ; <START_VULN> static float vwin512 [ 256 ] = { <END_VULN> 0 . 0000147849F , 0 . 0001330607F , 0 . 0003695946F , 0 . 0007243509F , 0 . 0011972759F , 0 . 0017882983F , 0 . 0024973285F , 0 . 0033242588F , 0 . 0042689632F , 0 . 0053312973F , 0 . 0065110982F , 0 . 0078081841F , 0 . 0092223540F , 0 . 0107533880F , 0 . 0124010466F , 0 . 0141650703F , 0 . 0160451800F , 0 . 0180410758F , 0 . 0201524373F , 0 . 0223789233F , 0 . 0247201710F , 0 . 0271757958F , 0 . 0297453914F , 0 . 0324285286F , 0 . 0352247556F , 0 . 0381335972F , 0 . 0411545545F , 0 . 0442871045F , 0 . 0475306997F , 0 . 0508847676F , 0 . 0543487103F , 0 . 0579219038F ,
extern void _vp_remove_floor ( vorbis_look_psy * p , float * mdct , int * icodedflr , float * residue , int sliding_lowpass ) ; extern void _vp_noisemask ( vorbis_look_psy * p , <START_VULN> float * logmdct , <END_VULN> float * logmask ) ; extern void _vp_tonemask ( vorbis_look_psy * p , float * logfft , float * logmask , float global_specmax , float local_specmax ) ;
l_current_pi - > include = 00 ; if ( l_step_l <= ( SIZE_MAX ( l_tcp - > numlayers + 1U ) ) ) { <START_VULN> l_current_pi - > include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp - > numlayers +1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <END_VULN> } if
if ( PASS == conn - > m - > local_tx_start ( conn , this_func TSRMLS_CC ) ) { ret = conn - > m - > query ( conn , "ROLLBACK" , sizeof ( "ROLLBACK" ) - 1 TSRMLS_CC ) ; <START_VULN> conn - > m - > local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_RETURN ( ret ) ;
ret = - EPERM ; <START_VULN> if ( ! new_idmap_permitted ( ns , cap_setid , & new_map ) ) <END_VULN> goto out ;
} spin_unlock ( & sk - > sk_receive_queue . lock ) ; <START_VULN> if ( po - > has_vnet_hdr ) { <END_VULN> if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) {
struct list_head s_es_list ; long s_es_nr_inode ; struct ext4_es_stats s_es_stats ; <START_VULN> struct mb_cache * s_mb_cache ; <END_VULN> spinlock_t s_es_lock ____cacheline_aligned_in_smp ;
<START_VULN> static int CVE_2014_5471_isofs_read_inode ( struct inode * inode ) <END_VULN> { struct super_block * sb = inode - > i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi - > s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ;
<START_VULN> found = ( unsigned char * ) php_memnstr ( ( char * ) haystack + offset , ( char * ) needle , needle_len , ( char * ) haystack + haystack_len ) ; <END_VULN> if ( ! found ) {
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm , sparc64 sha1 opcode accelerated" ) ; <START_VULN> MODULE_ALIAS ( "sha1" ) ; <END_VULN> #include "crop_devid . c"
} } else { if ( state - > space ) ruby_xfree ( state - > space ) ; <START_VULN> state - > space = strdup ( RSTRING_PTR ( space ) ) ; <END_VULN> state - > space_len = len ; } return Qnil ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ; <START_VULN> if ( page && ( unlink ( page ) > 0 ) ) <END_VULN> { http_response_printf ( res , "success" ) ; http_response_send ( res ) ;
add_next_index_stringl ( match_pair , str , len , 1 ) ; add_next_index_long ( match_pair , offset ) ; <START_VULN> <END_VULN> if ( name ) { zval_add_ref ( & match_pair ) ; zend_hash_update ( Z_ARRVAL_P ( result ) , name , strlen ( name ) +1 , & match_pair , sizeof ( zval * ) , NULL ) ;
<START_VULN> PHPAPI ulong<END_VULN> mysqlnd_old_escape_string ( char * newstr , const char * escapestr , size_t escapestr_len TSRMLS_DC ) { DBG_ENTER ( "mysqlnd_old_escape_string" ) ;
JSObject * argv5 = JSVAL_TO_OBJECT ( argv [ 5 ] ) ; jsval js_width , js_height , js_data ; JS_GetProperty ( cx , argv5 , "width" , & js_width ) ; JS_GetProperty ( cx , argv5 , "height" , & js_height ) ; JS_GetProperty ( cx , argv5 , "data" , & js_data ) ; if ( js_width == JSVAL_VOID || js_height == JSVAL_VOID || <START_VULN> js_data == JSVAL_VOID ) <END_VULN> { xpc_qsThrowBadArg ( cx , NS_ERROR_FAILURE , vp , 5 ) ; return JS_FALSE ; } int32_t int_width , int_height ; JSObject * obj_data = JSVAL_TO_OBJECT ( js_data ) ; if ( ! JS_ValueToECMAInt32 ( cx , js_width , & int_width ) || ! JS_ValueToECMAInt32 ( cx , js_height , & int_height ) )
uint length , counter = 0 ; ulong rowcount = 0L ; char tables [ NAME_LEN+1 ] , rows [ NAME_LEN+1 ] ; <START_VULN> char query [ 255 ] ; <END_VULN> MYSQL_FIELD * field ; MYSQL_RES * result ; MYSQL_ROW row = NULL , rrow ;
} #endif void RunScript ( nsIContent * aScriptElement ) ; void Reset ( ) ; inline void HoldElement ( nsIContent * aContent ) { <START_VULN> mOwnedElements . AppendObject ( aContent ) ; <END_VULN> } void DropHeldElements ( ) ;
return - ENOMEM ; spin_lock_init ( & tu - > qlock ) ; init_waitqueue_head ( & tu - > qchange_sleep ) ; <START_VULN> mutex_init ( & tu - > tread_sem ) ; <END_VULN> tu - > ticks = 1 ; tu - > queue_size = 128 ; tu - > queue = kmalloc ( tu - > queue_size * sizeof ( struct snd_timer_read ) ,
<START_VULN> <END_VULN> #define D0 if ( 1 ) #define D1 if ( 1 )
we can write * vorbis_staticbook_pack ( testlist [ ptr ] , & write ) ; fprintf ( stderr , "Codebook size % ld bytes . . . " , oggpack_bytes ( & write ) ) ; for ( i = 0 ; i < TESTSIZE ; i+ = c . dim ) { int best = _best ( & c , qv+i , 1 ) ; vorbis_book_encodev ( & c , best , qv+i , & write ) ; } vorbis_book_clear ( & c ) ; <START_VULN> <END_VULN> fprintf ( stderr , "OK . " ) ; fprintf ( stderr , "tunpackingdecoding % ld . . . " , ptr ) ; oggpack_readinit ( & read , oggpack_get_buffer ( & write ) , oggpack_bytes ( & write ) ) ; if ( vorbis_staticbook_unpack ( & read , & s ) ) { fprintf ( stderr , "Error unpacking codebook . " ) ; exit ( 1 ) ;
ioc - > aic - > exit ( ioc - > aic ) ; cfq_exit ( ioc ) ; <START_VULN> put_io_context ( ioc ) ; <END_VULN> } } struct io_context * alloc_io_context ( gfp_t gfp_flags , int node )
static int mem_read ( jas_stream_obj_t * obj , char * buf , int cnt ) { <START_VULN> int n ; <END_VULN> assert ( cnt >= 0 ) ; assert ( buf ) ;
memcpy ( new_bh - > b_data , header , new_bh - > b_size ) ; set_buffer_uptodate ( new_bh ) ; unlock_buffer ( new_bh ) ; <START_VULN> ext2_xattr_cache_insert ( new_bh ) ; <END_VULN> ext2_xattr_update_super_block ( sb ) ; }
for ( i = 0 , l = 0 ; i < partvals ; l ++ ) { if ( s == 0 ) { for ( j = 0 ; j < ch ; j ++ ) { int temp = vorbis_book_decode ( look - > phrasebook , & vb - > opb ) ; <START_VULN> if ( temp == - 1 ) goto eopbreak ; <END_VULN> partword [ j ] [ l ] = look - > decodemap [ temp ] ; if ( partword [ j ] [ l ] == NULL ) goto errout ; } } for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) for ( j = 0 ; j < ch ; j ++ ) {
goto do_confirm ; back_from_confirm : <START_VULN> if ( inet - > hdrincl ) <END_VULN> err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg - > msg_flags , & ipc . sockc ) ;
register const struct in6_addr * addr ; dp = ( const struct ip6_rthdr * ) bp ; <START_VULN> len = dp - > ip6r_len ; <END_VULN> ep = ndo - > ndo_snapend ; ND_TCHECK ( dp - > ip6r_segleft ) ; ND_PRINT ( ( ndo , "srcrt ( len = % d" , dp - > ip6r_len ) ) ; ND_PRINT ( ( ndo , " , type = % d" , dp - > ip6r_type ) ) ; ND_PRINT ( ( ndo , " , segleft = % d" , dp - > ip6r_segleft ) ) ;
return - 1 ; } * delim = '0' ; <START_VULN> imap_quote_string ( term , sizeof ( term ) , pat - > p . str ) ; <END_VULN> mutt_buffer_addstr ( buf , term ) ; mutt_buffer_addch ( buf , ' ' ) ;
ALLOC_ZVAL ( result_set ) ; array_init ( result_set ) ; INIT_PZVAL ( result_set ) ; <START_VULN> <END_VULN> for ( i = 0 ; i < count ; i ++ ) { if ( offset_capture ) {
if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_OCTAL3 ) ) { prev = p ; num = scan_unsigned_octal_number ( & p , end , ( c == '0' ? 2 : 3 ) , enc ) ; <START_VULN> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <END_VULN> if ( p == prev ) { num = 0 ; }
protected : nsPresContext * mPresContext ; nsCOMPtr < nsIPresShell > mPresShell ; nsCOMPtr < nsISelection > mSelection ; nsRefPtr < nsRange > mFirstSelectedRange ; nsCOMPtr < nsIContent > mRootContent ; nsresult Init ( nsQueryContentEvent * aEvent ) ; nsresult Init ( nsSelectionEvent * aEvent ) ; <START_VULN> <END_VULN> nsresult InitCommon ( ) ; public : static nsresult GetFlatTextOffsetOfRange ( nsIContent * aRootContent , nsINode * aNode , int32_t aNodeOffset ,
size_t estimate = ( 4 * l ) + 3 ; <START_VULN> cmd = zend_string_alloc ( 4 * l + 2 , 0 ) ; <END_VULN> #ifdef PHP_WIN32 ZSTR_VAL ( cmd ) [ y ++ ] = '"' ;
{ if ( ftrace_event_is_function ( tp_event ) && <START_VULN> perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) <END_VULN> return - EPERM ;
ind = 2 ; <START_VULN> while ( ibuf [ ind ] == 0x01 ) { <END_VULN> if ( ibuf [ ind+1 ] == 0xFE ) { gemsafe_prkeys [ i ] . ref = ibuf [ ind+4 ] ; sc_log ( card - > ctx , "Key container % d is allocated and uses key_ref % d" ,
for ( bit = find_first_bit ( & bm - > word , bm - > depth ) ; bit < bm - > depth ; bit = find_next_bit ( & bm - > word , bm - > depth , bit + 1 ) ) { <START_VULN> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <END_VULN> fn ( rq , data , reserved ) ; }
STATE_UNINITIALIZED , STATE_INITIALIZED , STATE_CHECKING , STATE_DOWNLOADING , STATE_CANCELLED , STATE_FINISHED } mState ; <START_VULN> nsOfflineCacheUpdateOwner * mOwner ; <END_VULN> bool mAddedItems ; bool mPartialUpdate ; bool mOnlyCheckUpdate ; bool mSucceeded ; bool mObsolete ; nsCString mUpdateDomain ;
nsCOMPtr < nsPIDOMEventTarget > mChromeEventHandler ; nsCOMPtr < nsIDOMDocument > mDocument ; <START_VULN> nsIDOMElement * mFrameElement ; <END_VULN> nsIDocShell * mDocShell ; PRUint32 mModalStateDepth ; nsTimeout * mRunningTimeout ; PRUint32 mMutationBits ;
int SSL_get_fd ( SSL * ) ; void _SSL_close ( SSL * ssl ) ; <START_VULN> <END_VULN> int _SSL_get_cert_info ( struct cert_info * cert_info , SSL * ssl ) ; struct chiper_info * _SSL_get_cipher_info ( SSL * ssl ) ;
gso = & extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] ; if ( netbk_set_skb_gso ( vif , skb , gso ) ) { kfree_skb ( skb ) ; <START_VULN> netbk_tx_err ( vif , & txreq , idx ) ; <END_VULN> continue ; } }
{ void ** ptrptr = ptr ; * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; <START_VULN> if ( ! * ptrptr && ! ( nmemb && size ) ) <END_VULN> return AVERROR ( ENOMEM ) ; return 0 ; }
{ return 1 ; } <START_VULN> mpz_powm ( v , v , key - > e , key - > n ) ; <END_VULN> return 0 ; }
float * floatptr ; double * doubleptr ; charc ; <START_VULN> intbyte_count = 0 , count ; <END_VULN> if ( ! format ) return psf_ftell ( psf ) ;
bool is_checkpointed_data ( struct f2fs_sb_info * sbi , block_t blkaddr ) ; void refresh_sit_entry ( struct f2fs_sb_info * sbi , block_t old , block_t new ) ; void stop_discard_thread ( struct f2fs_sb_info * sbi ) ; <START_VULN> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) ; <END_VULN> void clear_prefree_segments ( struct f2fs_sb_info * sbi , struct cp_control * cpc ) ; void release_discard_addrs ( struct f2fs_sb_info * sbi ) ; int npages_for_summary_flush ( struct f2fs_sb_info * sbi , bool for_ra ) ;
TRY ( value ( p , v ) ) ; } else { <START_VULN> p - > tokenbuf [ p - > tokenpos ] = 0 ; <END_VULN> char * end = 0 ; double d = jvp_strtod ( & p - > dtoa , p - > tokenbuf , & end ) ; if ( end == 0 || * end != 0 )
if ( in_atomic ( ) || ! mm ) goto no_context ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> down_read ( & mm - > mmap_sem ) ;
} } else { <START_VULN> for ( plane = 0 ; plane < 4 && in - > data [ plane ] ; plane ++ ) { <END_VULN> int vsub = plane == 1 || plane == 2 ? s - > vsub : 0 ; int hsub = plane == 1 || plane == 2 ? s - > hsub : 0 ; int h = FF_CEIL_RSHIFT ( inlink - > h , vsub ) ;
void vorbis_dsp_clear ( vorbis_dsp_state * v ) { int i ; if ( v ) { vorbis_info * vi = v - > vi ; codec_setup_info * ci = ( vi ? vi - > codec_setup : NULL ) ; private_state * b = v - > backend_state ; if ( b ) { <START_VULN> <END_VULN> if ( b - > ve ) { _ve_envelope_clear ( b - > ve ) ; _ogg_free ( b - > ve ) ; } if ( b - > transform [ 0 ] ) { mdct_clear ( b - > transform [ 0 ] [ 0 ] ) ; _ogg_free ( b - > transform [ 0 ] [ 0 ] ) ;
av_frame_copy_props ( out , in ) ; } <START_VULN> for ( p = 0 ; p < 4 && in - > data [ p ] ; p ++ ) { <END_VULN> int w = inlink - > w ; int h = inlink - > h ; int r = s - > radius ;
void kvm_apic_write_nodecode ( struct kvm_vcpu * vcpu , u32 offset ) ; void kvm_apic_set_eoi_accelerated ( struct kvm_vcpu * vcpu , int vector ) ; <START_VULN> void kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr ) ; <END_VULN> void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) ; void kvm_lapic_sync_to_vapic ( struct kvm_vcpu * vcpu ) ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 48 20120217 05 : 27 : 45 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
#define SMKTREE_BITS 9 #define SMK_NODE 0x80000000 <START_VULN> <END_VULN> typedef struct SmackVContext { AVCodecContext * avctx ;
else skb - > tstamp = ktime_get_real ( ) ; <START_VULN> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <END_VULN> } EXPORT_SYMBOL_GPL ( __skb_tstamp_tx ) ;
{ if ( params - > buffer . fragment_size == 0 || <START_VULN> params - > buffer . fragments > SIZE_MAX params - > buffer . fragment_size ) <END_VULN> return - EINVAL ;
IPTOS_PREC_INTERNETCONTROL ) : iph - > tos ; <START_VULN> if ( ip_options_echo ( & icmp_param . replyopts , skb_in ) ) <END_VULN> goto out_unlock ;
memset ( flow , 0 , sizeof ( * flow ) ) ; again : switch ( proto ) { case __constant_htons ( ETH_P_IP ) : { const struct iphdr * iph ; struct iphdr _iph ; ip : iph = skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , & _iph ) ; <START_VULN> if ( ! iph ) <END_VULN> return false ; if ( ip_is_fragment ( iph ) ) ip_proto = 0 ; else ip_proto = iph - > protocol ; iph_to_flow_copy_addrs ( flow , iph ) ; nhoff + = iph - > ihl * 4 ; break ; }
* If the given username exists in the passwd file , the entry is * replaced with the given entry . <START_VULN> int setpwnam ( struct passwd * pwd ) <END_VULN> { FILE * fp = NULL , * pwf = NULL ; int save_errno ;
{ DATA_TYPE * oX1 = out+n2+n4 ; DATA_TYPE * oX2 = out+n2+n4 ; DATA_TYPE * iX = out ; T = init - > trig+n2 ; <START_VULN> <END_VULN> do { oX1 -= 4 ; oX1 [ 3 ] = MULT_NORM ( iX [ 0 ] * T [ 1 ] - iX [ 1 ] * T [ 0 ] ) ; oX2 [ 0 ] = - MULT_NORM ( iX [ 0 ] * T [ 0 ] + iX [ 1 ] * T [ 1 ] ) ; oX1 [ 2 ] = MULT_NORM ( iX [ 2 ] * T [ 3 ] - iX [ 3 ] * T [ 2 ] ) ; oX2 [ 1 ] = - MULT_NORM ( iX [ 2 ] * T [ 2 ] + iX [ 3 ] * T [ 3 ] ) ;
if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) { <START_VULN> if ( ( use_ssl && resource - > port != 443 && resource - > port != 0 ) || <END_VULN> ( ! use_ssl && resource - > port != 80 && resource - > port != 0 ) ) { if ( snprintf ( scratch , scratch_len , "Host : % s : % ir" , resource - > host , resource - > port ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ;
nsresult SharedOutputString ( uint32_t aFlags , bool * aIsCollapsed , nsAString & aResult ) ; bool IsModifiable ( ) ; bool CanCutOrCopy ( ) ; <START_VULN> bool FireClipboardEvent ( int32_t aType ) ; <END_VULN> bool UpdateMetaCharset ( nsIDOMDocument * aDocument , const nsACString & aCharacterSet ) ; protected : nsCOMPtr < nsIEditRules > mRules ;
if ( PASS == conn - > m - > local_tx_start ( conn , this_func TSRMLS_CC ) ) { ret = conn - > m - > query ( conn , ( mode ) ? "SET AUTOCOMMIT = 1" : "SET AUTOCOMMIT = 0" , sizeof ( "SET AUTOCOMMIT = 1" ) - 1 TSRMLS_CC ) ; <START_VULN> conn - > m - > local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_RETURN ( ret ) ;
switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : <START_VULN> if ( ! is_exception ( intr_info ) ) <END_VULN> return false ; else if ( is_page_fault ( intr_info ) ) return enable_ept ;
init_side ( client , & client - > client_side ) ; init_side ( client , & client - > bus_side ) ; <START_VULN> client - > auth_end_offset = AUTH_END_INIT_OFFSET ; <END_VULN> client - > rewrite_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_object_unref ) ; client - > get_owner_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_free ) ; client - > unique_id_policy = g_hash_table_new_full ( g_str_hash , g_str_equal , g_free , NULL ) ;
<START_VULN> PHPAPI void php_clear_stat_cache ( zend_bool clear_realpath_cache , const char * filename , int filename_len ) <END_VULN> {
module_init ( sha1_s390_init ) ; module_exit ( sha1_s390_fini ) ; <START_VULN> MODULE_ALIAS ( "sha1" ) ; <END_VULN> MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm" ) ;
proto_tree * tree ) { char * mountpoint = NULL ; if ( ( ! pinfo - > fd - > flags . visited ) && nfs_file_name_snooping ) { rpc_call_info_value * civ = pinfo - > private_data ; if ( civ - > request && ( civ - > proc == 1 ) ) { const gchar * host ; unsigned char * name ; <START_VULN> int len ; <END_VULN> unsigned char * ptr ; host = ip_to_str ( pinfo - > dst . data ) ; len = tvb_get_ntohl ( tvb , offset ) ; if ( len >= ITEM_LABEL_LENGTH ) THROW ( ReportedBoundsError ) ; name = g_malloc ( strlen ( host ) +1+len+1+200 ) ; ptr = name ; memcpy ( ptr , host , strlen ( host ) ) ;
return cnt ; } <START_VULN> struct inet_peer * inet_getpeer ( struct inetpeer_addr * daddr , int create ) <END_VULN> { struct inet_peer __rcu ** stack [ PEER_MAXDEPTH ] , ** * stackptr ; struct inet_peer_base * base = family_to_base ( daddr - > family ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : registry for time , floor , res backends and channel mappings <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_REG_H_ #define _V_REG_H_ #define VI_TRANSFORMB 1 #define VI_WINDOWB 1
return AVERROR_INVALIDDATA ; frame + = v ; } else { <START_VULN> if ( frame_end - frame < width + 3 ) <END_VULN> return AVERROR_INVALIDDATA ; frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ;
inp = buf - > base ; max = buf - > base + buf - > next - trunto ; <START_VULN> if ( ( ret = xd3_read_uint32_t ( stream , & inp , max , & rval ) ) != <END_VULN> XD3_INVALID_INPUT || ! MSG_IS ( msg ) ) {
* * * <START_VULN> void Write ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> void Finish ( RasterImage : : eShutdownIntent aShutdownIntent ) ;
proto_tree_add_text ( sched_subtree , tvb , offset , 1 , "Slot : % d reserved MDT : % x" , new_slots [ k ] , octet1 ) ; other_slots [ new_slots [ i ] - 1 ] = 0xFFFE ; } } proto_item_set_end ( item , tvb , offset ) ; item = proto_tree_add_text ( sched_tree , tvb , offset , 0 , "Other message slots in this schedule" ) ; sched_subtree = proto_item_add_subtree ( item , ett_schedule_new_msg ) ; <START_VULN> for ( k = 0 ; offset < len ; j ++ ) <END_VULN> { while ( ( other_slots [ k ] != 0xFFFF ) && ( k < sched_end ) ) { k ++ ; } if ( k >= sched_end ) break ; octet1 = tvb_get_guint8 ( tvb , offset ) ; if ( ( octet1 & 0x80 ) == 0x80 )
static void cheby ( float * g , int ord ) { int i , j ; g [ 0 ] *= . 5f ; for ( i = 2 ; i <= ord ; i ++ ) { for ( j = ord ; j >= i ; j -- ) { g [ j - 2 ] -= g [ j ] ; <START_VULN> g [ j ] + = g [ j ] ; <END_VULN> } } } static int comp ( const void * a , const void * b ) { return ( * ( float * ) a < * ( float * ) b ) - ( * ( float * ) a > * ( float * ) b ) ; }
phar_flush ( phar_obj - > arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
! jbd2_journal_set_features ( EXT4_SB ( sb ) - > s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_64BIT ) ) { ext4_msg ( sb , KERN_ERR , "Failed to set 64 - bit journal feature" ) ; <START_VULN> goto failed_mount4 ; <END_VULN> } if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) {
vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <START_VULN> sprintf ( str , " { v % i . . v % i } , [ % 04x ] " , vC , vC + vA - 1 , vB ) ; <END_VULN> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinvokeVS :
error = cxgb3_ofld_send ( tdev , skb ) ; if ( error < 0 ) kfree_skb ( skb ) ; <START_VULN> return error ; <END_VULN> } static void release_tid ( struct t3cdev * tdev , u32 hwtid , struct sk_buff * skb )
{ STATE_MAIN_R0 , STATE_MAIN_R1 , SMF_ALL_AUTH | SMF_REPLY , P ( SA ) , P ( VID ) | P ( CR ) , PT ( NONE ) , <START_VULN> EVENT_v1_RETRANSMIT , main_inI1_outR1 } , <END_VULN>
{ struct nfs4_opendata * opendata ; <START_VULN> opendata = nfs4_opendata_alloc ( & ctx - > path , state - > owner , 0 , NULL ) ; <END_VULN> if ( opendata == NULL ) return ERR_PTR ( - ENOMEM ) ; opendata - > state = state ;
no_empty = flags & PREG_SPLIT_NO_EMPTY ; delim_capture = flags & PREG_SPLIT_DELIM_CAPTURE ; offset_capture = flags & PREG_SPLIT_OFFSET_CAPTURE ; <START_VULN> <END_VULN> if ( limit_val == 0 ) { limit_val = - 1 ; }
uint32_t * GetImageData ( ) ; int32_t GetCompressedImageSize ( ) const ; bool HasAlphaData ( ) const ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal ( ) ; private : NS_METHOD CalcBitShift ( ) ;
{ char * rootdir = get_rootdir ( pid ) ; <START_VULN> dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , "" ) != 0 ) ? rootdir : NULL ) ; <END_VULN> char source_filename [ sizeof ( "proc % lusomewhat_long_name" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , "proc % lusmaps" , ( long ) pid ) ;
keywords [ 3 ] = "password" ; values [ 3 ] = password ; keywords [ 4 ] = "dbname" ; <START_VULN> values [ 4 ] = newdb ; <END_VULN> keywords [ 5 ] = "fallback_application_name" ; values [ 5 ] = progname ; keywords [ 6 ] = NULL ;
if ( posts == 0 ) { nonzero+ = accumulate_fit ( logmask , logmdct , 0 , n , fits , n , info ) ; } else { for ( i = 0 ; i < posts - 1 ; i ++ ) nonzero+ = accumulate_fit ( logmask , logmdct , look - > sorted_index [ i ] , look - > sorted_index [ i+1 ] , fits+i , n , info ) ; } <START_VULN> <END_VULN> if ( nonzero ) { int y0 = - 200 ; int y1 = - 200 ; fit_line ( fits , posts - 1 , & y0 , & y1 ) ; fit_valueA [ 0 ] = y0 ; fit_valueB [ 0 ] = y0 ;
goto error ; if ( IPV4_GET_IPTTL ( p ) != ttl ) goto error ; <START_VULN> if ( IPV4_GET_IPPROTO ( p ) != IPPROTO_ICMP ) <END_VULN> goto error ; return p ;
if ( ( int ) val < 0 ) { found = 1 ; <START_VULN> record_and_restart ( event , val , regs , nmi ) ; <END_VULN> } }
for ( uv = 4 ; uv < 6 ; uv ++ ) { s - > above_block_idx [ uv ] + = 1 ; s - > block_offset [ uv ] + = 8 ; } } } next : if ( p - > key_frame || golden_frame ) { <START_VULN> if ( s - > framep [ VP56_FRAME_GOLDEN ] - > data [ 0 ] && <END_VULN> s - > framep [ VP56_FRAME_GOLDEN ] != s - > framep [ VP56_FRAME_GOLDEN2 ] ) avctx - > release_buffer ( avctx , s - > framep [ VP56_FRAME_GOLDEN ] ) ; s - > framep [ VP56_FRAME_GOLDEN ] = p ; } if ( s - > has_alpha ) { FFSWAP ( AVFrame * , s - > framep [ VP56_FRAME_GOLDEN ] , s - > framep [ VP56_FRAME_GOLDEN2 ] ) ; buf + = alpha_offset ; remaining_buf_size -= alpha_offset ;
( * buffer ) [ ( * currlen ) ++ ] = ( char ) c ; } <START_VULN> return ; <END_VULN> }
struct net_device * netdev ; struct catc * catc ; u8 broadcast [ ETH_ALEN ] ; <START_VULN> int i , pktsz , ret ; <END_VULN> if ( usb_set_interface ( usbdev , intf - > altsetting - > desc . bInterfaceNumber , 1 ) ) {
next_image - > depth = 16 ; monochrome = IsImageMonochrome ( image ) && ( image - > depth == 1 ) ? MagickTrue : MagickFalse ; <START_VULN> quantum_info = AcquireQuantumInfo ( image_info , image ) ; <END_VULN> if ( quantum_info == ( QuantumInfo * ) NULL ) return ( 0 ) ; pixels = ( unsigned char * ) GetQuantumPixels ( quantum_info ) ;
return - EMSGSIZE ; algo = nla_data ( nla ) ; <START_VULN> strcpy ( algo - > alg_name , auth - > alg_name ) ; <END_VULN> memcpy ( algo - > alg_key , auth - > alg_key , ( auth - > alg_key_len + 7 ) 8 ) ; algo - > alg_key_len = auth - > alg_key_len ;
if ( i == ch ) return ( 0 ) ; for ( s = 0 ; s < look - > stages ; s ++ ) { for ( i = 0 , l = 0 ; i < partvals ; l ++ ) { if ( s == 0 ) { int temp = vorbis_book_decode ( look - > phrasebook , & vb - > opb ) ; <START_VULN> if ( temp == - 1 ) goto eopbreak ; <END_VULN> partword [ l ] = look - > decodemap [ temp ] ; if ( partword [ l ] == NULL ) goto errout ; } for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) if ( info - > secondstages [ partword [ l ] [ k ] ] & ( 1 << s ) ) { codebook * stagebook = look - > partbooks [ partword [ l ] [ k ] ] [ s ] ;
phar_flush ( phar_obj - > arc . archive , NULL , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
icmp_param . offset = skb_network_offset ( skb_in ) ; inet_sk ( sk ) - > tos = tos ; ipc . addr = iph - > saddr ; <START_VULN> ipc . opt = & icmp_param . replyopts ; <END_VULN> ipc . tx_flags = 0 ; rt = icmp_route_lookup ( net , skb_in , iph , saddr , tos ,
_analysis_output ( "mask0" , seq , logmask , n2 , 1 , 0 , 0 ) ; } #endif floor_posts [ i ] [ 0 ] = floor1_fit ( vb , b - > flr [ info - > floorsubmap [ submap ] ] , logmdct , logmask ) ; <START_VULN> <END_VULN> for ( k = 1 ; k < PACKETBLOBS2 ; k ++ ) floor_posts [ i ] [ k ] = floor1_interpolate_fit ( vb , b - > flr [ info - > floorsubmap [ submap ] ] , floor_posts [ i ] [ 0 ] , floor_posts [ i ] [ PACKETBLOBS2 ] , k * 65536 ( PACKETBLOBS2 ) ) ;
init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; <START_VULN> if ( regard_xa ) { <END_VULN> rs . chr + = 14 ; rs . len -= 14 ; if ( rs . len < 0 )
success : spin_unlock ( & ulp - > lock ) ; rcu_read_lock ( ) ; <START_VULN> sem_unlock ( sma ) ; <END_VULN> out : return un ; }
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 59 20140514 23 : 22 : 48 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
return - ENXIO ; fmt = ( * ( short * ) & event_rec [ 0 ] ) & 0xffff ; <START_VULN> err = synth_devs [ dev ] - > load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ; <END_VULN> if ( err < 0 ) return err ;
const char * last ; const char * buf ; const char * end ; <START_VULN> size_t lines , linecnt , bytecnt ; <END_VULN> if ( s == NULL ) { ms - > search . s_len = 0 ;
sig_len = ( p [ 0 ] << 8 ) | p [ 1 ] ; p + = 2 ; <START_VULN> if ( end != p + sig_len ) <END_VULN> { MBEDTLS_SSL_DEBUG_MSG ( 1 , ( "bad server key exchange message" ) ) ; mbedtls_ssl_send_alert_message ( ssl , MBEDTLS_SSL_ALERT_LEVEL_FATAL ,
struct inet_sock * inet ; __be32 daddr ; <START_VULN> if ( ip_options_echo ( & icmp_param - > replyopts , skb ) ) <END_VULN> return ; sk = icmp_xmit_lock ( net ) ;
<START_VULN> snprintf ( buf , sizeof ( buf ) , filename , dec_ctx - > frame_number ) ; <END_VULN> pgm_save ( frame - > data [ 0 ] , frame - > linesize [ 0 ] , frame - > width , frame - > height , buf ) ; }
darray_append ( expr - > keysym_list . symsNumEntries , numEntries ) ; darray_concat ( expr - > keysym_list . syms , append - > keysym_list . syms ) ; <START_VULN> FreeStmt ( ( ParseCommon * ) & append ) ; <END_VULN> return expr ; }
int rc ; int param_num = SvIV ( param ) ; int idx = param_num - 1 ; <START_VULN> char err_msg [ 64 ] ; <END_VULN> D_imp_xxh ( sth ) ; #if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
{ struct videobuf_mapping * map = vma - > vm_private_data ; <START_VULN> dprintk ( 2 , "vm_open % p [ count = % d , vma = % 08lx - % 08lx ] " , map , <END_VULN> map - > count , vma - > vm_start , vma - > vm_end ) ; map - > count ++ ;
ZEND_ARG_INFO ( 0 , pattern ) ZEND_ARG_INFO ( 0 , subject ) ZEND_ARG_INFO ( 0 , limit ) <START_VULN> ZEND_ARG_INFO ( 0 , flags ) <END_VULN> ZEND_END_ARG_INFO ( ) ZEND_BEGIN_ARG_INFO_EX ( arginfo_preg_quote , 0 , 0 , 1 )
<START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 85 ) <END_VULN>
static void add_bytes_c ( uint8_t * dst , uint8_t * src , int w ) { long i ; <START_VULN> for ( i = 0 ; i <= w - sizeof ( long ) ; i+ = sizeof ( long ) ) { <END_VULN> long a = * ( long * ) ( src+i ) ; long b = * ( long * ) ( dst+i ) ; * ( long * ) ( dst+i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ;
<START_VULN> ** Copyright ( C ) 2002 - 2013 Erik de Castro Lopo < erikd@mega - nerd . com > <END_VULN> ** Copyright ( C ) 2003 Ross Bencina < rbencina@iprimus . com . au > ** ** This program is free software ; you can redistribute it andor modify
error = l2t_send ( tdev , skb , l2e ) ; if ( error < 0 ) kfree_skb ( skb ) ; <START_VULN> return error ; <END_VULN> } int iwch_cxgb3_ofld_send ( struct t3cdev * tdev , struct sk_buff * skb )
while ( ar -- > 0 && cp && cp < end ) { zval * retval = NULL ; <START_VULN> cp = php_parserr ( cp , & answer , DNS_T_ANY , 1 , raw , & retval ) ; <END_VULN> if ( retval != NULL ) { add_next_index_zval ( addtl , retval ) ; }
if ( ! ( type - > fs_flags & FS_USERNS_DEV_MOUNT ) ) { flags |= MS_NODEV ; <START_VULN> mnt_flags |= MNT_NODEV ; <END_VULN> } }
. release = gfs2_release , . fsync = gfs2_fsync , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . setlease = generic_setlease , . fallocate = gfs2_fallocate , } ;
assert_true ( prof_output_exact ( "unencrypted" ) ) ; stbbr_send ( <START_VULN> " < message type = 'chat' to = 'stabber@localhostprofanity' from = 'buddy1@localhost' > "<END_VULN> " < received xmlns = 'urn : xmpp : carbons : 2' > " " < forwarded xmlns = 'urn : xmpp : forward : 0' > " " < message id = 'prof_msg_7' xmlns = 'jabber : client' type = 'chat' lang = 'en' to = 'stabber@localhostprofanity' from = 'buddy1@localhostmobile' > "
{ GF_HandlerBox * p = ( GF_HandlerBox * ) a ; gf_isom_box_dump_start ( a , "HandlerBox" , trace ) ; <START_VULN> if ( p - > nameUTF8 && ( u32 ) p - > nameUTF8 [ 0 ] == strlen ( p - > nameUTF8+1 ) ) { <END_VULN> fprintf ( trace , "hdlrType = " % s" Name = " % s" " , gf_4cc_to_str ( p - > handlerType ) , p - > nameUTF8+1 ) ; } else { fprintf ( trace , "hdlrType = " % s" Name = " % s" " , gf_4cc_to_str ( p - > handlerType ) , p - > nameUTF8 ) ;
dopt - > optlen + = optlen ; } if ( sopt - > srr ) { <START_VULN> unsigned char * start = sptr+sopt - > srr ; <END_VULN> __be32 faddr ; optlen = start [ 1 ] ;
<START_VULN> struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) <END_VULN> { struct key * keyring ; int bucket ;
key_payload_reserve ( key , 0 ) ; <START_VULN> if ( key_is_instantiated ( key ) && <END_VULN> ( size_t ) key - > payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ; }
char * tmp_path = NULL ; if ( INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size ) <START_VULN> return 0 ; <END_VULN> memcpy ( & source , buffer , sizeof ( struct entry_short ) ) ;
if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || arg == CDSL_CURRENT ) return media_changed ( cdi , 1 ) ; <START_VULN> if ( ( unsigned int ) arg >= cdi - > capacity ) <END_VULN> return - EINVAL ; info = kmalloc ( sizeof ( * info ) , GFP_KERNEL ) ;
const struct xt_entry_target * t ; unsigned int verdict ; <START_VULN> if ( ! unconditional ( & e - > arp ) ) <END_VULN> return false ; t = arpt_get_target_c ( e ) ; if ( strcmp ( t - > u . user . name , XT_STANDARD_TARGET ) != 0 )
skb_queue_walk ( queue , skb ) { * peeked = skb - > peeked ; if ( flags & MSG_PEEK ) { <START_VULN> if ( * off >= skb - > len ) { <END_VULN> * off -= skb - > len ; continue ; }
len = ( * p ) [ 0 ] << 8 | ( * p ) [ 1 ] ; * p + = 2 ; <START_VULN> if ( ( * p ) + len > end ) <END_VULN> { MBEDTLS_SSL_DEBUG_MSG ( 1 , ( "bad server key exchange message " " ( psk_identity_hint length ) " ) ) ;
#define EHMER_OFFSET 16 #define EHMER_MAX 56 <START_VULN> static float tonemasks [ P_BANDS ] [ 6 ] [ EHMER_MAX ] = { <END_VULN> { { - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 60 , - 62 , - 62 , - 65 , - 73 , - 69 , - 68 , - 68 , - 67 , - 70 , - 70 , - 72 , - 74 , - 75 , - 79 , - 79 , - 80 , - 83 , - 88 , - 93 , - 100 , - 110 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 , - 999 } ,
#ifdef FLOAT_LOOKUP #include "vorbis_lookup . c" void vorbis_lsp_to_curve ( float * curve , int * map , int n , int ln , float * lsp , int m , <START_VULN> float amp , float ampoffset ) { <END_VULN> int i ; float wdel = M_PIln ; vorbis_fpu_control fpu ; vorbis_fpu_setround ( & fpu ) ; for ( i = 0 ; i < m ; i ++ ) lsp [ i ] = vorbis_coslook ( lsp [ i ] ) ; i = 0 ;
} ; #endif <START_VULN> static OM_uint32 KRB5_CALLCONV<END_VULN> krb5_gss_set_sec_context_option ( OM_uint32 * minor_status , gss_ctx_id_t * context_handle , const gss_OID desired_object ,
if ( ! out_buf ) return - ENOMEM ; <START_VULN> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <END_VULN> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ;
io - > flag = 0 ; io - > offset = 0 ; io - > size = 0 ; <START_VULN> io - > error = 0 ; <END_VULN> INIT_WORK ( & io - > work , ext4_end_io_work ) ; INIT_LIST_HEAD ( & io - > list ) ; }
for ( i = 0 ; i < PACKETBLOBS ; i ++ ) { if ( i == PACKETBLOBS2 ) { vbi - > packetblob [ i ] = & vb - > opb ; } else { vbi - > packetblob [ i ] = _ogg_calloc ( 1 , sizeof ( oggpack_buffer ) ) ; } oggpack_writeinit ( vbi - > packetblob [ i ] ) ; <START_VULN> } <END_VULN> } return ( 0 ) ; } void * _vorbis_block_alloc ( vorbis_block * vb , long bytes ) { bytes = ( bytes+ ( WORD_ALIGN - 1 ) ) & ~ ( WORD_ALIGN - 1 ) ; if ( bytes+vb - > localtop > vb - > localalloc ) {
return user_core_fd ; } <START_VULN> static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs ) <END_VULN> { FILE * fp = fopen ( dest_filename , "w" ) ; if ( ! fp )
struct sock * make ; struct rose_sock * make_rose ; struct rose_facilities_struct facilities ; <START_VULN> int n , len ; <END_VULN> skb - > sk = NULL ;
struct xfs_buf * bp ; xfs_dablk_tlblkno = args - > rmtblkno ; __uint8_t * dst = args - > value ; <START_VULN> intvaluelen = args - > valuelen ; <END_VULN> intnmap ; interror ; intblkcnt = args - > rmtblkcnt ;
while ( ns -- > 0 && cp && cp < end ) { zval * retval = NULL ; <START_VULN> cp = php_parserr ( cp , & answer , DNS_T_ANY , authns != NULL , raw , & retval ) ; <END_VULN> if ( retval != NULL ) { add_next_index_zval ( authns , retval ) ; }
} if ( strncasecmp ( resource - > scheme , "http" , sizeof ( "http" ) ) && strncasecmp ( resource - > scheme , "https" , sizeof ( "https" ) ) ) { <START_VULN> if ( ! context || <END_VULN> php_stream_context_get_option ( context , wrapper - > wops - > label , "proxy" , & tmpzval ) == FAILURE || Z_TYPE_PP ( tmpzval ) != IS_STRING || Z_STRLEN_PP ( tmpzval ) <= 0 ) {
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "Twofish Cipher Algorithm" ) ; <START_VULN> MODULE_ALIAS ( "twofish" ) ; <END_VULN>
struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; int error ; <START_VULN> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <END_VULN> ea_idebug ( inode , "buffer = % p , buffer_size = % ld" , buffer , ( long ) buffer_size ) ;
if ( ua ) { efree ( ua ) ; } <START_VULN> } <END_VULN> } if ( user_headers ) {
char * src ; char * dest = RUN_ASOUNDRC_FILE ; <START_VULN> <END_VULN> FILE * fp = fopen ( dest , "w" ) ; if ( fp ) { fprintf ( fp , "" ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : bitrate tracking and management <START_VULN> last mod : $ Id : bitrate . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_BITRATE_H_ #define _V_BITRATE_H_ #include "vorbiscodec . h" #include "codec_internal . h"
& yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <START_VULN> " % 4d - % 2d - % 2d , % 2d : % 2d : % 2d . % 9d : % 5s ( % 127 [ A - Za - z0 - 9 : ] ) , Length : % 9u , Pro : % 9d , Off : % 9d , Pri : % 9d , RM : % 9d , Err : % 9d [ % 8x , % 8x ] " , <END_VULN> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error ,
#define free ( ptr ) hunspell_free ( ptr ) inline void * hunspell_realloc ( void * ptr , size_t size ) { HunspellReportMemoryDeallocation ( ptr ) ; void * result = moz_realloc ( ptr , size ) ; if ( result ) { HunspellReportMemoryAllocation ( result ) ; <START_VULN> } else { <END_VULN> HunspellReportMemoryAllocation ( ptr ) ; } return result ; } #define realloc ( ptr , size ) hunspell_realloc ( ptr , size ) inline char * hunspell_strdup ( const char * str )
uint32_t length ( ) const { JS_ASSERT ( hasSourceData ( ) ) ; return length_ ; } bool argumentsNotIncluded ( ) const { JS_ASSERT ( hasSourceData ( ) ) ; return argumentsNotIncluded_ ; } <START_VULN> const jschar * chars ( JSContext * cx , const SourceDataCache : : AutoSuppressPurge & asp ) ; <END_VULN> JSFlatString * substring ( JSContext * cx , uint32_t start , uint32_t stop ) ; void addSizeOfIncludingThis ( mozilla : : MallocSizeOf mallocSizeOf , JS : : ScriptSourceInfo * info ) const ; template < XDRMode mode > bool performXDR ( XDRState < mode > * xdr ) ;
} } else { if ( state - > indent ) ruby_xfree ( state - > indent ) ; <START_VULN> state - > indent = strdup ( RSTRING_PTR ( indent ) ) ; <END_VULN> state - > indent_len = len ; } return Qnil ;
static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid ) { <START_VULN> FILE * fp = fopen ( dest_filename , "w" ) ; <END_VULN> if ( ! fp ) return false ;
char buf [ 20 ] ; int ret ; uid_t uid ; cred = current_cred ( ) ; user = cred - > user ; uid = from_kuid ( cred - > user_ns , user - > uid ) ; kenter ( " % p { % u } " , user , uid ) ; <START_VULN> if ( user - > uid_keyring ) { <END_VULN> kleave ( " = 0 [ exist ] " ) ; return 0 ; } mutex_lock ( & key_user_keyring_mutex ) ; ret = 0 ; if ( ! user - > uid_keyring ) { sprintf ( buf , "_uid . % u" , uid ) ;
<START_VULN> p = BuildTestPacket ( 1 , 8183 , 0 , 'A' , 71 ) ; <END_VULN> if ( p == NULL ) goto end ;
} ; class nsDocShell final : public nsDocLoader <START_VULN> , public nsIDocShell_ESR38<END_VULN> , public nsIWebNavigation , public nsIBaseWindow , public nsIScrollable , public nsITextScroll , public nsIDocCharset , public nsIContentViewerContainer , public nsIRefreshURI , public nsIWebProgressListener
don't need to change the reference count . * new_bh = old_bh ; get_bh ( new_bh ) ; <START_VULN> ext2_xattr_cache_insert ( new_bh ) ; <END_VULN> } else { ext2_fsblk_t goal = ext2_group_first_block_no ( sb ,
} <START_VULN> CWD_API realpath_cache_bucket * realpath_cache_lookup ( const char * path , int path_len , time_t t ) <END_VULN> { return realpath_cache_find ( path , path_len , t ) ; }
atomic_t xfer_avail ; struct gpio_chip gc ; u8 * in_out_buffer ; <START_VULN> spinlock_t lock ; <END_VULN> struct gpio_desc * desc [ 8 ] ; bool gpio_poll ;
} } <START_VULN> static void follow_dotdot ( struct nameidata * nd ) <END_VULN> { if ( ! nd - > root . mnt ) set_root ( nd ) ;
} } else { #ifdef DEBUG fprintf ( stderr , "dissect_wtp : ( 4 ) tree was % p" , tree ) ; #endif } if ( fCon ) { unsigned char tCon ; unsigned char tByte ; <START_VULN> unsigned char tpiLen ; <END_VULN> tvbuff_t * tmp_tvb ; vHeader = 0 ; do { tByte = tvb_get_guint8 ( tvb , offCur + cbHeader + vHeader ) ; tCon = tByte & 0x80 ; if ( tByte & 0x04 ) tpiLen = 2 + tvb_get_guint8 ( tvb , offCur + cbHeader + vHeader + 1 ) ;
<START_VULN> blkcnt = xfs_attr3_rmt_blocks ( mp , args - > valuelen ) ; <END_VULN> error = xfs_bmap_first_unused ( args - > trans , args - > dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ; if ( error )
transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { <START_VULN> <END_VULN> if ( strpbrk ( mode , "awx+" ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP wrapper does not support writeable connections" ) ; php_url_free ( resource ) ;
struct inode ; <START_VULN> extern int parse_rock_ridge_inode ( struct iso_directory_record * , struct inode * ) ; <END_VULN> extern int get_rock_ridge_filename ( struct iso_directory_record * , char * , struct inode * ) ; extern int isofs_name_translate ( struct iso_directory_record * , char * , struct inode * ) ;
virtual bool UndoScope ( ) MOZ_OVERRIDE ; virtual void SetUndoScope ( bool aUndoScope , mozilla : : ErrorResult & aError ) MOZ_OVERRIDE ; nsresult ClearDataset ( ) ; <START_VULN> nsSize GetWidthHeightForImage ( imgIRequest * aImageRequest ) ; <END_VULN> NS_FORWARD_NSIDOMNODE_TO_NSINODE NS_FORWARD_NSIDOMELEMENT_TO_GENERIC NS_IMETHOD GetId ( nsAString & aId ) MOZ_FINAL { mozilla : : dom : : Element : : GetId ( aId ) ;
struct TypedArrayObjectStorage : AllTypedArraysBase { protected : JSObject * mObj ; <START_VULN> TypedArrayObjectStorage ( ) <END_VULN> { } TypedArrayObjectStorage ( TypedArrayObjectStorage && aOther ) : mObj ( aOther . mObj ) { aOther . mObj = nullptr ; }
} else { newmap = malloc ( sizeof ( int ) * size ) ; newrev = malloc ( sizeof ( int ) * size ) ; atable - > size = 0 ; } if ( ! newmap || ! newrev ) { if ( newmap ) atable - > amap = newmap ; if ( newrev ) <START_VULN> atable - > amap = newrev ; <END_VULN> return - 1 ; } memset ( & newmap [ atable - > size ] , 0 , ( size - atable - > size ) * sizeof ( int ) ) ; memset ( & newrev [ atable - > size ] , 0 , ( size - atable - > size ) * sizeof ( int ) ) ; atable - > amap = newmap ; atable - > arev = newrev ; atable - > size = size ; } return 0 ; }
if ( ! has_header ( s - > headers , "rRange : " ) && ! post && ( s - > off > 0 || s - > end_off || s - > seekable == - 1 ) ) { len + = av_strlcatf ( headers + len , sizeof ( headers ) - len , <START_VULN> "Range : bytes = % "PRId64" - " , s - > off ) ; <END_VULN> if ( s - > end_off ) len + = av_strlcatf ( headers + len , sizeof ( headers ) - len , " % "PRId64 , s - > end_off - 1 ) ;
phar_flush ( entry_obj - > ent . entry - > phar , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; RETURN_FALSE ; } else {
TEST_MSG ( "Expected : % zu" , exp ) ; TEST_MSG ( "Actual : % zu" , enclen ) ; } <START_VULN> declen = mutt_b64_decode ( out2 , out1 ) ; <END_VULN> if ( ! TEST_CHECK ( declen == i ) ) { TEST_MSG ( "Expected : % zu" , i ) ;
MAKE_STD_ZVAL ( http_header ) ; ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ; <START_VULN> <END_VULN> zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ; } } else {
} <START_VULN> struct inet_peer * inet_getpeer ( struct inetpeer_addr * daddr , int create ) ; <END_VULN> static inline struct inet_peer * inet_getpeer_v4 ( __be32 v4daddr , int create ) {
struct rad_handle ; <START_VULN> intrad_get_vendor_attr ( u_int32_t * , const void ** , size_t * ) ; <END_VULN> intrad_put_vendor_addr ( struct rad_handle * , int , int , struct in_addr ) ; intrad_put_vendor_attr ( struct rad_handle * , int , int , const void * , size_t ) ;
} else { for ( i = 0 ; i < s - > entries ; i ++ ) { long num = oggpack_read ( opb , 5 ) ; if ( num == - 1 ) goto _eofout ; s - > lengthlist [ i ] = num+1 ; } } <START_VULN> <END_VULN> break ; case 1 : { long length = oggpack_read ( opb , 5 ) +1 ; s - > lengthlist = _ogg_malloc ( sizeof ( * s - > lengthlist ) * s - > entries ) ; for ( i = 0 ; i < s - > entries ; ) {
long dim ; long entries ; long used_entries ; const static_codebook * c ; <START_VULN> float * valuelist ; <END_VULN> ogg_uint32_t * codelist ; int * dec_index ; char * dec_codelengths ; ogg_uint32_t * dec_firsttable ; int dec_firsttablen ; int dec_maxlength ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 103 20140502 02 : 25 : 10 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
if ( ! b_xiph ) { void * p_org = p_stream - > p_headers ; p_stream - > i_headers + = p_oggpacket - > bytes ; p_stream - > p_headers = realloc ( p_stream - > p_headers , p_stream - > i_headers ) ; if ( p_stream - > p_headers ) { memcpy ( ( unsigned char * ) p_stream - > p_headers + p_stream - > i_headers - p_oggpacket - > bytes , <START_VULN> p_oggpacket - > packet , p_stream - > i_headers ) ; <END_VULN> } else { #warning Memory leak p_stream - > i_headers = 0 ; p_stream - > p_headers = NULL ; free ( p_org ) ; } } else if ( xiph_AppendHeaders ( & p_stream - > i_headers , & p_stream - > p_headers ,
public : ObjectElements ( uint32_t capacity , uint32_t length ) <START_VULN> : capacity ( capacity ) , initializedLength ( 0 ) , length ( length ) <END_VULN> { } HeapSlot * elements ( ) { return ( HeapSlot * ) ( uintptr_t ( this ) + sizeof ( ObjectElements ) ) ; }
CRM_CHECK ( client != NULL , return TRUE ) ; CRM_CHECK ( update_msg != NULL , return TRUE ) ; <START_VULN> if ( client - > ipc == NULL ) { <END_VULN> crm_warn ( "Skipping client with NULL channel" ) ; return FALSE ; }
osa_princ_ent_rec adb ; krb5_int32 now ; kadm5_policy_ent_rec pol ; <START_VULN> int ret , last_pwd ; <END_VULN> krb5_boolean have_pol = FALSE ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ;
bodyLength = pntoh16 ( data+offset+2 ) ; <START_VULN> if ( ( tot_len - offset - 4 ) < bodyLength ) { <END_VULN> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "EAPOL body too short" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; }
CVE_2011_1495__ctl_diag_read_buffer ( void __user * arg , enum block_state state ) { struct mpt2_diag_read_buffer karg ; struct mpt2_diag_read_buffer __user * uarg = arg ; struct MPT2SAS_ADAPTER * ioc ; void * request_data , * diag_data ; Mpi2DiagBufferPostRequest_t * mpi_request ; Mpi2DiagBufferPostReply_t * mpi_reply ; int rc , i ; u8 buffer_type ; <START_VULN> unsigned long timeleft ; <END_VULN> u16 smid ; u16 ioc_status ; u8 issue_reset = 0 ; if ( copy_from_user ( & karg , arg , sizeof ( karg ) ) ) { printk ( KERN_ERR "failure at % s : % d % s ( ) ! " , __FILE__ , __LINE__ , __func__ ) ; return - EFAULT ; } if ( _ctl_verify_adapter ( karg . hdr . ioc_number , & ioc ) == - 1 || ! ioc )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : floor backend 1 implementation <START_VULN> last mod : $ Id : floor1 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
virtual mozilla : : dom : : EventTarget * GetParentTarget ( ) MOZ_OVERRIDE { return mParent ; } virtual nsIDOMWindow * GetOwnerGlobal ( ) MOZ_OVERRIDE ; NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS ( nsWindowRoot , nsIDOMEventTarget ) protected : <START_VULN> nsPIDOMWindow * mWindow ; <END_VULN> nsRefPtr < nsEventListenerManager > mListenerManager ; nsCOMPtr < nsIDOMNode > mPopupNode ; nsCOMPtr < mozilla : : dom : : EventTarget > mParent ; } ;
inline void setNextView ( ArrayBufferViewObject * view ) ; <START_VULN> void neuter ( JSContext * cx ) ; <END_VULN> static void trace ( JSTracer * trc , JSObject * obj ) ;
} <START_VULN> CWD_API void realpath_cache_del ( const char * path , int path_len ) <END_VULN> { zend_ulong key = realpath_cache_key ( path , path_len ) ; zend_ulong n = key % ( sizeof ( CWDG ( realpath_cache ) ) sizeof ( CWDG ( realpath_cache ) [ 0 ] ) ) ;
module_init ( ipip_init ) ; module_exit ( ipip_fini ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "tunl0" ) ; <END_VULN>
uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; int i , plane , vsub = desc - > log2_chroma_h ; <START_VULN> for ( plane = 0 ; plane < 4 && frame - > data [ plane ] ; plane ++ ) { <END_VULN> int64_t linesize = av_image_get_linesize ( frame - > format , frame - > width , plane ) ; uint8_t * data = frame - > data [ plane ] ; int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT ( inlink - > h , vsub ) : inlink - > h ;
static char efbuf [ 100 ] ; my_regex_t re ; <START_VULN> sprintf ( efbuf , "REG_ % s" , name ) ; <END_VULN> assert ( strlen ( efbuf ) < sizeof ( efbuf ) ) ; re . re_endp = efbuf ; ( void ) my_regerror ( REG_ATOI , & re , efbuf , sizeof ( efbuf ) ) ;
h - > is_streamed = 0 ; } else if ( ! av_strcasecmp ( tag , "Transfer - Encoding" ) && ! av_strncasecmp ( p , "chunked" , 7 ) ) { <START_VULN> s - > filesize = - 1 ; <END_VULN> s - > chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , "WWW - Authenticate" ) ) { ff_http_auth_handle_header ( & s - > auth_state , tag , p ) ;
} if ( ! dump ) return CL_CLEAN ; <START_VULN> cli_dbgmsg ( "cli_pdf : dumping obj % u % u" , obj - > id >> 8 , obj - > id ) ; <END_VULN> snprintf ( fullname , sizeof ( fullname ) , " % s"PATHSEP"pdf % 02u" , pdf - > dir , pdf - > files ++ ) ; fout = open ( fullname , O_RDWR | O_CREAT | O_EXCL | O_TRUNC | O_BINARY , 0600 ) ; if ( fout < 0 ) {
void test_base64_decode ( void ) { char buffer [ 16 ] ; <START_VULN> int len = mutt_b64_decode ( buffer , encoded ) ; <END_VULN> if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) { TEST_MSG ( "Expected : % zu" , sizeof ( clear ) - 1 ) ;
mutt_str_strfcpy ( buf , "mailboxes "" , sizeof ( buf ) ) ; mutt_account_tourl ( & idata - > conn - > account , & url ) ; <START_VULN> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <END_VULN> url . path = errstr + 1 ; url . path [ strlen ( url . path ) - 1 ] = '0' ; if ( mutt_str_strcmp ( url . user , ImapUser ) == 0 )
{ void * pointer ; <START_VULN> if ( ! handle ) <END_VULN> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle - > dwUpper ) ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "Kernel Random Number Generator" ) ; <START_VULN> MODULE_ALIAS ( "stdrng" ) ; <END_VULN>
MODULE_PARM_DESC ( dbg , "Boolean to enable debugging ( 01 == offon ) " ) ; module_init ( prng_mod_init ) ; module_exit ( prng_mod_fini ) ; <START_VULN> MODULE_ALIAS ( "stdrng" ) ; <END_VULN>
char * result ; if ( len <= 0 ) return NULL ; result = ALLOC_N ( char , len ) ; <START_VULN> memccpy ( result , ptr , 0 , len ) ; <END_VULN> return result ; }
} } while ( base_was_tested ) ; mpz_init_set ( tested [ i ] , a ) ; <START_VULN> mpz_powm ( z , a , m , n ) ; <END_VULN> if ( ( mpz_cmp_ui ( z , 1 ) == 0 ) || ( mpz_cmp ( z , n_1 ) == 0 ) ) continue ; composite = 1 ;
c - > interfaces_offset < bin - > header . data_offset + bin - > header . data_size ) { p = r_buf_get_at ( binfile - > buf , c - > interfaces_offset , NULL ) ; <START_VULN> int types_list_size = r_read_le32 ( p ) ; <END_VULN> if ( types_list_size < 0 || types_list_size >= bin - > header . types_size ) { return ; }
const wbxml_decoding * map ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; <START_VULN> guint32 off = offset ; <END_VULN> guint32 len ; guint str_len ; guint32 ent ;
public : bool init ( uint32_t id , uint32_t offset , uint32_t numSuccessors ) { id_ = id ; offset_ = offset ; numSuccessors_ = numSuccessors ; if ( numSuccessors ) { <START_VULN> successors_ = ( uint32_t * ) js_calloc ( numSuccessors * sizeof ( uint32_t ) ) ; <END_VULN> if ( ! successors_ ) return false ; } return true ; } void destroy ( ) { js_free ( successors_ ) ;
static JS_ALWAYS_INLINE REMatchState * CVE_2011_2998_ExecuteREBytecode ( REGlobalData * gData , REMatchState * x ) { REMatchState * result = NULL ; REBackTrackData * backTrackData ; jsbytecode * nextpc , * testpc ; REOp nextop ; RECapture * cap ; <START_VULN> REProgState * curState ; <END_VULN> const jschar * startcp ; size_t parenIndex , k ; size_t parenSoFar = 0 ; jschar matchCh1 , matchCh2 ; RECharSet * charSet ; JSBool anchor ; jsbytecode * pc = gData - > regexp - > program ; REOp op = ( REOp ) * pc ++ ;
<START_VULN> void ip_options_build ( struct sk_buff * skb , struct ip_options * opt , <END_VULN> __be32 daddr , struct rtable * rt , int is_frag ) { unsigned char * iph = skb_network_header ( skb ) ;
struct hlist_node node ; struct user_namespace * ns ; kuid_t uid ; <START_VULN> atomic_t count ; <END_VULN> atomic_t ucount [ UCOUNT_COUNTS ] ; } ;
if ( ( sess != NULL ) && ( s - > enc_read_ctx != NULL ) && <START_VULN> ( EVP_MD_CTX_md ( s - > read_hash ) != NULL ) && ! SSL_USE_ETM ( s ) ) { <END_VULN> unsigned char * mac = NULL ; unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ;
1 , - 533200896 , 1611661312 , 4 , 0 , partial_quantlist1 , NULL , NULL , NULL , 0 } ; static float test4_result [ ] = { - 3 , - 3 , - 3 , 4 , - 3 , - 3 , - 1 , - 3 , - 3 , - 3 , 4 , - 3 , 4 , 4 , - 3 , - 1 , 4 , - 3 , <START_VULN> - 3 , - 1 , - 3 , 4 , - 1 , - 3 , - 1 , - 1 , - 3 , <END_VULN> - 3 , - 3 , 4 , 4 , - 3 , 4 , - 1 , - 3 , 4 , - 3 , 4 , 4 , 4 , 4 , 4 , - 1 , 4 , 4 , - 3 , - 1 , 4 , 4 , - 1 , 4 , - 1 , - 1 , 4 , - 3 , - 3 , - 1 , 4 , - 3 , - 1 , - 1 , - 3 , - 1 , - 3 , 4 , - 1 , 4 , 4 , - 1 , - 1 , 4 , - 1 , - 3 , - 1 , - 1 , 4 , - 1 , - 1 , - 1 , - 1 , - 1 } ;
if ( plugin_data ) { mnd_efree ( plugin_data ) ; } <START_VULN> <END_VULN> if ( ret == PASS ) { DBG_INF_FMT ( "saving requested_protocol = % s" , requested_protocol ) ; conn - > m - > set_client_option ( conn , MYSQLND_OPT_AUTH_PROTOCOL , requested_protocol TSRMLS_CC ) ;
} if ( need_dev ) { <START_VULN> if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) { <END_VULN> error = - ENOENT ; goto out ; }
shader - > DecrementAttachCount ( ) ; return PR_TRUE ; } return PR_FALSE ; } PRBool HasAttachedShaderOfType ( GLenum shaderType ) { for ( PRUint32 i = 0 ; i < mAttachedShaders . Length ( ) ; ++ i ) { <START_VULN> if ( mAttachedShaders [ i ] - > ShaderType ( ) == shaderType ) { <END_VULN> return PR_TRUE ; } } return PR_FALSE ; } PRBool HasBothShaderTypesAttached ( ) { return
offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb - > len - offset , 0 ) ; offset + = skb - > csum_offset ; * ( __sum16 * ) ( skb - > data + offset ) = csum_fold ( csum ) ; skb - > ip_summed = CHECKSUM_NONE ; tnl_hlen = skb_tnl_header_len ( skb ) ; <START_VULN> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <END_VULN> if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : PCM data envelope analysis <START_VULN> last mod : $ Id : envelope . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < stdio . h > #include < math . h > #include < oggogg . h >
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic codebook packunpackcodedecode operations <START_VULN> last mod : $ Id : codebook . c 16227 2009 - 07 - 08 06 : 58 : 46Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi - > ops - > drive_status ( cdi , CDSL_CURRENT ) ; <START_VULN> if ( ( ( int ) arg >= cdi - > capacity ) ) <END_VULN> return - EINVAL ; return cdrom_slot_status ( cdi , arg ) ; }
} else { num_items_scanned = sscanf ( line , <START_VULN> " % 5s ( % 127 [ A - Za - z0 - 9 : ] ) , Length : % 9u , Pro : % 9d , Off : % 9d , Pri : % 9d , RM : % 9d , Err : % 9d [ % 8x , % 8x ] " , <END_VULN> direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;
unsigned long end , long adjust_next ) { <START_VULN> if ( ! vma - > anon_vma || vma - > vm_ops || vma - > vm_file ) <END_VULN> return ; __vma_adjust_trans_huge ( vma , start , end , adjust_next ) ; }
int vorbis_synthesis_pcmout ( vorbis_dsp_state * v , float ** * pcm ) { vorbis_info * vi = v - > vi ; if ( v - > pcm_returned > - 1 && v - > pcm_returned < v - > pcm_current ) { if ( pcm ) { int i ; for ( i = 0 ; i < vi - > channels ; i ++ ) <START_VULN> v - > pcmret [ i ] = v - > pcm [ i ] +v - > pcm_returned ; <END_VULN> * pcm = v - > pcmret ; } return ( v - > pcm_current - v - > pcm_returned ) ; } return ( 0 ) ; } int vorbis_synthesis_read ( vorbis_dsp_state * v , int n ) {
bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image - > columns ; <START_VULN> length = image - > rows * ( bytes_per_line+image - > columns % 2 ) ; <END_VULN> if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image - > rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) )
return - EBUSY ; } <START_VULN> chip - > data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ; <END_VULN> if ( chip - > data_buffer == NULL ) { clear_bit ( 0 , & chip - > is_open ) ; put_device ( chip - > dev ) ;
MODULE_DESCRIPTION ( "Serpent Cipher Algorithm , AVX optimized" ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "serpent" ) ; <END_VULN>
rec_hdr . hdr . ts_sec = ( guint32 ) phdr - > ts . secs ; if ( wdh - > tsprecision == WTAP_FILE_TSPREC_NSEC ) { rec_hdr . hdr . ts_usec = phdr - > ts . nsecs ; } else { rec_hdr . hdr . ts_usec = phdr - > ts . nsecs 1000 ; } rec_hdr . hdr . incl_len = phdr - > caplen + phdrsize ; rec_hdr . hdr . orig_len = phdr - > len + phdrsize ; <START_VULN> if ( rec_hdr . hdr . incl_len > WTAP_MAX_PACKET_SIZE || rec_hdr . hdr . orig_len > WTAP_MAX_PACKET_SIZE ) { <END_VULN> * err = WTAP_ERR_BAD_FILE ; return FALSE ; } switch ( wdh - > file_type ) { case WTAP_FILE_PCAP : case WTAP_FILE_PCAP_NSEC : hdr_size = sizeof ( struct pcaprec_hdr ) ; break ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "Salsa20 stream cipher algorithm" ) ; <START_VULN> MODULE_ALIAS ( "salsa20" ) ; <END_VULN>
cap . descr_num = 16 ; cap . descr_type = CA_ECD ; memcpy ( parg , & cap , sizeof ( cap ) ) ; break ; } case CA_GET_SLOT_INFO : { ca_slot_info_t * info = ( ca_slot_info_t * ) parg ; <START_VULN> if ( info - > num > 1 ) <END_VULN> return - EINVAL ; av7110 - > ci_slot [ info - > num ] . num = info - > num ; av7110 - > ci_slot [ info - > num ] . type = FW_CI_LL_SUPPORT ( av7110 - > arm_app ) ? CA_CI_LINK : CA_CI ; memcpy ( info , & av7110 - > ci_slot [ info - > num ] , sizeof ( ca_slot_info_t ) ) ; break ; } case CA_GET_MSG : break ;
ip : iph = __skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , data , hlen , & _iph ) ; if ( ! iph || iph - > ihl < 5 ) <START_VULN> return false ; <END_VULN> nhoff + = iph - > ihl * 4 ; ip_proto = iph - > protocol ;
nfca_poll - > sens_res = __le16_to_cpu ( * ( ( __u16 * ) data ) ) ; data + = 2 ; <START_VULN> nfca_poll - > nfcid1_len = * data ++ ; <END_VULN> pr_debug ( "sens_res 0x % x , nfcid1_len % d" , nfca_poll - > sens_res , nfca_poll - > nfcid1_len ) ;
JSObject ** aRetval ) ; nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <START_VULN> unsigned char * aData , uint32_t aDataLen , <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , int32_t dirtyWidth , int32_t dirtyHeight ) ;
int ret = 0 ; ve - > stretch ++ ; if ( ve - > stretch > VE_MAXSTRETCH * 2 ) ve - > stretch = VE_MAXSTRETCH * 2 ; for ( i = 0 ; i < ve - > ch ; i ++ ) { float * pcm = v - > pcm [ i ] +ve - > searchstep * ( j ) ; <START_VULN> ret |= _ve_amp ( ve , gi , pcm , ve - > band , ve - > filter+i * VE_BANDS , j ) ; <END_VULN> } ve - > mark [ j+VE_POST ] = 0 ; if ( ret & 1 ) { ve - > mark [ j ] = 1 ; ve - > mark [ j+1 ] = 1 ; }
if ( ! p - > leave_spinning ) btrfs_set_path_blocking ( p ) ; <START_VULN> if ( ret < 0 ) <END_VULN> btrfs_release_path ( p ) ; return ret ; }
int badop = 0 , bugs = 0 ; int ret = 1 ; int off = 0 ; <START_VULN> int no_tmp_rsa = 0 , nocert = 0 ; <END_VULN> int state = 0 ; SSL_METHOD * meth = NULL ; #ifndef NO_DH
MODULE_DESCRIPTION ( "Cast6 Cipher Algorithm , AVX optimized" ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "cast6" ) ; <END_VULN>
rcu_read_unlock ( ) ; } <START_VULN> static void timerfd_remove_cancel ( struct timerfd_ctx * ctx ) <END_VULN> { if ( ctx - > might_cancel ) { ctx - > might_cancel = false ;
if ( ! ( plen <= * len ) ) printf ( "PLEN % d type % d len % d" , plen , nh . nh_type , * len ) ; <START_VULN> assert ( plen <= * len ) ; <END_VULN> * len = plen ; if ( ( * len ) && ( net_read_exact ( s , arg , * len ) == - 1 ) )
lblkno = args - > rmtblkno ; blkcnt = args - > rmtblkcnt ; <START_VULN> valuelen = args - > valuelen ; <END_VULN> while ( valuelen > 0 ) { struct xfs_buf * bp ; xfs_daddr_tdblkno ;
out1 [ 0 ] = '0' ; <START_VULN> declen = mutt_b64_decode ( out2 , out1 ) ; <END_VULN> if ( ! TEST_CHECK ( declen == - 1 ) ) { TEST_MSG ( "Expected : % zu" , - 1 ) ;
typedef void vorbis_info_residue ; typedef void vorbis_info_mapping ; #include "psy . h" #include "bitrate . h" typedef struct private_state { <START_VULN> envelope_lookup * ve ; <END_VULN> int window [ 2 ] ; vorbis_look_transform ** transform [ 2 ] ; drft_lookup fft_look [ 2 ] ; int modebits ; vorbis_look_floor ** flr ; vorbis_look_residue ** residue ; vorbis_look_psy * psy ;
bool mFullScreen ; void * mJavaView ; #endif nsPluginNativeWindow * mPluginWindow ; nsRefPtr < nsNPAPIPluginInstance > mInstance ; nsObjectFrame * mObjectFrame ; <START_VULN> nsIContent * mContent ; <END_VULN> nsCString mDocumentBase ; bool mWidgetCreationComplete ; nsCOMPtr < nsIWidget > mWidget ; nsRefPtr < nsPluginHost > mPluginHost ; #ifdef XP_MACOSX NP_CGContext mCGPluginPortCopy ; int32_t mInCGPaintLevel ;
. index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , <START_VULN> . match_data . cmp = user_match , <END_VULN> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ;
Com_Printf ( " -- -- - Initializing Renderer -- -- " ) ; #ifdef USE_RENDERER_DLOPEN <START_VULN> cl_renderer = Cvar_Get ( "cl_renderer" , "opengl2" , CVAR_ARCHIVE | CVAR_LATCH ) ; <END_VULN> Com_sprintf ( dllName , sizeof ( dllName ) , "renderer_ % s_" ARCH_STRING DLL_EXT , cl_renderer - > string ) ;
u32 eb ; eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) | <START_VULN> ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ; <END_VULN> if ( ( vcpu - > guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) )
gss_cred_usage_t , gss_OID_set * ) ; static void release_spnego_ctx ( spnego_gss_ctx_id_t * ) ; static void check_spnego_options ( spnego_gss_ctx_id_t ) ; <START_VULN> static spnego_gss_ctx_id_t create_spnego_ctx ( void ) ; <END_VULN> static int put_mech_set ( gss_OID_set mechSet , gss_buffer_t buf ) ; static int put_input_token ( unsigned char ** , gss_buffer_t , unsigned int ) ; static int put_mech_oid ( unsigned char ** , gss_OID_const , unsigned int ) ;
for ( bit = find_first_bit ( & bm - > word , bm - > depth ) ; bit < bm - > depth ; bit = find_next_bit ( & bm - > word , bm - > depth , bit + 1 ) ) { <START_VULN> rq = blk_mq_tag_to_rq ( hctx - > tags , off + bit ) ; <END_VULN> if ( rq - > q == hctx - > queue ) fn ( hctx , rq , data , reserved ) ; }
unregister_inetaddr_notifier ( & sctp_inetaddr_notifier ) ; } <START_VULN> static int __net_init sctp_net_init ( struct net * net ) <END_VULN> { int status ;
mutt_debug ( 1 , "#2 Error receiving server response . " ) ; goto bail ; } <START_VULN> request_buf . length = mutt_b64_decode ( buf2 , idata - > buf + 2 ) ; <END_VULN> request_buf . value = buf2 ; maj_stat = gss_unwrap ( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ;
Compatible Regular Expression library . It defines the things POSIX says should be there . I hope . <START_VULN> Copyright ( c ) 1997 - 2007 University of Cambridge<END_VULN> -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - Redistribution and use in source and binary forms , with or without
for ( x = 0 ; x < hdr - > width ; x ++ ) { while ( nz < hdr - > depth ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { <START_VULN> return - 1 ; <END_VULN> } z = ( z << 8 ) | c ; nz + = 8 ;
char * fn = rpmfilesFN ( files , firsthardlink ) ; <START_VULN> rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ; <END_VULN> firsthardlink = - 1 ; free ( fn ) ; }
{ zval * retval_ptr ; zval ** args [ 1 ] ; <START_VULN> zval * subpats ; <END_VULN> int result_len ; int i ;
#else <START_VULN> static inline zend_ulong realpath_cache_key ( const char * path , int path_len ) <END_VULN> { register zend_ulong h ; const char * e = path + path_len ;
i = 0 ; if ( info - > attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { nla_for_each_nested ( attr , info - > attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { if ( request - > ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request - > ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <START_VULN> request - > ssids [ i ] . ssid_len = nla_len ( attr ) ; <END_VULN> i ++ ; } }
} and 40 , replicate the 100dB curve to 110 * for ( j = 0 ; j < 6 ; j ++ ) memcpy ( workc [ i ] [ j+2 ] , tonemasks [ i ] [ j ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ j ] ) ) ; memcpy ( workc [ i ] [ 0 ] , tonemasks [ i ] [ 0 ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ 0 ] ) ) ; memcpy ( workc [ i ] [ 1 ] , tonemasks [ i ] [ 0 ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ 0 ] ) ) ; <START_VULN> <END_VULN> for ( j = 0 ; j < P_LEVELS ; j ++ ) { for ( k = 0 ; k < EHMER_MAX ; k ++ ) { float adj = center_boost+abs ( EHMER_OFFSET - k ) * center_decay_rate ; if ( adj < 0 . && center_boost > 0 ) adj = 0 . ; if ( adj > 0 . && center_boost < 0 ) adj = 0 . ; workc [ i ] [ j ] [ k ] + = adj ; }
ret = buf [ 1 ] ; exit : <START_VULN> spin_unlock_irqrestore ( & dev - > lock , flags ) ; <END_VULN> return ret ; }
if ( argc < 2 || ! WriteStatusFailure ( argv [ 1 ] , SERVICE_NOT_ENOUGH_COMMAND_LINE_ARGS ) ) { LOG_WARN ( ( "Could not write update . status service update failure . ( % d ) " , GetLastError ( ) ) ) ; } return FALSE ; } <START_VULN> WCHAR installDir [ MAX_PATH ] = { L'0' } ; <END_VULN> if ( ! GetInstallationDir ( argc , argv , installDir ) ) { LOG_WARN ( ( "Could not get the installation directory" ) ) ; if ( ! WriteStatusFailure ( argv [ 1 ] , SERVICE_INSTALLDIR_ERROR ) ) { LOG_WARN ( ( "Could not write update . status for GetInstallationDir failure . " ) ) ; } return FALSE ; }
if ( opt_count ) { <START_VULN> sprintf ( query , "select count ( * ) from ` % s`" , table ) ; <END_VULN> if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , " % s : Cannot get record count for db : % s , table : % s : % s" ,
ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; <START_VULN> return ret != - EEXIST ? ret : 0 ; <END_VULN> } return commit_creds ( new ) ; } int install_session_keyring_to_cred ( struct cred * cred , struct key * keyring ) {
out_cleanup : ovl_cleanup ( wdir , newdentry ) ; <START_VULN> goto out ; <END_VULN> }
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : softmagic . c , v 1 . 187 20140513 16 : 42 : 17 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; lock_sock ( sk ) ; switch ( optname ) { case TCP_MAXSEG : <START_VULN> if ( val < 8 || val > MAX_TCP_WINDOW ) { <END_VULN> err = - EINVAL ; break ; } tp - > rx_opt . user_mss = val ; break ; case TCP_NODELAY : if ( val ) { tp - > nonagle |= TCP_NAGLE_OFF | TCP_NAGLE_PUSH ;
* s = '' ; } } <START_VULN> s [ 1 ] = '0' ; <END_VULN> if ( resource - > path && * ( resource - > path ) == '' && * ( resource - > path + 1 ) == '0' ) { snprintf ( loc_path , sizeof ( loc_path ) - 1 , " % s % s" , resource - > path , location ) ; } else {
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 60 20140521 13 : 04 : 38 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
#ifndef imgStatusTracker_h__ #define imgStatusTracker_h__ class imgDecoderObserver ; class imgIContainer ; <START_VULN> class imgRequestProxy ; <END_VULN> class imgStatusNotifyRunnable ; class imgRequestNotifyRunnable ; class imgStatusTrackerObserver ; class imgStatusTrackerNotifyingObserver ; class nsIRunnable ; #include "mozillaRefPtr . h" #include "nsCOMPtr . h" #include "nsTObserverArray . h" #include "nsRect . h" namespace mozilla { namespace image { class Image ; struct ImageStatusDiff {
static inline void set_pte_at ( struct mm_struct * mm , unsigned long addr , pte_t * ptep , pte_t pte ) { <START_VULN> if ( pte_valid_ng ( pte ) ) { <END_VULN> if ( ! pte_special ( pte ) && pte_exec ( pte ) ) __sync_icache_dcache ( pte , addr ) ; if ( pte_dirty ( pte ) && pte_write ( pte ) )
static int CVE_2008_3915_init_state ( struct posix_acl_state * state , int cnt ) { int alloc ; memset ( state , 0 , sizeof ( struct posix_acl_state ) ) ; state - > empty = 1 ; alloc = sizeof ( struct posix_ace_state_array ) <START_VULN> + cnt * sizeof ( struct posix_ace_state ) ; <END_VULN> state - > users = kzalloc ( alloc , GFP_KERNEL ) ; if ( ! state - > users ) return - ENOMEM ; state - > groups = kzalloc ( alloc , GFP_KERNEL ) ; if ( ! state - > groups ) { kfree ( state - > users ) ; return - ENOMEM ; } return 0 ; }
_preextrapolate_helper ( v ) ; [ at least ] a few full blocks of zeroes at the end . * <START_VULN> vorbis_analysis_buffer ( v , ci - > blocksizes [ 1 ] * 3 ) ; <END_VULN> v - > eofflag = v - > pcm_current ; v - > pcm_current+ = ci - > blocksizes [ 1 ] * 3 ; for ( i = 0 ; i < vi - > channels ; i ++ ) { if ( v - > eofflag > order * 2 ) { long n ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "GHASH Message Digest Algorithm" ) ; <START_VULN> MODULE_ALIAS ( "ghash" ) ; <END_VULN>
fn = fib6_add_1 ( root , & rt - > rt6i_dst . addr , rt - > rt6i_dst . plen , offsetof ( struct rt6_info , rt6i_dst ) , allow_create , replace_required ) ; <START_VULN> <END_VULN> if ( IS_ERR ( fn ) ) { err = PTR_ERR ( fn ) ; goto out ; }
msg [ 0 ] - > msg_style == PAM_PROMPT_ECHO_ON ) ) { * resp = malloc ( sizeof ( struct pam_response ) ) ; assert ( * resp ) ; <START_VULN> ( * resp ) - > resp = calloc ( 1024 , 0 ) ; <END_VULN> struct termios termios = old_termios ; if ( msg [ 0 ] - > msg_style == PAM_PROMPT_ECHO_OFF ) { termios . c_lflag &= ~ ( ECHO | ECHONL ) ;
new - > ns = ns ; new - > uid = uid ; <START_VULN> atomic_set ( & new - > count , 0 ) ; <END_VULN> spin_lock_irq ( & ucounts_lock ) ; ucounts = find_ucounts ( ns , uid , hashent ) ;
e_hash - pointer to int for returning extracted checksum algorithm . returns - CL_FORMAT , CL_SUCCESS , CL_BREAK . CL_BREAK indicates no more < data > < ea > element . <START_VULN> static int xar_get_toc_data_values ( xmlTextReaderPtr reader , long * length , long * offset , long * size , int * encoding , <END_VULN> unsigned char ** a_cksum , int * a_hash , unsigned char ** e_cksum , int * e_hash ) { const xmlChar * name ;
} sem_lock_and_putref ( sma ) ; if ( sma - > sem_perm . deleted ) { <START_VULN> sem_unlock ( sma ) ; <END_VULN> err = - EIDRM ; goto out_free ; }
#ifdef ZEND_WIN32 <START_VULN> static inline zend_ulong realpath_cache_key ( const char * path , int path_len ) <END_VULN> { register zend_ulong h ; char * bucket_key_start = tsrm_win32_get_path_sid_key ( path ) ;
#include < linuxbuffer_head . h > #include < linuxinit . h > #include < linuxslab . h > <START_VULN> #include < linuxmbcache . h > <END_VULN> #include < linuxquotaops . h > #include < linuxrwsem . h > #include < linuxsecurity . h >
umount_mnt ( p ) ; } } <START_VULN> else umount_tree ( mnt , 0 ) ; <END_VULN> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ;
* #ifdef DEBUG <START_VULN> static const char CVS_ID [ ] = "@ ( # ) $ RCSfile : certdata . c , v $ $ Revision : 1 . 67 $ $ Date : 20100408 14 : 28 : 58 $ "" ; @ ( # ) $ RCSfile : certdata . c , v $ $ Revision : 1 . 67 $ $ Date : 20100408 14 : 28 : 58 $ " ; <END_VULN> #endif #ifndef BUILTINS_H #include "builtins . h" #endif static const CK_BBOOL ck_false = CK_FALSE ; static const CK_BBOOL ck_true = CK_TRUE ;
cdf_unpack_summary_info ( const cdf_stream_t * sst , const cdf_header_t * h , cdf_summary_info_header_t * ssi , cdf_property_info_t ** info , size_t * count ) { <START_VULN> size_t i , maxcount ; <END_VULN> const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst - > sst_tab ) ; const cdf_section_declaration_t * sd =
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : softmagic . c , v 1 . 195 20140924 19 : 49 : 07 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
UTF16_BIG_ENDIAN } ; <START_VULN> <END_VULN> extern int register_nls ( struct nls_table * ) ; extern int unregister_nls ( struct nls_table * ) ; extern struct nls_table * load_nls ( char * ) ;
void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key - > description ) ; <START_VULN> if ( key_is_instantiated ( key ) ) <END_VULN> seq_printf ( m , " : % u" , key - > datalen ) ; }
matched = 0 ; PCRE_G ( error_code ) = PHP_PCRE_NO_ERROR ; <START_VULN> <END_VULN> do { count = pcre_exec ( pce - > re , extra , subject , subject_len , start_offset ,
tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph - > doff * 4 ; <START_VULN> if ( len < tcp_hdrlen ) <END_VULN> return - 1 ; if ( info - > mss == XT_TCPMSS_CLAMP_PMTU ) {
. fsync = ubifs_fsync , . unlocked_ioctl = ubifs_ioctl , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> #ifdef CONFIG_COMPAT . compat_ioctl = ubifs_compat_ioctl , #endif
size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <START_VULN> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <END_VULN> unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ;
skip_bits_long ( & s - > gb , offset ) ; } <START_VULN> if ( ! nblocks || nblocks > INT_MAX ) { <END_VULN> av_log ( avctx , AV_LOG_ERROR , "Invalid sample count : % "PRIu32" . " , nblocks ) ; return AVERROR_INVALIDDATA ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : toplevel libogg include <START_VULN> last mod : $ Id : ogg . h 16051 2009 - 05 - 27 05 : 00 : 06Z xiphmont $ <END_VULN> #ifndef _OGG_H #define _OGG_H #ifdef __cplusplus extern "C" { #endif
if ( get_vmx_mem_address ( vcpu , exit_qualification , vmx_instruction_info , true , & vmcs_gva ) ) return 1 ; <START_VULN> <END_VULN> if ( kvm_write_guest_virt_system ( & vcpu - > arch . emulate_ctxt , vmcs_gva , ( void * ) & to_vmx ( vcpu ) - > nested . current_vmptr , sizeof ( u64 ) , & e ) ) {
e . endian = d [ 0 ] == 'I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG ; <START_VULN> ifd = iw_get_ui32_e ( & d [ 4 ] , e . endian ) ; <END_VULN> iwjpeg_scan_exif_ifd ( rctx , & e , ifd ) ; }
#ifndef MODULE_MAGIC_NUMBER_MAJOR #define MODULE_MAGIC_NUMBER_MAJOR 20150222 #endif <START_VULN> #define MODULE_MAGIC_NUMBER_MINOR 2<END_VULN> AP_DECLARE ( int ) ap_some_auth_required ( request_rec * r ) ;
void CVE_2011_3003_CopySubDataIfElementArray ( GLuint byteOffset , GLuint byteLength , const void * data ) { <START_VULN> if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER ) { <END_VULN> memcpy ( ( void * ) ( size_t ( mData ) +byteOffset ) , data , byteLength ) ; } }
if ( skb - > protocol == htons ( ETH_P_IP ) ) return tcp_v4_do_rcv ( sk , skb ) ; <START_VULN> if ( sk_filter ( sk , skb ) ) <END_VULN> goto discard ;
struct sock * sk , int tstype ) { struct sk_buff * skb ; <START_VULN> bool tsonly ; <END_VULN> if ( ! sk ) return ;
} ret = 1 ; <START_VULN> if ( ! SSL_USE_ETM ( s ) && EVP_MD_CTX_md ( s - > read_hash ) != NULL ) <END_VULN> mac_size = EVP_MD_CTX_size ( s - > read_hash ) ; if ( ( bs != 1 ) && ! send ) { int tmpret ;
continue ; timer - > it . cpu . expires + = incr ; <START_VULN> timer - > it_overrun + = 1 << i ; <END_VULN> delta -= incr ; } }
1 , - 533200896 , 1611661312 , 4 , 1 , partial_quantlist1 , NULL , NULL , NULL , 0 } ; static float test5_result [ ] = { - 3 , - 6 , - 9 , 4 , 1 , - 2 , - 1 , - 4 , - 7 , - 3 , 1 , - 2 , 4 , 8 , 5 , - 1 , 3 , 0 , <START_VULN> - 3 , - 4 , - 7 , 4 , 3 , 0 , - 1 , - 2 , - 5 , <END_VULN> - 3 , - 6 , - 2 , 4 , 1 , 5 , - 1 , - 4 , 0 , - 3 , 1 , 5 , 4 , 8 , 12 , - 1 , 3 , 7 , - 3 , - 4 , 0 , 4 , 3 , 7 , - 1 , - 2 , 2 , - 3 , - 6 , - 7 , 4 , 1 , 0 , - 1 , - 4 , - 5 , - 3 , 1 , 0 , 4 , 8 , 7 , - 1 , 3 , 2 , - 3 , - 4 , - 5 , 4 , 3 , 2 , - 1 , - 2 , - 3 } ; void run_test ( static_codebook * b , float * comp ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis codec headers <START_VULN> last mod : $ Id : codec_internal . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_CODECI_H_ #define _V_CODECI_H_ #include "envelope . h" #include "codebook . h"
static int CVE_2010_3875_ax25_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) { struct full_sockaddr_ax25 * fsa = ( struct full_sockaddr_ax25 * ) uaddr ; struct sock * sk = sock - > sk ; unsigned char ndigi , i ; ax25_cb * ax25 ; int err = 0 ; lock_sock ( sk ) ; ax25 = ax25_sk ( sk ) ; if ( peer != 0 ) { if ( sk - > sk_state != TCP_ESTABLISHED ) { err = - ENOTCONN ; goto out ; } fsa - > fsa_ax25 . sax25_family = AF_AX25 ; fsa - > fsa_ax25 . sax25_call = ax25 - > dest_addr ; <START_VULN> fsa - > fsa_ax25 . sax25_ndigis = 0 ; <END_VULN> if ( ax25 - > digipeat != NULL ) { ndigi = ax25 - > digipeat - > ndigi ; fsa - > fsa_ax25 . sax25_ndigis = ndigi ; for ( i = 0 ; i < ndigi ; i ++ ) fsa - > fsa_digipeater [ i ] = ax25 - > digipeat - > calls [ i ] ; } } else { fsa - > fsa_ax25 . sax25_family = AF_AX25 ;
tmp - > dev = skb - > dev ; memcpy ( skb_put ( tmp , hdrlen ) , skb - > data , hdrlen ) ; memcpy ( skb_put ( tmp , fraglen ) , skb - > data + pos , fraglen ) ; pos + = fraglen ; } <START_VULN> skb - > len = hdrlen + per_fragm ; <END_VULN> return 0 ; }
return ; } <START_VULN> it = item_get ( key , nkey , c , DO_UPDATE ) ; <END_VULN> if ( settings . detail_enabled ) { stats_prefix_record_get ( key , nkey , NULL != it ) ; }
JSTokenStream * ts ; JSPrincipals * principals ; jschar * collected_args , * cp ; <START_VULN> size_t arg_length , args_length ; <END_VULN> JSTokenType tt ; JSBool ok ;
u_int8_t type , old_state , new_state ; enum ct_dccp_roles role ; <START_VULN> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <END_VULN> BUG_ON ( dh == NULL ) ; type = dh - > dccph_type ;
} } <START_VULN> if ( ! eof ) { <END_VULN> memmove ( vars - > str . c , vars - > ptr , vars - > str . len = vars - > end - vars - > ptr ) ; } return SUCCESS ;
synchronize_rcu ( ) ; <START_VULN> <END_VULN> mutex_unlock ( & memcg - > thresholds_lock ) ; }
vb - > pcm = _vorbis_block_alloc ( vb , sizeof ( * vb - > pcm ) * vi - > channels ) ; for ( i = 0 ; i < vi - > channels ; i ++ ) vb - > pcm [ i ] = _vorbis_block_alloc ( vb , vb - > pcmend * sizeof ( * vb - > pcm [ i ] ) ) ; type = ci - > map_type [ ci - > mode_param [ mode ] - > mapping ] ; return ( _mapping_P [ type ] - > inverse ( vb , ci - > map_param [ ci - > mode_param [ mode ] - > <START_VULN> mapping ] ) ) ; <END_VULN> } int vorbis_synthesis_trackonly ( vorbis_block * vb , ogg_packet * op ) { vorbis_dsp_state * vd = vb - > vd ; private_state * b = vd - > backend_state ; vorbis_info * vi = vd - > vi ;
* ++ p2 = 0 ; if ( hdr ) * hdr = atom ; if ( val ) * val = p ; <START_VULN> SetHeader ( atom , nsDependentCString ( p , p2 - p ) , PR_TRUE ) ; <END_VULN> }
( sbi - > s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { ext4_msg ( sb , KERN_ERR , "Journal does not support " "requested data journaling mode" ) ; <START_VULN> goto failed_mount4 ; <END_VULN> } default : break ;
++ vcpu - > stat . insn_emulation_fail ; trace_kvm_emulate_insn_failed ( vcpu ) ; <START_VULN> if ( ! is_guest_mode ( vcpu ) ) { <END_VULN> vcpu - > run - > exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu - > run - > internal . suberror = KVM_INTERNAL_ERROR_EMULATION ; vcpu - > run - > internal . ndata = 0 ;
<START_VULN> image - > alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : <END_VULN> UndefinedPixelTrait ; image - > storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;
0 . 9999979185F , 0 . 9999982507F , 0 . 9999985414F , 0 . 9999987944F , 0 . 9999990129F , 0 . 9999992003F , 0 . 9999993596F , 0 . 9999994939F , 0 . 9999996059F , 0 . 9999996981F , 0 . 9999997732F , 0 . 9999998333F , 0 . 9999998805F , 0 . 9999999170F , 0 . 9999999444F , 0 . 9999999643F , 0 . 9999999784F , 0 . 9999999878F , 0 . 9999999937F , 0 . 9999999972F , 0 . 9999999990F , 0 . 9999999997F , 1 . 0000000000F , 1 . 0000000000F , } ; <START_VULN> static float vwin4096 [ 2048 ] = { <END_VULN> 0 . 0000002310F , 0 . 0000020791F , 0 . 0000057754F , 0 . 0000113197F , 0 . 0000187121F , 0 . 0000279526F , 0 . 0000390412F , 0 . 0000519777F , 0 . 0000667623F , 0 . 0000833949F , 0 . 0001018753F , 0 . 0001222036F , 0 . 0001443798F , 0 . 0001684037F , 0 . 0001942754F , 0 . 0002219947F , 0 . 0002515616F , 0 . 0002829761F , 0 . 0003162380F , 0 . 0003513472F , 0 . 0003883038F , 0 . 0004271076F , 0 . 0004677584F , 0 . 0005102563F , 0 . 0005546011F , 0 . 0006007928F , 0 . 0006488311F , 0 . 0006987160F , 0 . 0007504474F , 0 . 0008040251F , 0 . 0008594490F , 0 . 0009167191F ,
. lock = gfs2_lock , . flock = gfs2_flock , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . setlease = gfs2_setlease , . fallocate = gfs2_fallocate , } ;
. open = ftrace_graph_open , . read = seq_read , . write = ftrace_graph_write , . release = ftrace_graph_release , <START_VULN> . llseek = seq_lseek , <END_VULN> } ; #endif
if ( iv && ( timr - > it_requeue_pending & REQUEUE_PENDING || sig_none ) ) <START_VULN> timr - > it_overrun + = ( int ) kc - > timer_forward ( timr , now ) ; <END_VULN> remaining = kc - > timer_remaining ( timr , now ) ;
memset ( state , 128 , sizeof ( state ) ) ; if ( f - > version < 2 ) { <START_VULN> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <END_VULN> unsigned v = get_symbol ( c , state , 0 ) ; if ( v >= 2 ) { av_log ( f - > avctx , AV_LOG_ERROR , "invalid version % d in ver01 header" , v ) ;
int do_adjtimex ( struct timex * txc ) { <START_VULN> long mtemp , save_adjust , rem ; <END_VULN> s64 freq_adj ; int result ;
if ( type == DNS_T_PTR ) { add_assoc_string ( * subarray , "type" , "PTR" , 1 ) ; } <START_VULN> n = dn_expand ( answer - > qb2 , answer - > qb2+65536 , cp , name , ( sizeof name ) - 2 ) ; <END_VULN> if ( n < 0 ) { return NULL ; }
transmit_response_with_date ( p , "200 OK" , req ) ; manager_event ( EVENT_FLAG_SYSTEM , "PeerStatus" , "ChannelType : SIPrPeer : SIP % srPeerStatus : RegisteredrAddress : % sr" , peer - > name , ast_sockaddr_stringify ( addr ) ) ; peer - > lastmsgssent = - 1 ; res = 0 ; break ; } ao2_unlock ( peer ) ; } } <START_VULN> if ( ! peer && sip_cfg . alwaysauthreject ) { <END_VULN> transmit_response ( p , "100 Trying" , req ) ; sched_yield ( ) ; } if ( ! res ) { ast_devstate_changed ( AST_DEVICE_UNKNOWN , "SIP % s" , peer - > name ) ; } if ( res < 0 ) { switch ( res ) {
krb5_free_error_message ( handle - > context , errmsg ) ; } free ( prime_arg1 ) ; free ( prime_arg2 ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <START_VULN> exit_func : <END_VULN> free_server_handle ( handle ) ; return & ret ; }
} } else { if ( state - > array_nl ) ruby_xfree ( state - > array_nl ) ; <START_VULN> state - > array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ; <END_VULN> state - > array_nl_len = len ; } return Qnil ;
{ void * pointer ; <START_VULN> if ( ! handle ) <END_VULN> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle - > dwLower ) ;
if ( ! arp_checkentry ( & e - > arp ) ) return - EINVAL ; <START_VULN> ret = xt_compat_check_entry_offsets ( e , e - > target_offset , <END_VULN> e - > next_offset ) ; if ( ret ) return ret ;
if ( cipher_def - > type == type_block ) { <START_VULN> const unsigned int blockSize = cipher_def - > iv_size ; <END_VULN> const unsigned int macSize = crSpec - > mac_size ; if ( crSpec - > version <= SSL_LIBRARY_VERSION_3_0 ) {
if ( request . magic != htonl ( NBD_REQUEST_MAGIC ) ) err ( "Not enough magic . " ) ; <START_VULN> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <END_VULN> err ( "Request too big ! " ) ; #ifdef DODBG printf ( " % s from % llu ( % llu ) len % d , " , request . type ? "WRITE" :
phar_flush ( phar_obj - > arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
header [ 11 ] = ( rec - > length ) >> 8 ; header [ 12 ] = ( rec - > length ) & 0xff ; <START_VULN> if ( ! send && ! SSL_USE_ETM ( ssl ) && <END_VULN> EVP_CIPHER_CTX_mode ( ssl - > enc_read_ctx ) == EVP_CIPH_CBC_MODE && ssl3_cbc_record_digest_supported ( mac_ctx ) ) { # define SSL_PKEY_RSA_ENC 0
} ( void ) r_buf_read_at ( bf - > buf , sec - > paddr , buf , sec - > size ) ; if ( bits == 32 ) { <START_VULN> for ( i = 0 ; i < sec - > size ; i + = 4 ) { <END_VULN> ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec - > paddr + i , ( ut64 ) addr32 , type , bits ) ;
<START_VULN> if ( ( ctxt - > mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA ) <END_VULN> && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ;
PUNFETCH ; prev = p ; num = scan_unsigned_octal_number ( & p , end , 3 , enc ) ; <START_VULN> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <END_VULN> if ( p == prev ) { num = 0 ; }
perf_unpin_context ( ctx ) ; if ( move_group ) <START_VULN> mutex_unlock ( & gctx - > mutex ) ; <END_VULN> mutex_unlock ( & ctx - > mutex ) ; if ( task ) {
int length ; length = strlen ( filename ) ; <START_VULN> if ( length > 0 ) <END_VULN> { if ( ( filename [ 0 ] == '"' ) && ( filename [ length - 1 ] == '"' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ;
compact_pixels = ( unsigned char * ) NULL ; if ( next_image - > compression == RLECompression ) { <START_VULN> compact_pixels = AcquireCompactPixels ( image , exception ) ; <END_VULN> if ( compact_pixels == ( unsigned char * ) NULL ) return ( 0 ) ; }
long err ; int i ; <START_VULN> if ( nsops < 1 ) <END_VULN> return - EINVAL ; sops = kmalloc ( sizeof ( * sops ) * nsops , GFP_KERNEL ) ; if ( ! sops )
get_page ( netbk - > mmap_pages [ pending_idx ] ) ; <START_VULN> xen_netbk_idx_release ( netbk , pending_idx ) ; <END_VULN> } }
u8 * out_buf ; int ret ; if ( buf [ 0 ] != REPORT_TYPE_LEDS ) return - EINVAL ; out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ) ; if ( ! out_buf ) return - ENOMEM ; <START_VULN> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <END_VULN> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ; out_buf [ 1 ] = djdev - > device_index ; memcpy ( out_buf + 2 , buf , count ) ; ret = hid_hw_raw_request ( djrcv_dev - > hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ) ; kfree ( out_buf ) ;
length = ( size_t ) ( GetQuantumRange ( info . depth ) +1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <START_VULN> if ( info . scale != ( Quantum * ) NULL ) <END_VULN> info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ;
} _iov = iov + ret ; size = reg - > memory_size - addr + reg - > guest_phys_addr ; <START_VULN> _iov - > iov_len = min ( ( u64 ) len , size ) ; <END_VULN> _iov - > iov_base = ( void __user * ) ( unsigned long ) ( reg - > userspace_addr + addr - reg - > guest_phys_addr ) ; s + = size ;
const char * buf , size_t count ) { struct platform_device * pdev = to_platform_device ( dev ) ; <START_VULN> char * driver_override , * old = pdev - > driver_override , * cp ; <END_VULN> if ( count > PATH_MAX ) return - EINVAL ;
} rval = si4713_set_rds_ps_name ( sdev , ps_name ) ; } break ; case V4L2_CID_RDS_TX_RADIO_TEXT : { char radio_text [ MAX_RDS_RADIO_TEXT + 1 ] ; len = control - > size - 1 ; <START_VULN> if ( len > MAX_RDS_RADIO_TEXT ) { <END_VULN> rval = - ERANGE ; goto exit ; } rval = copy_from_user ( radio_text , control - > string , len ) ; if ( rval < 0 ) goto exit ; radio_text [ len ] = '0' ; if ( strlen ( radio_text ) % vqc . step ) { rval = - ERANGE ;
class nsIconDecoder : public Decoder { public : nsIconDecoder ( RasterImage & aImage ) ; virtual ~ nsIconDecoder ( ) ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> uint8_t mWidth ; uint8_t mHeight ; uint32_t mPixBytesRead ; uint32_t mState ; } ; enum {
ret = GSS_S_FAILURE ; goto cleanup ; } <START_VULN> <END_VULN> sc - > ctx_handle = GSS_C_NO_CONTEXT ; * ctx = ( gss_ctx_id_t ) sc ; sc = NULL ;
int i ; out = in ; <START_VULN> for ( i = 0 ; i < 4 && out - > data [ i ] ; i ++ ) { <END_VULN> int hsub = s - > draw . hsub [ i ] ; int vsub = s - > draw . vsub [ i ] ; out - > data [ i ] -= ( s - > x >> hsub ) * s - > draw . pixelstep [ i ] +
data [ 1 ] = new >> 4 ; } else { FAT_ENTRY subseqEntry ; <START_VULN> if ( cluster != fs - > clusters - 1 ) <END_VULN> get_fat ( & subseqEntry , fs - > fat , cluster + 1 , fs ) ; else subseqEntry . value = 0 ;
uint_fast32_t tmpxend ; uint_fast32_t tmpyend ; jpc_dec_cp_t * cp ; <START_VULN> jpc_tsfb_band_t bnds [ 64 ] ; <END_VULN> jpc_pchg_t * pchg ; int pchgno ; jpc_dec_cmpt_t * cmpt ;
fp = skb_shinfo ( head ) - > frag_list ; <START_VULN> if ( NFCT_FRAG6_CB ( fp ) - > orig == NULL ) <END_VULN> fp = fp - > next ;
if ( ! ( mGeneration+1 ) . valid ( ) ) return false ; ++ mGeneration ; mMapUniformLocations . Clear ( ) ; return true ; } <START_VULN> already_AddRefed < WebGLUniformLocation > GetUniformLocationObject ( GLint glLocation ) ; <END_VULN> bool UpdateInfo ( gl : : GLContext * gl ) ; WebGLint UniformMaxNameLength ( ) const { return mUniformMaxNameLength ; } WebGLint AttribMaxNameLength ( ) const { return mAttribMaxNameLength ; } WebGLint UniformCount ( ) const { return mUniformCount ; }
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 113 20141211 14 : 10 : 53 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
{ int len = strlen ( buffer ) ; <START_VULN> if ( ( len + * stringlen ) > * stralloc ) { <END_VULN> char * newptr = realloc ( string , * stralloc * 2 ) ; if ( newptr ) { string = newptr ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "Deflate Compression Algorithm for IPCOMP" ) ; MODULE_AUTHOR ( "James Morris < jmorris@intercode . com . au > " ) ; <START_VULN> <END_VULN>
oggpack_write ( opb , ci - > mode_param [ i ] - > transformtype , 16 ) ; oggpack_write ( opb , ci - > mode_param [ i ] - > mapping , 8 ) ; } oggpack_write ( opb , 1 , 1 ) ; return ( 0 ) ; err_out : return ( - 1 ) ; <START_VULN> } <END_VULN> int vorbis_commentheader_out ( vorbis_comment * vc , ogg_packet * op ) { oggpack_buffer opb ; oggpack_writeinit ( & opb ) ; if ( _vorbis_pack_comment ( & opb , vc ) ) return OV_EIMPL ;
<START_VULN> if ( n == - 1 ) { <END_VULN> * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen : cannot parse hex - data" ) ; return FALSE ;
* <START_VULN> #include < k5 - platform . h > <END_VULN> #include < gssrpcrpc . h > #include < gssapigssapi_krb5 . h > #include < syslog . h >
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : #ifdef jail to whip a few platforms into the UNIX ideal . <START_VULN> last mod : $ Id : os . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifdef HAVE_CONFIG_H #include "config . h" #endif #include < math . h >
path . dentry = res ; nfs_set_verifier ( path . dentry , nfs_save_change_attribute ( dir ) ) ; nfs_unblock_sillyrename ( parent ) ; <START_VULN> nfs4_intent_set_file ( nd , & path , state ) ; <END_VULN> return res ; }
val = min_t ( u32 , val , sysctl_wmem_max ) ; set_sndbuf : sk - > sk_userlocks |= SOCK_SNDBUF_LOCK ; <START_VULN> sk - > sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ; <END_VULN> sk - > sk_write_space ( sk ) ; break ;
int lines ; int compressed_lines ; int starting_line ; signed short line_packets ; int y_ptr ; int byte_run ; int pixel_skip ; int pixel_countdown ; unsigned char * pixels ; <START_VULN> int pixel_limit ; <END_VULN> s - > frame . reference = 1 ; s - > frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ; if ( avctx - > reget_buffer ( avctx , & s - > frame ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "reget_buffer ( ) failed" ) ; return - 1 ; } pixels = s - > frame . data [ 0 ] ; pixel_limit = s - > avctx - > height * s - > frame . linesize [ 0 ] ;
j = m+1 ; while ( j -- ) { double d = 0 ; for ( i = j ; i < n ; i ++ ) d+ = ( double ) data [ i ] * data [ i - j ] ; aut [ j ] = d ; } <START_VULN> <END_VULN> error = aut [ 0 ] * ( 1 . + 1e - 10 ) ; epsilon = 1e - 9 * aut [ 0 ] +1e - 10 ; for ( i = 0 ; i < m ; i ++ ) { double r = - aut [ i+1 ] ;
ether_setup ( dev ) ; dev - > priv_flags |= IFF_802_1Q_VLAN ; <START_VULN> dev - > priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <END_VULN> dev - > tx_queue_len = 0 ; dev - > netdev_ops = & vlan_netdev_ops ;
} ptep_user = ( pt_element_t __user * ) ( ( void * ) host_addr + offset ) ; <START_VULN> if ( unlikely ( copy_from_user ( & pte , ptep_user , sizeof ( pte ) ) ) ) { <END_VULN> present = false ; break ; }
MODULE_DESCRIPTION ( "Camellia Cipher Algorithm" ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "camellia" ) ; <END_VULN>
BIO_push ( out , etmp ) ; etmp = NULL ; } <START_VULN> if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) { <END_VULN> bio = in_bio ; } else { if ( data_body - > length > 0 )
strlcpy ( psz_server , psz_path , sizeof ( psz_server ) ) ; psz_share [ 0 ] = 0 ; psz_parser = strchr ( psz_path , '' ) ; if ( psz_parser ) { char * psz_parser2 = strchr ( ++ psz_parser , '' ) ; if ( psz_parser2 ) strlcpy ( psz_share , psz_parser , sizeof ( psz_share ) ) ; } <START_VULN> sprintf ( psz_remote , " % s % s" , psz_server , psz_share ) ; <END_VULN> net_resource . lpRemoteName = psz_remote ; i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ) ; if ( i_result != NO_ERROR ) { msg_Dbg ( p_access , "connected to % s" , psz_remote ) ; } else if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )
seq_puts ( m , key - > description ) ; <START_VULN> if ( key_is_instantiated ( key ) ) <END_VULN> seq_printf ( m , " : % zu [ % s ] " , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? "file" : "buff" ) ;
. index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , <START_VULN> . match_data . cmp = type - > match , <END_VULN> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ;
struct bpf_map * map_ptr ; } ; int ctx_field_size ; <START_VULN> int converted_op_size ; <END_VULN> } ; #define MAX_USED_MAPS 64
replace_value = & empty_replace ; } } <START_VULN> <END_VULN> if ( ( result = php_pcre_replace ( Z_STRVAL_PP ( regex_entry ) ,
const ut8 * buf_end = obuf + obuf_len ; size_t j ; <START_VULN> if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { <END_VULN> return NULL ; }
* dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; <START_VULN> * dptr ++ = 0xAA ; <END_VULN> memcpy ( dptr , & rose - > dest_addr , ROSE_ADDR_LEN ) ; dptr + = ROSE_ADDR_LEN ; memcpy ( dptr , & rose - > source_addr , ROSE_ADDR_LEN ) ;
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : softmagic . c , v 1 . 196 20141107 15 : 24 : 14 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
break ; case 0x80 . . . 0x8f : if ( test_cc ( ctxt - > b , ctxt - > eflags ) ) <START_VULN> jmp_rel ( ctxt , ctxt - > src . val ) ; <END_VULN> break ; case 0x90 . . . 0x9f : ctxt - > dst . val = test_cc ( ctxt - > b , ctxt - > eflags ) ;
zend_vspprintf ( & message , 0 , format , va ) ; if ( fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { <START_VULN> zend_throw_error ( exception_ce , message ) ; <END_VULN> } else { zend_error ( E_ERROR , " % s" , message ) ; }
public : inline void setDefaultCompartmentObject ( JSObject * obj ) ; inline void setDefaultCompartmentObjectIfUnset ( JSObject * obj ) ; JSObject * maybeDefaultCompartmentObject ( ) const { return defaultCompartmentObject_ ; } js : : ContextStack stack ; <START_VULN> <END_VULN> inline js : : Handle < js : : GlobalObject * > global ( ) const ; inline bool hasfp ( ) const { return stack . hasfp ( ) ; } inline js : : StackFrame * fp ( ) const { return stack . fp ( ) ; } inline js : : StackFrame * maybefp ( ) const { return stack . maybefp ( ) ; } inline js : : FrameRegs & regs ( ) const { return stack . regs ( ) ; } inline js : : FrameRegs * maybeRegs ( ) const { return stack . maybeRegs ( ) ; }
} <START_VULN> #define DOBIG4 c ^= * ++ buf4 ; <END_VULN> c = crc_table [ 4 ] [ c & 0xff ] ^ crc_table [ 5 ] [ ( c >> 8 ) & 0xff ] ^ crc_table [ 6 ] [ ( c >> 16 ) & 0xff ] ^ crc_table [ 7 ] [ c >> 24 ] #define DOBIG32 DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4
} ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <START_VULN> if ( ! ctx - > established ) { <END_VULN> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
} out_unlock : <START_VULN> sem_unlock ( sma ) ; <END_VULN> out_wakeup : wake_up_sem_queue_do ( & tasks ) ; out_free :
char * buf = mutt_str_strdup ( src ) ; imap_utf_encode ( idata , & buf ) ; <START_VULN> imap_quote_string ( dest , dlen , buf ) ; <END_VULN> FREE ( & buf ) ; }
list_del_init ( & u - > link ) ; unix_tot_inflight -- ; } <START_VULN> fp - > f_cred - > user - > unix_inflight -- ; <END_VULN> spin_unlock ( & unix_gc_lock ) ; }
& _vq_book_res0a_13 , NULL } ; float * testvec [ ] = { test1 , test3 } ; int main ( ) { oggpack_buffer write ; oggpack_buffer read ; long ptr = 0 , i ; oggpack_writeinit ( & write ) ; <START_VULN> <END_VULN> fprintf ( stderr , "Testing codebook abstraction . . . : " ) ; while ( testlist [ ptr ] ) { codebook c ; static_codebook s ; float * qv = alloca ( sizeof ( * qv ) * TESTSIZE ) ; float * iv = alloca ( sizeof ( * iv ) * TESTSIZE ) ; memcpy ( qv , testvec [ ptr ] , sizeof ( * qv ) * TESTSIZE ) ;
if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ; <START_VULN> if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) <END_VULN> return 1 ; if ( is_no_device ( intr_info ) ) {
const struct xt_entry_target * t ; unsigned int verdict ; <START_VULN> if ( ! unconditional ( & e - > ipv6 ) ) <END_VULN> return false ; t = ip6t_get_target_c ( e ) ; if ( strcmp ( t - > u . user . name , XT_STANDARD_TARGET ) != 0 )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : bitrate tracking and management <START_VULN> last mod : $ Id : bitrate . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
{ Vp3DecodeContext * s = dst - > priv_data , * s1 = src - > priv_data ; int qps_changed = 0 , i , err ; #define copy_fields ( to , from , start_field , end_field ) memcpy ( & to - > start_field , & from - > start_field , ( char * ) & to - > end_field - ( char * ) & to - > start_field ) if ( ! s1 - > current_frame . data [ 0 ] || s - > width != s1 - > width || s - > height != s1 - > height ) { if ( s != s1 ) <START_VULN> copy_fields ( s , s1 , golden_frame , current_frame ) ; <END_VULN> return - 1 ; } if ( s != s1 ) { if ( ! s - > current_frame . data [ 0 ] ) { int y_fragment_count , c_fragment_count ; s - > avctx = dst ; err = allocate_tables ( dst ) ; if ( err )
if ( ! fstype ) { error = - ENODEV ; goto out ; } if ( fstype - > fs_flags & FS_REQUIRES_DEV ) need_dev = 1 ; } if ( need_dev ) { <START_VULN> if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) { <END_VULN> error = - ENOENT ; goto out ; } requested_dev_name = tomoyo_realpath_from_path ( & path ) ; if ( ! requested_dev_name ) { error = - ENOENT ; goto out ; } } else {
module_init ( aes_s390_init ) ; module_exit ( aes_s390_fini ) ; <START_VULN> MODULE_ALIAS ( "aes - all" ) ; <END_VULN> MODULE_DESCRIPTION ( "Rijndael ( AES ) Cipher Algorithm" ) ; MODULE_LICENSE ( "GPL" ) ;
static int CVE_2012_1183_milliwatt_generate ( struct ast_channel * chan , void * data , int len , int samples ) { unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; <START_VULN> const int maxsamples = ARRAY_LEN ( buf ) ; <END_VULN> int i , * indexp = ( int * ) data ; struct ast_frame wf = { . frametype = AST_FRAME_VOICE , . offset = AST_FRIENDLY_OFFSET , . src = __FUNCTION__ , } ; ast_format_set ( & wf . subclass . format , AST_FORMAT_ULAW , 0 ) ; wf . data . ptr = buf + AST_FRIENDLY_OFFSET ;
<START_VULN> if ( sbi - > s_journal && ! handle ) <END_VULN> goto out ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ;
idev = __in_dev_get_rcu ( dev ) ; if ( idev ) { if ( idev - > ifa_list ) network = ntohl ( idev - > ifa_list - > ifa_address ) & 0xffffff00 ; } rcu_read_unlock ( ) ; udpdest . sin_addr . s_addr = htonl ( network | addr . station ) ; } ah . port = port ; ah . cb = cb & 0x7f ; ah . code = 2 ; <START_VULN> ah . pad = 0 ; <END_VULN> size = sizeof ( struct aunhdr ) ; iov [ 0 ] . iov_base = ( void * ) & ah ; iov [ 0 ] . iov_len = size ; for ( i = 0 ; i < msg - > msg_iovlen ; i ++ ) { void __user * base = msg - > msg_iov [ i ] . iov_base ; size_t iov_len = msg - > msg_iov [ i ] . iov_len ;
if ( h - > slice_type_nos == AV_PICTURE_TYPE_B ) h - > direct_spatial_mv_pred = get_bits1 ( & s - > gb ) ; num_ref_idx_active_override_flag = get_bits1 ( & s - > gb ) ; if ( num_ref_idx_active_override_flag ) { h - > ref_count [ 0 ] = get_ue_golomb ( & s - > gb ) + 1 ; if ( h - > slice_type_nos == AV_PICTURE_TYPE_B ) h - > ref_count [ 1 ] = get_ue_golomb ( & s - > gb ) + 1 ; else <START_VULN> max [ 1 ] = 31 ; <END_VULN> } if ( h - > ref_count [ 0 ] - 1 > max [ 0 ] || h - > ref_count [ 1 ] - 1 > max [ 1 ] ) { av_log ( h - > s . avctx , AV_LOG_ERROR , "reference overflow % u > % u or % u > % u" , h - > ref_count [ 0 ] - 1 , max [ 0 ] , h - > ref_count [ 1 ] - 1 , max [ 1 ] ) ; h - > ref_count [ 0 ] = h - > ref_count [ 1 ] = 1 ; return AVERROR_INVALIDDATA ; } if ( h - > slice_type_nos == AV_PICTURE_TYPE_B ) h - > list_count = 2 ;
return mar_fpopen ( fp ) ; } #ifdef XP_WIN MarFile * mar_wopen ( const wchar_t * path ) { FILE * fp ; <START_VULN> fp = _wfopen ( path , L"rb" ) ; <END_VULN> if ( ! fp ) return NULL ; return mar_fpopen ( fp ) ; } #endif void mar_close ( MarFile * mar ) {
{ int i ; for ( i = 0 ; i <= 31 ; i ++ ) { <START_VULN> if ( x & ( 1 << i ) ) return i ; <END_VULN> } return 0 ; }
return NULL ; } ; <START_VULN> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <END_VULN> { sf_errno = SFE_MALLOC_FAILED ; returnNULL ; } ;
if ( msr - > request_content_length == - 1 ) { char * transfer_encoding = ( char * ) apr_table_get ( msr - > request_headers , "Transfer - Encoding" ) ; <START_VULN> if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , "chunked" ) != NULL ) ) { <END_VULN> msr - > reqbody_should_exist = 1 ; msr - > reqbody_chunked = 1 ; }
this - > sd = - 1 ; this - > sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ; if ( this - > sd < 0 ) { <START_VULN> ERR ( "sockect open failed" ) ; <END_VULN> goto error ; }
return error ; } <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) {
e = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; if ( e == NULL || e - > method == SC_AC_NEVER ) return 10 ; <START_VULN> bufsize = file - > size ; <END_VULN> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) {
get_trust_val ( trust , valstr , sizeof valstr ) ; PR_LOG ( modlog , 4 , ( fmt_s_s_d , atype , valstr , attr - > ulValueLen ) ) ; break ; } case CKA_KEY_TYPE : if ( attr - > ulValueLen > 0 && attr - > pValue ) { CK_KEY_TYPE keyType = * ( ( CK_KEY_TYPE * ) attr - > pValue ) ; <START_VULN> get_obj_class ( keyType , valstr , sizeof valstr ) ; <END_VULN> PR_LOG ( modlog , 4 , ( fmt_s_s_d , atype , valstr , attr - > ulValueLen ) ) ; break ; } case CKA_LABEL : case CKA_NETSCAPE_EMAIL : case CKA_NETSCAPE_URL : if ( attr - > ulValueLen > 0 && attr - > pValue ) {
data . period = event - > hw . last_period ; if ( alpha_perf_event_set_period ( event , hwc , idx ) ) { <START_VULN> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <END_VULN>
0 . 8928678298F , 0 . 9080153310F , 0 . 9217306608F , 0 . 9340480615F , 0 . 9450138200F , 0 . 9546851041F , 0 . 9631286621F , 0 . 9704194171F , 0 . 9766389810F , 0 . 9818741197F , 0 . 9862151938F , 0 . 9897546035F , 0 . 9925852598F , 0 . 9947991032F , 0 . 9964856900F , 0 . 9977308602F , 0 . 9986155015F , 0 . 9992144193F , 0 . 9995953200F , 0 . 9998179155F , 0 . 9999331503F , 0 . 9999825563F , 0 . 9999977357F , 0 . 9999999720F , } ; <START_VULN> static float vwin256 [ 128 ] = { <END_VULN> 0 . 0000591390F , 0 . 0005321979F , 0 . 0014780301F , 0 . 0028960636F , 0 . 0047854363F , 0 . 0071449926F , 0 . 0099732775F , 0 . 0132685298F , 0 . 0170286741F , 0 . 0212513119F , 0 . 0259337111F , 0 . 0310727950F , 0 . 0366651302F , 0 . 0427069140F , 0 . 0491939614F , 0 . 0561216907F , 0 . 0634851102F , 0 . 0712788035F , 0 . 0794969160F , 0 . 0881331402F , 0 . 0971807028F , 0 . 1066323515F , 0 . 1164803426F , 0 . 1267164297F , 0 . 1373318534F , 0 . 1483173323F , 0 . 1596630553F , 0 . 1713586755F , 0 . 1833933062F , 0 . 1957555184F , 0 . 2084333404F , 0 . 2214142599F ,
size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ; <START_VULN> dl = kmalloc ( size , GFP_KERNEL ) ; <END_VULN> if ( ! dl ) return - ENOMEM ;
MODULE_DESCRIPTION ( "Rijndael ( AES ) Cipher Algorithm" ) ; MODULE_LICENSE ( "Dual BSDGPL" ) ; <START_VULN> MODULE_ALIAS ( "aes" ) ; <END_VULN>
{ SFE_BAD_CHUNK_MARKER , "Error : Bad chunk marker . " } , { SFE_BAD_CHUNK_DATA_PTR , "Error : Bad data pointer in SF_CHUNK_INFO struct . " } , { SFE_FILENAME_TOO_LONG , "Error : Supplied filename too long . " } , <START_VULN> <END_VULN> { SFE_MAX_ERROR , "Maximum error number . " } , { SFE_MAX_ERROR + 1 , NULL }
# define SSL_ST_BEFORE 0x4000 # define SSL_ST_OK 0x03 # define SSL_ST_RENEGOTIATE ( 0x04 | SSL_ST_INIT ) <START_VULN> # define SSL_ST_ERR 0x05<END_VULN> # define SSL_CB_LOOP 0x01 # define SSL_CB_EXIT 0x02
end : if ( TRUE == local_tx_started ) { <START_VULN> conn - > m - > local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_INF ( ret == PASS ? "PASS" : "FAIL" ) ; DBG_RETURN ( ret ) ;
protected : virtual void InitInternal ( ) ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal ( ) ;
seq_printf ( m , "seedsize : % u" , seedsize ( alg ) ) ; } <START_VULN> const struct crypto_type crypto_rng_type = { <END_VULN> . extsize = crypto_alg_extsize , . init_tfm = crypto_rng_init_tfm , #ifdef CONFIG_PROC_FS
sock - > _wreq . bufs = sock - > _wreq . smallbufs ; } else { sock - > _wreq . bufs = h2o_mem_alloc ( sizeof ( h2o_iovec_t ) * bufcnt ) ; <START_VULN> sock - > _wreq . alloced_ptr = sock - > _wreq . bufs = sock - > _wreq . bufs ; <END_VULN> } memcpy ( sock - > _wreq . bufs , bufs , sizeof ( h2o_iovec_t ) * bufcnt ) ; sock - > _wreq . cnt = bufcnt ;
return ; } <START_VULN> phar_file_stat ( filename , ( php_stat_len ) filename_len , funcnum , PHAR_G ( orig ) , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; <END_VULN> } }
if ( ! str ) return false ; size_t length ; const jschar * chars = JS_GetStringCharsAndLength ( cx , str , & length ) ; if ( ! chars ) return false ; NS_ConvertUTF16toUTF8 utf8str ( reinterpret_cast < const PRUnichar * > ( chars ) ) ; #ifdef ANDROID <START_VULN> __android_log_print ( ANDROID_LOG_INFO , "Gecko" , utf8str . get ( ) ) ; <END_VULN> #endif fputs ( utf8str . get ( ) , stdout ) ; fflush ( stdout ) ; return true ; }
<START_VULN> if ( ! SSL_USE_ETM ( s ) && mac_size != 0 ) { <END_VULN> if ( s - > method - > ssl3_enc - > mac ( s , & wr [ j ] , & ( outbuf [ j ] [ wr [ j ] . length + eivlen ] ) , 1 ) < 0 )
mutex_unlock ( & key_construction_mutex ) ; <START_VULN> if ( keyring ) <END_VULN> __key_link_end ( keyring , & key - > index_key , edit ) ;
uint32_t tag = track - > tag ; if ( track - > mode == MODE_MOV ) { <START_VULN> if ( track - > timescale > UINT16_MAX ) { <END_VULN> if ( mov_get_lpcm_flags ( track - > par - > codec_id ) ) tag = AV_RL32 ( "lpcm" ) ; version = 2 ;
EXT4_HAS_INCOMPAT_FEATURE ( sb , EXT4_FEATURE_INCOMPAT_RECOVER ) ) { ext4_msg ( sb , KERN_ERR , "required journal recovery " "suppressed and not mounted read - only" ) ; <START_VULN> goto failed_mount4 ; <END_VULN> } else { clear_opt ( sbi - > s_mount_opt , DATA_FLAGS ) ; set_opt ( sbi - > s_mount_opt , WRITEBACK_DATA ) ;
} bcc_ptr + = length + 1 ; strncpy ( tcon - > treeName , tree , MAX_TREE_SIZE ) ; if ( smb_buffer - > Flags2 & SMBFLG2_UNICODE ) { length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ) ; if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) ) { kfree ( tcon - > nativeFileSystem ) ; tcon - > nativeFileSystem = <START_VULN> kzalloc ( length + 2 , GFP_KERNEL ) ; <END_VULN> if ( tcon - > nativeFileSystem ) cifs_strfromUCS_le ( tcon - > nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ) ; bcc_ptr + = 2 * length ; bcc_ptr [ 0 ] = 0 ; bcc_ptr [ 1 ] = 0 ; bcc_ptr + = 2 ; }
nsLayoutUtils : : SurfaceFromElementResult SurfaceFromElement ( const dom : : NonNull < ElementType > & aElement ) { return SurfaceFromElement ( aElement . get ( ) ) ; } nsresult SurfaceFromElementResultToImageSurface ( nsLayoutUtils : : SurfaceFromElementResult & res , gfxImageSurface ** imageOut , WebGLTexelFormat * format ) ; <START_VULN> void CopyTexSubImage2D_base ( WebGLenum target , <END_VULN> WebGLint level , WebGLenum internalformat , WebGLint xoffset , WebGLint yoffset , WebGLint x , WebGLint y , WebGLsizei width , WebGLsizei height ,
vd = & ( iso9660 - > joliet ) ; <START_VULN> skipsize = LOGICAL_BLOCK_SIZE * vd - > location ; <END_VULN> skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 ) return ( ( int ) skipsize ) ;
} <START_VULN> static inline void realpath_cache_add ( const char * path , int path_len , const char * realpath , int realpath_len , int is_dir , time_t t ) <END_VULN> { zend_long size = sizeof ( realpath_cache_bucket ) + path_len + 1 ; int same = 1 ;
OM_uint32 code ; ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <START_VULN> if ( ! ctx - > established ) { <END_VULN> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
} <START_VULN> ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ; <END_VULN> pd = ws_buffer_start_ptr ( buf ) ;
err = b43_try_request_fw ( ctx ) ; if ( ! err ) goto start_ieee80211 ; if ( ctx - > fatal_failure ) goto out ; for ( i = 0 ; i < B43_NR_FWTYPES ; i ++ ) { errmsg = ctx - > errors [ i ] ; if ( strlen ( errmsg ) ) <START_VULN> b43err ( dev - > wl , errmsg ) ; <END_VULN> } b43_print_fw_helptext ( dev - > wl , 1 ) ; goto out ; start_ieee80211 : wl - > hw - > queues = B43_QOS_QUEUE_NUM ; if ( ! modparam_qos || dev - > fw . opensource ) wl - > hw - > queues = 1 ; err = ieee80211_register_hw ( wl - > hw ) ;
sem_rmid ( ns , sma ) ; <START_VULN> sem_unlock ( sma ) ; <END_VULN> wake_up_sem_queue_do ( & tasks ) ; ns - > used_sems -= sma - > sem_nsems ;
break ; case SO_PASSSEC : <START_VULN> v . val = test_bit ( SOCK_PASSSEC , & sock - > flags ) ? 1 : 0 ; <END_VULN> break ; case SO_PEERSEC :
} int touch ( const char * path ) { <START_VULN> return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <END_VULN> } int symlink_idempotent ( const char * from , const char * to ) {
size_t datalen = prep - > datalen ; int ret = 0 ; <START_VULN> if ( test_bit ( KEY_FLAG_NEGATIVE , & key - > flags ) ) <END_VULN> return - ENOKEY ; if ( datalen <= 0 || datalen > 32767 || ! prep - > data ) return - EINVAL ;
#if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( op - m_pos >= 8 ) { unsigned char * oe = op + t ; <START_VULN> if ( likely ( HAVE_OP ( t + 15 ) ) ) { <END_VULN> do { COPY8 ( op , m_pos ) ; op + = 8 ;
ut64data ; st64sdata ; ut64reference ; <START_VULN> struct str_structt { <END_VULN> char * string ; ut64offset ; } str_struct ;
status = decode_putfh ( xdr ) ; if ( status ) goto out ; <START_VULN> status = decode_getacl ( xdr , rqstp , & res - > acl_len ) ; <END_VULN> out : return status ;
if ( ( ret & VM_FAULT_WRITE ) && ! ( vma - > vm_flags & VM_WRITE ) ) <START_VULN> * flags &= ~ FOLL_WRITE ; <END_VULN> return 0 ; }
IPV6_SET_RAW_VER ( p - > ip6h , 6 ) ; IPV6FragHdr * fh = ( IPV6FragHdr * ) ( GET_PKT_DATA ( p ) + sizeof ( IPV6Hdr ) ) ; <START_VULN> fh - > ip6fh_nxt = IPPROTO_ICMP ; <END_VULN> fh - > ip6fh_ident = htonl ( id ) ; fh - > ip6fh_offlg = htons ( ( off << 3 ) | mf ) ;
private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , <START_VULN> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <END_VULN> { cdf_summary_info_header_t si ; cdf_property_info_t * info ;
<START_VULN> void unix_inflight ( struct file * fp ) <END_VULN> { struct sock * s = unix_get_socket ( fp ) ;
define_sid = 0 ; } <START_VULN> if ( ! PS ( id ) && <END_VULN> zend_hash_find ( & EG ( symbol_table ) , "_GET" , sizeof ( "_GET" ) , ( void ** ) & data ) == SUCCESS && Z_TYPE_PP ( data ) == IS_ARRAY &&
<START_VULN> return mutt_bcache_del ( bcache , id ) ; <END_VULN> } #ifdef USE_HCACHE
uint32_t lineIndexToNum ( uint32_t lineIndex ) const { return lineIndex + initialLineNum_ ; } uint32_t lineNumToIndex ( uint32_t lineNum ) const { return lineNum - initialLineNum_ ; } public : SourceCoords ( ExclusiveContext * cx , uint32_t ln ) ; void add ( uint32_t lineNum , uint32_t lineStartOffset ) ; <START_VULN> void fill ( const SourceCoords & other ) ; <END_VULN> bool isOnThisLine ( uint32_t offset , uint32_t lineNum ) const { uint32_t lineIndex = lineNumToIndex ( lineNum ) ; JS_ASSERT ( lineIndex + 1 < lineStartOffsets_ . length ( ) ) ; return lineStartOffsets_ [ lineIndex ] <= offset && offset < lineStartOffsets_ [ lineIndex + 1 ] ; }
data , hlen , & _keyid ) ; if ( ! keyid ) <START_VULN> return false ; <END_VULN> if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_GRE_KEYID ) ) {
<START_VULN> mp_err<END_VULN> ec_GFp_pt_dbl_jm ( const mp_int * px , const mp_int * py , const mp_int * pz , const mp_int * paz4 , mp_int * rx , mp_int * ry , mp_int * rz , mp_int * raz4 , mp_int scratch [ ] , const ECGroup * group ) { mp_err res = MP_OKAY ; mp_int * t0 , * t1 , * M , * S ; t0 = & scratch [ 0 ] ;
stat = yajl_parse_complete ( hand ) ; if ( stat != yajl_status_ok && <START_VULN> stat != yajl_status_insufficient_data ) <END_VULN> { unsigned char * str = yajl_get_error ( hand , 1 , data , dataSize ) ; fprintf ( stderr , ( const char * ) str ) ;
MODULE_DESCRIPTION ( "Adjunct Processor Bus driver , " "Copyright IBM Corp . 2006 , 2012" ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "z90crypt" ) ; <END_VULN>
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 126 20151116 16 : 03 : 45 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
} loff_t <START_VULN> ftrace_regex_lseek ( struct file * file , loff_t offset , int whence ) <END_VULN> { loff_t ret ;
err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; <START_VULN> mnt_flags |= mnt - > mnt . mnt_flags & MNT_PROPAGATION_MASK ; <END_VULN> mnt - > mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt - > mnt_ns ) ; unlock_mount_hash ( ) ;
} } ; <START_VULN> MODULE_ALIAS ( "sha512" ) ; <END_VULN> static int sha384_init ( struct shash_desc * desc ) {
while ( an -- && cp && cp < end ) { zval * retval ; <START_VULN> cp = php_parserr ( cp , & answer , type_to_fetch , store_results , raw , & retval ) ; <END_VULN> if ( retval != NULL && store_results ) { add_next_index_zval ( return_value , retval ) ; }
opthdr = __skb_header_pointer ( skb , nhoff , sizeof ( _opthdr ) , data , hlen , & _opthdr ) ; if ( ! opthdr ) <START_VULN> return false ; <END_VULN> ip_proto = opthdr [ 0 ] ; nhoff + = ( opthdr [ 1 ] + 1 ) << 3 ;
. compat_ioctl = f2fs_compat_ioctl , #endif . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> } ;
} <START_VULN> <END_VULN> struct snd_seq_client_port * snd_seq_create_port ( struct snd_seq_client * client , int port ) {
if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr - > ia_gid : inode - > i_gid ) && <START_VULN> ! inode_capable ( inode , CAP_FSETID ) ) <END_VULN> attr - > ia_mode &= ~ S_ISGID ; }
#endif virtual nsresult Close ( ) ; virtual void Suspend ( bool aCloseImmediately ) ; virtual void Resume ( ) ; virtual already_AddRefed < nsIPrincipal > GetCurrentPrincipal ( ) ; bool IsClosed ( ) const { return mCacheStream . IsClosed ( ) ; } virtual bool CanClone ( ) ; <START_VULN> virtual MediaResource * CloneData ( MediaDecoder * aDecoder ) ; <END_VULN> void RecordStatisticsTo ( MediaChannelStatistics * aStatistics ) MOZ_OVERRIDE { NS_ASSERTION ( aStatistics , "Statistics param cannot be null ! " ) ; MutexAutoLock lock ( mLock ) ; if ( ! mChannelStatistics ) { mChannelStatistics = aStatistics ; }
seed = buf ; } <START_VULN> err = tfm - > seed ( tfm , seed , slen ) ; <END_VULN> kfree ( buf ) ; return err ;
phar_obj - > arc . archive - > alias = oldalias ; phar_obj - > arc . archive - > alias_len = oldalias_len ; phar_obj - > arc . archive - > is_temporary_alias = old_temp ; <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> if ( readd ) { zend_hash_add ( & ( PHAR_GLOBALS - > phar_alias_map ) , oldalias , oldalias_len , ( void * ) & ( phar_obj - > arc . archive ) , sizeof ( phar_archive_data * ) , NULL ) ; }
} for ( ; num ; num -- ) { <START_VULN> if ( pread ( fd , xph_addr , xph_sizeof , off ) == - 1 ) { <END_VULN> file_badread ( ms ) ; return - 1 ; }
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 45 20110828 08 : 38 : 48 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
struct TypedArrayObjectStorage : AllTypedArraysBase { protected : JSObject * mObj ; <START_VULN> TypedArrayObjectStorage ( ) <END_VULN> { } public : inline void TraceSelf ( JSTracer * trc ) { if ( mObj ) { JS_CallObjectTracer ( trc , & mObj , "TypedArray . mObj" ) ;
{ stream - > msg = "abnormal command termination" ; } <START_VULN> return XD3_INTERNAL ; <END_VULN> } return 0 ; }
sdb_num_set ( sdb , "link" , shdr - > sh_link , 0 ) ; sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; <START_VULN> for ( cnt = 0 , i = 0 ; cnt < shdr - > sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <END_VULN> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ;
<START_VULN> static bool neuterViews ( JSContext * cx , Handle < ArrayBufferObject * > buffer ) ; <END_VULN> uint8_t * dataPointer ( ) const ;
if ( PASS == ( ret = PACKET_READ ( stats_header , conn ) ) ) { <START_VULN> * message = estrndup ( stats_header - > message , stats_header - > message_len ) ; <END_VULN> * message_len = stats_header - > message_len ; DBG_INF ( * message ) ; }
First : no IPv4 options . <START_VULN> newinet - > opt = NULL ; <END_VULN> newnp - > ipv6_fl_list = NULL ;
case GF_ISOM_SAMPLE_GROUP_TRIF : trif_dump ( trace , ( char * ) ( ( GF_DefaultSampleGroupDescriptionEntry * ) entry ) - > data , ( ( GF_DefaultSampleGroupDescriptionEntry * ) entry ) - > length ) ; break ; <START_VULN> <END_VULN> case GF_ISOM_SAMPLE_GROUP_NALM : nalm_dump ( trace , ( char * ) ( ( GF_DefaultSampleGroupDescriptionEntry * ) entry ) - > data , ( ( GF_DefaultSampleGroupDescriptionEntry * ) entry ) - > length ) ; break ;
} out_unlock : <START_VULN> sem_unlock ( sma ) ; <END_VULN> out_up : up_write ( & sem_ids ( ns ) . rw_mutex ) ; return err ;
{ int error ; bool is_dir = d_is_dir ( old_dentry ) ; <START_VULN> const unsigned char * old_name ; <END_VULN> struct inode * source = old_dentry - > d_inode ; struct inode * target = new_dentry - > d_inode ; bool new_is_dir = false ; unsigned max_links = new_dir - > i_sb - > s_max_links ; if ( source == target ) return 0 ;
{ FT_ASSERT ( cur [ 0 ] - > clazz ) ; <START_VULN> if ( cur [ 0 ] - > clazz - > get_interface ) <END_VULN> { result = cur [ 0 ] - > clazz - > get_interface ( cur [ 0 ] , service_id ) ; if ( result != NULL )
share - > kfile = - 1 ; ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ; if ( change_to_newfile ( share - > index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT , <START_VULN> MYF ( 0 ) ) || <END_VULN> mi_open_keyfile ( share ) ) goto err2 ; info - > lock_type = F_UNLCK ;
for ( int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK ; i > 0 ; i -- , to ++ ) { JSBool marked = to - > IsMarked ( ) ; to - > Unmark ( ) ; if ( marked ) continue ; <START_VULN> if ( ! to - > GetJSObject ( ) ) { <END_VULN> nsISupports * obj = to - > GetNative ( ) ; if ( obj ) { obj - > Release ( ) ; to - > SetNative ( nsnull ) ; } to - > SetInterface ( nsnull ) ; } }
merge : <START_VULN> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <END_VULN> ext4_ext_try_to_merge ( inode , path , nearex ) ;
#endif { unsigned char * oe = op + t ; <START_VULN> NEED_OP ( t ) ; <END_VULN> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op + = 2 ;
" for note" ) ; return - 1 ; } <START_VULN> if ( pread ( fd , nbuf , xsh_size , xsh_offset ) == - 1 ) { <END_VULN> file_badread ( ms ) ; free ( nbuf ) ; return - 1 ;
txp - > size -= data_len ; } else { <START_VULN> xen_netbk_idx_release ( netbk , pending_idx ) ; <END_VULN> } if ( txp - > flags & XEN_NETTXF_csum_blank )
if ( page == NULL ) page = http_request_get_query_string ( req ) ; <START_VULN> if ( page && ( access ( page , R_OK ) == 0 ) ) <END_VULN> { http_response_printf ( res , "success" ) ; http_response_send ( res ) ;
private : nsGfxScrollFrameInner * mInner ; } ; void FinishReflowForScrollbar ( nsIContent * aContent , nscoord aMinXY , nscoord aMaxXY , nscoord aCurPosXY , nscoord aPageIncrement , nscoord aIncrement ) ; <START_VULN> static void SetScrollbarEnabled ( nsIContent * aContent , nscoord aMaxPos ) ; <END_VULN> void SetCoordAttribute ( nsIContent * aContent , nsIAtom * aAtom , nscoord aSize ) ; nscoord GetCoordAttribute ( nsIFrame * aFrame , nsIAtom * aAtom , nscoord aDefaultValue , nscoord * aRangeStart , nscoord * aRangeLength ) ; void UpdateScrollbarPosition ( ) ; nsRect GetScrollPortRect ( ) const { return mScrollPort ; }
{ MOZ_COUNT_DTOR ( nsXBLProtoImpl ) ; delete mMembers ; delete mFields ; } <START_VULN> nsresult InstallImplementation ( nsXBLPrototypeBinding * aBinding , nsIContent * aBoundElement ) ; <END_VULN> nsresult InitTargetObjects ( nsXBLPrototypeBinding * aBinding , nsIScriptContext * aContext , nsIContent * aBoundElement , nsIXPConnectJSObjectHolder ** aScriptObjectHolder , JSObject ** aTargetClassObject ) ; nsresult CompilePrototypeMembers ( nsXBLPrototypeBinding * aBinding ) ; void SetMemberList ( nsXBLProtoImplMember * aMemberList ) {
} else if ( ret == - EINPROGRESS ) { ret = 0 ; } else { <START_VULN> goto couldnt_alloc_key ; <END_VULN> } key_put ( dest_keyring ) ;
return ret ; out_release_unlock : spin_unlock ( ptl ) ; <START_VULN> out_release_nounlock : <END_VULN> if ( vm_shared ) unlock_page ( page ) ; put_page ( page ) ; goto out ; }
phar_flush ( phar_obj - > arc . archive , stub , stub_len , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
<START_VULN> static int _nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state ** res ) <END_VULN> { struct nfs4_state_owner * sp ; struct nfs4_state * state = NULL ;
nsTextFrame * nextContinuation = static_cast < nsTextFrame * > ( aPrevInFlow - > GetNextContinuation ( ) ) ; #endif SetPrevInFlow ( aPrevInFlow ) ; aPrevInFlow - > SetNextInFlow ( this ) ; nsTextFrame * prev = static_cast < nsTextFrame * > ( aPrevInFlow ) ; mContentOffset = prev - > GetContentOffset ( ) + prev - > GetContentLengthHint ( ) ; <START_VULN> NS_ASSERTION ( mContentOffset < aContent - > GetText ( ) - > GetLength ( ) , <END_VULN> "Creating ContinuingTextFrame , but there is no more content" ) ; if ( prev - > GetStyleContext ( ) != GetStyleContext ( ) ) { prev - > ClearTextRun ( ) ; } else { mTextRun = prev - > GetTextRun ( ) ; }
fclose ( orig ) ; fclose ( recons ) ; <START_VULN> if ( diffs != 0 ) <END_VULN> { return XD3_INTERNAL ; }
. release = ext3_release_file , . fsync = ext3_sync_file , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> } ; const struct inode_operations ext3_file_inode_operations = {
uchar * buf_ ; <START_VULN> int bufsize_ ; <END_VULN> int_fast32_t len_ ;
pkiDebug ( "found kdcPkId in AS REQ" ) ; is = d2i_PKCS7_ISSUER_AND_SERIAL ( NULL , & p , ( int ) pkid_len ) ; if ( is == NULL ) <START_VULN> goto cleanup ; <END_VULN> status = X509_NAME_cmp ( X509_get_issuer_name ( kdc_cert ) , is - > issuer ) ; if ( ! status ) {
regs - > loadrs = 0 ; regs - > r8 = get_dumpable ( current - > mm ) ; regs - > r12 = new_sp - 16 ; <START_VULN> if ( unlikely ( ! get_dumpable ( current - > mm ) ) ) { <END_VULN> int get_dumpable ( struct mm_struct * mm ) { return __get_dumpable ( mm - > flags ) ;
static __u8 * ch_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <START_VULN> if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) { <END_VULN> hid_info ( hdev , "fixing up Cherry Cymotion report descriptor" ) ; rdesc [ 11 ] = rdesc [ 16 ] = 0xff ; rdesc [ 12 ] = rdesc [ 17 ] = 0x03 ;
<START_VULN> if ( ( int ) np - > file - > basename_utf16 . length > ffmax ) { <END_VULN> if ( archive_strncpy_l ( & iso9660 - > mbs , ( const char * ) np - > identifier , l , iso9660 - > sconv_from_utf16be ) != 0 &&
zval_dtor ( * zcount ) ; ZVAL_LONG ( * zcount , replace_count ) ; } <START_VULN> <END_VULN> }
int ip6_find_1stfragopt ( struct sk_buff * skb , u8 ** nexthdr ) { <START_VULN> u16 offset = sizeof ( struct ipv6hdr ) ; <END_VULN> unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ;
RETVAL_BOOL ( phar_open_from_filename ( fname , fname_len , alias , alias_len , REPORT_ERRORS , NULL , & error TSRMLS_CC ) == SUCCESS ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } }
ext4_ext_show_leaf ( inode , path ) ; <START_VULN> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <END_VULN> ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ;
gss_ctx_id_t * context_handle , gss_buffer_t output_token ) { <START_VULN> OM_uint32 major_status = GSS_S_COMPLETE ; <END_VULN> if ( output_token != GSS_C_NO_BUFFER ) { output_token - > length = 0 ;
data . period = event - > hw . last_period ; <START_VULN> if ( perf_event_overflow ( event , 1 , & data , regs ) ) <END_VULN> x86_pmu_stop ( event , 0 ) ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : single - block PCM analysis mode dispatch <START_VULN> last mod : $ Id : analysis . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdio . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : PCM data vector blocking , windowing and disreassembly <START_VULN> last mod : $ Id : block . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> Handle windowing , overlap - add , etc of the PCM vectors . This is made more amusing by Vorbis' current two allowed block sizes . #include < stdio . h > #include < stdlib . h >
down_read ( & uts_sem ) ; res = sysinfo_table [ offset ] ; len = strlen ( res ) +1 ; <START_VULN> if ( len > count ) <END_VULN> len = count ; if ( copy_to_user ( buf , res , len ) ) err = - EFAULT ;
if ( len ) len -- ; if ( ! strncmp ( rock - > namespace - > prefix [ NAMESPACE_USER ] , commonpat , MIN ( len , prefixlen ) ) ) { <START_VULN> if ( prefixlen < len ) { <END_VULN> strlcpy ( domainpat+domainlen , "user . " , sizeof ( domainpat ) - domainlen ) ; }
len -= sizeof ( * io ) * nid ; io = ( struct id_off * ) ( id + 1 ) ; cp = ( char * ) ( io + nid ) ; <START_VULN> if ( ! ND_TTEST2 ( cp , len ) ) { <END_VULN> ND_PRINT ( ( ndo , """ ) ) ; fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; ND_PRINT ( ( ndo , """ ) ) ;
} <START_VULN> if ( pread ( fd , xsh_addr , xsh_sizeof , off + size * strtab ) == - 1 ) { <END_VULN> file_badread ( ms ) ; return - 1 ; }
} } ; <START_VULN> MODULE_ALIAS ( "sha384" ) ; <END_VULN> static int __init init ( void ) {
module_init ( sit_init ) ; module_exit ( sit_cleanup ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "sit0" ) ; <END_VULN>
cli_dbgmsg ( "cli_scanxar : can't scan xar files , need libxml2 . " ) ; #endif if ( cksum_fails + extract_errors != 0 ) { <START_VULN> cli_warnmsg ( "cli_scanxar : % u checksum errors and % u extraction errors , use -- debug for more info . " , <END_VULN> cksum_fails , extract_errors ) ; }
if ( current - > flags & PF_RANDOMIZE ) random_factor = arch_mmap_rnd ( ) ; <START_VULN> mm - > mmap_legacy_base = mmap_legacy_base ( random_factor ) ; <END_VULN> if ( mmap_is_legacy ( ) ) { mm - > mmap_base = mm - > mmap_legacy_base ;
payload = NULL ; <START_VULN> if ( _payload ) { <END_VULN> ret = - ENOMEM ; payload = kvmalloc ( plen , GFP_KERNEL ) ; if ( ! payload )
} if ( src != tmp_im ) { <START_VULN> gdFree ( tmp_im ) ; <END_VULN> } return dst ;
static PRUint32 GetWorkerCloseHandlerTimeoutMS ( ) ; PRBool QueueSuspendedWorker ( nsDOMWorkerRunnable * aRunnable ) ; nsCOMPtr < nsIThreadPool > mThreadPool ; <START_VULN> nsRefPtrHashtable < nsISupportsHashKey , nsDOMWorkerPool > mPools ; <END_VULN> PRMonitor * mMonitor ; nsRefPtrHashtable < nsVoidPtrHashKey , nsDOMWorkerRunnable > mWorkersInProgress ;
BOOL updaterIsCorrect ; if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) ) { LOG_WARN ( ( "Error checking if the updaters are the same . " "Path 1 : % lsPath 2 : % ls" , argv [ 0 ] , installDirUpdater ) ) ; result = FALSE ; } if ( result && ! updaterIsCorrect ) { <START_VULN> LOG_WARN ( ( "The updaters do not match , udpater will not run . " ) ) ; <END_VULN> result = FALSE ; } if ( result ) { LOG ( ( "updater . exe was compared successfully to the installation directory" " updater . exe . " ) ) ; } else { if ( ! WriteStatusFailure ( argv [ 1 ] , SERVICE_UPDATER_COMPARE_ERROR ) ) { LOG_WARN ( ( "Could not write update . status updater compare failure . " ) ) ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "Blowfish Cipher Algorithm" ) ; <START_VULN> MODULE_ALIAS ( "blowfish" ) ; <END_VULN>
#ifndef _TYPES_INCLUDED #define _TYPES_INCLUDED #include "compilerBaseTypes . h" #include "compilerCommon . h" <START_VULN> #include "compilerdebug . h"<END_VULN> class TType ; struct TTypeLine { TType * type ; int line ; rename from gfxanglesrccompilerdebug . cpp rename to gfxanglesrccompilercompilerdebug . cpp
. write_iter = generic_file_write_iter , . fsync = noop_fsync , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . llseek = generic_file_llseek , } ;
goto bail ; } <START_VULN> request_buf . length = mutt_b64_decode ( buf2 , idata - > buf + 2 ) ; <END_VULN> request_buf . value = buf2 ; sec_token = & request_buf ;
return ret ; } <START_VULN> static void ptrace_triggered ( struct perf_event * bp , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) {
ipaddr_string ( ndo , & ps - > page . p_sid ) , EXTRACT_32BITS ( & ps - > page . p_uid ) ) ) ; io = ( struct id_off * ) ( ps + 1 ) ; <START_VULN> for ( ie = io + ps - > nid ; io < ie && ! ND_TTEST ( * io ) ; ++ io ) { <END_VULN> ND_PRINT ( ( ndo , " % c % s : % u" , c , ipaddr_string ( ndo , & io - > id ) , EXTRACT_32BITS ( & io - > off ) ) ) ; c = ' , ' ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic codebook packunpackcodedecode operations <START_VULN> last mod : $ Id : codebook . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
return register_die_notifier ( & kgdb_notifier ) ; } <START_VULN> static void kgdb_hw_overflow_handler ( struct perf_event * event , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) { struct task_struct * tsk = current ;
list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { if ( cmd - > device - > sdev_target == my_cmd - > device - > sdev_target && cmd - > device - > lun == my_cmd - > device - > lun ) <START_VULN> sas_eh_defer_cmd ( cmd ) ; <END_VULN> } }
} if ( j >= ISDN_MSNLEN ) break ; } if ( ++ i > 9 ) break ; } } else { p = ( char __user * ) iocts . arg ; for ( i = 0 ; i < 10 ; i ++ ) { <START_VULN> sprintf ( bname , " % s % s" , <END_VULN> strlen ( dev - > drv [ drvidx ] - > msn2eaz [ i ] ) ? dev - > drv [ drvidx ] - > msn2eaz [ i ] : "_" , ( i < 9 ) ? " , " : "0" ) ; if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) ) return - EFAULT ; p + = strlen ( bname ) ; } } return 0 ; } else
seq_puts ( m , "key : " ) ; seq_puts ( m , key - > description ) ; <START_VULN> if ( key_is_instantiated ( key ) ) <END_VULN> seq_printf ( m , " pid : % d ci : % zu" , rka - > pid , rka - > callout_len ) ; }
#define OFFT_MAX ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) #define LINELEN 256 <START_VULN> #define BUFSIZE ( 1024 * 1024 ) <END_VULN> #define DIFFPAGESIZE 4096 #define F_READONLY 1 #define F_MULTIFILE 2
SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO ( 'T' , 0x23 ) , } ; <START_VULN> static long snd_timer_user_ioctl ( struct file * file , unsigned int cmd , <END_VULN> unsigned long arg ) { struct snd_timer_user * tu ;
bee_t * bee = ic - > bee ; bee_user_t * bu = bee_user_by_handle ( bee , ic , handle ) ; <START_VULN> if ( bee - > ui - > ft_in_start ) { <END_VULN> return bee - > ui - > ft_in_start ( bee , bu , file_name , file_size ) ; } else { return NULL ;
* done = true ; spin_unlock_irqrestore ( & lock , flags ) ; <START_VULN> __net_random_once_disable_jump ( done_key ) ; <END_VULN> return true ; }
cl_allowDownload = Cvar_Get ( "cl_allowDownload" , "0" , CVAR_ARCHIVE ) ; #ifdef USE_CURL_DLOPEN <START_VULN> cl_cURLLib = Cvar_Get ( "cl_cURLLib" , DEFAULT_CURL_LIB , CVAR_ARCHIVE ) ; <END_VULN> #endif cl_conXOffset = Cvar_Get ( "cl_conXOffset" , "0" , 0 ) ;
BUG_ON ( path [ depth ] . p_hdr == NULL ) ; <START_VULN> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <END_VULN> && ext4_can_extents_be_merged ( inode , ex , newext ) ) { ext_debug ( "append [ % d ] % d block to % d : [ % d ] % d ( from % llu ) " , ext4_ext_is_uninitialized ( newext ) ,
char * vorbis_comment_query ( vorbis_comment * vc , const char * tag , int count ) { long i ; int found = 0 ; int taglen = strlen ( tag ) +1 ; char * fulltag = alloca ( taglen+ 1 ) ; strcpy ( fulltag , tag ) ; strcat ( fulltag , " = " ) ; <START_VULN> <END_VULN> for ( i = 0 ; i < vc - > comments ; i ++ ) { if ( ! tagcompare ( vc - > user_comments [ i ] , fulltag , taglen ) ) { if ( count == found ) return vc - > user_comments [ i ] + taglen ; else found ++ ; }
if ( GC_IS_RECURSIVE ( ht ) ) { <START_VULN> ( ( SBucketType * ) ( buffer - > buffer + p ) ) - > data_type = IS_NULL ; <END_VULN> php_error_docref ( NULL TSRMLS_CC , E_NOTICE , "the array has cycle ref" ) ; } else
nsIAtom * aAttribute , PRInt32 aModType ) ; nsresult GetText ( nsString & aText ) ; NS_DECL_QUERYFRAME public : <START_VULN> void FireOnInput ( ) ; <END_VULN> void SetValueChanged ( PRBool aValueChanged ) ; nsresult InitFocusedValue ( ) ; void SetFireChangeEventState ( PRBool aNewState ) { mFireChangeEventState = aNewState ; }
either version 2 of the License or ( at your option ) any later version . #pragma once #include "graphite2Types . h" #define GR2_VERSION_MAJOR 1 #define GR2_VERSION_MINOR 1 <START_VULN> #define GR2_VERSION_BUGFIX 2<END_VULN> #ifdef __cplusplus extern "C" { #endif typedef struct gr_face gr_face ; typedef struct gr_font gr_font ;
alternative_input ( "1 : " XRSTOR , <START_VULN> "1 : " XRSTORS , <END_VULN> X86_FEATURE_XSAVES , "D" ( fx ) , "m" ( * fx ) , "a" ( lmask ) , "d" ( hmask ) : "memory" ) ;
return ZEND_HASH_APPLY_STOP ; } <START_VULN> fname_len = ( php_stat_len ) strlen ( fname ) ; <END_VULN> save = fname ; goto phar_spl_fileinfo ; }
tp [ 0 ] = '0' ; add_assoc_string ( * subarray , "ipv6" , name , 1 ) ; if ( cp < p + dlen ) { <START_VULN> n = dn_expand ( answer - > qb2 , answer - > qb2+65536 , cp , name , ( sizeof name ) - 2 ) ; <END_VULN> if ( n < 0 ) { return NULL ; }
. open = stack_trace_filter_open , . read = seq_read , . write = ftrace_filter_write , <START_VULN> . llseek = ftrace_regex_lseek , <END_VULN> . release = ftrace_regex_release , } ;
#define MAJOR_VERSION 0 #define MINOR_VERSION 0 #define BUILD_VERSION 0 <START_VULN> #define BUILD_REVISION 740<END_VULN> #define STRINGIFY ( x ) #x #define MACRO_STRINGIFY ( x ) STRINGIFY ( x ) #define REVISION_STRING MACRO_STRINGIFY ( BUILD_REVISION ) #define VERSION_STRING MACRO_STRINGIFY ( MAJOR_VERSION ) " . " MACRO_STRINGIFY ( MINOR_VERSION ) " . " MACRO_STRINGIFY ( BUILD_VERSION ) " . " MACRO_STRINGIFY ( BUILD_REVISION )
static void dns_resolver_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key - > description ) ; <START_VULN> if ( key_is_instantiated ( key ) ) { <END_VULN> int err = PTR_ERR ( key - > payload . data [ dns_key_error ] ) ; if ( err )
SECURITY_STATUS SEC_ENTRY DeleteSecurityContext ( PCtxtHandle phContext ) { <START_VULN> char * Name ; <END_VULN> SECURITY_STATUS status ; SecurityFunctionTableA * table ;
fdbname , fmtId ( dbtablespace ) ) ; <START_VULN> appendPQExpBuffer ( buf , "connect % s" , fdbname ) ; <END_VULN> } if ( binary_upgrade )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis backend and mapping structures ; needed for static mode headers <START_VULN> last mod : $ Id : backends . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _vorbis_backend_h_
struct ipc_rcu_hdr { <START_VULN> int refcount ; <END_VULN> int is_vmalloc ; void * data [ 0 ] ; } ;
struct rpc_cred * cred ; struct nfs4_state * state ; fl_owner_t lockowner ; <START_VULN> int mode ; <END_VULN> unsigned long flags ; #define NFS_CONTEXT_ERROR_WRITE ( 0 )
void ( * reset ) ( int dev ) ; void ( * hw_control ) ( int dev , unsigned char * event ) ; int ( * load_patch ) ( int dev , int format , const char __user * addr , <START_VULN> int offs , int count , int pmgr_flag ) ; <END_VULN> void ( * aftertouch ) ( int dev , int voice , int pressure ) ; void ( * controller ) ( int dev , int voice , int ctrl_num , int value ) ; void ( * panning ) ( int dev , int voice , int value ) ;
parent_inode , & key , BTRFS_FT_DIR , index ) ; <START_VULN> BUG_ON ( ret == - EEXIST ) ; <END_VULN> if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; commit 9c52057c698fb96f8f07e7a4bcf4801a092bda89 Author : Chris Mason < chris . mason@fusionio . com > Date : Mon Dec 17 14 : 26 : 57 2012 - 0500 Btrfs : fix hash overflow handling The handling for directory crc hash overflows was fairly obscure , split_leaf returns EOVERFLOW when we try to extend the item and that is supposed to bubble up to userland . For a while it did so , but along the way we added better handling of errors and forced the FS readonly if we hit IO errors during the directory insertion . Along the way , we started testing only for EEXIST and the EOVERFLOW case was dropped . The end result is that we may force the FS readonly if we catch a directory hash bucket overflow . This fixes a few problem spots . First I add tests for EOVERFLOW in the places where we can safely just return the error up the chain . btrfs_rename is harder though , because it tries to insert the new directory item only after it has already unlinked anything the rename was going to overwrite . Rather than adding very complex logic , I added a helper to test for the hash overflow case early while it is still safe to bail out . Snapshot and subvolume creation had a similar problem , so they are using the new helper now too . Signed - off - by : Chris Mason < chris . mason@fusionio . com > Reported - by : Pascal Junod < pascal@junod . info >
tidx = i ; break ; } } } if ( src_end - src < 2 ) return 0 ; zsize = ( src [ 0 ] << 8 ) | src [ 1 ] ; src + = 2 ; <START_VULN> if ( src_end - src < zsize ) <END_VULN> return AVERROR_INVALIDDATA ; ret = uncompress ( c - > kempf_buf , & dlen , src , zsize ) ; if ( ret ) return AVERROR_INVALIDDATA ; src + = zsize ; if ( sub_type == 2 ) { kempf_restore_buf ( c - > kempf_buf , dlen , dst , c - > framebuf_stride , NULL , 0 , width , height , pal , npal , tidx ) ;
if ( event - > attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ; <START_VULN> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <END_VULN> power_pmu_stop ( event , 0 ) ; } }
static u32 challenge_timestamp ; static unsigned int challenge_count ; struct tcp_sock * tp = tcp_sk ( sk ) ; <START_VULN> u32 now ; <END_VULN> if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb ,
frame - > width = w ; frame - > height = h ; <START_VULN> for ( plane = 0 ; plane < 4 && frame - > data [ plane ] ; plane ++ ) { <END_VULN> int hsub = s - > draw . hsub [ plane ] ; int vsub = s - > draw . vsub [ plane ] ; frame - > data [ plane ] + = ( s - > x >> hsub ) * s - > draw . pixelstep [ plane ] +
{ unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; int first_key = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; <START_VULN> sprintf ( op - > buf_asm , "packed - switch - payload % d , % d" , array_size , first_key ) ; <END_VULN> size = 8 ; payload = 2 * ( array_size * 2 ) ; len = 0 ;
nsIPrincipal * originPrincipal , nsISupports * context , const nsACString & mimeType , nsISupports * extra , int16_t * decision , nsIContentPolicy * policyService = nullptr , nsIScriptSecurityManager * aSecMan = nullptr ) { <START_VULN> CHECK_PRINCIPAL ; <END_VULN> if ( policyService ) { CHECK_CONTENT_POLICY_WITH_SERVICE ( ShouldProcess , policyService ) ; } CHECK_CONTENT_POLICY ( ShouldProcess ) ; } #undef CHECK_CONTENT_POLICY #undef CHECK_CONTENT_POLICY_WITH_SERVICE
#else ctl - > pw - > pw_gecos = gecos ; <START_VULN> if ( setpwnam ( ctl - > pw ) < 0 ) { <END_VULN> warn ( "setpwnam failed" ) ; #endif printf ( _
switch ( intern - > type ) { case SPL_FS_DIR : test = spl_filesystem_object_get_path ( intern , NULL ) ; <START_VULN> fname_len = ( php_stat_len ) spprintf ( & fname , 0 , " % s % c % s" , test , DEFAULT_SLASH , intern - > u . dir . entry . d_name ) ; <END_VULN> php_stat ( fname , fname_len , FS_IS_DIR , & dummy ) ; if ( Z_TYPE ( dummy ) == IS_TRUE ) {
asoc - > state , asoc - > ep , asoc , transport , GFP_ATOMIC ) ; out_unlock : <START_VULN> bh_unlock_sock ( asoc - > base . sk ) ; <END_VULN> sctp_association_put ( asoc ) ; }
float * ath ; long * octave ; long * bark ; long firstoc ; long shiftoc ; int eighth_octave_lines ; <START_VULN> int total_octave_lines ; <END_VULN> long rate ; float m_val ; } vorbis_look_psy ; extern void _vp_psy_init ( vorbis_look_psy * p , vorbis_info_psy * vi , vorbis_info_psy_global * gi , int n , long rate ) ;
MediaByteRange const & aByteRange ) ; virtual nsresult Close ( ) ; virtual void Suspend ( bool aCloseImmediately ) ; virtual void Resume ( ) ; virtual already_AddRefed < nsIPrincipal > GetCurrentPrincipal ( ) ; bool IsClosed ( ) const { return mCacheStream . IsClosed ( ) ; } virtual bool CanClone ( ) ; <START_VULN> virtual MediaResource * CloneData ( MediaDecoder * aDecoder ) ; <END_VULN> void RecordStatisticsTo ( MediaChannelStatistics * aStatistics ) MOZ_OVERRIDE { NS_ASSERTION ( aStatistics , "Statistics param cannot be null ! " ) ; MutexAutoLock lock ( mLock ) ; if ( ! mChannelStatistics ) { mChannelStatistics = aStatistics ; }
zend_throw_exception_ex ( NULL , 0 , "can not find class % s" , class_name - > val TSRMLS_CC ) ; return NULL ; } <START_VULN> <END_VULN> zend_string * fname = swoole_string_init ( ZEND_STRL ( PG ( unserialize_callback_func ) ) ) ; Z_STR ( user_func ) = fname ; Z_TYPE_INFO ( user_func ) = IS_STRING_EX ;
skb_shinfo ( skb ) - > gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) - > gso_type = SKB_GSO_UDP ; <START_VULN> ipv6_select_ident ( & fhdr ) ; <END_VULN> skb_shinfo ( skb ) - > ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk - > sk_write_queue , skb ) ;
void RequestDecode ( RasterImage * aImg ) ; <START_VULN> void DecodeABitOf ( RasterImage * aImg ) ; <END_VULN>
if ( R - offset < noise [ i ] ) noise [ i ] = R - offset ; } for ( ; i < n ; i ++ , x + = 1 . f ) { R = ( A + x * B ) D ; if ( R - offset < noise [ i ] ) noise [ i ] = R - offset ; } } <START_VULN> static float FLOOR1_fromdB_INV_LOOKUP [ 256 ] = { <END_VULN> 0 . F , 8 . 81683e+06F , 8 . 27882e+06F , 7 . 77365e+06F , 7 . 29930e+06F , 6 . 85389e+06F , 6 . 43567e+06F , 6 . 04296e+06F , 5 . 67422e+06F , 5 . 32798e+06F , 5 . 00286e+06F , 4 . 69759e+06F , 4 . 41094e+06F , 4 . 14178e+06F , 3 . 88905e+06F , 3 . 65174e+06F , 3 . 42891e+06F , 3 . 21968e+06F , 3 . 02321e+06F , 2 . 83873e+06F , 2 . 66551e+06F , 2 . 50286e+06F , 2 . 35014e+06F , 2 . 20673e+06F , 2 . 07208e+06F , 1 . 94564e+06F , 1 . 82692e+06F , 1 . 71544e+06F , 1 . 61076e+06F , 1 . 51247e+06F , 1 . 42018e+06F , 1 . 33352e+06F ,
} <START_VULN> static void phar_file_stat ( const char * filename , php_stat_len filename_length , int type , void ( * orig_stat_func ) ( INTERNAL_FUNCTION_PARAMETERS ) , INTERNAL_FUNCTION_PARAMETERS ) <END_VULN> { if ( ! filename_length ) { RETURN_FALSE ;
typedef struct { int nfats ; off_t fat_start ; <START_VULN> unsigned int fat_size ; <END_VULN> unsigned int fat_bits ; unsigned int eff_fat_bits ; uint32_t root_cluster ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis codec headers <START_VULN> last mod : $ Id : codec . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _vorbis_codec_h_ #define _vorbis_codec_h_ #ifdef __cplusplus extern "C"
ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <START_VULN> if ( ! ctx - > established ) <END_VULN> return GSS_S_NO_CONTEXT ; for ( i = 0 ; i < sizeof ( krb5_gss_inquire_sec_context_by_oid_ops )
if ( c - > argc >= 4 ) { robj * o = lookupKeyWriteOrReply ( c , c - > argv [ 2 ] , shared . nokeyerr ) ; <START_VULN> if ( o == NULL ) return ; <END_VULN> s = o - > ptr ; grpname = c - > argv [ 3 ] - > ptr ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 104 20141017 15 : 49 : 00 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
void mdct_clear ( mdct_lookup * l ) { if ( l ) { if ( l - > trig ) _ogg_free ( l - > trig ) ; if ( l - > bitrev ) _ogg_free ( l - > bitrev ) ; memset ( l , 0 , sizeof ( * l ) ) ; } } <START_VULN> STIN void mdct_bitreverse ( mdct_lookup * init , <END_VULN> DATA_TYPE * x ) { int n = init - > n ; int * bit = init - > bitrev ; DATA_TYPE * w0 = x ; DATA_TYPE * w1 = x = w0+ ( n >> 1 ) ; DATA_TYPE * T = init - > trig+n ; do {
extern int rose_validate_nr ( struct sock * , unsigned short ) ; extern void rose_write_internal ( struct sock * , int ) ; extern int rose_decode ( struct sk_buff * , int * , int * , int * , int * , int * ) ; <START_VULN> extern int rose_parse_facilities ( unsigned char * , struct rose_facilities_struct * ) ; <END_VULN> extern void rose_disconnect ( struct sock * , int , int , int ) ;
#ifndef _V_LSP_H_ #define _V_LSP_H_ extern int vorbis_lpc_to_lsp ( float * lpc , float * lsp , int m ) ; extern void vorbis_lsp_to_curve ( float * curve , int * map , int n , int ln , float * lsp , int m , float amp , float ampoffset ) ; <START_VULN> <END_VULN> #endif
parent_inode , & key , BTRFS_FT_DIR , index ) ; <START_VULN> BUG_ON ( ret == - EEXIST ) ; <END_VULN> if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ;
break ; tag_value = ( ssize_t ) ReadProfileShort ( endian , q ) ; format = ( ssize_t ) ReadProfileShort ( endian , q+2 ) ; <START_VULN> if ( ( format - 1 ) >= EXIF_NUM_FORMATS ) <END_VULN> break ; components = ( ssize_t ) ReadProfileLong ( endian , q+4 ) ; if ( components < 0 )
private int cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info , <START_VULN> size_t count , const uint64_t clsid [ 2 ] ) <END_VULN> { size_t i ; cdf_timestamp_t tp ;
PRUint32 mPreferredWidth ; PRUint32 mPreferredHeight ; private : PRBool IsVisible ( ) ; void GetToplevelWidget ( GtkWidget ** aWidget ) ; GtkWidget * GetMozContainerWidget ( ) ; <START_VULN> void GetContainerWindow ( nsWindow ** aWindow ) ; <END_VULN> void SetUrgencyHint ( GtkWidget * top_window , PRBool state ) ; void * SetupPluginPort ( void ) ; nsresult SetWindowIconList ( const nsTArray < nsCString > & aIconList ) ; void SetDefaultIcon ( void ) ; void InitButtonEvent ( nsMouseEvent & aEvent , GdkEventButton * aGdkEvent ) ; PRBool DispatchCommandEvent ( nsIAtom * aCommand ) ; GtkWidget * mShell ;
} ; static const struct gprefix pfx_0f_ae_7 = { <START_VULN> I ( 0 , em_clflush ) , N , N , N , <END_VULN> } ; static const struct group_dual group15 = { {
if ( signature - > type == V_ASN1_BIT_STRING && signature - > flags & 0x7 ) { <START_VULN> ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <END_VULN> return - 1 ; }
void * regs ; gpa_t vapic_addr ; <START_VULN> struct page * vapic_page ; <END_VULN> unsigned long pending_events ; unsigned int sipi_vector ; } ;
goto found ; entry = next ; } <START_VULN> if ( ext2_xattr_cache_insert ( bh ) ) <END_VULN> ea_idebug ( inode , "cache insert failed" ) ; error = - ENODATA ; goto cleanup ;
goto err ; } <START_VULN> len = file ? file - > size : 4096 ; <END_VULN> p = realloc ( * data , len ) ; if ( ! p ) { goto err ;
conn - > current_result = NULL ; } while ( 0 ) ; <START_VULN> conn - > m - > local_tx_end ( conn , this_func , result == NULL ? FAIL : PASS TSRMLS_CC ) ; <END_VULN> } DBG_RETURN ( result ) ; }
BIO_free ( f ) ; f = tbio ; } <START_VULN> while ( f != upto ) ; <END_VULN> } else BIO_free_all ( f ) ;
( * JSGCCallback ) ( JSRuntime * rt , JSGCStatus status ) ; typedef enum JSFinalizeStatus { JSFINALIZE_START , JSFINALIZE_END } JSFinalizeStatus ; typedef void <START_VULN> ( * JSFinalizeCallback ) ( JSFreeOp * fop , JSFinalizeStatus status ) ; <END_VULN> typedef void ( * JSTraceDataOp ) ( JSTracer * trc , void * data ) ;
} phar_flush ( phar_obj - > arc . archive , ( char * ) & zstub , len , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } RETURN_TRUE ;
struct inode * inode , const char * name , const void * value , size_t size , int flags ) { <START_VULN> struct btrfs_dir_item * di ; <END_VULN> struct btrfs_root * root = BTRFS_I ( inode ) - > root ; struct btrfs_path * path ; size_t name_len = strlen ( name ) ;
if ( ret < 0 ) hid_err ( hdev , "error setting GPIO values : % d" , ret ) ; <START_VULN> spin_unlock_irqrestore ( & dev - > lock , flags ) ; <END_VULN> } static int cp2112_gpio_get_all ( struct gpio_chip * chip )
* <START_VULN> <END_VULN> #include "ssl . h" #include "sslimpl . h" #include "sslproto . h" static const char * ssl_GetCompressionMethodName ( SSLCompressionMethod compression ) { switch ( compression ) {
long n = look - > n ; long posts = look - > posts ; long nonzero = 0 ; lsfit_acc fits [ VIF_POSIT+1 ] ; int fit_valueA [ VIF_POSIT+2 ] ; int fit_valueB [ VIF_POSIT+2 ] ; int loneighbor [ VIF_POSIT+2 ] ; <START_VULN> int hineighbor [ VIF_POSIT+2 ] ; <END_VULN> int * output = NULL ; int memo [ VIF_POSIT+2 ] ; for ( i = 0 ; i < posts ; i ++ ) fit_valueA [ i ] = - 200 ; for ( i = 0 ; i < posts ; i ++ ) fit_valueB [ i ] = - 200 ; for ( i = 0 ; i < posts ; i ++ ) loneighbor [ i ] = 0 ; for ( i = 0 ; i < posts ; i ++ ) hineighbor [ i ] = 1 ; for ( i = 0 ; i < posts ; i ++ ) memo [ i ] = - 1 ;
tag = data [ dp ++ ] ; <START_VULN> if ( tag == 0 ) { <END_VULN> if ( data [ dp ++ ] != 0 ) goto invalid_eoc ;
int b = buf [ 0 ] & 0x7 ; int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ; <START_VULN> RAnalOp next_op ; <END_VULN>
static nsresult CVE_2013_1705_cryptojs_ReadArgsAndGenerateKey ( JSContext * cx , jsval * argv , nsKeyPairInfo * keyGenType , nsIInterfaceRequestor * uiCxt , PK11SlotInfo ** slot , bool willEscrow ) { JSString * jsString ; <START_VULN> JSAutoByteString params , keyGenAlg ; <END_VULN> int keySize ; nsresult rv ; if ( ! JSVAL_IS_INT ( argv [ 0 ] ) ) { JS_ReportError ( cx , " % s % s" , JS_ERROR , "passed in non - integer for key size" ) ; return NS_ERROR_FAILURE ; } keySize = JSVAL_TO_INT ( argv [ 0 ] ) ; if ( ! JSVAL_IS_NULL ( argv [ 1 ] ) ) {
if ( pv - > context - > extradata == NULL ) { <START_VULN> if ( pv - > parser == NULL || pv - > parser == NULL || <END_VULN> pv - > parser - > parser - > split == NULL ) { return 0 ;
. open = ftrace_notrace_open , . read = seq_read , . write = ftrace_notrace_write , <START_VULN> . llseek = ftrace_regex_lseek , <END_VULN> . release = ftrace_regex_release , } ;
if ( preg_options ) { * preg_options = pce ? pce - > preg_options : 0 ; } <START_VULN> <END_VULN> return pce ? pce - > re : NULL ; }
destroy_bio ( struct bio * bio ) { pthread_cond_destroy ( & bio - > bio_wait ) ; <START_VULN> <END_VULN> free ( bio ) ; }
if ( likely ( atomic_inc_not_zero ( & sk - > sk_refcnt ) ) ) { * skb_hwtstamps ( skb ) = * hwtstamps ; <START_VULN> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <END_VULN> sock_put ( sk ) ; } }
exit : mutex_unlock ( & dev - > lock ) ; <START_VULN> return ret <= 0 ? ret : - EIO ; <END_VULN> } static void cp2112_gpio_set ( struct gpio_chip * chip , unsigned offset , int value )
NULL , 0 , 0 , 0 , 0 , 0 , NULL , NULL , NULL , NULL , 0 } ; static float * test1_result = NULL ; <START_VULN> <END_VULN> static_codebook test2 = { 4 , 3 , NULL , 2 , - 533200896 , 1611661312 , 4 , 0 , full_quantlist1 , NULL , NULL , NULL ,
Z_PARAM_PATH ( filename , filename_len ) ZEND_PARSE_PARAMETERS_END ( ) ; <START_VULN> php_stat ( filename , ( php_stat_len ) filename_len , funcnum , return_value ) ; <END_VULN> }
static int open_unix_listener ( h2o_configurator_command_t * cmd , yoml_t * node , struct sockaddr_un * sa ) { struct stat st ; <START_VULN> int fd ; <END_VULN> struct passwd * owner = NULL , pwbuf ; char pwbuf_buf [ 65536 ] ; unsigned mode = UINT_MAX ;
for ( i = 0 ; i < numcmpts ; ++ i ) { if ( jas_image_readcmpt ( image , cmpts [ i ] , 0 , y , jas_image_width ( image ) , 1 , data [ i ] ) ) { <START_VULN> return - 1 ; <END_VULN> } } z = 0 ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : modified discrete cosine transform prototypes <START_VULN> last mod : $ Id : mdct . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _OGG_mdct_H_ #define _OGG_mdct_H_ #include "vorbiscodec . h"
return bdev ; fail : <START_VULN> ext3_msg ( sb , "error : failed to open journal device % s : % ld" , <END_VULN> __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ; return NULL ;
const struct xt_entry_target * t ; unsigned int verdict ; <START_VULN> if ( ! unconditional ( & e - > ip ) ) <END_VULN> return false ; t = ipt_get_target_c ( e ) ; if ( strcmp ( t - > u . user . name , XT_STANDARD_TARGET ) != 0 )
g_free ( strmbuf ) ; g_free ( compr ) ; g_free ( uncompr ) ; return NULL ; } } else { inflateEnd ( strm ) ; g_free ( strm ) ; g_free ( strmbuf ) ; <START_VULN> g_free ( compr ) ; <END_VULN> if ( uncompr == NULL ) { return NULL ; } break ; } } #ifdef TVB_Z_DEBUG printf ( "inflate ( ) total passes : % u" , inflate_passes ) ; printf ( "bytes in : % ubytes out : % u" , bytes_in , bytes_out ) ;
#include < stdlib . h > #include < stdio . h > #include < string . h > <START_VULN> #include "compilerdebug . h"<END_VULN> #include "compilerpreprocessorslglobals . h" #undef malloc #undef realloc #undef free
if ( ! is_irq_none ( vdev ) ) return - EINVAL ; <START_VULN> vdev - > ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <END_VULN> if ( ! vdev - > ctx ) return - ENOMEM ; commit 05692d7005a364add85c6e25a6c4447ce08f913a Author : Vlad Tsyrklevich < vlad@tsyrklevich . net > Date : Wed Oct 12 18 : 51 : 24 2016 +0200 vfiopci : Fix integer overflows , bitmask check The VFIO_DEVICE_SET_IRQS ioctl did not sufficiently sanitize user - supplied integers , potentially allowing memory corruption . This patch adds appropriate integer overflow checks , checks the range bounds for VFIO_IRQ_SET_DATA_NONE , and also verifies that only single element in the VFIO_IRQ_SET_DATA_TYPE_MASK bitmask is set . VFIO_IRQ_SET_ACTION_TYPE_MASK is already correctly checked later in vfio_pci_set_irqs_ioctl ( ) . Furthermore , a kzalloc is changed to a kcalloc because the use of a kzalloc with an integer multiplication allowed an integer overflow condition to be reached without this patch . kcalloc checks for overflow and should prevent a similar occurrence . Signed - off - by : Vlad Tsyrklevich < vlad@tsyrklevich . net > Signed - off - by : Alex Williamson < alex . williamson@redhat . com >
} atomic_dec ( & key - > user - > nkeys ) ; <START_VULN> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key - > flags ) ) <END_VULN> atomic_dec ( & key - > user - > nikeys ) ; key_user_put ( key - > user ) ;
ogg_sync_wrote ( & oy , next - buf ) ; while ( 1 ) { int ret = ogg_sync_pageout ( & oy , & og_de ) ; if ( ret == 0 ) break ; if ( ret < 0 ) continue ; <START_VULN> fprintf ( stderr , " ( % ld ) , " , pageout ) ; <END_VULN> check_page ( data+deptr , headers [ pageout ] , & og_de ) ; deptr+ = og_de . body_len ; pageout ++ ; ogg_stream_pagein ( & os_de , & og_de ) ;
if ( r ) { printk ( KERN_ERR "kvm_iommu_map_address : " "iommu failed to map pfn = % llx" , pfn ) ; <START_VULN> kvm_unpin_pages ( kvm , pfn , page_size ) ; <END_VULN> goto unmap_pages ; }
m_pos + = 8 ; } while ( op < oe ) ; op = oe ; <START_VULN> if ( HAVE_IP ( 6 ) ) { <END_VULN> state = next ; COPY4 ( op , ip ) ; op + = next ;
virtual already_AddRefed < mozilla : : dom : : UndoManager > GetUndoManager ( ) ; virtual bool UndoScope ( ) MOZ_OVERRIDE ; virtual void SetUndoScope ( bool aUndoScope , mozilla : : ErrorResult & aError ) MOZ_OVERRIDE ; nsresult ClearDataset ( ) ; <START_VULN> nsSize GetWidthHeightForImage ( imgIRequest * aImageRequest ) ; <END_VULN> NS_FORWARD_NSIDOMNODE_TO_NSINODE NS_FORWARD_NSIDOMELEMENT_TO_GENERIC NS_IMETHOD GetId ( nsAString & aId ) MOZ_FINAL { mozilla : : dom : : Element : : GetId ( aId ) ;
vorbis_info * vi = v - > vi ; codec_setup_info * ci = vi - > codec_setup ; int hs = ci - > halfrate_flag ; private_state * b = v - > backend_state ; if ( b - > window [ W ] - 1 < 0 ) return NULL ; return _vorbis_window_get ( b - > window [ W ] - hs ) ; } <START_VULN> <END_VULN>
unsigned int mc_saved_count = mc_saved_data - > mc_saved_count ; int i ; <START_VULN> while ( leftover ) { <END_VULN> mc_header = ( struct microcode_header_intel * ) ucode_ptr ; mc_size = get_totalsize ( mc_header ) ;
DeletionConfirmationDlg ( QWidget * parent , const int & size , const QString & name , bool defaultDeleteFiles ) : QDialog ( parent ) { setupUi ( this ) ; if ( size == 1 ) <START_VULN> label - > setText ( tr ( "Are you sure you want to delete ' % 1' from the transfer list ? " , "Are you sure you want to delete 'ubuntu - linux - iso' from the transfer list ? " ) . arg ( name ) ) ; <END_VULN> else label - > setText ( tr ( "Are you sure you want to delete these % 1 torrents from the transfer list ? " , "Are you sure you want to delete these 5 torrents from the transfer list ? " ) . arg ( QString : : number ( size ) ) ) ;
struct net_device * dev ; struct sock * sk = sock - > sk ; if ( peer ) return - EOPNOTSUPP ; uaddr - > sa_family = AF_PACKET ; rcu_read_lock ( ) ; dev = dev_get_by_index_rcu ( sock_net ( sk ) , pkt_sk ( sk ) - > ifindex ) ; if ( dev ) <START_VULN> strlcpy ( uaddr - > sa_data , dev - > name , 15 ) ; <END_VULN> else memset ( uaddr - > sa_data , 0 , 14 ) ; rcu_read_unlock ( ) ; * uaddr_len = sizeof ( * uaddr ) ; return 0 ; }
ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <START_VULN> mutt_bcache_del ( pop_data - > bcache , ctx - > hdrs [ i ] - > data ) ; <END_VULN> #ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx - > hdrs [ i ] - > data , strlen ( ctx - > hdrs [ i ] - > data ) ) ; #endif commit 9bfab35522301794483f8f9ed60820bdec9be59e Author : Richard Russon < rich@flatcap . org > Date : Thu Jul 5 13 : 32 : 17 2018 +0100 sanitise cache paths Co - authored - by : JerikoOne < jeriko . one@gmx . us >
err = blkdev_issue_discard ( bdev , req - > u . discard . sector_number , req - > u . discard . nr_sectors , GFP_KERNEL , secure ) ; <START_VULN> <END_VULN> if ( err == - EOPNOTSUPP ) { pr_debug ( DRV_PFX "discard op failed , not supported" ) ; status = BLKIF_RSP_EOPNOTSUPP ;
extern intip_build_and_send_pkt ( struct sk_buff * skb , struct sock * sk , __be32 saddr , __be32 daddr , <START_VULN> struct ip_options * opt ) ; <END_VULN> extern intip_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) ; extern intip_local_deliver ( struct sk_buff * skb ) ;
MODULE_AUTHOR ( "Clay Haapala < chaapala@cisco . com > " ) ; MODULE_DESCRIPTION ( "CRC32c ( Castagnoli ) calculations wrapper for libcrc32c" ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "crc32c" ) ; <END_VULN> MODULE_SOFTDEP ( "pre : crc32c" ) ;
if ( unlikely ( file - > f_flags & __O_TMPFILE ) ) { error = do_tmpfile ( dfd , pathname , nd , flags , op , file , & opened ) ; <START_VULN> goto out ; <END_VULN> } error = path_init ( dfd , pathname , flags , nd ) ;
PHPAPI char * xml_utf8_decode ( const XML_Char * s , int len , int * newlen , const XML_Char * encoding ) { <START_VULN> int pos = len ; <END_VULN> char * newbuf = emalloc ( len + 1 ) ; unsigned int c ; char ( * decoder ) ( unsigned short ) = NULL ;
boolneedquotes ; <START_VULN> needquotes = false ; <END_VULN> for ( s = str ; * s ; s ++ ) { if ( ! ( ( * s >= 'a' && * s <= 'z' ) || ( * s >= 'A' && * s <= 'Z' ) ||
guint16 CVE_2014_5163_de_sm_apn ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) { guint32curr_offset ; guintcurr_len ; guint8str [ MAX_APN_LENGTH+1 ] ; curr_offset = offset ; <START_VULN> memset ( str , 0 , MAX_APN_LENGTH ) ; <END_VULN> tvb_memcpy ( tvb , str , offset , len < MAX_APN_LENGTH ? len : MAX_APN_LENGTH ) ; curr_len = 0 ; while ( ( curr_len < len ) && ( curr_len < MAX_APN_LENGTH ) ) { guint step = str [ curr_len ] ; str [ curr_len ] = ' . ' ; curr_len + = step+1 ; }
* * NET_RX_SUCCESS ( no congestion ) <START_VULN> * NET_RX_DROP ( packet was dropped ) <END_VULN> *
struct timespec64 ts64 ; bool sig_none ; <START_VULN> sig_none = ( timr - > it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <END_VULN> iv = timr - > it_interval ;
#if defined ( MSDOS ) || defined ( WIN32 ) <START_VULN> char * sanitize_dos_name ( char * file_name ) ; <END_VULN> #if defined ( MSDOS ) && ( defined ( __DJGPP__ ) || defined ( __GO32__ ) )
phar_obj - > arc . archive - > ufp = pass . fp ; phar_flush ( phar_obj - > arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } } else {
} <START_VULN> err = __video_do_ioctl ( file , cmd , parg ) ; <END_VULN> if ( err == - ENOIOCTLCMD ) err = - EINVAL ;
else h - > is_streamed = 1 ; <START_VULN> s - > filesize = - 1 ; <END_VULN> s - > location = av_strdup ( uri ) ; if ( ! s - > location ) return AVERROR ( ENOMEM ) ;
if ( unlikely ( req - > src != req - > dst ) ) { scatterwalk_start ( & dst_sg_walk , req - > dst ) ; dst = scatterwalk_map ( & dst_sg_walk ) ; } } else { src = kmalloc ( req - > cryptlen + req - > assoclen , GFP_ATOMIC ) ; if ( ! src ) return - ENOMEM ; <START_VULN> assoc = ( src + req - > cryptlen + auth_tag_len ) ; <END_VULN> scatterwalk_map_and_copy ( src , req - > src , 0 , req - > cryptlen , 0 ) ; scatterwalk_map_and_copy ( assoc , req - > assoc , 0 , req - > assoclen , 0 ) ; dst = src ; } aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx - > hash_subkey , assoc , ( unsigned long ) req - > assoclen , authTag , auth_tag_len ) ;
print_res_top ( result ) ; if ( opt_show_keys ) { <START_VULN> end = strmov ( strmov ( strmov ( query , "show keys from `" ) , table ) , "`" ) ; <END_VULN> if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , " % s : Cannot list keys in db : % s , table : % s : % s" ,
char * password = * passptr ; <START_VULN> if ( ! ( mask & KADM5_ATTRIBUTES ) || <END_VULN> ! ( entry - > attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ;
num = ( rem_sz > scatter_elem_sz_prev ) ? scatter_elem_sz_prev : rem_sz ; <START_VULN> schp - > pages [ k ] = alloc_pages ( gfp_mask , order ) ; <END_VULN> if ( ! schp - > pages [ k ] ) goto out ;
struct ipv6_ac_socklist * ipv6_ac_list ; struct ipv6_fl_socklist __rcu * ipv6_fl_list ; <START_VULN> struct ipv6_txoptions * opt ; <END_VULN> struct sk_buff * pktoptions ; struct sk_buff * rxpmtu ; struct inet6_corkcork ;
<START_VULN> static int ocfs2_dio_get_block ( struct inode * inode , sector_t iblock , <END_VULN> struct buffer_head * bh_result , int create ) { struct ocfs2_super * osb = OCFS2_SB ( inode - > i_sb ) ;
efree ( error ) ; goto valid_alias ; } <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; RETURN_FALSE ; }
Find pathnames matching a pattern * PHP_FUNCTION ( glob ) { <START_VULN> int cwd_skip = 0 ; <END_VULN> #ifdef ZTS char cwd [ MAXPATHLEN ] ; char work_pattern [ MAXPATHLEN ] ;
return - ENETUNREACH ; } <START_VULN> if ( inet - > opt == NULL || ! inet - > opt - > srr ) <END_VULN> daddr = rt - > rt_dst ; if ( inet - > inet_saddr == 0 )
} else { int plane ; <START_VULN> for ( plane = 0 ; plane < 4 && in - > data [ plane ] ; plane ++ ) { <END_VULN> uint8_t * dst = out - > data [ plane ] ; const uint8_t * src = in - > data [ plane ] ; const float * fmap = s - > fmap ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : residue backend 0 , 1 and 2 implementation <START_VULN> last mod : $ Id : res0 . c 16327 2009 - 07 - 24 00 : 49 : 25Z xiphmont $ <END_VULN>
static bool generic_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { <START_VULN> return true ; <END_VULN> } #if IS_ENABLED ( CONFIG_NF_CT_NETLINK_TIMEOUT )
fh - > nexthdr = nexthdr ; fh - > reserved = 0 ; if ( ! frag_id ) { <START_VULN> ipv6_select_ident ( fh ) ; <END_VULN> frag_id = fh - > identification ; } else fh - > identification = frag_id ;
return false ; } link_shdr = & bin - > shdr [ shdr - > sh_link ] ; <START_VULN> if ( shdr - > sh_size < 1 ) { <END_VULN> return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr - > sh_size , sizeof ( char ) ) ;
if ( verbose ) appendPQExpBuffer ( & sql , " ( VERBOSE ) " ) ; <START_VULN> appendPQExpBuffer ( & sql , " SYSTEM % s ; " , PQdb ( conn ) ) ; <END_VULN> if ( ! executeMaintenanceCommand ( conn , sql . data , echo ) ) {
msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ; msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ; msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ; if ( peekonly ) { <START_VULN> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <END_VULN> goto peekout ; }
if ( ! ip6_checkentry ( & e - > ipv6 ) ) return - EINVAL ; <START_VULN> ret = xt_compat_check_entry_offsets ( e , <END_VULN> e - > target_offset , e - > next_offset ) ; if ( ret ) return ret ;
<START_VULN> #define JSXDR_BYTECODE_VERSION ( 0xb973c0de - 85 ) <END_VULN>
gss_release_buffer ( & tmpmin , & sc - > DER_mechTypes ) ; assert ( mech_wanted != GSS_C_NO_OID ) ; } else <START_VULN> sc = create_spnego_ctx ( ) ; <END_VULN> if ( sc == NULL ) { ret = GSS_S_FAILURE ; * return_token = NO_TOKEN_SEND ;
{ unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; <START_VULN> sprintf ( op - > buf_asm , "sparse - switch - payload % d" , array_size ) ; <END_VULN> size = 4 ; payload = 2 * ( array_size * 4 ) ; len = 0 ;
MODULE_PARM_DESC ( ksym , "Kernel symbol to monitor ; this module will report any" " write operations on the kernel symbol" ) ; <START_VULN> static void sample_hbp_handler ( struct perf_event * bp , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) {
{ MsgToEventLog ( M_SYSERR , TEXT ( "malloc failed" ) ) ; ReturnLastError ( pipe , L"malloc" ) ; <START_VULN> goto out ; <END_VULN> } read = ReadPipeAsync ( pipe , data , bytes , 1 , & exit_event ) ;
ma_mov ( c , lr ) ; ma_str ( lr , dest ) ; } BufferOffset ma_BoundsCheck ( Register bounded ) { return as_cmp ( bounded , Imm8 ( 0 ) ) ; } void moveFloat32 ( FloatRegister src , FloatRegister dest ) { <START_VULN> as_vmov ( VFPRegister ( src ) . singleOverlay ( ) , VFPRegister ( dest ) . singleOverlay ( ) ) ; <END_VULN> } #ifdef JSGC_GENERATIONAL void branchPtrInNurseryRange ( Condition cond , Register ptr , Register temp , Label * label ) ; void branchValueIsNurseryObject ( Condition cond , ValueOperand value , Register temp , Label * label ) ; #endif } ;
if ( pal ) { s - > frame - > palette_has_changed = 1 ; memcpy ( s - > pal , pal , AVPALETTE_SIZE ) ; } memcpy ( s - > frame - > data [ 1 ] , s - > pal , AVPALETTE_SIZE ) ; } if ( avctx - > height * istride == avpkt - > size ) { <START_VULN> int linesize = ( avctx - > width * avctx - > bits_per_coded_sample + 7 ) 8 ; <END_VULN> uint8_t * ptr = s - > frame - > data [ 0 ] ; uint8_t * buf = avpkt - > data + ( avctx - > height - 1 ) * istride ; int i , j ; for ( i = 0 ; i < avctx - > height ; i ++ ) { if ( avctx - > bits_per_coded_sample == 4 ) { for ( j = 0 ; j < avctx - > width - 1 ; j + = 2 ) { ptr [ j+0 ] = buf [ j >> 1 ] >> 4 ; ptr [ j+1 ] = buf [ j >> 1 ] & 0xF ; }
bool IsIMEDoingKakuteiUndo ( ) const ; <START_VULN> void RemoveMessageAndDispatchPluginEvent ( UINT aFirstMsg , UINT aLastMsg ) const ; <END_VULN> bool IsKeyDownMessage ( ) const { return ( mMsg . message == WM_KEYDOWN || mMsg . message == WM_SYSKEYDOWN ) ; } bool IsFollowedByCharMessage ( ) const { MOZ_ASSERT ( mMsg . message == WM_KEYDOWN || mMsg . message == WM_SYSKEYDOWN ) ;
if ( ! is_irq_none ( vdev ) ) return - EINVAL ; <START_VULN> vdev - > ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <END_VULN> if ( ! vdev - > ctx ) return - ENOMEM ;
static const struct driver_info wwan_noarp_info = { . description = "Mobile Broadband Network Device ( NO ARP ) " , . flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET <START_VULN> | FLAG_WWAN | FLAG_NOARP , <END_VULN> . bind = cdc_ncm_bind , . unbind = cdc_ncm_unbind , . manage_power = usbnet_manage_power ,
we're * not * floor1 . This won't happen unless someone has broken the encode setup lib . Guard it anyway . * if ( ci - > floor_type [ info - > floorsubmap [ submap ] ] != 1 ) return ( - 1 ) ; floor_posts [ i ] [ PACKETBLOBS2 ] = floor1_fit ( vb , b - > flr [ info - > floorsubmap [ submap ] ] , logmdct , logmask ) ; <START_VULN> <END_VULN> if ( vorbis_bitrate_managed ( vb ) && floor_posts [ i ] [ PACKETBLOBS2 ] ) { _vp_offset_and_mix ( psy_look , noise , tone ,
guint32 offset , guint32 str_tbl , guint8 level , guint8 * codepage_attr ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; <START_VULN> guint32 off = offset ; <END_VULN> guint32 len ; guint str_len ; guint32 ent ;
#define MAX_SHARE_SIZE 64 #define MAX_USERNAME_SIZE 32 <START_VULN> #define MAX_PASSWORD_SIZE 16<END_VULN> #define CIFS_MIN_RCV_POOL 4
if ( page == NULL ) page = http_request_get_query_string ( req ) ; <START_VULN> if ( page && ( access ( page , R_OK ) == 0 ) ) <END_VULN> { http_response_printf ( res , " % s" , file_read ( page ) ) ; http_response_send ( res ) ;
<START_VULN> if ( * p + 2 > end ) <END_VULN> { MBEDTLS_SSL_DEBUG_MSG ( 1 , ( "bad client key exchange message" ) ) ; return ( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE ) ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "Cast5 Cipher Algorithm" ) ; <START_VULN> MODULE_ALIAS ( "cast5" ) ; <END_VULN>
if ( ! c - > synth_tile || ! c - > jpeg_tile || c - > old_tile_w < c - > tile_width || c - > old_tile_h < c - > tile_height ) { <START_VULN> c - > tile_stride = FFALIGN ( c - > tile_width * 3 , 16 ) ; <END_VULN> aligned_height = FFALIGN ( c - > tile_height , 16 ) ; av_free ( c - > synth_tile ) ; av_free ( c - > jpeg_tile ) ;
static void mpeg4_encode_gop_header ( MpegEncContext * s ) { <START_VULN> int hours , minutes , seconds ; <END_VULN> int64_t time ; put_bits ( & s - > pb , 16 , 0 ) ;
#ifndef WOFF_H_ #define WOFF_H_ #ifdef _MSC_VER <START_VULN> typedef char int8_t ; <END_VULN> typedef short int16_t ; typedef int int32_t ; typedef unsigned char uint8_t ; typedef unsigned short uint16_t ; typedef unsigned int uint32_t ; typedef unsigned __int64 uint64_t ; #else #include < inttypes . h >
default : CHECK ( 0 ) ; } <START_VULN> snprintf_func ( rptr , rbuf+TESTBUFSIZE - rptr , " % d % d" , <END_VULN> inst - > pos , inst - > size ) ; rptr + = strlen ( rptr ) ;
zval * z_still_running ; php_curlm * mh ; int still_running ; <START_VULN> int result ; <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , "rz" , & z_mh , & z_still_running ) == FAILURE ) { return ;
return bh ; } brelse ( bh ) ; <START_VULN> ce = mb_cache_entry_find_next ( ce , inode - > i_sb - > s_bdev , hash ) ; <END_VULN> } return NULL ; }
sub_str_end_pos = ustr_len ; } } <START_VULN> <END_VULN> if ( sub_str_start_pos > sub_str_end_pos ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "grapheme_substr : length is beyond start" , 1 TSRMLS_CC ) ;
return intpart ; } <START_VULN> static void<END_VULN> fmtfp ( char ** sbuffer , char ** buffer , size_t * currlen ,
. data = & ipv6_devconf . mtu6 , . maxlen = sizeof ( int ) , . mode = 0644 , <START_VULN> . proc_handler = proc_dointvec , <END_VULN> } , { . procname = "accept_ra" ,
} ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <START_VULN> if ( ! ctx - > established ) { <END_VULN> * minor_status = KG_CTX_INCOMPLETE ; return ( GSS_S_NO_CONTEXT ) ; }
size = 1 ; for ( i = 0 ; i < cpp ; i ++ ) <START_VULN> size *= 94 ; <END_VULN> if ( ncolors <= 0 || ncolors > size ) { av_log ( avctx , AV_LOG_ERROR , "invalid number of colors : % d" , ncolors ) ;
#define char_to_int ( p ) ( p - '0' ) #define OSSL_MAX ( p , q ) ( ( p >= q ) ? p : q ) <START_VULN> static void<END_VULN> _dopr ( char ** sbuffer , char ** buffer , size_t * maxlen ,
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : window functions <START_VULN> last mod : $ Id : window . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_WINDOW_ #define _V_WINDOW_ extern float * _vorbis_window_get ( int n ) ; extern void _vorbis_apply_window ( float * d , int * winno , long * blocksizes ,
Token currentToken ; unsigned lookahead ; Token lookaheadTokens [ maxLookahead ] ; } ; void advance ( size_t position ) ; void tell ( Position * ) ; void seek ( const Position & pos ) ; <START_VULN> void seek ( const Position & pos , const TokenStream & other ) ; <END_VULN> void positionAfterLastFunctionKeyword ( Position & pos ) ; size_t positionToOffset ( const Position & pos ) const { return pos . buf - userbuf . base ( ) ; } bool hasSourceMap ( ) const { return sourceMap != NULL ;
{ MsgToEventLog ( M_ERR , TEXT ( "Startup data ends at working directory" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <START_VULN> goto out ; <END_VULN> } sud - > options = sud - > directory + len ;
p - > n = n ; p - > rate = rate ; p - > m_val = 1 . ; if ( rate < 26000 ) p - > m_val = 0 ; else if ( rate < 38000 ) p - > m_val = . 94 ; else if ( rate > 46000 ) p - > m_val = 1 . 275 ; <START_VULN> <END_VULN> for ( i = 0 , j = 0 ; i < MAX_ATH - 1 ; i ++ ) { int endpos = rint ( fromOC ( ( i+1 ) * . 125 - 2 . ) * 2 * nrate ) ; float base = ATH [ i ] ; if ( j < endpos ) { float delta = ( ATH [ i+1 ] - base ) ( endpos - j ) ; for ( ; j < endpos && j < n ; j ++ ) {
<START_VULN> p1 = BuildTestPacket ( id , 0 , 0 , 'A' , 8 ) ; <END_VULN> if ( p1 == NULL ) { goto end ; }
const AVFrame * src , int field ) { int plane ; <START_VULN> for ( plane = 0 ; plane < 4 && src - > data [ plane ] ; plane ++ ) <END_VULN> av_image_copy_plane ( dst - > data [ plane ] + field * dst - > linesize [ plane ] , dst - > linesize [ plane ] << 1 , src - > data [ plane ] + field * src - > linesize [ plane ] , src - > linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) 2 ) ;
int err ; struct virtio_net_hdr vnet_hdr = { 0 } ; int vnet_hdr_len = 0 ; <START_VULN> int copylen ; <END_VULN> bool zerocopy = false ; if ( q - > flags & IFF_VNET_HDR ) {
return - ENOMEM ; for ( i = scm - > fp - > count - 1 ; i >= 0 ; i -- ) <START_VULN> unix_inflight ( scm - > fp - > fp [ i ] ) ; <END_VULN> return max_level ; }
} * hdr , _hdr ; hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; if ( ! hdr ) <START_VULN> return false ; <END_VULN> proto = hdr - > proto ; nhoff + = PPPOE_SES_HLEN ; switch ( proto ) {
} } mutt_buffer_addstr ( buf , "X - GM - RAW " ) ; <START_VULN> imap_quote_string ( term , sizeof ( term ) , pat - > p . str ) ; <END_VULN> mutt_buffer_addstr ( buf , term ) ; break ; }
static int CVE_2013_3670_rle_unpack ( const unsigned char * src , int src_len , int src_count , unsigned char * dest , int dest_len ) { const unsigned char * ps ; const unsigned char * ps_end ; unsigned char * pd ; <START_VULN> int i , l ; <END_VULN> unsigned char * dest_end = dest + dest_len ; ps = src ; ps_end = src + src_len ; pd = dest ; if ( src_count & 1 ) { if ( ps_end - ps < 1 ) return 0 ; * pd ++ = * ps ++ ; }
sdb_num_set ( sdb , "link" , shdr - > sh_link , 0 ) ; sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; <START_VULN> for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr - > sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <END_VULN> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ;
struct domain_device * dev = NULL ; res = sas_find_bcast_dev ( port_dev , & dev ) ; <START_VULN> while ( res == 0 && dev ) { <END_VULN> struct expander_device * ex = & dev - > ex_dev ; int i = 0 , phy_id ;
static uint32_t sanityCheck ( const uint8_t * woffData , uint32_t woffLen ) { const woffHeader * header ; uint16_t numTables , i ; const woffDirEntry * dirEntry ; <START_VULN> uint32_t tableTotal = 0 ; <END_VULN> if ( ! woffData || ! woffLen ) { return eWOFF_bad_parameter ; } if ( woffLen < sizeof ( woffHeader ) ) { return eWOFF_invalid ; }
return AVERROR_INVALIDDATA ; if ( ! encoding && c - > palette_size && c - > bpp <= 8 && c - > format != CHUNKY ) { avctx - > pix_fmt = AV_PIX_FMT_PAL8 ; <START_VULN> } else if ( encoding == 1 && ( c - > bpp == 6 || c - > bpp == 8 ) ) { <END_VULN> if ( c - > palette_size != ( 1 << ( c - > bpp - 1 ) ) ) return AVERROR_INVALIDDATA ; avctx - > pix_fmt = AV_PIX_FMT_BGR24 ;
const char * msg ; u_int8_t state ; <START_VULN> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <END_VULN> BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh - > dccph_type ] [ CT_DCCP_NONE ] ;
static int hns_xgmac_get_sset_count ( int stringset ) { <START_VULN> if ( stringset == ETH_SS_STATS ) <END_VULN> return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : LSP ( also called LSF ) conversion routines <START_VULN> last mod : $ Id : lsp . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> The LSP generation code is taken ( with minimal modification and a few bugfixes ) from "On the Computation of the LSP Frequencies" by Joseph Rothweiler ( see http : The paper is available at : http :
oggpack_write ( opb , 1 , 1 ) ; return ( 0 ) ; } static int _vorbis_pack_comment ( oggpack_buffer * opb , vorbis_comment * vc ) { int bytes = strlen ( ENCODE_VENDOR_STRING ) ; <START_VULN> <END_VULN> oggpack_write ( opb , 0x03 , 8 ) ; _v_writestring ( opb , "vorbis" , 6 ) ; oggpack_write ( opb , bytes , 32 ) ; _v_writestring ( opb , ENCODE_VENDOR_STRING , bytes ) ;
WebGLContextOptions mOptions ; PRPackedBool mInvalidated ; PRPackedBool mResetLayer ; PRPackedBool mVerbose ; PRPackedBool mOptionsFrozen ; WebGLuint mActiveTexture ; <START_VULN> WebGLenum mSynthesizedGLError ; <END_VULN> PRBool mShaderValidation ; PRInt32 mGLMaxVertexAttribs ; PRInt32 mGLMaxTextureUnits ; PRInt32 mGLMaxTextureSize ;
} key_ref = ERR_PTR ( - EINVAL ) ; <START_VULN> if ( ! index_key . type - > match || ! index_key . type - > instantiate || <END_VULN> ( ! index_key . description && ! index_key . type - > preparse ) ) goto error_put_type ;
ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <START_VULN> mutt_bcache_del ( pop_data - > bcache , ctx - > hdrs [ i ] - > data ) ; <END_VULN> #ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx - > hdrs [ i ] - > data , strlen ( ctx - > hdrs [ i ] - > data ) ) ; #endif
} bool __net_get_random_once ( void * buf , int nbytes , bool * done , <START_VULN> struct static_key * done_key ) <END_VULN> { static DEFINE_SPINLOCK ( lock ) ; unsigned long flags ;
<START_VULN> if ( dest == a - > name ) { <END_VULN>
memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_TCP ; fl6 . daddr = ireq - > ir_v6_rmt_addr ; <START_VULN> final_p = fl6_update_dst ( & fl6 , np - > opt , & final ) ; <END_VULN> fl6 . saddr = ireq - > ir_v6_loc_addr ; fl6 . flowi6_oif = sk - > sk_bound_dev_if ; fl6 . flowi6_mark = ireq - > ir_mark ;
int32_t i32 ; uint32_t u32 ; JSWhyMagic why ; } payload ; } s ; double asDouble ; void * asPtr ; size_t asWord ; <START_VULN> } jsval_layout ; <END_VULN> # endif #endif JS_STATIC_ASSERT ( sizeof ( jsval_layout ) == 8 ) ; #if JS_BITS_PER_WORD == 32
bool mFullScreen ; void * mJavaView ; #endif nsPluginNativeWindow * mPluginWindow ; nsRefPtr < nsNPAPIPluginInstance > mInstance ; nsPluginFrame * mPluginFrame ; <START_VULN> nsIContent * mContent ; <END_VULN> nsCString mDocumentBase ; bool mWidgetCreationComplete ; nsCOMPtr < nsIWidget > mWidget ; nsRefPtr < nsPluginHost > mPluginHost ; #ifdef XP_MACOSX NP_CGContext mCGPluginPortCopy ; int32_t mInCGPaintLevel ;
<START_VULN> static int udp_push_pending_frames ( struct sock * sk ) <END_VULN> { struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ;
scatterwalk_done ( & src_sg_walk , 0 , 0 ) ; scatterwalk_done ( & assoc_sg_walk , 0 , 0 ) ; } else { <START_VULN> scatterwalk_map_and_copy ( dst , req - > dst , 0 , req - > cryptlen , 1 ) ; <END_VULN> kfree ( src ) ; } return retval ;
if ( value_expected == MagickFalse ) continue ; p = value ; <START_VULN> while ( ( c != '' ) && ( c != '0' ) ) <END_VULN> { if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) * p ++ = c ;
NSS_CMSSignerInfo_Sign ( NSSCMSSignerInfo * signerinfo , SECItem * digest , SECItem * contentType ) { CERTCertificate * cert ; SECKEYPrivateKey * privkey = NULL ; SECOidTag digestalgtag ; SECOidTag pubkAlgTag ; SECItem signature = { 0 } ; SECStatus rv ; <START_VULN> PLArenaPool * poolp , * tmppoolp ; <END_VULN> SECAlgorithmID * algID , freeAlgID ; CERTSubjectPublicKeyInfo * spki ; PORT_Assert ( digest != NULL ) ; poolp = signerinfo - > cmsg - > poolp ; switch ( signerinfo - > signerIdentifier . identifierType ) {
printf ( " ] ( % llu ) " , ddword_tmp ) ; break ; case PT_LONG : <START_VULN> printf ( " Value : % li" , * ( ( long * ) mapidata - > data ) ) ; <END_VULN> break ; case PT_I2 : printf ( " Value : % hi" , * ( ( short int * ) mapidata - > data ) ) ;
while ( strncmp ( file , " . " , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ; while ( ( cp = strstr ( file , " . " ) ) != ( char * ) 0 ) <START_VULN> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <END_VULN> for ( ; ; )
if ( limit_val != - 1 ) limit_val -- ; } <START_VULN> <END_VULN> last_match = & subject [ offsets [ 1 ] ] ; next_offset = offsets [ 1 ] ;
mParent = aTarget ; } virtual nsIDOMEventTarget * GetParentTarget ( ) { return mParent ; } NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS ( nsWindowRoot , nsIDOMEventTarget ) protected : <START_VULN> nsPIDOMWindow * mWindow ; <END_VULN> nsRefPtr < nsEventListenerManager > mListenerManager ; nsCOMPtr < nsIDOMNode > mPopupNode ; nsCOMPtr < nsIDOMEventTarget > mParent ; } ;
return 1 ; case GSI_GET_HWRPB : <START_VULN> if ( nbytes < sizeof ( * hwrpb ) ) <END_VULN> return - EINVAL ; if ( copy_to_user ( buffer , hwrpb , nbytes ) != 0 ) return - EFAULT ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : code raw packets into framed OggSquish stream and decode Ogg streams back into raw packets <START_VULN> last mod : $ Id : framing . c 16051 2009 - 05 - 27 05 : 00 : 06Z xiphmont $ <END_VULN> note : The CRC code is directly derived from public domain code by Ross Williams ( ross@guest . adelaide . edu . au ) . See docsframing . html for details . #include < stdlib . h >
mutex_unlock ( & vq - > mutex ) ; if ( oldubufs ) { <START_VULN> vhost_net_ubuf_put_and_wait ( oldubufs ) ; <END_VULN> mutex_lock ( & vq - > mutex ) ; vhost_zerocopy_signal_used ( n , vq ) ; mutex_unlock ( & vq - > mutex ) ;
int * sortpointer [ VIF_POSIT+2 ] ; vorbis_info_floor1 * info = ( vorbis_info_floor1 * ) in ; vorbis_look_floor1 * look = _ogg_calloc ( 1 , sizeof ( * look ) ) ; int i , j , n = 0 ; look - > vi = info ; look - > n = info - > postlist [ 1 ] ; <START_VULN> <END_VULN> for ( i = 0 ; i < info - > partitions ; i ++ ) n+ = info - > class_dim [ info - > partitionclass [ i ] ] ;
m_pos -= t >> 2 ; m_pos -= * ip ++ << 2 ; TEST_LB ( m_pos ) ; <START_VULN> NEED_OP ( 2 ) ; <END_VULN> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op + = 2 ;
fprintf ( stderr , "Unable to select public key file : % s" , sc_strerror ( r ) ) ; return 2 ; } <START_VULN> bufsize = file - > size ; <END_VULN> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) {
#define __S001 PAGE_READONLY #define __S010 PAGE_SHARED #define __S011 PAGE_SHARED <START_VULN> #define __S100 PAGE_EXECONLY<END_VULN> #define __S101 PAGE_READONLY_EXEC #define __S110 PAGE_SHARED_EXEC #define __S111 PAGE_SHARED_EXEC
static int kvm_set_guest_paused ( struct kvm_vcpu * vcpu ) { <START_VULN> if ( ! vcpu - > arch . time_page ) <END_VULN> return - EINVAL ; vcpu - > arch . pvclock_set_guest_stopped_request = true ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ;
__be32 spi ; spi = xfrm6_tunnel_spi_lookup ( ( xfrm_address_t * ) & iph - > saddr ) ; <START_VULN> return xfrm6_rcv_spi ( skb , spi ) ; <END_VULN> } static int xfrm6_tunnel_err ( struct sk_buff * skb , struct inet6_skb_parm * opt ,
* out = NULL ; * out_len = 0 ; <START_VULN> <END_VULN> if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , "failed to apply delta : base size does not match given data" ) ; return - 1 ;
int vorbis_synthesis_headerin ( vorbis_info * vi , vorbis_comment * vc , ogg_packet * op ) { oggpack_buffer opb ; <START_VULN> <END_VULN> if ( op ) { oggpack_readinit ( & opb , op - > packet , op - > bytes ) ; { char buffer [ 6 ] ; int packtype = oggpack_read ( & opb , 8 ) ;
char * ptr ; int err ; <START_VULN> file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ; <END_VULN> if ( ! file ) return - ENOMEM ;
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : softmagic . c , v 1 . 189 20140530 16 : 47 : 44 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
sslSessionID * sid = ss - > sec . ci . sid ; if ( sid - > peerCert == NULL ) { PORT_Memcpy ( sid - > u . ssl2 . sessionID , s , sizeof ( sid - > u . ssl2 . sessionID ) ) ; sid - > peerCert = CERT_DupCertificate ( ss - > sec . peerCert ) ; } <START_VULN> if ( ! ss - > opt . noCache ) <END_VULN> ( * ss - > sec . cache ) ( sid ) ; } static SECStatus ssl2_TriggerNextMessage ( sslSocket * ss ) { SECStatus rv ;
XPCCompartmentSet & GetCompartmentSet ( ) { return mCompartmentSet ; } XPCLock * GetMapLock ( ) const { return mMapLock ; } JSBool OnJSContextNew ( JSContext * cx ) ; <START_VULN> JSBool DeferredRelease ( nsISupports * obj ) ; <END_VULN> JSBool GetDoingFinalization ( ) const { return mDoingFinalization ; } enum {
mTrans - > mConnection - > SetSecurityCallbacks ( mCallbacks ) ; return NS_OK ; } private : nsRefPtr < nsHttpTransaction > mTrans ; nsCOMPtr < nsIInterfaceRequestor > mCallbacks ; } ; <START_VULN> Mutex mCallbacksLock ; <END_VULN> nsCOMPtr < nsIInterfaceRequestor > mCallbacks ; nsCOMPtr < nsITransportEventSink > mTransportSink ; nsCOMPtr < nsIEventTarget > mConsumerTarget ; nsCOMPtr < nsISupports > mSecurityInfo ; nsCOMPtr < nsIAsyncInputStream > mPipeIn ; nsCOMPtr < nsIAsyncOutputStream > mPipeOut ; nsCOMPtr < nsILoadGroupConnectionInfo > mLoadGroupCI ;
struct task_struct * tsk = current ; struct sh_fpu_soft_struct * fpu = & ( tsk - > thread . xstate - > softfpu ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <END_VULN> if ( ! ( task_thread_info ( tsk ) - > status & TS_USEDFPU ) ) {
const PRUint16 platformID = ReadShortAt ( table , TableOffsetPlatformID ) ; if ( ! acceptablePlatform ( platformID ) ) continue ; const PRUint16 encodingID = ReadShortAt ( table , TableOffsetEncodingID ) ; const PRUint32 offset = ReadLongAt ( table , TableOffsetOffset ) ; NS_ASSERTION ( offset < aBufLength , "cmap table offset is longer than table size" ) ; <START_VULN> NS_ENSURE_TRUE ( offset < aBufLength , NS_ERROR_FAILURE ) ; <END_VULN> const PRUint8 * subtable = aBuf + offset ; const PRUint16 format = ReadShortAt ( subtable , SubtableOffsetFormat ) ; if ( isSymbol ( platformID , encodingID ) ) { aUnicodeFont = PR_FALSE ; aSymbolFont = PR_TRUE ; keepFormat = format ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "AES Secure Hash Algorithm , sparc64 aes opcode accelerated" ) ; <START_VULN> MODULE_ALIAS ( "aes" ) ; <END_VULN> #include "crop_devid . c"
} } <START_VULN> <END_VULN> efree ( offsets ) ; }
static inline size_t GetPSDRowSize ( Image * image ) { if ( image - > depth == 1 ) <START_VULN> return ( ( image - > columns+7 ) 8 ) ; <END_VULN> else return ( image - > columns * GetPSDPacketSize ( image ) ) ; }
if ( ! tx_ring ) prb_shutdown_retire_blk_timer ( po , rb_queue ) ; } <START_VULN> release_sock ( sk ) ; <END_VULN> if ( pg_vec ) free_pg_vec ( pg_vec , order , req - > tp_block_nr ) ; out : return err ; }
ret = FAIL ; break ; } <START_VULN> <END_VULN> new_charset_name = mnd_pestrdup ( value , conn - > persistent ) ; if ( ! new_charset_name ) { goto oom ;
nsresult SaveSelection ( nsISelection * aSel ) ; nsresult RestoreSelection ( nsISelection * aSel ) ; bool IsCollapsed ( ) ; bool IsEqual ( nsSelectionState * aSelState ) ; void MakeEmpty ( ) ; bool IsEmpty ( ) ; protected : <START_VULN> nsTArray < nsRangeStore > mArray ; <END_VULN> friend class nsRangeUpdater ; } ; class nsRangeUpdater { public :
{ int i ; int nr = pagevec_count ( pvec ) ; <START_VULN> int delta_munlocked ; <END_VULN> struct pagevec pvec_putback ; int pgrescued = 0 ;
virtual bool IsTransportSeekable ( ) = 0 ; <START_VULN> static MediaResource * Create ( MediaDecoder * aDecoder , nsIChannel * aChannel ) ; <END_VULN> virtual nsresult Open ( nsIStreamListener ** aStreamListener ) = 0 ; #ifdef MOZ_DASH
cleanup : if ( ce ) <START_VULN> mb_cache_entry_release ( ce ) ; <END_VULN> brelse ( new_bh ) ; if ( ! ( bs - > bh && s - > base == bs - > bh - > b_data ) ) kfree ( s - > base ) ;
le16_to_cpu ( entry - > e_value_offs ) + size > inode - > i_sb - > s_blocksize ) goto bad_block ; <START_VULN> if ( ext2_xattr_cache_insert ( bh ) ) <END_VULN> ea_idebug ( inode , "cache insert failed" ) ; if ( buffer ) { error = - ERANGE ;
} fseek ( f , 0 , SEEK_SET ) ; <START_VULN> if ( fscanf ( f , "PG % [ t ] % c % c % [ t+ - ] % d % [ t ] % d % [ t ] % d" , temp , & endian1 , <END_VULN> & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) { fclose ( f ) ; fprintf ( stderr ,
{ const char * header ; uint head_length , counter = 0 ; <START_VULN> char query [ 255 ] , rows [ NAME_LEN ] , fields [ 16 ] ; <END_VULN> MYSQL_FIELD * field ; MYSQL_RES * result ; MYSQL_ROW row , rrow ;
mt - > mt_buffer_ [ i ] = <START_VULN> ( 1812433253UL * ( mt - > mt_buffer_ [ i - 1 ] ^ <END_VULN> ( mt - > mt_buffer_ [ i - 1 ] >> 30 ) ) + i ) ; } }
void * jas_malloc ( size_t size ) { void * result ; <START_VULN> JAS_DBGLOG ( 101 , ( "jas_malloc called with % zu" , size ) ) ; <END_VULN> result = malloc ( size ) ; JAS_DBGLOG ( 100 , ( "jas_malloc ( % zu ) - > % p" , size , result ) ) ; return result ;
' < session - name >= < session - id > ' to allow URLs of the form http : <START_VULN> if ( ! PS ( id ) && <END_VULN> zend_hash_find ( & EG ( symbol_table ) , "REQUEST_URI" , sizeof ( "REQUEST_URI" ) , ( void ** ) & data ) == SUCCESS && Z_TYPE_PP ( data ) == IS_STRING &&
void removeWrapper ( js : : WrapperMap : : Ptr p ) { crossCompartmentWrappers . remove ( p ) ; } struct WrapperEnum : public js : : WrapperMap : : Enum { WrapperEnum ( JSCompartment * c ) : js : : WrapperMap : : Enum ( c - > crossCompartmentWrappers ) { } } ; <START_VULN> void mark ( JSTracer * trc ) ; <END_VULN> bool isDiscardingJitCode ( JSTracer * trc ) ; void sweep ( js : : FreeOp * fop , bool releaseTypes ) ; void sweepCrossCompartmentWrappers ( ) ; void purge ( ) ; void clearTables ( ) ; bool hasObjectMetadataCallback ( ) const { return objectMetadataCallback ; } void setObjectMetadataCallback ( js : : ObjectMetadataCallback callback ) ;
INIT_LIST_HEAD ( & tasks ) ; do_smart_update ( sma , NULL , 0 , 1 , & tasks ) ; <START_VULN> sem_unlock ( sma ) ; <END_VULN> wake_up_sem_queue_do ( & tasks ) ; kfree_rcu ( un , rcu ) ;
{ struct nfs_delegation * delegation ; struct nfs4_opendata * opendata ; <START_VULN> int delegation_type = 0 ; <END_VULN> int status ; opendata = nfs4_open_recoverdata_alloc ( ctx , state ) ;
stub = phar_create_default_stub ( index , webindex , & stub_len , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; if ( stub ) { efree ( stub ) ;
if ( av_image_check_size ( s - > width , s - > height , 0 , avctx ) < 0 ) return - 1 ; <START_VULN> if ( s - > width != avctx - > width && s - > height != avctx - > height ) { <END_VULN> ret = ff_set_dimensions ( avctx , s - > width , s - > height ) ; if ( ret < 0 ) return ret ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic shared codebook operations <START_VULN> last mod : $ Id : sharedbook . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < math . h > #include < string . h > #include < oggogg . h > #include "os . h"
bool mDroppedDown ; bool mInRedisplayText ; bool mDelayedShowDropDown ; <START_VULN> static nsComboboxControlFrame * mFocused ; <END_VULN> #ifdef DO_REFLOW_COUNTER PRInt32 mReflowId ; #endif } ; #endif
NAPI_GRO_CB ( skb ) - > same_flow = 0 ; NAPI_GRO_CB ( skb ) - > flush = 0 ; NAPI_GRO_CB ( skb ) - > free = 0 ; <START_VULN> NAPI_GRO_CB ( skb ) - > udp_mark = 0 ; <END_VULN> NAPI_GRO_CB ( skb ) - > gro_remcsum_start = 0 ;
return rv ; case FILE_USE : <START_VULN> if ( nbytes < offset ) <END_VULN> return 0 ; sbuf = m - > value . s ; if ( * sbuf == ' ^ ' ) {
unsigned int * size ) ; int xt_compat_target_to_user ( const struct xt_entry_target * t , void __user ** dstptr , unsigned int * size ) ; <START_VULN> int xt_compat_check_entry_offsets ( const void * base , <END_VULN> unsigned int target_offset , unsigned int next_offset ) ;
u32 __user * optval , int __user * optlen ) { int rc = - ENOPROTOOPT ; <START_VULN> if ( ccid - > ccid_ops - > ccid_hc_rx_getsockopt != NULL ) <END_VULN> rc = ccid - > ccid_ops - > ccid_hc_rx_getsockopt ( sk , optname , len , optval , optlen ) ; return rc ;
oggpack_write ( opb , 0 , 32 ) ; } } } oggpack_write ( opb , 1 , 1 ) ; return ( 0 ) ; } <START_VULN> <END_VULN> static int _vorbis_pack_books ( oggpack_buffer * opb , vorbis_info * vi ) { codec_setup_info * ci = vi - > codec_setup ; int i ; if ( ! ci ) return ( OV_EFAULT ) ; oggpack_write ( opb , 0x05 , 8 ) ; _v_writestring ( opb , "vorbis" , 6 ) ;
| Sara Golemon < pollita@php . net > | + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- + <START_VULN> <END_VULN> #include "php . h" #include "php_globals . h"
MODULE_LICENSE ( "GPL" ) ; MODULE_AUTHOR ( "Michal Ludvig" ) ; <START_VULN> MODULE_ALIAS ( "aes" ) ; <END_VULN>
INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; <START_VULN> RAnalOp next_op ; <END_VULN>
static int _vds_shared_init ( vorbis_dsp_state * v , vorbis_info * vi , int encp ) { int i ; codec_setup_info * ci = vi - > codec_setup ; private_state * b = NULL ; int hs ; if ( ci == NULL ) return 1 ; <START_VULN> hs = ci - > halfrate_flag ; <END_VULN> memset ( v , 0 , sizeof ( * v ) ) ; b = v - > backend_state = _ogg_calloc ( 1 , sizeof ( * b ) ) ; v - > vi = vi ; b - > modebits = ilog2 ( ci - > modes ) ; b - > transform [ 0 ] = _ogg_calloc ( VI_TRANSFORMB , sizeof ( * b - > transform [ 0 ] ) ) ;
bool isVector ( ) const { return size > 1 && ! matrix ; } bool isScalar ( ) const { return size == 1 && ! matrix && ! structure ; } TTypeList * getStruct ( ) const { return structure ; } void setStruct ( TTypeList * s ) { structure = s ; computeDeepestStructNesting ( ) ; } const TString & getTypeName ( ) const { <START_VULN> assert ( typeName ) ; <END_VULN> return * typeName ; } void setTypeName ( const TString & n ) { typeName = NewPoolTString ( n . c_str ( ) ) ; } bool isField ( ) const { return fieldName != 0 ; }
int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , <START_VULN> const char * name , int rep_quick ) <END_VULN> { int got_error ; uint i ;
ast_rtp_codecs_payloads_copy ( & newtextrtp , ast_rtp_instance_get_codecs ( p - > trtp ) , p - > trtp ) ; } else { ast_rtp_instance_stop ( p - > trtp ) ; if ( debug ) ast_verbose ( "Peer doesn't provide T . 140" ) ; } } if ( p - > udptl ) { <START_VULN> if ( udptlportno > 0 ) { <END_VULN> if ( ast_test_flag ( & p - > flags [ 1 ] , SIP_PAGE2_SYMMETRICRTP ) && ast_test_flag ( & p - > flags [ 1 ] , SIP_PAGE2_UDPTL_DESTINATION ) ) { ast_rtp_instance_get_remote_address ( p - > rtp , isa ) ; if ( ! ast_sockaddr_isnull ( isa ) && debug ) { ast_debug ( 1 , "Peer T . 38 UDPTL is set behind NAT and with destination , destination address now % s" , ast_sockaddr_stringify ( isa ) ) ; } } ast_sockaddr_set_port ( isa , udptlportno ) ; ast_udptl_set_peer ( p - > udptl , isa ) ; if ( debug ) ast_debug ( 1 , "Peer T . 38 UDPTL is at port % s" , ast_sockaddr_stringify ( isa ) ) ;
char __ptype [ 5 ] ; strcpy ( __ptype , gf_4cc_to_str ( __parent - > type ) ) ; GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( " [ iso file ] extra box % s found in % s , deleting" , gf_4cc_to_str ( __abox - > type ) , __ptype ) ) ; <START_VULN> gf_isom_box_del ( a ) ; <END_VULN> return GF_OK ; }
buf = buftmp ; if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 ) { if ( ret != AVERROR_EOF ) { av_free ( buf ) ; return ret ; } score = 0 ; ret = 0 ; } <START_VULN> pd . buf_size + = ret ; <END_VULN> pd . buf = & buf [ offset ] ; memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ) ; * fmt = av_probe_input_format2 ( & pd , 1 , & score ) ; if ( * fmt ) { if ( score <= AVPROBE_SCORE_MAX4 ) { av_log ( logctx , AV_LOG_WARNING , "Format % s detected only with low score of % d , misdetection possible ! " , ( * fmt ) - > name , score ) ; } else
js_AtomizeString ( JSContext * cx , JSString * str , uintN flags ) ; extern JSAtom * <START_VULN> js_Atomize ( JSContext * cx , const char * bytes , size_t length , uintN flags , bool useCESU8 = false ) ; <END_VULN> extern JSAtom * js_AtomizeChars ( JSContext * cx , const jschar * chars , size_t length , uintN flags ) ;
if ( ! op && ! adv ) return ( 1 ) ; { int size = os - > lacing_vals [ ptr ] & 0xff ; <START_VULN> int bytes = size ; <END_VULN> int eos = os - > lacing_vals [ ptr ] & 0x200 ; int bos = os - > lacing_vals [ ptr ] & 0x100 ; while ( size == 255 ) { int val = os - > lacing_vals [ ++ ptr ] ; size = val & 0xff ; if ( val & 0x200 ) eos = 0x200 ; bytes+ = size ;
if ( ! fp ) return ; <START_VULN> fprintf ( certificate_store - > fp , " % s % s" , certificate_data - > hostname , certificate_data - > fingerprint ) ; <END_VULN> fclose ( fp ) ; }
mrb_bool failed = TRUE ; mrb_get_args ( mrb , "o" , & orig ) ; fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; if ( fptr_copy != NULL ) { fptr_finalize ( mrb , fptr_copy , FALSE ) ; mrb_free ( mrb , fptr_copy ) ; } fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; <START_VULN> fptr_orig = io_get_open_fptr ( mrb , orig ) ; <END_VULN> DATA_TYPE ( copy ) = & mrb_io_type ; DATA_PTR ( copy ) = fptr_copy ;
<START_VULN> static int CVE_2014_5472_isofs_read_inode ( struct inode * inode ) <END_VULN> { struct super_block * sb = inode - > i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi - > s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ;
return true ; if ( ( uint64_t ) capacity * elemSize > size_type ( - 1 ) 2 ) { <START_VULN> NS_ERROR ( "Attempting to allocate excessively large array" ) ; <END_VULN> return false ; } if ( mHdr == EmptyHdr ( ) ) { Header * header = static_cast < Header * > ( Alloc : : Malloc ( sizeof ( Header ) + capacity * elemSize ) ) ; if ( ! header )
void mdct_init ( mdct_lookup * lookup , int n ) { int * bitrev = _ogg_malloc ( sizeof ( * bitrev ) * ( n4 ) ) ; DATA_TYPE * T = _ogg_malloc ( sizeof ( * T ) * ( n+n4 ) ) ; <START_VULN> <END_VULN> int i ; int n2 = n >> 1 ; int log2n = lookup - > log2n = rint ( log ( ( float ) n ) log ( 2 . f ) ) ; lookup - > n = n ; lookup - > trig = T ; lookup - > bitrev = bitrev ;
if ( IS_ERR ( prog ) ) return prog ; <START_VULN> atomic_inc ( & prog - > aux - > refcnt ) ; <END_VULN> fdput ( f ) ; return prog ;
{ static char * message = NULL ; <START_VULN> static unsigned short len = 0 ; <END_VULN> char buff [ 13 ] , * ret_msg = NULL ; register unsigned char i ; unsigned char blen ;
if ( i < pos && i + insn - > off + 1 > pos ) insn - > off + = delta ; <START_VULN> else if ( i > pos && i + insn - > off + 1 < pos ) <END_VULN> insn - > off -= delta ; } }
struct TypedArrayObjectStorage : AllTypedArraysBase { protected : JSObject * mObj ; <START_VULN> TypedArrayObjectStorage ( ) <END_VULN> { } explicit TypedArrayObjectStorage ( TypedArrayObjectStorage && aOther ) : mObj ( aOther . mObj ) { aOther . mObj = nullptr ; }
krb5_free_error_message ( handle - > context , errmsg ) ; } gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <START_VULN> exit_func : <END_VULN> free_server_handle ( handle ) ; return & ret ; }
{ struct sock * sk = skb - > sk ; struct inet_sock * inet = inet_sk ( sk ) ; <START_VULN> struct ip_options * opt = inet - > opt ; <END_VULN> struct rtable * rt ; struct iphdr * iph ; int res ;
friend struct nsTreeRange ; protected : nsresult FireOnSelectHandler ( ) ; static void SelectCallback ( nsITimer * aTimer , void * aClosure ) ; protected : <START_VULN> nsITreeBoxObject * mTree ; <END_VULN> PRBool mSuppressed ; PRInt32 mCurrentIndex ; nsCOMPtr < nsITreeColumn > mCurrentColumn ; PRInt32 mShiftSelectPivot ; nsTreeRange * mFirstRange ;
: 0 ; } bool isNative ( ) const { JS_ASSERT ( ! ( flags & NON_NATIVE ) == getObjectClass ( ) - > isNative ( ) ) ; return ! ( flags & NON_NATIVE ) ; } <START_VULN> const js : : Shape * previous ( ) const { <END_VULN> return parent ; } class Range { protected : friend struct Shape ; const Shape * cursor ;
static void * arm_coherent_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { <START_VULN> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <END_VULN> void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) )
guint8 * codepage_stag , guint8 * codepage_attr ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; <START_VULN> guint32 off = offset ; <END_VULN> guint32 len ; guint str_len ; guint32 ent ;
! jas_safe_size_mul ( size , cmpt - > cps_ , & size ) ) { goto error ; } <START_VULN> cmpt - > stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) : <END_VULN> jas_stream_tmpfile ( ) ; if ( ! cmpt - > stream_ ) { goto error ;
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : funcs . c , v 1 . 72 20140514 23 : 15 : 42 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
PRBool HasLoadFlag ( PRUint32 flag ) { return ( mLoadFlags & flag ) != 0 ; } PRBool IsPending ( ) const { <START_VULN> return ( mPump != nsnull ) ; <END_VULN> } void SetContentLength64 ( PRInt64 len ) ; PRInt64 ContentLength64 ( ) ;
swoole_string_release ( fname ) ; zval_ptr_dtor ( & ret ) ; } <START_VULN> <END_VULN> return buffer ; }
err = sock_do_ioctl ( net , sock , cmd , ( unsigned long ) & kts ) ; set_fs ( old_fs ) ; if ( ! err ) <START_VULN> err = compat_put_timespec ( up , & kts ) ; <END_VULN> return err ; }
msr . host_initiated = false ; svm - > next_rip = kvm_rip_read ( & svm - > vcpu ) + 2 ; <START_VULN> if ( svm_set_msr ( & svm - > vcpu , & msr ) ) { <END_VULN> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( & svm - > vcpu , 0 ) ; } else {
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 54 20140225 20 : 52 : 02 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
struct ttm_object_file * tfile = vmw_fpriv ( file_priv ) - > tfile ; int ret ; uint32_t size ; <START_VULN> uint32_t backup_handle ; <END_VULN> if ( req - > multisample_count != 0 ) return - EINVAL ;
} if ( half_horiz ) run_length *= 2 ; if ( run_length > s - > avctx - > width - x ) return AVERROR_INVALIDDATA ; if ( color ) { memset ( s - > frame - > data [ 0 ] + y * s - > frame - > linesize [ 0 ] + x , color , run_length ) ; <START_VULN> if ( half_vert ) <END_VULN> memset ( s - > frame - > data [ 0 ] + ( y+1 ) * s - > frame - > linesize [ 0 ] + x , color , run_length ) ; } x+ = run_length ; if ( x >= s - > avctx - > width ) { x = 0 ; y + = 1 + half_vert ; } }
} } * q = '0' ; <START_VULN> <END_VULN> RETVAL_STRINGL ( erealloc ( out_str , q - out_str + 1 ) , q - out_str , 0 ) ; }
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm , NEON accelerated" ) ; <START_VULN> MODULE_ALIAS ( "sha1" ) ; <END_VULN>
if ( context && php_stream_context_get_option ( context , "http" , "header" , & tmpzval ) == SUCCESS ) { tmp = NULL ; <START_VULN> <END_VULN> if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval ** tmpheader = NULL ;
( ( whence == SEEK_CUR && off == 0 ) || ( whence == SEEK_SET && off == s - > off ) ) ) return s - > off ; <START_VULN> else if ( ( s - > filesize == - 1 && whence == SEEK_END ) ) <END_VULN> return AVERROR ( ENOSYS ) ; if ( whence == SEEK_CUR )
for ( i = 1 ; i < view - > n ; ++ i ) { const struct user_regset * regset = & view - > regsets [ i ] ; do_thread_regset_writeback ( t - > task , regset ) ; <START_VULN> if ( regset - > core_note_type && <END_VULN> ( ! regset - > active || regset - > active ( t - > task , regset ) ) ) { int ret ; size_t size = regset - > n * regset - > size ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readcdf . c , v 1 . 39 20140227 23 : 26 : 18 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "GHASH Message Digest Algorithm , " "acclerated by PCLMULQDQ - NI" ) ; <START_VULN> MODULE_ALIAS ( "ghash" ) ; <END_VULN>
add_assoc_long ( * subarray , "weight" , n ) ; GETSHORT ( n , cp ) ; add_assoc_long ( * subarray , "port" , n ) ; <START_VULN> n = dn_expand ( answer - > qb2 , answer - > qb2+65536 , cp , name , ( sizeof name ) - 2 ) ; <END_VULN> if ( n < 0 ) { return NULL ; }
static const struct net_offload sit_offload = { . callbacks = { . gso_segment = ipv6_gso_segment , <START_VULN> . gro_receive = ipv6_gro_receive , <END_VULN> . gro_complete = sit_gro_complete , } , } ;
This is how the time string is formatted : snprintf ( p , sizeof ( p ) , " % 02d % 02d % 02d % 02d % 02d % 02dZ" , ts - > tm_year % 100 , <START_VULN> ts - > tm_mon+1 , ts - > tm_mday , ts - > tm_hour , ts - > tm_min , ts - > tm_sec ) ; <END_VULN> time_t ret ;
const cdf_sat_t * ssat , const cdf_stream_t * sst , cdf_secid_t sid , size_t len , cdf_stream_t * scn ) { <START_VULN> size_t ss = CDF_SEC_SIZE ( h ) , i , j ; <END_VULN> scn - > sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ; scn - > sst_dirlen = len ;
char * guestfs___first_line_of_file ( guestfs_h * g , const char * filename ) { <START_VULN> CLEANUP_FREE char ** lines = NULL ; <END_VULN> int64_t size ; char * ret ;
struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; <START_VULN> int idx , ret = - EINVAL ; <END_VULN> if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) ||
if ( lpc_order == 31 ) { for ( i = 1 ; i < nb_samples ; i ++ ) { buffer_out [ i ] = sign_extend ( buffer_out [ i - 1 ] + error_buffer [ i ] , bps ) ; } return ; } <START_VULN> for ( i = 1 ; i <= lpc_order ; i ++ ) <END_VULN> buffer_out [ i ] = sign_extend ( buffer_out [ i - 1 ] + error_buffer [ i ] , bps ) ; for ( ; i < nb_samples ; i ++ ) { int j ; int val = 0 ; int error_val = error_buffer [ i ] ; int error_sign ; int d = * pred ++ ;
* <START_VULN> <END_VULN> #ifndef __SSL_ERR_H_ #define __SSL_ERR_H_ #define SSL_ERROR_BASE ( - 0x3000 ) #define SSL_ERROR_LIMIT ( SSL_ERROR_BASE + 1000 ) #define IS_SSL_ERROR ( code )
} } } <START_VULN> gdCtxPrintf ( out , " } ; " ) ; <END_VULN> }
skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; <START_VULN> ipv6_select_ident ( fh ) ; <END_VULN> fh - > nexthdr = nexthdr ; fh - > reserved = 0 ; fh - > frag_off = htons ( IP6_MF ) ;
send_cookie = 0 ; } <START_VULN> if ( ! PS ( id ) && <END_VULN> zend_hash_find ( & EG ( symbol_table ) , "_POST" , sizeof ( "_POST" ) , ( void ** ) & data ) == SUCCESS && Z_TYPE_PP ( data ) == IS_ARRAY &&
if ( acl_len > buflen ) goto out_free ; _copy_from_pages ( buf , pages , res . acl_data_offset , <START_VULN> res . acl_len ) ; <END_VULN> } ret = acl_len ; out_free :
static void CVE_2014_5163_decode_apn ( tvbuff_t * tvb , int offset , guint16 length , proto_tree * tree , proto_item * item ) { guint8str [ MAX_APN_LENGTH+1 ] ; guintcurr_len ; <START_VULN> memset ( str , 0 , MAX_APN_LENGTH ) ; <END_VULN> tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ) ; curr_len = 0 ; while ( ( curr_len < length ) && ( curr_len < MAX_APN_LENGTH ) ) { guint step = str [ curr_len ] ; str [ curr_len ] = ' . ' ; curr_len + = step+1 ; }
void WalkRules ( nsIStyleRuleProcessor : : EnumFunc aFunc , void * aData ) ; nsINodeList * GetAnonymousNodes ( ) ; static nsresult DoInitJSClass ( JSContext * cx , JSObject * global , JSObject * obj , const nsAFlatCString & aClassName , nsXBLPrototypeBinding * aProtoBinding , <START_VULN> JSObject ** aClassObject ) ; <END_VULN> bool AllowScripts ( ) ; void RemoveInsertionParent ( nsIContent * aParent ) ; bool HasInsertionParent ( nsIContent * aParent ) ; protected :
} <START_VULN> const PRUint8 * <END_VULN> PrepareOpenTypeData ( const PRUint8 * aData , PRUint32 * aLength ) { switch ( gfxFontUtils : : DetermineFontDataType ( aData , * aLength ) ) { case GFX_USERFONT_OPENTYPE : return aData ;
while ( v ) { ret ++ ; v >>= 1 ; } return ( ret ) ; } static void mapping0_pack ( vorbis_info * vi , vorbis_info_mapping * vm , <START_VULN> oggpack_buffer * opb ) { <END_VULN> int i ; vorbis_info_mapping0 * info = ( vorbis_info_mapping0 * ) vm ; if ( info - > submaps > 1 ) { for ( i = 0 ; i < vi - > channels ; i ++ ) {
int fd = - 1 ; struct xar_header hdr ; fmap_t * map = * ctx - > fmap ; <START_VULN> long length , offset , size , at ; <END_VULN> int encoding ; z_stream strm ; char * toc , * tmpname ;
goto err ; for ( j = 0 ; j < numpipes ; j ++ ) { <START_VULN> if ( SSL_USE_ETM ( s ) && mac_size != 0 ) { <END_VULN> if ( s - > method - > ssl3_enc - > mac ( s , & wr [ j ] , outbuf [ j ] + wr [ j ] . length , 1 ) < 0 ) goto err ;
xattr_value_len , calc . digest ) ; if ( rc ) break ; <START_VULN> rc = memcmp ( xattr_data - > digest , calc . digest , <END_VULN> sizeof ( calc . digest ) ) ; if ( rc ) rc = - EINVAL ;
switch ( ntf - > activation_rf_tech_and_mode ) { case NCI_NFC_A_PASSIVE_POLL_MODE : nfca_poll = & ntf - > activation_params . nfca_poll_iso_dep ; <START_VULN> nfca_poll - > rats_res_len = * data ++ ; <END_VULN> pr_debug ( "rats_res_len % d" , nfca_poll - > rats_res_len ) ; if ( nfca_poll - > rats_res_len > 0 ) { memcpy ( nfca_poll - > rats_res ,
if ( errmsg != NULL ) krb5_free_error_message ( handle - > context , errmsg ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <START_VULN> exit_func : <END_VULN> free_server_handle ( handle ) ; return & ret ; }
case TIOCGSID : return tiocgsid ( tty , real_tty , p ) ; case TIOCGETD : <START_VULN> return put_user ( tty - > ldisc - > ops - > num , ( int __user * ) p ) ; <END_VULN> case TIOCSETD : return tiocsetd ( tty , p ) ; case TIOCVHANGUP :
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : LPC low level routines <START_VULN> last mod : $ Id : lpc . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN>
continue ; } } else { <START_VULN> NEED_OP ( t ) ; <END_VULN> do { * op ++ = * m_pos ++ ; } while ( op < oe ) ;
nsresult InitClass ( const nsCString & aClassName , JSContext * aContext , JSObject * aGlobal , JSObject * aScriptObject , JSObject ** aClassObject ) ; nsresult ConstructInterfaceTable ( const nsAString & aImpls ) ; void SetImplementation ( nsXBLProtoImpl * aImpl ) { mImplementation = aImpl ; } <START_VULN> nsresult InstallImplementation ( nsIContent * aBoundElement ) ; <END_VULN> bool HasImplementation ( ) const { return mImplementation != nullptr ; } void AttributeChanged ( nsIAtom * aAttribute , int32_t aNameSpaceID , bool aRemoveFlag , nsIContent * aChangedElement , nsIContent * aAnonymousContent , bool aNotify ) ; void SetBasePrototype ( nsXBLPrototypeBinding * aBinding ) ; nsXBLPrototypeBinding * GetBasePrototype ( ) { return mBaseBinding ; }
JSObject * obj ; void * ptr ; JSWhyMagic why ; size_t word ; } payload ; } s ; double asDouble ; void * asPtr ; <START_VULN> } jsval_layout ; <END_VULN> # elif JS_BITS_PER_WORD == 64 typedef union jsval_layout { uint64_t asBits ; struct { JSValueTag tag : 17 ; uint64_t payload47 : 47 ; } debugView ;
gss_buffer_t interprocess_token ) { OM_uint32 maj ; <START_VULN> iakerb_ctx_id_t ctx = ( iakerb_ctx_id_t ) context_handle ; <END_VULN> if ( ! ctx - > established )
static void l2tp_eth_dev_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <START_VULN> <END_VULN> dev - > netdev_ops = & l2tp_eth_netdev_ops ; dev - > destructor = free_netdev ; }
dir == - 1 - > result <= off dir == 0 - > result == off dir == 1 - > result >= off * <START_VULN> static RFlagsAtOffset * r_flag_get_nearest_list ( RFlag * f , ut64 off , int dir ) { <END_VULN> RFlagsAtOffset * flags = NULL ; RFlagsAtOffset key ; key . off = off ;
int ext_off , noff , weight ; size_t lt ; <START_VULN> if ( ( int ) ( l = np - > file - > basename_utf16 . length ) > ffmax ) <END_VULN> l = ffmax ; p = malloc ( ( l+1 ) * 2 ) ;
plgctx = pkinit_find_realm_context ( context , moddata , request - > server ) ; if ( plgctx == NULL ) { <START_VULN> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <END_VULN> return ; }
ret = anon_inode_getfd ( ops - > name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; if ( ret < 0 ) { <START_VULN> ops - > destroy ( dev ) ; <END_VULN> mutex_lock ( & kvm - > lock ) ; list_del ( & dev - > vm_node ) ; mutex_unlock ( & kvm - > lock ) ; return ret ; }
goto out_wakeup ; } <START_VULN> spin_lock ( & sma - > sem_perm . lock ) ; <END_VULN> curr = & sma - > sem_base [ semnum ] ; switch ( cmd ) {
void ImplSetSize ( sal_uInt16 nSize , bool bResize = true ) ; void ImplCreateFlagArray ( ) ; <START_VULN> void ImplSplit ( sal_uInt16 nPos , sal_uInt16 nSpace , ImplPolygon const * pInitPoly = nullptr ) ; <END_VULN> } ; #define MAX_POLYGONS ( ( sal_uInt16 ) 0x3FF0 )
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "DES & Triple DES EDE Cipher Algorithms , sparc64 des opcode accelerated" ) ; <START_VULN> MODULE_ALIAS ( "des" ) ; <END_VULN> #include "crop_devid . c"
if ( ! dev - > in_out_buffer ) return - ENOMEM ; <START_VULN> spin_lock_init ( & dev - > lock ) ; <END_VULN> ret = hid_parse ( hdev ) ; if ( ret ) {
static PHP_MINIT_FUNCTION ( pcre ) { REGISTER_INI_ENTRIES ( ) ; <START_VULN> <END_VULN> REGISTER_LONG_CONSTANT ( "PREG_PATTERN_ORDER" , PREG_PATTERN_ORDER , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( "PREG_SET_ORDER" , PREG_SET_ORDER , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( "PREG_OFFSET_CAPTURE" , PREG_OFFSET_CAPTURE , CONST_CS | CONST_PERSISTENT ) ;
unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; <START_VULN> int index , count , i ; <END_VULN> if ( get_user ( index , & c - > index ) || __get_user ( count , & c - > count ) ||
case EXPR_INVERT : case EXPR_NOT : <START_VULN> ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; <END_VULN> if ( ok ) * set_rtrn = ! * set_rtrn ; return ok ;
exit ( 1 ) ; } struct stat sb ; <START_VULN> char * pathname = RUNTIME_PATH "locklxcvarliblxc" ; <END_VULN> ret = stat ( pathname , & sb ) ; if ( ret != 0 ) { fprintf ( stderr , " % d : filename % s not created" , __LINE__ ,
frag - > len -= len ; } <START_VULN> if ( vcpu - > mmio_cur_fragment == vcpu - > mmio_nr_fragments ) { <END_VULN> vcpu - > mmio_needed = 0 ;
src = kmalloc ( req - > cryptlen + req - > assoclen , GFP_ATOMIC ) ; if ( ! src ) return - ENOMEM ; <START_VULN> assoc = ( src + req - > cryptlen + auth_tag_len ) ; <END_VULN> scatterwalk_map_and_copy ( src , req - > src , 0 , req - > cryptlen , 0 ) ; scatterwalk_map_and_copy ( assoc , req - > assoc , 0 , req - > assoclen , 0 ) ;
cl_allowDownload = Cvar_Get ( "cl_allowDownload" , "1" , CVAR_ARCHIVE ) ; #ifdef USE_CURL_DLOPEN <START_VULN> cl_cURLLib = Cvar_Get ( "cl_cURLLib" , DEFAULT_CURL_LIB , CVAR_ARCHIVE ) ; <END_VULN> #endif
err_locked : if ( move_group ) <START_VULN> mutex_unlock ( & gctx - > mutex ) ; <END_VULN> mutex_unlock ( & ctx - > mutex ) ; fput ( event_file ) ;
{ HTTPContext * s = h - > priv_data ; URLContext * old_hd = s - > hd ; <START_VULN> int64_t old_off = s - > off ; <END_VULN> uint8_t old_buf [ BUFFER_SIZE ] ; int old_buf_size , ret ; AVDictionary * options = NULL ;
unsigned int n_rdonly ; unsigned int n_wronly ; unsigned int n_rdwr ; <START_VULN> int state ; <END_VULN> atomic_t count ; } ;
BuiltInFunctionEmulator builtInFunctionEmulator ; TInfoSink infoSink ;
code FAR * next ; const unsigned short FAR * base ; const unsigned short FAR * extra ; <START_VULN> int end ; <END_VULN> unsigned short count [ MAXBITS+1 ] ; unsigned short offs [ MAXBITS+1 ] ; static const unsigned short lbase [ 31 ] = {
int mi_repair ( MI_CHECK * param , register MI_INFO * info , <START_VULN> char * name , int rep_quick ) <END_VULN> { int error , got_error ; ha_rows start_records , new_header_length ;
MODULE_DESCRIPTION ( "Serpent Cipher Algorithm , SSE2 optimized" ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "serpent" ) ; <END_VULN>
timr - > it_interval = timespec64_to_ktime ( new_setting - > it_interval ) ; expires = timespec64_to_ktime ( new_setting - > it_value ) ; <START_VULN> sigev_none = ( timr - > it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <END_VULN> kc - > timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ; timr - > it_active = ! sigev_none ;
} } } else { <START_VULN> for ( i = 0 ; i < sec - > size ; i + = 8 ) { <END_VULN> ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec - > paddr + i , addr64 , type , bits ) ;
void prependToViews ( ArrayBufferViewObject * viewsHead ) ; <START_VULN> void neuter ( JSContext * cx ) ; <END_VULN> static void trace ( JSTracer * trc , JSObject * obj ) ; } ;
} <START_VULN> if ( buf - > pts == AV_NOPTS_VALUE ) { <END_VULN> return write_to_fifo ( s - > fifo , buf ) ; }
class nsGIFDecoder2 : public Decoder { public : nsGIFDecoder2 ( RasterImage & aImage ) ; ~ nsGIFDecoder2 ( ) ; <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal ( ) ; virtual Telemetry : : ID SpeedHistogram ( ) ; private : void BeginGIF ( ) ;
phar_flush ( phar_obj - > arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; RETURN_FALSE ; } else {
return - ENETUNREACH ; } <START_VULN> if ( ! inet - > opt || ! inet - > opt - > srr ) <END_VULN> daddr = rt - > rt_dst ; if ( ! inet - > inet_saddr )
size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <START_VULN> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <END_VULN> int ret , i ; struct rb_node ** p , * parent ; unsigned int octets [ 4 ] ;
size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <START_VULN> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <END_VULN> unsigned long tmp ; char * p = ( char * ) page ; int ret = 0 ;
return res ; } <START_VULN> mp_err<END_VULN> ec_GFp_pt_add_jm_aff ( const mp_int * px , const mp_int * py , const mp_int * pz , const mp_int * paz4 , const mp_int * qx , const mp_int * qy , mp_int * rx , mp_int * ry , mp_int * rz , mp_int * raz4 , mp_int scratch [ ] , const ECGroup * group ) { mp_err res = MP_OKAY ; mp_int * A , * B , * C , * D , * C2 , * C3 ;
struct rf_tech_specific_params_nfcb_poll * nfcb_poll , __u8 * data ) { <START_VULN> nfcb_poll - > sensb_res_len = * data ++ ; <END_VULN> pr_debug ( "sensb_res_len % d" , nfcb_poll - > sensb_res_len ) ;
MODULE_DESCRIPTION ( "Twofish Cipher Algorithm , AVX optimized" ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "twofish" ) ; <END_VULN>
char * src ; char * dest = RUN_XAUTHORITY_FILE ; <START_VULN> <END_VULN> FILE * fp = fopen ( dest , "w" ) ; if ( fp ) { fprintf ( fp , "" ) ;
unsigned short * pixels = ( unsigned short * ) s - > frame . data [ 0 ] ; int row_ptr = 0 ; <START_VULN> int pixel_ptr = 0 ; <END_VULN> int block_ptr ; int pixel_x , pixel_y ; int total_blocks ;
if ( ! unifilename ) goto out1 ; <START_VULN> if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) <END_VULN> goto out2 ; if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_UTF8 ) ) {
err = - EIO ; <START_VULN> netdev - > hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; <END_VULN> netdev - > features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "Cast6 Cipher Algorithm" ) ; <START_VULN> MODULE_ALIAS ( "cast6" ) ; <END_VULN>
walk ++ ; } else return 0 ; <START_VULN> <END_VULN> if ( * walk && * walk >= '0' && * walk <= '9' ) { * backref = * backref * 10 + * walk - '0' ; walk ++ ;
} <START_VULN> bool f2fs_init_extent_tree ( struct inode * inode , struct f2fs_extent * i_ext ) <END_VULN> { struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; struct extent_tree * et ;
JS_BEGIN_EXTERN_C extern JSClass js_MathClass ; extern JSObject * js_InitMathClass ( JSContext * cx , JSObject * obj ) ; extern void <START_VULN> js_InitRandom ( JSThreadData * data ) ; <END_VULN> extern JSBool js_math_ceil ( JSContext * cx , uintN argc , jsval * vp ) ; extern JSBool js_math_floor ( JSContext * cx , uintN argc , jsval * vp ) ; extern JSBool
room = dst_mtu ( & rt - > dst ) ; if ( room > 576 ) room = 576 ; <START_VULN> room -= sizeof ( struct iphdr ) + icmp_param . replyopts . optlen ; <END_VULN> room -= sizeof ( struct icmphdr ) ; icmp_param . data_len = skb_in - > len - icmp_param . offset ;
phar_flush ( phar_obj - > arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; } break ;
int php_optind = 1 , use_extended_info = 0 ; char * ini_path_override = NULL ; char * ini_entries = NULL ; <START_VULN> int ini_entries_len = 0 ; <END_VULN> int ini_ignore = 0 ; sapi_module_struct * sapi_module = & cli_sapi_module ;
} static struct nfs4_opendata * nfs4_opendata_alloc ( struct path * path , <START_VULN> struct nfs4_state_owner * sp , int flags , <END_VULN> const struct iattr * attrs ) { struct dentry * parent = dget_parent ( path - > dentry ) ;
<START_VULN> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <END_VULN> if ( is_error_noslot_pfn ( pfn ) ) { gfn + = 1 ; continue ;
. compat_ioctl = compat_blkdev_ioctl , #endif . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> } ; int ioctl_by_bdev ( struct block_device * bdev , unsigned cmd , unsigned long arg )
list_add_tail ( & new_port - > list , & p - > list ) ; client - > num_ports ++ ; new_port - > addr . port = num ; write_unlock_irqrestore ( & client - > ports_lock , flags ) ; mutex_unlock ( & client - > ports_mutex ) ; <START_VULN> sprintf ( new_port - > name , "port - % d" , num ) ; <END_VULN> return new_port ; }
static __u8 * pl_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <START_VULN> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <END_VULN> rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) { hid_info ( hdev , "fixing up Petalynx Maxter Remote report descriptor" ) ;
. read_iter = xfs_file_read_iter , . write_iter = xfs_file_write_iter , . splice_read = xfs_file_splice_read , <START_VULN> . splice_write = xfs_file_splice_write , <END_VULN> . unlocked_ioctl = xfs_file_ioctl , #ifdef CONFIG_COMPAT . compat_ioctl = xfs_file_compat_ioctl ,
spin_unlock_irqrestore ( & i8042_lock , flags ) ; <START_VULN> if ( likely ( port - > exists && ! filtered ) ) <END_VULN> serio_interrupt ( serio , data , dfl ) ; out :
found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { <START_VULN> jas_eprintf ( "box type % s" , box - > info - > name ) ; <END_VULN> } switch ( box - > type ) { case JP2_BOX_JP2C :
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : channel mapping 0 implementation <START_VULN> last mod : $ Id : mapping0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < stdio . h > #include < string . h > #include < math . h > #include < oggogg . h >
int hns_rcb_get_ring_sset_count ( int stringset ) { <START_VULN> if ( stringset == ETH_SS_STATS ) <END_VULN> return HNS_RING_STATIC_REG_NUM ; return 0 ;
if ( hdr - > substreamid == info - > num_ind_sub + 1 ) { <START_VULN> avpriv_request_sample ( track - > par , "Multiple independent substreams" ) ; <END_VULN> ret = AVERROR_PATCHWELCOME ; goto end ; } else if ( hdr - > substreamid < info - > num_ind_sub ||
else regs . flags &= ~ PERF_EFLAGS_EXACT ; <START_VULN> if ( perf_event_overflow ( event , 1 , & data , & regs ) ) <END_VULN> x86_pmu_stop ( event , 0 ) ; }
int flags = 0 ; Elf32_Ehdr elf32hdr ; Elf64_Ehdr elf64hdr ; <START_VULN> uint16_t type ; <END_VULN> if ( ms - > flags & ( MAGIC_MIME | MAGIC_APPLE ) ) return 0 ;
#include "file . h" #ifndeflint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : funcs . c , v 1 . 80 20150102 21 : 29 : 39 christos Exp $ " ) <END_VULN> #endif #include "magic . h"
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS ) return - 1 ; if ( s - > interlaced && ( s - > bottom_field == ! s - > interlace_polarity ) ) { if ( nb_components != s - > nb_components ) { av_log ( s - > avctx , AV_LOG_ERROR , "nb_components changing in interlaced picture" ) ; return AVERROR_INVALIDDATA ; } } <START_VULN> if ( s - > ls && ! ( s - > bits <= 8 || nb_components == 1 ) ) { <END_VULN> avpriv_report_missing_feature ( s - > avctx , "JPEG - LS that is not <= 8 " "bitscomponent or 16 - bit gray" ) ; return AVERROR_PATCHWELCOME ; } s - > nb_components = nb_components ; s - > h_max = 1 ; s - > v_max = 1 ; memset ( h_count , 0 , sizeof ( h_count ) ) ; memset ( v_count , 0 , sizeof ( v_count ) ) ;
namespace XrayUtils { extern JSClass HolderClass ; bool CloneExpandoChain ( JSContext * cx , JSObject * src , JSObject * dst ) ; bool <START_VULN> IsTransparent ( JSContext * cx , JSObject * wrapper ) ; <END_VULN> JSObject * GetNativePropertiesObject ( JSContext * cx , JSObject * wrapper ) ; } class XrayTraits ; class XPCWrappedNativeXrayTraits ;
