else if ( ( out_ct & PNG_COLOR_MASK_ALPHA ) != 0 ) output_alpha = sample ( pRow , out_ct , out_bd , x , <START_VULN> samples_per_pixel ) ; <END_VULN> if ( output_alpha != 65536 ) alpha = gamma_component_validate ( "alpha" , & vi , input_alpha ,
} if ( mod_loc_name == NULL ) { <START_VULN> mod_loc_name = estrdup ( loc_name ) ; <END_VULN> }
{ BYTE c ; BYTE flags ; <START_VULN> int extra ; <END_VULN> int opIndex ; int haveBits ; int inPrefix ;
{ OnigCodePoint gcode = wordlist [ key ] . code ; <START_VULN> if ( code == gcode ) <END_VULN> return & wordlist [ key ] ; } }
{ DATA_TYPE * oX1 = out + n2 + n4 ; DATA_TYPE * oX2 = out + n2 + n4 ; DATA_TYPE * iX = out ; T = init -> trig + n2 ; <START_VULN> <END_VULN> do { oX1 -= 4 ; oX1 [ 3 ] = MULT_NORM ( iX [ 0 ] * T [ 1 ] - iX [ 1 ] * T [ 0 ] ) ; oX2 [ 0 ] = - MULT_NORM ( iX [ 0 ] * T [ 0 ] + iX [ 1 ] * T [ 1 ] ) ; oX1 [ 2 ] = MULT_NORM ( iX [ 2 ] * T [ 3 ] - iX [ 3 ] * T [ 2 ] ) ; oX2 [ 1 ] = - MULT_NORM ( iX [ 2 ] * T [ 2 ] + iX [ 3 ] * T [ 3 ] ) ;
void PopulateJSClass ( JSBool isGlobal ) ; void Mark ( ) { mFlags . Mark ( ) ; } void Unmark ( ) { mFlags . Unmark ( ) ; } JSBool IsMarked ( ) const { return mFlags . IsMarked ( ) ; } private : XPCNativeScriptableFlags mFlags ; <START_VULN> XPCNativeScriptableSharedJSClass mJSClass ; <END_VULN> JSBool mCanBeSlim ; } ; class XPCNativeScriptableInfo
oggpack_buffer * b ) ; #else static inline ogg_uint32_t decode_packed_entry_number ( codebook * book , <START_VULN> oggpack_buffer * b ) { <END_VULN> ogg_uint32_t chase = 0 ; int read = book -> dec_maxlength ; long lok = oggpack_look ( b , read ) , i ;
} if ( sco_listen ) { <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <END_VULN> fprintf ( stdout , "BT adapter is up" ) ; bt_property_t * property = property_new_scan_mode ( BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE ) ;
ZVAL_BOOL ( rval , parse_iv ( start + 2 ) ) ; return 1 ; } <START_VULN> #line 1228 "extstandardvar_unserializer . c"<END_VULN> yy87 : ++ YYCURSOR ; #line 573 "extstandardvar_unserializer . re"
} } else { if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ; <START_VULN> state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ; <END_VULN> state -> object_nl_len = len ; } return Qnil ;
} } } <START_VULN> #endif<END_VULN> #if defined ( PNG_READ_USER_TRANSFORM_SUPPORTED ) | | defined ( PNG_WRITE_USER_TRANSFORM_SUPPORTED )
if ( ! btpan_cb . congest_packet_size ) { <START_VULN> ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ; <END_VULN> switch ( ret ) { case - 1 : BTIF_TRACE_ERROR ( " % s unable to read from driver : % s" , __func__ , strerror ( errno ) ) ;
break ; } <START_VULN> for ( i = 0 ; * data && i < length ; i ++ , data ++ ) <END_VULN> ND_PRINT ( ( ndo , " % c" , ( * data < 32 | | * data > 126 ) ? ' . ' : * data ) ) ; return ;
<START_VULN> # ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED<END_VULN> return discard ; # else return 1 ;
bool done_ ; <START_VULN> const char * name_ ; <END_VULN> private : DISALLOW_COPY_AND_ASSIGN ( AutocompleteProvider ) ;
JSObject ** aRetval ) ; nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <START_VULN> unsigned char * aData , uint32_t aDataLen , <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , int32_t dirtyWidth , int32_t dirtyHeight ) ;
ppapi : : host : : ResourceHost * resource_host_ ; <START_VULN> Delegate * delegate_ ; <END_VULN> PP_DeviceType_Dev device_type_ ; GURL document_url_ ;
if ( png_ptr == NULL ) return ; <START_VULN> if ( ! ( png_ptr -> mode & PNG_HAVE_IDAT ) ) <END_VULN> png_error ( png_ptr , "No IDATs written into file" ) ; #ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
if ( mod_loc_name == NULL ) { mod_loc_name = estrdup ( loc_name ) ; } <START_VULN> <END_VULN> if ( ! disp_loc_name ) { disp_loc_name = estrdup ( intl_locale_get_default ( TSRMLS_C ) ) ;
} s -> width = AV_RL16 ( & s -> avctx -> extradata [ 6 ] ) ; s -> height = AV_RL16 ( & s -> avctx -> extradata [ 8 ] ) ; <START_VULN> if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) { <END_VULN> s -> width = s -> height = 0 ; return ret ; }
( void ) add_linux_shareopt ( plinux_opts , "no_root_squash" , NULL ) ; ( void ) add_linux_shareopt ( plinux_opts , "mountpoint" , NULL ) ; <START_VULN> rc = foreach_nfs_shareopt ( shareopts , get_linux_shareopts_cb , <END_VULN> plinux_opts ) ; if ( rc != SA_OK ) {
png_ptr -> save_buffer_size -= save_size ; png_ptr -> save_buffer_ptr += save_size ; } <START_VULN> if ( length && png_ptr -> current_buffer_size ) <END_VULN> { png_size_t save_size ;
char ** argv ) { mode_t old_umask ; <START_VULN> cleanup_free char * base_path = NULL ; <END_VULN> int clone_flags ; char * old_cwd = NULL ; pid_t pid ;
if ( hp -> conn && hp -> conn -> sock ) { obj = ejsCreateEmptyPot ( ejs ) ; for ( key = stok ( mprGetSocketState ( hp -> conn -> sock ) , " , " , & next ) ; key ; key = stok ( NULL , " , " , & next ) ) { <START_VULN> stok ( key , " = " , & value ) ; <END_VULN> ejsSetPropertyByName ( ejs , obj , EN ( key ) , ejsCreateStringFromAsc ( ejs , value ) ) ; } return obj ;
bool CanUpdateLayout ( ) override ; void DidUpdateMainFrameLayout ( ) override ; blink : : WebString AcceptLanguages ( ) override ; <START_VULN> void NavigateBackForwardSoon ( int offset ) override ; <END_VULN> int HistoryBackListCount ( ) override ; int HistoryForwardListCount ( ) override ; void ZoomLimitsChanged ( double minimum_level , double maximum_level ) override ;
distortion2 += distortion ; if ( cm -> interp_filter == SWITCHABLE ) <START_VULN> rate2 += vp9_get_switchable_rate ( x ) ; <END_VULN> if ( ! mode_excluded ) mode_excluded = comp_pred ? cm -> reference_mode == SINGLE_REFERENCE
#include < stdlib . h> #include < stdio . h> #include < string . h> <START_VULN> #include "compilerdebug . h"<END_VULN> #include "compilerpreprocessorslglobals . h" #undef malloc #undef realloc #undef free
void prependToViews ( ArrayBufferViewObject * viewsHead ) ; <START_VULN> void neuter ( JSContext * cx ) ; <END_VULN> static void trace ( JSTracer * trc , JSObject * obj ) ; } ;
class GPU_EXPORT TextureDefinition { public : <START_VULN> struct LevelInfo { <END_VULN> LevelInfo ( GLenum target , GLenum internal_format , GLsizei width ,
mpls_print ( ndo , p , l2info . length ) ; return l2info . header_len ; case JUNIPER_LSQ_L3_PROTO_ISO : <START_VULN> isoclns_print ( ndo , p , l2info . length , l2info . caplen ) ; <END_VULN> return l2info . header_len ; default : break ;
#ifndef _V_LSP_H_ #define _V_LSP_H_ extern int vorbis_lpc_to_lsp ( float * lpc , float * lsp , int m ) ; extern void vorbis_lsp_to_curve ( float * curve , int * map , int n , int ln , float * lsp , int m , float amp , float ampoffset ) ; <START_VULN> <END_VULN> #endif
png_pass_start [ png_ptr -> pass ] ) png_pass_inc [ png_ptr -> pass ] ; <START_VULN> if ( ! ( png_ptr -> transformations & PNG_INTERLACE ) ) <END_VULN> { png_ptr -> num_rows = ( png_ptr -> height + png_pass_yinc [ png_ptr -> pass ] - 1 -
#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED static void <START_VULN> modifier_current_encoding ( PNG_CONST png_modifier * pm , color_encoding * ce ) <END_VULN> { if ( pm -> current_encoding != 0 ) * ce = * pm -> current_encoding ;
png_ptr -> background_gamma_type = PNG_BACKGROUND_GAMMA_FILE ; png_ptr -> transformations &= ~ PNG_BACKGROUND_EXPAND ; <START_VULN> if ( png_ptr -> transformations & PNG_COMPOSE ) <END_VULN> png_error ( png_ptr , "conflicting calls to set alpha mode and background" ) ;
matched = 0 ; PCRE_G ( error_code ) = PHP_PCRE_NO_ERROR ; <START_VULN> <END_VULN> do { count = pcre_exec ( pce -> re , extra , subject , subject_len , start_offset ,
def = sfmt ( " [ % s ] " , sjoinArgs ( argc - 2 , ( cchar ** ) & argv [ 2 ] , " , " ) ) ; abilities = mprParseJson ( def ) ; key = sfmt ( "app . http . auth . roles . % s" , rolename ) ; <START_VULN> if ( mprSetJsonObj ( app -> config , key , abilities ) < 0 ) { <END_VULN> fail ( "Cannot update % s" , key ) ; return ; }
inline void JSObject : : initCall ( JSContext * cx , const js : : Bindings & bindings , JSObject * parent ) { init ( cx , & js : : CallClass , & js : : types : : emptyTypeObject , parent , NULL , false ) ; <START_VULN> lastProp = bindings . lastShape ( ) ; <END_VULN> if ( bindings . extensibleParents ( ) ) setOwnShape ( js_GenerateShape ( cx ) ) ; else
class EncodedFormData ; class ScriptState ; <START_VULN> class MODULES_EXPORT BodyStreamBuffer final : public UnderlyingSourceBase , public UnderlyingSource , public WebDataConsumerHandle : : Client { <END_VULN> WTF_MAKE_NONCOPYABLE ( BodyStreamBuffer ) ; USING_GARBAGE_COLLECTED_MIXIN ( BodyStreamBuffer ) ; public :
#include < string> <START_VULN> #include "basecallback . h"<END_VULN> #include "basegtest_prod_util . h" #include "contentbrowsercancelable_request . h"
} while ( -- count > 0 ) ; <START_VULN> printf ( " % d tests including % d overflows , % d passed , % d failed ( % d 64 bit "<END_VULN> "errors ) " , tested , overflow , passed , error , error64 ) ; return 0 ; }
nsLayoutUtils : : SurfaceFromElementResult SurfaceFromElement ( const dom : : NonNull < ElementType> & aElement ) { return SurfaceFromElement ( aElement . get ( ) ) ; } nsresult SurfaceFromElementResultToImageSurface ( nsLayoutUtils : : SurfaceFromElementResult & res , gfxImageSurface ** imageOut , WebGLTexelFormat * format ) ; <START_VULN> void CopyTexSubImage2D_base ( WebGLenum target , <END_VULN> WebGLint level , WebGLenum internalformat , WebGLint xoffset , WebGLint yoffset , WebGLint x , WebGLint y , WebGLsizei width , WebGLsizei height ,
fwrite ( signature , sizeof signature , 1 , stdout ) ; put_chunk ( IHDR , sizeof IHDR ) ; <START_VULN> for ( ; ; ) <END_VULN> put_chunk ( unknown , sizeof unknown ) ; }
#endif #endif <START_VULN> if ( strict ) <END_VULN> { png_set_benign_errors ( read_ptr , 0 ) ;
if ( out == NULL ) { return ; } <START_VULN> gdImageWebpCtx ( im , out , quality ) ; <END_VULN> out -> gd_free ( out ) ; }
bool mFullScreen ; void * mJavaView ; #endif nsPluginNativeWindow * mPluginWindow ; nsRefPtr < nsNPAPIPluginInstance> mInstance ; nsPluginFrame * mPluginFrame ; <START_VULN> nsIContent * mContent ; <END_VULN> nsCString mDocumentBase ; bool mWidgetCreationComplete ; nsCOMPtr < nsIWidget> mWidget ; nsRefPtr < nsPluginHost> mPluginHost ; #ifdef XP_MACOSX NP_CGContext mCGPluginPortCopy ; int32_t mInCGPaintLevel ;
<START_VULN> <END_VULN> virtual const extensions : : Extension * GetInstalledExtension ( const std : : string & id ) const = 0 ;
#include "uiviewscontrolsbuttonbutton . h" #include "uiviewscontrolslink_listener . h" #include "uiviewscontrolsseparator . h" <START_VULN> #include "uiviewscontrolsstyled_label . h"<END_VULN> #include "uiviewscontrolsstyled_label_listener . h" #include "uiviewswidgetwidget . h" class BubbleHeaderView ; class GURL ; class Profile ; namespace content {
} #endif } <START_VULN> #endif<END_VULN>
} # ifdef PNG_WRITE_SUPPORTED <START_VULN> <END_VULN> else if ( unsupported_chunks > 0 ) { fprintf ( STDERR , " % s : unsupported chunks ( % d ) % s" ,
LayerTreeContext m_layerTreeContext ; bool m_shouldSyncFrame ; bool m_shouldSyncRootLayer ; <START_VULN> void layerFlushTimerFired ( WebCore : : Timer < LayerTreeCoordinator> * ) ; <END_VULN> WebCore : : Timer < LayerTreeCoordinator> m_layerFlushTimer ; bool m_layerFlushSchedulingEnabled ; uint64_t m_forceRepaintAsyncCallbackID ; } ;
re = js_toregexp ( J , - 1 ) ; <START_VULN> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <END_VULN> js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; else js_pushnumber ( J , - 1 ) ;
yy_size_t yyl ; for ( yyl = 0 ; yyl < yyleng ; ++ yyl ) if ( yytext [ yyl ] == '' ) <START_VULN> <END_VULN> do { yylineno ++ ; yycolumn = 0 ; } while ( 0 )
if ( imsx > max_x | | imsy > max_y ) { dmsx = max_x ; dmsy = max_y ; <START_VULN> if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ) == NULL ) { <END_VULN> imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; return ( MagickFalse ) ; }
state = Colon ; break ; } <START_VULN> <END_VULN> state = SkipLine ;
{ ether_setup ( dev ) ; <START_VULN> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <END_VULN> dev -> netdev_ops = & macvlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> header_ops = & macvlan_hard_header_ops ,
static void allocate ( struct file * file , int allocate_idat ) { <START_VULN> struct control * control = png_voidcast ( struct control * , file -> alloc_ptr ) ; <END_VULN> if ( allocate_idat ) {
private : std : : unique_ptr < content : : ContentClient> content_client_ ; <START_VULN> std : : unique_ptr < content : : ContentBrowserClient> browser_client_ ; <END_VULN> zx : : channel context_channel_ ;
list -> count = 0 ; file -> idat -> idat_list_tail = list ; } <START_VULN> <END_VULN> list -> lengths [ ( list -> count ) ++ ] = file -> chunk -> chunk_length ;
! ( r & ( num_8x8_blocks_high_lookup [ sb_type ] - 1 ) ) : 1 ; const int skip_this_r = skip_this && ! block_edge_above ; const TX_SIZE tx_size = ( plane -> plane_type == PLANE_TYPE_UV ) <START_VULN> ? get_uv_tx_size ( & mi [ 0 ] . mbmi ) <END_VULN> : mi [ 0 ] . mbmi . tx_size ; const int skip_border_4x4_c = ss_x && mi_col + c == cm -> mi_cols - 1 ; const int skip_border_4x4_r = ss_y && mi_row + r == cm -> mi_rows - 1 ;
ZVAL_DOUBLE ( * rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ; return 1 ; } <START_VULN> #line 1069 "extstandardvar_unserializer . c"<END_VULN> yy65 : yych = * ++ YYCURSOR ; if ( yych <= ' , ' ) {
in [ 0 ] = _mm_add_epi16 ( in [ 0 ] , k__nonzero_bias_b ) ; } <START_VULN> static INLINE void write_buffer_4x4 ( int16_t * output , __m128i * res ) { <END_VULN> const __m128i kOne = _mm_set1_epi16 ( 1 ) ; __m128i in01 = _mm_unpacklo_epi64 ( res [ 0 ] , res [ 1 ] ) ; __m128i in23 = _mm_unpacklo_epi64 ( res [ 2 ] , res [ 3 ] ) ;
if ( ! obj | | ! child ) { return 0 ; } <START_VULN> if ( ( existing = mprLookupJsonObj ( obj , name ) ) != 0 ) { <END_VULN> existing -> value = child -> value ; existing -> children = child -> children ; existing -> type = child -> type ;
if ( name ) { <START_VULN> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <END_VULN> sprintf ( dst_name , " % s % s" , name , name ) ; if ( ( c = strrchr ( dst_name , ' . ' ) ) && ( strncmp ( c , " . pdf" , 4 ) == 0 ) )
return ; trunc : <START_VULN> ND_PRINT ( ( ndo , " [ | dao - truncated ] " ) ) ; <END_VULN> return ; tooshort :
int num_unknowns = png_get_unknown_chunks ( read_ptr , end_info_ptr , & unknowns ) ; <START_VULN> if ( num_unknowns ) <END_VULN> { png_set_unknown_chunks ( write_ptr , write_end_info_ptr , unknowns , num_unknowns ) ;
uint32_t lineIndexToNum ( uint32_t lineIndex ) const { return lineIndex + initialLineNum_ ; } uint32_t lineNumToIndex ( uint32_t lineNum ) const { return lineNum - initialLineNum_ ; } public : SourceCoords ( JSContext * cx , uint32_t ln ) ; void add ( uint32_t lineNum , uint32_t lineStartOffset ) ; <START_VULN> void fill ( const SourceCoords & other ) ; <END_VULN> bool isOnThisLine ( uint32_t offset , uint32_t lineNum ) const { uint32_t lineIndex = lineNumToIndex ( lineNum ) ; JS_ASSERT ( lineIndex + 1 < lineStartOffsets_ . length ( ) ) ; return lineStartOffsets_ [ lineIndex ] <= offset && offset < lineStartOffsets_ [ lineIndex + 1 ] ; }
static int image_transform_png_set_strip_16_add ( image_transform * this , <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <END_VULN> { UNUSED ( colour_type )
TFunctionSign3 ,
virtual ~ DesktopSessionWin ( ) ; <START_VULN> virtual void OnChannelConnected ( ) OVERRIDE ; <END_VULN> virtual bool OnMessageReceived ( const IPC : : Message & message ) OVERRIDE ; virtual void OnPermanentError ( ) OVERRIDE ;
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
@description The supported format is : [ ( + | - ) ] [ 0 ] [ ( x | X ) ] [ HEX_DIGITS ] @return true if all characters are digits or 'x' or 'X' @ingroup MprString <START_VULN> @stability Evolving<END_VULN> PUBLIC bool shnumber ( cchar * s ) ;
if ( ++ channel > = channels ) channel = 0 ; * bp ++ = ( png_byte ) ( value >> 8 ) ; <START_VULN> * bp ++ = ( png_byte ) ( value & 0xff ) ; <END_VULN> } break ; }
#ifndef MODULE_MAGIC_NUMBER_MAJOR #define MODULE_MAGIC_NUMBER_MAJOR 20150222 #endif <START_VULN> #define MODULE_MAGIC_NUMBER_MINOR 2<END_VULN> AP_DECLARE ( int ) ap_some_auth_required ( request_rec * r ) ;
if ( ( cm -> frame_type == KEY_FRAME ) | | ( cm -> refresh_golden_frame ) ) { <START_VULN> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <END_VULN> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; } else
{ return 1 ; } <START_VULN> mpz_powm ( v , v , key -> e , key -> n ) ; <END_VULN> return 0 ; }
return res ; } <START_VULN> mp_err<END_VULN> ec_GFp_pt_add_jm_aff ( const mp_int * px , const mp_int * py , const mp_int * pz , const mp_int * paz4 , const mp_int * qx , const mp_int * qy , mp_int * rx , mp_int * ry , mp_int * rz , mp_int * raz4 , mp_int scratch [ ] , const ECGroup * group ) { mp_err res = MP_OKAY ; mp_int * A , * B , * C , * D , * C2 , * C3 ;
{ fprintf ( stderr , "usage : ssh - agent [ - c | - s ] [ - Dd ] [ - a bind_address ] [ - E fingerprint_hash ] " <START_VULN> " [ - t life ] [ command [ arg . . . ] ] "<END_VULN> " ssh - agent [ - c | - s ] - k" ) ; exit ( 1 ) ; }
ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; <START_VULN> ps_dec -> u4_first_slice_in_pic = 2 ; <END_VULN> ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ;
<START_VULN> PHP_FUNCTION ( locale_get_display_script ) <END_VULN> { get_icu_disp_value_src_php ( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; }
phar_flush ( phar_obj -> arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
{ int status = - 1 ; BYTE descriptor ; <START_VULN> <END_VULN> wStream * stream = Stream_New ( ( BYTE * ) pSrcData , SrcSize ) ; if ( ! stream ) return - 1 ;
#define COL_FROM_ID ( id ) ( ( png_byte ) ( ( id ) & 0x7U ) ) #define DEPTH_FROM_ID ( id ) ( ( png_byte ) ( ( ( id ) >> 3 ) & 0x1fU ) ) #define PALETTE_FROM_ID ( id ) ( ( ( id ) >> 8 ) & 0x1f ) <START_VULN> #define INTERLACE_FROM_ID ( id ) ( ( int ) ( ( ( id ) >> 13 ) & 0x3 ) ) <END_VULN> #define DO_INTERLACE_FROM_ID ( id ) ( ( int ) ( ( ( id ) >> 15 ) & 1 ) ) #define WIDTH_FROM_ID ( id ) ( ( ( id ) >> 16 ) & 0xff ) #define HEIGHT_FROM_ID ( id ) ( ( ( id ) >> 24 ) & 0xff )
if ( argc < 2 | | ! WriteStatusFailure ( argv [ 1 ] , SERVICE_NOT_ENOUGH_COMMAND_LINE_ARGS ) ) { LOG_WARN ( ( "Could not write update . status service update failure . ( % d ) " , GetLastError ( ) ) ) ; } return FALSE ; } <START_VULN> WCHAR installDir [ MAX_PATH ] = { L'0' } ; <END_VULN> if ( ! GetInstallationDir ( argc , argv , installDir ) ) { LOG_WARN ( ( "Could not get the installation directory" ) ) ; if ( ! WriteStatusFailure ( argv [ 1 ] , SERVICE_INSTALLDIR_ERROR ) ) { LOG_WARN ( ( "Could not write update . status for GetInstallationDir failure . " ) ) ; } return FALSE ; }
IPV6_SET_L4PROTO ( p , nh ) ; hdrextlen = ( * ( pkt + 1 ) + 1 ) << 3 ; if ( hdrextlen > plen ) { <START_VULN> ENGINE_SET_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <END_VULN> SCReturn ; }
SPL_METHOD ( SplFileObject , rewind ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
if ( ! high_sierra ) { <START_VULN> parse_rock_ridge_inode ( de , inode ) ; <END_VULN> if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ;
double doubleinfo ; while ( ptr && * ptr ) { <START_VULN> if ( ' % ' == * ptr ) { <END_VULN> if ( ' % ' == ptr [ 1 ] ) { fputc ( ' % ' , stream ) ;
RenderBox ( Node * ) ; virtual ~ RenderBox ( ) ; <START_VULN> virtual bool requiresLayer ( ) const OVERRIDE { return isRoot ( ) | | isPositioned ( ) | | isRelPositioned ( ) | | isTransparent ( ) | | hasOverflowClip ( ) | | hasTransform ( ) | | hasHiddenBackface ( ) | | hasMask ( ) | | hasReflection ( ) | | hasFilter ( ) | | style ( ) -> specifiesColumns ( ) ; } <END_VULN> RenderBox * firstChildBox ( ) const ;
if ( IsFullyDefined < T> : : value && ! IsGarbageCollectedMixin < T> : : value ) <START_VULN> ASSERT ( HeapObjectHeader : : fromPayload ( m_raw ) -> checkHeader ( ) ) ; <END_VULN> #endif #endif }
exit ( 1 ) ; } for ( i = 0 ; i < TESTSIZE ; i ++ ) if ( fabs ( qv [ i ] - iv [ i ] ) > . 000001 ) { fprintf ( stderr , "read ( % g ) != written ( % g ) at position ( % ld ) " , iv [ i ] , qv [ i ] , i ) ; exit ( 1 ) ; } <START_VULN> <END_VULN> fprintf ( stderr , "OK" ) ; ptr ++ ; } exit ( 0 ) ; }
} png_write_row ( png_ptr , png_voidcast ( png_const_bytep , <START_VULN> display -> local_row ) ) ; <END_VULN> input_row += display -> row_bytes ( sizeof ( png_uint_16 ) ) ; } }
<START_VULN> <END_VULN> % lld" , st -> st_size ) ;
public : <START_VULN> HistoryContentsProvider ( ACProviderListener * listener , <END_VULN> Profile * profile , bool body_only ) ;
#include < atlcom . h> #include < string> <START_VULN> #include "basecallback . h"<END_VULN> #include "basethreadingplatform_thread . h" #include "netbasenet_errors . h" #include "nethttphttp_response_headers . h"
if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; <START_VULN> if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) <END_VULN> goto MATLAB_KO ; filepos += ( MagickOffsetType ) MATLAB_HDR . ObjectSize + 4 + 4 ;
et_listselected , et_listdoubleclick , et_scrollbarchange , et_textchanged , et_textfocuschanged , <START_VULN> et_lastsubtype } ; <END_VULN> enum sb { et_sb_top , et_sb_uppage , et_sb_up , et_sb_left = et_sb_up , et_sb_down , et_sb_right = et_sb_down , et_sb_downpage ,
#define CHROME_BROWSER_UI_VIEWS_INFOBARS_EXTENSION_INFOBAR_H_ #pragma once <START_VULN> #include "chromebrowseruiviewsinfobarsinfobars . h"<END_VULN> #include "chromebrowserextensionsextension_infobar_delegate . h" #include "chromebrowserextensionsimage_loading_tracker . h"
} tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ; <START_VULN> <END_VULN> if ( snprintf ( scratch , scratch_len , "Authorization : Basic % sr" , tmp ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ;
@param hash MprHash object @return An MprJson instance @ingroup MprJson <START_VULN> @stability Prototype<END_VULN> PUBLIC MprJson * mprHashToJson ( MprHash * hash ) ;
#pragma once #include "basebasictypes . h" <START_VULN> #include "basecallback . h"<END_VULN> namespace chromeos {
} } else { <START_VULN> syslog ( LOG_WARNING , _ ( " ( % d ) Unhandeled control packet type : % d" ) , curconn -> seskey , cpkt . cptype ) ; <END_VULN> }
DISALLOW_COPY_AND_ASSIGN ( ChromeWebUIControllerFactory ) ; } ; <START_VULN> #endif<END_VULN>
strlcpy ( psz_server , psz_path , sizeof ( psz_server ) ) ; psz_share [ 0 ] = 0 ; psz_parser = strchr ( psz_path , '' ) ; if ( psz_parser ) { char * psz_parser2 = strchr ( ++ psz_parser , '' ) ; if ( psz_parser2 ) strlcpy ( psz_share , psz_parser , sizeof ( psz_share ) ) ; } <START_VULN> sprintf ( psz_remote , " % s % s" , psz_server , psz_share ) ; <END_VULN> net_resource . lpRemoteName = psz_remote ; i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ) ; if ( i_result != NO_ERROR ) { msg_Dbg ( p_access , "connected to % s" , psz_remote ) ; } else if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )
max_screen_colors , histogram , 0 ) ; } } <START_VULN> #endif<END_VULN> png_set_invert_mono ( png_ptr ) ;
efree ( stack ) ; done : <START_VULN> im -> alphaBlendingFlag = alphablending_bak ; <END_VULN> } static void _gdImageFillTiled ( gdImagePtr im , int x , int y , int nc )
{ spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; long size ; <START_VULN> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "l" , & size ) == FAILURE ) { return ; }
& _vq_book_res0a_13 , NULL } ; float * testvec [ ] = { test1 , test3 } ; int main ( ) { oggpack_buffer write ; oggpack_buffer read ; long ptr = 0 , i ; oggpack_writeinit ( & write ) ; <START_VULN> <END_VULN> fprintf ( stderr , "Testing codebook abstraction . . . : " ) ; while ( testlist [ ptr ] ) { codebook c ; static_codebook s ; float * qv = alloca ( sizeof ( * qv ) * TESTSIZE ) ; float * iv = alloca ( sizeof ( * iv ) * TESTSIZE ) ; memcpy ( qv , testvec [ ptr ] , sizeof ( * qv ) * TESTSIZE ) ;
if ( test ) { fname = test ; <START_VULN> fname_len = ( php_stat_len ) strlen ( fname ) ; <END_VULN> } else { zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 , "Could not resolve file path" ) ; return ZEND_HASH_APPLY_STOP ;
if ( req -> trb ) memset ( req -> trb , 0 , sizeof ( struct dwc3_trb ) ) ; dep -> queued_requests -- ; <START_VULN> dwc3_gadget_giveback ( dep , req , ret ) ; <END_VULN> return ret ; }
current_element = object -> child ; if ( case_sensitive ) { <START_VULN> while ( ( current_element != NULL ) && ( strcmp ( name , current_element -> string ) != 0 ) ) <END_VULN> { current_element = current_element -> next ; }
EXPECT_TRUE ( this -> SetCanonicalCookie ( cs , <START_VULN> base : : MakeUnique < CanonicalCookie> ( <END_VULN> "C" , "D" , " . " + foo_bar_domain , "bar" , two_hours_ago , base : : Time ( ) , one_hour_ago , false , true , CookieSameSite : : DEFAULT_MODE , COOKIE_PRIORITY_DEFAULT ) ,
{ 101 , 21 , 107 , 181 , 192 , 103 , 19 , 67 , 125 } } ; <START_VULN> const vp9_prob vp9_kf_partition_probs [ PARTITION_CONTEXTS ] <END_VULN> [ PARTITION_TYPES - 1 ] = { { 158 , 97 , 94 } ,
BTIF_TRACE_DEBUG ( "set curr_set = org_set " ) ; curr_set = org_set ; max_curr_s = max_org_s ; <START_VULN> int ret = select ( ( max_curr_s + 1 ) , & curr_set , NULL , NULL , NULL ) ; <END_VULN> BTIF_TRACE_DEBUG ( "select unblocked ret = % d" , ret ) ; if ( ret == - 1 ) {
class BrightnessLibrary ; class BurnLibrary ; class CryptohomeLibrary ; <START_VULN> class KeyboardLibrary ; <END_VULN> class InputMethodLibrary ; class LibraryLoader ; class LoginLibrary ; class MountLibrary ;
virtual ~ IMediaDeathNotifier ( ) { removeObitRecipient ( this ) ; } virtual void died ( ) = 0 ; <START_VULN> static const sp < IMediaPlayerService> & getMediaPlayerService ( ) ; <END_VULN> private : IMediaDeathNotifier & operator = ( const IMediaDeathNotifier & ) ;
class ResizeGripperDelegate { <START_VULN> public : <END_VULN>
@param json JSON object tree @return An MprHash instance @ingroup MprJson <START_VULN> @stability Prototype<END_VULN> PUBLIC MprHash * mprJsonToHash ( MprJson * json ) ;
<START_VULN> PHP_FUNCTION ( locale_get_display_region ) <END_VULN> { get_icu_disp_value_src_php ( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ; }
{ sock_cmd_t cmd = { - 1 , 0 , 0 , 0 , 0 } ; int fd = ts [ h ] . cmd_fdr ; <START_VULN> if ( recv ( fd , & cmd , sizeof ( cmd ) , MSG_WAITALL ) != sizeof ( cmd ) ) <END_VULN> { APPL_TRACE_ERROR ( "recv cmd errno : % d" , errno ) ; return FALSE ;
offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; tnl_hlen = skb_tnl_header_len ( skb ) ; <START_VULN> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <END_VULN> if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ;
private int32_t moffset ( struct magic_set * , struct magic * ) ; private void mdebug ( uint32_t , const char * , size_t ) ; private int mcopy ( struct magic_set * , union VALUETYPE * , int , int , <START_VULN> const unsigned char * , uint32_t , size_t , size_t ) ; <END_VULN> private int mconvert ( struct magic_set * , struct magic * , int ) ; private int print_sep ( struct magic_set * , int ) ; private int handle_annotation ( struct magic_set * , struct magic * ) ;
return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; lock_sock ( sk ) ; switch ( optname ) { case TCP_MAXSEG : <START_VULN> if ( val < 8 | | val > MAX_TCP_WINDOW ) { <END_VULN> err = - EINVAL ; break ; } tp -> rx_opt . user_mss = val ; break ; case TCP_NODELAY : if ( val ) { tp -> nonagle |= TCP_NAGLE_OFF | TCP_NAGLE_PUSH ;
pixmap . bits_per_pixel = 32 ; pixmap . pack_type = 0x04 ; transfer_mode = 0x40 ; <START_VULN> row_bytes = ( unsigned short ) ( ( 4 * image -> columns ) | 0x8000 ) ; <END_VULN> } Allocate memory .
ide_set_irq ( s -> bus ) ; return false ; case SMART_EXECUTE_OFFLINE : switch ( s -> sector ) { case 0 : case 1 : case 2 : s -> smart_selftest_count ++ ; if ( s -> smart_selftest_count > 21 ) { <START_VULN> s -> smart_selftest_count = 0 ; <END_VULN> } n = 2 + ( s -> smart_selftest_count - 1 ) * 24 ; s -> smart_selftest_data [ n ] = s -> sector ; s -> smart_selftest_data [ n + 1 ] = 0x00 ; s -> smart_selftest_data [ n + 2 ] = 0x34 ; s -> smart_selftest_data [ n + 3 ] = 0x12 ; break ; default : goto abort_cmd ; }
static int bgp_attr_print ( netdissect_options * ndo , <START_VULN> u_int atype , const u_char * pptr , u_int len ) <END_VULN> { int i ; uint16_t af ;
<START_VULN> class FilePath { <END_VULN> public : #if defined ( OS_POSIX )
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : basic codebook packunpackcodedecode operations <START_VULN> last mod : $ Id : codebook . c 16227 2009 - 07 - 08 06 : 58 : 46Z xiphmont $ <END_VULN> #include < stdlib . h> #include < string . h> #include < math . h> #include < oggogg . h> #include "vorbiscodec . h"
for ( lvl = 0 ; lvl <= MAX_LOOP_FILTER ; lvl ++ ) { <START_VULN> <END_VULN> int block_inside_limit = lvl >> ( ( sharpness_lvl > 0 ) + ( sharpness_lvl > 4 ) ) ; if ( sharpness_lvl > 0 ) {
file -> path = * in_path ; for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <START_VULN> int j , len = apdu . resp [ i + 1 ] ; <END_VULN> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; switch ( type ) {
zlib -> file_bits = file_bits ; if ( new_bits == 0 ) <START_VULN> zlib -> window_bits = file_bits ; <END_VULN> else if ( new_bits != file_bits ) bIn = ( png_byte ) ( ( bIn & 0xf ) + ( ( new_bits - 8 ) << 4 ) ) ;
{ MOZ_COUNT_DTOR ( nsXBLProtoImpl ) ; delete mMembers ; delete mFields ; } <START_VULN> nsresult InstallImplementation ( nsXBLPrototypeBinding * aBinding , nsIContent * aBoundElement ) ; <END_VULN> nsresult InitTargetObjects ( nsXBLPrototypeBinding * aBinding , nsIScriptContext * aContext , nsIContent * aBoundElement , nsIXPConnectJSObjectHolder ** aScriptObjectHolder , JSObject ** aTargetClassObject ) ; nsresult CompilePrototypeMembers ( nsXBLPrototypeBinding * aBinding ) ; void SetMemberList ( nsXBLProtoImplMember * aMemberList ) {
<START_VULN> MockPrinter * printer ( ) const { return printer_ . get ( ) ; } <END_VULN>
if ( size > batadv_frag_size_limit ( ) ) goto free ; entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) ; hlist_del ( & entry -> list ) ; skb_out = entry -> skb ; kfree ( entry ) ; <START_VULN> if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { <END_VULN> kfree_skb ( skb_out ) ; skb_out = NULL ; goto free ; } skb_pull_rcsum ( skb_out , hdr_size ) ; memmove ( skb_out -> data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ) ; skb_set_mac_header ( skb_out , - ETH_HLEN ) ; skb_reset_network_header ( skb_out ) ;
#include < assert . h> #include "vpx_config . h" #include "vp8_rtcd . h" <START_VULN> #include "vp8commonpragmas . h"<END_VULN> #include "tokenize . h" #include "treewriter . h" #include "onyx_int . h"
case PNG_COLOR_TYPE_PALETTE : { <START_VULN> PNG_CONST unsigned int index = component ( row , x , 0 , bit_depth , 1 ) ; <END_VULN> png_colorp palette = NULL ; int num_palette = 0 ;
if ( ! str ) return false ; size_t length ; const jschar * chars = JS_GetStringCharsAndLength ( cx , str , & length ) ; if ( ! chars ) return false ; NS_ConvertUTF16toUTF8 utf8str ( reinterpret_cast < const PRUnichar * > ( chars ) ) ; #ifdef ANDROID <START_VULN> __android_log_print ( ANDROID_LOG_INFO , "Gecko" , utf8str . get ( ) ) ; <END_VULN> #endif fputs ( utf8str . get ( ) , stdout ) ; fflush ( stdout ) ; return true ; }
} if ( drop_it | | ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ; <START_VULN> if ( drop_it | | ioctl ( sock -> our_fd , FIONREAD , & size ) != 0 | | size == 0 ) <END_VULN> btsock_l2cap_free_l ( sock ) ; } }
case BGP_ATTR_EXT_COMMUNITIES : ret = bgp_attr_ext_communities ( & attr_args ) ; break ; <START_VULN> #if ENABLE_BGP_VNC<END_VULN> case BGP_ATTR_VNC : #endif case BGP_ATTR_ENCAP :
} } for ( i = 1 ; i < argc && ! app -> error ; i ++ ) { <START_VULN> field = stok ( sclone ( argv [ i ] ) , " : " , & typeString ) ; <END_VULN> if ( ( type = ediParseTypeString ( typeString ) ) < 0 ) { fail ( "Unknown type ' % s' for field ' % s'" , typeString , field ) ; break ;
# define PNG_IMAGE_WARNING 1 # define PNG_IMAGE_ERROR 2 #define PNG_FORMAT_FLAG_ALPHA 0x01U #define PNG_FORMAT_FLAG_COLOR 0x02U <START_VULN> #define PNG_FORMAT_FLAG_LINEAR 0x04U<END_VULN> #define PNG_FORMAT_FLAG_COLORMAP 0x08U #ifdef PNG_FORMAT_BGR_SUPPORTED
TrackTicks inputEndTicks = TimeToTicksRoundUp ( rate , inputEnd ) ; TrackTicks inputStartTicks = inputEndTicks - ticks ; <START_VULN> segment -> AppendSlice ( * inputTrack -> GetSegment ( ) , <END_VULN> NS_MIN ( inputTrackEndPoint , inputStartTicks ) , NS_MIN ( inputTrackEndPoint , inputEndTicks ) ) ; LOG ( PR_LOG_DEBUG , ( "TrackUnionStream % p appending % lld ticks of input data to track % d" , this , ( long long ) ( NS_MIN ( inputTrackEndPoint , inputEndTicks ) - NS_MIN ( inputTrackEndPoint , inputStartTicks ) ) , outputTrack -> GetID ( ) ) ) ; } for ( uint32_t j = 0 ; j < mListeners . Length ( ) ; ++ j ) { MediaStreamListener * l = mListeners [ j ] ;
<START_VULN> if ( compose ) <END_VULN> { memset ( & png_ptr -> background , 0 , ( sizeof png_ptr -> background ) ) ;
char delimiter = ' , ' , enclosure = '"' , escape = '' ; char * delim = NULL , * enclo = NULL , * esc = NULL ; int d_len = 0 , e_len = 0 , esc_len = 0 ; <START_VULN> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , " | sss" , & delim , & d_len , & enclo , & e_len , & esc , & esc_len ) == SUCCESS ) { switch ( ZEND_NUM_ARGS ( ) ) {
struct perf_event * event , struct pt_regs * regs ) ; <START_VULN> extern int perf_event_overflow ( struct perf_event * event , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) ;
| Sara Golemon < pollita@php . net> | + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- + <START_VULN> <END_VULN> #include "php . h" #include "php_globals . h"
size += 16 ; <START_VULN> if ( ! ( buf = g_try_malloc ( size ) ) ) { <END_VULN> #ifdef DEBUG g_assert_not_reached ( ) ; #endif
else if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE ) { <START_VULN> if ( ! ( png_ptr -> mode & PNG_HAVE_PLTE ) ) <END_VULN> { png_crc_finish ( png_ptr , length ) ;
start_frame = distance + frames_to_blur_forward ; <START_VULN> vpx_memset ( cpi -> frames , 0 , max_frames * sizeof ( YV12_BUFFER_CONFIG * ) ) ; <END_VULN> for ( frame = 0 ; frame < frames_to_blur ; frame ++ ) { int which_buffer = start_frame - frame ;
golden_ref , cpi -> Source ) ; } <START_VULN> vp9_clear_system_state ( ) ; <END_VULN> separate_arf_mbs ( cpi ) ; }
} #endif <START_VULN> if ( ! ( png_ptr -> mode & PNG_HAVE_IDAT ) ) <END_VULN> png_error ( png_ptr , "Invalid attempt to read row data" ) ;
for ( size_t i = 0 ; i < numBlocks_ ; i ++ ) blocks_ [ i ] . destroy ( ) ; js_free ( blocks_ ) ; js_delete ( previous_ ) ; } bool init ( size_t numBlocks ) { numBlocks_ = numBlocks ; <START_VULN> blocks_ = ( IonBlockCounts * ) js_calloc ( numBlocks * sizeof ( IonBlockCounts ) ) ; <END_VULN> return blocks_ != NULL ; } size_t numBlocks ( ) const { return numBlocks_ ; } IonBlockCounts & block ( size_t i ) {
if ( ! is_irq_none ( vdev ) ) return - EINVAL ; <START_VULN> vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <END_VULN> if ( ! vdev -> ctx ) return - ENOMEM ; commit 05692d7005a364add85c6e25a6c4447ce08f913a Author : Vlad Tsyrklevich < vlad@tsyrklevich . net> Date : Wed Oct 12 18 : 51 : 24 2016 + 0200 vfiopci : Fix integer overflows , bitmask check The VFIO_DEVICE_SET_IRQS ioctl did not sufficiently sanitize user - supplied integers , potentially allowing memory corruption . This patch adds appropriate integer overflow checks , checks the range bounds for VFIO_IRQ_SET_DATA_NONE , and also verifies that only single element in the VFIO_IRQ_SET_DATA_TYPE_MASK bitmask is set . VFIO_IRQ_SET_ACTION_TYPE_MASK is already correctly checked later in vfio_pci_set_irqs_ioctl ( ) . Furthermore , a kzalloc is changed to a kcalloc because the use of a kzalloc with an integer multiplication allowed an integer overflow condition to be reached without this patch . kcalloc checks for overflow and should prevent a similar occurrence . Signed - off - by : Vlad Tsyrklevich < vlad@tsyrklevich . net> Signed - off - by : Alex Williamson < alex . williamson@redhat . com>
} SKIP_BLANKS ; SHRINK ; <START_VULN> while ( RAW != ' ) ' ) { <END_VULN>
parent_inode , & key , BTRFS_FT_DIR , index ) ; <START_VULN> BUG_ON ( ret == - EEXIST ) ; <END_VULN> if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; commit 9c52057c698fb96f8f07e7a4bcf4801a092bda89 Author : Chris Mason < chris . mason@fusionio . com> Date : Mon Dec 17 14 : 26 : 57 2012 - 0500 Btrfs : fix hash overflow handling The handling for directory crc hash overflows was fairly obscure , split_leaf returns EOVERFLOW when we try to extend the item and that is supposed to bubble up to userland . For a while it did so , but along the way we added better handling of errors and forced the FS readonly if we hit IO errors during the directory insertion . Along the way , we started testing only for EEXIST and the EOVERFLOW case was dropped . The end result is that we may force the FS readonly if we catch a directory hash bucket overflow . This fixes a few problem spots . First I add tests for EOVERFLOW in the places where we can safely just return the error up the chain . btrfs_rename is harder though , because it tries to insert the new directory item only after it has already unlinked anything the rename was going to overwrite . Rather than adding very complex logic , I added a helper to test for the hash overflow case early while it is still safe to bail out . Snapshot and subvolume creation had a similar problem , so they are using the new helper now too . Signed - off - by : Chris Mason < chris . mason@fusionio . com> Reported - by : Pascal Junod < pascal@junod . info>
#define PACKAGE_URL "" <START_VULN> #define PACKAGE_VERSION "2 . 13 . 0"<END_VULN>
{ if ( Op ) { <START_VULN> if ( WalkState -> AscendingCallback != NULL ) <END_VULN> { WalkState -> Op = Op ; WalkState -> OpInfo = AcpiPsGetOpcodeInfo ( Op -> Common . AmlOpcode ) ;
<START_VULN> { <END_VULN> long bp = _ve_envelope_search ( v ) ; if ( bp == - 1 ) { if ( v -> eofflag == 0 ) return ( 0 ) ; v -> nW = 0 ; } else {
vb -> pcm = _vorbis_block_alloc ( vb , sizeof ( * vb -> pcm ) * vi -> channels ) ; for ( i = 0 ; i < vi -> channels ; i ++ ) vb -> pcm [ i ] = _vorbis_block_alloc ( vb , vb -> pcmend * sizeof ( * vb -> pcm [ i ] ) ) ; type = ci -> map_type [ ci -> mode_param [ mode ] -> mapping ] ; return ( _mapping_P [ type ] -> inverse ( vb , ci -> map_param [ ci -> mode_param [ mode ] -> <START_VULN> mapping ] ) ) ; <END_VULN> } int vorbis_synthesis_trackonly ( vorbis_block * vb , ogg_packet * op ) { vorbis_dsp_state * vd = vb -> vd ; private_state * b = vd -> backend_state ; vorbis_info * vi = vd -> vi ;
} } else if ( ! strncmp ( argv [ i ] , " - protos" , 7 ) ) { nflags ++ ; <START_VULN> ret = sscanf ( argv [ i ] + 1 , "protos = % s" , buf ) ; <END_VULN> if ( ret != 1 ) { fprintf ( stderr , "parse failure for protos" ) ; return 1 ;
static int CVE_2013_4516_mp_get_count ( struct sb_uart_state * state , struct serial_icounter_struct * icnt ) { <START_VULN> struct serial_icounter_struct icount ; <END_VULN> struct sb_uart_icount cnow ; struct sb_uart_port * port = state -> port ; spin_lock_irq ( & port -> lock ) ; memcpy ( & cnow , & port -> icount , sizeof ( struct sb_uart_icount ) ) ; spin_unlock_irq ( & port -> lock ) ; icount . cts = cnow . cts ; icount . dsr = cnow . dsr ; icount . rng = cnow . rng ;
#include "third_partyblinkrendererplatformgeometryfloat_rect . h" #include "third_partyblinkrendererplatformgraphicspaintdisplay_item . h" #include "third_partyblinkrendererplatformgraphicspainthit_test_data . h" #include "third_partyblinkrendererplatformgraphicspaintraster_invalidation_tracking . h" <START_VULN> #include "third_partyblinkrendererplatformgraphicspaintref_counted_property_tree_state . h"<END_VULN> #include "third_partyblinkrendererplatformplatform_export . h" #include "third_partyblinkrendererplatformwtfallocator . h" #include "third_partyblinkrendererplatformwtfforward . h"
static int CVE_2006_2935_dvd_read_bca ( struct cdrom_device_info * cdi , dvd_struct * s ) { int ret ; u_char buf [ 4 + 188 ] ; struct packet_command cgc ; struct cdrom_device_ops * cdo = cdi -> ops ; init_cdrom_command ( & cgc , buf , sizeof ( buf ) , CGC_DATA_READ ) ; cgc . cmd [ 0 ] = GPCMD_READ_DVD_STRUCTURE ; cgc . cmd [ 7 ] = s -> type ; <START_VULN> cgc . cmd [ 9 ] = cgc . buflen = 0xff ; <END_VULN> if ( ( ret = cdo -> generic_packet ( cdi , & cgc ) ) ) return ret ; s -> bca . len = buf [ 0 ] << 8 | buf [ 1 ] ; if ( s -> bca . len < 12 | | s -> bca . len > 188 ) { cdinfo ( CD_WARNING , "Received invalid BCA length ( % d ) " , s -> bca . len ) ; return - EIO ; } memcpy ( s -> bca . value , & buf [ 4 ] , s -> bca . len ) ;
static int image_transform_png_set_palette_to_rgb_add ( image_transform * this , <START_VULN> PNG_CONST image_transform ** that , png_byte colour_type , png_byte bit_depth ) <END_VULN> { UNUSED ( bit_depth )
yych = * ++ YYCURSOR ; if ( yych != ' ; ' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 584 "extstandardvar_unserializer . re"<END_VULN> { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ;
<START_VULN> class Pickle { <END_VULN> public : Pickle ( ) ;
rec_hdr . hdr . ts_sec = ( guint32 ) phdr -> ts . secs ; if ( wdh -> tsprecision == WTAP_FILE_TSPREC_NSEC ) { rec_hdr . hdr . ts_usec = phdr -> ts . nsecs ; } else { rec_hdr . hdr . ts_usec = phdr -> ts . nsecs 1000 ; } rec_hdr . hdr . incl_len = phdr -> caplen + phdrsize ; rec_hdr . hdr . orig_len = phdr -> len + phdrsize ; <START_VULN> if ( rec_hdr . hdr . incl_len > WTAP_MAX_PACKET_SIZE | | rec_hdr . hdr . orig_len > WTAP_MAX_PACKET_SIZE ) { <END_VULN> * err = WTAP_ERR_BAD_FILE ; return FALSE ; } switch ( wdh -> file_type ) { case WTAP_FILE_PCAP : case WTAP_FILE_PCAP_NSEC : hdr_size = sizeof ( struct pcaprec_hdr ) ; break ;
we're * not * floor1 . This won't happen unless someone has broken the encode setup lib . Guard it anyway . * if ( ci -> floor_type [ info -> floorsubmap [ submap ] ] != 1 ) return ( - 1 ) ; floor_posts [ i ] [ PACKETBLOBS2 ] = floor1_fit ( vb , b -> flr [ info -> floorsubmap [ submap ] ] , logmdct , logmask ) ; <START_VULN> <END_VULN> if ( vorbis_bitrate_managed ( vb ) && floor_posts [ i ] [ PACKETBLOBS2 ] ) { _vp_offset_and_mix ( psy_look , noise , tone ,
PHP_FUNCTION ( mcrypt_module_get_algo_block_size ) { MCRYPT_GET_MODE_DIR_ARGS ( algorithms_dir ) <START_VULN> <END_VULN> RETURN_LONG ( mcrypt_module_get_algo_block_size ( module , dir ) ) ; }
vp9_iht4x4_16_add ( input , dest , stride , tx_type ) ; } <START_VULN> void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <END_VULN> int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct8x8_add ( input , dest , stride , eob ) ;
* int mar_read_product_info_block ( MarFile * mar , struct ProductInformationBlock * infoBlock ) { <START_VULN> int i , hasAdditionalBlocks , offset , <END_VULN> offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; char buf [ 97 ] = { '0' } ; int ret = get_mar_file_info_fp ( mar -> fp , NULL , NULL , & hasAdditionalBlocks , & offsetAdditionalBlocks ,
#ifndef ColorInputType_h #define ColorInputType_h <START_VULN> #include "corehtmlformsBaseClickableWithKeyInputType . h"<END_VULN> #include "corehtmlformsColorChooserClient . h" #include "corehtmlformsInputType . h" namespace blink {
{ struct nfs4_opendata * opendata ; <START_VULN> opendata = nfs4_opendata_alloc ( & ctx -> path , state -> owner , 0 , NULL ) ; <END_VULN> if ( opendata == NULL ) return ERR_PTR ( - ENOMEM ) ; opendata -> state = state ;
if ( img ) img += num_enc - 1 ; for ( i = num_enc - 1 ; i > = 0 ; i -- ) { <START_VULN> if ( ( res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <END_VULN> duration , flags , deadline ) ) ) break ;
sixel_palet [ n ] = SIXEL_RGB ( 255 , 255 , 255 ) ; } <START_VULN> ( void ) ResetMagickMemory ( imbuf , background_color_index , imsx * imsy ) ; <END_VULN> while ( * p != '0' ) { if ( ( p [ 0 ] == '033' && p [ 1 ] == 'P' ) | | * p == 0x90 ) {
case FILE_BEQWDATE : case FILE_LEQWDATE : if ( file_printf ( ms , F ( ms , m , " % s" ) , <START_VULN> file_fmttime ( p -> q , FILE_T_WINDOWS , tbuf ) ) == - 1 ) <END_VULN> return - 1 ; t = ms -> offset + sizeof ( uint64_t ) ; break ;
( void ) SetImageType ( huffman_image , BilevelType ) ; write_info = CloneImageInfo ( ( ImageInfo * ) NULL ) ; SetImageInfoFile ( write_info , file ) ; <START_VULN> ( void ) SetImageType ( image , BilevelType ) ; <END_VULN> ( void ) SetImageDepth ( image , 1 ) ; write_info -> compression = Group4Compression ; write_info -> type = BilevelType ; ( void ) SetImageOption ( write_info , "quantum : polarity" , "min - is - white" ) ;
{ char sig_recv = 0 ; <START_VULN> recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <END_VULN> } }
const net : : IPEndPoint & remote_address ) ; void OnAcceptIncomingTcpConnection ( const IPC : : Message & msg , int listen_socket_id , <START_VULN> net : : IPEndPoint remote_address , <END_VULN> int connected_socket_id ) ; void OnSend ( const IPC : : Message & msg , int socket_id , const net : : IPEndPoint & socket_address ,
if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "rs" , & mcryptind , & data , & data_len ) == FAILURE ) { return ; } <START_VULN> <END_VULN> ZEND_FETCH_RESOURCE ( pm , php_mcrypt * , & mcryptind , - 1 , "MCrypt" , le_mcrypt ) ; PHP_MCRYPT_INIT_CHECK
ND_PRINT ( ( ndo , " status = % u" , mh -> ip6m_data8 [ 0 ] ) ) ; hlen = IP6M_MINLEN ; <START_VULN> ND_TCHECK2 ( * mh , hlen + 16 ) ; <END_VULN> ND_PRINT ( ( ndo , " homeaddr % s" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; hlen += 16 ; break ;
while ( len != 0 ) { unsigned int amode , tlen = 3 ; <START_VULN> if ( len < 5 && p [ 0 ] != 0x80 && p [ 1 ] != 0x01 ) { <END_VULN> sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , "invalid access mode encoding" ) ; return SC_ERROR_INTERNAL ; }
temp_in [ i * 4 + j ] = out [ j * 4 + i ] ; } } <START_VULN> vp9_idct4_columns_add_blk_dspr2 ( & temp_in [ 0 ] , dest , dest_stride ) ; <END_VULN> break ; case ADST_ADST : for ( i = 0 ; i < 4 ; ++ i ) {
{ struct crypto_report_rng rrng ; <START_VULN> snprintf ( rrng . type , CRYPTO_MAX_ALG_NAME , " % s" , "rng" ) ; <END_VULN> rrng . seedsize = alg -> cra_rng . seedsize ;
} for ( j = first ; j < last ; j ++ ) { int ret = 0 ; ve -> stretch ++ ; if ( ve -> stretch>VE_MAXSTRETCH * 2 ) ve -> stretch = VE_MAXSTRETCH * 2 ; <START_VULN> <END_VULN> for ( i = 0 ; i < ve -> ch ; i ++ ) { float * pcm = v -> pcm [ i ] + ve -> searchstep * ( j ) ; ret |= _ve_amp ( ve , gi , pcm , ve -> band , ve -> filter + i * VE_BANDS ) ; } ve -> mark [ j + VE_POST ] = 0 ; if ( ret & 1 ) { ve -> mark [ j ] = 1 ;
static inline Quantum GetPixelChannel ( const Image * magick_restrict image , const PixelChannel channel , const Quantum * magick_restrict pixel ) { <START_VULN> if ( image -> channel_map [ image -> channel_map [ channel ] . offset ] . traits == UndefinedPixelTrait ) <END_VULN> return ( ( Quantum ) 0 ) ; return ( pixel [ image -> channel_map [ channel ] . offset ] ) ; }
#define LIBRAW_MAJOR_VERSION 0 #define LIBRAW_MINOR_VERSION 18 <START_VULN> #define LIBRAW_PATCH_VERSION 7<END_VULN> #define LIBRAW_VERSION_TAIL Release #define LIBRAW_SHLIB_CURRENT 16
bool mFullScreen ; void * mJavaView ; #endif nsPluginNativeWindow * mPluginWindow ; nsRefPtr < nsNPAPIPluginInstance> mInstance ; nsObjectFrame * mObjectFrame ; <START_VULN> nsIContent * mContent ; <END_VULN> nsCString mDocumentBase ; bool mWidgetCreationComplete ; nsCOMPtr < nsIWidget> mWidget ; nsRefPtr < nsPluginHost> mPluginHost ; #ifdef XP_MACOSX NP_CGContext mCGPluginPortCopy ; int32_t mInCGPaintLevel ;
{ png_debug ( 1 , "in png_set_palette_to_rgb" ) ; <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <END_VULN> return ; png_ptr -> transformations |= ( PNG_EXPAND | PNG_EXPAND_tRNS ) ;
return_value -> value . obj = spl_filesystem_object_new_ex ( ce , & intern TSRMLS_CC ) ; Z_TYPE_P ( return_value ) = IS_OBJECT ; <START_VULN> <END_VULN> spl_filesystem_object_get_file_name ( source TSRMLS_CC ) ; if ( ce -> constructor -> common . scope != spl_ce_SplFileObject ) {
buffer [ uncompressed_length + prefix_length ] = 0 ; <START_VULN> if ( compressed ) <END_VULN> text . compression = PNG_ITXT_COMPRESSION_NONE ; else
return ( inflateReset ( & png_ptr -> zstream ) ) ; } <START_VULN> #endif <END_VULN> png_uint_32 PNGAPI
int lines ; int compressed_lines ; signed short line_packets ; int y_ptr ; int byte_run ; int pixel_skip ; int pixel_countdown ; unsigned char * pixels ; int pixel ; <START_VULN> int pixel_limit ; <END_VULN> s -> frame . reference = 1 ; s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ; if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "reget_buffer ( ) failed" ) ; return - 1 ; } pixels = s -> frame . data [ 0 ] ; pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] ;
else if ( warn < 2 ) { <START_VULN> if ( warn ) <END_VULN> png_chunk_warning ( png_ptr , "insufficient memory to read chunk" ) ; else
bool isVisible ( ) const { return m_isVisible ; } <START_VULN> bool hasSource ( ) const { return m_source != AutoplaySource : : NumberOfSources ; } <END_VULN> DECLARE_VIRTUAL_TRACE ( ) ;
return ret ; free_and_end : <START_VULN> if ( avctx -> codec && <END_VULN> ( codec_init_ok | | ( avctx -> codec -> caps_internal & FF_CODEC_CAP_INIT_CLEANUP ) ) ) avctx -> codec -> close ( avctx ) ;
bool mListenerEnabled ; bool mReturnInEmptyLIKillsList ; bool mDidDeleteSelection ; bool mDidRangedDelete ; bool mRestoreContentEditableCount ; nsCOMPtr < nsIDOMRange> mUtilRange ; PRUint32 mJoinOffset ; nsCOMPtr < nsIDOMNode> mNewBlock ; <START_VULN> nsRangeStore mRangeItem ; <END_VULN> StyleCache mCachedStyles [ SIZE_STYLE_TABLE ] ; } ; #endif
break ; case 6 : <START_VULN> if ( ! ( png_ptr -> row_number & 0x01 ) ) <END_VULN> { png_write_finish_row ( png_ptr ) ; return ;
} } else { if ( state -> space ) ruby_xfree ( state -> space ) ; <START_VULN> state -> space = strdup ( RSTRING_PTR ( space ) ) ; <END_VULN> state -> space_len = len ; } return Qnil ;
{ struct chunk * chunk = zlib -> chunk ; int rc ; <START_VULN> <END_VULN> assert ( zlib -> rewrite_offset < chunk -> chunk_length ) ; rc = zlib_advance ( zlib , chunk -> chunk_length - zlib -> rewrite_offset ) ;
png_crc_read ( png_ptr , buffer , length ) ; buffer [ length ] = 0 ; <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <END_VULN> return ;
js : : InitialShapeSet initialShapes ; void sweepInitialShapeTable ( ) ; js : : types : : TypeObjectSet newTypeObjects ; js : : types : : TypeObjectSet lazyTypeObjects ; void sweepNewTypeObjectTable ( js : : types : : TypeObjectSet & table ) ; <START_VULN> js : : types : : TypeObject * emptyTypeObject ; <END_VULN> inline js : : types : : TypeObject * getEmptyType ( JSContext * cx ) ; js : : types : : TypeObject * getLazyType ( JSContext * cx , JSObject * proto ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis codec headers <START_VULN> last mod : $ Id : codec_internal . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_CODECI_H_ #define _V_CODECI_H_ #include "envelope . h" #include "codebook . h"
for ( r = 0 ; r < 16 ; r ++ ) { <START_VULN> vpx_memset ( ypred_ptr , yleft_col [ r ] , 16 ) ; <END_VULN> ypred_ptr += y_stride ; }
bc + candidates [ s ] [ next_chkpts_indices [ i ] ] . col } ; thissad = vfp -> sdf ( what -> buf , what -> stride , get_buf_from_mv ( in_what , & this_mv ) , <START_VULN> in_what -> stride , bestsad ) ; <END_VULN> CHECK_BETTER } } else {
PNG_EXPORT ( 129 , png_int_32 , png_get_y_offset_microns , ( png_const_structrp png_ptr , png_const_inforp info_ptr ) ) ; <START_VULN> #endif<END_VULN> #ifdef PNG_READ_SUPPORTED
} static ogg_uint32_t decpack ( long entry , long used_entry , long quantvals , <START_VULN> codebook * b , oggpack_buffer * opb , int maptype ) { <END_VULN> ogg_uint32_t ret = 0 ; int j ;
RETURN_FALSE ; } <START_VULN> buffer = zend_string_alloc ( len , 0 ) ; <END_VULN> n = zip_fread ( zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ; if ( n < 1 ) { zend_string_free ( buffer ) ;
<START_VULN> Result AskUserForSettings ( gfx : : NativeWindow window , int max_pages , <END_VULN> bool has_selection ) ;
const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <START_VULN> ND_TCHECK ( * ext ) ; <END_VULN> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ;
if ( SyncAuthenticPixels ( image , & image -> exception ) == MagickFalse ) break ; } <START_VULN> if ( ! image -> ping ) <END_VULN> SyncImage ( image ) ; } else { #if DEBUG
if ( unlikely ( error_code & PF_RSVD ) ) pgtable_bad ( regs , error_code , address ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <END_VULN>
memcpy ( png_ptr -> prev_row , png_ptr -> row_buf , row_info . rowbytes + 1 ) ; #ifdef PNG_READ_TRANSFORMS_SUPPORTED <START_VULN> if ( png_ptr -> transformations ) <END_VULN> png_do_read_transformations ( png_ptr , & row_info ) ; #endif
assert ( socket != NULL ) ; int size = 0 ; <START_VULN> if ( ioctl ( socket -> fd , FIONREAD , & size ) == - 1 ) <END_VULN> return - 1 ; return size ; }
virtual void Print ( gfx : : NativeDrawingContext context ) ; virtual NPObject * GetPluginScriptableObject ( ) ; virtual void DidFinishLoadWithReason ( const GURL & url , NPReason reason , <START_VULN> intptr_t notify_data ) ; <END_VULN> virtual void SetFocus ( ) ; virtual bool HandleInputEvent ( const WebKit : : WebInputEvent & event , WebKit : : WebCursorInfo * cursor ) ;
return FALSE ; } <START_VULN> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <END_VULN> UINT32 scanline ) { UINT16 x ;
} #endif void RunScript ( nsIContent * aScriptElement ) ; void Reset ( ) ; inline void HoldElement ( nsIContent * aContent ) { <START_VULN> mOwnedElements . AppendObject ( aContent ) ; <END_VULN> } void DropHeldElements ( ) ;
static uint32_t sanityCheck ( const uint8_t * woffData , uint32_t woffLen ) { const woffHeader * header ; uint16_t numTables , i ; const woffDirEntry * dirEntry ; <START_VULN> uint32_t tableTotal = 0 ; <END_VULN> if ( ! woffData | | ! woffLen ) { return eWOFF_bad_parameter ; } if ( woffLen < sizeof ( woffHeader ) ) { return eWOFF_invalid ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : PCM data envelope analysis <START_VULN> last mod : $ Id : envelope . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h> #include < string . h> #include < stdio . h> #include < math . h> #include < oggogg . h>
} ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) { <START_VULN> for ( i = 0 ; i < sec -> size ; i += 4 ) { <END_VULN> ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ;
{ png_debug ( 1 , "in png_set_scale_16" ) ; <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <END_VULN> return ; png_ptr -> transformations |= PNG_SCALE_16_TO_8 ;
SkASSERT ( fPtr != fStorage ) ; fPtr = fStorage ; } else { <START_VULN> fPtr = sk_malloc_flags ( size , SK_MALLOC_THROW | SK_MALLOC_TEMP ) ; <END_VULN> } fSize = size ;
c = * cp ; if ( c == '' | | c == '0' ) { * cp = '0' ; <START_VULN> key = stok ( term , " = " , & value ) ; <END_VULN> if ( smatch ( key , "emailAddress" ) ) { key = "EMAIL" ; }
end : if ( TRUE == local_tx_started ) { <START_VULN> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <END_VULN> } DBG_INF ( ret == PASS ? "PASS" : "FAIL" ) ; DBG_RETURN ( ret ) ;
#endif <START_VULN> if ( transforms & PNG_TRANSFORM_SWAP_ALPHA ) <END_VULN> #ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED png_set_swap_alpha ( png_ptr ) ; #else
#define VP9_ENCODER_VP9_MCOMP_H_ #include "vp9encodervp9_block . h" <START_VULN> #include "vp9encodervp9_variance . h"<END_VULN> #ifdef __cplusplus extern "C" {
extern const char kProtectorHistogramStartupSettingsChanged [ ] ; <START_VULN> <END_VULN> extern const char kProtectorHistogramStartupSettingsDiscarded [ ] ; extern const char kProtectorHistogramStartupSettingsTimeout [ ] ;
char sig_recv = 0 ; BTIF_TRACE_DEBUG ( "btif_hl_select_wake_reset" ) ; <START_VULN> recv ( signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <END_VULN> return ( int ) sig_recv ; }
struct { struct vm_area_struct * mmap ; struct rb_root mm_rb ; <START_VULN> u32 vmacache_seqnum ; <END_VULN> #ifdef CONFIG_MMU unsigned long ( * get_unmapped_area ) ( struct file * filp , unsigned long addr , unsigned long len ,
class TranslateInfoBarBase : public TranslateInfoBarView , <START_VULN> public InfoBar { <END_VULN> public : explicit TranslateInfoBarBase ( TranslateInfoBarDelegate * delegate ) ; virtual ~ TranslateInfoBarBase ( ) ;
help prevent buffer overflows and other potential security traps . @defgroup WebsRuntime WebsRuntime @see fmt wallocHandle wallocObject wfreeHandle hextoi itosbuf scaselesscmp scaselessmatch <START_VULN> sclone scmp scopy sfmt sfmtv slen slower smatch sncaselesscmp sncmp sncopy stok strim supper<END_VULN> @stability Stable
rate_uv = 0 ; this_skip2 = 1 ; } <START_VULN> } else if ( mb_skip_allowed ) { <END_VULN> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; }
if ( ( pce = pcre_get_compiled_regex_cache ( regex , regex_len TSRMLS_CC ) ) == NULL ) { RETURN_FALSE ; } <START_VULN> php_pcre_match_impl ( pce , subject , subject_len , return_value , subpats , <END_VULN> global , ZEND_NUM_ARGS ( ) > = 4 , flags , start_offset TSRMLS_CC ) ; }
based temporary image . * pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; if ( ! pim ) { <START_VULN> return ; <END_VULN> } tim = pim ; }
<START_VULN> class NonThreadSafeImpl { <END_VULN> public : ~ NonThreadSafeImpl ( ) ;
void set_ignore_wm_events ( bool ignore ) { ignore_wm_events_ = ignore ; } <START_VULN> void LeaveTabletMode ( wm : : WindowState * window_state ) ; <END_VULN> void OnWMEvent ( wm : : WindowState * window_state ,
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ) ; num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ) ; if ( num_ref_idx_active_override_flag ) { h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1 ; if ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1 ; else <START_VULN> max [ 1 ] = 31 ; <END_VULN> } if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] | | h -> ref_count [ 1 ] - 1 > max [ 1 ] ) { av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow % u > % u or % u > % u" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ) ; h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1 ; return AVERROR_INVALIDDATA ; } if ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) h -> list_count = 2 ;
@param count Count of pad characters to put @returns Zero if successful and otherwise a negative error code @ingroup MprBuf <START_VULN> @stability Evolving<END_VULN> PUBLIC ssize mprPutPadToBuf ( MprBuf * buf , int c , ssize count ) ;
for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 ) <START_VULN> byte = ( size_t ) ( * p ++ ) ; <END_VULN> SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ; bit ++ ; byte >>= 1 ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis backend and mapping structures ; needed for static mode headers <START_VULN> last mod : $ Id : backends . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _vorbis_backend_h_
g_variant_new ( " ( bs ) " , FALSE , reason ) ) ; g_free ( reason ) ; } <START_VULN> tcmur_unregister_handler ( handler ) ; <END_VULN> dbus_unexport_handler ( handler ) ; }
return ( MagickFalse ) ; ( void ) QueryColorCompliance ( "#0000" , AllCompliance , & clip_mask -> background_color , exception ) ; <START_VULN> clip_mask -> background_color . alpha = ( Quantum ) TransparentAlpha ; <END_VULN> ( void ) SetImageBackgroundColor ( clip_mask , exception ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( DrawEvent , GetMagickModule ( ) , "begin clip - path % s" ,
( defined ( PNG_FIXED_POINT_SUPPORTED ) | | defined ( PNG_FLOATING_POINT_SUPPORTED ) ) #if PNG_LIBPNG_VER < 10500 <START_VULN> <END_VULN> typedef png_byte * png_const_bytep ;
uint32_t mNumSampleSizes ; uint32_t mTimeToSampleCount ; <START_VULN> uint32_t * mTimeToSample ; <END_VULN> struct SampleTimeEntry { uint32_t mSampleIndex ;
#define CONTENT_PUBLIC_RENDERER_WINDOW_FEATURES_CONVERTER_H_ #include "contentcommoncontent_export . h" <START_VULN> #include "third_partyblinkpublicmojomwindow_featureswindow_features . mojom . h"<END_VULN> #include "third_partyblinkpublicwebweb_window_features . h" namespace content {
~ Prompt ( ) ; void SetPermissions ( std : : vector < string16> permissions ) ; <START_VULN> void SetInlineInstallWebstoreData ( std : : string localized_user_count , <END_VULN> double average_rating , int rating_count ) ;
<START_VULN> if ( endptr <= buf + 12 ) <END_VULN> { png_chunk_benign_error ( png_ptr , "invalid" ) ; return ;
source = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; <START_VULN> if ( js_regexec ( re -> prog , source , & m , 0 ) ) { <END_VULN> js_copy ( J , 0 ) ; return ; }
&& ( 'w' == 119 ) && ( 'x' == 120 ) && ( 'y' == 121 ) && ( 'z' == 122 ) && ( ' { ' == 123 ) && ( ' | ' == 124 ) && ( ' } ' == 125 ) && ( ' ~ ' == 126 ) ) <START_VULN> #error "gperf generated tables don't work with this execution character set . Please report a bug to < bug - gperf@gnu . org> . "<END_VULN> #endif #line 1 "fcobjshash . gperf"
#ifdef PNG_iCCP_SUPPORTED <START_VULN> if ( ( mask & PNG_FREE_ICCP ) & info_ptr -> free_me ) <END_VULN> { png_free ( png_ptr , info_ptr -> iccp_name ) ; png_free ( png_ptr , info_ptr -> iccp_profile ) ;
using SourcesMapEntry = std : : pair < mojom : : SensorType , scoped_refptr < PlatformSensor >> ; PlatformSensorFusion ( <START_VULN> mojo : : ScopedSharedBufferMapping mapping , <END_VULN> PlatformSensorProvider * provider , std : : unique_ptr < PlatformSensorFusionAlgorithm> fusion_algorithm , SourcesMap sources ) ;
} if ( strncasecmp ( resource -> scheme , "http" , sizeof ( "http" ) ) && strncasecmp ( resource -> scheme , "https" , sizeof ( "https" ) ) ) { <START_VULN> if ( ! context | | <END_VULN> php_stream_context_get_option ( context , wrapper -> wops -> label , "proxy" , & tmpzval ) == FAILURE | | Z_TYPE_PP ( tmpzval ) != IS_STRING | | Z_STRLEN_PP ( tmpzval ) <= 0 ) {
static void Np_toString ( js_State * J ) { <START_VULN> char buf [ 32 ] ; <END_VULN> js_Object * self = js_toobject ( J , 0 ) ; int radix = js_isundefined ( J , 1 ) ? 10 : js_tointeger ( J , 1 ) ; if ( self -> type != JS_CNUMBER )
} ; class nsDocShell final : public nsDocLoader <START_VULN> , public nsIDocShell_ESR38<END_VULN> , public nsIWebNavigation , public nsIBaseWindow , public nsIScrollable , public nsITextScroll , public nsIDocCharset , public nsIContentViewerContainer , public nsIRefreshURI , public nsIWebProgressListener
if ( tga -> bits == TGA_BPP_24 ) { * tpix = gdTrueColor ( tga -> bitmap [ bitmap_caret + 2 ] , tga -> bitmap [ bitmap_caret + 1 ] , tga -> bitmap [ bitmap_caret ] ) ; bitmap_caret += 3 ; <START_VULN> } else if ( tga -> bits == TGA_BPP_32 | | tga -> alphabits ) { <END_VULN> register int a = tga -> bitmap [ bitmap_caret + 3 ] ; * tpix = gdTrueColorAlpha ( tga -> bitmap [ bitmap_caret + 2 ] , tga -> bitmap [ bitmap_caret + 1 ] , tga -> bitmap [ bitmap_caret ] , gdAlphaMax - ( a >> 1 ) ) ;
tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ; <START_VULN> int iskew = imagew - tilew ; <END_VULN> uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ;
VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ; <START_VULN> round = ( vpx_codec_pts_t ) 1000000<END_VULN> delta = ( dst_end_time_stamp - dst_time_stamp ) ; pkt . kind = VPX_CODEC_CX_FRAME_PKT ;
NetInc , h -> content -> length + h -> content -> offset - 1 ) ; <START_VULN> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; <END_VULN> if ( ! msg -> fp ) {
stat = yajl_parse_complete ( hand ) ; if ( stat != yajl_status_ok && <START_VULN> stat != yajl_status_insufficient_data ) <END_VULN> { unsigned char * str = yajl_get_error ( hand , 1 , data , dataSize ) ; fprintf ( stderr , ( const char * ) str ) ;
chunked = 1 ; } } <START_VULN> while ( header_buf [ i ] == 'r' | | header_buf [ i ] == '' ) <END_VULN> i ++ ; linestart = i ; colon = linestart ;
__FUNCTION__ , p_dev -> attr_mask , p_dev -> sub_class , p_dev -> app_id ) ; if ( p_dev -> fd < 0 ) { <START_VULN> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <END_VULN> if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( " % s : Error : failed to open uhid , err : % s" , __FUNCTION__ , strerror ( errno ) ) ;
fname -> disk_name . len = iname -> len ; return 0 ; } <START_VULN> ret = fscrypt_get_crypt_info ( dir ) ; <END_VULN> if ( ret && ret != - EOPNOTSUPP ) return ret ;
if ( compile_options ) { * compile_options = pce ? pce -> compile_options : 0 ; } <START_VULN> <END_VULN> return pce ? pce -> re : NULL ; }
unsigned int count_sat , unsigned int update_factor ) { const FRAME_CONTEXT * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] ; <START_VULN> vp9_coeff_probs_model * const probs = cm -> fc . coef_probs [ tx_size ] ; <END_VULN> const vp9_coeff_probs_model * const pre_probs = pre_fc -> coef_probs [ tx_size ] ; vp9_coeff_count_model * counts = cm -> counts . coef [ tx_size ] ; unsigned int ( * eob_counts ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] =
RD_BOOL ber_in_header ( STREAM s , int * tagval , int * length ) ; void ber_out_header ( STREAM s , int tagval , int length ) ; <START_VULN> RD_BOOL ber_parse_header ( STREAM s , int tagval , int * length ) ; <END_VULN> void ber_out_integer ( STREAM s , int value ) ; void ber_out_sequence ( STREAM s , STREAM contents ) ;
BUG_ON ( regs -> tstate & TSTATE_PRIV ) ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <END_VULN> if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ;
<START_VULN> PHPAPI ulong<END_VULN> mysqlnd_old_escape_string ( char * newstr , const char * escapestr , size_t escapestr_len TSRMLS_DC ) { DBG_ENTER ( "mysqlnd_old_escape_string" ) ;
t &= - t ; <START_VULN> for ( i = 0 ; i < TTABLE_SIZE ; ++ i ) <END_VULN> { if ( ( transform_info [ i ] . transform & t ) != 0 ) return transform_info [ i ] . name ;
impeg2d_bit_stream_flush_to_byte_boundary ( ps_stream ) ; while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <START_VULN> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <END_VULN> { impeg2d_bit_stream_get ( ps_stream , 8 ) ; }
text_info . text = text ; text_info . text_length = strlen ( text ) ; <START_VULN> if ( png_set_text_2 ( png_ptr , info_ptr , & text_info , 1 ) ) <END_VULN> png_warning ( png_ptr , "Insufficient memory to process text chunk" ) ; } #endif
0 . 9994740570F , 0 . 9995575079F , 0 . 9996306699F , 0 . 9996944099F , 0 . 9997495605F , 0 . 9997969190F , 0 . 9998372465F , 0 . 9998712678F , 0 . 9998996704F , 0 . 9999231041F , 0 . 9999421807F , 0 . 9999574732F , 0 . 9999695157F , 0 . 9999788026F , 0 . 9999857885F , 0 . 9999908879F , 0 . 9999944746F , 0 . 9999968817F , 0 . 9999984010F , 0 . 9999992833F , 0 . 9999997377F , 0 . 9999999317F , 0 . 9999999911F , 0 . 9999999999F , } ; <START_VULN> static float vwin1024 [ 512 ] = { <END_VULN> 0 . 0000036962F , 0 . 0000332659F , 0 . 0000924041F , 0 . 0001811086F , 0 . 0002993761F , 0 . 0004472021F , 0 . 0006245811F , 0 . 0008315063F , 0 . 0010679699F , 0 . 0013339631F , 0 . 0016294757F , 0 . 0019544965F , 0 . 0023090133F , 0 . 0026930125F , 0 . 0031064797F , 0 . 0035493989F , 0 . 0040217533F , 0 . 0045235250F , 0 . 0050546946F , 0 . 0056152418F , 0 . 0062051451F , 0 . 0068243817F , 0 . 0074729278F , 0 . 0081507582F , 0 . 0088578466F , 0 . 0095941655F , 0 . 0103596863F , 0 . 0111543789F , 0 . 0119782122F , 0 . 0128311538F , 0 . 0137131701F , 0 . 0146242260F ,
WRITE32 ( NFS4_SHARE_ACCESS_BOTH ) ; break ; default : <START_VULN> BUG ( ) ; <END_VULN> } WRITE32 ( 0 ) ; }
} ; chunk_list = chunks_to_ignore ; <START_VULN> num_chunks = ( sizeof chunks_to_ignore ) 5 ; <END_VULN> } else
int max_pending_send_allowed_ ; <START_VULN> base : : WeakPtr < URLRequestContext> context_ ; <END_VULN> UserDataMap user_data_ ;
for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; <START_VULN> pval *= cpi -> fixed_divide [ count [ k ] ] ; <END_VULN> pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ;
cstate = 0 ; <START_VULN> if ( JAS_CAST ( uint , jas_stream_write ( out , ( char * ) ppm -> data , ppm -> len ) ) != ppm -> len ) { <END_VULN> return - 1 ; } return 0 ;
} while ( power > 0 ) ; <START_VULN> if ( recip ) d = 1d ; <END_VULN> }
{ if ( ms ) { <START_VULN> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <END_VULN> if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ;
} while ( init_l ) ; <START_VULN> qrio_set_gpio ( GPIO_A , FPGA_PROG_L , 1 ) ; <END_VULN> return ret ; }
COPYTHECONTEXT ( "SH : frame_num" , u2_frame_num ) ; <START_VULN> if ( ! ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) ) <END_VULN> { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ;
static size_t store_message ( png_store * ps , png_const_structp pp , char * buffer , size_t bufsize , <START_VULN> size_t pos , PNG_CONST char * msg ) <END_VULN> { if ( pp != NULL && pp == ps -> pread ) {
void PrintPage ( blink : : WebLocalFrame * frame ) override ; blink : : WebSpeechRecognizer * SpeechRecognizer ( ) override ; blink : : WebString AcceptLanguages ( ) override ; <START_VULN> void DidFocus ( ) override ; <END_VULN> bool CanHandleGestureEvent ( ) override ; bool CanUpdateLayout ( ) override ;
} } else { if ( state -> indent ) ruby_xfree ( state -> indent ) ; <START_VULN> state -> indent = strdup ( RSTRING_PTR ( indent ) ) ; <END_VULN> state -> indent_len = len ; } return Qnil ;
buffer [ iout ] = '0' ; } } <START_VULN> #endif<END_VULN> #if defined ( PNG_READ_SUPPORTED ) && defined ( PNG_ERROR_TEXT_SUPPORTED ) PNG_FUNCTION ( void , PNGAPI
char block_dev [ PATH_MAX + 1 ] ; size_t size ; unsigned int blksize ; <START_VULN> unsigned int blocks ; <END_VULN> unsigned int range_count ; unsigned int i ;
} if ( discoverable ) { <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <END_VULN> fprintf ( stdout , "BT adapter is up" ) ; bt_property_t * property = property_new_scan_mode ( BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE ) ;
enum gr_face_options { gr_face_default = 0 , <START_VULN> <END_VULN> gr_face_dumbRendering = 1 , gr_face_preloadGlyphs = 2 ,
gplot -> nplots ++ ; <START_VULN> snprintf ( buf , L_BUF_SIZE , " % s . data . % d" , gplot -> rootname , gplot -> nplots ) ; <END_VULN> sarrayAddString ( gplot -> datanames , buf , L_COPY ) ;
ZVAL_DOUBLE ( rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ; return 1 ; } <START_VULN> #line 1086 "extstandardvar_unserializer . c"<END_VULN> yy65 : yych = * ++ YYCURSOR ; if ( yych <= ' , ' ) {
return ; ptr = buffer ; <START_VULN> if ( png_ptr -> save_buffer_size ) <END_VULN> { png_size_t save_size ;
extern void ipx_print ( netdissect_options * , const u_char * , u_int ) ; extern void isakmp_print ( netdissect_options * , const u_char * , u_int , const u_char * ) ; extern void isakmp_rfc3948_print ( netdissect_options * , const u_char * , u_int , const u_char * ) ; <START_VULN> extern void isoclns_print ( netdissect_options * , const u_char * , u_int , u_int ) ; <END_VULN> extern void krb_print ( netdissect_options * , const u_char * ) ; extern void l2tp_print ( netdissect_options * , const u_char * , u_int ) ; extern void lane_print ( netdissect_options * , const u_char * , u_int , u_int ) ;
#define DATA_SOURCE_H_ #include < systypes . h> <START_VULN> <END_VULN> #include < mediastagefrightMediaErrors . h> #include < utilsErrors . h> #include < utilsKeyedVector . h>
phar_flush ( phar_obj -> arc . archive , stub , stub_len , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
<START_VULN> <END_VULN> #include < stdio . h> #include < r_types . h>
struct TypedArrayObjectStorage : AllTypedArraysBase { protected : JSObject * mObj ; <START_VULN> TypedArrayObjectStorage ( ) <END_VULN> { } TypedArrayObjectStorage ( TypedArrayObjectStorage && aOther ) : mObj ( aOther . mObj ) { aOther . mObj = nullptr ; }
#define CHROME_BROWSER_UI_BLOCKED_CONTENT_POPUP_BLOCKER_H_ #include "baseoptional . h" <START_VULN> #include "third_partyblinkpublicmojomwindow_featureswindow_features . mojom . h"<END_VULN> #include "uibasewindow_open_disposition . h" #include "urlgurl . h"
static bool IsNestedOnCurrentThread ( ) ; <START_VULN> <END_VULN> class BASE_EXPORT NestingObserver {
case '7' : case '8' : case '9' : case ' + ' : case ' - ' : case ' . ' : if ( state -> ptr == tmp ) { <START_VULN> return tmp ; <END_VULN> } case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' :
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : lookup based functions <START_VULN> last mod : $ Id : lookup . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_LOOKUP_H_ #ifdef FLOAT_LOOKUP extern float vorbis_coslook ( float a ) ; extern float vorbis_invsqlook ( float a ) ;
if ( chunk -> data [ 0 ] != 0 && chunk -> data [ 0 ] != 1 ) return ( - 1 ) ; <START_VULN> if ( set_location ( png_ptr , my_user_chunk_data , have_sTER ) ) <END_VULN> { my_user_chunk_data -> sTER_mode = chunk -> data [ 0 ] ; return ( 1 ) ;
uint32_t tmp_val ; uint32_t midi_type ; <START_VULN> uint32_t track_size ; <END_VULN> uint8_t ** tracks ; uint32_t end_of_tracks = 0 ; uint32_t no_tracks ; uint32_t i ;
e = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; if ( e == NULL | | e -> method == SC_AC_NEVER ) return 10 ; <START_VULN> bufsize = file -> size ; <END_VULN> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) {
header -> cmsg_len = CMSG_LEN ( sizeof ( int ) ) ; * ( int * ) CMSG_DATA ( header ) = fd ; <START_VULN> ssize_t ret = sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ; <END_VULN> close ( fd ) ; return ret ; }
# endif #endif <START_VULN> #endif<END_VULN>
<START_VULN> class FileEnumerator { <END_VULN> public : #if defined ( OS_WIN ) typedef WIN32_FIND_DATA FindInfo ;
port = args -> args [ 0 ] ; idx = args -> args [ 1 ] ; <START_VULN> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <END_VULN> struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ; if ( idx != macro -> idx )
if ( card -> type == SC_CARD_TYPE_IASECC_SAGEM ) { <START_VULN> for ( ii = 0 ; ii < rbuf [ 1 ] - offs ; ii ++ ) <END_VULN> * ( card -> serialnr . value + ii ) = ( ( rbuf [ ii + offs + 1 ] & 0x0F ) << 4 ) + ( ( rbuf [ ii + offs + 2 ] & 0xF0 ) >> 4 ) ; card -> serialnr . len = ii ;
uint16_t prev_hdrextlen = hdrextlen ; hdrextlen = sizeof ( IPV6FragHdr ) ; if ( hdrextlen > plen ) { <START_VULN> ENGINE_SET_EVENT ( p , IPV6_TRUNC_EXTHDR ) ; <END_VULN> SCReturn ; }
if ( png_ptr != NULL && info_ptr != NULL && <START_VULN> ( info_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_ENDPOINTS ) ) <END_VULN> { png_debug1 ( 1 , "in % s retrieval function" , "cHRM" ) ;
<START_VULN> void OnAllowBindings ( int enabled_bindings_flags ) ; <END_VULN> void OnAllowScriptToClose ( bool script_can_close ) ; void OnAsyncFileOpened ( base : : PlatformFileError error_code , IPC : : PlatformFileForTransit file_for_transit ,
@param obj Parsed JSON object returned by mprParseJson @return The number of direct dependent child properties @ingroup MprJson <START_VULN> @stability Prototype<END_VULN> PUBLIC ssize mprGetJsonLength ( MprJson * obj ) ;
IntPoint mapPoint ( const IntPoint & p ) const { <START_VULN> return roundedIntPoint ( mapPoint ( p ) ) ; <END_VULN> }
uint32_t length ( ) const { JS_ASSERT ( hasSourceData ( ) ) ; return length_ ; } bool argumentsNotIncluded ( ) const { JS_ASSERT ( hasSourceData ( ) ) ; return argumentsNotIncluded_ ; } <START_VULN> const jschar * chars ( JSContext * cx , const SourceDataCache : : AutoSuppressPurge & asp ) ; <END_VULN> JSFlatString * substring ( JSContext * cx , uint32_t start , uint32_t stop ) ; void addSizeOfIncludingThis ( mozilla : : MallocSizeOf mallocSizeOf , JS : : ScriptSourceInfo * info ) const ; template < XDRMode mode> bool performXDR ( XDRState < mode> * xdr ) ;
( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; fputs ( "" , config -> errors ) ; ptr += cut + 1 ; <START_VULN> len -= cut ; <END_VULN> } else { fputs ( ptr , config -> errors ) ;
<START_VULN> #endif<END_VULN> #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED #ifdef PNG_STDIO_SUPPORTED
for ( i = 0 ; i < PACKETBLOBS ; i ++ ) { if ( i == PACKETBLOBS2 ) { vbi -> packetblob [ i ] = & vb -> opb ; } else { vbi -> packetblob [ i ] = _ogg_calloc ( 1 , sizeof ( oggpack_buffer ) ) ; } oggpack_writeinit ( vbi -> packetblob [ i ] ) ; <START_VULN> } <END_VULN> } return ( 0 ) ; } void * _vorbis_block_alloc ( vorbis_block * vb , long bytes ) { bytes = ( bytes + ( WORD_ALIGN - 1 ) ) & ~ ( WORD_ALIGN - 1 ) ; if ( bytes + vb -> localtop>vb -> localalloc ) {
{ - 1024 , 0 } } , } ; return vp9_pattern_search ( x , ref_mv , search_param , sad_per_bit , <START_VULN> do_init_search , 0 , vfp , use_mvcost , <END_VULN> center_mv , best_mv , hex_num_candidates , hex_candidates ) ; }
case CSN_PADDING_BITS : { if ( remaining_bits_len > 0 ) { proto_item * ti = proto_tree_add_text ( tree , tvb , bit_offset >> 3 , - 1 , "Padding Bits" ) ; proto_tree * padding_tree = proto_item_add_subtree ( ti , ett_csn1 ) ; while ( remaining_bits_len > 0 ) { <START_VULN> guint8 bits_to_handle = remaining_bits_len + ( bit_offset % 8 ) ; <END_VULN> if ( bits_to_handle > 32 ) { bits_to_handle = 32 - ( bit_offset % 8 ) ; } else { bits_to_handle -= ( bit_offset % 8 ) ; } proto_tree_add_text ( padding_tree , tvb , bit_offset >> 3 , ( ( bit_offset + bits_to_handle - 1 ) >> 3 ) - ( bit_offset >> 3 ) + 1 , " % s % s" , decode_bits_in_field ( bit_offset , bits_to_handle , tvb_get_bits ( tvb , bit_offset , bits_to_handle , ENC_BIG_ENDIAN ) ) ,
static inline bool isIteratorTarget ( RenderObject * object ) { ASSERT ( object ) ; <START_VULN> return object -> isText ( ) | | object -> isFloating ( ) | | object -> isPositioned ( ) | | object -> isReplaced ( ) ; <END_VULN> }
{ if ( row_info -> bit_depth == 8 ) { <START_VULN> if ( flags & PNG_FLAG_FILLER_AFTER ) <END_VULN> { png_bytep sp = row + ( png_size_t ) row_width * 3 ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : window functions <START_VULN> last mod : $ Id : window . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_WINDOW_ #define _V_WINDOW_ extern float * _vorbis_window_get ( int n ) ; extern void _vorbis_apply_window ( float * d , int * winno , long * blocksizes ,
base : : Lock audio_thread_lock_ ; <START_VULN> scoped_ptr < AudioDeviceThread> audio_thread_ ; <END_VULN> scoped_ptr < AudioOutputDevice : : AudioThreadCallback> audio_callback_ ; DISALLOW_COPY_AND_ASSIGN ( AudioOutputDevice ) ;
char * suffix = 0 , * fname ; int slen = 0 ; size_t flen ; <START_VULN> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , " | s" , & suffix , & slen ) == FAILURE ) { return ; }
ZVAL_STRINGL ( * rval , str , len , 0 ) ; return 1 ; } <START_VULN> #line 916 "extstandardvar_unserializer . c"<END_VULN> yy46 : yych = * ++ YYCURSOR ; if ( yych == ' + ' ) goto yy47 ;
} static int ceph_x_decrypt ( struct ceph_crypto_key * secret , <START_VULN> void ** p , void * end , void * obuf , size_t olen ) <END_VULN> { struct ceph_x_encrypt_header head ; size_t head_len = sizeof ( head ) ;
fclose ( pathfile ) ; } <START_VULN> ret = mount ( path , destpath , "none" , MS_BIND , NULL ) ; <END_VULN> if ( ret < 0 ) SYSERROR ( "Failed to bind lxc . init . static into container" ) ; INFO ( "lxc . init . static bound into container at % s" , path ) ;
PHP_FUNCTION ( curl_escape ) { char * str = NULL , * res = NULL ; <START_VULN> size_t str_len = 0 ; <END_VULN> zval * zid ; php_curl * ch ;
else if ( y > = b -> image . colormap_entries ) { <START_VULN> if ( ( a -> opts & ACCUMULATE ) == 0 ) <END_VULN> { char pindex [ 9 ] ; sprintf ( pindex , " % lu [ % lu ] " , ( unsigned long ) y ,
jumbo -> ip6j_len = ip6_optlen ; if ( ip6_optlen < sizeof ( jumbo -> ip6j_payload_len ) ) { <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <END_VULN> break ; }
qsort ( f , numf , sizeof ( struct mschmd_file * ) , & sortfunc ) ; for ( i = 0 ; i < numf ; i ++ ) { <START_VULN> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <END_VULN> printf ( "Extracting % s" , outname ) ; ensure_filepath ( outname ) ; if ( chmd -> extract ( chmd , f [ i ] , outname ) ) {
js_AtomizeString ( JSContext * cx , JSString * str , uintN flags ) ; extern JSAtom * <START_VULN> js_Atomize ( JSContext * cx , const char * bytes , size_t length , uintN flags , bool useCESU8 = false ) ; <END_VULN> extern JSAtom * js_AtomizeChars ( JSContext * cx , const jschar * chars , size_t length , uintN flags ) ;
#ifndef UserMediaClientImpl_h #define UserMediaClientImpl_h <START_VULN> #include "coreplatformmediastreamMediaStreamSource . h"<END_VULN> #include "modulesmediastreamUserMediaClient . h" #include "wtfPassRefPtr . h" namespace WebCore {
#define PPAPI_DISPATCH_HOST_RESOURCE_CALL ( msg_class , member_func ) case msg_class : : ID : { <START_VULN> TRACK_RUN_IN_IPC_HANDLER ( member_func ) ; <END_VULN> msg_class : : Schema : : Param p ; if ( msg_class : : Read ( & ipc_message__ , & p ) ) { return ppapi : : host : : DispatchResourceCall (
#define PPAPI_DISPATCH_HOST_RESOURCE_CALL_0 ( msg_class , member_func ) case msg_class : : ID : { <START_VULN> TRACK_RUN_IN_IPC_HANDLER ( member_func ) ; <END_VULN> return member_func ( context ) ; }
1 , - 533200896 , 1611661312 , 4 , 0 , partial_quantlist1 , NULL , NULL , NULL , 0 } ; static float test4_result [ ] = { - 3 , - 3 , - 3 , 4 , - 3 , - 3 , - 1 , - 3 , - 3 , - 3 , 4 , - 3 , 4 , 4 , - 3 , - 1 , 4 , - 3 , <START_VULN> - 3 , - 1 , - 3 , 4 , - 1 , - 3 , - 1 , - 1 , - 3 , <END_VULN> - 3 , - 3 , 4 , 4 , - 3 , 4 , - 1 , - 3 , 4 , - 3 , 4 , 4 , 4 , 4 , 4 , - 1 , 4 , 4 , - 3 , - 1 , 4 , 4 , - 1 , 4 , - 1 , - 1 , 4 , - 3 , - 3 , - 1 , 4 , - 3 , - 1 , - 1 , - 3 , - 1 , - 3 , 4 , - 1 , 4 , 4 , - 1 , - 1 , 4 , - 1 , - 3 , - 1 , - 1 , 4 , - 1 , - 1 , - 1 , - 1 , - 1 } ;
int ras_validate ( jas_stream_t * in ) { <START_VULN> uchar buf [ RAS_MAGICLEN ] ; <END_VULN> int i ; int n ; uint_fast32_t magic ;
efree ( variant ) ; } } <START_VULN> <END_VULN> }
dev -> flags |= IFF_NOARP ; dev -> flags &= ~ IFF_MULTICAST ; <START_VULN> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <END_VULN> random_ether_addr ( dev -> dev_addr ) ; }
} } <START_VULN> static void filter_selectively_vert_row2 ( PLANE_TYPE plane_type , <END_VULN> uint8_t * s , int pitch , unsigned int mask_16x16_l , unsigned int mask_8x8_l ,
return - ENOSYS ; if ( arg != CDSL_CURRENT && arg != CDSL_NONE ) { <START_VULN> if ( ( int ) arg > = cdi -> capacity ) <END_VULN> return - EINVAL ; }
pfd . fd = sfd ; pfd . events = POLLIN ; <START_VULN> if ( poll ( & pfd , 1 , 0 ) == 0 ) <END_VULN> { BTIF_TRACE_EVENT ( "accept poll timeout" ) ; return - 1 ;
#include < stdint . h> #include < utility> <START_VULN> #include "basemove . h"<END_VULN> #include "mojopubliccppsystemmessage_pipe . h" namespace mojo {
<START_VULN> if ( ( png_ptr -> mng_features_permitted & PNG_FLAG_MNG_FILTER_64 ) && <END_VULN> ( png_ptr -> filter_type == PNG_INTRAPIXEL_DIFFERENCING ) ) {
char * saved_ptr = NULL ; intl_error_reset ( NULL TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "s" , & loc_name , & loc_name_len ) == FAILURE ) {
gray = r * data . red_coefficient + g * data . green_coefficient + <START_VULN> b * data . blue_coefficient - 1 . 32768 - out_qe ; <END_VULN> if ( gray <= 0 ) gray = 0 ; else
& cipher , & cipher_len , & module , & module_len ) == FAILURE ) { return ; } <START_VULN> <END_VULN> td = mcrypt_module_open ( cipher , cipher_dir_string , module , module_dir_string ) ; if ( td != MCRYPT_FAILED ) { RETVAL_LONG ( mcrypt_enc_get_iv_size ( td ) ) ;
MprKey * kp ; MprFile * file ; cchar * actionProgram , * ext , * cmdShell , * cp , * start , * path ; <START_VULN> char * tok , buf [ ME_MAX_FNAME + 1 ] ; <END_VULN> rx = conn -> rx ; tx = conn -> tx ;
} uint32_t numInstructions ( ) const { return numInstructions_ ; } void setLocalSlotCount ( uint32_t localSlotCount ) { localSlotCount_ = localSlotCount ; } uint32_t localSlotCount ( ) const { <START_VULN> return localSlotCount_ ; <END_VULN> } void setArgumentSlotCount ( uint32_t argumentSlotCount ) { argumentSlotCount_ = argumentSlotCount ; } uint32_t argumentSlotCount ( ) const { return argumentSlotCount_ ; } uint32_t totalSlotCount ( ) const {
{ xd -> mb_segement_abs_delta = ( unsigned char ) vp8_read_bit ( bc ) ; <START_VULN> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <END_VULN> for ( i = 0 ; i < MB_LVL_MAX ; i ++ )
bool intra_only ; uint8_t reset_context ; <START_VULN> uint8_t refresh_flags ; <END_VULN> uint8_t frame_refs [ kVp9NumRefsPerFrame ] ; bool ref_sign_biases [ kVp9NumRefsPerFrame ] ; bool allow_high_precision_mv ;
return 0 ; } <START_VULN> void ptrace_triggered ( struct perf_event * bp , int nmi , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event_attr attr ;
{ int i , count = 0 ; int * key_sizes ; <START_VULN> <END_VULN> MCRYPT_GET_MODE_DIR_ARGS ( algorithms_dir ) array_init ( return_value ) ;
if ( ! ctx | | ! iter | | ! ctx -> iface | | ! ctx -> priv ) img = NULL ; else <START_VULN> img = ctx -> iface -> dec . get_frame ( ctx -> priv -> alg_priv , iter ) ; <END_VULN> return img ; }
int new_mv_mode_penalty = 256 ; <START_VULN> v_fn_ptr . vf = vp8_mse16x16 ; <END_VULN> xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ;
( * buffer ) [ ( * currlen ) ++ ] = ( char ) c ; } <START_VULN> return ; <END_VULN> }
xmlParserInputBufferPtr ret ; int errcode ; <START_VULN> if ( size <= 0 ) return ( NULL ) ; <END_VULN> if ( mem == NULL ) return ( NULL ) ; ret = xmlAllocParserInputBuffer ( enc ) ;
PHP_NAMED_FUNCTION ( zif_locale_set_default ) { char * locale_name = NULL ; <START_VULN> int len = 0 ; <END_VULN> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "s" , & locale_name , & len ) == FAILURE )
CoreIPC : : Connection * connection ( ) const ; uint64_t destinationID ( ) const { return m_downloadID ; } <START_VULN> void start ( ) ; <END_VULN> void didStart ( ) ; void didReceiveResponse ( const WebCore : : ResourceResponse & ) ;
EXPECT_FALSE ( this -> SetCanonicalCookie ( cs , <START_VULN> base : : MakeUnique < CanonicalCookie> ( <END_VULN> "E" , "F" , http_foo_host , "" , base : : Time ( ) , base : : Time ( ) , base : : Time ( ) , true , false , CookieSameSite : : DEFAULT_MODE , COOKIE_PRIORITY_DEFAULT ) ,
textp -> text = textp -> key + key_len + 1 ; } <START_VULN> if ( text_length ) <END_VULN> memcpy ( textp -> text , text_ptr [ i ] . text , text_length ) ; * ( textp -> text + text_length ) = '0' ;
* <START_VULN> #define LIBXML_MODULE_EXTENSION " . dll"<END_VULN> #endif
<START_VULN> if ( ( routes = mprGetJsonObj ( prop , "routes" ) ) != 0 ) { <END_VULN> parseRoutes ( route , key , routes ) ; } }
int in_opaque ; int is_palette ; int accumulate ; <START_VULN> int output_8bit ; <END_VULN> void ( * in_gp ) ( Pixel * , png_const_voidp ) ; void ( * out_gp ) ( Pixel * , png_const_voidp ) ;
int i ; BEST_SEG_INFO bsi ; <START_VULN> vpx_memset ( & bsi , 0 , sizeof ( bsi ) ) ; <END_VULN> bsi . segment_rd = best_rd ; bsi . ref_mv = best_ref_mv ;
s += 11 ; SKIPWS ( s ) ; ptmp = tmp ; <START_VULN> while ( isdigit ( ( unsigned char ) * s ) ) <END_VULN> * ptmp ++ = * s ++ ; * ptmp = '0' ; if ( mutt_str_atol ( tmp , & h -> content_length ) < 0 ) commit 1b0f0d0988e6df4e32e9f4bf8780846ea95d4485 Author : JerikoOne < jeriko . one@gmx . us> Date : Sat Jul 7 14 : 03 : 46 2018 - 0500 Don't overflow stack buffer in msg_parse_fetch
PRUint32 mPreferredWidth ; PRUint32 mPreferredHeight ; private : PRBool IsVisible ( ) ; void GetToplevelWidget ( GtkWidget ** aWidget ) ; GtkWidget * GetMozContainerWidget ( ) ; <START_VULN> void GetContainerWindow ( nsWindow ** aWindow ) ; <END_VULN> void SetUrgencyHint ( GtkWidget * top_window , PRBool state ) ; void * SetupPluginPort ( void ) ; nsresult SetWindowIconList ( const nsTArray < nsCString> & aIconList ) ; void SetDefaultIcon ( void ) ; void InitButtonEvent ( nsMouseEvent & aEvent , GdkEventButton * aGdkEvent ) ; PRBool DispatchCommandEvent ( nsIAtom * aCommand ) ; GtkWidget * mShell ;
break ; } while ( image_info -> adjoin != MagickFalse ) ; TIFFClose ( tiff ) ; <START_VULN> return ( image -> exception . severity > ErrorException ? MagickFalse : MagickTrue ) ; <END_VULN> } #endif
selaComputeCompositeParameters ( const char * fileout ) { char * str , * nameh1 , * nameh2 , * namev1 , * namev2 ; <START_VULN> char buf [ L_BUF_SIZE ] ; <END_VULN> l_int32 size , size1 , size2 , len ; SARRAY * sa ; SELA * selabasic , * selacomb ;
stateEnum state ( ) { return state_ ; } CSecurity * csecurity ; <START_VULN> SecurityClient * security ; <END_VULN> protected : void setState ( stateEnum s ) { state_ = s ; }
PHP_FUNCTION ( mcrypt_module_is_block_mode ) { MCRYPT_GET_MODE_DIR_ARGS ( modes_dir ) <START_VULN> <END_VULN> if ( mcrypt_module_is_block_mode ( module , dir ) == 1 ) { RETURN_TRUE ; } else {
<START_VULN> if ( transforms & PNG_TRANSFORM_PACKSWAP ) <END_VULN> #ifdef PNG_READ_PACKSWAP_SUPPORTED png_set_packswap ( png_ptr ) ; #else
( jp2_image -> comps [ 0 ] . dy != jp2_image -> comps [ i ] . dy ) | | ( jp2_image -> comps [ 0 ] . prec != jp2_image -> comps [ i ] . prec ) | | ( jp2_image -> comps [ 0 ] . sgnd != jp2_image -> comps [ i ] . sgnd ) | | <START_VULN> ( jp2_image -> comps [ i ] . data == NULL ) ) <END_VULN> { opj_destroy_codec ( jp2_codec ) ; opj_image_destroy ( jp2_image ) ;
<START_VULN> if ( transforms & PNG_TRANSFORM_INVERT_ALPHA ) <END_VULN> #ifdef PNG_READ_INVERT_ALPHA_SUPPORTED png_set_invert_alpha ( png_ptr ) ; #else
for ( size_t i = 0 ; i < test_suite_size ; ++ i ) { if ( ! test_name | | ! strcmp ( test_name , test_suite [ i ] . function_name ) ) { callbacks_init ( ) ; <START_VULN> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <END_VULN> if ( test_suite [ i ] . function ( ) ) { printf ( " [ % 4d ] % - 64s [ % sPASS % s ] " , ++ case_num , test_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ;
int_mv mode_mv [ MB_MODE_COUNT ] [ 2 ] ; int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; <START_VULN> MB_PREDICTION_MODE mode_selected = ZEROMV ; <END_VULN> int64_t best_rd = INT64_MAX ; const int i = idy * 2 + idx ; int ref ;
newinet -> inet_daddr = ireq -> rmt_addr ; newinet -> inet_rcv_saddr = ireq -> loc_addr ; newinet -> inet_saddr = ireq -> loc_addr ; <START_VULN> newinet -> opt = ireq -> opt ; <END_VULN> ireq -> opt = NULL ; newinet -> mc_index = inet_iif ( skb ) ; newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ;
const media : : AudioParameters & params , const std : : string & raw_device_id ) > ; <START_VULN> AudioOutputAuthorizationHandler ( media : : AudioManager * audio_manager , <END_VULN> MediaStreamManager * media_stream_manager , int render_process_id_ , const std : : string & salt ) ;
ND_PRINT ( ( ndo , " [ | osi ] " ) ) ; return ( 1 ) ; } <START_VULN> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <END_VULN> return ( 1 ) ; case ETHERTYPE_PPPOED :
{ struct sockaddr_un client_address ; socklen_t clen ; <START_VULN> int fd = accept ( s , ( struct sockaddr * ) & client_address , & clen ) ; <END_VULN> APPL_TRACE_DEBUG ( "accepted fd : % d for server fd : % d" , fd , s ) ; return fd ; }
#include "vpxvpx_codec . h" <START_VULN> static const char * const cfg = " -- target = x86 - linux - gcc -- disable - sse4_1 -- disable - avx -- disable - avx2 -- as = yasm -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
atPoint : ( CGPoint ) touchLocation atIndexPath : ( nonnull NSIndexPath * ) indexPath ; <START_VULN> - ( void ) dismissContextMenu ; <END_VULN> - ( void ) handlePromoTapped ;
void Wire ( UberDispatcher * dispatcher ) override ; <START_VULN> void SetRenderer ( RenderProcessHost * process_host , <END_VULN> RenderFrameHostImpl * frame_host ) override ; Response Disable ( ) override ;
l_int32 gplotGenCommandFile ( GPLOT * gplot ) { <START_VULN> char buf [ L_BUF_SIZE ] ; <END_VULN> char * cmdstr , * plottitle , * dataname ; l_int32 i , plotstyle , nplots ; FILE * fp ;
break ; case 3 : <START_VULN> if ( ( png_ptr -> row_number & 0x03 ) | | png_ptr -> width < 3 ) <END_VULN> { png_write_finish_row ( png_ptr ) ; return ;
This enables callers to use the OS socket handle for their own purposes . @param sp Socket object returned from #mprCreateSocket @ingroup MprSocket <START_VULN> @stability Prototype<END_VULN> PUBLIC Socket mprStealSocketHandle ( MprSocket * sp ) ;
JSIdArray * ida ; jschar * chars , * ochars , * vsharp ; const jschar * idstrchars , * vchars ; <START_VULN> size_t nchars , idstrlength , gsoplength , vlength , vsharplength ; <END_VULN> char * comma ; jsint i , j , length , valcnt ; jsid id ;
#ifndef _TYPES_INCLUDED #define _TYPES_INCLUDED #include "compilerBaseTypes . h" #include "compilerCommon . h" <START_VULN> #include "compilerdebug . h"<END_VULN> class TType ; struct TTypeLine { TType * type ; int line ; rename from gfxanglesrccompilerdebug . cpp rename to gfxanglesrccompilercompilerdebug . cpp
int64_t d ; int64_t sse ; int segment_yrate ; <START_VULN> MB_PREDICTION_MODE modes [ 4 ] ; <END_VULN> SEG_RDSTAT rdstat [ 4 ] [ INTER_MODES ] ; int mvthresh ; } BEST_SEG_INFO ;
struct windows_device_priv * priv = _device_priv ( dev_handle -> dev ) ; int i ; <START_VULN> if ( ( api_id < USB_API_WINUSBX ) | | ( api_id > USB_API_HID ) ) { <END_VULN> usbi_dbg ( "unsupported API ID" ) ; return - 1 ; }
* sp = ( png_byte ) ( tmp & 0xff ) ; } <START_VULN> if ( ! shift ) <END_VULN> { shift = 7 ; sp ++ ;
size_t extent ; <START_VULN> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <END_VULN> return ( ( void * ) NULL ) ; extent = count * quantum ; return ( AcquireMagickMemory ( extent ) ) ;
#define VP8_ENCODER_MCOMP_H_ #include "block . h" <START_VULN> #include "vp8commonvariance . h"<END_VULN> #ifdef __cplusplus extern "C" {
typedef struct { void ( * pack ) ( vorbis_info_floor * , oggpack_buffer * ) ; vorbis_info_floor * ( * unpack ) ( vorbis_info * , oggpack_buffer * ) ; vorbis_look_floor * ( * look ) ( vorbis_dsp_state * , vorbis_info_floor * ) ; void ( * free_info ) ( vorbis_info_floor * ) ; void ( * free_look ) ( vorbis_look_floor * ) ; void * ( * inverse1 ) ( struct vorbis_block * , vorbis_look_floor * ) ; int ( * inverse2 ) ( struct vorbis_block * , vorbis_look_floor * , <START_VULN> void * buffer , float * ) ; <END_VULN> } vorbis_func_floor ; typedef struct { int order ; long rate ; long barkmap ; int ampbits ;
do { <START_VULN> if ( user_png_ver [ i ] != png_libpng_ver [ i ] ) <END_VULN> { #ifdef PNG_LEGACY_SUPPORTED png_ptr -> flags |= PNG_FLAG_LIBRARY_MISMATCH ;
static inline void perf_event_task_sched_out ( struct task_struct * task , struct task_struct * next ) { <START_VULN> perf_sw_event ( PERF_COUNT_SW_CONTEXT_SWITCHES , 1 , 1 , NULL , 0 ) ; <END_VULN> __perf_event_task_sched_out ( task , next ) ; }
oggpack_write ( opb , 0 , 32 ) ; } } } oggpack_write ( opb , 1 , 1 ) ; return ( 0 ) ; } <START_VULN> <END_VULN> static int _vorbis_pack_books ( oggpack_buffer * opb , vorbis_info * vi ) { codec_setup_info * ci = vi -> codec_setup ; int i ; if ( ! ci ) return ( OV_EFAULT ) ; oggpack_write ( opb , 0x05 , 8 ) ; _v_writestring ( opb , "vorbis" , 6 ) ;
if ( yych <= '9' ) goto yy91 ; if ( yych != ' ; ' ) goto yy18 ; ++ YYCURSOR ; <START_VULN> #line 521 "extstandardvar_unserializer . re"<END_VULN> { long id ;
SPL_METHOD ( FilesystemIterator , key ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { return ; }
struct State { <START_VULN> scoped_refptr < const TransformPaintPropertyNode> local_transform_space ; <END_VULN> FloatRoundedRect clip_rect ; base : : Optional < FloatRoundedRect> clip_rect_excluding_overlay_scrollbars ; scoped_refptr < const RefCountedPath> clip_path ;
header [ 11 ] = ( rec -> length ) >> 8 ; header [ 12 ] = ( rec -> length ) & 0xff ; <START_VULN> if ( ! send && ! SSL_USE_ETM ( ssl ) && <END_VULN> EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && ssl3_cbc_record_digest_supported ( mac_ctx ) ) {
if ( sock -> connected ) { int size = 0 ; <START_VULN> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) | | ( ioctl ( sock -> our_fd , FIONREAD , & size ) <END_VULN> == 0 && size ) ) { uint8_t * buffer = osi_malloc ( L2CAP_MAX_SDU_LENGTH ) ;
int size ; syscall_nr = trace_get_syscall_nr ( current , regs ) ; <START_VULN> if ( syscall_nr < 0 ) <END_VULN> return ;
status_t resetPlugin ( ) ; <START_VULN> void setDecodeArgs ( <END_VULN> ivd_video_decode_ip_t * ps_dec_ip , ivd_video_decode_op_t * ps_dec_op , OMX_BUFFERHEADERTYPE * inHeader ,
event . code = code ; event . value = value ; <START_VULN> return write ( fd , & event , sizeof ( event ) ) ; <END_VULN> } void send_key ( int fd , uint16_t key , int pressed )
y = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { <START_VULN> p = GetVirtualPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <END_VULN> if ( p == ( const PixelPacket * ) NULL ) break ; bit = 0 ;
for ( x = 0 ; x < MAX_UINPUT_PATHS ; x ++ ) { <START_VULN> fd = open ( uinput_dev_path [ x ] , O_RDWR ) ; <END_VULN> if ( fd < 0 ) continue ; break ;
p -> n = n ; p -> rate = rate ; p -> m_val = 1 . ; if ( rate < 26000 ) p -> m_val = 0 ; else if ( rate < 38000 ) p -> m_val = . 94 ; else if ( rate > 46000 ) p -> m_val = 1 . 275 ; <START_VULN> <END_VULN> for ( i = 0 , j = 0 ; i < MAX_ATH - 1 ; i ++ ) { int endpos = rint ( fromOC ( ( i + 1 ) * . 125 - 2 . ) * 2 * nrate ) ; float base = ATH [ i ] ; if ( j < endpos ) { float delta = ( ATH [ i + 1 ] - base ) ( endpos - j ) ; for ( ; j < endpos && j < n ; j ++ ) {
next -> next = NULL ; fprintf ( stderr , "t % lu bytes @ % p" , <START_VULN> ( unsigned long ) next -> size , ( PNG_CONST void * ) ( next + 1 ) ) ; <END_VULN>
void init ( JSContext * cx ) ; ~ TypeCompartment ( ) ; inline JSCompartment * compartment ( ) ; inline void addPending ( JSContext * cx , TypeConstraint * constraint , TypeSet * source , Type type ) ; <START_VULN> void growPendingArray ( JSContext * cx ) ; <END_VULN> inline void resolvePending ( JSContext * cx ) ; void print ( JSContext * cx , bool force ) ;
} s ++ ; ptmp = tmp ; <START_VULN> while ( * s && * s != '"' ) <END_VULN> * ptmp ++ = * s ++ ; if ( * s != '"' ) return - 1 ;
static void down2_symodd ( const uint8_t * const input , int length , uint8_t * output ) { <START_VULN> static const int16_t * filter = vp9_down2_symodd_half_filter ; <END_VULN> const int filter_len_half = sizeof ( vp9_down2_symodd_half_filter ) 2 ; int i , j ; uint8_t * optr = output ;
if ( ! ( * cursor < oldlen ) ) goto no_suitable_2nd ; <START_VULN> next_char = get_next_char ( charset , old , oldlen , cursor , & status ) ; <END_VULN> if ( status == FAILURE ) goto no_suitable_2nd ;
qttag != MAKEID ( 'c' , 'o' , '6' , '4' ) && qttag != MAKEID ( 'h' , 'd' , 'l' , 'r' ) ) { <START_VULN> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <END_VULN> NESTSIZE ( qtsize ) ; }
if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE ) #endif { <START_VULN> png_crc_finish ( png_ptr , 0 ) ; <END_VULN> } #ifndef PNG_READ_OPT_PLTE_SUPPORTED else if ( png_crc_error ( png_ptr ) )
png_ptr -> num_palette_max = - 1 ; } #endif <START_VULN> #endif<END_VULN>
a = text ; e = text + strlen ( text ) ; while ( a <= e ) { <START_VULN> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <END_VULN> break ; b = m . sub [ 0 ] . sp ;
int dst_pitch ) { <START_VULN> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , FData2 , 4 * 9 ) ; <END_VULN> if ( xoffset ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis codec headers <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _vorbis_codec_h_ #define _vorbis_codec_h_ #ifdef __cplusplus extern "C"
private : void layout ( ) override ; void calcViewport ( ) override ; <START_VULN> bool calculateLocalTransform ( ) override ; <END_VULN> AffineTransform viewportTransform ( ) const ;
<START_VULN> #line 1180 "ntp_parser . y"<END_VULN> void yyerror ( char * msg )
} while ( Op ) ; <START_VULN> return_ACPI_STATUS ( Status ) ; <END_VULN> }
memset ( data_s , 0 , data_size ) ; memcpy ( data_s , data , data_len ) ; } <START_VULN> <END_VULN> mcrypt_generic ( pm -> td , data_s , data_size ) ; data_s [ data_size ] = '0' ;
vi -> background_blue = b ; } } <START_VULN> else<END_VULN> vi -> do_background = 0 ; if ( vi -> do_background == 0 )
entity_table_opt retval = { NULL } ; assert ( ! ( doctype == ENT_HTML_DOC_XML1 && all ) ) ; <START_VULN> <END_VULN> if ( all ) { retval . ms_table = ( doctype == ENT_HTML_DOC_HTML5 ) ? entity_ms_table_html5 : entity_ms_table_html4 ;
} SKIP_BLANKS ; GROW ; <START_VULN> while ( RAW != '>' ) { <END_VULN> const xmlChar * check = CUR_PTR ; int type ; int def ;
if ( task_cpu ( p ) != new_cpu ) { p -> se . nr_migrations ++ ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_CPU_MIGRATIONS , 1 , 1 , NULL , 0 ) ; <END_VULN> } __set_task_cpu ( p , new_cpu ) ;
} else { spl_filesystem_info_set_filename ( intern , file_path , file_path_len , use_copy TSRMLS_CC ) ; } <START_VULN> <END_VULN> zend_restore_error_handling ( & error_handling TSRMLS_CC ) ; return intern ; }
int ret , i , rd = ( ( insn >> 25 ) & 0x1f ) ; int from_kernel = ( regs -> tstate & TSTATE_PRIV ) != 0 ; <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <END_VULN> if ( insn & 0x2000 ) { maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; value = sign_extend_imm13 ( insn ) ;
return ( 0 ) ; } <START_VULN> if ( ! num_in ) <END_VULN> break ; if ( memcmp ( inbuf , outbuf , num_in ) )
#undef mem_put_le24 #define mem_put_le24 mem_ops_wrap_symbol ( mem_put_le24 ) <START_VULN> static void mem_put_le24 ( void * vmem , MEM_VALUE_T val ) { <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; mem [ 0 ] = ( val >> 0 ) & 0xff ;
if ( i + 1 < P_BANDS ) { int l = 0 ; k = i + 1 ; for ( j = 0 ; j < EHMER_MAX ; j ++ ) { int lo_bin = fromOC ( j * . 125 + i * . 5 - 2 . 0625 ) binHz ; int hi_bin = fromOC ( j * . 125 + i * . 5 - 1 . 9375 ) binHz + 1 ; <START_VULN> <END_VULN> if ( lo_bin < 0 ) lo_bin = 0 ; if ( lo_bin>n ) lo_bin = n ; if ( lo_bin < l ) l = lo_bin ; if ( hi_bin < 0 ) hi_bin = 0 ; if ( hi_bin>n ) hi_bin = n ; for ( ; l < hi_bin && l < n ; l ++ ) if ( brute_buffer [ l ] >workc [ k ] [ m ] [ j ] )
assert ( comp != 0 ) ; <START_VULN> vp9_write ( w , sign , mvcomp -> sign ) ; <END_VULN> vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes ,
! ( ctx -> iface -> caps & VPX_CODEC_CAP_EXTERNAL_FRAME_BUFFER ) ) { res = VPX_CODEC_ERROR ; } else { <START_VULN> res = ctx -> iface -> dec . set_fb_fn ( ctx -> priv -> alg_priv , cb_get , cb_release , <END_VULN> cb_priv ) ; }
#endif #ifndef M_PI # define M_PI ( 3 . 1415926536f ) #endif #if defined ( _WIN32 ) && ! defined ( __SYMBIAN32__ ) # include < malloc . h> <START_VULN> # define rint ( x ) ( floor ( ( x ) + 0 . 5f ) ) <END_VULN> # define NO_FLOAT_MATH_LIB # define FAST_HYPOT ( a , b ) sqrt ( ( a ) * ( a ) + ( b ) * ( b ) ) #endif #if defined ( __SYMBIAN32__ ) && defined ( __WINS__ ) void * _alloca ( size_t size ) ; # define alloca _alloca #endif
DEBUG ( "A2DP COMMAND % s" , dump_a2dp_ctrl_event ( cmd ) ) ; <START_VULN> if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 ) <END_VULN> { ERROR ( "cmd failed ( % s ) " , strerror ( errno ) ) ; skt_disconnect ( common -> ctrl_fd ) ;
for ( zend_hash_internal_pointer_reset ( hash_arr ) ; zend_hash_has_more_elements ( hash_arr ) == SUCCESS ; zend_hash_move_forward ( hash_arr ) ) { <START_VULN> <END_VULN> if ( zend_hash_get_current_data ( hash_arr , ( void ** ) & ele_value ) == FAILURE ) { continue ;
