#include "psy . h" <NEW_LINE> #include "os . h" <NEW_LINE> #include "lpc . h" <NEW_LINE> #include "smallft . h" <NEW_LINE> #include "scales . h" <NEW_LINE> #include "misc . h" <NEW_LINE> #define NEGINF - 9999 . f <NEW_LINE> <START_VULN> static double stereo_threshholds [ ] = { 0 . 0 , . 5 , 1 . 0 , 1 . 5 , 2 . 5 , 4 . 5 , 8 . 5 , 16 . 5 , 9e10 } ; <NEW_LINE>static double stereo_threshholds_limited [ ] = { 0 . 0 , . 5 , 1 . 0 , 1 . 5 , 2 . 0 , 2 . 5 , 4 . 5 , 8 . 5 , 9e10 } ; <NEW_LINE> <END_VULN> vorbis_look_psy_global * _vp_global_look ( vorbis_info * vi ) { <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> vorbis_info_psy_global * gi = & ci -> psy_g_param ; <NEW_LINE> vorbis_look_psy_global * look = _ogg_calloc ( 1 , sizeof ( * look ) ) ; <NEW_LINE> look -> channels = vi -> channels ;
static int _vds_shared_init ( vorbis_dsp_state * v , vorbis_info * vi , int encp ) { <NEW_LINE> int i ; <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> private_state * b = NULL ; <NEW_LINE> int hs ; <NEW_LINE> if ( ci == NULL ) return 1 ; <NEW_LINE> <START_VULN> hs = ci -> halfrate_flag ; <NEW_LINE> <END_VULN> memset ( v , 0 , sizeof ( * v ) ) ; <NEW_LINE> b = v -> backend_state = _ogg_calloc ( 1 , sizeof ( * b ) ) ; <NEW_LINE> v -> vi = vi ; <NEW_LINE> b -> modebits = ilog2 ( ci -> modes ) ; <NEW_LINE> b -> transform [ 0 ] = _ogg_calloc ( VI_TRANSFORMB , sizeof ( * b -> transform [ 0 ] ) ) ;
<TAB> } <NEW_LINE> <START_VULN> <TAB> if ( buf -> pts == AV_NOPTS_VALUE ) { <NEW_LINE> <END_VULN> <TAB> <TAB> return write_to_fifo ( s -> fifo , buf ) ; <NEW_LINE> <TAB> }
<TAB> JSTokenStream * ts ; <NEW_LINE> <TAB> JSPrincipals * principals ; <NEW_LINE> <TAB> jschar * collected_args , * cp ; <NEW_LINE> <START_VULN> <TAB> size_t arg_length , args_length ; <NEW_LINE> <END_VULN> <TAB> JSTokenType tt ; <NEW_LINE> <TAB> JSBool ok ;
<TAB> <TAB> conn -> m -> local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> DBG_RETURN ( ret ) ; <TAB> <NEW_LINE> <END_VULN> }
<TAB> case KEY_REQKEY_DEFL_PROCESS_KEYRING : <NEW_LINE> <TAB> <TAB> ret = install_process_keyring_to_cred ( new ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( ret < 0 ) { <NEW_LINE><TAB> <TAB> <TAB> if ( ret != - EEXIST ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> goto error ; <NEW_LINE><TAB> <TAB> <TAB> ret = 0 ; <NEW_LINE><TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> <TAB> goto set ; <NEW_LINE> <TAB> case KEY_REQKEY_DEFL_DEFAULT :
} <NEW_LINE> static spnego_gss_ctx_id_t <NEW_LINE> <START_VULN> create_spnego_ctx ( void ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> spnego_gss_ctx_id_t spnego_ctx = NULL ; <NEW_LINE> <TAB> spnego_ctx = ( spnego_gss_ctx_id_t )
int ip6_find_1stfragopt ( struct sk_buff * skb , u8 ** nexthdr ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> u16 offset = sizeof ( struct ipv6hdr ) ; <NEW_LINE> <END_VULN> <TAB> unsigned int packet_len = skb_tail_pointer ( skb ) - <NEW_LINE> <TAB> <TAB> skb_network_header ( skb ) ; <NEW_LINE> <TAB> int found_rhdr = 0 ;
int __init CVE_2008_3527_sysenter_setup ( void ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> syscall_page = ( void * ) get_zeroed_page ( GFP_ATOMIC ) ; <NEW_LINE> <END_VULN> #ifdef CONFIG_COMPAT_VDSO <NEW_LINE> <TAB> __set_fixmap ( FIX_VDSO , __pa ( syscall_page ) , PAGE_READONLY ) ;
<TAB> <TAB> <TAB> <TAB> continue ; <NEW_LINE> <TAB> <TAB> <TAB> case REOP_ASSERTTEST : <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> -- curState ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> x -> cp = gData -> cpbegin + curState -> index ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> gData -> backTrackSP =
<TAB> rcu_assign_pointer ( vq -> private_data , oldsock ) ; <NEW_LINE> <TAB> vhost_net_enable_vq ( n , vq ) ; <NEW_LINE> <TAB> if ( ubufs ) <NEW_LINE> <START_VULN> <TAB> <TAB> vhost_net_ubuf_put_and_wait ( ubufs ) ; <NEW_LINE> <END_VULN> err_ubufs : <NEW_LINE> <TAB> fput ( sock -> file ) ; <NEW_LINE> err_vq :
<TAB> <TAB> return error ; <NEW_LINE> <TAB> if ( type == ACL_TYPE_ACCESS ) { <NEW_LINE> <START_VULN> <TAB> <TAB> umode_t mode = inode -> i_mode ; <NEW_LINE><TAB> <TAB> error = posix_acl_equiv_mode ( acl , & mode ) ; <NEW_LINE><NEW_LINE><TAB> <TAB> if ( error <= 0 ) { <NEW_LINE><TAB> <TAB> <TAB> acl = NULL ; <NEW_LINE><NEW_LINE><TAB> <TAB> <TAB> if ( error < 0 ) <NEW_LINE><TAB> <TAB> <TAB> <TAB> return error ; <NEW_LINE><TAB> <TAB> } <NEW_LINE> <END_VULN> <TAB> <TAB> error = xfs_set_mode ( inode , mode ) ; <NEW_LINE> <TAB> <TAB> if ( error ) <NEW_LINE> <TAB> <TAB> <TAB> return error ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_ALIAS_RTNL_LINK ( "gre" ) ; <NEW_LINE> MODULE_ALIAS_RTNL_LINK ( "gretap" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "gre0" ) ; <NEW_LINE> <END_VULN>
<TAB> if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_OCTAL3 ) ) { <NEW_LINE> <TAB> <TAB> prev = p ; <NEW_LINE> <TAB> <TAB> num = scan_unsigned_octal_number ( & p , end , ( c == '0' ? 2 : 3 ) , enc ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( p == prev ) { <NEW_LINE> <TAB> <TAB> num = 0 ; <NEW_LINE> <TAB> <TAB> }
int xt_register_matches ( struct xt_match * match , unsigned int n ) ; <NEW_LINE> void xt_unregister_matches ( struct xt_match * match , unsigned int n ) ; <NEW_LINE> <START_VULN> int xt_check_entry_offsets ( const void * base , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> unsigned int target_offset , <NEW_LINE> <TAB> <TAB> <TAB> unsigned int next_offset ) ;
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "Triple DES EDE Cipher Algorithm , asm optimized" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "des3_ede" ) ; <NEW_LINE>MODULE_ALIAS ( "des3_ede - asm" ) ; <NEW_LINE>MODULE_ALIAS ( "des" ) ; <NEW_LINE>MODULE_ALIAS ( "des - asm" ) ; <NEW_LINE> <END_VULN> MODULE_AUTHOR ( "Jussi Kivilinna < jussi . kivilinna@iki . fi > " ) ;
<TAB> xen_netbk_tx_submit ( netbk ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> struct xenvif * vif ; <NEW_LINE> <TAB> struct pending_tx_info * pending_tx_info ;
} <NEW_LINE> static int _vorbis_pack_info ( oggpack_buffer * opb , vorbis_info * vi ) { <NEW_LINE> codec_setup_info * ci = vi -> codec_setup ; <NEW_LINE> if ( ! ci ) return ( OV_EFAULT ) ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> oggpack_write ( opb , 0x01 , 8 ) ; <NEW_LINE> _v_writestring ( opb , "vorbis" , 6 ) ; <NEW_LINE> oggpack_write ( opb , 0x00 , 32 ) ; <NEW_LINE> oggpack_write ( opb , vi -> channels , 8 ) ; <NEW_LINE> oggpack_write ( opb , vi -> rate , 32 ) ;
extern int ext2_xattr_set ( struct inode * , int , const char * , const void * , size_t , int ) ; <NEW_LINE> extern void ext2_xattr_delete_inode ( struct inode * ) ; <NEW_LINE> <START_VULN> extern void ext2_xattr_put_super ( struct super_block * ) ; <NEW_LINE>extern int init_ext2_xattr ( void ) ; <NEW_LINE>extern void exit_ext2_xattr ( void ) ; <NEW_LINE> <END_VULN> extern const struct xattr_handler * ext2_xattr_handlers [ ] ;
<TAB> memset ( state , 128 , sizeof ( state ) ) ; <NEW_LINE> <TAB> if ( f -> version < 2 ) { <NEW_LINE> <START_VULN> <TAB> <TAB> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <NEW_LINE> <END_VULN> <TAB> <TAB> unsigned v = get_symbol ( c , state , 0 ) ; <NEW_LINE> <TAB> <TAB> if ( v >= 2 ) { <NEW_LINE> <TAB> <TAB> <TAB> av_log ( f -> avctx , AV_LOG_ERROR , "invalid version % d in ver01 header\n" , v ) ;
{ <NEW_LINE> <TAB> OPJ_UINT32 l_data_size ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE><TAB> l_data_size = 1 + ( OPJ_UINT32 ) ( ( p_code_block -> x1 - p_code_block -> x0 ) * <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ( p_code_block -> y1 - p_code_block -> y0 ) * ( OPJ_INT32 ) sizeof ( OPJ_UINT32 ) ) ; <NEW_LINE> <TAB> if ( l_data_size > p_code_block -> data_size ) {
if ( attr ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> _cupsStrFree ( attr -> values [ 0 ] . string . text ) ; <NEW_LINE><NEW_LINE><TAB> attr -> value_tag = IPP_TAG_KEYWORD ; <NEW_LINE><TAB> attr -> values [ 0 ] . string . text = _cupsStrAlloc ( "no - hold" ) ; <NEW_LINE> <END_VULN> <TAB> cupsdAddEvent ( CUPSD_EVENT_JOB_CONFIG_CHANGED , cupsdFindDest ( job -> dest ) , job , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> "Job job - hold - until value changed by user . " ) ;
class nsIconDecoder : public Decoder <NEW_LINE> { <NEW_LINE> public : <NEW_LINE> nsIconDecoder ( RasterImage & aImage ) ; <NEW_LINE> virtual ~ nsIconDecoder ( ) ; <NEW_LINE> <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> uint8_t mWidth ; <NEW_LINE> uint8_t mHeight ; <NEW_LINE> uint32_t mPixBytesRead ; <NEW_LINE> uint32_t mState ; <NEW_LINE> } ; <NEW_LINE> enum {
rtadv_event ( zvrf , RTADV_READ , sock ) ; <NEW_LINE> <START_VULN> len = rtadv_recv_packet ( sock , buf , BUFSIZ , & from , & ifindex , & hoplimit ) ; <NEW_LINE> <END_VULN> if ( len < 0 ) <NEW_LINE> <TAB> {
<TAB> <TAB> <TAB> <TAB> <TAB> efree ( result ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> zend_hash_move_forward ( Z_ARRVAL_PP ( subject ) ) ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <TAB> } else { <TAB>
<START_VULN> virtual nsresult OpenContentStream ( PRBool async , nsIInputStream ** stream ) = 0 ; <NEW_LINE> <END_VULN>
static int perf_swevent_init ( struct perf_event * event ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> int event_id = event -> attr . config ; <NEW_LINE> <END_VULN> <TAB> if ( event -> attr . type != PERF_TYPE_SOFTWARE ) <NEW_LINE> <TAB> <TAB> return - ENOENT ;
static krb5_error_code <NEW_LINE> <START_VULN> iakerb_alloc_context ( iakerb_ctx_id_t * pctx ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> iakerb_ctx_id_t ctx ; <NEW_LINE> <TAB> krb5_error_code code ;
<TAB> PORT_ZFree ( slotPw . data , PL_strlen ( slotPw . data ) ) ; <NEW_LINE> <TAB> if ( p12FilePw . data != NULL ) <NEW_LINE> <TAB> PORT_ZFree ( p12FilePw . data , PL_strlen ( p12FilePw . data ) ) ; <NEW_LINE> <TAB> if ( slot ) <NEW_LINE> <TAB> <TAB> PK11_FreeSlot ( slot ) ; <NEW_LINE> <TAB> if ( NSS_Shutdown ( ) != SECSuccess ) { <NEW_LINE> <TAB> pk12uErrno = 1 ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> PR_Cleanup ( ) ; <NEW_LINE> <START_VULN> <TAB> PL_ArenaFinish ( ) ; <NEW_LINE> <END_VULN> <TAB> return pk12uErrno ; <NEW_LINE> }
<TAB> * done = true ; <NEW_LINE> <TAB> spin_unlock_irqrestore ( & lock , flags ) ; <NEW_LINE> <START_VULN> <TAB> __net_random_once_disable_jump ( done_key ) ; <NEW_LINE> <END_VULN> <TAB> return true ; <NEW_LINE> }
static inline void set_pte_at ( struct mm_struct * mm , unsigned long addr , <NEW_LINE> <TAB> <TAB> <TAB> pte_t * ptep , pte_t pte ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> if ( pte_valid_ng ( pte ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> if ( ! pte_special ( pte ) && pte_exec ( pte ) ) <NEW_LINE> <TAB> <TAB> <TAB> __sync_icache_dcache ( pte , addr ) ; <NEW_LINE> <TAB> <TAB> if ( pte_dirty ( pte ) && pte_write ( pte ) )
void * chk_malloc ( size_t bytes ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> char * buffer = ( char * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ; <NEW_LINE> <END_VULN> <TAB> if ( buffer ) { <NEW_LINE> <TAB> <TAB> memset ( buffer , CHK_SENTINEL_VALUE , bytes + CHK_OVERHEAD_SIZE ) ; <NEW_LINE> <TAB> <TAB> size_t offset = dlmalloc_usable_size ( buffer ) - sizeof ( size_t ) ;
void * arm_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , <NEW_LINE> <TAB> <TAB> gfp_t gfp , struct dma_attrs * attrs ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <NEW_LINE> <END_VULN> <TAB> void * memory ; <NEW_LINE> <TAB> if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) )
<TAB> memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; <NEW_LINE> <TAB> fl6 -> flowi6_proto = proto ; <NEW_LINE> <TAB> fl6 -> daddr = ireq -> ir_v6_rmt_addr ; <NEW_LINE> <START_VULN> <TAB> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <NEW_LINE> <END_VULN> <TAB> fl6 -> saddr = ireq -> ir_v6_loc_addr ; <NEW_LINE> <TAB> fl6 -> flowi6_oif = ireq -> ir_iif ; <NEW_LINE> <TAB> fl6 -> flowi6_mark = ireq -> ir_mark ;
<TAB> <TAB> goto err ; <NEW_LINE> <TAB> if ( ! port ) { <NEW_LINE> <START_VULN> <TAB> <TAB> hlist_add_head ( & mp -> mglist , & br -> mglist ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ; <NEW_LINE> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> }
<TAB> size_t datalen = prep -> datalen ; <NEW_LINE> <TAB> int ret = 0 ; <NEW_LINE> <START_VULN> <TAB> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - ENOKEY ; <NEW_LINE> <TAB> if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) <NEW_LINE> <TAB> <TAB> return - EINVAL ;
<TAB> <TAB> skb -> protocol = htons ( ETH_P_IPV6 ) ; <NEW_LINE> <TAB> <TAB> skb -> ip_summed = CHECKSUM_PARTIAL ; <NEW_LINE> <TAB> <TAB> skb -> csum = 0 ; <NEW_LINE> <START_VULN> <TAB> } <NEW_LINE><NEW_LINE><TAB> err = skb_append_datato_frags ( sk , skb , getfrag , from , <NEW_LINE><TAB> <TAB> <TAB> <TAB> ( length - transhdrlen ) ) ; <NEW_LINE><TAB> if ( ! err ) { <NEW_LINE><TAB> <TAB> struct frag_hdr fhdr ; <NEW_LINE><TAB> kfree_skb ( skb ) ; <NEW_LINE><TAB> return err ; <NEW_LINE> <END_VULN> } <NEW_LINE> static inline struct ipv6_opt_hdr * ip6_opt_dup ( struct ipv6_opt_hdr * src ,
<TAB> free ( reply . enc_part . ciphertext . data ) ; <NEW_LINE> cleanup : <NEW_LINE> <START_VULN> <TAB> assert ( status != NULL ) ; <NEW_LINE> <END_VULN> <TAB> if ( reply_key ) <NEW_LINE> <TAB> <TAB> krb5_free_keyblock ( kdc_context , reply_key ) ; <NEW_LINE> <TAB> if ( errcode )
<TAB> <TAB> <TAB> score = 0 ; <NEW_LINE> <TAB> <TAB> <TAB> ret = 0 ; <NEW_LINE> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> pd . buf_size += ret ; <NEW_LINE> <END_VULN> <TAB> <TAB> pd . buf = & buf [ offset ] ; <NEW_LINE> <TAB> <TAB> memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ) ;
class nsPNGDecoder : public Decoder <NEW_LINE> { <NEW_LINE> public : <NEW_LINE> nsPNGDecoder ( RasterImage & aImage ) ; <NEW_LINE> virtual ~ nsPNGDecoder ( ) ; <NEW_LINE> virtual void InitInternal ( ) ; <NEW_LINE> <START_VULN> virtual void WriteInternal ( const char * aBuffer , uint32_t aCount ) ; <NEW_LINE> <END_VULN> virtual Telemetry : : ID SpeedHistogram ( ) ; <NEW_LINE> void CreateFrame ( png_uint_32 x_offset , png_uint_32 y_offset , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> int32_t width , int32_t height , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> gfxImageFormat format ) ; <NEW_LINE> void EndImageFrame ( ) ;
<TAB> * <NEW_LINE> SVGLengthList & InternalList ( ) const ; <NEW_LINE> <START_VULN> void EnsureItemAt ( uint32_t aIndex ) ; <NEW_LINE> <END_VULN> void MaybeInsertNullInAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> void MaybeRemoveItemFromAnimValListAt ( uint32_t aIndex ) ; <NEW_LINE> FallibleTArray < DOMSVGLength * > mItems ;
{ <NEW_LINE> <TAB> int error ; <NEW_LINE> <TAB> bool is_dir = d_is_dir ( old_dentry ) ; <NEW_LINE> <START_VULN> <TAB> const unsigned char * old_name ; <NEW_LINE> <END_VULN> <TAB> struct inode * source = old_dentry -> d_inode ; <NEW_LINE> <TAB> struct inode * target = new_dentry -> d_inode ; <NEW_LINE> <TAB> bool new_is_dir = false ; <NEW_LINE> <TAB> unsigned max_links = new_dir -> i_sb -> s_max_links ; <NEW_LINE> <TAB> if ( source == target ) <NEW_LINE> <TAB> <TAB> return 0 ;
module_init ( aes_s390_init ) ; <NEW_LINE> module_exit ( aes_s390_fini ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "aes - all" ) ; <NEW_LINE> <END_VULN> MODULE_DESCRIPTION ( "Rijndael ( AES ) Cipher Algorithm" ) ; <NEW_LINE> MODULE_LICENSE ( "GPL" ) ;
} <NEW_LINE> <START_VULN> CWD_API void realpath_cache_del ( const char * path , int path_len ) <NEW_LINE> <END_VULN> { <NEW_LINE> <TAB> zend_ulong key = realpath_cache_key ( path , path_len ) ; <NEW_LINE> <TAB> zend_ulong n = key % ( sizeof ( CWDG ( realpath_cache ) ) / sizeof ( CWDG ( realpath_cache ) [ 0 ] ) ) ;
<TAB> ASSERT ( blkno == 0 ) ; <NEW_LINE> <TAB> error = xfs_attr3_leaf_create ( args , blkno , & bp ) ; <NEW_LINE> <TAB> if ( error ) { <NEW_LINE> <START_VULN> <TAB> <TAB> error = xfs_da_shrink_inode ( args , 0 , bp ) ; <NEW_LINE><TAB> <TAB> bp = NULL ; <NEW_LINE><TAB> <TAB> if ( error ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> goto out ; <NEW_LINE> <TAB> <TAB> xfs_idata_realloc ( dp , size , XFS_ATTR_FORK ) ; <TAB> <NEW_LINE> <TAB> <TAB> memcpy ( ifp -> if_u1 . if_data , tmpbuffer , size ) ; <TAB>
public : <NEW_LINE> <TAB> inline void setDefaultCompartmentObject ( JSObject * obj ) ; <NEW_LINE> <TAB> inline void setDefaultCompartmentObjectIfUnset ( JSObject * obj ) ; <NEW_LINE> <TAB> JSObject * maybeDefaultCompartmentObject ( ) const { return defaultCompartmentObject_ ; } <NEW_LINE> <TAB> js : : ContextStack stack ; <NEW_LINE> <START_VULN> <TAB> <NEW_LINE> <END_VULN> <TAB> inline js : : Handle < js : : GlobalObject * > global ( ) const ; <NEW_LINE> <TAB> inline bool hasfp ( ) const { return stack . hasfp ( ) ; } <NEW_LINE> <TAB> inline js : : StackFrame * fp ( ) const { return stack . fp ( ) ; } <NEW_LINE> <TAB> inline js : : StackFrame * maybefp ( ) const { return stack . maybefp ( ) ; } <NEW_LINE> <TAB> inline js : : FrameRegs & regs ( ) const { return stack . regs ( ) ; } <NEW_LINE> <TAB> inline js : : FrameRegs * maybeRegs ( ) const { return stack . maybeRegs ( ) ; }
<TAB> if ( p -> trtp ) { <NEW_LINE> <START_VULN> <TAB> <TAB> if ( tportno > 0 ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> ast_sockaddr_set_port ( tsa , tportno ) ; <NEW_LINE> <TAB> <TAB> <TAB> ast_rtp_instance_set_remote_address ( p -> trtp , tsa ) ; <NEW_LINE> <TAB> <TAB> <TAB> if ( debug ) {
<TAB> if ( ( ptr = strchr ( filename , ' ? ' ) ) != NULL ) <NEW_LINE> <TAB> * ptr = '\0' ; <NEW_LINE> <START_VULN> <TAB> if ( ( status = stat ( filename , filestats ) ) != 0 ) <NEW_LINE> <END_VULN> <TAB> {
<TAB> uint32_t length ( ) const { <NEW_LINE> <TAB> <TAB> JS_ASSERT ( hasSourceData ( ) ) ; <NEW_LINE> <TAB> <TAB> return length_ ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> bool argumentsNotIncluded ( ) const { <NEW_LINE> <TAB> <TAB> JS_ASSERT ( hasSourceData ( ) ) ; <NEW_LINE> <TAB> <TAB> return argumentsNotIncluded_ ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> const jschar * chars ( JSContext * cx , const SourceDataCache : : AutoSuppressPurge & asp ) ; <NEW_LINE> <END_VULN> <TAB> JSFlatString * substring ( JSContext * cx , uint32_t start , uint32_t stop ) ; <NEW_LINE> <TAB> void addSizeOfIncludingThis ( mozilla : : MallocSizeOf mallocSizeOf , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> JS : : ScriptSourceInfo * info ) const ; <NEW_LINE> <TAB> template < XDRMode mode > <NEW_LINE> <TAB> bool performXDR ( XDRState < mode > * xdr ) ;
<TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> sr -> fd_file = fd ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> sr -> bytes_to_send = finfo . size ; <NEW_LINE> <TAB> <TAB> <TAB> sr -> headers . content_length = finfo . size ; <NEW_LINE> <TAB> <TAB> <TAB> sr -> headers . real_length = finfo . size ;
<TAB> TRY ( value ( p , v ) ) ; <NEW_LINE> } else { <NEW_LINE> <START_VULN> <TAB> p -> tokenbuf [ p -> tokenpos ] = 0 ; <NEW_LINE> <END_VULN> <TAB> char * end = 0 ; <NEW_LINE> <TAB> double d = jvp_strtod ( & p -> dtoa , p -> tokenbuf , & end ) ; <NEW_LINE> <TAB> if ( end == 0 || * end != 0 )
static int mp_get_count ( struct sb_uart_state * state , struct serial_icounter_struct * icnt ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> struct serial_icounter_struct icount ; <NEW_LINE> <END_VULN> <TAB> struct sb_uart_icount cnow ; <NEW_LINE> <TAB> struct sb_uart_port * port = state -> port ;
<TAB> hdr = ( sctp_addiphdr_t * ) chunk -> skb -> data ; <NEW_LINE> <TAB> serial = ntohl ( hdr -> serial ) ; <NEW_LINE> <START_VULN> <TAB> addr_param = ( union sctp_addr_param * ) hdr -> params ; <NEW_LINE><TAB> length = ntohs ( addr_param -> p . length ) ; <NEW_LINE><TAB> if ( length < sizeof ( sctp_paramhdr_t ) ) <NEW_LINE><TAB> <TAB> return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , <NEW_LINE><TAB> <TAB> <TAB> ( void * ) addr_param , commands ) ; <NEW_LINE><NEW_LINE><TAB> if ( ! sctp_verify_asconf ( asoc , <NEW_LINE><TAB> <TAB> <TAB> ( sctp_paramhdr_t * ) ( ( void * ) addr_param + length ) , <NEW_LINE><TAB> <TAB> <TAB> ( void * ) chunk -> chunk_end , <NEW_LINE><TAB> <TAB> <TAB> & err_param ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ( void * ) err_param , commands ) ;
<TAB> duprintf ( "check_compat_entry_size_and_hooks % p\n" , e ) ; <NEW_LINE> <TAB> if ( ( unsigned long ) e % __alignof__ ( struct compat_ipt_entry ) != 0 || <NEW_LINE> <START_VULN> <TAB> ( unsigned char * ) e + sizeof ( struct compat_ipt_entry ) >= limit ) { <NEW_LINE> <END_VULN> <TAB> <TAB> duprintf ( "Bad offset % p , limit = % p\n" , e , limit ) ; <NEW_LINE> <TAB> <TAB> return - EINVAL ; <NEW_LINE> <TAB> }
} <NEW_LINE> <START_VULN> extern int udf_get_filename ( struct super_block * , uint8_t * , uint8_t * , int ) ; <NEW_LINE> <END_VULN> extern int udf_put_filename ( struct super_block * , const uint8_t * , uint8_t * , <NEW_LINE> <TAB> <TAB> <TAB> int ) ; <NEW_LINE> extern int udf_build_ustr ( struct ustr * , dstring * , int ) ;
<TAB> TriangleFilter , exception ) ; <NEW_LINE> <TAB> chroma_image = DestroyImage ( chroma_image ) ; <NEW_LINE> <TAB> if ( resize_image == ( Image * ) NULL ) <NEW_LINE> <START_VULN> <TAB> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <END_VULN> <TAB> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y + + ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;
<TAB> <TAB> <TAB> act_code = GetGifWord ( i , & context ) ; <NEW_LINE> <TAB> <TAB> <TAB> casspecial = ( u8 ) act_code ; <NEW_LINE> <TAB> <TAB> <TAB> old_code = act_code ; <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> WritePixel ( i , & context , casspecial ) ; npix -- ; <NEW_LINE> <END_VULN> <TAB> <TAB> } else { <NEW_LINE> <TAB> <TAB> <TAB> read_byt = act_code ; <NEW_LINE> <TAB> <TAB> <TAB> if ( act_code >= free ) { <TAB>
<TAB> <TAB> struct sock * sk , int tstype ) <NEW_LINE> { <NEW_LINE> <TAB> struct sk_buff * skb ; <NEW_LINE> <START_VULN> <TAB> bool tsonly ; <NEW_LINE> <END_VULN> <TAB> if ( ! sk ) <NEW_LINE> <TAB> <TAB> return ;
bool mFullScreen ; <NEW_LINE> void * mJavaView ; <NEW_LINE> #endif <NEW_LINE> nsPluginNativeWindow * mPluginWindow ; <NEW_LINE> nsRefPtr < nsNPAPIPluginInstance > mInstance ; <NEW_LINE> nsPluginFrame * mPluginFrame ; <NEW_LINE> <START_VULN> nsIContent * mContent ; <NEW_LINE> <END_VULN> nsCString mDocumentBase ; <NEW_LINE> bool mWidgetCreationComplete ; <NEW_LINE> nsCOMPtr < nsIWidget > mWidget ; <NEW_LINE> nsRefPtr < nsPluginHost > mPluginHost ; <NEW_LINE> #ifdef XP_MACOSX <NEW_LINE> NP_CGContext mCGPluginPortCopy ; <NEW_LINE> int32_t mInCGPaintLevel ;
<TAB> <TAB> <TAB> ( * buffer ) [ ( * currlen ) + + ] = ( char ) c ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> return ; <NEW_LINE> <END_VULN> }
<TAB> <TAB> exit ( 1 ) ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> pid_t child = fork ( ) ; <NEW_LINE><TAB> if ( child < 0 ) <NEW_LINE><TAB> <TAB> errExit ( "fork" ) ; <NEW_LINE><TAB> if ( child == 0 ) { <NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> drop_privs ( 0 ) ; <NEW_LINE><NEW_LINE><TAB> <TAB> <NEW_LINE><TAB> <TAB> int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; <NEW_LINE><TAB> <TAB> if ( rv ) <NEW_LINE><TAB> <TAB> <TAB> fprintf ( stderr , "Warning : cannot transfer . asoundrc in private home directory\n" ) ; <NEW_LINE><TAB> <TAB> else { <NEW_LINE><TAB> <TAB> <TAB> fs_logger2 ( "clone" , dest ) ; <NEW_LINE><TAB> <TAB> } <NEW_LINE><TAB> <TAB> _exit ( 0 ) ; <NEW_LINE><TAB> } <NEW_LINE><TAB> <NEW_LINE><TAB> waitpid ( child , NULL , 0 ) ; <NEW_LINE> <END_VULN> <TAB> unlink ( src ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : libvorbis backend and mapping structures ; needed for <NEW_LINE> <TAB> <TAB> <TAB> static mode headers <NEW_LINE> <START_VULN> last mod : $ Id : backends . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _vorbis_backend_h_
{ <NEW_LINE> <TAB> union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; <NEW_LINE> <TAB> int <TAB> num_items_scanned ; <NEW_LINE> <START_VULN> <TAB> int <TAB> yy , mm , dd , hr , min , sec , csec ; <NEW_LINE><TAB> guint <TAB> pkt_len ; <NEW_LINE> <END_VULN> <TAB> int <TAB> pro , off , pri , rm , error ; <NEW_LINE> <TAB> guint <TAB> code1 , code2 ; <NEW_LINE> <TAB> char <TAB> if_name [ COSINE_MAX_IF_NAME_LEN ] = "" , direction [ 6 ] = "" ;
{ <NEW_LINE> struct NntpServer * nserv = data ; <NEW_LINE> struct NntpData * nntp_data = NULL ; <NEW_LINE> <START_VULN> char group [ LONG_STRING ] ; <NEW_LINE> <END_VULN> char desc [ HUGE_STRING ] = "" ; <NEW_LINE> char mod ; <NEW_LINE> anum_t first , last ;
if ( posts == 0 ) { <NEW_LINE> <TAB> nonzero += accumulate_fit ( logmask , logmdct , 0 , n , fits , n , info ) ; <NEW_LINE> } else { <NEW_LINE> <TAB> for ( i = 0 ; i < posts - 1 ; i + + ) <NEW_LINE> <TAB> nonzero += accumulate_fit ( logmask , logmdct , look -> sorted_index [ i ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> look -> sorted_index [ i + 1 ] , fits + i , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> n , info ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( nonzero ) { <NEW_LINE> <TAB> int y0 = - 200 ; <NEW_LINE> <TAB> int y1 = - 200 ; <NEW_LINE> <TAB> fit_line ( fits , posts - 1 , & y0 , & y1 ) ; <NEW_LINE> <TAB> fit_valueA [ 0 ] = y0 ; <NEW_LINE> <TAB> fit_valueB [ 0 ] = y0 ;
<TAB> <TAB> <TAB> case REOP_REPEAT : <NEW_LINE> <TAB> <TAB> <TAB> <TAB> -- curState ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> do { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> if ( ! result ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> if ( curState -> u . quantifier . min == 0 )
<TAB> <TAB> verdef -> vd_hash = READ32 ( dfs , j ) <NEW_LINE> <TAB> <TAB> verdef -> vd_aux = READ32 ( dfs , j ) <NEW_LINE> <TAB> <TAB> verdef -> vd_next = READ32 ( dfs , j ) <NEW_LINE> <START_VULN> <TAB> <TAB> vstart += verdef -> vd_aux ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <NEW_LINE> <TAB> <TAB> <TAB> sdb_free ( sdb_verdef ) ; <NEW_LINE> <TAB> <TAB> <TAB> goto out_error ;
{ <NEW_LINE> <TAB> struct videobuf_mapping * map = vma -> vm_private_data ; <NEW_LINE> <START_VULN> <TAB> dprintk ( 2 , "vm_open % p [ count = % d , vma = % 08lx - % 08lx ] \n" , map , <NEW_LINE> <END_VULN> <TAB> <TAB> map -> count , vma -> vm_start , vma -> vm_end ) ; <NEW_LINE> <TAB> map -> count + + ;
<TAB> if ( copy_from_user ( & getaddrs , optval , len ) ) <NEW_LINE> <TAB> <TAB> return - EFAULT ; <NEW_LINE> <START_VULN> <TAB> if ( getaddrs . addr_num <= 0 ) return - EINVAL ; <NEW_LINE> <END_VULN> <TAB> if ( 0 == getaddrs . assoc_id ) { <NEW_LINE> <TAB> <TAB> bp = & sctp_sk ( sk ) -> ep -> base . bind_addr ;
<TAB> data = malloc ( size * sizeof ( krb5_data ) ) ; <NEW_LINE> <TAB> if ( ! data ) { retval = ENOMEM ; } <NEW_LINE> <START_VULN> <TAB> if ( ! retval ) { <NEW_LINE><TAB> <TAB> r = strdup ( realm ) ; <NEW_LINE><TAB> <TAB> if ( ! r ) { retval = ENOMEM ; } <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> while ( ! retval && ( component = va_arg ( ap , char * ) ) ) { <NEW_LINE> <TAB> <TAB> if ( count == size ) {
<START_VULN> <TAB> <TAB> if ( ( int ) np -> file -> basename_utf16 . length > ffmax ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> if ( archive_strncpy_l ( & iso9660 -> mbs , <NEW_LINE> <TAB> <TAB> <TAB> ( const char * ) np -> identifier , l , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> iso9660 -> sconv_from_utf16be ) != 0 &&
<TAB> av_frame_copy_props ( outpic , inpic ) ; <NEW_LINE> <TAB> outpic -> interlaced_frame = 0 ; <NEW_LINE> <START_VULN> <TAB> for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ; <NEW_LINE> <TAB> <TAB> bwidth = kerndeint -> tmp_bwidth [ plane ] ;
<TAB> spin_unlock_irqrestore ( & i8042_lock , flags ) ; <NEW_LINE> <START_VULN> <TAB> if ( likely ( port -> exists && ! filtered ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> serio_interrupt ( serio , data , dfl ) ; <NEW_LINE> out :
<TAB> if ( ( conn -> validator == NULL ) || <NEW_LINE> <START_VULN> <TAB> cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return ret_error ; <NEW_LINE> <TAB> size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , " * ( ) " ) ;
<TAB> case 's' : disableLocking = PR_TRUE ; break ; <NEW_LINE> <TAB> case 't' : <NEW_LINE> <TAB> maxThreads = PORT_Atoi ( optstate -> value ) ; <NEW_LINE> <TAB> if ( maxThreads > MAX_THREADS ) maxThreads = MAX_THREADS ; <NEW_LINE> <TAB> if ( maxThreads < MIN_THREADS ) maxThreads = MIN_THREADS ; <NEW_LINE> <TAB> break ; <NEW_LINE> <START_VULN> <TAB> case 'u' : enableSessionTickets = PR_TRUE ; break ; <NEW_LINE> <END_VULN> <TAB> case 'v' : verbose + + ; break ; <NEW_LINE> <TAB> case 'w' : <NEW_LINE> <TAB> <TAB> <TAB> pwdata . source = PW_PLAINTEXT ; <NEW_LINE> <TAB> <TAB> <TAB> pwdata . data = passwd = PORT_Strdup ( optstate -> value ) ; <NEW_LINE> <TAB> <TAB> <TAB> break ;
<TAB> file -> path = * in_path ; <NEW_LINE> <TAB> for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <NEW_LINE> <START_VULN> <TAB> <TAB> int j , len = apdu . resp [ i + 1 ] ; <NEW_LINE> <END_VULN> <TAB> <TAB> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; <NEW_LINE> <TAB> <TAB> switch ( type ) {
<TAB> unsigned int lci , new_lci ; <NEW_LINE> <TAB> unsigned char cause , diagnostic ; <NEW_LINE> <TAB> struct net_device * dev ; <NEW_LINE> <START_VULN> <TAB> int len , res = 0 ; <NEW_LINE> <END_VULN> <TAB> char buf [ 11 ] ; <NEW_LINE> #if 0
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function : fft transform <NEW_LINE> <START_VULN> last mod : $ Id : smallft . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <NEW_LINE> <END_VULN> #ifndef _V_SMFT_H_ <NEW_LINE> #define _V_SMFT_H_ <NEW_LINE> #include "vorbis / codec . h"
{ <NEW_LINE> <TAB> static gprincs_ret ret ; <NEW_LINE> <TAB> char * prime_arg ; <NEW_LINE> <START_VULN> <TAB> gss_buffer_desc client_name , <NEW_LINE><TAB> <TAB> service_name ; <NEW_LINE> <END_VULN> <TAB> OM_uint32 minor_stat ; <NEW_LINE> <TAB> kadm5_server_handle_t handle ; <NEW_LINE> <TAB> const char * errmsg = NULL ;
<TAB> txStack mResultHandlerStack ; <NEW_LINE> <TAB> txStack mParamStack ; <NEW_LINE> <TAB> txInstruction * mNextInstruction ; <NEW_LINE> <TAB> txVariableMap * mLocalVariables ; <NEW_LINE> <TAB> txVariableMap mGlobalVariableValues ; <NEW_LINE> <TAB> nsRefPtr < txAExprResult > mGlobalVarPlaceholderValue ; <NEW_LINE> <TAB> PRInt32 mRecursionDepth ; <NEW_LINE> <START_VULN> <TAB> TemplateRule * mTemplateRules ; <NEW_LINE><TAB> PRInt32 mTemplateRulesBufferSize ; <NEW_LINE><TAB> PRInt32 mTemplateRuleCount ; <NEW_LINE> <END_VULN> <TAB> txIEvalContext * mEvalContext ; <NEW_LINE> <TAB> txIEvalContext * mInitialEvalContext ; <NEW_LINE> <TAB> txOwningExpandedNameMap < txIGlobalParameter > * mGlobalParams ; <NEW_LINE> <TAB> txLoadedDocumentsHash mLoadedDocuments ; <NEW_LINE> <TAB> txKeyHash mKeyHash ;
MODULE_DESCRIPTION ( "Rijndael ( AES ) Cipher Algorithm" ) ; <NEW_LINE> MODULE_LICENSE ( "Dual BSD / GPL" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "aes" ) ; <NEW_LINE> <END_VULN>
<TAB> <TAB> break ; <NEW_LINE> <TAB> case 0xe9 : <NEW_LINE> <TAB> case 0xeb : <NEW_LINE> <START_VULN> <TAB> <TAB> jmp_rel ( ctxt , ctxt -> src . val ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> ctxt -> dst . type = OP_NONE ; <NEW_LINE> <TAB> <TAB> break ; <NEW_LINE> <TAB> case 0xf4 :
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> char errbuff [ 128 ] ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> cli_strerror ( errno , errbuff , sizeof ( errbuff ) ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> cli_dbgmsg ( "cli_scanxar : Can't read % li bytes @ % li , errno : % s . \n" , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> length , at , errbuff ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> rc = CL_EREAD ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> __lzma_wrap_free ( NULL , buff ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> cli_LzmaShutdown ( & lz ) ;
<TAB> code FAR * next ; <NEW_LINE> <TAB> const unsigned short FAR * base ; <NEW_LINE> <TAB> const unsigned short FAR * extra ; <NEW_LINE> <START_VULN> <TAB> int end ; <NEW_LINE> <END_VULN> <TAB> unsigned short count [ MAXBITS + 1 ] ; <NEW_LINE> <TAB> unsigned short offs [ MAXBITS + 1 ] ; <NEW_LINE> <TAB> static const unsigned short lbase [ 31 ] = {
<TAB> <TAB> gss_release_buffer ( & tmpmin , & sc -> DER_mechTypes ) ; <NEW_LINE> <TAB> <TAB> assert ( mech_wanted != GSS_C_NO_OID ) ; <NEW_LINE> <TAB> } else <NEW_LINE> <START_VULN> <TAB> <TAB> sc = create_spnego_ctx ( ) ; <NEW_LINE> <END_VULN> <TAB> if ( sc == NULL ) { <NEW_LINE> <TAB> <TAB> ret = GSS_S_FAILURE ; <NEW_LINE> <TAB> <TAB> * return_token = NO_TOKEN_SEND ;
{ <NEW_LINE> <TAB> if ( params -> buffer . fragment_size == 0 || <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) <NEW_LINE> <END_VULN> <TAB> <TAB> return - EINVAL ;
<START_VULN> <TAB> if ( serial -> num_ports < 2 ) <NEW_LINE><TAB> <TAB> return - 1 ; <NEW_LINE> <END_VULN> <TAB> port = serial -> port [ 0 ] ;
<TAB> <TAB> + + compno , + + picomp ) { <NEW_LINE> <TAB> <TAB> <TAB> for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < <NEW_LINE> <TAB> <TAB> <TAB> picomp -> numrlvls ; + + rlvlno , + + pirlvl ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <NEW_LINE><TAB> <TAB> <TAB> <TAB> picomp -> numrlvls - rlvlno - 1 ) ) ; <NEW_LINE><TAB> <TAB> <TAB> <TAB> ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <NEW_LINE><TAB> <TAB> <TAB> <TAB> picomp -> numrlvls - rlvlno - 1 ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; <NEW_LINE> <TAB> <TAB> <TAB> }
<TAB> <TAB> for ( x = 0 ; x < hdr -> width ; x + + ) { <NEW_LINE> <TAB> <TAB> <TAB> while ( nz < hdr -> depth ) { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> if ( ( c = jas_stream_getc ( in ) ) == EOF ) { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> return - 1 ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <TAB> <TAB> <TAB> <TAB> z = ( z << 8 ) | c ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> nz += 8 ;
<TAB> mpz_mod ( u1 , u1 , key -> q ) ; <NEW_LINE> <TAB> mpz_mul ( u2 , r , w ) ; <NEW_LINE> <TAB> mpz_mod ( u2 , u2 , key -> q ) ; <NEW_LINE> <START_VULN> <TAB> mpz_powm ( v1 , key -> g , u1 , key -> p ) ; <NEW_LINE><TAB> mpz_powm ( v2 , key -> y , u2 , key -> p ) ; <NEW_LINE> <END_VULN> <TAB> mpz_mul ( w , v1 , v2 ) ; <NEW_LINE> <TAB> mpz_mod ( w , w , key -> p ) ; <NEW_LINE> <TAB> mpz_mod ( w , w , key -> q ) ;
<TAB> fl6 -> fl6_dport = inet -> inet_dport ; <NEW_LINE> <TAB> security_sk_classify_flow ( sk , flowi6_to_flowi ( fl6 ) ) ; <NEW_LINE> <START_VULN> <TAB> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <NEW_LINE> <END_VULN> <TAB> dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ; <NEW_LINE> <TAB> if ( ! dst ) {
<TAB> void wrapPendingException ( ) ; <NEW_LINE> private : <NEW_LINE> <TAB> js : : frontend : : ParseMapPool * parseMapPool_ ; <NEW_LINE> public : <NEW_LINE> <START_VULN> <TAB> JSSharpObjectMap sharpObjectMap ; <NEW_LINE><TAB> js : : BusyArraysSet busyArrays ; <NEW_LINE> <END_VULN> <TAB> JSArgumentFormatMap * argumentFormatMap ; <NEW_LINE> <TAB> char * lastMessage ;
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "lowkeyi . h" <NEW_LINE> #include "secasn1 . h" <NEW_LINE> #include "secder . h" <NEW_LINE> #include "secoid . h" <NEW_LINE> #include "blapi . h" <NEW_LINE> #include "secitem . h" <NEW_LINE> #include "pcert . h"
void pin_remove ( struct fs_pin * pin ) <NEW_LINE> { <NEW_LINE> <TAB> spin_lock ( & pin_lock ) ; <NEW_LINE> <START_VULN> <TAB> hlist_del ( & pin -> m_list ) ; <NEW_LINE><TAB> hlist_del ( & pin -> s_list ) ; <NEW_LINE> <END_VULN> <TAB> spin_unlock ( & pin_lock ) ; <NEW_LINE> <TAB> spin_lock_irq ( & pin -> wait . lock ) ; <NEW_LINE> <TAB> pin -> done = 1 ;
<START_VULN> static void ptrace_hbptriggered ( struct perf_event * bp , int unused , <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> struct perf_sample_data * data , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> struct pt_regs * regs ) <NEW_LINE> {
<TAB> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> ldblk , sizeof ( * BImgBuff ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> if ( BImgBuff == ( unsigned char * ) NULL ) <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> goto NoMemory ;
<TAB> ret = hugetlb_acct_memory ( h , chg ) ; <NEW_LINE> <TAB> if ( ret < 0 ) { <NEW_LINE> <TAB> <TAB> hugepage_subpool_put_pages ( spool , chg ) ; <NEW_LINE> <START_VULN> <TAB> <TAB> return ret ; <NEW_LINE> <END_VULN> <TAB> }
<TAB> <TAB> if ( i < pos && i + insn -> off + 1 > pos ) <NEW_LINE> <TAB> <TAB> <TAB> insn -> off += delta ; <NEW_LINE> <START_VULN> <TAB> <TAB> else if ( i > pos && i + insn -> off + 1 < pos ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> insn -> off -= delta ; <NEW_LINE> <TAB> } <NEW_LINE> }
<TAB> if ( ret != XpmSuccess ) { <NEW_LINE> <TAB> <TAB> return 0 ; <NEW_LINE> <TAB> } <NEW_LINE> <TAB> if ( ! ( im = gdImageCreate ( image . width , image . height ) ) ) { <NEW_LINE> <TAB> <TAB> goto done ; <NEW_LINE> <TAB> } <NEW_LINE> <START_VULN> <TAB> number = image . ncolors ; <NEW_LINE> <END_VULN> <TAB> colors = ( int * ) safe_emalloc ( number , sizeof ( int ) , 0 ) ; <NEW_LINE> <TAB> for ( i = 0 ; i < number ; i + + ) { <NEW_LINE> <TAB> <TAB> switch ( strlen ( image . colorTable [ i ] . c_color ) ) {
<TAB> <TAB> <TAB> size_t cnt , loff_t * ppos ) ; <NEW_LINE> ssize_t ftrace_notrace_write ( struct file * file , const char __user * ubuf , <NEW_LINE> <TAB> <TAB> <TAB> size_t cnt , loff_t * ppos ) ; <NEW_LINE> <START_VULN> loff_t ftrace_regex_lseek ( struct file * file , loff_t offset , int whence ) ; <NEW_LINE> <END_VULN> int ftrace_regex_release ( struct inode * inode , struct file * file ) ; <NEW_LINE> void __init
<TAB> u8 * raw_key = NULL ; <NEW_LINE> <TAB> int res ; <NEW_LINE> <TAB> res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; <NEW_LINE> <TAB> if ( res ) <NEW_LINE> <TAB> <TAB> return res ; <NEW_LINE> <TAB> if ( ! inode -> i_sb -> s_cop -> get_context ) <NEW_LINE> <TAB> <TAB> return - EOPNOTSUPP ; <NEW_LINE> <START_VULN> retry : <NEW_LINE><TAB> crypt_info = ACCESS_ONCE ( inode -> i_crypt_info ) ; <NEW_LINE><TAB> if ( crypt_info ) { <NEW_LINE><TAB> <TAB> if ( ! crypt_info -> ci_keyring_key || <NEW_LINE><TAB> <TAB> <TAB> <TAB> key_validate ( crypt_info -> ci_keyring_key ) == 0 ) <NEW_LINE><TAB> <TAB> <TAB> return 0 ; <NEW_LINE><TAB> <TAB> fscrypt_put_encryption_info ( inode , crypt_info ) ; <NEW_LINE><TAB> <TAB> goto retry ; <NEW_LINE><TAB> } <NEW_LINE> <END_VULN> <TAB> res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; <NEW_LINE> <TAB> if ( res < 0 ) {
<TAB> <TAB> <TAB> <TAB> <TAB> value = va_arg ( args , int ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> fmtint ( sbuffer , buffer , & currlen , maxlen , <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> value , 10 , min , max , flags ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> case 'X' : <NEW_LINE> <TAB> <TAB> <TAB> <TAB> flags |= DP_F_UP ;
<TAB> err = sock_do_ioctl ( net , sock , cmd , ( unsigned long ) & kts ) ; <NEW_LINE> <TAB> set_fs ( old_fs ) ; <NEW_LINE> <TAB> if ( ! err ) <NEW_LINE> <START_VULN> <TAB> <TAB> err = compat_put_timespec ( up , & kts ) ; <NEW_LINE> <END_VULN> <TAB> return err ; <NEW_LINE> }
* <NEW_LINE> * <TAB> NET_RX_SUCCESS <TAB> ( no congestion ) <NEW_LINE> <START_VULN> * <TAB> NET_RX_DROP ( packet was dropped ) <NEW_LINE> <END_VULN> *
char * buf = mutt_str_strdup ( src ) ; <NEW_LINE> imap_utf_encode ( idata , & buf ) ; <NEW_LINE> <START_VULN> imap_quote_string ( dest , dlen , buf ) ; <NEW_LINE> <END_VULN> FREE ( & buf ) ; <NEW_LINE> }
<TAB> addr = gfn_to_hva ( kvm , gfn ) ; <NEW_LINE> <TAB> if ( kvm_is_error_hva ( addr ) ) <NEW_LINE> <TAB> <TAB> return - EFAULT ; <NEW_LINE> <START_VULN> <TAB> r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ; <NEW_LINE> <END_VULN> <TAB> if ( r ) <NEW_LINE> <TAB> <TAB> return - EFAULT ; <NEW_LINE> <TAB> return 0 ;
private : <NEW_LINE> <TAB> nsGfxScrollFrameInner * mInner ; <NEW_LINE> } ; <NEW_LINE> void FinishReflowForScrollbar ( nsIContent * aContent , nscoord aMinXY , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nscoord aMaxXY , nscoord aCurPosXY , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nscoord aPageIncrement , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nscoord aIncrement ) ; <NEW_LINE> <START_VULN> static void SetScrollbarEnabled ( nsIContent * aContent , nscoord aMaxPos ) ; <NEW_LINE> <END_VULN> void SetCoordAttribute ( nsIContent * aContent , nsIAtom * aAtom , nscoord aSize ) ; <NEW_LINE> nscoord GetCoordAttribute ( nsIFrame * aFrame , nsIAtom * aAtom , nscoord aDefaultValue , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> nscoord * aRangeStart , nscoord * aRangeLength ) ; <NEW_LINE> void UpdateScrollbarPosition ( ) ; <NEW_LINE> nsRect GetScrollPortRect ( ) const { return mScrollPort ; }
if ( attr ) <NEW_LINE> { <NEW_LINE> <START_VULN> <TAB> attr -> value_tag = IPP_TAG_KEYWORD ; <NEW_LINE><TAB> cupsdSetString ( & ( attr -> values [ 0 ] . string . text ) , "no - hold" ) ; <NEW_LINE> <END_VULN> }
% <NEW_LINE> % DefineImageProperty ( ) associates an assignment string of the form <NEW_LINE> % "key = value" with an artifact or options . It is equivelent to <NEW_LINE> <START_VULN> % SetImageProperty ( ) <NEW_LINE> <END_VULN> % <NEW_LINE> % The format of the DefineImageProperty method is : <NEW_LINE> %
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm , NEON accelerated" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha1" ) ; <NEW_LINE> <END_VULN>
typedef int ( * RE_EXEC_FUNC ) ( <NEW_LINE> <TAB> uint8_t * code , <NEW_LINE> <TAB> uint8_t * input , <NEW_LINE> <START_VULN> <TAB> size_t input_size , <NEW_LINE> <END_VULN> <TAB> int flags , <NEW_LINE> <TAB> RE_MATCH_CALLBACK_FUNC callback , <NEW_LINE> <TAB> void * callback_args ) ;
<TAB> <TAB> } <NEW_LINE> <TAB> } else <NEW_LINE> #endif <NEW_LINE> <START_VULN> <TAB> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <NEW_LINE> <END_VULN> <TAB> <TAB> long a = * ( long * ) ( src1 + i ) ; <NEW_LINE> <TAB> <TAB> long b = * ( long * ) ( src2 + i ) ; <NEW_LINE> <TAB> <TAB> * ( long * ) ( dst + i ) = ( ( a|pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ;
NS_DECL_NSIDOMPARSERJS <NEW_LINE> NS_IMETHOD Initialize ( nsISupports * aOwner , JSContext * cx , JSObject * obj , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> PRUint32 argc , jsval * argv ) ; <NEW_LINE> private : <NEW_LINE> <START_VULN> nsresult SetUpDocument ( DocumentFlavor aFlavor , nsIDOMDocument ** aResult ) ; <NEW_LINE> <END_VULN> class AttemptedInitMarker { <NEW_LINE> public : <NEW_LINE> <TAB> AttemptedInitMarker ( bool * aAttemptedInit ) : <NEW_LINE> <TAB> mAttemptedInit ( aAttemptedInit ) <NEW_LINE> <TAB> { } <NEW_LINE> <TAB> ~ AttemptedInitMarker ( ) {
MODULE_LICENSE ( "GPL" ) ; <NEW_LINE> MODULE_DESCRIPTION ( "SHA - 512 and SHA - 384 Secure Hash Algorithms" ) ; <NEW_LINE> <START_VULN> MODULE_ALIAS ( "sha384" ) ; <NEW_LINE>MODULE_ALIAS ( "sha512" ) ; <NEW_LINE> <END_VULN>
<START_VULN> <TAB> <TAB> snprintf ( buf , sizeof ( buf ) , filename , dec_ctx -> frame_number ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> pgm_save ( frame -> data [ 0 ] , frame -> linesize [ 0 ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> frame -> width , frame -> height , buf ) ; <NEW_LINE> <TAB> }
#define __get_user_asm_ex ( x , addr , itype , rtype , ltype ) <TAB> <TAB> <TAB> \ <NEW_LINE> <TAB> asm volatile ( "1 : <TAB> mov"itype" % 1 , % "rtype"0\n" <TAB> <TAB> \ <NEW_LINE> <TAB> <TAB> "2 : \n" <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <START_VULN> <TAB> <TAB> _ASM_EXTABLE_EX ( 1b , 2b ) <TAB> <TAB> <TAB> <TAB> \ <NEW_LINE> <END_VULN> <TAB> <TAB> : ltype ( x ) : "m" ( __m ( addr ) ) ) <NEW_LINE> #define __put_user_nocheck ( x , ptr , size ) <TAB> <TAB> <TAB> \
<TAB> <TAB> <TAB> <TAB> eprintf ( "Warning : malformed dwarf attribute capacity doesn't match length\n" ) ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> break ; <NEW_LINE> <TAB> <TAB> <TAB> } <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> memset ( & cu -> dies [ cu -> length ] . attr_values [ i ] , 0 , sizeof <NEW_LINE><TAB> <TAB> <TAB> <TAB> <TAB> ( cu -> dies [ cu -> length ] . attr_values [ i ] ) ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> buf = r_bin_dwarf_parse_attr_value ( buf , buf_end - buf , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> & da -> decls [ abbr_code - 1 ] . specs [ i ] , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> & cu -> dies [ cu -> length ] . attr_values [ i ] ,
<START_VULN> <TAB> if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) ) <NEW_LINE> <END_VULN> <TAB> <TAB> return false ; <NEW_LINE> <TAB> for ( x = 0 ; x < x_size ; + + x ) { <NEW_LINE> <TAB> <TAB> for ( y = 0 ; y < y_size ; + + y ) {
<TAB> <TAB> <TAB> for ( conn_opt = conn_opts ; conn_opt -> keyword != NULL ; conn_opt + + ) <NEW_LINE> <TAB> <TAB> <TAB> { <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' ) <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> <TAB> { <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> keywords [ i ] = conn_opt -> keyword ; <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> values [ i ] = conn_opt -> val ;
<TAB> if ( ! has_header ( s -> headers , "\r\nRange : " ) && ! post && ( s -> off > 0 || s -> end_off || s -> seekable == - 1 ) ) { <NEW_LINE> <TAB> <TAB> len += av_strlcatf ( headers + len , sizeof ( headers ) - len , <NEW_LINE> <START_VULN> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> "Range : bytes = % "PRId64" - " , s -> off ) ; <NEW_LINE> <END_VULN> <TAB> <TAB> if ( s -> end_off ) <NEW_LINE> <TAB> <TAB> <TAB> len += av_strlcatf ( headers + len , sizeof ( headers ) - len , <NEW_LINE> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> " % "PRId64 , s -> end_off - 1 ) ;
<TAB> * rv = NS_ERROR_XPC_BAD_CONVERT_JS ; <NEW_LINE> <TAB> if ( ! native ) <NEW_LINE> <TAB> <TAB> return nsnull ; <NEW_LINE> <TAB> NS_ASSERTION ( IS_WRAPPER_CLASS ( js : : GetObjectClass ( cur ) ) , "Not a wrapper ? " ) ; <NEW_LINE> <START_VULN> <TAB> XPCNativeScriptableSharedJSClass * clasp = <NEW_LINE><TAB> ( XPCNativeScriptableSharedJSClass * ) js : : GetObjectClass ( cur ) ; <NEW_LINE> <END_VULN> <TAB> if ( ! ( clasp -> interfacesBitmap & ( 1 << interfaceBit ) ) ) <NEW_LINE> <TAB> <TAB> return nsnull ; <NEW_LINE> <TAB> * pRef = nsnull ; <NEW_LINE> <TAB> * pVal = OBJECT_TO_JSVAL ( cur ) ; <NEW_LINE> <TAB> if ( lccx ) { <NEW_LINE> <TAB> <TAB> if ( wrapper )
<TAB> } else { <NEW_LINE> <TAB> <TAB> int plane ; <NEW_LINE> <START_VULN> <TAB> <TAB> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane + + ) { <NEW_LINE> <END_VULN> <TAB> <TAB> <TAB> uint8_t * dst = out -> data [ plane ] ; <NEW_LINE> <TAB> <TAB> <TAB> const uint8_t * src = in -> data [ plane ] ; <NEW_LINE> <TAB> <TAB> <TAB> const float * fmap = s -> fmap ;
if ( length > row_size + 256 ) <NEW_LINE> <TAB> { <NEW_LINE> <TAB> pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; <NEW_LINE> <START_VULN> <TAB> ThrowBinaryException ( ResourceLimitError , "InvalidLength" , <NEW_LINE><TAB> <TAB> image -> filename ) ; <NEW_LINE> <END_VULN> <TAB> } <NEW_LINE> compact_pixels = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * pixels ) ) ;
HDC mMemoryDC ; <NEW_LINE> nsTransparencyMode mTransparencyMode ; <NEW_LINE> #endif <NEW_LINE> PRPackedBool mIsTopWidgetWindow ; <NEW_LINE> PRPackedBool mHas3DBorder ; <NEW_LINE> PRPackedBool mIsShiftDown ; <NEW_LINE> PRPackedBool mIsControlDown ; <NEW_LINE> PRPackedBool mIsAltDown ; <NEW_LINE> <START_VULN> PRPackedBool mIsDestroying ; <NEW_LINE> <END_VULN> PRPackedBool mIsVisible ; <NEW_LINE> PRPackedBool mIsInMouseCapture ; <NEW_LINE> PRPackedBool mIsInMouseWheelProcessing ; <NEW_LINE> PRPackedBool mUnicodeWidget ; <NEW_LINE> PRPackedBool mIsPluginWindow ; <NEW_LINE> PRPackedBool mPainting ; <NEW_LINE> char mLeadByte ;
<TAB> RBinInfo * info = binobj ? binobj -> info : NULL ; <NEW_LINE> <TAB> if ( info ) { <NEW_LINE> <TAB> <TAB> int va = info -> has_va ; <NEW_LINE> <START_VULN> <TAB> <TAB> const char * arch = info -> arch ; <NEW_LINE> <END_VULN> <TAB> <TAB> ut16 bits = info -> bits ; <NEW_LINE> <TAB> <TAB> ut64 baseaddr = r_bin_get_baddr ( r -> bin ) ;
<TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> & _vq_book_res0a_13 , NULL } ; <NEW_LINE> float * testvec [ ] = { test1 , test3 } ; <NEW_LINE> int main ( ) { <NEW_LINE> oggpack_buffer write ; <NEW_LINE> oggpack_buffer read ; <NEW_LINE> long ptr = 0 , i ; <NEW_LINE> oggpack_writeinit ( & write ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> fprintf ( stderr , "Testing codebook abstraction . . . : \n" ) ; <NEW_LINE> while ( testlist [ ptr ] ) { <NEW_LINE> <TAB> codebook c ; <NEW_LINE> <TAB> static_codebook s ; <NEW_LINE> <TAB> float * qv = alloca ( sizeof ( * qv ) * TESTSIZE ) ; <NEW_LINE> <TAB> float * iv = alloca ( sizeof ( * iv ) * TESTSIZE ) ; <NEW_LINE> <TAB> memcpy ( qv , testvec [ ptr ] , sizeof ( * qv ) * TESTSIZE ) ;
