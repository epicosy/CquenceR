} <NEW_LINE> #endif <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN>
void SetBrowserOnly ( bool browser_only ) ; <NEW_LINE> void AddHandler ( std::unique_ptr < protocol::DevToolsDomainHandler > handler ) ; <NEW_LINE> <START_VULN> <NEW_LINE>void SetRenderer ( RenderProcessHost * process_host , <NEW_LINE>RenderFrameHostImpl * frame_host ) ; <NEW_LINE> <END_VULN> void AttachToAgent ( const blink::mojom::DevToolsAgentAssociatedPtr & agent ) ; <NEW_LINE> void DispatchProtocolMessage ( const std::string & message ) ;
JSClass * clasp = parentProto ? & sMainRuntimeClass : & sClass ; <NEW_LINE> JSObject * proto = JS_InitClass ( aCx , aObj , parentProto , clasp , Construct , 0 , <NEW_LINE> <START_VULN> sProperties , sFunctions , sStaticProperties , <NEW_LINE>NULL ) ; <NEW_LINE>if ( proto && ! JS_DefineProperties ( aCx , proto , sStaticProperties ) ) { <NEW_LINE> <END_VULN> return NULL ; <NEW_LINE> }
} <NEW_LINE> <START_VULN> static void <NEW_LINE> <END_VULN> vpx_usec_timer_mark ( struct vpx_usec_timer * t ) { <NEW_LINE> #if defined ( _WIN32 ) <NEW_LINE> QueryPerformanceCounter ( & t -> end ) ;
nsDocumentEncoder::FlushText ( nsAString & aString , bool aForce ) <NEW_LINE> { <NEW_LINE> if ( ! mStream ) <NEW_LINE> return NS_OK ; <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> if ( aString . Length ( ) > 1024 || aForce ) { <NEW_LINE> <START_VULN> rv = ConvertAndWrite ( aString , mStream , mUnicodeEncoder ) ; <NEW_LINE><NEW_LINE> <END_VULN> aString . Truncate ( ) ; <NEW_LINE> } <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> #if 0
if ( ( which & FPM_CLEANUP_CHILD ) == 0 && fpm_globals . parent_pid == getpid ( ) ) { <NEW_LINE> fpm_scoreboard_free ( wp -> scoreboard ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> free ( wp -> config ) ; <NEW_LINE>free ( wp -> user ) ; <NEW_LINE>free ( wp -> home ) ; <NEW_LINE>free ( wp ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> fpm_worker_all_pools = NULL ; <NEW_LINE> }
bestsad = vfp -> sdf ( what -> buf , what -> stride , <NEW_LINE> <START_VULN> get_buf_from_mv ( in_what , ref_mv ) , in_what -> stride , <NEW_LINE>0x7fffffff ) + mvsad_err_cost ( ref_mv , & fcenter_mv , <NEW_LINE>mvjsadcost , mvsadcost , sad_per_bit ) ; <NEW_LINE> <END_VULN>
return static_cast < nsPluginArray * > ( aSupports ) ; <NEW_LINE> } <NEW_LINE> private: <NEW_LINE> nsresult GetPlugins ( ) ; <NEW_LINE> PRBool AllowPlugins ( ) ; <NEW_LINE> public: <NEW_LINE> <START_VULN> void SetDocShell ( nsIDocShell * aDocShell ) ; <NEW_LINE> <END_VULN> protected: <NEW_LINE> nsNavigator * mNavigator ; <NEW_LINE> nsCOMPtr < nsIPluginHost > mPluginHost ; <NEW_LINE> PRUint32 mPluginCount ; <NEW_LINE> nsIDOMPlugin ** mPluginArray ; <NEW_LINE> nsIDocShell * mDocShell ; <NEW_LINE> } ;
virtual void SetPickledData ( const OSExchangeData::CustomFormat & format , <NEW_LINE> const Pickle & data ) OVERRIDE ; <NEW_LINE> virtual bool GetString ( base::string16 * data ) const OVERRIDE ; <NEW_LINE> <START_VULN> virtual bool GetURLAndTitle ( GURL * url , base::string16 * title ) const OVERRIDE ; <NEW_LINE> <END_VULN> virtual bool GetFilename ( base::FilePath * path ) const OVERRIDE ; <NEW_LINE> virtual bool GetFilenames ( <NEW_LINE> std::vector < OSExchangeData::FileInfo > * filenames ) const OVERRIDE ;
} <NEW_LINE> else <NEW_LINE> <START_VULN> s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len <NEW_LINE> <END_VULN> && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0 ; <NEW_LINE> break ;
jumbo -> ip6j_len = ip6_optlen ; <NEW_LINE> if ( ip6_optlen < sizeof ( jumbo -> ip6j_payload_len ) ) { <NEW_LINE> <START_VULN> ENGINE_SET_EVENT ( p , IPV6_EXTHDR_INVALID_OPTLEN ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> }
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . methodReturningSequence" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( int , intArg , toInt32 ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> return v8Array ( imp -> methodReturningSequence ( intArg ) , args . GetIsolate ( ) ) ;
if ( useFileSocket ) { <NEW_LINE> sock_addr . setFromPath ( address ) ; <NEW_LINE> } else if ( address . empty ( ) ) { <NEW_LINE> <START_VULN> sock_addr . setFromLocalPort ( port ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> sock_addr . setFromHostPort ( address , port ) ; <NEW_LINE> }
<START_VULN> <NEW_LINE> <END_VULN> * above_y |= above_prediction_mask [ block_size ] << shift_y ; <NEW_LINE> * above_uv |= above_prediction_mask_uv [ block_size ] << shift_uv ;
BTIF_TRACE_DEBUG ( "set curr_set = org_set " ) ; <NEW_LINE> curr_set = org_set ; <NEW_LINE> max_curr_s = max_org_s ; <NEW_LINE> <START_VULN> int ret = select ( ( max_curr_s + 1 ) , & curr_set , NULL , NULL , NULL ) ; <NEW_LINE> <END_VULN> BTIF_TRACE_DEBUG ( "select unblocked ret = % d" , ret ) ; <NEW_LINE> if ( ret == - 1 ) <NEW_LINE> {
m_vectorLength = newLength ; <NEW_LINE> fastFree ( storage -> m_allocBase ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> Heap::heap ( this ) -> reportExtraMemoryCost ( storageSize ( newVectorLength ) - storageSize ( vectorLength ) ) ; <NEW_LINE> return true ;
} <NEW_LINE> <START_VULN> for ( pass = HID_PASS + 1 ; pass < nb_guids ; pass ++ ) { <NEW_LINE> <END_VULN> safe_free ( guid [ pass ] ) ; <NEW_LINE> }
} else if ( Bignum * bignum = try_as < Bignum > ( this ) ) { <NEW_LINE> return bignum -> hash_bignum ( state ) ; <NEW_LINE> } else if ( Float * flt = try_as < Float > ( this ) ) { <NEW_LINE> <START_VULN> return String::hash_str ( ( unsigned char * ) ( & ( flt -> val ) ) , sizeof ( double ) ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> return id ( state ) -> to_native ( ) ; <NEW_LINE> }
fault = handle_mm_fault ( mm , vma , address , write ? FAULT_FLAG_WRITE : 0 ) ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <NEW_LINE> <END_VULN> if ( unlikely ( fault & VM_FAULT_ERROR ) ) { <NEW_LINE> if ( fault & VM_FAULT_OOM ) <NEW_LINE> goto out_of_memory ;
{ <NEW_LINE> } <NEW_LINE> NS_IMETHOD Run ( ) <NEW_LINE> { <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> JSContext * cx = mContext ? mContext -> GetNativeContext ( ) <NEW_LINE> : nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE> <START_VULN> pusher . Push ( cx , nsCxPusher::ALWAYS_PUSH ) ; <NEW_LINE> <END_VULN> JSObject * obj = nullptr ; <NEW_LINE> mWrapper -> GetJSObject ( & obj ) ; <NEW_LINE> NS_ASSERTION ( obj , "Should never be null" ) ; <NEW_LINE> nsHTMLPluginObjElementSH::SetupProtoChain ( mWrapper , cx , obj ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
<START_VULN> <NEW_LINE>nsDOMDataTransfer ( uint32_t aEventType , bool aIsExternal ) ; <NEW_LINE> <END_VULN> void GetDragTarget ( nsIDOMElement ** aDragTarget ) <NEW_LINE> { <NEW_LINE> * aDragTarget = mDragTarget ; <NEW_LINE> NS_IF_ADDREF ( * aDragTarget ) ; <NEW_LINE> }
notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <NEW_LINE> <START_VULN> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <NEW_LINE> <END_VULN> log_message ( LOG_INFO , "Unable to open % snotify fifo % s - errno % d" , type , fifo -> name , errno ) ; <NEW_LINE> if ( fifo -> created_fifo ) { <NEW_LINE> unlink ( fifo -> name ) ;
memset ( data_s , 0 , data_size ) ; <NEW_LINE> memcpy ( data_s , data , data_len ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> mdecrypt_generic ( pm -> td , data_s , data_size ) ; <NEW_LINE> RETVAL_STRINGL ( data_s , data_size , 1 ) ;
<START_VULN> if ( startedFromUnelevatedUpdater ) { <NEW_LINE> <END_VULN> UACHelper::DisablePrivileges ( nullptr ) ;
const char * n ; <NEW_LINE> pdf_t * pdf ; <NEW_LINE> <START_VULN> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <NEW_LINE> <END_VULN> if ( name ) <NEW_LINE> {
} <NEW_LINE> if ( interlace_type == PNG_INTERLACE_ADAM7 ) { <NEW_LINE> <START_VULN> decoder -> interlacebuf = ( PRUint8 * ) nsMemory::Alloc ( channels * width * height ) ; <NEW_LINE> <END_VULN> if ( ! decoder -> interlacebuf ) { <NEW_LINE> longjmp ( decoder -> mPNG -> jmpbuf , 5 ) ; <NEW_LINE> }
#if defined ( MSDOS ) || defined ( WIN32 ) <NEW_LINE> <START_VULN> char * sanitize_dos_name ( char * file_name ) ; <NEW_LINE> <END_VULN> #if defined ( MSDOS ) && ( defined ( __DJGPP__ ) || defined ( __GO32__ ) )
yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != ' ; ' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 584 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> * p = YYCURSOR ; <NEW_LINE> INIT_PZVAL ( * rval ) ;
static void down2_symodd ( const uint8_t * const input , int length , <NEW_LINE> uint8_t * output ) { <NEW_LINE> <START_VULN> static const int16_t * filter = vp9_down2_symodd_half_filter ; <NEW_LINE> <END_VULN> const int filter_len_half = sizeof ( vp9_down2_symodd_half_filter ) / 2 ; <NEW_LINE> int i , j ; <NEW_LINE> uint8_t * optr = output ;
AutoContextPusher ( JSContext * cx <NEW_LINE> MOZ_GUARD_OBJECT_NOTIFIER_PARAM ) <NEW_LINE> : mRequest ( cx ) <NEW_LINE> , mContext ( cx ) <NEW_LINE> , mSavedOptions ( JS_SetOptions ( cx , ( JS_GetOptions ( cx ) | <NEW_LINE> JSOPTION_DONT_REPORT_UNCAUGHT ) ) ) <NEW_LINE> { <NEW_LINE> MOZ_GUARD_OBJECT_NOTIFIER_INIT ; <NEW_LINE> <START_VULN> mStack . Push ( cx , nsCxPusher::ALWAYS_PUSH ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> ~ AutoContextPusher ( ) { <NEW_LINE> mStack . Pop ( ) ; <NEW_LINE> JS_SetOptions ( mContext , mSavedOptions ) ; <NEW_LINE> } <NEW_LINE> } ;
image -> rows * sizeof ( * runlength ) ) ; <NEW_LINE> if ( runlength == ( unsigned char * ) NULL ) <NEW_LINE> ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> <START_VULN> buffer = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * buffer ) ) ; <NEW_LINE> <END_VULN> if ( buffer == ( unsigned char * ) NULL ) <NEW_LINE> ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <NEW_LINE> packet_size = ( size_t ) ( image -> depth > 8 ? 2: 1 ) ;
#endif <NEW_LINE> #ifdef MOZ_WIDGET_ANDROID <NEW_LINE> { <NEW_LINE> nsIFocusManager * fm = nsFocusManager::GetFocusManager ( ) ; <NEW_LINE> if ( fm ) { <NEW_LINE> <START_VULN> nsCOMPtr < nsIDOMElement > elem = do_QueryInterface ( mContent ) ; <NEW_LINE> <END_VULN> fm -> SetFocus ( elem , 0 ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> switch ( anEvent . eventStructType ) <NEW_LINE> { <NEW_LINE> case NS_MOUSE_EVENT: <NEW_LINE> { <NEW_LINE> switch ( anEvent . message )
<START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN>
if ( memcmp ( & lpddi -> guidInstance , & self -> mGamepads [ i ] . guidInstance , <NEW_LINE> sizeof ( GUID ) ) == 0 ) { <NEW_LINE> self -> mGamepads [ i ] . present = true ; <NEW_LINE> return DIENUM_CONTINUE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> Gamepad gamepad ; <NEW_LINE>memset ( & gamepad , 0 , sizeof ( Gamepad ) ) ; <NEW_LINE> <END_VULN> if ( self -> dinput -> CreateDevice ( lpddi -> guidInstance , <NEW_LINE> getter_AddRefs ( gamepad . device ) , <NEW_LINE> nullptr ) <NEW_LINE> == DI_OK ) { <NEW_LINE> gamepad . present = true ; <NEW_LINE> memcpy ( & gamepad . guidInstance , & lpddi -> guidInstance , sizeof ( GUID ) ) ; <NEW_LINE> DIDEVICEINSTANCE info ;
case 's': disableLocking = PR_TRUE ; break ; <NEW_LINE> case 't': <NEW_LINE> maxThreads = PORT_Atoi ( optstate -> value ) ; <NEW_LINE> if ( maxThreads > MAX_THREADS ) maxThreads = MAX_THREADS ; <NEW_LINE> if ( maxThreads < MIN_THREADS ) maxThreads = MIN_THREADS ; <NEW_LINE> break ; <NEW_LINE> <START_VULN> case 'u': enableSessionTickets = PR_TRUE ; break ; <NEW_LINE> <END_VULN> case 'v': verbose ++ ; break ; <NEW_LINE> case 'w': <NEW_LINE> pwdata . source = PW_PLAINTEXT ; <NEW_LINE> pwdata . data = passwd = PORT_Strdup ( optstate -> value ) ; <NEW_LINE> break ;
int in_opaque ; <NEW_LINE> int is_palette ; <NEW_LINE> int accumulate ; <NEW_LINE> <START_VULN> int output_8bit ; <NEW_LINE> <END_VULN> void ( * in_gp ) ( Pixel * , png_const_voidp ) ; <NEW_LINE> void ( * out_gp ) ( Pixel * , png_const_voidp ) ;
const uint32_t aLimit ) <NEW_LINE> : ObjectStoreHelper ( aTransaction , aRequest , aObjectStore ) , <NEW_LINE> mKeyRange ( aKeyRange ) , mLimit ( aLimit ) <NEW_LINE> { } <NEW_LINE> ~ GetAllHelper ( ) <NEW_LINE> { <NEW_LINE> for ( uint32_t index = 0 ; index < mCloneReadInfos . Length ( ) ; index ++ ) { <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( <NEW_LINE>mCloneReadInfos [ index ] . mCloneBuffer ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> virtual nsresult DoDatabaseWork ( mozIStorageConnection * aConnection ) <NEW_LINE> MOZ_OVERRIDE ; <NEW_LINE> virtual nsresult GetSuccessResult ( JSContext * aCx , <NEW_LINE> jsval * aVal ) MOZ_OVERRIDE ;
void InitContentSecurityPolicy ( <NEW_LINE> ContentSecurityPolicy * = nullptr , <NEW_LINE> <START_VULN> const ContentSecurityPolicy * policy_to_inherit = nullptr ) ; <NEW_LINE> <END_VULN> bool IsSecureTransitionTo ( const KURL & ) const ;
php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Missing y position" ) ; <NEW_LINE> RETURN_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( type == GD_AFFINE_TRANSLATE ) { <NEW_LINE> res = gdAffineTranslate ( affine , x , y ) ; <NEW_LINE> } else {
if ( unlikely ( cork -> opt == NULL ) ) <NEW_LINE> return - ENOBUFS ; <NEW_LINE> } <NEW_LINE> <START_VULN> memcpy ( cork -> opt , opt , sizeof ( struct ip_options ) + opt -> optlen ) ; <NEW_LINE> <END_VULN> cork -> flags |= IPCORK_OPT ; <NEW_LINE> cork -> addr = ipc -> addr ; <NEW_LINE> }
#define BT_SHB 0x0A0D0D0A <NEW_LINE> <START_VULN> #define BT_SHB_INSANE_MAX 1024 * 1024 * 1 <NEW_LINE> <END_VULN> struct section_header_block { <NEW_LINE> bpf_u_int32 byte_order_magic ; <NEW_LINE> u_short major_version ;
DEBUG ( "emulate a2dp write delay ( % d us ) " , us_delay ) ; <NEW_LINE> <START_VULN> usleep ( us_delay ) ; <NEW_LINE> <END_VULN> pthread_mutex_unlock ( & out -> common . lock ) ; <NEW_LINE> return - 1 ; <NEW_LINE> }
nsXMLHttpRequest::GetInterface ( JSContext * aCx , nsIJSID * aIID , ErrorResult & aRv ) <NEW_LINE> { <NEW_LINE> const nsID * iid = aIID -> GetID ( ) ; <NEW_LINE> nsCOMPtr < nsISupports > result ; <NEW_LINE> JS::Value v = JSVAL_NULL ; <NEW_LINE> aRv = GetInterface ( * iid , getter_AddRefs ( result ) ) ; <NEW_LINE> NS_ENSURE_FALSE ( aRv . Failed ( ) , JSVAL_NULL ) ; <NEW_LINE> <START_VULN> JSObject * global = JS_GetGlobalForObject ( aCx , GetWrapper ( ) ) ; <NEW_LINE> <END_VULN> aRv = nsContentUtils::WrapNative ( aCx , global , result , iid , & v ) ; <NEW_LINE> return aRv . Failed ( ) ? JSVAL_NULL : v ; <NEW_LINE> } <NEW_LINE> nsXMLHttpRequestUpload * <NEW_LINE> nsXMLHttpRequest::Upload ( ) <NEW_LINE> { <NEW_LINE> if ( ! mUpload ) {
} <NEW_LINE> void vp9_end_first_pass ( VP9_COMP * cpi ) { <NEW_LINE> <START_VULN> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { <NEW_LINE> <END_VULN> int i ; <NEW_LINE> for ( i = 0 ; i < cpi -> svc . number_spatial_layers ; ++ i ) { <NEW_LINE> output_stats ( & cpi -> svc . layer_context [ i ] . twopass . total_stats ,
return false ; <NEW_LINE> } <NEW_LINE> if ( ! forward . isNull ( ) ) { <NEW_LINE> <START_VULN> m . setForwardedFrom ( Jid ( from ) ) ; <NEW_LINE> <END_VULN> m . setCarbonDirection ( cd ) ; <NEW_LINE> }
} <NEW_LINE> if ( drop_it || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { <NEW_LINE> int size = 0 ; <NEW_LINE> <START_VULN> if ( drop_it || ioctl ( sock -> our_fd , FIONREAD , & size ) != 0 || size == 0 ) <NEW_LINE> <END_VULN> btsock_l2cap_free_l ( sock ) ; <NEW_LINE> } <NEW_LINE> }
if ( TRC -> count == 0 ) { <NEW_LINE> compute_curve_gamma_table_type0 ( gamma_table ) ; <NEW_LINE> } else if ( TRC -> count == 1 ) { <NEW_LINE> <START_VULN> compute_curve_gamma_table_type1 ( gamma_table , u8Fixed8Number_to_float ( TRC -> data [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> compute_curve_gamma_table_type2 ( gamma_table , TRC -> data , TRC -> count ) ; <NEW_LINE> }
return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 1143 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy76: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych == 'N' ) goto yy73 ;
if ( sock -> connected ) { <NEW_LINE> int size = 0 ; <NEW_LINE> <START_VULN> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( sock -> our_fd , FIONREAD , & size ) <NEW_LINE> <END_VULN> == 0 && size ) ) { <NEW_LINE> uint8_t * buffer = osi_malloc ( L2CAP_MAX_SDU_LENGTH ) ;
ListBase < LC > ::finalize ( JSContext * cx , JSObject * proxy ) <NEW_LINE> { <NEW_LINE> ListType * list = getListObject ( proxy ) ; <NEW_LINE> nsWrapperCache * cache ; <NEW_LINE> CallQueryInterface ( list , & cache ) ; <NEW_LINE> if ( cache ) { <NEW_LINE> cache -> ClearWrapper ( ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> NS_RELEASE ( list ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> JSObject * <NEW_LINE> NoBase::getPrototype ( JSContext * cx , XPCWrappedNativeScope * scope ) <NEW_LINE> {
PLArenaPool * <NEW_LINE> PORT_NewArena ( unsigned long chunksize ) <NEW_LINE> { <NEW_LINE> PORTArenaPool * pool ; <NEW_LINE> pool = PORT_ZNew ( PORTArenaPool ) ; <NEW_LINE> if ( ! pool ) { <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> pool -> magic = ARENAPOOL_MAGIC ; <NEW_LINE> pool -> lock = PZ_NewLock ( nssILockArena ) ; <NEW_LINE> if ( ! pool -> lock ) { <NEW_LINE> ++ port_allocFailures ; <NEW_LINE> PORT_Free ( pool ) ; <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> PL_InitArenaPool ( & pool -> arena , "security" , chunksize , sizeof ( double ) ) ; <NEW_LINE> return ( & pool -> arena ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #define MAX_SIZE 0x7fffffffUL <NEW_LINE><NEW_LINE> <END_VULN> void * <NEW_LINE> PORT_ArenaAlloc ( PLArenaPool * arena , size_t size ) <NEW_LINE> { <NEW_LINE> void * p = NULL ; <NEW_LINE> PORTArenaPool * pool = ( PORTArenaPool * ) arena ; <NEW_LINE> if ( size <= 0 ) {
} <NEW_LINE> and 40 , replicate the 100dB curve to 110 * / <NEW_LINE> for ( j = 0 ; j < 6 ; j ++ ) <NEW_LINE> memcpy ( workc [ i ] [ j + 2 ] , tonemasks [ i ] [ j ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ j ] ) ) ; <NEW_LINE> memcpy ( workc [ i ] [ 0 ] , tonemasks [ i ] [ 0 ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ 0 ] ) ) ; <NEW_LINE> memcpy ( workc [ i ] [ 1 ] , tonemasks [ i ] [ 0 ] , EHMER_MAX * sizeof ( * tonemasks [ i ] [ 0 ] ) ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> for ( j = 0 ; j < P_LEVELS ; j ++ ) { <NEW_LINE> for ( k = 0 ; k < EHMER_MAX ; k ++ ) { <NEW_LINE> float adj = center_boost + abs ( EHMER_OFFSET - k ) * center_decay_rate ; <NEW_LINE> if ( adj < 0 . && center_boost > 0 ) adj = 0 . ; <NEW_LINE> if ( adj
ServerKit::HeaderTable::Iterator it ( req -> headers ) ; <NEW_LINE> while ( * it != NULL ) { <NEW_LINE> <START_VULN> if ( ( it -> header -> hash == HTTP_CONTENT_LENGTH . hash ( ) <NEW_LINE> || it -> header -> hash == HTTP_CONTENT_TYPE . hash ( ) <NEW_LINE> || it -> header -> hash == HTTP_CONNECTION . hash ( ) ) <NEW_LINE> && ( psg_lstr_cmp ( & it -> header -> key , P_STATIC_STRING ( "content - type" ) ) <NEW_LINE> || psg_lstr_cmp ( & it -> header -> key , P_STATIC_STRING ( "content - length" ) ) <NEW_LINE> || psg_lstr_cmp ( & it -> header -> key , P_STATIC_STRING ( "connection" ) ) ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> it . next ( ) ; <NEW_LINE> continue ;
namespace WebCore { <NEW_LINE> <START_VULN> WebGLObject::WebGLObject ( WebGLRenderingContext * context ) <NEW_LINE> <END_VULN> : m_object ( 0 ) <NEW_LINE> , m_attachmentCount ( 0 ) <NEW_LINE> , m_deleted ( false )
for ( i = 0 ; i < olen ; i ++ ) { <NEW_LINE> b = i / elements ; <NEW_LINE> x = i % elements + start [ 0 ] ; <NEW_LINE> <START_VULN> if ( x < sx ) { <NEW_LINE>j = x * size + b ; <NEW_LINE> <END_VULN> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <NEW_LINE> } <NEW_LINE> }
<START_VULN> struct MailboxName { <NEW_LINE> <END_VULN> GLbyte key [ GL_MAILBOX_SIZE_CHROMIUM / 2 ] ; <NEW_LINE> GLbyte signature [ GL_MAILBOX_SIZE_CHROMIUM / 2 ] ; <NEW_LINE> } ;
static_cast < ContentTypeType > ( msg . type ) ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! msg . fragment ) { <NEW_LINE> <END_VULN> if ( msg . type == ContentType::application_data ) { <NEW_LINE> msg . fragment = folly::IOBuf::create ( 0 ) ; <NEW_LINE> } else {
bool * base64_encoded ) ; <NEW_LINE> static String ResourceTypeJson ( ResourceType ) ; <NEW_LINE> <START_VULN> static ResourceType CachedResourceType ( const Resource & ) ; <NEW_LINE> <END_VULN> static String CachedResourceTypeJson ( const Resource & ) ;
NS_PRECONDITION ( mActionNesting > 0 , "bad action nesting ! " ) ; <NEW_LINE> nsresult res = NS_OK ; <NEW_LINE> if ( ! -- mActionNesting ) <NEW_LINE> { <NEW_LINE> res = AfterEditInner ( action , aDirection ) ; <NEW_LINE> <START_VULN> ( mHTMLEditor -> mRangeUpdater ) . DropRangeItem ( & mRangeItem ) ; <NEW_LINE> <END_VULN> if ( mRestoreContentEditableCount ) { <NEW_LINE> nsCOMPtr < nsIDOMDocument > doc ; <NEW_LINE> res = mHTMLEditor -> GetDocument ( getter_AddRefs ( doc ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( res , res ) ; <NEW_LINE> nsCOMPtr < nsIHTMLDocument > htmlDoc = do_QueryInterface ( doc ) ; <NEW_LINE> NS_ENSURE_TRUE ( htmlDoc , NS_ERROR_FAILURE ) ;
struct ssl_connect_data * connssl = ( struct ssl_connect_data * ) arg ; <NEW_LINE> struct Curl_easy * data = connssl -> data ; <NEW_LINE> const char * nickname = connssl -> client_nickname ; <NEW_LINE> if ( connssl -> obj_clicert ) { <NEW_LINE> <START_VULN> static const char pem_slotname [ ] = "PEM Token #1" ; <NEW_LINE> <END_VULN> SECItem cert_der = { 0 , NULL , 0 } ; <NEW_LINE> void * proto_win = SSL_RevealPinArg ( sock ) ; <NEW_LINE> struct CERTCertificateStr * cert ;
newserv -> server [ l ] = '\0' ; <NEW_LINE> p += l ; <NEW_LINE> DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <NEW_LINE> <START_VULN> if ( p + l > buf + n ) { <NEW_LINE> <END_VULN> syslog ( LOG_WARNING , "bad request ( length encoding ) " ) ; <NEW_LINE> goto error ; <NEW_LINE> }
#include "ui / views / controls / button / button . h" <NEW_LINE> #include "ui / views / controls / link_listener . h" <NEW_LINE> #include "ui / views / controls / separator . h" <NEW_LINE> <START_VULN> #include "ui / views / controls / styled_label . h" <NEW_LINE> <END_VULN> #include "ui / views / controls / styled_label_listener . h" <NEW_LINE> #include "ui / views / widget / widget . h" <NEW_LINE> class BubbleHeaderView ; <NEW_LINE> class GURL ; <NEW_LINE> class Profile ; <NEW_LINE> namespace content {
NS_ADDREF ( * aDocListener = mStreamListener ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsPluginDocument::CreateSyntheticPluginDocument ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>nsCOMPtr < nsIDocShellTreeItem > dsti ( do_QueryReferent ( mDocumentContainer ) ) ; <NEW_LINE>if ( dsti ) { <NEW_LINE>PRBool isMsgPane = PR_FALSE ; <NEW_LINE>dsti -> NameEquals ( NS_LITERAL_STRING ( "messagepane" ) . get ( ) , & isMsgPane ) ; <NEW_LINE>if ( isMsgPane ) { <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <END_VULN> nsresult rv = nsMediaDocument::CreateSyntheticDocument ( ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsIContent * body = GetBodyContent ( ) ; <NEW_LINE> if ( ! body ) {
} <NEW_LINE> <START_VULN> for ( i = 0 ; i < ( height ) ; i ++ ) <NEW_LINE> <END_VULN> row_pointers [ i ] = png_pixels + i * row_bytes ;
void vp9_init_second_pass_spatial_svc ( struct VP9_COMP * cpi ) ; <NEW_LINE> <START_VULN> void vp9_inc_frame_in_layer ( SVC * svc ) ; <NEW_LINE> <END_VULN> #ifdef __cplusplus <NEW_LINE> }
int reg = ( instr >> 12 ) & 15 ; <NEW_LINE> if ( reg == 15 ) <NEW_LINE> return 1 ; <NEW_LINE> <START_VULN> regs -> uregs [ reg ] = current_thread_info ( ) -> tp_value ; <NEW_LINE> <END_VULN> regs -> ARM_pc += 4 ; <NEW_LINE> return 0 ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> do { <NEW_LINE> <START_VULN> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <NEW_LINE> <END_VULN> if ( setup_ret == 0 ) { <NEW_LINE> goto _end ; <NEW_LINE> }
static void <NEW_LINE> process_add_smartcard_key ( SocketEntry * e ) <NEW_LINE> { <NEW_LINE> <START_VULN> char * provider = NULL , * pin ; <NEW_LINE> <END_VULN> int r , i , version , count = 0 , success = 0 , confirm = 0 ; <NEW_LINE> u_int seconds ; <NEW_LINE> time_t death = 0 ;
bool intra_only ; <NEW_LINE> uint8_t reset_context ; <NEW_LINE> <START_VULN> uint8_t refresh_flags ; <NEW_LINE> <END_VULN> uint8_t frame_refs [ kVp9NumRefsPerFrame ] ; <NEW_LINE> bool ref_sign_biases [ kVp9NumRefsPerFrame ] ; <NEW_LINE> bool allow_high_precision_mv ;
<START_VULN> mSpec . SetLength ( approxLen + 32 ) ; <NEW_LINE> <END_VULN> char * buf ; <NEW_LINE> mSpec . BeginWriting ( buf ) ; <NEW_LINE> PRUint32 i = 0 ;
uint32 colb = 0 ; <NEW_LINE> uint32 col ; <NEW_LINE> <START_VULN> for ( col = 0 ; col < imagewidth ; col += tw ) { <NEW_LINE> <END_VULN> if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 <NEW_LINE> && ! ignore ) { <NEW_LINE> TIFFError ( TIFFFileName ( in ) ,
} <NEW_LINE> void * sk_malloc_flags ( size_t size , unsigned flags ) { <NEW_LINE> <START_VULN> void * p = malloc ( size ) ; <NEW_LINE> <END_VULN> if ( flags & SK_MALLOC_THROW ) { <NEW_LINE> return throw_on_failure ( size , p ) ; <NEW_LINE> } else {
virtual void FillFrame ( ) { <NEW_LINE> <START_VULN> if ( frame_ % 30 < 15 ) <NEW_LINE>for ( size_t i = 0 ; i < raw_sz_ ; ++ i ) <NEW_LINE>img_ -> img_data [ i ] = rnd_ . Rand8 ( ) ; <NEW_LINE>else <NEW_LINE>memset ( img_ -> img_data , 0 , raw_sz_ ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> ACMRandom rnd_ ;
} ; <NEW_LINE> <START_VULN> if ( colorspace -> flags & PNG_COLORSPACE_INVALID ) <NEW_LINE> <END_VULN> return 0 ;
private: <NEW_LINE> static bool StoreRegisters ( int64_t store [ 8 ] ) { <NEW_LINE> <START_VULN> vp9_push_neon ( store ) ; <NEW_LINE> <END_VULN> return true ; <NEW_LINE> }
{ <NEW_LINE> const struct mp_capable * mpc = ( const struct mp_capable * ) opt ; <NEW_LINE> <START_VULN> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <NEW_LINE> <END_VULN> ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) <NEW_LINE> return 0 ;
static int <NEW_LINE> cfm_network_addr_print ( netdissect_options * ndo , <NEW_LINE> <START_VULN> register const u_char * tptr ) <NEW_LINE> <END_VULN> { <NEW_LINE> u_int network_addr_type ; <NEW_LINE> u_int hexdump = FALSE ;
#if DCHECK_IS_ON ( ) <NEW_LINE> <START_VULN> scoped_refptr < ClipPaintPropertyNode > Clone ( ) const { <NEW_LINE>return base::AdoptRef ( new ClipPaintPropertyNode ( Parent ( ) , State ( state_ ) ) ) ; <NEW_LINE> <END_VULN> }
Stop a dispatcher by removing it from the run queue <NEW_LINE> @param dispatcher Dispatcher object created via #mprCreateDispatcher <NEW_LINE> @return Zero if successful , otherwise a negative MPR status code . <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> @ingroup MprEvent <NEW_LINE> PUBLIC int mprStopDispatcher ( MprDispatcher * dispatcher ) ;
do <NEW_LINE> { <NEW_LINE> UWORD32 u4_x_offset , u4_y_offset ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> UWORD32 u4_x_dst_offset = 0 ;
u32 device_idx , target_idx ; <NEW_LINE> int rc ; <NEW_LINE> <START_VULN> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> device_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) ;
cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 0 ; <NEW_LINE> cpi -> mb . e_mbd . mode_ref_lf_delta_update = 0 ; <NEW_LINE> <START_VULN> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <NEW_LINE>vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <NEW_LINE>vpx_memset ( cpi -> mb . e_mbd . last_ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <NEW_LINE>vpx_memset ( cpi -> mb . e_mbd . last_mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <NEW_LINE> <END_VULN> set_default_lf_deltas ( cpi ) ;
} <NEW_LINE> <START_VULN> void <NEW_LINE> <END_VULN> Selection::GetIndicesForInterval ( nsINode * aBeginNode , PRInt32 aBeginOffset , <NEW_LINE> nsINode * aEndNode , PRInt32 aEndOffset , <NEW_LINE> bool aAllowAdjacent , <NEW_LINE> PRInt32 * aStartIndex , PRInt32 * aEndIndex ) <NEW_LINE> { <NEW_LINE> PRInt32 startIndex ; <NEW_LINE> PRInt32 endIndex ;
static nsresult Startup ( ) ; <NEW_LINE> static void Shutdown ( ) ; <NEW_LINE> friend class TimerThread ; <NEW_LINE> friend struct TimerAdditionComparator ; <NEW_LINE> void Fire ( ) ; <NEW_LINE> <START_VULN> nsresult PostTimerEvent ( ) ; <NEW_LINE> <END_VULN> void SetDelayInternal ( uint32_t aDelay ) ; <NEW_LINE> NS_DECL_THREADSAFE_ISUPPORTS <NEW_LINE> NS_DECL_NSITIMER <NEW_LINE> int32_t GetGeneration ( ) <NEW_LINE> { <NEW_LINE> return mGeneration ;
SPL_METHOD ( SplFileObject , key ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
size_t tagSize = realTagSize > AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 ? <NEW_LINE> AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 : realTagSize ; <NEW_LINE> <START_VULN> utf16_to_utf8 ( tags . string ( ) , tagSize , attributes -> tags ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } else { <NEW_LINE> ALOGE ( "unmarshallAudioAttributes ( ) received unflattened tags , ignoring tag values" ) ;
return object_common2 ( UNSERIALIZE_PASSTHRU , <NEW_LINE> object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 836 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy32: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych == ' + ' ) goto yy33 ;
static int CVE_2013_4516_mp_get_count ( struct sb_uart_state * state , struct serial_icounter_struct * icnt ) <NEW_LINE> { <NEW_LINE> <START_VULN> struct serial_icounter_struct icount ; <NEW_LINE> <END_VULN> struct sb_uart_icount cnow ; <NEW_LINE> struct sb_uart_port * port = state -> port ;
uint32_t table_id , count , size_required ; <NEW_LINE> uint32_t num_extensions = 0 ; <NEW_LINE> <START_VULN> if ( size_left && size_left < 4 ) { <NEW_LINE> <END_VULN> LogError ( "Process_ipfix [ % u ] Template size error at % s line % u" , <NEW_LINE> exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; <NEW_LINE> size_left = 0 ;
IntervalNode * left = node -> left ( ) ; <NEW_LINE> if ( left != NULL && <NEW_LINE> <START_VULN> interval . low ( ) < left -> data ( ) . max_high ( ) ) { <NEW_LINE> <END_VULN> SearchForOverlapsFrom ( left , interval , res ) ; <NEW_LINE> }
} <NEW_LINE> res . append ( ':' ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( res . back ( ) == ':' ) res . pop_back ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> struct ListAddHelper : public AddableContainer
int error ; <NEW_LINE> jrdev = & pdev -> dev ; <NEW_LINE> <START_VULN> jrpriv = kmalloc ( sizeof ( struct caam_drv_private_jr ) , <NEW_LINE>GFP_KERNEL ) ; <NEW_LINE> <END_VULN> if ( ! jrpriv ) <NEW_LINE> return - ENOMEM ;
ret = cur = xmlNewDocElementContent ( ctxt -> myDoc , NULL , XML_ELEMENT_CONTENT_PCDATA ) ; <NEW_LINE> if ( ret == NULL ) return ( NULL ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> while ( RAW == ' | ' ) { <NEW_LINE> <END_VULN> NEXT ; <NEW_LINE> if ( elem == NULL ) { <NEW_LINE> ret = xmlNewDocElementContent ( ctxt -> myDoc , NULL , XML_ELEMENT_CONTENT_OR ) ;
#include "core / platform / graphics / GraphicsContext . h" <NEW_LINE> #include "core / platform / graphics / chromium / FontUtilsChromiumWin . h" <NEW_LINE> #include "core / platform / graphics / skia / SkiaFontWin . h" <NEW_LINE> <START_VULN> #include "core / platform / win / HWndDC . h" <NEW_LINE> <END_VULN> #include "third_party / skia / include / core / SkPoint . h" <NEW_LINE> #include "wtf / Assertions . h"
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . overloadedMethod7" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( RefPtr < DOMStringList > , arrayArg , v8ValueToWebCoreDOMStringList ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> imp -> overloadedMethod ( arrayArg ) ;
, mActivated ( false ) <NEW_LINE> , mPlayPreviewCanceled ( false ) <NEW_LINE> , mIsStopping ( false ) <NEW_LINE> , mIsLoading ( false ) <NEW_LINE> , mScriptRequested ( false ) { } <NEW_LINE> nsObjectLoadingContent:: ~ nsObjectLoadingContent ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> if ( mFrameLoader ) { <NEW_LINE> NS_NOTREACHED ( "Should not be tearing down frame loaders at this point" ) ; <NEW_LINE> mFrameLoader -> Destroy ( ) ; <NEW_LINE> } <NEW_LINE> if ( mInstanceOwner ) { <NEW_LINE> NS_NOTREACHED ( "Should not be tearing down a plugin at this point ! " ) ;
RUN_CALLBACK ( LIBRAW_PROGRESS_REMOVE_ZEROES , 1 , 2 ) ; <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> <START_VULN> #line 4111 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> void CLASS gamma_curve ( double pwr , double ts , int mode , int imax ) <NEW_LINE> { <NEW_LINE> int i ;
if ( IS_NOT_NULL ( einfo ) ) einfo -> par = ( UChar * ) NULL ; <NEW_LINE> if ( ci -> pattern_enc != ci -> target_enc ) { <NEW_LINE> <START_VULN> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <NEW_LINE> & cpat , & cpat_end ) ; <NEW_LINE>if ( r != 0 ) return r ; <NEW_LINE> <END_VULN> } <NEW_LINE> else { <NEW_LINE> cpat = ( UChar * ) pattern ;
class CurrentThreadPlatformMock : public Platform { <NEW_LINE> public: <NEW_LINE> CurrentThreadPlatformMock ( ) { } <NEW_LINE> <START_VULN> virtual void cryptographicallyRandomValues ( unsigned char * buffer , size_t length ) { ASSERT_NOT_REACHED ( ) ; } <NEW_LINE> <END_VULN> WebThread * currentThread ( ) override { return & m_currentThread ; } <NEW_LINE> void enterRunLoop ( ) { m_currentThread . enterRunLoop ( ) ; }
{ <NEW_LINE> float ratio = GetRatio ( ) ; <NEW_LINE> if ( restoreImage ) { <NEW_LINE> RestoreImage ( ) ; <NEW_LINE> FlushPendingNotifications ( Flush_Layout ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsIPresShell * shell = GetShell ( ) ; <NEW_LINE> <END_VULN> if ( ! shell ) <NEW_LINE> return ; <NEW_LINE> nsIScrollableFrame * sf = shell -> GetRootScrollFrameAsScrollable ( ) ; <NEW_LINE> if ( ! sf ) <NEW_LINE> return ; <NEW_LINE> nsRect portRect = sf -> GetScrollPortRect ( ) ;
static inline bool <NEW_LINE> CanFakeSync ( FrameEntry * fe ) <NEW_LINE> { <NEW_LINE> <START_VULN> return fe -> isNotType ( JSVAL_TYPE_OBJECT ) <NEW_LINE> && fe -> isNotType ( JSVAL_TYPE_STRING ) <NEW_LINE> && fe -> isNotType ( JSVAL_TYPE_DOUBLE ) <NEW_LINE> && fe -> isNotType ( JSVAL_TYPE_MAGIC ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> FrameState::evictDeadEntries ( bool includePinned ) <NEW_LINE> { <NEW_LINE> for ( uint32_t i = 0 ; i < Registers::TotalAnyRegisters ; i ++ ) { <NEW_LINE> AnyRegisterID reg = AnyRegisterID::fromRaw ( i ) ;
setLogicalHeight ( logicalHeight ( ) + borderAndPaddingBefore ) ; <NEW_LINE> <START_VULN> if ( ! isPositioned ( ) ) <NEW_LINE> <END_VULN> computeLogicalHeight ( ) ; <NEW_LINE> Length logicalHeightLength = style ( ) -> logicalHeight ( ) ;
const SyncSourceInfo & source , <NEW_LINE> bool notifications_enabled , <NEW_LINE> size_t num_entries , <NEW_LINE> <START_VULN> base::Time sync_start_time ) ; <NEW_LINE> <END_VULN> ~ SyncSessionSnapshot ( ) ;
{ <NEW_LINE> png_debug ( 1 , "in png_set_expand" ) ; <NEW_LINE> <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> png_ptr -> transformations |= ( PNG_EXPAND | PNG_EXPAND_tRNS ) ;
ProxyJNIEnv & proxyEnv = GetProxyEnv ( env ) ; <NEW_LINE> nsISecureEnv * secureEnv = GetSecureEnv ( env ) ; <NEW_LINE> nsISecurityContext * securityContext = proxyEnv . getContext ( ) ; <NEW_LINE> <START_VULN> nsresult rv = secureEnv -> GetField ( field -> mFieldType , obj , field -> mFieldID , & outValue , securityContext ) ; <NEW_LINE> <END_VULN> NS_IF_RELEASE ( securityContext ) ; <NEW_LINE> return NS_SUCCEEDED ( rv ) ? outValue : kErrorValue ; <NEW_LINE> }
ND_PRINT ( ( ndo , "\n\t Application Priority Table" ) ) ; <NEW_LINE> while ( i < sublen ) { <NEW_LINE> tval = * ( tptr + i + 5 ) ; <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , "\n\t Priority: % d , RES: % d , Sel: % d" , <NEW_LINE>tval >> 5 , ( tval >> 3 ) & 0x03 , ( tval & 0x07 ) ) ) ; <NEW_LINE>ND_PRINT ( ( ndo , "Protocol ID: % d" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ; <NEW_LINE> <END_VULN> i = i + 3 ; <NEW_LINE> } <NEW_LINE> break ;
nsCOMPtr < nsIDOMWindow > outer = do_QueryReferent ( mOuter ) ; <NEW_LINE> if ( NS_UNLIKELY ( ! outer ) ) <NEW_LINE> return false ; <NEW_LINE> nsCOMPtr < nsIScriptObjectPrincipal > sop = do_QueryInterface ( outer ) ; <NEW_LINE> bool subsumes = false ; <NEW_LINE> nsresult rv = nsContentUtils::GetSubjectPrincipal ( ) -> Subsumes ( sop -> GetPrincipal ( ) , & subsumes ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , false ) ; <NEW_LINE> <START_VULN> return subsumes ; <NEW_LINE> <END_VULN> }
NS_PRECONDITION ( ! mSkipOverflowContainerChildren || mWalkOOFFrames == <NEW_LINE> ! ! ( aOverflowCont -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) , <NEW_LINE> "shouldn't insert frame that doesn't match walker type" ) ; <NEW_LINE> NS_PRECONDITION ( aOverflowCont -> GetPrevInFlow ( ) , <NEW_LINE> "overflow containers must have a prev - in - flow" ) ; <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> bool reparented = false ; <NEW_LINE> nsPresContext * presContext = aOverflowCont -> PresContext ( ) ; <NEW_LINE> <START_VULN> const bool addToList = ! mSentry || aOverflowCont != mSentry -> GetNextInFlow ( ) ; <NEW_LINE> <END_VULN> if ( addToList ) { <NEW_LINE> if ( aOverflowCont -> GetStateBits ( ) & NS_FRAME_IS_OVERFLOW_CONTAINER ) { <NEW_LINE> NS_ASSERTION ( ! ( mOverflowContList && <NEW_LINE> mOverflowContList -> ContainsFrame ( aOverflowCont ) ) , <NEW_LINE> "overflow containers out of order" ) ; <NEW_LINE> rv = static_cast < nsContainerFrame * > ( aOverflowCont -> GetParent ( ) )
<START_VULN> #ifndef org_chromium_example_jni_generator_SampleForTests_JNI <NEW_LINE>#define org_chromium_example_jni_generator_SampleForTests_JNI <NEW_LINE> <END_VULN> #include < jni . h >
if ( NS_FAILED ( rv ) ) <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> <START_VULN> rv = newChannel -> AsyncOpen ( mListener , mListenerContext ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) <NEW_LINE>return rv ; <NEW_LINE> <END_VULN> Cancel ( NS_BINDING_REDIRECTED ) ; <NEW_LINE> mListener = nsnull ; <NEW_LINE> mListenerContext = nsnull ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
len = strlen ( filein ) ; <NEW_LINE> if ( filein [ len - 1 ] == 'h' ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> snprintf ( buf , L_BUF_SIZE , "cpp - ansi - DNO_PROTOS % s % s" , <NEW_LINE> <END_VULN> filein , tempfile ) ; <NEW_LINE> ret = system ( buf ) ; <NEW_LINE> if ( ret ) {
IPC_MESSAGE_CONTROL1 ( <NEW_LINE> ChromeUtilityHostMsg_AnalyzeZipFileForDownloadProtection_Finished , <NEW_LINE> safe_browsing::zip_analyzer::Results ) <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #if defined ( OS_WIN ) <NEW_LINE> IPC_MESSAGE_CONTROL0 ( ChromeUtilityHostMsg_GetOpenFileName_Failed )
static void Np_toString ( js_State * J ) <NEW_LINE> { <NEW_LINE> <START_VULN> char buf [ 32 ] ; <NEW_LINE> <END_VULN> js_Object * self = js_toobject ( J , 0 ) ; <NEW_LINE> int radix = js_isundefined ( J , 1 ) ? 10 : js_tointeger ( J , 1 ) ; <NEW_LINE> if ( self -> type != JS_CNUMBER )
return 0 ; <NEW_LINE> code_key = ( unsigned short ) code_key_a ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> while ( l <= h ) { <NEW_LINE> m = l + ( h - l ) / 2 ; <NEW_LINE> if ( code_key < m -> un_code_point )
unsigned long addr = compute_effective_address ( regs , insn ) ; <NEW_LINE> int err ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <NEW_LINE> <END_VULN> switch ( dir ) { <NEW_LINE> case load: <NEW_LINE> err = do_int_load ( fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) ,
pm_results ) ; <NEW_LINE> if ( pm_matches > 0 ) { <NEW_LINE> alproto = pm_results [ 0 ] ; <NEW_LINE> <START_VULN> goto end ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
perf_event_header__init_id ( & mmap_event -> event_id . header , & sample , event ) ; <NEW_LINE> ret = perf_output_begin ( & handle , event , <NEW_LINE> <START_VULN> mmap_event -> event_id . header . size , 0 , 0 ) ; <NEW_LINE> <END_VULN> if ( ret ) <NEW_LINE> goto out ;
{ <NEW_LINE> <START_VULN> HKEY hkApp ; <NEW_LINE> <END_VULN> RegCreateKeyExW ( HKEY_CURRENT_USER , L"Software\\Classes\\Applications" , <NEW_LINE> 0 , nullptr , REG_OPTION_NON_VOLATILE , KEY_SET_VALUE , nullptr , <NEW_LINE> & hkApp , nullptr ) ;
} <NEW_LINE> xmlNodeDump ( buf , test -> doc , test , 0 , 0 ) ; <NEW_LINE> pctxt = xmlRelaxNGNewMemParserCtxt ( ( const char * ) buf -> content , buf -> use ) ; <NEW_LINE> <START_VULN> xmlRelaxNGSetParserErrors ( pctxt , <NEW_LINE> ( xmlRelaxNGValidityErrorFunc ) testErrorHandler , <NEW_LINE> ( xmlRelaxNGValidityWarningFunc ) testErrorHandler , <NEW_LINE>pctxt ) ; <NEW_LINE> <END_VULN> rng = xmlRelaxNGParse ( pctxt ) ; <NEW_LINE> xmlRelaxNGFreeParserCtxt ( pctxt ) ; <NEW_LINE> if ( rng != NULL ) {
tok2str ( af_values , "Unknown" , af ) , af , <NEW_LINE> subobj_len ) ) ; <NEW_LINE> <START_VULN> if ( subobj_len == 0 ) <NEW_LINE> <END_VULN> goto invalid ; <NEW_LINE> switch ( subobj_type ) {
typedef base::Callback < void ( content::DownloadInterruptReason reason ) > <NEW_LINE> CreateDownloadFileCallback ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE> <END_VULN> typedef base::Callback < void ( const FilePath & ) > RenameCompletionCallback ; <NEW_LINE> class DownloadFileFactory {
#pragma once <NEW_LINE> #include "chrome / browser / translate / translate_infobar_view . h" <NEW_LINE> <START_VULN> #include "chrome / browser / ui / views / infobars / infobars . h" <NEW_LINE> <END_VULN> class TranslateInfoBarDelegate ;
PTA * <NEW_LINE> ptaReadStream ( FILE * fp ) <NEW_LINE> { <NEW_LINE> <START_VULN> char typestr [ 128 ] ; <NEW_LINE> <END_VULN> l_int32 i , n , ix , iy , type , version ; <NEW_LINE> l_float32 x , y ; <NEW_LINE> PTA * pta ;
header -> cmsg_len = CMSG_LEN ( sizeof ( int ) ) ; <NEW_LINE> * ( int * ) CMSG_DATA ( header ) = fd ; <NEW_LINE> <START_VULN> ssize_t ret = sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ; <NEW_LINE> <END_VULN> close ( fd ) ; <NEW_LINE> return ret ; <NEW_LINE> }
draw_info -> direction == RightToLeftDirection ? image -> columns - <NEW_LINE> metrics . bounds . x2 : - metrics . bounds . x1 , 0 . 0 ) , draw_info -> gravity == <NEW_LINE> UndefinedGravity ? metrics . ascent : 0 . 0 ) ; <NEW_LINE> <START_VULN> draw_info -> geometry = AcquireString ( geometry ) ; <NEW_LINE> <END_VULN> status = AnnotateImage ( image , draw_info ) ; <NEW_LINE> if ( image_info -> pointsize == 0 . 0 ) <NEW_LINE> {
& cu -> hdr , debug_str , debug_str_len ) ; <NEW_LINE> if ( cu -> dies [ cu -> length ] . attr_values [ i ] . name == DW_AT_comp_dir ) { <NEW_LINE> const char * name = cu -> dies [ cu -> length ] . attr_values [ i ] . encoding . str_struct . string ; <NEW_LINE> <START_VULN> sdb_set ( s , "DW_AT_comp_dir" , name , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> cu -> dies [ cu -> length ] . length ++ ; <NEW_LINE> }
#undef mem_put_be32 <NEW_LINE> #define mem_put_be32 mem_ops_wrap_symbol ( mem_put_be32 ) <NEW_LINE> <START_VULN> static void mem_put_be32 ( void * vmem , MEM_VALUE_T val ) { <NEW_LINE> <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; <NEW_LINE> mem [ 0 ] = ( val >> 24 ) & 0xff ;
WTF::Vector < Violation > maxViolations ; <NEW_LINE> for ( size_t i = 0 ; i < children . size ( ) ; ++ i ) { <NEW_LINE> RenderBox * child = children [ i ] ; <NEW_LINE> <START_VULN> if ( child -> isPositioned ( ) ) { <NEW_LINE> <END_VULN> childSizes . append ( 0 ) ; <NEW_LINE> continue ; <NEW_LINE> }
stream -> img -> stride [ VPX_PLANE_V ] , <NEW_LINE> stream -> img -> d_w , stream -> img -> d_h , <NEW_LINE> kFilterBox ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> img = stream -> img ; <NEW_LINE> } <NEW_LINE> vpx_usec_timer_start ( & timer ) ;
timeout . tv_sec = 0 ; <NEW_LINE> timeout . tv_usec = 0 ; <NEW_LINE> <START_VULN> select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ; <NEW_LINE> <END_VULN> return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ; <NEW_LINE> }
<START_VULN> bool isPositionedWithSpecifiedHeight = cb -> isPositioned ( ) && ( ! cb -> style ( ) -> logicalHeight ( ) . isAuto ( ) || ( ! cb -> style ( ) -> top ( ) . isAuto ( ) && ! cb -> style ( ) -> bottom ( ) . isAuto ( ) ) ) ; <NEW_LINE> <END_VULN>
png_debug ( 1 , "in png_do_rgb_to_gray" ) ; <NEW_LINE> <START_VULN> if ( ! ( row_info -> color_type & PNG_COLOR_MASK_PALETTE ) && <NEW_LINE> ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> PNG_CONST png_uint_32 rc = png_ptr -> rgb_to_gray_red_coeff ; <NEW_LINE> PNG_CONST png_uint_32 gc = png_ptr -> rgb_to_gray_green_coeff ;
return ( DestroyImageList ( image ) ) ; <NEW_LINE> } <NEW_LINE> packets = ( bits_per_pixel * image -> columns + 7 ) / 8 ; <NEW_LINE> <START_VULN> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <NEW_LINE> <END_VULN> sizeof ( * pixels ) ) ; <NEW_LINE> if ( pixels == ( unsigned char * ) NULL ) <NEW_LINE> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ;
return DisplaySelectionOverlay ( aBuilder , aLists . Content ( ) ) ; <NEW_LINE> } <NEW_LINE> void nsComboboxControlFrame::PaintFocus ( nsRenderingContext & aRenderingContext , <NEW_LINE> nsPoint aPt ) <NEW_LINE> { <NEW_LINE> nsEventStates eventStates = mContent -> AsElement ( ) -> State ( ) ; <NEW_LINE> <START_VULN> if ( eventStates . HasState ( NS_EVENT_STATE_DISABLED ) || mFocused != this ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> aRenderingContext . PushState ( ) ; <NEW_LINE> nsRect clipRect = mDisplayFrame -> GetRect ( ) + aPt ; <NEW_LINE> aRenderingContext . IntersectClip ( clipRect ) ;
proto_item * wpa_sub_ucs_item , * wpa_sub_akms_item ; <NEW_LINE> proto_tree * wpa_mcs_tree , * wpa_ucs_tree , * wpa_akms_tree ; <NEW_LINE> proto_tree * wpa_sub_ucs_tree , * wpa_sub_akms_tree ; <NEW_LINE> <START_VULN> guint16 i , ucs_count , akms_count ; <NEW_LINE> <END_VULN> proto_tree_add_item ( tree , hf_ieee80211_wfa_ie_wpa_version , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; <NEW_LINE> offset += 2 ;
c <<= 1 ; <NEW_LINE> } <NEW_LINE> for ( y = posision_y + i ; y < posision_y + i + n ; ++ y ) { <NEW_LINE> <START_VULN> ( void ) ResetMagickMemory ( imbuf + imsx * y + posision_x , color_index , repeat_count ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( max_x < ( posision_x + repeat_count - 1 ) ) { <NEW_LINE> max_x = posision_x + repeat_count - 1 ;
nsresult FindInsertionPoint ( <NEW_LINE> nsTArray < RangeData > * aElementArray , <NEW_LINE> nsINode * aPointNode , PRInt32 aPointOffset , <NEW_LINE> nsresult ( * aComparator ) ( nsINode * , PRInt32 , nsRange * , PRInt32 * ) , <NEW_LINE> PRInt32 * aPoint ) ; <NEW_LINE> bool EqualsRangeAtPoint ( nsINode * aBeginNode , PRInt32 aBeginOffset , <NEW_LINE> nsINode * aEndNode , PRInt32 aEndOffset , <NEW_LINE> PRInt32 aRangeIndex ) ; <NEW_LINE> <START_VULN> void GetIndicesForInterval ( nsINode * aBeginNode , PRInt32 aBeginOffset , <NEW_LINE>nsINode * aEndNode , PRInt32 aEndOffset , <NEW_LINE>bool aAllowAdjacent , <NEW_LINE>PRInt32 * aStartIndex , PRInt32 * aEndIndex ) ; <NEW_LINE> <END_VULN> RangeData * FindRangeData ( nsIDOMRange * aRange ) ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . overloadedMethod5" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> if ( args . Length ( ) <= 0 || ! args [ 0 ] -> IsFunction ( ) ) <NEW_LINE> return throwError ( TYPE_MISMATCH_ERR , args . GetIsolate ( ) ) ;
if ( status == MagickFalse ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> p = GetCacheViewVirtualPixels ( image_view , 0 , y , image -> columns , 1 , exception ) ; <NEW_LINE> <END_VULN> q = QueueCacheViewAuthenticPixels ( splice_view , 0 , y , splice_image -> columns , 1 , <NEW_LINE> exception ) ; <NEW_LINE> if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) )
. index_key . type = type , <NEW_LINE> . index_key . description = description , <NEW_LINE> . cred = current_cred ( ) , <NEW_LINE> <START_VULN> . match_data . cmp = type -> match , <NEW_LINE> <END_VULN> . match_data . raw_data = description , <NEW_LINE> . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , <NEW_LINE> . flags = KEYRING_SEARCH_DO_STATE_CHECK ,
yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych != ' { ' ) goto yy18 ; <NEW_LINE> ++ YYCURSOR ; <NEW_LINE> <START_VULN> #line 677 "ext / standard / var_unserializer . re" <NEW_LINE> <END_VULN> { <NEW_LINE> long elements = parse_iv ( start + 2 ) ;
jsval rval = JSVAL_VOID ; <NEW_LINE> nsCxPusher pusher ; <NEW_LINE> <START_VULN> if ( ! pusher . Push ( mContext ) ) <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> <END_VULN> rv = sSecurityManager -> CheckFunctionAccess ( mContext , aHandler , target ) ; <NEW_LINE> nsJSContext::TerminationFuncHolder holder ( this ) ; <NEW_LINE> if ( NS_SUCCEEDED ( rv ) ) {
} <NEW_LINE> } else if ( ( ctxt -> internalized ) && <NEW_LINE> ( target -> doc != NULL ) && <NEW_LINE> <START_VULN> ( target -> doc -> dict == ctxt -> dict ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> text -> content = ( xmlChar * ) value ; <NEW_LINE> } else {
pbi -> last_time_stamp = time_stamp ; <NEW_LINE> decode_exit: <NEW_LINE> <START_VULN> #if HAVE_NEON <NEW_LINE>#if CONFIG_RUNTIME_CPU_DETECT <NEW_LINE>if ( cm -> cpu_caps & HAS_NEON ) <NEW_LINE>#endif <NEW_LINE> { <NEW_LINE>vp8_pop_neon ( dx_store_reg ) ; <NEW_LINE> } <NEW_LINE>#endif <NEW_LINE><NEW_LINE> <END_VULN> pbi -> common . error . setjmp = 0 ; <NEW_LINE> return retcode ; <NEW_LINE> } <NEW_LINE> int vp8dx_get_raw_frame ( VP8D_COMP * pbi , YV12_BUFFER_CONFIG * sd , int64_t * time_stamp , int64_t * time_end_stamp , vp8_ppflags_t * flags )
do <NEW_LINE> { <NEW_LINE> <START_VULN> if ( user_png_ver [ i ] != png_libpng_ver [ i ] ) <NEW_LINE> <END_VULN> { <NEW_LINE> #ifdef PNG_LEGACY_SUPPORTED <NEW_LINE> png_ptr -> flags |= PNG_FLAG_LIBRARY_MISMATCH ;
#include < new > <NEW_LINE> #include "base / logging . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "mojo / public / cpp / bindings / type_converter . h" <NEW_LINE> namespace mojo {
{ <NEW_LINE> int		i ; <NEW_LINE> u_entry_T	 * uep ; <NEW_LINE> <START_VULN> char_u	 ** array ; <NEW_LINE> <END_VULN> char_u	 * line ; <NEW_LINE> int		line_len ;
#include "base / files / file . h" <NEW_LINE> #include "base / files / file_path . h" <NEW_LINE> <START_VULN> #include "base / move . h" <NEW_LINE> <END_VULN> #include "ipc / ipc_platform_file . h" <NEW_LINE> namespace picasa {
nsIntRect r ; <NEW_LINE> if ( mImage ) { <NEW_LINE> r = mImage -> FrameRect ( imgIContainer::FRAME_CURRENT ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsTObserverArray < imgRequestProxy * > array ; <NEW_LINE>array . AppendElement ( proxy ) ; <NEW_LINE> <END_VULN> SyncNotifyState ( array , ! ! mImage , mState , r , mHadLastPart ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> imgStatusTracker::SyncNotifyDecodeState ( ) <NEW_LINE> { <NEW_LINE> LOG_SCOPE ( GetImgLog ( ) , "imgStatusTracker::SyncNotifyDecodeState" ) ;
if ( ( image_info -> interlace == PlaneInterlace ) || <NEW_LINE> ( image_info -> interlace == PartitionInterlace ) ) <NEW_LINE> ( void ) TIFFSetField ( tiff , TIFFTAG_PLANARCONFIG , PLANARCONFIG_SEPARATE ) ; <NEW_LINE> <START_VULN> rows_per_strip = TIFFDefaultStripSize ( tiff , 0 ) ; <NEW_LINE> <END_VULN> option = GetImageOption ( image_info , "tiff:rows - per - strip" ) ; <NEW_LINE> if ( option != ( const char * ) NULL ) <NEW_LINE> rows_per_strip = ( size_t ) strtol ( option , ( char ** ) NULL , 10 ) ;
<START_VULN> read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
virtual ModelSafeGroup GetModelSafeGroup ( ) ; <NEW_LINE> virtual bool CurrentThreadIsWorkThread ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE>virtual void OnRequestAdded ( CancelableRequestProvider * provider , <NEW_LINE>CancelableRequestProvider::Handle handle ) { } <NEW_LINE><NEW_LINE>virtual void OnRequestRemoved ( CancelableRequestProvider * provider , <NEW_LINE>CancelableRequestProvider::Handle handle ) { } <NEW_LINE><NEW_LINE>virtual void WillExecute ( CancelableRequestProvider * provider , <NEW_LINE>CancelableRequestProvider::Handle handle ) { } <NEW_LINE><NEW_LINE>virtual void DidExecute ( CancelableRequestProvider * provider , <NEW_LINE>CancelableRequestProvider::Handle handle ) { } <NEW_LINE><NEW_LINE> <END_VULN> private: <NEW_LINE> scoped_refptr < HistoryService > history_service_ ; <NEW_LINE> DISALLOW_COPY_AND_ASSIGN ( HistoryModelWorker ) ; <NEW_LINE> } ;
} <NEW_LINE> } <NEW_LINE> <START_VULN> static void copyMultiCh24 ( short * dst , const int * const * src , unsigned nSamples , unsigned nChannels ) <NEW_LINE> <END_VULN> { <NEW_LINE> for ( unsigned i = 0 ; i < nSamples ; ++ i ) { <NEW_LINE> for ( unsigned c = 0 ; c < nChannels ; ++ c ) {
} <NEW_LINE> } <NEW_LINE> break ; <NEW_LINE> #if JS_HAS_XML_SUPPORT <NEW_LINE> case TOK_FILTER: <NEW_LINE> if ( ! js_EmitTree ( cx , cg , pn -> pn_left ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> <START_VULN> jmp = js_Emit3 ( cx , cg , JSOP_FILTER , 0 , 0 ) ; <NEW_LINE> <END_VULN> if ( jmp < 0 ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> top = js_Emit1 ( cx , cg , JSOP_TRACE ) ; <NEW_LINE> if ( top < 0 ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> if ( ! js_EmitTree ( cx , cg , pn -> pn_right ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> CHECK_AND_SET_JUMP_OFFSET_AT ( cx , cg , jmp ) ;
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> PassRefPtr < IDBKey > key ( createIDBKeyFromValue ( exec , MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
delete entry ; <NEW_LINE> return nsnull ; <NEW_LINE> } <NEW_LINE> const char * info = entry -> GetMetaDataElement ( "security - info" ) ; <NEW_LINE> if ( info ) { <NEW_LINE> nsCOMPtr < nsISupports > infoObj ; <NEW_LINE> <START_VULN> NS_DeserializeObject ( nsDependentCString ( info ) , getter_AddRefs ( infoObj ) ) ; <NEW_LINE> <END_VULN> entry -> SetSecurityInfo ( infoObj ) ; <NEW_LINE> } <NEW_LINE> return entry ; <NEW_LINE> }
nsCString buf ; <NEW_LINE> rv = NS_ReadInputStreamToString ( instream , buf , len ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) <NEW_LINE> return rv ; <NEW_LINE> <START_VULN> rv = mSystemPrincipal -> GetJSPrincipals ( cx , & jsPrincipals ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) || ! jsPrincipals ) { <NEW_LINE> return ReportError ( cx , LOAD_ERROR_NOPRINCIPALS ) ; <NEW_LINE> } <NEW_LINE> er = JS_SetErrorReporter ( cx , mozJSLoaderErrorReporter ) ;
NS_ASSERTION ( aScriptObject , "uh - oh , script Object should NOT be null or bad things will happen" ) ; <NEW_LINE> if ( ! aScriptObject ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> JSObject * globalObject = sgo -> GetGlobalJSObject ( ) ; <NEW_LINE> <START_VULN> if ( mJSMethodObject && aTargetClassObject ) { <NEW_LINE> <END_VULN> nsDependentString name ( mName ) ; <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , globalObject ) ; <NEW_LINE> JSObject * method = ::JS_CloneFunctionObject ( cx , mJSMethodObject , globalObject ) ; <NEW_LINE> if ( ! method ) { <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> }
XWDColor <NEW_LINE> color ; <NEW_LINE> <START_VULN> colors = ( XColor * ) AcquireQuantumMemory ( ( size_t ) header . ncolors , <NEW_LINE>sizeof ( * colors ) ) ; <NEW_LINE> <END_VULN> if ( colors == ( XColor * ) NULL ) <NEW_LINE> { <NEW_LINE> ximage = ( XImage * ) RelinquishMagickMemory ( ximage ) ;
<START_VULN> int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , <NEW_LINE>vpx_codec_frame_buffer_t * fb ) { <NEW_LINE> <END_VULN> int i ; <NEW_LINE> struct ExternalFrameBufferList * const ext_fb_list = <NEW_LINE> ( struct ExternalFrameBufferList * ) cb_priv ;
m_isReadOnly = ! value . isNull ( ) ; <NEW_LINE> if ( wasReadOnly != m_isReadOnly ) { <NEW_LINE> setNeedsWillValidateCheck ( ) ; <NEW_LINE> <START_VULN> setNeedsStyleRecalc ( SubtreeStyleChange , StyleChangeReasonForTracing::fromAttribute ( name ) ) ; <NEW_LINE> <END_VULN> if ( layoutObject ( ) ) <NEW_LINE> LayoutTheme::theme ( ) . controlStateChanged ( * layoutObject ( ) , ReadOnlyControlState ) ; <NEW_LINE> }
switch ( cmdCode ) { <NEW_LINE> case EFFECT_CMD_INIT: <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <NEW_LINE> <END_VULN> ALOGV ( "\tLVM_ERROR , EFFECT_CMD_INIT: ERROR for effect type % d" , <NEW_LINE> pContext -> EffectType ) ; <NEW_LINE> return - EINVAL ;
static int check_line_charstring ( void ) <NEW_LINE> { <NEW_LINE> char * p = line ; <NEW_LINE> <START_VULN> while ( isspace ( * p ) ) <NEW_LINE> <END_VULN> p ++ ; <NEW_LINE> return ( * p == ' / ' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; <NEW_LINE> }
if ( ! subpelmv && have_ref && <NEW_LINE> ref_bsi -> rdstat [ i ] [ mode_idx ] . brdcost < INT64_MAX ) { <NEW_LINE> <START_VULN> vpx_memcpy ( & bsi -> rdstat [ i ] [ mode_idx ] , & ref_bsi -> rdstat [ i ] [ mode_idx ] , <NEW_LINE>sizeof ( SEG_RDSTAT ) ) ; <NEW_LINE> <END_VULN> if ( num_4x4_blocks_wide > 1 ) <NEW_LINE> bsi -> rdstat [ i + 1 ] [ mode_idx ] . eobs = <NEW_LINE> ref_bsi -> rdstat [ i + 1 ] [ mode_idx ] . eobs ;
FireOnSelectHandler ( ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeSelection::InvalidateSelection ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( mFirstRange ) <NEW_LINE>mFirstRange -> Invalidate ( ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsTreeSelection::GetShiftSelectPivot ( PRInt32 * aIndex ) <NEW_LINE> { <NEW_LINE> * aIndex = mShiftSelectPivot ; <NEW_LINE> return NS_OK ;
static void <NEW_LINE> <START_VULN> gamma_test ( png_modifier * pmIn , PNG_CONST png_byte colour_typeIn , <NEW_LINE>PNG_CONST png_byte bit_depthIn , PNG_CONST int palette_numberIn , <NEW_LINE>PNG_CONST int interlace_typeIn , <NEW_LINE>PNG_CONST double file_gammaIn , PNG_CONST double screen_gammaIn , <NEW_LINE>PNG_CONST png_byte sbitIn , PNG_CONST int threshold_testIn , <NEW_LINE>PNG_CONST char * name , <NEW_LINE>PNG_CONST int use_input_precisionIn , PNG_CONST int scale16In , <NEW_LINE>PNG_CONST int expand16In , PNG_CONST int do_backgroundIn , <NEW_LINE>PNG_CONST png_color_16 * bkgd_colorIn , double bkgd_gammaIn ) <NEW_LINE> <END_VULN> { <NEW_LINE> gamma_display d ; <NEW_LINE> context ( & pmIn -> this , fault ) ;
uint64 ContentEncoding::Size ( ) const { <NEW_LINE> const uint64 encryption_size = EncryptionSize ( ) ; <NEW_LINE> const uint64 encoding_size = EncodingSize ( 0 , encryption_size ) ; <NEW_LINE> <START_VULN> const uint64 encodings_size = EbmlMasterElementSize ( kMkvContentEncoding , <NEW_LINE>encoding_size ) + <NEW_LINE>encoding_size ; <NEW_LINE> <END_VULN> return encodings_size ; <NEW_LINE> }
p -> invitestate = INV_TERMINATED ; <NEW_LINE> p -> pendinginvite = 0 ; <NEW_LINE> acked = __sip_ack ( p , seqno , 1 , 0 ) ; <NEW_LINE> <START_VULN> if ( find_sdp ( req ) ) { <NEW_LINE> <END_VULN> if ( process_sdp ( p , req , SDP_T38_NONE ) ) { <NEW_LINE> return - 1 ; <NEW_LINE> }
void ImplSetSize ( sal_uInt16 nSize , bool bResize = true ) ; <NEW_LINE> void ImplCreateFlagArray ( ) ; <NEW_LINE> <START_VULN> void ImplSplit ( sal_uInt16 nPos , sal_uInt16 nSpace , ImplPolygon const * pInitPoly = nullptr ) ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> #define MAX_POLYGONS ( ( sal_uInt16 ) 0x3FF0 )
<START_VULN> void * base = dlmalloc ( bytes + sizeof ( AllocationEntry ) ) ; <NEW_LINE> <END_VULN> if ( base != NULL ) { <NEW_LINE> pthread_mutex_lock ( & gAllocationsMutex ) ;
#define BGP_ATTR_ENCAP 23 <NEW_LINE> #define BGP_ATTR_LARGE_COMMUNITIES 32 <NEW_LINE> #define BGP_ATTR_PREFIX_SID 40 <NEW_LINE> <START_VULN> #if ENABLE_BGP_VNC <NEW_LINE> <END_VULN> #define BGP_ATTR_VNC 255 <NEW_LINE> #endif
{ <NEW_LINE> if ( m_successCallback ) { <NEW_LINE> RefPtr < RTCSessionDescription > sessionDescription = RTCSessionDescription::create ( descriptor ) ; <NEW_LINE> <START_VULN> m_successCallback -> handleEvent ( sessionDescription . get ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> clear ( ) ;
} else { <NEW_LINE> newWrapper = targetwrapper ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ! RemapWrappers ( cx , origobj , targetobj ) ) <NEW_LINE> <END_VULN> return NULL ; <NEW_LINE> {
return ; <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " [ | icmp6 ] " ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void
_y4m -> convert = y4m_convert_444_420jpeg ; <NEW_LINE> } else { <NEW_LINE> _y4m -> vpx_fmt = VPX_IMG_FMT_I444 ; <NEW_LINE> <START_VULN> _y4m -> vpx_bps = 24 ; <NEW_LINE> <END_VULN> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; <NEW_LINE> _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; <NEW_LINE> _y4m -> dst_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ;
{ <NEW_LINE> if ( row_info -> bit_depth == 8 ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( at_start ) <NEW_LINE> <END_VULN> ++ sp ; <NEW_LINE> else <NEW_LINE> sp += 4 , dp += 3 ;
ProxyJNIEnv & proxyEnv = GetProxyEnv ( env ) ; <NEW_LINE> nsISecureEnv * secureEnv = GetSecureEnv ( env ) ; <NEW_LINE> nsISecurityContext * securityContext = proxyEnv . getContext ( ) ; <NEW_LINE> <START_VULN> nsresult rv = secureEnv -> GetStaticField ( field -> mFieldType , clazz , field -> mFieldID , & outValue , securityContext ) ; <NEW_LINE> <END_VULN> NS_IF_RELEASE ( securityContext ) ; <NEW_LINE> return NS_SUCCEEDED ( rv ) ? outValue : kErrorValue ; <NEW_LINE> }
if ( out == NULL ) { <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> <START_VULN> gdImageWebpCtx ( im , out , quality ) ; <NEW_LINE>rv = gdDPExtractData ( out , size ) ; <NEW_LINE> <END_VULN> out -> gd_free ( out ) ; <NEW_LINE> return rv ; <NEW_LINE> }
static NS_DEFINE_CID ( kWidgetCID , NS_CHILD_CID ) ; <NEW_LINE> static PLDHashOperator <NEW_LINE> CancelImageRequest ( const nsAString & aKey , <NEW_LINE> nsTreeImageCacheEntry aEntry , void * aData ) <NEW_LINE> { <NEW_LINE> <START_VULN> aEntry . request -> Cancel ( NS_BINDING_ABORTED ) ; <NEW_LINE> <END_VULN> return PL_DHASH_NEXT ; <NEW_LINE> }
selaComputeCompositeParameters ( const char * fileout ) <NEW_LINE> { <NEW_LINE> char * str , * nameh1 , * nameh2 , * namev1 , * namev2 ; <NEW_LINE> <START_VULN> char buf [ L_BUF_SIZE ] ; <NEW_LINE> <END_VULN> l_int32 size , size1 , size2 , len ; <NEW_LINE> SARRAY * sa ; <NEW_LINE> SELA * selabasic , * selacomb ;
io -> flag = 0 ; <NEW_LINE> io -> offset = 0 ; <NEW_LINE> io -> size = 0 ; <NEW_LINE> <START_VULN> io -> error = 0 ; <NEW_LINE> <END_VULN> INIT_WORK ( & io -> work , ext4_end_io_work ) ; <NEW_LINE> INIT_LIST_HEAD ( & io -> list ) ; <NEW_LINE> }
sqlite3_result_int64 ( pCtx , pCsr -> iPrevId ) ; <NEW_LINE> } else if ( iCol == p -> nColumn ) { <NEW_LINE> <START_VULN> sqlite3_result_blob ( pCtx , & pCsr , sizeof ( pCsr ) , SQLITE_TRANSIENT ) ; <NEW_LINE>sqlite3_result_subtype ( pCtx , '3' ) ; <NEW_LINE> <END_VULN> } else if ( iCol == p -> nColumn + 2 && pCsr -> pExpr ) { <NEW_LINE> sqlite3_result_int64 ( pCtx , pCsr -> iLangid ) ; <NEW_LINE> } else {
ssize_t MPEG4DataSource::readAt ( off64_t offset , void * data , size_t size ) { <NEW_LINE> Mutex::Autolock autoLock ( mLock ) ; <NEW_LINE> <START_VULN> if ( offset >= mCachedOffset <NEW_LINE> && offset + size <= mCachedOffset + mCachedSize ) { <NEW_LINE> <END_VULN> memcpy ( data , & mCache [ offset - mCachedOffset ] , size ) ; <NEW_LINE> return size ; <NEW_LINE> }
#include "vp9 / common / vp9_filter . h" <NEW_LINE> <START_VULN> const InterpKernel vp9_bilinear_filters [ SUBPEL_SHIFTS ] = { <NEW_LINE> <END_VULN> { 0 , 0 , 0 , 128 , 0 , 0 , 0 , 0 } , <NEW_LINE> { 0 , 0 , 0 , 120 , 8 , 0 , 0 , 0 } , <NEW_LINE> { 0 , 0 , 0 , 112 , 16 , 0 , 0 , 0 } ,
) { <NEW_LINE> DEBUG_PRINT_LOW ( "Freeing the Input Memory" ) ; <NEW_LINE> for ( i = 0 ; i < m_sInPortDef . nBufferCountActual ; i ++ ) { <NEW_LINE> <START_VULN> free_input_buffer ( & m_inp_mem_ptr [ i ] ) ; <NEW_LINE> <END_VULN> }
nsresult <NEW_LINE> nsComputedDOMStyle::GetBorderWidthFor ( PRUint8 aSide , nsIDOMCSSValue ** aValue ) <NEW_LINE> { <NEW_LINE> nsROCSSPrimitiveValue * val = GetROCSSPrimitiveValue ( ) ; <NEW_LINE> NS_ENSURE_TRUE ( val , NS_ERROR_OUT_OF_MEMORY ) ; <NEW_LINE> nscoord width ; <NEW_LINE> if ( mInnerFrame ) { <NEW_LINE> <START_VULN> FlushPendingReflows ( ) ; <NEW_LINE> <END_VULN> width = mInnerFrame -> GetUsedBorder ( ) . side ( aSide ) ; <NEW_LINE> } else { <NEW_LINE> width = GetStyleBorder ( ) -> GetBorderWidth ( aSide ) ; <NEW_LINE> } <NEW_LINE> val -> SetAppUnits ( width ) ; <NEW_LINE> return CallQueryInterface ( val , aValue ) ; <NEW_LINE> }
ValidateStateStack ( ) ; <NEW_LINE> <START_VULN> if ( OriginClean ( ) && <NEW_LINE>WouldTaintOrigin ( image_source , ExecutionContext::From ( script_state ) ) ) { <NEW_LINE>SetOriginTainted ( ) ; <NEW_LINE>ClearResolvedFilters ( ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> Draw ( <NEW_LINE> [ this , & image_source , & image , & src_rect , dst_rect ] (
<START_VULN> #line 1180 "ntp_parser . y" <NEW_LINE> <END_VULN> void yyerror ( char * msg )
return - 1 ; <NEW_LINE> } <NEW_LINE> ff_free_vlc ( & s -> vlc [ i ] ) ; <NEW_LINE> <START_VULN> init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , <NEW_LINE>s -> bits [ i ] , 4 , 4 , 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> generate_joint_tables ( s ) ;
<START_VULN> static const char * const cfg = " -- target = armv7 - android - gcc -- disable - runtime - cpu - detect -- sdk - path = / usr / local / google / home / hkuang / Downloads / android - ndk - r9d -- disable - examples -- disable - docs -- enable - realtime - only" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
nsPIDOMWindow * aWindow , <NEW_LINE> const dom::MediaStreamConstraints & aRawConstraints , <NEW_LINE> nsIDOMGetUserMediaSuccessCallback * onSuccess , <NEW_LINE> nsIDOMGetUserMediaErrorCallback * onError ) ; <NEW_LINE> nsresult GetUserMediaDevices ( nsPIDOMWindow * aWindow , <NEW_LINE> const dom::MediaStreamConstraintsInternal & aConstraints , <NEW_LINE> nsIGetUserMediaDevicesSuccessCallback * onSuccess , <NEW_LINE> <START_VULN> nsIDOMGetUserMediaErrorCallback * onError ) ; <NEW_LINE> <END_VULN> void OnNavigation ( uint64_t aWindowID ) ; <NEW_LINE> MediaEnginePrefs mPrefs ; <NEW_LINE> private: <NEW_LINE> WindowTable * GetActiveWindows ( ) { <NEW_LINE> NS_ASSERTION ( NS_IsMainThread ( ) , "Only access windowlist on main thread" ) ; <NEW_LINE> return & mActiveWindows ;
size_t CacheMemoryUsageInBytes ( ) const ; <NEW_LINE> private: <NEW_LINE> <START_VULN> TransformPaintPropertyNode ( <NEW_LINE>scoped_refptr < const TransformPaintPropertyNode > parent , <NEW_LINE>State && state ) <NEW_LINE>: PaintPropertyNode ( std::move ( parent ) ) , state_ ( std::move ( state ) ) { <NEW_LINE> <END_VULN> Validate ( ) ; <NEW_LINE> }
} <NEW_LINE> else if ( aDeep || aNode -> IsNodeOfType ( nsINode::eATTRIBUTE ) ) { <NEW_LINE> PRUint32 i , length = aNode -> GetChildCount ( ) ; <NEW_LINE> for ( i = 0 ; i < length ; ++ i ) { <NEW_LINE> nsCOMPtr < nsINode > child ; <NEW_LINE> rv = CloneAndAdopt ( aNode -> GetChildAt ( i ) , aClone , PR_TRUE , nodeInfoManager , <NEW_LINE> <START_VULN> aCx , aOldScope , aNewScope , aNodesWithProperties , <NEW_LINE>clone , getter_AddRefs ( child ) ) ; <NEW_LINE> <END_VULN> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> } <NEW_LINE> }
m_group ( dsa . get_group ( ) ) , <NEW_LINE> m_y ( dsa . get_y ( ) ) , <NEW_LINE> m_mod_q ( dsa . group_q ( ) ) <NEW_LINE> <START_VULN> { } <NEW_LINE> <END_VULN> size_t max_input_bits ( ) const override { return m_group . get_q ( ) . bits ( ) ; }
# else <NEW_LINE> PNG_UNUSED ( png_ptr ) <NEW_LINE> # endif <NEW_LINE> <START_VULN> if ( is_screen ) <NEW_LINE> <END_VULN> output_gamma = PNG_GAMMA_sRGB ; <NEW_LINE> else <NEW_LINE> output_gamma = PNG_GAMMA_sRGB_INVERSE ;
static EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionOverloadedMethod12 ( ExecState * exec ) <NEW_LINE> { <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> const String & type ( ustringToString ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . isEmpty ( ) ? UString ( ) : MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) . toString ( exec ) -> value ( exec ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
<START_VULN> #include < GUSICommandLine . h > <NEW_LINE> <END_VULN> #include < stdlib . h > #undef main DECLARE_MAIN ( test ) REGISTER_MAIN_START REGISTER_MAIN ( test ) REGISTER_MAIN_END int main ( ) { ( void ) exec_commands ( ) ; return 0 ; } <NEW_LINE> \ No newline at end of file
#define s_pop_layer ( s , h ) ( s ) -> p = ( s ) -> h ; <NEW_LINE> #define s_mark_end ( s ) ( s ) -> end = ( s ) -> p ; <NEW_LINE> #define s_check ( s ) ( ( s ) -> p <= ( s ) -> end ) <NEW_LINE> <START_VULN> #define s_check_rem ( s , n ) ( ( s ) -> p + n <= ( s ) -> end ) <NEW_LINE> <END_VULN> #define s_check_end ( s ) ( ( s ) -> p == ( s ) -> end ) <NEW_LINE> #define s_length ( s ) ( ( s ) -> end - ( s ) -> data ) <NEW_LINE> #define s_left ( s ) ( ( s ) -> size - ( ( s ) -> p - ( s ) -> data ) )
void WalkDescendantsClearAncestorDirAuto ( mozilla::dom::Element * aElement ) ; <NEW_LINE> <START_VULN> void SetDirectionFromChangedTextNode ( nsIContent * aTextNode , uint32_t aOffset , <NEW_LINE>const char16_t * aBuffer , uint32_t aLength , <NEW_LINE>bool aNotify ) ; <NEW_LINE> <END_VULN> void SetDirectionFromNewTextNode ( nsIContent * aTextNode ) ;
jas_seq2d_t * jas_seq2d_copy ( jas_seq2d_t * x ) ; <NEW_LINE> <START_VULN> jas_matrix_t * jas_seq2d_create ( int xstart , int ystart , int xend , int yend ) ; <NEW_LINE> <END_VULN> #define jas_seq2d_destroy ( s ) \ <NEW_LINE> jas_matrix_destroy ( s )
SkISize GetSupportedDecodeSize ( const SkISize & requested_size ) const ; <NEW_LINE> bool IsMultiFrame ( ) const { return is_multi_frame_ ; } <NEW_LINE> <START_VULN> bool DecodeFailed ( ) const { return decode_failed_ ; } <NEW_LINE> <END_VULN> bool HasAlpha ( size_t index ) ;
RenderObject * renderer = ( * it ) -> renderer ( ) ; <NEW_LINE> if ( ! renderer ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> SVGResourcesCache::clientStyleChanged ( renderer , StyleDifferenceLayout , renderer -> style ( ) ) ; <NEW_LINE> <END_VULN> renderer -> setNeedsLayout ( ) ; <NEW_LINE> } <NEW_LINE> }
} <NEW_LINE> static __always_inline void <NEW_LINE> <START_VULN> perf_sw_event ( u32 event_id , u64 nr , int nmi , struct pt_regs * regs , u64 addr ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct pt_regs hot_regs ;
<START_VULN> if ( transforms & PNG_TRANSFORM_PACKING ) <NEW_LINE> <END_VULN> #ifdef PNG_READ_PACK_SUPPORTED <NEW_LINE> png_set_packing ( png_ptr ) ; <NEW_LINE> #else
mFullScreen = false ; <NEW_LINE> mJavaView = nullptr ; <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> nsPluginInstanceOwner:: ~ nsPluginInstanceOwner ( ) <NEW_LINE> { <NEW_LINE> if ( mWaitingForPaint ) { <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE>nsCOMPtr < nsIRunnable > event = new AsyncPaintWaitEvent ( mContent , true ) ; <NEW_LINE>NS_DispatchToMainThread ( event ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> mPluginFrame = nullptr ; <NEW_LINE> PLUG_DeletePluginNativeWindow ( mPluginWindow ) ; <NEW_LINE> mPluginWindow = nullptr ; <NEW_LINE> #ifdef MOZ_WIDGET_ANDROID
if ( currentScaleFactor == - 1 ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> int x , y ; <NEW_LINE>ewk_frame_scroll_pos_get ( smartData -> main_frame , & x , & y ) ; <NEW_LINE><NEW_LINE>x = static_cast < int > ( ( ( x + centerX ) / currentScaleFactor ) * scaleFactor ) - centerX ; <NEW_LINE>y = static_cast < int > ( ( ( y + centerY ) / currentScaleFactor ) * scaleFactor ) - centerY ; <NEW_LINE>priv -> page -> setPageScaleFactor ( scaleFactor , WebCore::LayoutPoint ( x , y ) ) ; <NEW_LINE> <END_VULN> return true ; <NEW_LINE> }
} <NEW_LINE> void <NEW_LINE> nsDocument::MaybePreLoadImage ( nsIURI * uri ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( nsContentUtils::IsImageInCache ( uri ) ) { <NEW_LINE> <END_VULN> return ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < imgIRequest > request ; <NEW_LINE> nsresult rv = <NEW_LINE> nsContentUtils::LoadImage ( uri , <NEW_LINE> this ,
keywords [ 3 ] = "password" ; <NEW_LINE> values [ 3 ] = password ; <NEW_LINE> keywords [ 4 ] = "dbname" ; <NEW_LINE> <START_VULN> values [ 4 ] = newdb ; <NEW_LINE> <END_VULN> keywords [ 5 ] = "fallback_application_name" ; <NEW_LINE> values [ 5 ] = progname ; <NEW_LINE> keywords [ 6 ] = NULL ;
if ( finalNbRects != nbRects ) <NEW_LINE> { <NEW_LINE> <START_VULN> int allocSize = sizeof ( REGION16_DATA ) + ( finalNbRects * sizeof ( RECTANGLE_16 ) ) ; <NEW_LINE>region -> data = realloc ( region -> data , allocSize ) ; <NEW_LINE> <END_VULN> if ( ! region -> data ) <NEW_LINE> {
return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } while ( ( doc = doc -> GetParentDocument ( ) ) ) ; <NEW_LINE> nsCOMPtr < nsINode > parent = adoptedNode -> GetNodeParent ( ) ; <NEW_LINE> if ( parent ) { <NEW_LINE> <START_VULN> parent -> RemoveChildAt ( parent -> IndexOf ( adoptedNode ) , true ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> case nsIDOMNode::DOCUMENT_NODE: <NEW_LINE> { <NEW_LINE> return NS_ERROR_DOM_NOT_SUPPORTED_ERR ; <NEW_LINE> }
#include "nsReadableUtils . h" <NEW_LINE> #include "nsNetSegmentUtils . h" <NEW_LINE> #include "nsEscape . h" <NEW_LINE> #include "plbase64 . h" <NEW_LINE> #include "plstr . h" <NEW_LINE> #include "prmem . h" <NEW_LINE> nsresult <NEW_LINE> <START_VULN> nsDataChannel::OpenContentStream ( PRBool async , nsIInputStream ** result ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ENSURE_TRUE ( URI ( ) , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE> nsresult rv ; <NEW_LINE> nsCAutoString spec ; <NEW_LINE> rv = URI ( ) -> GetAsciiSpec ( spec ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) return rv ;
} ; <NEW_LINE> } <NEW_LINE> class nsTimerEvent : public nsRunnable { <NEW_LINE> public: <NEW_LINE> NS_IMETHOD Run ( ) ; <NEW_LINE> <START_VULN> nsTimerEvent ( nsTimerImpl * timer , int32_t generation ) <NEW_LINE>: mTimer ( dont_AddRef ( timer ) ) , mGeneration ( generation ) { <NEW_LINE><NEW_LINE> <END_VULN> MOZ_COUNT_CTOR ( nsTimerEvent ) ; <NEW_LINE> MOZ_ASSERT ( gThread -> IsOnTimerThread ( ) , <NEW_LINE> "nsTimer must always be allocated on the timer thread" ) ; <NEW_LINE> PR_ATOMIC_INCREMENT ( & sAllocatorUsers ) ; <NEW_LINE> }
yyg -> yy_hold_char = * ++ yyg -> yy_c_buf_p ; <NEW_LINE> if ( c == '\n' ) <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> do { yylineno ++ ; <NEW_LINE> yycolumn = 0 ; <NEW_LINE> } while ( 0 )
return 0 ; <NEW_LINE> } <NEW_LINE> <START_VULN> bool InputHandler::shouldRequestSpellCheckingOptionsForPoint ( Platform::IntPoint & point , const Element * touchedElement , imf_sp_text_t & spellCheckingOptionRequest ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( ! isActiveTextEdit ( ) ) <NEW_LINE> return false ;
extern const base::Feature kAffiliationBasedMatching ; <NEW_LINE> extern const base::Feature kHtmlBasedUsernameDetector ; <NEW_LINE> <START_VULN> extern const base::Feature kEnableManualFallbacksFilling ; <NEW_LINE> <END_VULN> extern const base::Feature kEnableManualFallbacksFillingStandalone ; <NEW_LINE> extern const base::Feature kEnableManualFallbacksGeneration ; <NEW_LINE> extern const base::Feature kEnableManualPasswordGeneration ;
if ( str [ 0 ] == ' ( ' ) <NEW_LINE> { <NEW_LINE> <START_VULN> ascii = malloc ( strlen ( str ) + 1 ) ; <NEW_LINE> <END_VULN> strncpy ( ascii , str , strlen ( str ) + 1 ) ; <NEW_LINE> return ascii ; <NEW_LINE> }
if ( flip & 1 ) col = iwidth - 1 - col ; <NEW_LINE> return row * iwidth + col ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 10487 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> void CLASS tiff_set ( ushort * ntag , <NEW_LINE> ushort tag , ushort type , int count , int val ) <NEW_LINE> {
{ <NEW_LINE> struct crypto_report_akcipher rakcipher ; <NEW_LINE> <START_VULN> strlcpy ( rakcipher . type , "akcipher" , sizeof ( rakcipher . type ) ) ; <NEW_LINE> <END_VULN> if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , <NEW_LINE> sizeof ( struct crypto_report_akcipher ) , & rakcipher ) )
xmlNodePtr cur ) <NEW_LINE> { <NEW_LINE> if ( ( ctxt == NULL ) || ( ctxt -> context == NULL ) ) return ( NULL ) ; <NEW_LINE> <START_VULN> if ( ( ctxt -> context -> node -> type == XML_ATTRIBUTE_NODE ) || <NEW_LINE> ( ctxt -> context -> node -> type == XML_NAMESPACE_DECL ) ) <NEW_LINE>return ( NULL ) ; <NEW_LINE> <END_VULN> if ( cur == NULL ) { <NEW_LINE> cur = ctxt -> context -> node ; <NEW_LINE> if ( cur == NULL ) <NEW_LINE> return ( NULL ) ; <NEW_LINE> ctxt -> ancestor = cur -> parent ; <NEW_LINE> } <NEW_LINE> if ( ( cur -> prev != NULL ) && ( cur -> prev -> type == XML_DTD_NODE ) )
return result ; <NEW_LINE> } <NEW_LINE> <START_VULN> long mkvparser::UnserializeFloat ( IMkvReader * pReader , long long pos , <NEW_LINE>long long size_ , double & result ) { <NEW_LINE>assert ( pReader ) ; <NEW_LINE>assert ( pos >= 0 ) ; <NEW_LINE><NEW_LINE>if ( ( size_ != 4 ) && ( size_ != 8 ) ) <NEW_LINE> <END_VULN> return E_FILE_FORMAT_INVALID ; <NEW_LINE> const long size = static_cast < long > ( size_ ) ;
cx -> free ( ( void * ) obj -> getFlatClosureUpvars ( ) ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> if ( FUN_INTERPRETED ( fun ) && fun -> u . i . script ) <NEW_LINE> <START_VULN> js_DestroyScript ( cx , fun -> u . i . script ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> int <NEW_LINE> JSFunction::sharpSlotBase ( JSContext * cx ) <NEW_LINE> { <NEW_LINE> #if JS_HAS_SHARP_VARS <NEW_LINE> JSAtom * name = js_Atomize ( cx , "#array" , 6 , 0 ) ; <NEW_LINE> if ( name ) { <NEW_LINE> uintN index = uintN ( - 1 ) ;
switch ( mState ) <NEW_LINE> { <NEW_LINE> case mState_ASCII: <NEW_LINE> if ( 0x1b == * src ) <NEW_LINE> { <NEW_LINE> mLastLegalState = mState ; <NEW_LINE> mState = mState_ESC ; <NEW_LINE> } else if ( * src & 0x80 ) { <NEW_LINE> <START_VULN> goto error2 ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> if ( CHECK_OVERRUN ( dest , destEnd , 1 ) ) <NEW_LINE> goto error1 ; <NEW_LINE> * dest ++ = ( PRUnichar ) * src ; <NEW_LINE> } <NEW_LINE> break ; <NEW_LINE> case mState_ESC:
{ <NEW_LINE> #ifdef DEBUG <NEW_LINE> for ( size_t i = 0 ; i != sizeof ( * this ) ; ++ i ) <NEW_LINE> JS_ASSERT ( reinterpret_cast < uint8 * > ( this ) [ i ] == 0 ) ; <NEW_LINE> #endif <NEW_LINE> if ( ! stackSpace . init ( ) ) <NEW_LINE> return false ; <NEW_LINE> #ifdef JS_TRACER <NEW_LINE> <START_VULN> InitJIT ( & traceMonitor ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef JS_METHODJIT <NEW_LINE> jmData . Initialize ( ) ; <NEW_LINE> #endif <NEW_LINE> dtoaState = js_NewDtoaState ( ) ; <NEW_LINE> if ( ! dtoaState ) { <NEW_LINE> finish ( ) ; <NEW_LINE> return false ; <NEW_LINE> }
} <NEW_LINE> JS::Rooted < JSObject * > proto ( cx ) ; <NEW_LINE> JS::Rooted < JS::Value > val ( cx ) ; <NEW_LINE> if ( ! ::JS_LookupPropertyWithFlags ( cx , global , className . get ( ) , 0 , & val ) ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> <START_VULN> if ( val . isObject ( ) ) { <NEW_LINE> <END_VULN> * aNew = false ; <NEW_LINE> proto = & val . toObject ( ) ; <NEW_LINE> } else { <NEW_LINE> * aNew = true ; <NEW_LINE> if ( ! c ) { <NEW_LINE> c = nsXBLService::getClass ( xblKey ) ;
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File: apprentice . c , v 1 . 226 2014 / 11 / 28 02:35:05 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #include "magic . h"
cur ++ ; <NEW_LINE> } <NEW_LINE> if ( uri != NULL ) <NEW_LINE> <START_VULN> uri -> port = port & INT_MAX ; <NEW_LINE> <END_VULN> * str = cur ; <NEW_LINE> return ( 0 ) ; <NEW_LINE> }
NetInc , h -> content -> length + h -> content -> offset - 1 ) ; <NEW_LINE> <START_VULN> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; <NEW_LINE> <END_VULN> if ( ! msg -> fp ) <NEW_LINE> {
<START_VULN> class AutocompleteController : public ACProviderListener { <NEW_LINE> <END_VULN> public: <NEW_LINE> static const int kNoItemSelected ;
} <NEW_LINE> LOCAL ( boolean ) <NEW_LINE> get_sos ( j_decompress_ptr cinfo ) <NEW_LINE> { <NEW_LINE> INT32 length ; <NEW_LINE> <START_VULN> int i , ci , n , c , cc ; <NEW_LINE> <END_VULN> jpeg_component_info * compptr ; <NEW_LINE> INPUT_VARS ( cinfo ) ; <NEW_LINE> if ( ! cinfo -> marker -> saw_SOF ) <NEW_LINE> ERREXIT ( cinfo , JERR_SOS_NO_SOF ) ; <NEW_LINE> INPUT_2BYTES ( cinfo , length , return FALSE ) ;
i4_row - = 1 ; <NEW_LINE> <START_VULN> if ( i4_prev_row != i4_row ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( i4_start_row != - 1 )
JS_GetGlobalFromScript ( aScriptObject ) , <NEW_LINE> getter_AddRefs ( principal ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> rv = sSecurityManager -> PushContextPrincipal ( mContext , nsnull , principal ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> nsJSContext::TerminationFuncHolder holder ( this ) ; <NEW_LINE> <START_VULN> JSAutoRequest ar ( mContext ) ; <NEW_LINE> <END_VULN> ++ mExecuteDepth ; <NEW_LINE> jsval val ; <NEW_LINE> bool ok = JS_ExecuteScript ( mContext , aScopeObject , aScriptObject , & val ) ; <NEW_LINE> if ( ok ) {
else { <NEW_LINE> type = GamepadEvent::HatY ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> self -> mGamepads [ i ] . hatState [ which ] . x = hatState . x ; <NEW_LINE> self -> mGamepads [ i ] . hatState [ which ] . y = hatState . y ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( type != GamepadEvent::Unknown ) { <NEW_LINE> <END_VULN> nsRefPtr < GamepadEvent > event = <NEW_LINE> new GamepadEvent ( self -> mGamepads [ i ] , type , which , data . dwData ) ; <NEW_LINE> NS_DispatchToMainThread ( event , NS_DISPATCH_NORMAL ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> items -- ; <NEW_LINE> } <NEW_LINE> }
if ( ConstructorMode::current ( ) == ConstructorMode::WrapExistingObject ) <NEW_LINE> return args . Holder ( ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , str1 , MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ;
static JSValue getDataViewMember ( ExecState * exec , DataView * imp , DataViewAccessType type ) <NEW_LINE> { <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> ExceptionCode ec = 0 ; <NEW_LINE> unsigned byteOffset = exec -> argument ( 0 ) . toUInt32 ( exec ) ; <NEW_LINE> if ( exec -> hadException ( ) )
png_text_compress_init ( & comp , ( png_const_bytep ) text , strlen ( text ) ) ; <NEW_LINE> <START_VULN> if ( compression ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( png_text_compress ( png_ptr , png_iTXt , & comp , prefix_len ) != Z_OK ) <NEW_LINE> png_error ( png_ptr , png_ptr -> zstream . msg ) ;
#if CHAR_BIT == 8 && UCHAR_MAX == 255 <NEW_LINE> typedef unsigned char png_byte ; <NEW_LINE> #else <NEW_LINE> <START_VULN> # error "libpng requires 8 bit bytes" <NEW_LINE> <END_VULN> #endif <NEW_LINE> #if INT_MIN == - 32768 && INT_MAX == 32767
nsresult <NEW_LINE> xpc_EvalInSandbox ( JSContext * cx , JSObject * sandbox , const nsAString & source , <NEW_LINE> <START_VULN> const char * filename , PRInt32 lineNo , jsval * rval ) ; <NEW_LINE> <END_VULN> #endif
bool mListenerEnabled ; <NEW_LINE> bool mReturnInEmptyLIKillsList ; <NEW_LINE> bool mDidDeleteSelection ; <NEW_LINE> bool mDidRangedDelete ; <NEW_LINE> bool mRestoreContentEditableCount ; <NEW_LINE> nsRefPtr < nsRange > mUtilRange ; <NEW_LINE> PRUint32 mJoinOffset ; <NEW_LINE> nsCOMPtr < nsIDOMNode > mNewBlock ; <NEW_LINE> <START_VULN> nsRangeStore mRangeItem ; <NEW_LINE> <END_VULN> StyleCache mCachedStyles [ SIZE_STYLE_TABLE ] ; <NEW_LINE> } ; <NEW_LINE> #endif
reactor_object_t * object = reactor_register ( reactor , fd , NULL , NULL , NULL ) ; <NEW_LINE> spawn_reactor_thread ( reactor ) ; <NEW_LINE> <START_VULN> usleep ( 50 * 1000 ) ; <NEW_LINE> <END_VULN> reactor_unregister ( object ) ; <NEW_LINE> reactor_stop ( reactor ) ;
rv = mOwnerContent -> NodePrincipal ( ) -> GetURI ( getter_AddRefs ( referrer ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> loadInfo -> SetReferrer ( referrer ) ; <NEW_LINE> bool tmpState = mNeedsAsyncDestroy ; <NEW_LINE> mNeedsAsyncDestroy = true ; <NEW_LINE> <START_VULN> rv = mDocShell -> LoadURI ( mURIToLoad , loadInfo , <NEW_LINE> <END_VULN> nsIWebNavigation::LOAD_FLAGS_NONE , false ) ; <NEW_LINE> mNeedsAsyncDestroy = tmpState ; <NEW_LINE> mURIToLoad = nullptr ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> }
ASSERT ( beforeChild -> isAnonymousBlock ( ) ) ; <NEW_LINE> ASSERT ( beforeChild -> parent ( ) == this ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> } else if ( ! childrenInline ( ) && ( newChild -> isFloatingOrPositioned ( ) || newChild -> isInline ( ) ) ) { <NEW_LINE> <END_VULN>
#include "vp9 / common / vp9_common . h" <NEW_LINE> #include "vp9 / encoder / vp9_extend . h" <NEW_LINE> #include "vp9 / encoder / vp9_lookahead . h" <NEW_LINE> <START_VULN> #include "vp9 / encoder / vp9_onyx_int . h" <NEW_LINE><NEW_LINE>struct lookahead_ctx { <NEW_LINE>unsigned int max_sz ; <NEW_LINE>unsigned int sz ; <NEW_LINE>unsigned int read_idx ; <NEW_LINE>unsigned int write_idx ; <NEW_LINE>struct lookahead_entry * buf ; <NEW_LINE> } ; <NEW_LINE><NEW_LINE> <END_VULN> static struct lookahead_entry * pop ( struct lookahead_ctx * ctx ,
ind = 2 ; <NEW_LINE> <START_VULN> while ( ibuf [ ind ] == 0x01 ) { <NEW_LINE> <END_VULN> if ( ibuf [ ind + 1 ] == 0xFE ) { <NEW_LINE> gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; <NEW_LINE> sc_log ( card -> ctx , "Key container % d is allocated and uses key_ref % d" ,
int id ; <NEW_LINE> } ; <NEW_LINE> #include < string . h > <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #ifdef __GNUC__ <NEW_LINE> __inline
return sAllocator -> Alloc ( aSize ) ; <NEW_LINE> } <NEW_LINE> void operator delete ( void * aPtr ) <NEW_LINE> { <NEW_LINE> sAllocator -> Free ( aPtr ) ; <NEW_LINE> DeleteAllocatorIfNeeded ( ) ; <NEW_LINE> } <NEW_LINE> private: <NEW_LINE> <START_VULN> nsTimerEvent ( ) ; <NEW_LINE> <END_VULN> ~ nsTimerEvent ( ) <NEW_LINE> { <NEW_LINE> MOZ_COUNT_DTOR ( nsTimerEvent ) ; <NEW_LINE> MOZ_ASSERT ( ! sCanDeleteAllocator || sAllocatorUsers > 0 , <NEW_LINE> "This will result in us attempting to deallocate the nsTimerEvent allocator twice" ) ; <NEW_LINE> sAllocatorUsers -- ; <NEW_LINE> }
} <NEW_LINE> static int ceph_x_decrypt ( struct ceph_crypto_key * secret , <NEW_LINE> <START_VULN> void ** p , void * end , void * obuf , size_t olen ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct ceph_x_encrypt_header head ; <NEW_LINE> size_t head_len = sizeof ( head ) ;
if ( ( success = pb_get_encoded_size ( & encoded_size , RIL_SIM_SAP_DISCONNECT_REQ_fields , <NEW_LINE> & disconnectReq ) ) && encoded_size <= INT32_MAX ) { <NEW_LINE> buffer_size = encoded_size + sizeof ( uint32_t ) ; <NEW_LINE> <START_VULN> uint8_t buffer [ buffer_size ] ; <NEW_LINE> <END_VULN> written_size = htonl ( ( uint32_t ) encoded_size ) ; <NEW_LINE> ostream = pb_ostream_from_buffer ( buffer , buffer_size ) ; <NEW_LINE> pb_write ( & ostream , ( uint8_t * ) & written_size , sizeof ( written_size ) ) ;
parser -> m_processor = prologProcessor ; <NEW_LINE> return doProlog ( parser , parser -> m_encoding , s , end , tok , next , nextPtr , <NEW_LINE> <START_VULN> ( XML_Bool ) ! parser -> m_parsingStatus . finalBuffer ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static enum XML_Error PTRCALL
#endif <NEW_LINE> #if ENABLE ( SPELLCHECK ) <NEW_LINE> <START_VULN> WebKit::EditorClient * client = static_cast < WebKit::EditorClient * > ( core ( webView ) -> editorClient ( ) ) ; <NEW_LINE>static_cast < WebKit::TextCheckerClientEnchant * > ( client -> textChecker ( ) ) -> updateSpellCheckingLanguage ( defaultSpellCheckingLanguages ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> #if ENABLE ( WEBGL )
} ; <NEW_LINE> <START_VULN> const interp_kernel vp9_filteredinterp_filters750 [ ( 1 << SUBPEL_BITS ) ] = { <NEW_LINE> <END_VULN> { 2 , - 11 , 25 , 96 , 25 , - 11 , 2 , 0 } , <NEW_LINE> { 2 , - 11 , 22 , 96 , 28 , - 11 , 2 , 0 } , <NEW_LINE> { 2 , - 10 , 19 , 95 , 31 , - 11 , 2 , 0 } ,
if ( xdr -> mode == JSXDR_DECODE ) { <NEW_LINE> if ( idx != uint32 ( - 1 ) ) { <NEW_LINE> <START_VULN> JS_ASSERT ( size_t ( idx ) < xdr -> state -> atoms . length ( ) ) ; <NEW_LINE> * atomp = xdr -> state -> atoms [ idx ] ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> uint32 len ; <NEW_LINE> if ( ! JS_XDRUint32 ( xdr , & len ) )
mCurrentSampleTime = mozilla::TimeStamp::Now ( ) ; <NEW_LINE> nsSMILTimeContainer::Resume ( aType ) ; <NEW_LINE> if ( wasPaused && ! mPauseState && mChildContainerTable . Count ( ) ) { <NEW_LINE> Sample ( ) ; <NEW_LINE> <START_VULN> if ( mAnimationElementTable . Count ( ) ) { <NEW_LINE>StartSampling ( GetRefreshDriverForDoc ( mDocument ) ) ; <NEW_LINE> } else { <NEW_LINE>mDeferredStartSampling = PR_TRUE ; <NEW_LINE> } <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> nsSMILTime <NEW_LINE> nsSMILAnimationController::GetParentTime ( ) const <NEW_LINE> { <NEW_LINE> return ( nsSMILTime ) ( mCurrentSampleTime - mStartTime ) . ToMilliseconds ( ) ; <NEW_LINE> }
} <NEW_LINE> <START_VULN> CWD_API void realpath_cache_del ( const char * path , int path_len ) <NEW_LINE> <END_VULN> { <NEW_LINE> zend_ulong key = realpath_cache_key ( path , path_len ) ; <NEW_LINE> zend_ulong n = key % ( sizeof ( CWDG ( realpath_cache ) ) / sizeof ( CWDG ( realpath_cache ) [ 0 ] ) ) ;
} <NEW_LINE> JSBool <NEW_LINE> js_json_stringify ( JSContext * cx , uintN argc , jsval * vp ) <NEW_LINE> { <NEW_LINE> jsval * argv = vp + 2 ; <NEW_LINE> JSObject * replacer = NULL ; <NEW_LINE> jsval space = JSVAL_NULL ; <NEW_LINE> <START_VULN> JSAutoTempValueRooter ( cx , replacer ) ; <NEW_LINE>JSAutoTempValueRooter ( cx , 1 , & space ) ; <NEW_LINE> <END_VULN> if ( ! JS_ConvertArguments ( cx , argc , argv , "v / o v" , vp , & replacer , & space ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> JSCharBuffer cb ( cx ) ; <NEW_LINE> if ( ! js_Stringify ( cx , vp , replacer , space , cb ) )
GC_REFCOUNT ( ht ) = 1 ; <NEW_LINE> GC_TYPE_INFO ( ht ) = IS_ARRAY ; <NEW_LINE> ht -> u . flags = ( persistent ? HASH_FLAG_PERSISTENT : 0 ) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS ; <NEW_LINE> <START_VULN> ht -> nTableSize = zend_hash_check_size ( nSize ) ; <NEW_LINE> <END_VULN> ht -> nTableMask = HT_MIN_MASK ; <NEW_LINE> HT_SET_DATA_ADDR ( ht , & uninitialized_bucket ) ; <NEW_LINE> ht -> nNumUsed = 0 ; <NEW_LINE> ht -> nNumOfElements = 0 ; <NEW_LINE> ht -> nInternalPointer = HT_INVALID_IDX ; <NEW_LINE> ht -> nNextFreeElement = 0 ; <NEW_LINE> ht -> pDestructor = pDestructor ; <NEW_LINE> } <NEW_LINE> static void ZEND_FASTCALL zend_hash_packed_grow ( HashTable * ht )
{ <NEW_LINE> if ( Op ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( WalkState -> AscendingCallback != NULL ) <NEW_LINE> <END_VULN> { <NEW_LINE> WalkState -> Op = Op ; <NEW_LINE> WalkState -> OpInfo = AcpiPsGetOpcodeInfo ( Op -> Common . AmlOpcode ) ;
const GURL & url ) const = 0 ; <NEW_LINE> virtual bool UseWebUIForURL ( BrowserContext * browser_context , <NEW_LINE> const GURL & url ) const = 0 ; <NEW_LINE> virtual bool UseWebUIBindingsForURL ( BrowserContext * browser_context , <NEW_LINE> const GURL & url ) const = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE>virtual bool HasWebUIScheme ( const GURL & url ) const = 0 ; <NEW_LINE> <END_VULN>
if ( cText -> buf -> len < minLength ) { <NEW_LINE> <START_VULN> SSL_DBG ( ( " % d: SSL3 [ % d ] : HandleRecord , record too small . " , <NEW_LINE>SSL_GETPID ( ) , ss -> fd ) ) ; <NEW_LINE><NEW_LINE>ssl_ReleaseSpecReadLock ( ss ) ; <NEW_LINE>SSL3_SendAlert ( ss , alert_fatal , bad_record_mac ) ; <NEW_LINE><NEW_LINE>PORT_SetError ( SSL_ERROR_BAD_MAC_READ ) ; <NEW_LINE>return SECFailure ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( cipher_def -> type == type_block &&
<START_VULN> if ( ctx -> max_sz == 1 && active_map && ! flags ) { <NEW_LINE> <END_VULN> for ( row = 0 ; row < mb_rows ; ++ row ) { <NEW_LINE> col = 0 ;
RemoveLetterFrames ( presContext , mPresShell , frameManager , <NEW_LINE> containingBlock ) ; <NEW_LINE> childFrame = mPresShell -> GetPrimaryFrameFor ( aChild ) ; <NEW_LINE> <START_VULN> if ( ! childFrame ) { <NEW_LINE> <END_VULN> frameManager -> ClearUndisplayedContentIn ( aChild , aContainer ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> parentFrame = childFrame -> GetParent ( ) ; <NEW_LINE> #ifdef NOISY_FIRST_LETTER <NEW_LINE> printf ( " == > revised parentFrame = " ) ; <NEW_LINE> nsFrame::ListTag ( stdout , parentFrame ) ;
the match again at the same point . If this fails ( picked up above ) we <NEW_LINE> advance to the next character . * / <NEW_LINE> g_notempty = ( offsets [ 1 ] == offsets [ 0 ] ) ? PCRE_NOTEMPTY | PCRE_ANCHORED : 0 ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> start_offset = offsets [ 1 ] ; <NEW_LINE> }
size_t <NEW_LINE> mozJSComponentLoader::SizeOfIncludingThis ( MallocSizeOf aMallocSizeOf ) <NEW_LINE> { <NEW_LINE> size_t amount = aMallocSizeOf ( this ) ; <NEW_LINE> amount += mModules . SizeOfExcludingThis ( DataEntrySizeOfExcludingThis , aMallocSizeOf ) ; <NEW_LINE> amount += mImports . SizeOfExcludingThis ( ClassEntrySizeOfExcludingThis , aMallocSizeOf ) ; <NEW_LINE> amount += mInProgressImports . SizeOfExcludingThis ( DataEntrySizeOfExcludingThis , aMallocSizeOf ) ; <NEW_LINE> <START_VULN> amount += mThisObjects . SizeOfExcludingThis ( nullptr , aMallocSizeOf ) ; <NEW_LINE> <END_VULN> return amount ; <NEW_LINE> } <NEW_LINE> #ifdef HAVE_PR_MEMMAP <NEW_LINE> class FileAutoCloser <NEW_LINE> {
} <NEW_LINE> } <NEW_LINE> <START_VULN> char buf [ BUFFER_SIZE ] ; <NEW_LINE>read_buf ( g_procs [ id ] . m_fin , buf ) ; <NEW_LINE>if ( strncmp ( buf , "error" , 5 ) == 0 ) { <NEW_LINE>read_buf ( g_procs [ id ] . m_fin , buf ) ; <NEW_LINE>sscanf ( buf , " % d" , & errno ) ; <NEW_LINE> <END_VULN> if ( error_send ) {
{ <NEW_LINE> recalcSectionsIfNeeded ( ) ; <NEW_LINE> <START_VULN> if ( isPositioned ( ) ) <NEW_LINE> <END_VULN> computePositionedLogicalWidth ( ) ; <NEW_LINE> RenderBlock * cb = containingBlock ( ) ;
if ( do_refine ) { <NEW_LINE> const int search_range = 8 ; <NEW_LINE> MV best_mv = * dst_mv ; <NEW_LINE> <START_VULN> thissme = cpi -> refining_search_sad ( x , & best_mv , sadpb , search_range , <NEW_LINE>fn_ptr , x -> nmvjointcost , x -> mvcost , <NEW_LINE>ref_mv ) ; <NEW_LINE> <END_VULN> if ( thissme < INT_MAX ) <NEW_LINE> thissme = vp9_get_mvpred_var ( x , & best_mv , ref_mv , fn_ptr , 1 ) ; <NEW_LINE> if ( thissme < bestsme ) {
line_len = strcspn ( buf , "\r\n" ) ; <NEW_LINE> buf [ line_len ] = '\0' ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> intern -> u . file . current_line = buf ; <NEW_LINE> intern -> u . file . current_line_len = line_len ; <NEW_LINE> }
nsCOMArray < nsIDOMElement > ourParams ; <NEW_LINE> <START_VULN> nsCOMPtr < nsIDOMElement > mydomElement = do_QueryInterface ( mContent ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( mydomElement , NS_ERROR_NO_INTERFACE ) ; <NEW_LINE> nsCOMPtr < nsIPluginInstanceOwner > kungFuDeathGrip ( this ) ; <NEW_LINE> nsCOMPtr < nsIDOMHTMLCollection > allParams ; <NEW_LINE> NS_NAMED_LITERAL_STRING ( xhtml_ns , "http: <NEW_LINE> mydomElement -> GetElementsByTagNameNS ( xhtml_ns , NS_LITERAL_STRING ( "param" ) ,
nsRefPtr < nsRange > mMaintainRange ; <NEW_LINE> nsSelectionAmount mMaintainedAmount ; <NEW_LINE> PRInt32 mBatching ; <NEW_LINE> <START_VULN> nsIContent * mLimiter ; <NEW_LINE>nsIContent * mAncestorLimiter ; <NEW_LINE><NEW_LINE> <END_VULN> nsIPresShell * mShell ; <NEW_LINE> PRInt16 mSelectionChangeReason ; <NEW_LINE> PRInt16 mDisplaySelection ; <NEW_LINE> HINT mHint ; <NEW_LINE> #ifdef IBMBIDI <NEW_LINE> PRUint8 mCaretBidiLevel ;
void wrapPendingException ( ) ; <NEW_LINE> private: <NEW_LINE> js::frontend::ParseMapPool * parseMapPool_ ; <NEW_LINE> public: <NEW_LINE> <START_VULN> JSSharpObjectMap sharpObjectMap ; <NEW_LINE>js::BusyArraysSet busyArrays ; <NEW_LINE> <END_VULN> JSArgumentFormatMap * argumentFormatMap ; <NEW_LINE> char * lastMessage ;
LayoutSize containerOffset = offsetFromContainer ( o , LayoutPoint ( ) ) ; <NEW_LINE> <START_VULN> if ( ! style ( ) -> isPositioned ( ) && o -> hasColumns ( ) ) { <NEW_LINE> <END_VULN> RenderBlock * block = static_cast < RenderBlock * > ( o ) ; <NEW_LINE> LayoutPoint point ( roundedLayoutPoint ( transformState . mappedPoint ( ) ) ) ; <NEW_LINE> point - = containerOffset ;
if ( cpi -> cyclic_refresh_mode_enabled ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( cpi -> current_layer == 0 ) <NEW_LINE> <END_VULN> cyclic_background_refresh ( cpi , Q , 0 ) ; <NEW_LINE> else <NEW_LINE> disable_segmentation ( cpi ) ;
| Sara Golemon < pollita@php . net > | <NEW_LINE> + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- + <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "php . h" <NEW_LINE> #include "php_globals . h"
# define KERNEL_STACK_SIZE_ORDER 0 <NEW_LINE> #endif <NEW_LINE> <START_VULN> #define IA64_RBS_OFFSET ( ( IA64_TASK_SIZE + IA64_THREAD_INFO_SIZE + 15 ) & ~ 15 ) <NEW_LINE> <END_VULN> #define IA64_STK_OFFSET ( ( 1 << KERNEL_STACK_SIZE_ORDER ) * PAGE_SIZE ) <NEW_LINE> #define KERNEL_STACK_SIZE IA64_STK_OFFSET
else <NEW_LINE> { <NEW_LINE> vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> q += 16 ;
<START_VULN> tok = stok ( value , " , " , & value ) ; <NEW_LINE> <END_VULN> if ( * tok != ' - ' ) { <NEW_LINE> range -> start = ( ssize ) stoi ( tok ) ; <NEW_LINE> } else {
r = sc_check_sw ( card , sm -> sw1 , sm -> sw2 ) ; <NEW_LINE> if ( r == SC_SUCCESS ) { <NEW_LINE> if ( exdata -> sm ) { <NEW_LINE> <START_VULN> if ( 0 != decrypt_response ( card , sm -> resp , plain -> resp , & len ) ) <NEW_LINE> <END_VULN> return SC_ERROR_CARD_CMD_FAILED ; <NEW_LINE> } <NEW_LINE> else {
return res ; <NEW_LINE> } <NEW_LINE> <START_VULN> mp_err <NEW_LINE> <END_VULN> ec_GFp_pt_add_jm_aff ( const mp_int * px , const mp_int * py , const mp_int * pz , <NEW_LINE> const mp_int * paz4 , const mp_int * qx , <NEW_LINE> const mp_int * qy , mp_int * rx , mp_int * ry , mp_int * rz , <NEW_LINE> mp_int * raz4 , mp_int scratch [ ] , const ECGroup * group ) <NEW_LINE> { <NEW_LINE> mp_err res = MP_OKAY ; <NEW_LINE> mp_int * A , * B , * C , * D , * C2 , * C3 ;
size_t <NEW_LINE> extent ; <NEW_LINE> <START_VULN> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <NEW_LINE> <END_VULN> { <NEW_LINE> memory = RelinquishMagickMemory ( memory ) ; <NEW_LINE> return ( ( void * ) NULL ) ;
void RTCSessionDescriptionRequestImpl::requestFailed ( const String & error ) <NEW_LINE> { <NEW_LINE> if ( m_errorCallback ) <NEW_LINE> <START_VULN> m_errorCallback -> handleEvent ( error ) ; <NEW_LINE> <END_VULN> clear ( ) ; <NEW_LINE> }
void ResetLoadingState ( ) ; <NEW_LINE> <START_VULN> FeaturePolicy * get_feature_policy ( ) { return feature_policy_ . get ( ) ; } <NEW_LINE> <END_VULN>
EXPECT_TRUE ( animationCanBeTranslated ( values , animation . get ( ) ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> TEST ( AnimationTranslationUtilTest , createTransformAnimationWithSingularMatrix ) <NEW_LINE> <END_VULN> { <NEW_LINE> const double duration = 1 ; <NEW_LINE> WebCore::KeyframeValueList values ( AnimatedPropertyWebkitTransform ) ;
void CloseFrame ( ) ; <NEW_LINE> <START_VULN> void TabDetachedAtImpl ( TabContents * contents , int index , DetachType type ) ; <NEW_LINE> <END_VULN> void ReloadInternal ( WindowOpenDisposition disposition , bool ignore_cache ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: floor backend 0 implementation <NEW_LINE> <START_VULN> last mod: $ Id: floor0 . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #include < stdlib . h > <NEW_LINE> #include < string . h > <NEW_LINE> #include < math . h > <NEW_LINE> #include < ogg / ogg . h > <NEW_LINE> #include "vorbis / codec . h"
uint64 GetAndClearTaskWasRunOnQueueBitmap ( ) ; <NEW_LINE> <START_VULN> void SetTimeSourceForTesting ( scoped_ptr < TimeSource > time_source ) ; <NEW_LINE> <END_VULN> void SetWorkBatchSizeForTesting ( size_t work_batch_size ) ; <NEW_LINE> TaskQueueManager * GetTaskQueueManagerForTesting ( ) ;
if ( compression_count > 0 ) { <NEW_LINE> compression_entries_ = <NEW_LINE> <START_VULN> new ( std::nothrow ) ContentCompression * [ compression_count ] ; <NEW_LINE> <END_VULN> if ( ! compression_entries_ ) <NEW_LINE> return - 1 ; <NEW_LINE> compression_entries_end_ = compression_entries_ ;
if ( NS_FAILED ( mInternalError ) && ! mResponseMsg . IsEmpty ( ) ) { <NEW_LINE> nsCOMPtr < nsIPrompt > prompter ; <NEW_LINE> mChannel -> GetCallback ( prompter ) ; <NEW_LINE> <START_VULN> if ( prompter ) <NEW_LINE>prompter -> Alert ( nullptr , NS_ConvertASCIItoUTF16 ( mResponseMsg ) . get ( ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsresult broadcastErrorCode = mControlStatus ; <NEW_LINE> if ( NS_SUCCEEDED ( broadcastErrorCode ) ) <NEW_LINE> broadcastErrorCode = mInternalError ; <NEW_LINE> mInternalError = broadcastErrorCode ;
{ <NEW_LINE> uipc_main . read_set = uipc_main . active_set ; <NEW_LINE> <START_VULN> result = select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ; <NEW_LINE> <END_VULN> if ( result == 0 ) <NEW_LINE> {
#define MAXstring 64		 <NEW_LINE> #define MAGICNO		0xF11E041C <NEW_LINE> <START_VULN> #define VERSIONNO	11 <NEW_LINE> <END_VULN> #define FILE_MAGICSIZE	248 <NEW_LINE> #define	FILE_LOAD	0
break ; <NEW_LINE> case ARPOP_INVREPLY: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " % s at % s" , <NEW_LINE>linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <NEW_LINE>ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> default:
false , <NEW_LINE> violatedDirective ) ) { <NEW_LINE> bool okToSendAncestor = NS_SecurityCompareURIs ( ancestorsArray [ a ] , mSelfURI , true ) ; <NEW_LINE> this -> AsyncReportViolation ( ( okToSendAncestor ? ancestorsArray [ a ] : nullptr ) , <NEW_LINE> <START_VULN> mSelfURI , <NEW_LINE> <END_VULN> violatedDirective , <NEW_LINE> i , <NEW_LINE> EmptyString ( ) , <NEW_LINE> EmptyString ( ) , <NEW_LINE> EmptyString ( ) , <NEW_LINE> 0 ) ; <NEW_LINE> * outPermitsAncestry = false ; <NEW_LINE> }
int aDelayMs ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( aConnector ) ; <NEW_LINE> MOZ_ASSERT ( NS_IsMainThread ( ) ) ; <NEW_LINE> if ( mImpl ) { <NEW_LINE> NS_WARNING ( "Socket already connecting / connected ! " ) ; <NEW_LINE> return false ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsCString addr ; <NEW_LINE>addr . Assign ( aAddress ) ; <NEW_LINE> <END_VULN> mImpl = new UnixSocketImpl ( this , aConnector , addr ) ; <NEW_LINE> MessageLoop * ioLoop = XRE_GetIOMessageLoop ( ) ; <NEW_LINE> mConnectionStatus = SOCKET_CONNECTING ; <NEW_LINE> if ( aDelayMs > 0 ) { <NEW_LINE> ioLoop -> PostDelayedTask ( FROM_HERE , new SocketConnectTask ( mImpl ) , aDelayMs ) ; <NEW_LINE> } else { <NEW_LINE> ioLoop -> PostTask ( FROM_HERE , new SocketConnectTask ( mImpl ) ) ; <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> <START_VULN> lf -> filter_level = filt_best ; <NEW_LINE> <END_VULN> } <NEW_LINE> void vp9_pick_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi ,
ND_PRINT ( ( ndo , " , length % u" , length ) ) ; <NEW_LINE> return ; <NEW_LINE> trunc: <NEW_LINE> <START_VULN> ND_PRINT ( ( ndo , " [ | icmp6 ] " ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static const struct udphdr *
NS_ERROR ( "Failed to remove directory ! " ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> aQuotaManager -> RemoveQuotaForPattern ( mOriginOrPattern ) ; <NEW_LINE> <START_VULN> aQuotaManager -> UninitializeOriginsByPattern ( mOriginOrPattern ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> NS_IMPL_THREADSAFE_ISUPPORTS1 ( OriginClearRunnable , nsIRunnable ) <NEW_LINE> NS_IMETHODIMP <NEW_LINE> OriginClearRunnable::Run ( ) <NEW_LINE> { <NEW_LINE> PROFILER_LABEL ( "Quota" , "OriginClearRunnable::Run" ) ;
bc + candidates [ t ] [ i ] . col } ; <NEW_LINE> thissad = vfp -> sdf ( what -> buf , what -> stride , <NEW_LINE> get_buf_from_mv ( in_what , & this_mv ) , <NEW_LINE> <START_VULN> in_what -> stride , bestsad ) ; <NEW_LINE> <END_VULN> CHECK_BETTER <NEW_LINE> } <NEW_LINE> } else {
lastChunk = chunk , chunk = chunk -> mNextChunk ) { <NEW_LINE> to = chunk -> mTearOffs ; <NEW_LINE> XPCWrappedNativeTearOff * const end = chunk -> mTearOffs + <NEW_LINE> XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK ; <NEW_LINE> for ( to = chunk -> mTearOffs ; <NEW_LINE> to < end ; <NEW_LINE> to ++ ) { <NEW_LINE> if ( to -> GetInterface ( ) == aInterface ) { <NEW_LINE> <START_VULN> if ( needJSObject && ! to -> GetJSObject ( ) ) { <NEW_LINE> <END_VULN> AutoMarkingWrappedNativeTearOffPtr tearoff ( ccx , to ) ; <NEW_LINE> JSBool ok = InitTearOffJSObject ( ccx , to ) ; <NEW_LINE> to -> Unmark ( ) ; <NEW_LINE> if ( ! ok ) {
if ( async ) { <NEW_LINE> mState |= XML_HTTP_REQUEST_ASYNC ; <NEW_LINE> } else { <NEW_LINE> mState &= ~ XML_HTTP_REQUEST_ASYNC ; <NEW_LINE> } <NEW_LINE> mState &= ~ XML_HTTP_REQUEST_MPART_HEADERS ; <NEW_LINE> <START_VULN> nsCOMPtr < nsIDocument > doc = GetDocumentFromScriptContext ( mScriptContext ) ; <NEW_LINE> <END_VULN> nsCOMPtr < nsIURI > baseURI ; <NEW_LINE> if ( mBaseURI ) { <NEW_LINE> baseURI = mBaseURI ; <NEW_LINE> } <NEW_LINE> else if ( doc ) { <NEW_LINE> baseURI = doc -> GetBaseURI ( ) ; <NEW_LINE> }
virtual already_AddRefed < mozilla::dom::UndoManager > GetUndoManager ( ) ; <NEW_LINE> virtual bool UndoScope ( ) MOZ_OVERRIDE ; <NEW_LINE> virtual void SetUndoScope ( bool aUndoScope , mozilla::ErrorResult & aError ) MOZ_OVERRIDE ; <NEW_LINE> nsresult ClearDataset ( ) ; <NEW_LINE> <START_VULN> nsSize GetWidthHeightForImage ( imgIRequest * aImageRequest ) ; <NEW_LINE> <END_VULN> NS_FORWARD_NSIDOMNODE_TO_NSINODE <NEW_LINE> NS_FORWARD_NSIDOMELEMENT_TO_GENERIC <NEW_LINE> NS_IMETHOD GetId ( nsAString & aId ) MOZ_FINAL { <NEW_LINE> mozilla::dom::Element::GetId ( aId ) ;
addBorderOutsetVisualOverflow ( logicalVisualOverflow ) ; <NEW_LINE> for ( InlineBox * curr = firstChild ( ) ; curr ; curr = curr -> nextOnLine ( ) ) { <NEW_LINE> <START_VULN> if ( curr -> renderer ( ) -> isPositioned ( ) ) <NEW_LINE> <END_VULN> continue ; <NEW_LINE> if ( curr -> renderer ( ) -> isText ( ) ) {
ShelfContainerView * shelf_container_view_ = nullptr ; <NEW_LINE> <START_VULN> int space_for_icons_ = 0 ; <NEW_LINE> <END_VULN> ShelfView * shelf_view_ = nullptr ;
* <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #include "ssl . h" <NEW_LINE> #include "sslimpl . h" <NEW_LINE> #include "sslproto . h" <NEW_LINE> static const char * <NEW_LINE> ssl_GetCompressionMethodName ( SSLCompressionMethod compression ) <NEW_LINE> { <NEW_LINE> switch ( compression ) {
<START_VULN> struct control * control = png_voidcast ( struct control * , <NEW_LINE> <END_VULN> png_get_error_ptr ( png_ptr ) ) ; <NEW_LINE> return & control -> file ; <NEW_LINE> }
msg . msg_iov = & iov ; <NEW_LINE> iov . iov_len = size ; <NEW_LINE> iov . iov_base = ubuf ; <NEW_LINE> <START_VULN> msg . msg_name = ( struct sockaddr * ) & address ; <NEW_LINE>msg . msg_namelen = sizeof ( address ) ; <NEW_LINE> <END_VULN> if ( sock -> file -> f_flags & O_NONBLOCK ) <NEW_LINE> flags |= MSG_DONTWAIT ; <NEW_LINE> err = sock_recvmsg ( sock , & msg , size , flags ) ;
void ShadowRoot::setInnerHTML ( const String & markup , ExceptionCode & ec ) <NEW_LINE> { <NEW_LINE> <START_VULN> RefPtr < DocumentFragment > fragment = createFragmentFromSource ( markup , host ( ) , ec ) ; <NEW_LINE>if ( fragment ) <NEW_LINE> <END_VULN> replaceChildrenWithFragment ( this , fragment . release ( ) , ec ) ; <NEW_LINE> }
else if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! ( png_ptr -> mode & PNG_HAVE_PLTE ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_crc_finish ( png_ptr , length ) ;
static void <NEW_LINE> <START_VULN> image_transform_ini_end ( PNG_CONST image_transform * this , <NEW_LINE> <END_VULN> transform_display * that ) <NEW_LINE> { <NEW_LINE> UNUSED ( this )
JSBool <NEW_LINE> js_DeflateStringToUTF8Buffer ( JSContext * cx , const jschar * src , size_t srclen , <NEW_LINE> <START_VULN> char * dst , size_t * dstlenp , bool useCESU8 ) <NEW_LINE> <END_VULN> { <NEW_LINE> size_t dstlen , i , origDstlen , utf8Len ; <NEW_LINE> jschar c , c2 ;
const int plane = planes [ i ] ; <NEW_LINE> const unsigned char * buf = img -> planes [ plane ] ; <NEW_LINE> const int stride = img -> stride [ plane ] ; <NEW_LINE> <START_VULN> const int w = vpx_img_plane_width ( img , plane ) ; <NEW_LINE> <END_VULN> const int h = vpx_img_plane_height ( img , plane ) ; <NEW_LINE> for ( y = 0 ; y < h ; ++ y ) {
} <NEW_LINE> if ( WouldTaintOrigin ( image , security_origin ) ) { <NEW_LINE> <START_VULN> exception_state . ThrowSecurityError ( "The cross - origin image at " + <NEW_LINE>url . ElidedString ( ) + <NEW_LINE>" may not be loaded . " ) ; <NEW_LINE> <END_VULN> return false ; <NEW_LINE> } <NEW_LINE> return true ;
nsINode * commonParent = nullptr ; <NEW_LINE> if ( aTarget && aRelatedTarget ) { <NEW_LINE> commonParent = <NEW_LINE> nsContentUtils::GetCommonAncestor ( aTarget , aRelatedTarget ) ; <NEW_LINE> } <NEW_LINE> nsIContent * current = aTarget ; <NEW_LINE> while ( current && current != commonParent ) { <NEW_LINE> <START_VULN> if ( ! current -> IsInNativeAnonymousSubtree ( ) ) { <NEW_LINE> <END_VULN> mTargets . AppendObject ( current ) ; <NEW_LINE> } <NEW_LINE> current = current -> GetParent ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> }
case FILE_BELDATE: <NEW_LINE> p -> l = ( int32_t ) <NEW_LINE> ( ( p -> hl [ 0 ] << 24 ) | ( p -> hl [ 1 ] << 16 ) | ( p -> hl [ 2 ] << 8 ) | ( p -> hl [ 3 ] ) ) ; <NEW_LINE> <START_VULN> cvt_32 ( p , m ) ; <NEW_LINE> <END_VULN> return 1 ; <NEW_LINE> case FILE_BEQUAD: <NEW_LINE> case FILE_BEQDATE:
#pragma once <NEW_LINE> #include "base / basictypes . h" <NEW_LINE> <START_VULN> #include "base / callback . h" <NEW_LINE> <END_VULN> namespace chromeos {
public: <NEW_LINE> PlatformSensorLinux ( <NEW_LINE> mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> PlatformSensorProvider * provider , <NEW_LINE> const SensorInfoLinux * sensor_device , <NEW_LINE> scoped_refptr < base::SingleThreadTaskRunner > polling_thread_task_runner ) ;
<START_VULN> * <NEW_LINE> <END_VULN> *
if ( IsEditorRoot ( aCurrentNode ) ) { <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> <START_VULN> nsIContent * candidate = <NEW_LINE> <END_VULN> FindNextLeafNode ( aCurrentNode , aGoForward , bNoBlockCrossing ) ; <NEW_LINE> if ( ! candidate ) { <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> if ( ! aEditableNode || IsEditable ( candidate ) ) { <NEW_LINE> return candidate ;
<START_VULN> RoutingStatus RouteToFrame ( const char * method , bool is_javascript_url , <NEW_LINE>const char * target , unsigned int len , <NEW_LINE>const char * buf , bool is_file_data , <NEW_LINE>bool notify_needed , intptr_t notify_data , <NEW_LINE>const char * url , Referrer referrer_flag ) ; <NEW_LINE> <END_VULN> void CancelResource ( unsigned long id ) ;
ProxyJNIEnv & proxyEnv = GetProxyEnv ( env ) ; <NEW_LINE> nsISecureEnv * secureEnv = GetSecureEnv ( env ) ; <NEW_LINE> nsISecurityContext * securityContext = proxyEnv . getContext ( ) ; <NEW_LINE> <START_VULN> nsresult result ; <NEW_LINE>result = secureEnv -> CallNonvirtualMethod ( jvoid_type , obj , clazz , method -> mMethodID , args , & unusedValue , securityContext ) ; <NEW_LINE> <END_VULN> NS_IF_RELEASE ( securityContext ) ; <NEW_LINE> }
if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) || <NEW_LINE> ( total_length > BT_SHB_INSANE_MAX ) ) { <NEW_LINE> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , <NEW_LINE> <START_VULN> "Section Header Block in pcapng dump file has invalid length % " PRIsize " < _ % lu_ < % lu ( BT_SHB_INSANE_MAX ) " , <NEW_LINE>sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) , <NEW_LINE>total_length , <NEW_LINE>BT_SHB_INSANE_MAX ) ; <NEW_LINE> <END_VULN> * err = 1 ; <NEW_LINE> return ( NULL ) ;
for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) <NEW_LINE> { <NEW_LINE> if ( bit == 0 ) <NEW_LINE> <START_VULN> byte = ( size_t ) ( * p ++ ) ; <NEW_LINE> <END_VULN> SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ; <NEW_LINE> bit ++ ; <NEW_LINE> byte >> = 1 ;
} else { <NEW_LINE> if ( l_header_read == 0 ) { <NEW_LINE> <START_VULN> if ( sscanf ( l_line , " % u % u % u" , o_row_count , o_column_count , o_element_count ) == 3 ) { <NEW_LINE> <END_VULN> * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; <NEW_LINE> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( ( size_t ) ( * o_column_count ) + 1 ) ) ;
<START_VULN> static const char * const cfg = " -- force - target = generic - gnu -- disable - examples -- disable - docs -- enable - realtime - only" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
@param ptr Pointer to the block <NEW_LINE> @remarks Do not mix calls to pfree and free . <NEW_LINE> @ingroup MprMem <NEW_LINE> <START_VULN> @stability Evolving <NEW_LINE> <END_VULN> PUBLIC void pfree ( void * ptr ) ;
} ; <NEW_LINE> GpuChannelHostFactory * factory_ ; <NEW_LINE> <START_VULN> int gpu_process_id_ ; <NEW_LINE> <END_VULN> int client_id_ ; <NEW_LINE> State state_ ;
png_ptr -> save_buffer_size - = save_size ; <NEW_LINE> png_ptr -> save_buffer_ptr += save_size ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( length && png_ptr -> current_buffer_size ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_size_t save_size ;
void <NEW_LINE> nsGenericHTMLElement::RemoveFocus ( nsPresContext * aPresContext ) <NEW_LINE> { <NEW_LINE> if ( ! aPresContext ) <NEW_LINE> return ; <NEW_LINE> if ( IsNodeOfType ( eHTML_FORM_CONTROL ) ) { <NEW_LINE> <START_VULN> nsIFormControlFrame * formControlFrame = GetFormControlFrame ( PR_FALSE ) ; <NEW_LINE> <END_VULN> if ( formControlFrame ) { <NEW_LINE> formControlFrame -> SetFocus ( PR_FALSE , PR_FALSE ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> if ( IsInDoc ( ) ) { <NEW_LINE> aPresContext -> EventStateManager ( ) -> SetContentState ( nsnull , <NEW_LINE> NS_EVENT_STATE_FOCUS ) ;
in [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void fadst16_8col ( __m128i * in ) { <NEW_LINE> <END_VULN> __m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ; <NEW_LINE> const __m128i k__cospi_p01_p31 = pair_set_epi16 ( cospi_1_64 , cospi_31_64 ) ;
int jas_iccprofdata_srgblen = sizeof ( jas_iccprofdata_srgb ) ; <NEW_LINE> <START_VULN> uchar jas_iccprofdata_sgray [ ] = { <NEW_LINE> <END_VULN> 0x00 , 0x00 , 0x01 , 0x8a , 0x00 , 0x00 , 0x00 , 0x00 , <NEW_LINE> 0x02 , 0x20 , 0x00 , 0x00 , 0x73 , 0x63 , 0x6e , 0x72 , <NEW_LINE> 0x47 , 0x52 , 0x41 , 0x59 , 0x58 , 0x59 , 0x5a , 0x20 ,
<START_VULN> while ( impeg2d_bit_stream_nxt ( ps_stream , MB_STUFFING_CODE_LEN ) == MB_STUFFING_CODE ) <NEW_LINE> <END_VULN> impeg2d_bit_stream_flush ( ps_stream , MB_STUFFING_CODE_LEN ) ;
thisp = JSVAL_IS_VOID ( v ) <NEW_LINE> ? OBJ_GET_PARENT ( cx , thisp ) <NEW_LINE> : JSVAL_TO_OBJECT ( v ) ; <NEW_LINE> while ( ( parent = OBJ_GET_PARENT ( cx , thisp ) ) != NULL ) <NEW_LINE> thisp = parent ; <NEW_LINE> } <NEW_LINE> <START_VULN> OBJ_TO_OUTER_OBJECT ( cx , thisp ) ; <NEW_LINE> <END_VULN> if ( ! thisp ) <NEW_LINE> return NULL ; <NEW_LINE> argv [ - 1 ] = OBJECT_TO_JSVAL ( thisp ) ; <NEW_LINE> return thisp ; <NEW_LINE> } <NEW_LINE> static JSObject * <NEW_LINE> ComputeThis ( JSContext * cx , JSBool lazy , jsval * argv )
virtual void CreateSensorInternal ( mojom::SensorType type , <NEW_LINE> <START_VULN> mojo::ScopedSharedBufferMapping mapping , <NEW_LINE> <END_VULN> const CreateSensorCallback & callback ) = 0 ;
SimpleStringList tableNames ; <NEW_LINE> int			useDB ; <NEW_LINE> <START_VULN> char	 * dbname ; <NEW_LINE> <END_VULN> char	 * pgport ; <NEW_LINE> char	 * pghost ; <NEW_LINE> char	 * username ;
uint32_t lineIndexToNum ( uint32_t lineIndex ) const { return lineIndex + initialLineNum_ ; } <NEW_LINE> uint32_t lineNumToIndex ( uint32_t lineNum ) const { return lineNum - initialLineNum_ ; } <NEW_LINE> public: <NEW_LINE> SourceCoords ( ExclusiveContext * cx , uint32_t ln ) ; <NEW_LINE> void add ( uint32_t lineNum , uint32_t lineStartOffset ) ; <NEW_LINE> <START_VULN> void fill ( const SourceCoords & other ) ; <NEW_LINE> <END_VULN> bool isOnThisLine ( uint32_t offset , uint32_t lineNum ) const { <NEW_LINE> uint32_t lineIndex = lineNumToIndex ( lineNum ) ; <NEW_LINE> JS_ASSERT ( lineIndex + 1 < lineStartOffsets_ . length ( ) ) ; <NEW_LINE> return lineStartOffsets_ [ lineIndex ] <= offset && <NEW_LINE> offset < lineStartOffsets_ [ lineIndex + 1 ] ; <NEW_LINE> }
( void ) CloseBlob ( image ) ; <NEW_LINE> return ( GetFirstImageInList ( image ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE><NEW_LINE> <END_VULN>
RenderBlock * parentBlock = toRenderBlock ( parent ( ) ) ; <NEW_LINE> bool parentHasFloats = false ; <NEW_LINE> RenderObject * prev = previousSibling ( ) ; <NEW_LINE> <START_VULN> while ( prev && ( prev -> isFloatingOrPositioned ( ) || ! prev -> isBox ( ) || ! prev -> isRenderBlock ( ) || toRenderBlock ( prev ) -> avoidsFloats ( ) ) ) { <NEW_LINE> <END_VULN> if ( prev -> isFloating ( ) ) <NEW_LINE> parentHasFloats = true ; <NEW_LINE> prev = prev -> previousSibling ( ) ;
* -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <NEW_LINE> <START_VULN> int Downmix_Reset ( downmix_object_t * pDownmixer , bool init ) { <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
double decay_accumulator = 1 . 0 ; <NEW_LINE> double next_iiratio ; <NEW_LINE> <START_VULN> vpx_memcpy ( & local_next_frame , next_frame , sizeof ( * next_frame ) ) ; <NEW_LINE> <END_VULN> start_pos = cpi -> twopass . stats_in ;
return PL_DHASH_NEXT ; <NEW_LINE> } <NEW_LINE> class ScopedRequestSuspender { <NEW_LINE> public: <NEW_LINE> ScopedRequestSuspender ( nsIRequest * request ) <NEW_LINE> : mRequest ( request ) { <NEW_LINE> <START_VULN> if ( NS_FAILED ( mRequest -> Suspend ( ) ) ) { <NEW_LINE> <END_VULN> NS_WARNING ( "Couldn't suspend pump" ) ; <NEW_LINE> mRequest = nsnull ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> ~ ScopedRequestSuspender ( ) { <NEW_LINE> if ( mRequest ) <NEW_LINE> mRequest -> Resume ( ) ; <NEW_LINE> }
<START_VULN> <NEW_LINE> <END_VULN> class P2PQuicStream { <NEW_LINE> public:
if ( specialization ( ) != MIRType_Int32 && specialization ( ) != MIRType_Double ) <NEW_LINE> return ; <NEW_LINE> Range lhs ( getOperand ( 0 ) ) ; <NEW_LINE> Range rhs ( getOperand ( 1 ) ) ; <NEW_LINE> int64_t a = Abs < int64_t > ( rhs . lower ( ) ) ; <NEW_LINE> int64_t b = Abs < int64_t > ( rhs . upper ( ) ) ; <NEW_LINE> if ( a == 0 && b == 0 ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> int64_t bound = Max ( 1 - a , b - 1 ) ; <NEW_LINE> <END_VULN> setRange ( new Range ( - bound , bound , lhs . isDecimal ( ) || rhs . isDecimal ( ) ) ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> MToDouble::computeRange ( ) <NEW_LINE> { <NEW_LINE> setRange ( new Range ( getOperand ( 0 ) ) ) ; <NEW_LINE> }
XPCCompartmentSet & GetCompartmentSet ( ) <NEW_LINE> { return mCompartmentSet ; } <NEW_LINE> XPCLock * GetMapLock ( ) const { return mMapLock ; } <NEW_LINE> JSBool OnJSContextNew ( JSContext * cx ) ; <NEW_LINE> <START_VULN> JSBool DeferredRelease ( nsISupports * obj ) ; <NEW_LINE> <END_VULN> JSBool GetDoingFinalization ( ) const { return mDoingFinalization ; } <NEW_LINE> enum {
( b -> qcoeff [ 0 ] * DQC [ 0 ] , <NEW_LINE> dst , dst_stride , <NEW_LINE> dst , dst_stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: residue backend 0 , 1 and 2 implementation <NEW_LINE> <START_VULN> last mod: $ Id: res0 . c 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN>
if ( ! npp ) <NEW_LINE> return false ; <NEW_LINE> NPPAutoPusher nppPusher ( npp ) ; <NEW_LINE> nsIDocument * doc = GetDocumentFromNPP ( npp ) ; <NEW_LINE> NS_ENSURE_TRUE ( doc , false ) ; <NEW_LINE> <START_VULN> JSContext * cx = GetJSContextFromDoc ( doc ) ; <NEW_LINE> <END_VULN> NS_ENSURE_TRUE ( cx , false ) ; <NEW_LINE> nsCOMPtr < nsIScriptContext > scx = GetScriptContextFromJSContext ( cx ) ; <NEW_LINE> NS_ENSURE_TRUE ( scx , false ) ; <NEW_LINE> JSAutoRequest req ( cx ) ; <NEW_LINE> JSObject * obj =
int size ; <NEW_LINE> syscall_nr = trace_get_syscall_nr ( current , regs ) ; <NEW_LINE> <START_VULN> if ( syscall_nr < 0 ) <NEW_LINE> <END_VULN> return ;
#undef mem_put_be24 <NEW_LINE> #define mem_put_be24 mem_ops_wrap_symbol ( mem_put_be24 ) <NEW_LINE> <START_VULN> static void mem_put_be24 ( void * vmem , MEM_VALUE_T val ) { <NEW_LINE> <END_VULN> MAU_T * mem = ( MAU_T * ) vmem ; <NEW_LINE> mem [ 0 ] = ( val >> 16 ) & 0xff ;
* returndistortion = distortion2 ; <NEW_LINE> best_rd_sse = sse ; <NEW_LINE> best_rd = this_rd ; <NEW_LINE> <START_VULN> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , <NEW_LINE>sizeof ( MB_MODE_INFO ) ) ; <NEW_LINE> <END_VULN>
d [ i ] = p_src [ i ] ; <NEW_LINE> for ( col = 0 ; col < cols ; col ++ ) { <NEW_LINE> <START_VULN> int kernel = 4 ; <NEW_LINE> <END_VULN> v = p_src [ col ] ; <NEW_LINE> d [ col & 7 ] = v ;
static void locationWithExceptionAttributeSetter ( v8::Local < v8::Value > jsValue , const v8::PropertyCallbackInfo < void > & info ) <NEW_LINE> { <NEW_LINE> TestObject * proxyImp = V8TestObject::toNative ( info . Holder ( ) ) ; <NEW_LINE> <START_VULN> TestNode * imp = WTF::getPtr ( proxyImp -> locationWithException ( ) ) ; <NEW_LINE> <END_VULN> if ( ! imp ) <NEW_LINE> return ; <NEW_LINE> V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID ( V8StringResource < > , cppValue , jsValue ) ;
} <NEW_LINE> } <NEW_LINE> return true ; <NEW_LINE> } <NEW_LINE> JSScript * <NEW_LINE> frontend::CompileScript ( JSContext * cx , JSObject * scopeChain , StackFrame * callerFrame , <NEW_LINE> <START_VULN> JSPrincipals * principals , uint32 tcflags , <NEW_LINE> <END_VULN> const jschar * chars , size_t length , <NEW_LINE> const char * filename , uintN lineno , JSVersion version , <NEW_LINE> JSString * source , <NEW_LINE> uintN staticLevel ) <NEW_LINE> { <NEW_LINE> TokenKind tt ; <NEW_LINE> ParseNode * pn ; <NEW_LINE> JSScript * script ;
ast_mutex_init ( & s -> __lock ) ; <NEW_LINE> ast_mutex_lock ( & s -> __lock ) ; <NEW_LINE> s -> inuse = 1 ; <NEW_LINE> <START_VULN> s -> managerid = rand ( ) | ( unsigned long ) s ; <NEW_LINE> <END_VULN> AST_LIST_LOCK ( & sessions ) ; <NEW_LINE> AST_LIST_INSERT_HEAD ( & sessions , s , list ) ;
} <NEW_LINE> void vp9_find_mv_refs ( const VP9_COMMON * cm , const MACROBLOCKD * xd , <NEW_LINE> <START_VULN> const TileInfo * const tile , <NEW_LINE>MODE_INFO * mi , MV_REFERENCE_FRAME ref_frame , <NEW_LINE>int_mv * mv_ref_list , <NEW_LINE>int mi_row , int mi_col ) { <NEW_LINE>find_mv_refs_idx ( cm , xd , tile , mi , ref_frame , mv_ref_list , - 1 , <NEW_LINE>mi_row , mi_col ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static void lower_mv_precision ( MV * mv , int allow_hp ) {
#endif <NEW_LINE> <START_VULN> if ( transforms & PNG_TRANSFORM_INVERT_ALPHA ) <NEW_LINE> <END_VULN> #ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED <NEW_LINE> png_set_invert_alpha ( png_ptr ) ; <NEW_LINE> #else
BOOL <NEW_LINE> GetBackupLogPath ( LPWSTR path , LPCWSTR basePath , int logNumber ) <NEW_LINE> { <NEW_LINE> <START_VULN> WCHAR logName [ 64 ] ; <NEW_LINE>wcscpy ( path , basePath ) ; <NEW_LINE> <END_VULN> if ( logNumber <= 0 ) { <NEW_LINE> swprintf ( logName , sizeof ( logName ) / sizeof ( logName [ 0 ] ) , <NEW_LINE> L"maintenanceservice . log" ) ; <NEW_LINE> } else { <NEW_LINE> swprintf ( logName , sizeof ( logName ) / sizeof ( logName [ 0 ] ) , <NEW_LINE> L"maintenanceservice - % d . log" , logNumber ) ; <NEW_LINE> } <NEW_LINE> return PathAppendSafe ( path , logName ) ;
return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> #line 804 "ext / standard / var_unserializer . c" <NEW_LINE> <END_VULN> yy25: <NEW_LINE> yych = * ++ YYCURSOR ; <NEW_LINE> if ( yych <= ' , ' ) {
const unsigned char * ps ; <NEW_LINE> const unsigned char * ps_end ; <NEW_LINE> unsigned char * pd ; <NEW_LINE> <START_VULN> int i , l ; <NEW_LINE> <END_VULN> unsigned char * dest_end = dest + dest_len ; <NEW_LINE> ps = src ;
mDomain = NS_TryToMakeImmutable ( aDomain ) ; <NEW_LINE> mDomainImmutable = URIIsImmutable ( mDomain ) ; <NEW_LINE> SetSecurityPolicy ( nullptr ) ; <NEW_LINE> <START_VULN> JSContext * cx = nsContentUtils::GetSafeJSContext ( ) ; <NEW_LINE>NS_ENSURE_TRUE ( cx , NS_ERROR_FAILURE ) ; <NEW_LINE> <END_VULN> JSPrincipals * principals = nsJSPrincipals::get ( static_cast < nsIPrincipal * > ( this ) ) ; <NEW_LINE> bool success = js::RecomputeWrappers ( cx , js::ContentCompartmentsOnly ( ) , <NEW_LINE> js::CompartmentsWithPrincipals ( principals ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( success , NS_ERROR_FAILURE ) ; <NEW_LINE> success = js::RecomputeWrappers ( cx , js::CompartmentsWithPrincipals ( principals ) , <NEW_LINE> js::ContentCompartmentsOnly ( ) ) ; <NEW_LINE> NS_ENSURE_TRUE ( success , NS_ERROR_FAILURE ) ;
if ( cpi -> oxcf . auto_key && <NEW_LINE> <START_VULN> rc -> frames_to_key > ( int ) cpi -> key_frame_frequency ) { <NEW_LINE> <END_VULN> FIRSTPASS_STATS tmp_frame = first_frame ; <NEW_LINE> rc -> frames_to_key /= 2 ;
nsresult <NEW_LINE> nsXBLProtoImpl::Read ( nsIScriptContext * aContext , <NEW_LINE> nsIObjectInputStream * aStream , <NEW_LINE> nsXBLPrototypeBinding * aBinding , <NEW_LINE> nsIScriptGlobalObject * aGlobal ) <NEW_LINE> { <NEW_LINE> <START_VULN> JSContext * cx = aContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSObject * global = aGlobal -> GetGlobalJSObject ( ) ; <NEW_LINE> JSObject * classObject ; <NEW_LINE> bool classObjectIsNew = false ; <NEW_LINE> nsresult rv = aBinding -> InitClass ( mClassName , cx , global , global , & classObject , <NEW_LINE> & classObjectIsNew ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> MOZ_ASSERT ( classObject ) ;
} <NEW_LINE> if ( ! jsprin ) { <NEW_LINE> return ThrowException ( NS_ERROR_UNEXPECTED , cx ) ; <NEW_LINE> } <NEW_LINE> JSFunction * scriptedFun = <NEW_LINE> ::JS_CompileFunctionForPrincipals ( cx , <NEW_LINE> <START_VULN> JS_GetGlobalForObject ( cx , unsafeObj ) , <NEW_LINE>jsprin , nsnull , 0 , nsnull , <NEW_LINE> <END_VULN> funScript . get ( ) , funScript . Length ( ) , <NEW_LINE> "XPCSafeJSObjectWrapper . cpp" , <NEW_LINE> __LINE__ ) ; <NEW_LINE> JSPRINCIPALS_DROP ( cx , jsprin ) ; <NEW_LINE> if ( ! scriptedFun ) { <NEW_LINE> return ThrowException ( NS_ERROR_FAILURE , cx ) ;
layer_id = ( int ) stats -> spatial_layer_id ; <NEW_LINE> if ( layer_id >= cfg -> ss_number_layers <NEW_LINE> <START_VULN> || ( int ) ( stats -> count + 0 . 5 ) != n_packets_per_layer [ layer_id ] - 1 ) <NEW_LINE> <END_VULN> ERROR ( "rc_twopass_stats_in missing EOS stats packet" ) ; <NEW_LINE> } <NEW_LINE> } else {
OMX_IN OMX_BUFFERHEADERTYPE * buffer ) <NEW_LINE> { <NEW_LINE> DEBUG_PRINT_LOW ( "FTB: buffer -> pBuffer [ % p ] " , buffer -> pBuffer ) ; <NEW_LINE> <START_VULN> if ( m_state == OMX_StateInvalid ) { <NEW_LINE> <END_VULN> DEBUG_PRINT_ERROR ( "ERROR: FTB in Invalid State" ) ; <NEW_LINE> return OMX_ErrorInvalidState ; <NEW_LINE> }
mMimeTypeArray = nsnull ; <NEW_LINE> } <NEW_LINE> nsPluginElement:: ~ nsPluginElement ( ) <NEW_LINE> { <NEW_LINE> NS_IF_RELEASE ( mPlugin ) ; <NEW_LINE> if ( mMimeTypeArray != nsnull ) { <NEW_LINE> <START_VULN> for ( PRUint32 i = 0 ; i < mMimeTypeCount ; i ++ ) <NEW_LINE>NS_IF_RELEASE ( mMimeTypeArray [ i ] ) ; <NEW_LINE> <END_VULN> delete [ ] mMimeTypeArray ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> NS_INTERFACE_MAP_BEGIN ( nsPluginElement ) <NEW_LINE> NS_INTERFACE_MAP_ENTRY ( nsISupports )
return true ; <NEW_LINE> } <NEW_LINE> <START_VULN> bool ChunkedCopy ( mkvparser::IMkvReader * source , <NEW_LINE>mkvmuxer::IMkvWriter * dst , <NEW_LINE> <END_VULN> mkvmuxer::int64 start , int64 size ) { <NEW_LINE> const uint32 kBufSize = 2048 ;
struct nfsd4_getdeviceinfo * gdev ) <NEW_LINE> { <NEW_LINE> struct xdr_stream * xdr = & resp -> xdr ; <NEW_LINE> <START_VULN> const struct nfsd4_layout_ops * ops = <NEW_LINE>nfsd4_layout_ops [ gdev -> gd_layout_type ] ; <NEW_LINE> <END_VULN> u32 starting_len = xdr -> buf -> len , needed_len ; <NEW_LINE> __be32 * p ;
const std::string & raw_device_id , <NEW_LINE> const media::AudioParameters & output_params ) const ; <NEW_LINE> <START_VULN> media::AudioManager * audio_manager_ ; <NEW_LINE> <END_VULN> MediaStreamManager * const media_stream_manager_ ; <NEW_LINE> std::unique_ptr < MediaDevicesPermissionChecker > permission_checker_ ; <NEW_LINE> const int render_process_id_ ;
ipaddr_string ( ndo , obj_tptr + 8 ) , <NEW_LINE> EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <NEW_LINE> <START_VULN> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <NEW_LINE> <END_VULN> hexdump = TRUE ; <NEW_LINE> break ;
<START_VULN> if ( png_get_valid ( png_ptr , info_ptr , PNG_INFO_sBIT ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_color_8p sig_bit_p ;
void cryptographicallyRandomValues ( unsigned char * , size_t ) override <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> } <NEW_LINE> void screenColorProfile ( WebVector < char > * profile ) override
void DispatchTabUpdatedEvent ( content::WebContents * contents , <NEW_LINE> <START_VULN> DictionaryValue * changed_properties ) ; <NEW_LINE> <END_VULN>
return mouse && mProtoHandler -> MouseEventMatched ( mouse ) ; <NEW_LINE> } <NEW_LINE> nsXBLKeyEventHandler::nsXBLKeyEventHandler ( nsIAtom * aEventType , uint8_t aPhase , <NEW_LINE> uint8_t aType ) <NEW_LINE> : mEventType ( aEventType ) , <NEW_LINE> mPhase ( aPhase ) , <NEW_LINE> mType ( aType ) , <NEW_LINE> <START_VULN> mIsBoundToChrome ( false ) <NEW_LINE> <END_VULN> { <NEW_LINE> } <NEW_LINE> nsXBLKeyEventHandler:: ~ nsXBLKeyEventHandler ( ) <NEW_LINE> { <NEW_LINE> } <NEW_LINE> NS_IMPL_ISUPPORTS1 ( nsXBLKeyEventHandler , nsIDOMEventListener )
} else { <NEW_LINE> * aMode = NP_EMBED ; <NEW_LINE> } <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsPluginInstanceOwner::GetAttributes ( PRUint16 & n , <NEW_LINE> <START_VULN> const char * const * & names , <NEW_LINE>const char * const * & values ) <NEW_LINE> <END_VULN> { <NEW_LINE> nsresult rv = EnsureCachedAttrParamArrays ( ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> n = mNumCachedAttrs ; <NEW_LINE> names = ( const char ** ) mCachedAttrParamNames ; <NEW_LINE> values = ( const char ** ) mCachedAttrParamValues ;
free ( identity ) ; <NEW_LINE> free ( mechanism ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> zmq_close ( handler ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> int main ( void )
} <NEW_LINE> <START_VULN> if ( dataSize > MAX_DLS_WAVE_SIZE ) <NEW_LINE> <END_VULN> { <NEW_LINE> return EAS_ERROR_SOUND_LIBRARY ; <NEW_LINE> }
return mRemoteBinder ; <NEW_LINE> } <NEW_LINE> <START_VULN> virtual status_t dump ( int fd , const Vector < String16 > & args ) = 0 ; <NEW_LINE> <END_VULN> protected: <NEW_LINE> BasicClient ( const sp < CameraService > & cameraService ,
uint32_t count = aContent . Length ( ) ; <NEW_LINE> for ( uint32_t i = 0 ; i < count ; i ++ ) { <NEW_LINE> nsIContent * content = aContent [ i ] . mContent ; <NEW_LINE> NS_ASSERTION ( content , "null anonymous content ? " ) ; <NEW_LINE> <START_VULN> if ( aParent && <NEW_LINE>aParent -> NodeInfo ( ) -> Equals ( nsGkAtoms::use , kNameSpaceID_SVG ) ) { <NEW_LINE> <END_VULN> content -> SetFlags ( NODE_IS_ANONYMOUS ) ; <NEW_LINE> } else { <NEW_LINE> content -> SetNativeAnonymous ( ) ; <NEW_LINE> } <NEW_LINE> bool anonContentIsEditable = content -> HasFlag ( NODE_IS_EDITABLE ) ; <NEW_LINE> rv = content -> BindToTree ( mDocument , aParent , aParent , true ) ;
{ <NEW_LINE> for ( i = 0 ; i < 8 ; i ++ ) <NEW_LINE> { <NEW_LINE> <START_VULN> vpx_memset ( upred_ptr , uleft_col [ i ] , 8 ) ; <NEW_LINE>vpx_memset ( vpred_ptr , vleft_col [ i ] , 8 ) ; <NEW_LINE> <END_VULN> upred_ptr += pred_stride ; <NEW_LINE> vpred_ptr += pred_stride ; <NEW_LINE> }
if ( devices == NULL ) <NEW_LINE> { <NEW_LINE> hb_log ( "OpenCL: hb_generat_bin_from_kernel_source: no device found" ) ; <NEW_LINE> <START_VULN> return 0 ; <NEW_LINE> <END_VULN> }
switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( decopts , <NEW_LINE> jas_tvparser_gettag ( tvp ) ) ) -> id ) { <NEW_LINE> case OPT_MAXSIZE: <NEW_LINE> <START_VULN> opts -> max_size = atoi ( jas_tvparser_getval ( tvp ) ) ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> default: <NEW_LINE> jas_eprintf ( "warning: ignoring invalid option % s\n" ,
if ( * p != xdr_zero ) <NEW_LINE> <START_VULN> * reply = ( struct rpcrdma_write_array * ) p ; <NEW_LINE> <END_VULN> else <NEW_LINE> * reply = NULL ; <NEW_LINE> }
type = buf [ 0 ] ; <NEW_LINE> p = buf + 1 ; <NEW_LINE> DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <NEW_LINE> <START_VULN> if ( p + l > buf + n ) { <NEW_LINE> <END_VULN> syslog ( LOG_WARNING , "bad request ( length encoding l = % u n = % u ) " , <NEW_LINE> l , ( unsigned ) n ) ; <NEW_LINE> goto error ;
if ( ! p ) <NEW_LINE> return 0 ; <NEW_LINE> p = xdr_decode_hyper ( p , & args -> offset ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> args -> count = ntohl ( * p ++ ) ; <NEW_LINE> len = min ( args -> count , max_blocksize ) ;
void newType ( JSContext * cx , TypeSet * source , Type type ) ; <NEW_LINE> } ; <NEW_LINE> void <NEW_LINE> StackTypeSet::addPropagateThis ( JSContext * cx , HandleScript script , jsbytecode * pc , <NEW_LINE> Type type , StackTypeSet * types ) <NEW_LINE> { <NEW_LINE> <START_VULN> <NEW_LINE>jsbytecode * callpc = script -> analysis ( ) -> getCallPC ( pc ) ; <NEW_LINE>if ( JSOp ( * callpc ) == JSOP_NEW ) <NEW_LINE>return ; <NEW_LINE><NEW_LINE>add ( cx , cx -> analysisLifoAlloc ( ) . new_ < TypeConstraintPropagateThis > ( script , callpc , type , types ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> class TypeConstraintFilterPrimitive : public TypeConstraint <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> TypeSet * target ;
nsCOMPtr < nsIScriptContext > context = global -> GetContext ( ) ; <NEW_LINE> if ( ! context ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsAutoMicroTask mt ; <NEW_LINE> <START_VULN> JSContext * cx = context -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSObject * globalObject = global -> GetGlobalJSObject ( ) ; <NEW_LINE> nsCOMPtr < nsIXPConnectJSObjectHolder > wrapper ; <NEW_LINE> jsval v ; <NEW_LINE> nsresult rv = <NEW_LINE> nsContentUtils::WrapNative ( cx , globalObject , aBoundElement , & v , <NEW_LINE> getter_AddRefs ( wrapper ) ) ;
public: <NEW_LINE> inline void setDefaultCompartmentObject ( JSObject * obj ) ; <NEW_LINE> inline void setDefaultCompartmentObjectIfUnset ( JSObject * obj ) ; <NEW_LINE> JSObject * maybeDefaultCompartmentObject ( ) const { return defaultCompartmentObject_ ; } <NEW_LINE> js::ContextStack stack ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> inline js::Handle < js::GlobalObject * > global ( ) const ; <NEW_LINE> inline bool hasfp ( ) const { return stack . hasfp ( ) ; } <NEW_LINE> inline js::StackFrame * fp ( ) const { return stack . fp ( ) ; } <NEW_LINE> inline js::StackFrame * maybefp ( ) const { return stack . maybefp ( ) ; } <NEW_LINE> inline js::FrameRegs & regs ( ) const { return stack . regs ( ) ; } <NEW_LINE> inline js::FrameRegs * maybeRegs ( ) const { return stack . maybeRegs ( ) ; }
int64_t a = Abs < int64_t > ( rhs . lower ( ) ) ; <NEW_LINE> int64_t b = Abs < int64_t > ( rhs . upper ( ) ) ; <NEW_LINE> if ( a == 0 && b == 0 ) <NEW_LINE> return ; <NEW_LINE> <START_VULN> int64_t rhsAbsBound = Max ( a - 1 , b - 1 ) ; <NEW_LINE> <END_VULN> int64_t lhsAbsBound = Max ( Abs < int64_t > ( lhs . lower ( ) ) , Abs < int64_t > ( lhs . upper ( ) ) ) ; <NEW_LINE> int64_t absBound = Min ( lhsAbsBound , rhsAbsBound ) ;
png_crc_read ( png_ptr , buffer , length ) ; <NEW_LINE> <START_VULN> if ( png_crc_finish ( png_ptr , skip ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> buffer [ length ] = 0 ;
static int CVE_2013_2548_crypto_report_one ( struct crypto_alg * alg , <NEW_LINE> struct crypto_user_alg * ualg , struct sk_buff * skb ) <NEW_LINE> { <NEW_LINE> <START_VULN> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <NEW_LINE>memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <NEW_LINE>sizeof ( ualg -> cru_driver_name ) ) ; <NEW_LINE>memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <NEW_LINE>CRYPTO_MAX_ALG_NAME ) ; <NEW_LINE> <END_VULN> ualg -> cru_flags = alg -> cra_flags ; <NEW_LINE> ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ;
<START_VULN> bool paused_ ; <NEW_LINE> <END_VULN> const OnEncodedVideoCB on_encoded_video_callback_ ;
} <NEW_LINE> if ( intern -> u . dir . sub_path ) { <NEW_LINE> efree ( intern -> u . dir . sub_path ) ; <NEW_LINE> <START_VULN> } <NEW_LINE> <END_VULN> break ; <NEW_LINE> case SPL_FS_FILE: <NEW_LINE> if ( intern -> u . file . stream ) {
void GetAvailability ( const v8::FunctionCallbackInfo < v8::Value > & args ) ; <NEW_LINE> void GetModuleSystem ( const v8::FunctionCallbackInfo < v8::Value > & args ) ; <NEW_LINE> <START_VULN> void RunWithNativesEnabledModuleSystem ( <NEW_LINE>const v8::FunctionCallbackInfo < v8::Value > & args ) ; <NEW_LINE> <END_VULN> ScriptContext * context_ ; <NEW_LINE> Dispatcher * dispatcher_ ;
<START_VULN> <NEW_LINE>virtual bool Bound ( int32_t offset , int32_t length ) ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE>virtual bool Bound ( int32_t offset ) ; <NEW_LINE> <END_VULN>
pthread_mutex_lock ( & client_socket_lock_ ) ; <NEW_LINE> if ( client_socket_ != - 1 ) { <NEW_LINE> <START_VULN> if ( send ( client_socket_ , data , length , 0 ) == - 1 && errno == ECONNRESET ) { <NEW_LINE> <END_VULN> safe_close_ ( & client_socket_ ) ; <NEW_LINE> } <NEW_LINE> }
if ( element -> hasLegalLinkAttribute ( attrName ) ) { <NEW_LINE> if ( attrValue . startsWith ( "javascript:" , TextCaseInsensitive ) ) { <NEW_LINE> <START_VULN> result . append ( attrValue ) ; <NEW_LINE> <END_VULN> } else { <NEW_LINE> WebLocalFrameImpl * subFrame = WebLocalFrameImpl::fromFrameOwnerElement ( element ) ;
} <NEW_LINE> ( void ) CloseBlob ( image ) ; <NEW_LINE> <START_VULN> DestroyImage ( RemoveFirstImageFromList ( & image ) ) ; <NEW_LINE> <END_VULN> if ( image_type == GIMP_GRAY ) <NEW_LINE> image -> type = GrayscaleType ; <NEW_LINE> return ( GetFirstImageInList ( image ) ) ;
if ( r < 0 ) <NEW_LINE> return log_error_errno ( r , "Virtual console % s is not allocated: % m" , src_vc ) ; <NEW_LINE> <START_VULN> r = verify_vc_kbmode ( fd ) ; <NEW_LINE> <END_VULN> if ( r < 0 ) <NEW_LINE> return log_error_errno ( r , "Virtual console % s is not in K_XLATE or K_UNICODE: % m" , src_vc ) ;
ND_PRINT ( ( ndo , " ( length bogus , should be >= 4 ) " ) ) ; <NEW_LINE> return len ; <NEW_LINE> } <NEW_LINE> <START_VULN> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <NEW_LINE> <END_VULN> ND_PRINT ( ( ndo , ": Window: % uK , Method: % s ( 0x % x ) , MBZ: % u , CHK: % u" , <NEW_LINE> ( p [ 2 ] & 0xf0 ) >> 4 , <NEW_LINE> ( ( p [ 2 ] & 0x0f ) == 8 ) ? "zlib" : "unknown" ,
delete mMembers ; <NEW_LINE> delete mFields ; <NEW_LINE> } <NEW_LINE> nsresult InstallImplementation ( nsXBLPrototypeBinding * aPrototypeBinding , nsXBLBinding * aBinding ) ; <NEW_LINE> nsresult InitTargetObjects ( nsXBLPrototypeBinding * aBinding , nsIScriptContext * aContext , <NEW_LINE> nsIContent * aBoundElement , <NEW_LINE> nsIXPConnectJSObjectHolder ** aScriptObjectHolder , <NEW_LINE> <START_VULN> JSObject ** aTargetClassObject ) ; <NEW_LINE> <END_VULN> nsresult CompilePrototypeMembers ( nsXBLPrototypeBinding * aBinding ) ; <NEW_LINE> void SetMemberList ( nsXBLProtoImplMember * aMemberList ) <NEW_LINE> { <NEW_LINE> delete mMembers ; <NEW_LINE> mMembers = aMemberList ; <NEW_LINE> }
RARLABS , <NEW_LINE> GNAUNRAR , <NEW_LINE> UNZIP , <NEW_LINE> <START_VULN> P7ZIP , <NEW_LINE>TAR <NEW_LINE> <END_VULN> } ComicBookDecompressType ; <NEW_LINE> typedef struct _ComicsDocumentClass ComicsDocumentClass ;
{ <NEW_LINE> } <NEW_LINE> <START_VULN> void cryptographicallyRandomValues ( unsigned char * buffer , size_t length ) override { } <NEW_LINE> <END_VULN> const unsigned char * getTraceCategoryEnabledFlag ( const char * categoryName ) override <NEW_LINE> {
( cx , args ) ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsXBLProtoImplField::InstallAccessors ( JSContext * aCx , <NEW_LINE> JSObject * aTargetClassObject ) <NEW_LINE> { <NEW_LINE> MOZ_ASSERT ( js::IsObjectInContextCompartment ( aTargetClassObject , aCx ) ) ; <NEW_LINE> <START_VULN> JSObject * global = JS_GetGlobalForObject ( aCx , aTargetClassObject ) ; <NEW_LINE> <END_VULN> if ( IsEmpty ( ) ) { <NEW_LINE> return NS_OK ; <NEW_LINE> }
! WriteStatusFailure ( argv [ 1 ] , <NEW_LINE> SERVICE_NOT_ENOUGH_COMMAND_LINE_ARGS ) ) { <NEW_LINE> LOG_WARN ( ( "Could not write update . status service update failure . ( % d ) " , <NEW_LINE> GetLastError ( ) ) ) ; <NEW_LINE> } <NEW_LINE> return FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> WCHAR installDir [ MAX_PATH ] = { L'\0' } ; <NEW_LINE> <END_VULN> if ( ! GetInstallationDir ( argc , argv , installDir ) ) { <NEW_LINE> LOG_WARN ( ( "Could not get the installation directory" ) ) ; <NEW_LINE> if ( ! WriteStatusFailure ( argv [ 1 ] , <NEW_LINE> SERVICE_INSTALLDIR_ERROR ) ) { <NEW_LINE> LOG_WARN ( ( "Could not write update . status for GetInstallationDir failure . " ) ) ; <NEW_LINE> } <NEW_LINE> return FALSE ; <NEW_LINE> }
{ <NEW_LINE> p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) > 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , <NEW_LINE> p_buff + 8 + sizeof ( BITMAPINFOHEADER ) ,
mImageLoad -> GetImage ( getter_AddRefs ( mImage ) ) ; <NEW_LINE> if ( ! mImage ) { <NEW_LINE> mImage = do_CreateInstance ( "@mozilla . org / image / container ; 1" ) ; <NEW_LINE> if ( ! mImage ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> mImageLoad -> SetImage ( mImage ) ; <NEW_LINE> <START_VULN> if ( NS_FAILED ( mImage -> SetDiscardable ( "image / png" ) ) ) { <NEW_LINE>PR_LOG ( gPNGDecoderAccountingLog , PR_LOG_DEBUG , <NEW_LINE> ( "PNGDecoderAccounting: info_callback ( ) : failed to set image container % p as discardable" , <NEW_LINE>mImage . get ( ) ) ) ; <NEW_LINE>return NS_ERROR_FAILURE ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsPNGDecoder::Close ( )
uint16_t transmitted_length = 0 ; <NEW_LINE> while ( length > 0 ) { <NEW_LINE> <START_VULN> ssize_t ret = write ( fd , data + transmitted_length , length ) ; <NEW_LINE> <END_VULN> switch ( ret ) { <NEW_LINE> case - 1: <NEW_LINE> LOG_ERROR ( "In % s , error writing to the serial port with fd % d: % s" , __func__ , fd , strerror ( errno ) ) ;
} <NEW_LINE> <START_VULN> void cryptographicallyRandomValues ( unsigned char * , size_t ) override { ASSERT_NOT_REACHED ( ) ; } <NEW_LINE> <END_VULN> void setPublicSuffix ( const blink::WebString & suffix ) <NEW_LINE> {
<START_VULN> updateCoefficientsIfNecessary ( true , false ) ; <NEW_LINE> <END_VULN> m_biquad . process ( source , destination , framesToProcess ) ; <NEW_LINE> }
data_offset = get4 ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> #line 7390 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> char * CLASS foveon_gets ( int offset , char * str , int len ) <NEW_LINE> { <NEW_LINE> int i ;
} <NEW_LINE> static ogg_uint32_t decpack ( long entry , long used_entry , long quantvals , <NEW_LINE> <START_VULN> codebook * b , oggpack_buffer * opb , int maptype ) { <NEW_LINE> <END_VULN> ogg_uint32_t ret = 0 ; <NEW_LINE> int j ;
xmlXPathCompOpEval ( ctxt , <NEW_LINE> & comp -> steps [ op -> ch2 ] ) ; <NEW_LINE> if ( ctxt -> error != XPATH_EXPRESSION_OK ) { <NEW_LINE> <START_VULN> xmlXPathFreeObject ( obj ) ; <NEW_LINE>return ( 0 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> res = valuePop ( ctxt ) ;
<START_VULN> static int CVE_2014_5472_isofs_read_inode ( struct inode * inode ) <NEW_LINE> <END_VULN> { <NEW_LINE> struct super_block * sb = inode -> i_sb ; <NEW_LINE> struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ;
NS_ASSERTION ( mParser , "no parser: unitialized" ) ; <NEW_LINE> if ( mScheme . mLen < 0 ) { <NEW_LINE> <START_VULN> NS_ERROR ( "unable to Resolve URL: this URL not initialized" ) ; <NEW_LINE> <END_VULN> return NS_ERROR_NOT_INITIALIZED ; <NEW_LINE> } <NEW_LINE> nsresult rv ; <NEW_LINE> URLSegment scheme ; <NEW_LINE> char * resultPath = nullptr ; <NEW_LINE> bool relative = false ; <NEW_LINE> uint32_t offset = 0 ;
{ <NEW_LINE> INC_STATS ( "DOM . TestInterface . supplementalMethod2" ) ; <NEW_LINE> if ( args . Length ( ) < 2 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestInterface * imp = V8TestInterface::toNative ( args . Holder ( ) ) ; <NEW_LINE> ExceptionCode ec = 0 ; <NEW_LINE> {
int i , j ; <NEW_LINE> char buf [ 128 ] ; <NEW_LINE> ArmOpcode aop = { . off = off } ; <NEW_LINE> <START_VULN> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <NEW_LINE> <END_VULN> if ( str [ j ] == '#' ) { <NEW_LINE> i -- ; continue ; <NEW_LINE> }
for ( i = 1 ; ( i < ( ssize_t ) dds_info -> mipmapcount ) && w && h ; i ++ ) <NEW_LINE> { <NEW_LINE> offset = ( MagickOffsetType ) w * h * pixel_size ; <NEW_LINE> <START_VULN> ( void ) SeekBlob ( image , offset , SEEK_CUR ) ; <NEW_LINE><NEW_LINE> <END_VULN> w = DIV2 ( w ) ; <NEW_LINE> h = DIV2 ( h ) ; <NEW_LINE> }
} <NEW_LINE> sock_cmd_t cmd = { CMD_REMOVE_FD , fd , 0 , 0 , 0 } ; <NEW_LINE> <START_VULN> return send ( ts [ thread_handle ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> int btsock_thread_post_cmd ( int h , int type , const unsigned char * data , int size , uint32_t user_id )
OwnPtr < GIFImageDecoder > decoder = createDecoder ( ) ; <NEW_LINE> <START_VULN> RefPtr < SharedBuffer > data = readFile ( " / Source / web / tests / data / invalid - disposal - method . gif" ) ; <NEW_LINE> <END_VULN> ASSERT_TRUE ( data . get ( ) ) ; <NEW_LINE> decoder -> setData ( data . get ( ) , true ) ;
ASSERT ( ! error ) ; <NEW_LINE> ASSERT ( numSubpatterns == m_numSubpatterns ) ; <NEW_LINE> } <NEW_LINE> constructor . checkForTerminalParentheses ( ) ; <NEW_LINE> constructor . optimizeBOL ( ) ; <NEW_LINE> <START_VULN> constructor . setupOffsets ( ) ; <NEW_LINE> <END_VULN> constructor . setupBeginChars ( ) ; <NEW_LINE> return NoError ; <NEW_LINE> } <NEW_LINE> YarrPattern::YarrPattern ( const UString & pattern , bool ignoreCase , bool multiline , ErrorCode * error ) <NEW_LINE> : m_ignoreCase ( ignoreCase ) <NEW_LINE> , m_multiline ( multiline )
return 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( fields -> MaxLen < 1 ) <NEW_LINE> fields -> MaxLen = fields -> Len ;
BodyStreamBuffer * buffer = new BodyStreamBuffer ( scope . getScriptState ( ) , std::move ( handle ) ) ; <NEW_LINE> checkpoint . Call ( 1 ) ; <NEW_LINE> ScriptValue reason ( scope . getScriptState ( ) , v8String ( scope . getScriptState ( ) -> isolate ( ) , "reason" ) ) ; <NEW_LINE> <START_VULN> buffer -> cancelSource ( scope . getScriptState ( ) , reason ) ; <NEW_LINE> <END_VULN> checkpoint . Call ( 2 ) ; <NEW_LINE> }
} else if ( data [ 0 ] == WHITEHEAT_EVENT ) { <NEW_LINE> dev_dbg ( & urb -> dev -> dev , " % s - event received\n" , __func__ ) ; <NEW_LINE> <START_VULN> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <NEW_LINE> <END_VULN> memcpy ( command_info -> result_buffer , & data [ 1 ] , <NEW_LINE> urb -> actual_length - 1 ) ; <NEW_LINE> command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;
if ( ! dbname && reuse_previous ) <NEW_LINE> <START_VULN> dbname = PQdb ( o_conn ) ; <NEW_LINE> <END_VULN>
PHP_FUNCTION ( mcrypt_module_is_block_mode ) <NEW_LINE> { <NEW_LINE> MCRYPT_GET_MODE_DIR_ARGS ( modes_dir ) <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( mcrypt_module_is_block_mode ( module , dir ) == 1 ) { <NEW_LINE> RETURN_TRUE ; <NEW_LINE> } else {
<START_VULN> if ( diff == StyleDifferenceLayout && parent ( ) && oldStyle -> position ( ) != newStyle . position ( ) ) { <NEW_LINE> <END_VULN> markContainingBlocksForLayout ( ) ; <NEW_LINE> if ( oldStyle -> position ( ) == StaticPosition ) <NEW_LINE> repaint ( ) ;
image -> filename ) ; <NEW_LINE> return ( FALSE ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> iptc_profile = ( StringInfo * ) GetImageProfile ( image , "8bim" ) ; <NEW_LINE> if ( iptc_profile != ( StringInfo * ) NULL ) <NEW_LINE> {
} <NEW_LINE> #endif <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> #ifdef PNG_SET_OPTION_SUPPORTED <NEW_LINE> int PNGAPI <NEW_LINE> png_set_option ( png_structrp png_ptr , int option , int onoff )
void RegisterFileAsBlob ( const GURL & blob_url , <NEW_LINE> <START_VULN> const FilePath & virtual_path , <NEW_LINE> <END_VULN> const FilePath & platform_path ) ;
static PHP_MINIT_FUNCTION ( pcre ) <NEW_LINE> { <NEW_LINE> REGISTER_INI_ENTRIES ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> REGISTER_LONG_CONSTANT ( "PREG_PATTERN_ORDER" , PREG_PATTERN_ORDER , CONST_CS | CONST_PERSISTENT ) ; <NEW_LINE> REGISTER_LONG_CONSTANT ( "PREG_SET_ORDER" , PREG_SET_ORDER , CONST_CS | CONST_PERSISTENT ) ; <NEW_LINE> REGISTER_LONG_CONSTANT ( "PREG_OFFSET_CAPTURE" , PREG_OFFSET_CAPTURE , CONST_CS | CONST_PERSISTENT ) ;
( void ) ParseGeometry ( annotate_info -> geometry , & geometry_info ) ; <NEW_LINE> } <NEW_LINE> if ( SetImageStorageClass ( image , DirectClass , exception ) == MagickFalse ) <NEW_LINE> <START_VULN> return ( MagickFalse ) ; <NEW_LINE> <END_VULN> if ( IsGrayColorspace ( image -> colorspace ) != MagickFalse ) <NEW_LINE> ( void ) SetImageColorspace ( image , sRGBColorspace , exception ) ; <NEW_LINE> status = MagickTrue ;
nsDOMStorage2::Principal ( ) <NEW_LINE> { <NEW_LINE> return mPrincipal ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> nsDOMStorage2::CanAccess ( nsIPrincipal * aPrincipal ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( mStorage -> mSecurityChecker != this ) <NEW_LINE>return mStorage -> mSecurityChecker -> CanAccess ( aPrincipal ) ; <NEW_LINE><NEW_LINE><NEW_LINE>if ( ! aPrincipal ) <NEW_LINE>return true ; <NEW_LINE><NEW_LINE><NEW_LINE>bool subsumes ; <NEW_LINE>nsresult rv = aPrincipal -> SubsumesIgnoringDomain ( mPrincipal , & subsumes ) ; <NEW_LINE>if ( NS_FAILED ( rv ) ) <NEW_LINE>return false ; <NEW_LINE><NEW_LINE>return subsumes ; <NEW_LINE> <END_VULN> } <NEW_LINE> nsPIDOMStorage::nsDOMStorageType <NEW_LINE> nsDOMStorage2::StorageType ( ) <NEW_LINE> { <NEW_LINE> if ( mStorage ) <NEW_LINE> return mStorage -> StorageType ( ) ;
} <NEW_LINE> mPresShellsToInvalidateIfHidden . Clear ( ) ; <NEW_LINE> if ( mViewManagerFlushIsPending ) { <NEW_LINE> #ifdef DEBUG_INVALIDATIONS <NEW_LINE> printf ( "Starting ProcessPendingUpdates\n" ) ; <NEW_LINE> #endif <NEW_LINE> mViewManagerFlushIsPending = false ; <NEW_LINE> <START_VULN> mPresContext -> GetPresShell ( ) -> GetViewManager ( ) -> ProcessPendingUpdates ( ) ; <NEW_LINE> <END_VULN> #ifdef DEBUG_INVALIDATIONS <NEW_LINE> printf ( "Ending ProcessPendingUpdates\n" ) ; <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> if ( mThrottled || <NEW_LINE> ( mTimerIsPrecise != <NEW_LINE> ( GetRefreshTimerType ( ) == nsITimer::TYPE_REPEATING_PRECISE_CAN_SKIP ) ) ) {
vpx_codec_iter_t iter = NULL ; <NEW_LINE> vpx_image_t * img ; <NEW_LINE> struct vpx_usec_timer timer ; <NEW_LINE> <START_VULN> int corrupted ; <NEW_LINE> <END_VULN> frame_avail = 0 ; <NEW_LINE> if ( ! stop_after || frame_in < stop_after ) {
} <NEW_LINE> } <NEW_LINE> for ( i = 1 ; i < argc && ! app -> error ; i ++ ) { <NEW_LINE> <START_VULN> field = stok ( sclone ( argv [ i ] ) , ":" , & typeString ) ; <NEW_LINE> <END_VULN> if ( ( type = ediParseTypeString ( typeString ) ) < 0 ) { <NEW_LINE> fail ( "Unknown type ' % s' for field ' % s'" , typeString , field ) ; <NEW_LINE> break ;
DocumentLoader * loader , <NEW_LINE> ResourceRequest & request , <NEW_LINE> const ResourceResponse & redirect_response , <NEW_LINE> <START_VULN> const FetchInitiatorInfo & initiator_info ) { <NEW_LINE> <END_VULN> if ( initiator_info . name == FetchInitiatorTypeNames::internal ) <NEW_LINE> return ;
JSObject * <NEW_LINE> js::CloneRegExpObject ( JSContext * cx , JSObject * obj_ , JSObject * proto_ ) <NEW_LINE> { <NEW_LINE> RegExpObjectBuilder builder ( cx ) ; <NEW_LINE> Rooted < RegExpObject * > regex ( cx , & obj_ -> as < RegExpObject > ( ) ) ; <NEW_LINE> Rooted < RegExpObject * > proto ( cx , & proto_ -> as < RegExpObject > ( ) ) ; <NEW_LINE> <START_VULN> return builder . clone ( regex , proto ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool <NEW_LINE> js::ParseRegExpFlags ( JSContext * cx , JSString * flagStr , RegExpFlag * flagsOut ) <NEW_LINE> { <NEW_LINE> size_t n = flagStr -> length ( ) ; <NEW_LINE> const jschar * s = flagStr -> getChars ( cx ) ; <NEW_LINE> if ( ! s )
encoded_pixels = ( ( decompression_buffer [ buffer_caret ] & ~ TGA_RLE_FLAG ) + 1 ) ; <NEW_LINE> buffer_caret ++ ; <NEW_LINE> <START_VULN> if ( ( bitmap_caret + ( encoded_pixels * pixel_block_size ) ) > image_block_size ) { <NEW_LINE> <END_VULN> gdFree ( decompression_buffer ) ; <NEW_LINE> gdFree ( conversion_buffer ) ; <NEW_LINE> return - 1 ;
This enables callers to use the O / S socket handle for their own purposes . <NEW_LINE> @param sp Socket object returned from #mprCreateSocket <NEW_LINE> @ingroup MprSocket <NEW_LINE> <START_VULN> @stability Prototype <NEW_LINE> <END_VULN> PUBLIC Socket mprStealSocketHandle ( MprSocket * sp ) ;
return NS_OK ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> OpenCursorHelper::ReleaseMainThreadObjects ( ) <NEW_LINE> { <NEW_LINE> mKeyRange = nullptr ; <NEW_LINE> <START_VULN> IDBObjectStore::ClearStructuredCloneBuffer ( mCloneReadInfo . mCloneBuffer ) ; <NEW_LINE> <END_VULN> mCursor = nullptr ; <NEW_LINE> mSerializedCloneReadInfo . data = nullptr ; <NEW_LINE> mSerializedCloneReadInfo . dataLength = 0 ;
for ( i = 0 ; i < MAXSUB ; ++ i ) <NEW_LINE> sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; <NEW_LINE> <START_VULN> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> #ifdef TEST
blink::WebString GetErrorMessage ( ) const override ; <NEW_LINE> bool DidLoadingProgress ( ) override ; <NEW_LINE> <START_VULN> <NEW_LINE>bool DidGetOpaqueResponseFromServiceWorker ( ) const override ; <NEW_LINE>bool HasSingleSecurityOrigin ( ) const override ; <NEW_LINE>bool DidPassCORSAccessCheck ( ) const override ; <NEW_LINE> <END_VULN> double MediaTimeForTimeValue ( double timeValue ) const override ;
if ( zend_parse_parameters ( argc TSRMLS_CC , "z | ss" , & arg_str , & arg_pattern , & arg_pattern_len , & arg_options , & arg_options_len ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( argc > 1 && arg_pattern_len == 0 ) { <NEW_LINE> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Empty pattern" ) ; <NEW_LINE> RETURN_FALSE ;
w . z = ( row2 . z * v . z ) + w . z ; <NEW_LINE> w . w = ( row2 . w * v . z ) + w . w ; <NEW_LINE> <START_VULN> a = 1 . 0f / MaxF ( w . x , MaxF ( w . y , w . z ) ) ; <NEW_LINE> <END_VULN> v . x = w . x * a ; <NEW_LINE> v . y = w . y * a ;
<START_VULN> if ( png_colorspace_endpoints_match ( xy , & sRGB_xy , 1000 ) ) <NEW_LINE> <END_VULN> colorspace -> flags |= PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB ; <NEW_LINE> else
<START_VULN> #ifndef SAFE_MATH_IMPL_H_ <NEW_LINE>#define SAFE_MATH_IMPL_H_ <NEW_LINE> <END_VULN> #include < stdint . h >
MprJson * child , * job ; <NEW_LINE> int ji ; <NEW_LINE> <START_VULN> if ( ( job = mprGetJsonObj ( route -> config , "app . http . auth . roles" ) ) != 0 ) { <NEW_LINE> <END_VULN> parseAuthRoles ( route , "app . http . auth . roles" , job ) ; <NEW_LINE> } <NEW_LINE> abilities = mprCreateHash ( 0 , 0 ) ;
( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , <NEW_LINE> " Copying JDAT chunk data to color_blob . " ) ; <NEW_LINE> <START_VULN> if ( length != 0 ) <NEW_LINE> <END_VULN> { <NEW_LINE> ( void ) WriteBlob ( color_image , length , chunk ) ; <NEW_LINE> chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ;
if ( ( dst -> data -> size > 0 ) && ( dst -> data != & empty_region ) ) <NEW_LINE> free ( dst -> data ) ; <NEW_LINE> <START_VULN> dst -> data = realloc ( newItems , newItems -> size ) ; <NEW_LINE> <END_VULN> if ( ! dst -> data ) <NEW_LINE> {
DBG ( "Using file ' % s' for emitting touch request notifications" , cfg -> authpending_file ) ; <NEW_LINE> <START_VULN> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <NEW_LINE> <END_VULN> if ( authpending_file_descriptor < 0 ) { <NEW_LINE> DBG ( "Unable to emit 'authentication started' notification by opening the file ' % s' , ( % s ) " , <NEW_LINE> cfg -> authpending_file , strerror ( errno ) ) ;
struct carray_cursor { <NEW_LINE> sqlite3_vtab_cursor base ; <NEW_LINE> sqlite3_int64 iRowid ; <NEW_LINE> <START_VULN> sqlite3_int64 iPtr ; <NEW_LINE> <END_VULN> sqlite3_int64 iCnt ; <NEW_LINE> unsigned char eType ; <NEW_LINE> } ;
return rv ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsEditorSpellCheck::GetCurrentDictionary ( nsAString & aDictionary ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_TRUE ( mSpellChecker , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE> <START_VULN> nsRefPtr < nsEditorSpellCheck > kungFuDeathGrip = this ; <NEW_LINE><NEW_LINE> <END_VULN> return mSpellChecker -> GetCurrentDictionary ( aDictionary ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsEditorSpellCheck::SetCurrentDictionary ( const nsAString & aDictionary ) <NEW_LINE> { <NEW_LINE> NS_ENSURE_TRUE ( mSpellChecker , NS_ERROR_NOT_INITIALIZED ) ; <NEW_LINE> if ( ! mUpdateDictionaryRunning ) { <NEW_LINE> nsDefaultStringComparator comparator ; <NEW_LINE> nsAutoString langCode ; <NEW_LINE> PRInt32 dashIdx = aDictionary . FindChar ( ' - ' ) ; <NEW_LINE> if ( dashIdx != - 1 ) { <NEW_LINE> langCode . Assign ( Substring ( aDictionary , 0 , dashIdx ) ) ; <NEW_LINE> } else {
static const u_char * <NEW_LINE> ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , <NEW_LINE> const struct isakmp_gen * ext , u_int item_len , <NEW_LINE> <START_VULN> const u_char * ep , uint32_t phase , uint32_t doi0 _U_ , <NEW_LINE>uint32_t proto0 _U_ , int depth ) <NEW_LINE> <END_VULN> { <NEW_LINE> const struct ikev1_pl_n * p ; <NEW_LINE> struct ikev1_pl_n n ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . convert1" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( a * , , V8a::HasInstance ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ? V8a::toNative ( v8::Handle < v8::Object > ::Cast ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) : 0 ) ; <NEW_LINE> imp -> convert1 ( ) ;
if ( blocked_reason != ResourceRequestBlockedReason::kNone && <NEW_LINE> reporting_policy == SecurityViolationReportingPolicy::kReport ) { <NEW_LINE> DispatchDidBlockRequest ( resource_request , options . initiator_info , <NEW_LINE> <START_VULN> blocked_reason ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return blocked_reason ; <NEW_LINE> }
if ( i == ch ) return ( 0 ) ; <NEW_LINE> for ( s = 0 ; s < look -> stages ; s ++ ) { <NEW_LINE> for ( i = 0 , l = 0 ; i < partvals ; l ++ ) { <NEW_LINE> if ( s == 0 ) { <NEW_LINE> int temp = vorbis_book_decode ( look -> phrasebook , & vb -> opb ) ; <NEW_LINE> <START_VULN> if ( temp == - 1 ) goto eopbreak ; <NEW_LINE> <END_VULN> partword [ l ] = look -> decodemap [ temp ] ; <NEW_LINE> if ( partword [ l ] == NULL ) goto errout ; <NEW_LINE> } <NEW_LINE> for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) <NEW_LINE> if ( info -> secondstages [ partword [ l ] [ k ] ] & ( 1 << s ) ) { <NEW_LINE> codebook * stagebook = look -> partbooks [ partword [ l ] [ k ] ] [ s ] ;
if ( dst . codecPrivateSize != 0 ) <NEW_LINE> return - 1 ; <NEW_LINE> <START_VULN> dst . codecPrivate = new ( std::nothrow ) unsigned char [ codecPrivateSize ] ; <NEW_LINE> <END_VULN> if ( dst . codecPrivate == NULL ) <NEW_LINE> return - 1 ;
VALUE cCipher ; <NEW_LINE> VALUE eCipherError ; <NEW_LINE> <START_VULN> static ID id_auth_tag_len ; <NEW_LINE> <END_VULN> static VALUE ossl_cipher_alloc ( VALUE klass ) ; <NEW_LINE> static void ossl_cipher_free ( void * ptr ) ;
fseek ( fp , 0 , SEEK_SET ) ; <NEW_LINE> <START_VULN> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <NEW_LINE> <END_VULN> ver = 1 ; <NEW_LINE> for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) <NEW_LINE> {
} else if ( ! strncmp ( token , "asr" , 3 ) ) { <NEW_LINE> op -> operands [ operand ] . shift = ARM_ASR ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <NEW_LINE> <END_VULN> op -> operands_count ++ ; <NEW_LINE> op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; <NEW_LINE> if ( op -> operands [ operand ] . shift_amount > 63 ) {
load_buffer_8x8 ( input + 8 * stride , in1 + 8 , stride ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 , <NEW_LINE> <END_VULN> __m128i * in1 , int stride ) { <NEW_LINE> write_buffer_8x8 ( output , in0 , stride ) ;
#include "vpx / vpx_codec . h" <NEW_LINE> <START_VULN> static const char * const cfg = " -- target = x86_64 - linux - gcc -- disable - sse4_1 -- disable - avx -- disable - avx2 -- as = yasm -- enable - external - build -- enable - realtime - only -- enable - pic -- disable - runtime - cpu - detect" ; <NEW_LINE> <END_VULN> const char * vpx_codec_build_config ( void ) { return cfg ; }
png_crc_read ( png_ptr , buf , 7 ) ; <NEW_LINE> <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> mod_time . second = buf [ 6 ] ;
if ( isTable ( ) ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> if ( isBody ( ) || isRoot ( ) || hasOverflowClip ( ) || isRelPositioned ( ) || <NEW_LINE>isFloatingOrPositioned ( ) || isTableCell ( ) || isInlineBlockOrInlineTable ( ) || hasTransform ( ) || <NEW_LINE>hasReflection ( ) || hasMask ( ) || isWritingModeRoot ( ) ) <NEW_LINE> <END_VULN> return true ; <NEW_LINE> if ( view ( ) && view ( ) -> selectionStart ( ) ) {
{ <NEW_LINE> lastRowIndex = NS_MAX ( 0 , rowIndex - 1 ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> nsTArray < nsIDOMElement * > deleteList ; <NEW_LINE> <END_VULN> for ( rowIndex = 0 ; rowIndex < rowCount ; rowIndex ++ ) <NEW_LINE> { <NEW_LINE> for ( colIndex = 0 ; colIndex < colCount ; colIndex += NS_MAX ( actualColSpan2 , 1 ) ) <NEW_LINE> { <NEW_LINE> res = GetCellDataAt ( table , rowIndex , colIndex , getter_AddRefs ( cell2 ) , <NEW_LINE> & startRowIndex2 , & startColIndex2 ,
ChromeClientChromium * chromeClient = chromeClientChromium ( ) ; <NEW_LINE> if ( chromeClient ) { <NEW_LINE> <START_VULN> IntRect popupRect = frameRect ( ) ; <NEW_LINE> <END_VULN> chromeClient -> popupOpened ( this , layoutAndCalculateWidgetRect ( popupRect . height ( ) , popupRect . location ( ) ) , false ) ; <NEW_LINE> m_popupOpen = true ; <NEW_LINE> }
uint32_t mOwnOrContainingAppId ; <NEW_LINE> private: <NEW_LINE> nsCString mForcedCharset ; <NEW_LINE> nsCString mParentCharset ; <NEW_LINE> nsTObserverArray < nsWeakPtr > mPrivacyObservers ; <NEW_LINE> nsTObserverArray < nsWeakPtr > mReflowObservers ; <NEW_LINE> <START_VULN> int32_t mParentCharsetSource ; <NEW_LINE> <END_VULN> nsCString mOriginalUriString ; <NEW_LINE> nsresult DoFindItemWithName ( const PRUnichar * aName , <NEW_LINE> nsISupports * aRequestor , <NEW_LINE> nsIDocShellTreeItem * aOriginalRequestor , <NEW_LINE> nsIDocShellTreeItem ** _retval ) ;
if ( mDataSource -> readAt ( data_offset + 8 , mSyncSamples , <NEW_LINE> ( size_t ) allocSize ) != ( ssize_t ) allocSize ) { <NEW_LINE> <START_VULN> delete mSyncSamples ; <NEW_LINE> <END_VULN> mSyncSamples = NULL ; <NEW_LINE> return ERROR_IO ; <NEW_LINE> }
} ; <NEW_LINE> template < > struct APIClientTraits < WKPageLoaderClient > { <NEW_LINE> <START_VULN> static const size_t interfaceSizesByVersion [ 2 ] ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> template < > struct APIClientTraits < WKPageUIClient > {
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . convert4" ) ; <NEW_LINE> if ( args . Length ( ) < 1 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( d * , , V8d::HasInstance ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ? V8d::toNative ( v8::Handle < v8::Object > ::Cast ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) : 0 ) ; <NEW_LINE> imp -> convert4 ( ) ;
static png_structp <NEW_LINE> <START_VULN> set_store_for_write ( png_store * ps , png_infopp ppi , <NEW_LINE>PNG_CONST char * volatile name ) <NEW_LINE> <END_VULN> { <NEW_LINE> anon_context ( ps ) ;
if ( ! serialize . init ( builder ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> size_t length = src -> length ( ) ; <NEW_LINE> const jschar * chars = src -> getChars ( cx ) ; <NEW_LINE> if ( ! chars ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> <START_VULN> Parser parser ( cx , NULL , NULL , false ) ; <NEW_LINE> <END_VULN> if ( ! parser . init ( chars , length , filename , lineno , cx -> findVersion ( ) ) ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> serialize . setParser ( & parser ) ; <NEW_LINE> ParseNode * pn = parser . parse ( NULL ) ; <NEW_LINE> if ( ! pn )
} ; <NEW_LINE> <START_VULN> const interp_kernel vp9_filteredinterp_filters1000 [ ( 1 << SUBPEL_BITS ) ] = { <NEW_LINE> <END_VULN> { 0 , 0 , 0 , 128 , 0 , 0 , 0 , 0 } , <NEW_LINE> { 0 , 1 , - 3 , 128 , 3 , - 1 , 0 , 0 } , <NEW_LINE> { - 1 , 2 , - 6 , 127 , 7 , - 2 , 1 , 0 } ,
const nsCString & sourceCString = NS_LossyConvertUTF16toASCII ( flatSource ) ; <NEW_LINE> const PRUint32 maxSourceLength = ( PRUint32 ( 1 ) << 18 ) - 1 ; <NEW_LINE> if ( sourceCString . Length ( ) > maxSourceLength ) <NEW_LINE> return ErrorInvalidValue ( "compileShader: source has more than % d characters" , maxSourceLength ) ; <NEW_LINE> const char * s = sourceCString . get ( ) ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( ! ShCompile ( compiler , & s , 1 , SH_OBJECT_CODE ) ) { <NEW_LINE> <END_VULN> int len = 0 ; <NEW_LINE> ShGetInfo ( compiler , SH_INFO_LOG_LENGTH , & len ) ; <NEW_LINE> if ( len ) { <NEW_LINE> nsCAutoString info ; <NEW_LINE> info . SetLength ( len ) ; <NEW_LINE> ShGetInfoLog ( compiler , info . BeginWriting ( ) ) ; <NEW_LINE> shader -> SetTranslationFailure ( info ) ;
} <NEW_LINE> else <NEW_LINE> { <NEW_LINE> <START_VULN> rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , <NEW_LINE> <END_VULN> & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ; <NEW_LINE> }
continue ; <NEW_LINE> } <NEW_LINE> state -> key = 0 ; <NEW_LINE> <START_VULN> key = getDirective ( line , & value ) ; <NEW_LINE> <END_VULN> if ( ! state -> enabled ) { <NEW_LINE> if ( key [ 0 ] != ' < ' ) { <NEW_LINE> continue ;
Mutex::Autolock autoLock ( mLock ) ; <NEW_LINE> ssize_t index = mLiveNodes . indexOfKey ( the_late_who ) ; <NEW_LINE> <START_VULN> CHECK ( index >= 0 ) ; <NEW_LINE> <END_VULN> instance = mLiveNodes . editValueAt ( index ) ; <NEW_LINE> mLiveNodes . removeItemsAt ( index ) ;
jas_stream_close ( in ) ; <NEW_LINE> #endif <NEW_LINE> } <NEW_LINE> <START_VULN> #line 3846 "dcraw / dcraw . c" <NEW_LINE> <END_VULN> void CLASS crop_masked_pixels ( ) <NEW_LINE> { <NEW_LINE> int row , col ;
} else if ( ' . ' == * src ) { <NEW_LINE> mState = mState_ESC_2e ; <NEW_LINE> } else if ( 'N' == * src ) { <NEW_LINE> mState = mState_ESC_4e ; <NEW_LINE> } else { <NEW_LINE> if ( CHECK_OVERRUN ( dest , destEnd , 2 ) ) <NEW_LINE> goto error1 ; <NEW_LINE> * dest ++ = ( PRUnichar ) 0x1b ; <NEW_LINE> <START_VULN> if ( 0x80 & * src ) <NEW_LINE>goto error2 ; <NEW_LINE> * dest ++ = ( PRUnichar ) * src ; <NEW_LINE> <END_VULN> mState = mLastLegalState ; <NEW_LINE> } <NEW_LINE> break ; <NEW_LINE> case mState_ESC_28: <NEW_LINE> if ( 'B' == * src ) { <NEW_LINE> mState = mState_ASCII ; <NEW_LINE> if ( mRunLength == 0 ) {
phar_flush ( phar_obj -> arc . archive , NULL , 0 , 0 , & error TSRMLS_CC ) ; <NEW_LINE> if ( error ) { <NEW_LINE> <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <NEW_LINE> <END_VULN> efree ( error ) ; <NEW_LINE> }
parser -> m_processor = prologProcessor ; <NEW_LINE> tok = XmlPrologTok ( parser -> m_encoding , s , end , & next ) ; <NEW_LINE> return doProlog ( parser , parser -> m_encoding , s , end , tok , next , nextPtr , <NEW_LINE> <START_VULN> ( XML_Bool ) ! parser -> m_parsingStatus . finalBuffer ) ; <NEW_LINE> <END_VULN> } else <NEW_LINE> #endif <NEW_LINE> {
typedef double iw_tmpsample ; <NEW_LINE> #ifdef IW_64BIT <NEW_LINE> <START_VULN> #define IW_DEFAULT_MAX_DIMENSION 1000000 <NEW_LINE>#define IW_DEFAULT_MAX_MALLOC 2000000000000 <NEW_LINE> <END_VULN> #else <NEW_LINE> #define IW_DEFAULT_MAX_DIMENSION 40000 <NEW_LINE> #define IW_DEFAULT_MAX_MALLOC 2000000000 <NEW_LINE> commit 86564051db45b466e5f667111ce00b5eeedc8fb6 <NEW_LINE> Author: Jason Summers < jason1@pobox . com > <NEW_LINE> Date: Wed Apr 12 10:54:31 2017 - 0400 <NEW_LINE> Reduced the max memory use and image size in 64 - bit builds <NEW_LINE> This is a stopgap measure that should prevent some problems with excessive <NEW_LINE> resource use , and possibly integer overflow . <NEW_LINE> Related: issue #14
} else if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || <NEW_LINE> ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) ) { <NEW_LINE> <START_VULN> guint offset = 0 ; <NEW_LINE> <END_VULN> proto_item * ti = NULL ; <NEW_LINE> proto_tree * hsrp_tree = NULL ; <NEW_LINE> guint8 type , len ;
} <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsAutoRepeatBoxFrame::HandlePress ( nsPresContext * aPresContext , <NEW_LINE> nsGUIEvent * aEvent , <NEW_LINE> nsEventStatus * aEventStatus ) <NEW_LINE> { <NEW_LINE> if ( ! IsActivatedOnHover ( ) ) { <NEW_LINE> mTrustedEvent = NS_IS_TRUSTED_EVENT ( aEvent ) ; <NEW_LINE> DoMouseClick ( aEvent , mTrustedEvent ) ; <NEW_LINE> <START_VULN> StartRepeat ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP <NEW_LINE> nsAutoRepeatBoxFrame::HandleRelease ( nsPresContext * aPresContext , <NEW_LINE> nsGUIEvent * aEvent ,
static void <NEW_LINE> smtp_log_to_file ( smtp_t * smtp ) <NEW_LINE> { <NEW_LINE> <START_VULN> FILE * fp = fopen ( " / tmp / smtp - alert . log" , "a" ) ; <NEW_LINE> <END_VULN> time_t now ; <NEW_LINE> struct tm tm ; <NEW_LINE> char time_buf [ 25 ] ;
{ <NEW_LINE> RefPtr < HTMLBodyElement > fakeBody = HTMLBodyElement::create ( document ) ; <NEW_LINE> <START_VULN> RefPtr < DocumentFragment > fragment = Range::createDocumentFragmentForElement ( markup , fakeBody . get ( ) , scriptingPermission ) ; <NEW_LINE> <END_VULN> if ( fragment && ! baseURL . isEmpty ( ) && baseURL != blankURL ( ) && baseURL != document -> baseURL ( ) ) <NEW_LINE> completeURLs ( fragment . get ( ) , baseURL ) ;
relatedTarget = static_cast < nsMouseEvent_base * > ( mEvent ) -> relatedTarget ; <NEW_LINE> break ; <NEW_LINE> default: <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> if ( relatedTarget ) { <NEW_LINE> nsCOMPtr < nsIContent > content = do_QueryInterface ( relatedTarget ) ; <NEW_LINE> <START_VULN> if ( content && content -> IsInNativeAnonymousSubtree ( ) && <NEW_LINE> <END_VULN> ! nsContentUtils::CanAccessNativeAnon ( ) ) { <NEW_LINE> relatedTarget = content -> FindFirstNonNativeAnonymous ( ) ; <NEW_LINE> if ( ! relatedTarget ) { <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> CallQueryInterface ( relatedTarget , aRelatedTarget ) ;
++ rc -> frames_to_key ; <NEW_LINE> <START_VULN> <NEW_LINE>if ( rc -> frames_to_key >= 2 * ( int ) cpi -> key_frame_frequency ) <NEW_LINE> <END_VULN> break ; <NEW_LINE> } else { <NEW_LINE> ++ rc -> frames_to_key ;
StopPlayback ( ) ; <NEW_LINE> if ( mState != DECODER_STATE_COMPLETED ) { <NEW_LINE> NS_ASSERTION ( IsStateMachineScheduled ( ) , "Must have timer scheduled" ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> StopAudioThread ( ) ; <NEW_LINE> if ( mDecoder -> GetState ( ) == MediaDecoder::PLAY_STATE_PLAYING ) { <NEW_LINE> int64_t videoTime = HasVideo ( ) ? mVideoFrameEndTime : 0 ; <NEW_LINE> int64_t clockTime = NS_MAX ( mEndTime , NS_MAX ( videoTime , GetAudioClock ( ) ) ) ; <NEW_LINE> UpdatePlaybackPosition ( clockTime ) ; <NEW_LINE> nsCOMPtr < nsIRunnable > event = <NEW_LINE> NS_NewRunnableMethod ( mDecoder , & MediaDecoder::PlaybackEnded ) ; <NEW_LINE> NS_DispatchToMainThread ( event , NS_DISPATCH_NORMAL ) ;
SetLinkState ( eLinkState_Unknown ) ; <NEW_LINE> } <NEW_LINE> nsresult rv = nsGenericHTMLElement::SetAttr ( aNameSpaceID , aName , aPrefix , <NEW_LINE> aValue , aNotify ) ; <NEW_LINE> if ( NS_SUCCEEDED ( rv ) ) { <NEW_LINE> PRBool dropSheet = PR_FALSE ; <NEW_LINE> if ( aNameSpaceID == kNameSpaceID_None && aName == nsGkAtoms::rel && <NEW_LINE> <START_VULN> mStyleSheet ) { <NEW_LINE> <END_VULN> nsAutoTArray < nsString , 4 > linkTypes ; <NEW_LINE> nsStyleLinkElement::ParseLinkTypes ( aValue , linkTypes ) ; <NEW_LINE> dropSheet = ! linkTypes . Contains ( NS_LITERAL_STRING ( "stylesheet" ) ) ; <NEW_LINE> } <NEW_LINE> UpdateStyleSheetInternal ( nsnull , <NEW_LINE> dropSheet || <NEW_LINE> ( aNameSpaceID == kNameSpaceID_None &&
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED ( DOMRequest , <NEW_LINE> nsDOMEventTargetHelper ) <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_TRAVERSE ( mError ) <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED ( DOMRequest , <NEW_LINE> nsDOMEventTargetHelper ) <NEW_LINE> <START_VULN> if ( tmp -> mRooted ) { <NEW_LINE>tmp -> UnrootResultVal ( ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> NS_IMPL_CYCLE_COLLECTION_UNLINK ( mError ) <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_UNLINK_END <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED ( DOMRequest , <NEW_LINE> nsDOMEventTargetHelper ) <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_TRACE_JSVAL_MEMBER_CALLBACK ( mResult ) <NEW_LINE> NS_IMPL_CYCLE_COLLECTION_TRACE_END
png_crc_read ( png_ptr , buffer , length ) ; <NEW_LINE> buffer [ length ] = 0 ; <NEW_LINE> <START_VULN> if ( png_crc_finish ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ;
NS_WARNING ( "No DBState ! Profile already closed ? " ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> PRBool requireHostMatch ; <NEW_LINE> nsCAutoString baseDomain ; <NEW_LINE> nsresult rv = GetBaseDomain ( aHostURI , baseDomain , requireHostMatch ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> COOKIE_LOGFAILURE ( SET_COOKIE , aHostURI , aCookieHeader , <NEW_LINE> "couldn't get base domain from URI" ) ; <NEW_LINE> return ; <NEW_LINE> }
<START_VULN> <NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN>
nptrs = backtrace ( buffer , 100 ) ; <NEW_LINE> if ( file_name ) { <NEW_LINE> <START_VULN> fd = open ( file_name , O_WRONLY | O_APPEND | O_CREAT , 0644 ) ; <NEW_LINE> <END_VULN> if ( str ) <NEW_LINE> dprintf ( fd , " % s\n" , str ) ; <NEW_LINE> backtrace_symbols_fd ( buffer , nptrs , fd ) ;
int sumsq = 0 ; <NEW_LINE> int sum = 0 ; <NEW_LINE> uint8_t d [ 16 ] ; <NEW_LINE> <START_VULN> const short * rv2 = rv3 + ( ( c * 17 ) & 127 ) ; <NEW_LINE> <END_VULN> for ( i = - 8 ; i <= 6 ; i ++ ) { <NEW_LINE> sumsq += s [ i * pitch ] * s [ i * pitch ] ;
#include "prprf . h" <NEW_LINE> int main ( ) <NEW_LINE> { <NEW_LINE> double pi = 3 . 1415926 ; <NEW_LINE> double e = 2 . 71828 ; <NEW_LINE> double root2 = 1 . 414 ; <NEW_LINE> <START_VULN> double nan = 0 . 0 / 0 . 0 ; <NEW_LINE> <END_VULN> PR_fprintf ( PR_STDOUT , "pi is % f . \n" , pi ) ; <NEW_LINE> PR_fprintf ( PR_STDOUT , "e is % f . \n" , e ) ; <NEW_LINE> PR_fprintf ( PR_STDOUT , "The square root of 2 is % f . \n" , root2 ) ; <NEW_LINE> PR_fprintf ( PR_STDOUT , "NaN is % f . \n" , nan ) ; <NEW_LINE> PR_fprintf ( PR_STDOUT , "pi is % 301f . \n" , pi ) ; <NEW_LINE> PR_fprintf ( PR_STDOUT , "e is % 65416 . 123f . \n" , e ) ;
PRUint32 depth = mGIFStruct . global_colormap_depth ; <NEW_LINE> if ( q [ 8 ] & 0x80 ) <NEW_LINE> depth = ( q [ 8 ] & 0x07 ) + 1 ; <NEW_LINE> <START_VULN> PRUint32 realDepth = depth ; <NEW_LINE>while ( mGIFStruct . tpixel >= ( 1 << realDepth ) && ( realDepth < 8 ) ) { <NEW_LINE>realDepth ++ ; <NEW_LINE> } <NEW_LINE>nsresult rv = BeginImageFrame ( realDepth ) ; <NEW_LINE> <END_VULN> if ( NS_FAILED ( rv ) || ! mImageData ) { <NEW_LINE> mGIFStruct . state = gif_error ; <NEW_LINE> break ; <NEW_LINE> } <NEW_LINE> if ( q [ 8 ] & 0x40 ) { <NEW_LINE> mGIFStruct . interlaced = PR_TRUE ; <NEW_LINE> mGIFStruct . ipass = 1 ;
virtual ~ NavigatorServiceWorker ( ) ; <NEW_LINE> <START_VULN> static ServiceWorkerContainer * serviceWorker ( Navigator & , ExceptionState & ) ; <NEW_LINE> <END_VULN> DECLARE_VIRTUAL_TRACE ( ) ;
JSObject * obj ; <NEW_LINE> void * ptr ; <NEW_LINE> JSWhyMagic why ; <NEW_LINE> size_t word ; <NEW_LINE> } payload ; <NEW_LINE> } s ; <NEW_LINE> double asDouble ; <NEW_LINE> void * asPtr ; <NEW_LINE> <START_VULN> } jsval_layout ; <NEW_LINE> <END_VULN> # elif JS_BITS_PER_WORD == 64 <NEW_LINE> typedef union jsval_layout <NEW_LINE> { <NEW_LINE> uint64_t asBits ; <NEW_LINE> struct { <NEW_LINE> JSValueTag tag : 17 ; <NEW_LINE> uint64_t payload47 : 47 ; <NEW_LINE> } debugView ;
DomDistillerServiceInterface * dom_distiller_service_ ; <NEW_LINE> <START_VULN> <NEW_LINE>scoped_ptr < ExternalFeedbackReporter > external_feedback_reporter_ ; <NEW_LINE> <END_VULN> DISALLOW_COPY_AND_ASSIGN ( DomDistillerViewerSource ) ; <NEW_LINE> } ;
( jp2_image -> comps [ 0 ] . dx != jp2_image -> comps [ i ] . dx ) || <NEW_LINE> ( jp2_image -> comps [ 0 ] . dy != jp2_image -> comps [ i ] . dy ) || <NEW_LINE> ( jp2_image -> comps [ 0 ] . prec != jp2_image -> comps [ i ] . prec ) || <NEW_LINE> <START_VULN> ( jp2_image -> comps [ 0 ] . sgnd != jp2_image -> comps [ i ] . sgnd ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> opj_destroy_codec ( jp2_codec ) ; <NEW_LINE> opj_image_destroy ( jp2_image ) ;
if ( isRootObject || isViewObject ) <NEW_LINE> setHasBoxDecorations ( true ) ; <NEW_LINE> <START_VULN> setPositioned ( styleToUse -> isPositioned ( ) ) ; <NEW_LINE>setFloating ( ! isPositioned ( ) && styleToUse -> isFloating ( ) ) ; <NEW_LINE> <END_VULN> if ( styleToUse -> overflowX ( ) != OVISIBLE && ! isRootObject && ( isRenderBlock ( ) || isTableRow ( ) || isTableSection ( ) ) ) {
WebsiteSettings ( WebsiteSettingsUI * ui , <NEW_LINE> Profile * profile , <NEW_LINE> TabSpecificContentSettings * tab_specific_content_settings , <NEW_LINE> <START_VULN> InfoBarService * infobar_service , <NEW_LINE> <END_VULN> const GURL & url , <NEW_LINE> const content::SSLStatus & ssl , <NEW_LINE> content::CertStore * cert_store ) ;
DEBUG ( "success" ) ; <NEW_LINE> <START_VULN> usleep ( 250000 ) ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> err_open:
#if DCHECK_IS_ON ( ) && CPU ( 64BIT ) <NEW_LINE> NO_SANITIZE_ADDRESS <NEW_LINE> void HeapObjectHeader::zapMagic ( ) { <NEW_LINE> <START_VULN> ASSERT ( checkHeader ( ) ) ; <NEW_LINE> <END_VULN> m_magic = zappedMagic ; <NEW_LINE> } <NEW_LINE> #endif
int process_mode ; <NEW_LINE> int cur_palette ; <NEW_LINE> <START_VULN> #endif <NEW_LINE> <END_VULN> #if defined ( __TURBOC__ ) && ! defined ( _Windows ) && ! defined ( __FLAT__ )
0 . 9919389832F , 0 . 9931929973F , 0 . 9942985174F , 0 . 9952667537F , <NEW_LINE> 0 . 9961087037F , 0 . 9968351119F , 0 . 9974564312F , 0 . 9979827858F , <NEW_LINE> 0 . 9984239359F , 0 . 9987892441F , 0 . 9990876435F , 0 . 9993276081F , <NEW_LINE> 0 . 9995171241F , 0 . 9996636648F , 0 . 9997741654F , 0 . 9998550016F , <NEW_LINE> 0 . 9999119692F , 0 . 9999502656F , 0 . 9999744742F , 0 . 9999885497F , <NEW_LINE> 0 . 9999958064F , 0 . 9999989077F , 0 . 9999998584F , 0 . 9999999983F , <NEW_LINE> } ; <NEW_LINE> <START_VULN> static float vwin512 [ 256 ] = { <NEW_LINE> <END_VULN> 0 . 0000147849F , 0 . 0001330607F , 0 . 0003695946F , 0 . 0007243509F , <NEW_LINE> 0 . 0011972759F , 0 . 0017882983F , 0 . 0024973285F , 0 . 0033242588F , <NEW_LINE> 0 . 0042689632F , 0 . 0053312973F , 0 . 0065110982F , 0 . 0078081841F , <NEW_LINE> 0 . 0092223540F , 0 . 0107533880F , 0 . 0124010466F , 0 . 0141650703F , <NEW_LINE> 0 . 0160451800F , 0 . 0180410758F , 0 . 0201524373F , 0 . 0223789233F ,
Document * doc = frame -> document ( ) ; <NEW_LINE> if ( doc && doc -> isHTMLDocument ( ) ) { <NEW_LINE> <START_VULN> if ( toHTMLDocument ( doc ) -> hasNamedItem ( propName . impl ( ) ) || doc -> hasElementWithId ( propName . impl ( ) ) ) { <NEW_LINE> <END_VULN> RefPtr < HTMLCollection > items = doc -> windowNamedItems ( propName ) ; <NEW_LINE> if ( ! items -> isEmpty ( ) ) { <NEW_LINE> if ( items -> hasExactlyOneItem ( ) ) {
int LELib_Create ( const effect_uuid_t * uuid , <NEW_LINE> <START_VULN> int32_t sessionId , <NEW_LINE>int32_t ioId , <NEW_LINE> <END_VULN> effect_handle_t * pHandle ) { <NEW_LINE> ALOGV ( "LELib_Create ( ) " ) ; <NEW_LINE> int ret ;
x = i % elements ; <NEW_LINE> y = x % dy + start [ 1 ] ; <NEW_LINE> x = x / dy + start [ 0 ] ; <NEW_LINE> <START_VULN> if ( y < sy && x < sx ) { <NEW_LINE>j = ( ( x * sy + y ) * size ) + b ; <NEW_LINE> <END_VULN> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <NEW_LINE> } <NEW_LINE> }
ps_stream = & ps_dec -> s_bit_stream ; <NEW_LINE> impeg2d_bit_stream_flush_to_byte_boundary ( ps_stream ) ; <NEW_LINE> <START_VULN> while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != u4_start_code_val ) <NEW_LINE> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( impeg2d_bit_stream_get ( ps_stream , 8 ) != 0 )
int pass ; <NEW_LINE> int usage ; <NEW_LINE> int deadline ; <NEW_LINE> <START_VULN> int use_i420 ; <NEW_LINE> <END_VULN> int quiet ; <NEW_LINE> int verbose ; <NEW_LINE> int limit ;
} <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsTransactionItem::UndoChildren ( nsTransactionManager * aTxMgr ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsTransactionItem * item ; <NEW_LINE> <END_VULN> nsresult result = NS_OK ; <NEW_LINE> PRInt32 sz = 0 ; <NEW_LINE> if ( mUndoStack ) { <NEW_LINE> if ( ! mRedoStack && mUndoStack ) { <NEW_LINE> mRedoStack = new nsTransactionRedoStack ( ) ; <NEW_LINE> if ( ! mRedoStack ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ;
break ; <NEW_LINE> case 3: <NEW_LINE> <START_VULN> if ( ( png_ptr -> row_number & 0x03 ) || png_ptr -> width < 3 ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_write_finish_row ( png_ptr ) ; <NEW_LINE> return ;
int32_t type = - 1 ; <NEW_LINE> isChromeShell = ( NS_SUCCEEDED ( dsti -> GetItemType ( & type ) ) && <NEW_LINE> type == nsIDocShellTreeItem::typeChrome ) ; <NEW_LINE> } <NEW_LINE> if ( ! isChromeShell ) { <NEW_LINE> <START_VULN> nsIContent * nonNativeAnon = mContent -> FindFirstNonNativeAnonymous ( ) ; <NEW_LINE> <END_VULN> if ( ! nonNativeAnon || nonNativeAnon -> GetParent ( ) ) { <NEW_LINE> return nullptr ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> nsPIDOMWindow * domWindow = aPresShell -> GetDocument ( ) -> GetWindow ( ) ; <NEW_LINE> if ( domWindow ) {
zlib -> file_bits = file_bits ; <NEW_LINE> if ( new_bits == 0 ) <NEW_LINE> <START_VULN> zlib -> window_bits = file_bits ; <NEW_LINE> <END_VULN> else if ( new_bits != file_bits ) <NEW_LINE> bIn = ( png_byte ) ( ( bIn & 0xf ) + ( ( new_bits - 8 ) << 4 ) ) ;
if ( verbose ) <NEW_LINE> appendPQExpBuffer ( & sql , " ( VERBOSE ) " ) ; <NEW_LINE> <START_VULN> appendPQExpBuffer ( & sql , " SYSTEM % s ; " , PQdb ( conn ) ) ; <NEW_LINE> <END_VULN> if ( ! executeMaintenanceCommand ( conn , sql . data , echo ) ) <NEW_LINE> {
JSClass * clazz = JS_GET_CLASS ( cx , obj ) ; <NEW_LINE> if ( clazz == & sNPObjectJSWrapperClass ) { <NEW_LINE> NPObject * npobj = ( NPObject * ) ::JS_GetPrivate ( cx , obj ) ; <NEW_LINE> <START_VULN> return _retainobject ( npobj ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( ! sJSObjWrappers . ops ) { <NEW_LINE> static PLDHashTableOps ops = <NEW_LINE> { <NEW_LINE> PL_DHashAllocTable ,
} <NEW_LINE> return obj ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> mozJSComponentLoader::ObjectForLocation ( nsIFile * aComponentFile , <NEW_LINE> nsIURI * aURI , <NEW_LINE> <START_VULN> JSObject ** aObject , <NEW_LINE>JSScript ** aTableScript , <NEW_LINE> <END_VULN> char ** aLocation , <NEW_LINE> bool aPropagateExceptions , <NEW_LINE> MutableHandleValue aException ) <NEW_LINE> { <NEW_LINE> JSCLContextHelper cx ( mContext ) ; <NEW_LINE> JS_AbortIfWrongThread ( JS_GetRuntime ( cx ) ) ;
} <NEW_LINE> JS_REQUIRES_STACK JSRecordingStatus <NEW_LINE> TraceRecorder::record_JSOP_ARGSUB ( ) <NEW_LINE> { <NEW_LINE> JSStackFrame * fp = cx -> fp ; <NEW_LINE> if ( ! ( fp -> fun -> flags & JSFUN_HEAVYWEIGHT ) ) { <NEW_LINE> uintN slot = GET_ARGNO ( fp -> regs -> pc ) ; <NEW_LINE> <START_VULN> if ( slot < fp -> argc ) <NEW_LINE>stack ( 0 , get ( & cx -> fp -> argv [ slot ] ) ) ; <NEW_LINE>else <NEW_LINE>stack ( 0 , INS_VOID ( ) ) ; <NEW_LINE> <END_VULN> return JSRS_CONTINUE ; <NEW_LINE> } <NEW_LINE> ABORT_TRACE ( "can't trace JSOP_ARGSUB hard case" ) ; <NEW_LINE> } <NEW_LINE> JS_REQUIRES_STACK LIns * <NEW_LINE> TraceRecorder::guardArgsLengthNotAssigned ( LIns * argsobj_ins ) <NEW_LINE> {
nsCOMPtr < nsIURI > uri ; <NEW_LINE> rv = ioService -> NewURI ( href , nullptr , nullptr , getter_AddRefs ( uri ) ) ; <NEW_LINE> if ( NS_FAILED ( rv ) ) { <NEW_LINE> nsAutoString label ( aHref ) ; <NEW_LINE> aRv . ThrowTypeError ( MSG_INVALID_URL , & label ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> <START_VULN> aRv = mURI -> SetSpec ( href ) ; <NEW_LINE> <END_VULN> UpdateURLSearchParams ( ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> URL::GetOrigin ( nsString & aOrigin ) const <NEW_LINE> { <NEW_LINE> nsContentUtils::GetUTFNonNullOrigin ( mURI , aOrigin ) ; <NEW_LINE> }
printk ( XENLOG_G_INFO <NEW_LINE> "Cannot bind IRQ % d to dom % d . Out of memory . \n" , <NEW_LINE> pirq -> pirq , v -> domain -> domain_id ) ; <NEW_LINE> <START_VULN> rc = - ENOMEM ; <NEW_LINE>goto out ; <NEW_LINE> <END_VULN> } <NEW_LINE> action = newaction ;
{ <NEW_LINE> <START_VULN> PNG_CONST double d = ( 255 - 128 . 5 ) / 65535 ; <NEW_LINE> <END_VULN> that -> rede += d ; <NEW_LINE> that -> greene += d ; <NEW_LINE> that -> bluee += d ;
bool CanSubframeSwapProcess ( const GURL & dest_url , <NEW_LINE> SiteInstance * source_instance , <NEW_LINE> <START_VULN> SiteInstance * dest_instance , <NEW_LINE>bool was_server_redirect ) ; <NEW_LINE> <END_VULN>
nsIFrame * <NEW_LINE> nsCSSFrameConstructor::FindFrameForContentSibling ( nsIContent * aContent , <NEW_LINE> nsIContent * aTargetContent , <NEW_LINE> PRUint8 & aTargetContentDisplay , <NEW_LINE> PRBool aPrevSibling ) <NEW_LINE> { <NEW_LINE> nsIFrame * sibling = mPresShell -> GetPrimaryFrameFor ( aContent ) ; <NEW_LINE> <START_VULN> if ( ! sibling ) { <NEW_LINE> <END_VULN> return nsnull ; <NEW_LINE> } <NEW_LINE> if ( sibling -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) { <NEW_LINE> nsIFrame * placeholderFrame ; <NEW_LINE> mPresShell -> GetPlaceholderFrameFor ( sibling , & placeholderFrame ) ;
HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; <NEW_LINE> switch ( Z_TYPE_P ( offset ) ) { <NEW_LINE> <START_VULN> case IS_STRING: <NEW_LINE> <END_VULN> if ( zend_symtable_find ( ht , Z_STRVAL_P ( offset ) , Z_STRLEN_P ( offset ) + 1 , ( void ** ) & tmp ) != FAILURE ) { <NEW_LINE> if ( check_empty == 2 ) { <NEW_LINE> return 1 ;
source = checkstring ( J , 0 ) ; <NEW_LINE> re = js_toregexp ( J , 1 ) ; <NEW_LINE> <START_VULN> if ( js_regexec ( re -> prog , source , & m , 0 ) ) { <NEW_LINE> <END_VULN> js_copy ( J , 0 ) ; <NEW_LINE> return ; <NEW_LINE> }
tcflags = 0 ; <NEW_LINE> script = JSCompiler::compileScript ( cx , scopeobj , NULL , principals , tcflags , <NEW_LINE> str -> chars ( ) , str -> length ( ) , <NEW_LINE> NULL , file , line ) ; <NEW_LINE> if ( ! script ) <NEW_LINE> return JS_FALSE ; <NEW_LINE> JS_LOCK_OBJ ( cx , obj ) ; <NEW_LINE> <START_VULN> execDepth = GetScriptExecDepth ( cx , obj ) ; <NEW_LINE> <END_VULN> if ( execDepth > 0 ) { <NEW_LINE> JS_UNLOCK_OBJ ( cx , obj ) ; <NEW_LINE> JS_ReportErrorNumber ( cx , js_GetErrorMessage , NULL , <NEW_LINE> JSMSG_COMPILE_EXECED_SCRIPT ) ;
cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 1 ; <NEW_LINE> cpi -> mb . e_mbd . mode_ref_lf_delta_update = 1 ; <NEW_LINE> <START_VULN> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <NEW_LINE>vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <NEW_LINE> <END_VULN> cpi -> mb . e_mbd . ref_lf_deltas [ INTRA_FRAME ] = 2 ;
size_t retlen ; <NEW_LINE> int truncated ; <NEW_LINE> <START_VULN> _dopr ( & buf , NULL , & n , & retlen , & truncated , format , args ) ; <NEW_LINE> <END_VULN> if ( truncated )
static bool URIIsImmutable ( nsIURI * aURI ) <NEW_LINE> { <NEW_LINE> nsCOMPtr < nsIMutable > mutableObj ( do_QueryInterface ( aURI ) ) ; <NEW_LINE> bool isMutable ; <NEW_LINE> return <NEW_LINE> mutableObj && <NEW_LINE> NS_SUCCEEDED ( mutableObj -> GetMutable ( & isMutable ) ) && <NEW_LINE> <START_VULN> ! isMutable ; <NEW_LINE> <END_VULN> } <NEW_LINE> const char nsBasePrincipal::sInvalid [ ] = "Invalid" ; <NEW_LINE> NS_IMETHODIMP_ ( nsrefcnt ) <NEW_LINE> nsBasePrincipal::AddRef ( ) <NEW_LINE> {
OMX_ERRORTYPE ret1 = OMX_ErrorNone ; <NEW_LINE> unsigned int nBufferIndex = drv_ctx . ip_buf . actualcount ; <NEW_LINE> <START_VULN> if ( m_state == OMX_StateInvalid ) { <NEW_LINE> <END_VULN> DEBUG_PRINT_ERROR ( "Empty this buffer in Invalid State" ) ; <NEW_LINE> return OMX_ErrorInvalidState ; <NEW_LINE> }
goto alert_loser ; <NEW_LINE> } <NEW_LINE> sid -> version = ss -> version ; <NEW_LINE> sid -> u . ssl3 . sessionIDLength = sidBytes . len ; <NEW_LINE> PORT_Memcpy ( sid -> u . ssl3 . sessionID , sidBytes . data , sidBytes . len ) ; <NEW_LINE> ss -> ssl3 . hs . isResuming = PR_FALSE ; <NEW_LINE> <START_VULN> ss -> ssl3 . hs . ws = wait_server_cert ; <NEW_LINE> <END_VULN> return SECSuccess ; <NEW_LINE> alert_loser: <NEW_LINE> ( void ) SSL3_SendAlert ( ss , alert_fatal , desc ) ; <NEW_LINE> loser: <NEW_LINE> errCode = ssl_MapLowLevelError ( errCode ) ; <NEW_LINE> return SECFailure ;
IntPoint mapPoint ( const IntPoint & p ) const <NEW_LINE> { <NEW_LINE> <START_VULN> return roundedIntPoint ( mapPoint ( p ) ) ; <NEW_LINE> <END_VULN> }
fprintf ( stderr , "Hit 'h' for help\n\n" ) ; <NEW_LINE> str = gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) ; <NEW_LINE> if ( str ) { <NEW_LINE> <START_VULN> strcpy ( the_url , "MP4Client "GPAC_FULL_VERSION ) ; <NEW_LINE> <END_VULN> gf_term_connect ( term , str ) ; <NEW_LINE> startup_file = 1 ; <NEW_LINE> is_connected = 1 ;
if ( len <= 0 ) { <NEW_LINE> setEof ( true ) ; <NEW_LINE> if ( len < 0 ) { <NEW_LINE> <START_VULN> return - 1 ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> return len ;
class nsHttpRequestHead <NEW_LINE> { <NEW_LINE> public: <NEW_LINE> <START_VULN> nsHttpRequestHead ( ) : mHeaders ( nsHttpHeaderArray::HTTP_REQUEST_HEADERS ) <NEW_LINE> , mMethod ( nsHttp::Get ) <NEW_LINE> , mVersion ( NS_HTTP_VERSION_1_1 ) { } <NEW_LINE> <END_VULN> ~ nsHttpRequestHead ( ) { } <NEW_LINE> void SetMethod ( nsHttpAtom method ) { mMethod = method ; } <NEW_LINE> void SetVersion ( nsHttpVersion version ) { mVersion = version ; } <NEW_LINE> void SetRequestURI ( const nsCSubstring & s ) { mRequestURI = s ; } <NEW_LINE> nsHttpHeaderArray & Headers ( ) { return mHeaders ; } <NEW_LINE> nsHttpAtom Method ( ) { return mMethod ; }
} <NEW_LINE> static JSBool <NEW_LINE> <START_VULN> LookupGetterOrSetter ( JSContext * cx , JSBool wantGetter , jsval * vp ) <NEW_LINE> <END_VULN> { <NEW_LINE> uintN attrs ; <NEW_LINE> JSBool found ;
<START_VULN> class PassPlatformFile { <NEW_LINE> <END_VULN> public: <NEW_LINE> explicit PassPlatformFile ( PlatformFile * value ) : value_ ( value ) { <NEW_LINE> }
template < typename T > <NEW_LINE> struct IsMoveOnlyType { <NEW_LINE> <START_VULN> template < typename U > <NEW_LINE>static YesType Test ( const typename U::MoveOnlyTypeForCPP03 * ) ; <NEW_LINE><NEW_LINE>template < typename U > <NEW_LINE>static NoType Test ( . . . ) ; <NEW_LINE><NEW_LINE>static const bool value = <NEW_LINE>sizeof ( Test < T > ( 0 ) ) == sizeof ( YesType ) && ! IsConst < T > ::value ; <NEW_LINE> <END_VULN> } ;
nsListControlFrame::DidReflow ( nsPresContext * aPresContext , <NEW_LINE> const nsHTMLReflowState * aReflowState , <NEW_LINE> nsDidReflowStatus aStatus ) <NEW_LINE> { <NEW_LINE> nsresult rv ; <NEW_LINE> bool wasInterrupted = ! mHasPendingInterruptAtStartOfReflow && <NEW_LINE> aPresContext -> HasPendingInterrupt ( ) ; <NEW_LINE> <START_VULN> if ( IsInDropDownMode ( ) ) <NEW_LINE> { <NEW_LINE><NEW_LINE>rv = nsHTMLScrollFrame::DidReflow ( aPresContext , aReflowState , aStatus ) ; <NEW_LINE>SyncViewWithFrame ( ) ; <NEW_LINE> } else { <NEW_LINE>rv = nsHTMLScrollFrame::DidReflow ( aPresContext , aReflowState , aStatus ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> if ( mNeedToReset && ! wasInterrupted ) { <NEW_LINE> mNeedToReset = false ;
nsresult rv = NS_OK ; <NEW_LINE> SetMozBackgroundRequest ( aMozBackgroundRequest , rv ) ; <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsXMLHttpRequest::SetMozBackgroundRequest ( bool aMozBackgroundRequest , nsresult & aRv ) <NEW_LINE> { <NEW_LINE> <START_VULN> bool privileged ; <NEW_LINE>aRv = IsCapabilityEnabled ( "UniversalXPConnect" , & privileged ) ; <NEW_LINE>if ( NS_FAILED ( aRv ) ) { <NEW_LINE>return ; <NEW_LINE> } <NEW_LINE><NEW_LINE>if ( ! privileged ) { <NEW_LINE> <END_VULN> aRv = NS_ERROR_DOM_SECURITY_ERR ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> if ( ! ( mState & XML_HTTP_REQUEST_UNSENT ) ) { <NEW_LINE> aRv = NS_ERROR_IN_PROGRESS ; <NEW_LINE> return ;
const double BaseRenderingContext2D::kCDeviceScaleFactor = 1 . 0 ; <NEW_LINE> BaseRenderingContext2D::BaseRenderingContext2D ( ) <NEW_LINE> <START_VULN> : clip_antialiasing_ ( kNotAntiAliased ) { <NEW_LINE> <END_VULN> state_stack_ . push_back ( CanvasRenderingContext2DState::Create ( ) ) ; <NEW_LINE> }
( ctxt -> value -> type == XPATH_NODESET ) && <NEW_LINE> ( ctxt -> value -> nodesetval != NULL ) && <NEW_LINE> ( ctxt -> value -> nodesetval -> nodeNr > 1 ) ) <NEW_LINE> <START_VULN> ctxt -> value -> nodesetval -> nodeNr = 1 ; <NEW_LINE> <END_VULN> return ( total ) ; <NEW_LINE> } <NEW_LINE> }
std::unique_ptr < ServiceWorker::Frontend > frontend_ ; <NEW_LINE> bool enabled_ ; <NEW_LINE> scoped_refptr < ServiceWorkerContextWatcher > context_watcher_ ; <NEW_LINE> <START_VULN> RenderProcessHost * process_ ; <NEW_LINE> <END_VULN> base::WeakPtrFactory < ServiceWorkerHandler > weak_factory_ ;
#endif <NEW_LINE> #endif <NEW_LINE> } else { <NEW_LINE> <START_VULN> strncpy ( result , "undefined" , 10 ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
bool privileged ; <NEW_LINE> if ( NS_FAILED ( IsCapabilityEnabled ( "UniversalXPConnect" , & privileged ) ) ) <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> if ( ! privileged ) { <NEW_LINE> <START_VULN> const char * kInvalidHeaders [ ] = { <NEW_LINE> <END_VULN> "accept - charset" , "accept - encoding" , "access - control - request - headers" , <NEW_LINE> "access - control - request - method" , "connection" , "content - length" , <NEW_LINE> "cookie" , "cookie2" , "content - transfer - encoding" , "date" , "dnt" , <NEW_LINE> "expect" , "host" , "keep - alive" , "origin" , "referer" , "te" , "trailer" , <NEW_LINE> "transfer - encoding" , "upgrade" , "user - agent" , "via" <NEW_LINE> } ; <NEW_LINE> uint32_t i ; <NEW_LINE> for ( i = 0 ; i < ArrayLength ( kInvalidHeaders ) ; ++ i ) {
lfm -> int_4x4_y &= mask_y ; <NEW_LINE> lfm -> int_4x4_uv &= mask_uv_int ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( columns == 1 ) { <NEW_LINE> lfm -> left_uv [ TX_8X8 ] |= lfm -> left_uv [ TX_16X16 ] ;
textp -> text = textp -> key + key_len + 1 ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( text_length ) <NEW_LINE> <END_VULN> memcpy ( textp -> text , text_ptr [ i ] . text , text_length ) ; <NEW_LINE> * ( textp -> text + text_length ) = '\0' ;
int vp9_get_pred_context_single_ref_p2 ( const MACROBLOCKD * xd ) { <NEW_LINE> int pred_context ; <NEW_LINE> <START_VULN> const MB_MODE_INFO * const above_mbmi = get_mbmi ( get_above_mi ( xd ) ) ; <NEW_LINE>const MB_MODE_INFO * const left_mbmi = get_mbmi ( get_left_mi ( xd ) ) ; <NEW_LINE>const int has_above = above_mbmi != NULL ; <NEW_LINE>const int has_left = left_mbmi != NULL ; <NEW_LINE> <END_VULN>
pkt -> data . frame . pts ) ) { <NEW_LINE> die_codec ( codec , "Failed to write compressed frame" ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> printf ( keyframe ? "K" : " . " ) ; <NEW_LINE> fflush ( stdout ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> int main ( int argc , char ** argv ) {
if ( card -> type == SC_CARD_TYPE_IASECC_SAGEM ) { <NEW_LINE> <START_VULN> for ( ii = 0 ; ii < rbuf [ 1 ] - offs ; ii ++ ) <NEW_LINE> <END_VULN> * ( card -> serialnr . value + ii ) = ( ( rbuf [ ii + offs + 1 ] & 0x0F ) << 4 ) <NEW_LINE> + ( ( rbuf [ ii + offs + 2 ] & 0xF0 ) >> 4 ) ; <NEW_LINE> card -> serialnr . len = ii ;
return E_FILE_FORMAT_INVALID ; <NEW_LINE> pos += len ; <NEW_LINE> <START_VULN> assert ( pos <= stop ) ; <NEW_LINE> <END_VULN> const int exp = 7 * len - 1 ; <NEW_LINE> const long long bias = ( 1LL << exp ) - 1LL ;
{ <NEW_LINE> ASSERT ( ! childNeedsStyleInvalidation ( ) ) ; <NEW_LINE> ASSERT ( ! needsStyleInvalidation ( ) ) ; <NEW_LINE> <START_VULN> ASSERT ( insertionPoint -> inDocument ( ) || isContainerNode ( ) ) ; <NEW_LINE> <END_VULN> if ( insertionPoint -> inDocument ( ) ) { <NEW_LINE> setFlag ( InDocumentFlag ) ; <NEW_LINE> insertionPoint -> document ( ) . incrementNodeCount ( ) ;
if ( ! m_layoutObject ) <NEW_LINE> return false ; <NEW_LINE> <START_VULN> return equalIgnoringCase ( getAttribute ( attributeName ) , "true" ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> }
} <NEW_LINE> } <NEW_LINE> <START_VULN> void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <NEW_LINE> <END_VULN> int stride , int eob ) { <NEW_LINE> if ( tx_type == DCT_DCT ) { <NEW_LINE> vp9_idct16x16_add ( input , dest , stride , eob ) ;
png_fixed_point gtest ; <NEW_LINE> if ( ( colorspace -> flags & PNG_COLORSPACE_HAVE_GAMMA ) != 0 && <NEW_LINE> <START_VULN> ( ! png_muldiv ( & gtest , colorspace -> gamma , PNG_FP_1 , gAMA ) || <NEW_LINE>png_gamma_significant ( gtest ) ) ) <NEW_LINE> <END_VULN> {
ALOGV ( "Downmix_Command EFFECT_CMD_GET_PARAM pCmdData % p , * replySize % " PRIu32 " , pReplyData: % p" , <NEW_LINE> pCmdData , * replySize , pReplyData ) ; <NEW_LINE> if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || <NEW_LINE> <START_VULN> pReplyData == NULL || <NEW_LINE> <END_VULN> * replySize < ( int ) sizeof ( effect_param_t ) + 2 * sizeof ( int32_t ) ) { <NEW_LINE> return - EINVAL ; <NEW_LINE> }
#include "vp8 / common / findnearmv . h" <NEW_LINE> #include "vp8 / common / quant_common . h" <NEW_LINE> #include "encodemb . h" <NEW_LINE> <START_VULN> #include "quantize . h" <NEW_LINE>#include "vp8 / common / variance . h" <NEW_LINE> <END_VULN> #include "mcomp . h" <NEW_LINE> #include "rdopt . h" <NEW_LINE> #include "vpx_mem / vpx_mem . h"
return E_FILE_FORMAT_INVALID ; <NEW_LINE> pos += size ; <NEW_LINE> <START_VULN> assert ( ( segment_stop < 0 ) || ( pos <= segment_stop ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> cluster_size = pos - payload_pos ;
ret = DecodeTunnel ( tv , dtv , p , GET_PKT_DATA ( p ) , <NEW_LINE> GET_PKT_LEN ( p ) , pq , proto ) ; <NEW_LINE> <START_VULN> if ( unlikely ( ret != TM_ECODE_OK ) ) { <NEW_LINE><NEW_LINE> <END_VULN> p -> root = NULL ; <NEW_LINE> UNSET_TUNNEL_PKT ( p ) ; <NEW_LINE> TmqhOutputPacketpool ( tv , p ) ;
if ( status == MagickFalse ) <NEW_LINE> continue ; <NEW_LINE> <START_VULN> Ar = GetCacheViewVirtualPixels ( Ar_view , 0 , y , Ar_image -> columns , 1 , exception ) ; <NEW_LINE>Ai = GetCacheViewVirtualPixels ( Ai_view , 0 , y , Ai_image -> columns , 1 , exception ) ; <NEW_LINE>Br = GetCacheViewVirtualPixels ( Br_view , 0 , y , Br_image -> columns , 1 , exception ) ; <NEW_LINE>Bi = GetCacheViewVirtualPixels ( Bi_view , 0 , y , Bi_image -> columns , 1 , exception ) ; <NEW_LINE> <END_VULN> Cr = QueueCacheViewAuthenticPixels ( Cr_view , 0 , y , Cr_image -> columns , 1 , exception ) ; <NEW_LINE> Ci = QueueCacheViewAuthenticPixels ( Ci_view , 0 , y , Ci_image -> columns , 1 , exception ) ; <NEW_LINE> if ( ( Ar == ( const Quantum * ) NULL ) || ( Ai == ( const Quantum * ) NULL ) ||
BUG_ON ( regs -> tstate & TSTATE_PRIV ) ; <NEW_LINE> <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <NEW_LINE> <END_VULN> if ( test_thread_flag ( TIF_32BIT ) ) <NEW_LINE> pc = ( u32 ) pc ;
virtual WebPluginResourceClient * CreateResourceClient ( <NEW_LINE> unsigned long resource_id , <NEW_LINE> const GURL & url , <NEW_LINE> <START_VULN> bool notify_needed , <NEW_LINE>intptr_t notify_data , <NEW_LINE>intptr_t stream ) = 0 ; <NEW_LINE> <END_VULN> } ; <NEW_LINE> }
{ <NEW_LINE> sock_cmd_t cmd = { - 1 , 0 , 0 , 0 , 0 } ; <NEW_LINE> int fd = ts [ h ] . cmd_fdr ; <NEW_LINE> <START_VULN> if ( recv ( fd , & cmd , sizeof ( cmd ) , MSG_WAITALL ) != sizeof ( cmd ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> APPL_TRACE_ERROR ( "recv cmd errno: % d" , errno ) ; <NEW_LINE> return FALSE ;
( ( decoder -> video_info . height - decoder -> video_info . offset_y ) < decoder -> video_info . frame_height ) <NEW_LINE> || <NEW_LINE> ( ( decoder -> video_info . width - decoder -> video_info . offset_x ) < decoder -> video_info . frame_width ) <NEW_LINE> ) <NEW_LINE> { <NEW_LINE> common -> initialised |= - 1 ; <NEW_LINE> return OGGZ_CONTINUE ; <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( theora_decode_init ( & ( decoder -> video_handle ) , & ( decoder -> video_info ) ) ) { <NEW_LINE> common -> initialised |= - 1 ; <NEW_LINE> return OGGZ_CONTINUE ; <NEW_LINE> } <NEW_LINE> common -> initialised |= 1 ; <NEW_LINE> } <NEW_LINE> return OGGZ_CONTINUE ;
mEditor -> SetFlags ( currentFlags ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> nsEditorEventListener::IsFileControlTextBox ( ) <NEW_LINE> { <NEW_LINE> dom::Element * root = mEditor -> GetRoot ( ) ; <NEW_LINE> <START_VULN> if ( root && root -> IsInNativeAnonymousSubtree ( ) ) { <NEW_LINE>nsIContent * parent = root -> FindFirstNonNativeAnonymous ( ) ; <NEW_LINE> <END_VULN> if ( parent && parent -> IsHTML ( nsGkAtoms::input ) ) { <NEW_LINE> nsCOMPtr < nsIFormControl > formControl = do_QueryInterface ( parent ) ; <NEW_LINE> MOZ_ASSERT ( formControl ) ; <NEW_LINE> return formControl -> GetType ( ) == NS_FORM_INPUT_FILE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return false ; <NEW_LINE> }
ALOGV ( "Downmix_Command EFFECT_CMD_SET_PARAM cmdSize % d pCmdData % p , * replySize % " PRIu32 <NEW_LINE> " , pReplyData % p" , cmdSize , pCmdData , * replySize , pReplyData ) ; <NEW_LINE> if ( pCmdData == NULL || ( cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ) <NEW_LINE> <START_VULN> || pReplyData == NULL || * replySize != ( int ) sizeof ( int32_t ) ) { <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> } <NEW_LINE> effect_param_t * cmd = ( effect_param_t * ) pCmdData ;
int length ; <NEW_LINE> DEBUG_MSG ( "\tDissector_postgresql RESPONSE type is clear - text ! " ) ; <NEW_LINE> GET_ULONG_BE ( length , ptr , 1 ) ; <NEW_LINE> <START_VULN> strncpy ( ( char * ) conn_status -> password , ( char * ) ( ptr + 5 ) , length - 4 ) ; <NEW_LINE>conn_status -> password [ length - 4 ] = 0 ; <NEW_LINE> <END_VULN> DISSECT_MSG ( "PostgreSQL credentials: % s - % d: % s: % s\n" , ip_addr_ntoa ( & PACKET -> L3 . dst , tmp ) , ntohs ( PACKET -> L4 . dst ) , conn_status -> user , conn_status -> password ) ; <NEW_LINE> dissect_wipe_session ( PACKET , DISSECT_CODE ( dissector_postgresql ) ) ; <NEW_LINE> } <NEW_LINE> commit e3abe7d7585ecc420a7cab73313216613aadad5a <NEW_LINE> Author: NickSampanis < nicksampanis@gmail . com > <NEW_LINE> Date: Wed Sep 3 13:59:51 2014 + 0300 <NEW_LINE> Fixed heap overflow caused by length
void ScheduleServiceInitialization ( int64 delay_milliseconds ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> void InitializeUserPolicy ( const std::string & user_name ,
thread_t * read_thread = thread_new ( "read_thread" ) ; <NEW_LINE> eager_reader_register ( reader , thread_get_reactor ( read_thread ) , expect_data , ( void * ) small_data ) ; <NEW_LINE> <START_VULN> write ( pipefd [ 1 ] , small_data , strlen ( small_data ) ) ; <NEW_LINE> <END_VULN> semaphore_wait ( done ) ; <NEW_LINE> eager_reader_free ( reader ) ;
for ( plane = 0 ; plane < 3 ; ++ plane ) { <NEW_LINE> const unsigned char * buf = img -> planes [ plane ] ; <NEW_LINE> const int stride = img -> stride [ plane ] ; <NEW_LINE> <START_VULN> const int w = vpx_img_plane_width ( img , plane ) ; <NEW_LINE> <END_VULN> const int h = vpx_img_plane_height ( img , plane ) ; <NEW_LINE> int y ;
JSObject * aGlobal ) <NEW_LINE> : mWrappedNativeMap ( Native2WrappedNativeMap::newMap ( XPC_NATIVE_MAP_SIZE ) ) , <NEW_LINE> mWrappedNativeProtoMap ( ClassInfo2WrappedNativeProtoMap::newMap ( XPC_NATIVE_PROTO_MAP_SIZE ) ) , <NEW_LINE> mMainThreadWrappedNativeProtoMap ( ClassInfo2WrappedNativeProtoMap::newMap ( XPC_NATIVE_PROTO_MAP_SIZE ) ) , <NEW_LINE> mComponents ( nullptr ) , <NEW_LINE> mNext ( nullptr ) , <NEW_LINE> mGlobalJSObject ( nullptr ) , <NEW_LINE> mPrototypeNoHelper ( nullptr ) , <NEW_LINE> <START_VULN> mExperimentalBindingsEnabled ( XPCJSRuntime::Get ( ) -> ExperimentalBindingsEnabled ( ) ) <NEW_LINE> <END_VULN> { <NEW_LINE> { <NEW_LINE> XPCAutoLock lock ( XPCJSRuntime::Get ( ) -> GetMapLock ( ) ) ; <NEW_LINE> #ifdef DEBUG <NEW_LINE> for ( XPCWrappedNativeScope * cur = gScopes ; cur ; cur = cur -> mNext ) <NEW_LINE> MOZ_ASSERT ( aGlobal != cur -> GetGlobalJSObjectPreserveColor ( ) , "dup object" ) ;
goto out_drop ; <NEW_LINE> rqstp -> rq_xprt_hlen = ret ; <NEW_LINE> <START_VULN> if ( svc_rdma_is_backchannel_reply ( xprt , rmsgp ) ) { <NEW_LINE>ret = svc_rdma_handle_bc_reply ( xprt -> xpt_bc_xprt , rmsgp , <NEW_LINE> <END_VULN> & rqstp -> rq_arg ) ; <NEW_LINE> svc_rdma_put_context ( ctxt , 0 ) ; <NEW_LINE> if ( ret )
#include "file . h" <NEW_LINE> #ifndef lint <NEW_LINE> <START_VULN> FILE_RCSID ( "@ ( # ) $ File: readelf . c , v 1 . 114 2014 / 12 / 11 14:19:36 christos Exp $ " ) <NEW_LINE> <END_VULN> #endif <NEW_LINE> #ifdef BUILTIN_ELF
FRIEND_TEST_ALL_PREFIXES ( content::AppCacheDatabaseTest , DeletableResponseIds ) ; <NEW_LINE> FRIEND_TEST_ALL_PREFIXES ( content::AppCacheDatabaseTest , OriginUsage ) ; <NEW_LINE> FRIEND_TEST_ALL_PREFIXES ( content::AppCacheDatabaseTest , <NEW_LINE> <START_VULN> UpgradeSchemaNukesDeprecatedVersion ) ; <NEW_LINE> <END_VULN> FRIEND_TEST_ALL_PREFIXES ( content::AppCacheDatabaseTest , WasCorrutionDetected ) ; <NEW_LINE> DISALLOW_COPY_AND_ASSIGN ( AppCacheDatabase ) ;
ctxt = xmlRelaxNGNewMemParserCtxt ( ( char * ) base , info . st_size ) ; <NEW_LINE> xmlRelaxNGSetParserErrors ( ctxt , <NEW_LINE> <START_VULN> ( xmlRelaxNGValidityErrorFunc ) fprintf , <NEW_LINE> ( xmlRelaxNGValidityWarningFunc ) fprintf , <NEW_LINE>stderr ) ; <NEW_LINE> <END_VULN> schema = xmlRelaxNGParse ( ctxt ) ; <NEW_LINE> xmlRelaxNGFreeParserCtxt ( ctxt ) ; <NEW_LINE> munmap ( ( char * ) base , info . st_size ) ;
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 2 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> TestObj * objArg ( toTestObj ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
TEST ( GIFImageDecoderTest , badTerminator ) <NEW_LINE> { <NEW_LINE> <START_VULN> RefPtr < SharedBuffer > referenceData = readFile ( " / Source / web / tests / data / radient . gif" ) ; <NEW_LINE>RefPtr < SharedBuffer > testData = readFile ( " / Source / web / tests / data / radient - bad - terminator . gif" ) ; <NEW_LINE> <END_VULN> ASSERT_TRUE ( referenceData . get ( ) ) ; <NEW_LINE> ASSERT_TRUE ( testData . get ( ) ) ;
mEditor -> SetFlags ( currentFlags ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> nsEditorEventListener::IsFileControlTextBox ( ) <NEW_LINE> { <NEW_LINE> dom::Element * root = mEditor -> GetRoot ( ) ; <NEW_LINE> <START_VULN> if ( root && root -> IsInNativeAnonymousSubtree ( ) ) { <NEW_LINE> <END_VULN> nsIContent * parent = root -> FindFirstNonNativeAnonymous ( ) ; <NEW_LINE> if ( parent && parent -> IsHTML ( nsGkAtoms::input ) ) { <NEW_LINE> nsCOMPtr < nsIFormControl > formControl = do_QueryInterface ( parent ) ; <NEW_LINE> MOZ_ASSERT ( formControl ) ; <NEW_LINE> return formControl -> GetType ( ) == NS_FORM_INPUT_FILE ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return false ;
* ( q ++ ) = * p ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> * q = '\0' ; <NEW_LINE> * retlen = ( size_t ) ( q - ret ) ; <NEW_LINE> }
<START_VULN> ZEND_BEGIN_ARG_INFO ( arginfo_info___construct , 0 ) <NEW_LINE> <END_VULN> ZEND_ARG_INFO ( 0 , file_name ) <NEW_LINE> ZEND_END_ARG_INFO ( )
} <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsPresContext::AppUnitsPerDevPixelChanged ( ) <NEW_LINE> { <NEW_LINE> InvalidateThebesLayers ( ) ; <NEW_LINE> <START_VULN> mDeviceContext -> FlushFontCache ( ) ; <NEW_LINE> <END_VULN> if ( HasCachedStyleData ( ) ) { <NEW_LINE> MediaFeatureValuesChanged ( eAlwaysRebuildStyle , NS_STYLE_HINT_REFLOW ) ; <NEW_LINE> } <NEW_LINE> mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel ( ) ; <NEW_LINE> }
using CopyOrMoveOption = FileSystemOperation::CopyOrMoveOption ; <NEW_LINE> using GetMetadataField = FileSystemOperation::GetMetadataField ; <NEW_LINE> <START_VULN> using OperationID = int ; <NEW_LINE> <END_VULN> virtual ~ FileSystemOperationRunner ( ) ;
<START_VULN> JSGlobalContextRef context = toGlobalRef ( coreFrame -> script ( ) -> globalObject ( ) -> globalExec ( ) ) ; <NEW_LINE>JSObjectRef windowObject = toRef ( coreFrame -> script ( ) -> globalObject ( ) ) ; <NEW_LINE> <END_VULN> ASSERT ( windowObject ) ; <NEW_LINE> WebKitWebView * webView = getViewFromFrame ( m_frame ) ;
int partwords = ( partvals + partitions_per_word - 1 ) / partitions_per_word ; <NEW_LINE> char * partword = <NEW_LINE> <START_VULN> ( char * ) alloca ( partwords * partitions_per_word * sizeof ( * partword ) ) ; <NEW_LINE> <END_VULN> int beginoff = info -> begin / ch ; <NEW_LINE> for ( i = 0 ; i < ch ; i ++ ) if ( nonzero [ i ] ) break ;
const int32 new_frames_size = frames_size_ - shift_left ; <NEW_LINE> for ( int32 i = 0 ; i < new_frames_size ; ++ i ) { <NEW_LINE> <START_VULN> frames_ [ i ] = frames_ [ i + shift_left ] ; <NEW_LINE> <END_VULN> } <NEW_LINE> frames_size_ = new_frames_size ;
SPL_METHOD ( FilesystemIterator , getFlags ) <NEW_LINE> { <NEW_LINE> spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( zend_parse_parameters_none ( ) == FAILURE ) { <NEW_LINE> return ; <NEW_LINE> }
SkipRoot skipHash ( cx , & p ) ; <NEW_LINE> if ( p ) { <NEW_LINE> JSAtom * atom = p -> asPtr ( ) ; <NEW_LINE> p -> setTagged ( bool ( ib ) ) ; <NEW_LINE> js_free ( tbchars ) ; <NEW_LINE> return atom ; <NEW_LINE> } <NEW_LINE> <START_VULN> AutoEnterAtomsCompartment ac ( cx ) ; <NEW_LINE> <END_VULN> JSFlatString * flat = js_NewString < CanGC > ( cx , tbchars , length ) ; <NEW_LINE> if ( ! flat ) { <NEW_LINE> js_free ( tbchars ) ; <NEW_LINE> return NULL ; <NEW_LINE> } <NEW_LINE> JSAtom * atom = flat -> morphAtomizedStringIntoAtom ( ) ;
mCacheUpdate -> AddObserver ( this , PR_TRUE ) ; <NEW_LINE> return NS_OK ; <NEW_LINE> } <NEW_LINE> already_AddRefed < nsIApplicationCacheContainer > <NEW_LINE> nsDOMOfflineResourceList::GetDocumentAppCacheContainer ( ) <NEW_LINE> { <NEW_LINE> <START_VULN> nsCOMPtr < nsIDOMWindow > window = do_QueryReferent ( mWindow ) ; <NEW_LINE>if ( ! window ) { <NEW_LINE>return nsnull ; <NEW_LINE> } <NEW_LINE><NEW_LINE>nsCOMPtr < nsIWebNavigation > webnav = do_GetInterface ( window ) ; <NEW_LINE> <END_VULN> if ( ! webnav ) { <NEW_LINE> return nsnull ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIApplicationCacheContainer > appCacheContainer = <NEW_LINE> do_GetInterface ( webnav ) ; <NEW_LINE> return appCacheContainer . forget ( ) ; <NEW_LINE> }
} <NEW_LINE> bool deletedSetter = false ; <NEW_LINE> if ( mSetterText && mSetterText -> GetText ( ) ) { <NEW_LINE> nsDependentString setter ( mSetterText -> GetText ( ) ) ; <NEW_LINE> if ( ! setter . IsEmpty ( ) ) { <NEW_LINE> JSObject * setterObject = nullptr ; <NEW_LINE> <START_VULN> JSContext * cx = aContext -> GetNativeContext ( ) ; <NEW_LINE> <END_VULN> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSAutoCompartment ac ( cx , aClassObject ) ; <NEW_LINE> JS::CompileOptions options ( cx ) ; <NEW_LINE> options . setFileAndLine ( functionUri . get ( ) , mSetterText -> GetLineNumber ( ) ) <NEW_LINE> . setVersion ( JSVERSION_LATEST ) <NEW_LINE> . setUserBit ( true ) ; <NEW_LINE> nsCString name = NS_LITERAL_CSTRING ( "set_" ) + NS_ConvertUTF16toUTF8 ( mName ) ; <NEW_LINE> js::RootedObject rootedNull ( cx , nullptr ) ;
loff_t * ppos ) <NEW_LINE> { <NEW_LINE> struct usb_yurex * dev ; <NEW_LINE> <START_VULN> int retval = 0 ; <NEW_LINE>int bytes_read = 0 ; <NEW_LINE> <END_VULN> char in_buffer [ 20 ] ; <NEW_LINE> unsigned long flags ;
Platform::current ( ) -> recordAction ( <NEW_LINE> UserMetricsAction ( "Media . Controls . VolumeChangeEnd" ) ) ; <NEW_LINE> <START_VULN> double volume = value ( ) . toDouble ( ) ; <NEW_LINE>mediaElement ( ) . setVolume ( volume ) ; <NEW_LINE>mediaElement ( ) . setMuted ( false ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> bool MediaControlVolumeSliderElement::willRespondToMouseMoveEvents ( ) {
case cs_cp866: <NEW_LINE> table = unimap_cp866 ; <NEW_LINE> table_size = sizeof ( unimap_cp866 ) / sizeof ( * unimap_cp866 ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> table_over_7F: <NEW_LINE> if ( code <= 0x7F ) { <NEW_LINE> * res = code ;
const char * s = sourceCString . get ( ) ; <NEW_LINE> compiler = ShConstructCompiler ( ( ShShaderType ) shader -> ShaderType ( ) , <NEW_LINE> SH_WEBGL_SPEC , <NEW_LINE> targetShaderSourceLanguage , <NEW_LINE> & resources ) ; <NEW_LINE> <START_VULN> int compileOptions = SH_ATTRIBUTES_UNIFORMS ; <NEW_LINE> <END_VULN> if ( useShaderSourceTranslation ) { <NEW_LINE> compileOptions |= SH_OBJECT_CODE <NEW_LINE> | SH_MAP_LONG_VARIABLE_NAMES ; <NEW_LINE> #ifdef XP_MACOSX <NEW_LINE> if ( gl -> WorkAroundDriverBugs ( ) ) { <NEW_LINE> if ( gl -> Vendor ( ) == gl::GLContext::VendorATI ) { <NEW_LINE> compileOptions |= SH_EMULATE_BUILT_IN_FUNCTIONS ;
virtual ~ nsXBLProtoImplMember ( ) { <NEW_LINE> nsMemory::Free ( mName ) ; <NEW_LINE> NS_CONTENT_DELETE_LIST_MEMBER ( nsXBLProtoImplMember , this , mNext ) ; <NEW_LINE> } <NEW_LINE> nsXBLProtoImplMember * GetNext ( ) { return mNext ; } <NEW_LINE> void SetNext ( nsXBLProtoImplMember * aNext ) { mNext = aNext ; } <NEW_LINE> <START_VULN> virtual nsresult InstallMember ( nsIScriptContext * aContext , <NEW_LINE>nsIContent * aBoundElement , <NEW_LINE>JSObject * aScriptObject , <NEW_LINE>JSObject * aTargetClassObject , <NEW_LINE>const nsCString & aClassStr ) = 0 ; <NEW_LINE> <END_VULN> virtual nsresult CompileMember ( nsIScriptContext * aContext , <NEW_LINE> const nsCString & aClassStr , <NEW_LINE> JSObject * aClassObject ) = 0 ; <NEW_LINE> virtual void Trace ( TraceCallback aCallback , void * aClosure ) const = 0 ; <NEW_LINE> virtual nsresult Write ( nsIScriptContext * aContext , <NEW_LINE> nsIObjectOutputStream * aStream )
<START_VULN> #ifndef CHROME_BROWSER_CHROMEOS_LOW_BATTERY_OBSERVER_H_ <NEW_LINE>#define CHROME_BROWSER_CHROMEOS_LOW_BATTERY_OBSERVER_H_ <NEW_LINE> <END_VULN> #pragma once <NEW_LINE> #include "base / basictypes . h"
bool needquotes ; <NEW_LINE> <START_VULN> needquotes = false ; <NEW_LINE> <END_VULN> for ( s = str ; * s ; s ++ ) <NEW_LINE> { <NEW_LINE> if ( ! ( ( * s >= 'a' && * s <= 'z' ) || ( * s >= 'A' && * s <= 'Z' ) ||
filetype -> type ) ; <NEW_LINE> if ( format ) <NEW_LINE> <START_VULN> { <NEW_LINE>_cupsStrFree ( format -> values [ 0 ] . string . text ) ; <NEW_LINE><NEW_LINE>format -> values [ 0 ] . string . text = _cupsStrAlloc ( mimetype ) ; <NEW_LINE> } <NEW_LINE> <END_VULN> else <NEW_LINE> ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_MIMETYPE , <NEW_LINE> "document - format" , NULL , mimetype ) ;
<START_VULN> #ifndef BASE_DEFAULT_CLOCK_H_ <NEW_LINE>#define BASE_DEFAULT_CLOCK_H_ <NEW_LINE> <END_VULN> #include "base / base_export . h" <NEW_LINE> #include "base / compiler_specific . h"
imgdata . rawdata . raw_alloc = 0 ; <NEW_LINE> <START_VULN> imgdata . image = ( ushort ( * ) [ 4 ] ) calloc ( unsigned ( S . raw_width ) * unsigned ( S . raw_height ) , sizeof ( * imgdata . image ) ) ; <NEW_LINE> <END_VULN> if ( ! ( decoder_info . decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL ) ) <NEW_LINE> { <NEW_LINE> imgdata . rawdata . raw_image = ( ushort * ) imgdata . image ;
int ret = 0 ; <NEW_LINE> ve -> stretch ++ ; <NEW_LINE> if ( ve -> stretch > VE_MAXSTRETCH * 2 ) <NEW_LINE> ve -> stretch = VE_MAXSTRETCH * 2 ; <NEW_LINE> for ( i = 0 ; i < ve -> ch ; i ++ ) { <NEW_LINE> float * pcm = v -> pcm [ i ] + ve -> searchstep * ( j ) ; <NEW_LINE> <START_VULN> ret |= _ve_amp ( ve , gi , pcm , ve -> band , ve -> filter + i * VE_BANDS , j ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> ve -> mark [ j + VE_POST ] = 0 ; <NEW_LINE> if ( ret & 1 ) { <NEW_LINE> ve -> mark [ j ] = 1 ; <NEW_LINE> ve -> mark [ j + 1 ] = 1 ; <NEW_LINE> }
parenSoFar - curState -> parenSoFar ) ) { <NEW_LINE> goto bad ; <NEW_LINE> } <NEW_LINE> <START_VULN> -- gData -> stateStackTop ; <NEW_LINE> <END_VULN> pc = pc + GET_OFFSET ( pc ) ; <NEW_LINE> op = ( REOp ) * pc ++ ; <NEW_LINE> JS_ASSERT ( op < REOP_LIMIT ) ;
stubcc . linkExit ( emptyFreeList , Uses ( 0 ) ) ; <NEW_LINE> stubcc . leave ( ) ; <NEW_LINE> stubcc . masm . storePtr ( ImmPtr ( type ) , FrameAddress ( offsetof ( VMFrame , scratch ) ) ) ; <NEW_LINE> stubcc . masm . move ( ImmPtr ( stubArg ) , Registers::ArgReg1 ) ; <NEW_LINE> OOL_STUBCALL ( stub , REJOIN_FALLTHROUGH ) ; <NEW_LINE> <START_VULN> frame . pushTypedPayload ( JSVAL_TYPE_OBJECT , result ) ; <NEW_LINE> <END_VULN> stubcc . rejoin ( Changes ( 1 ) ) ; <NEW_LINE> frame . extra ( frame . peek ( - 1 ) ) . initArray = ( * PC == JSOP_NEWARRAY ) ; <NEW_LINE> frame . extra ( frame . peek ( - 1 ) ) . initObject = baseobj ; <NEW_LINE> return true ; <NEW_LINE> }
JS_ASSERT ( script != JSScript::emptyScript ( ) ) ; <NEW_LINE> JSDestroyScriptHook hook ; <NEW_LINE> hook = cx -> debugHooks -> destroyScriptHook ; <NEW_LINE> if ( hook ) <NEW_LINE> hook ( cx , script , cx -> debugHooks -> destroyScriptHookData ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void <NEW_LINE>js_DestroyScript ( JSContext * cx , JSScript * script ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( script == JSScript::emptyScript ( ) ) { <NEW_LINE> JS_RUNTIME_UNMETER ( cx -> runtime , liveEmptyScripts ) ; <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> js_CallDestroyScriptHook ( cx , script ) ; <NEW_LINE> JS_ClearScriptTraps ( cx , script ) ;
return res ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up ) <NEW_LINE> <END_VULN> { <NEW_LINE> size_t n ; <NEW_LINE> uint32_t types = up -> types ;
PRBool <NEW_LINE> nsComputedDOMStyle::GetFrameBoundsHeightForTransform ( nscoord & aHeight ) <NEW_LINE> { <NEW_LINE> if ( ! mInnerFrame ) { <NEW_LINE> return PR_FALSE ; <NEW_LINE> } <NEW_LINE> <START_VULN> FlushPendingReflows ( ) ; <NEW_LINE> <END_VULN> if ( ! mInnerFrame -> GetStyleDisplay ( ) -> HasTransform ( ) ) <NEW_LINE> return PR_FALSE ; <NEW_LINE> aHeight = nsDisplayTransform::GetFrameBoundsForTransform ( mInnerFrame ) . height ; <NEW_LINE> return PR_TRUE ; <NEW_LINE> }
if ( p_buf -> len == 0 ) <NEW_LINE> return SENT_ALL ; <NEW_LINE> <START_VULN> ssize_t sent = send ( fd , p_buf -> data + p_buf -> offset , p_buf -> len , MSG_DONTWAIT ) ; <NEW_LINE> <END_VULN> if ( sent == - 1 ) { <NEW_LINE> if ( errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR )
if ( aElement ) { <NEW_LINE> nsCOMPtr < nsIContent > content = do_QueryInterface ( aElement ) ; <NEW_LINE> if ( content ) { <NEW_LINE> <START_VULN> aDocObserver -> ContentRemoved ( nsnull , aParentContent , content , - 1 ) ; <NEW_LINE> <END_VULN> content -> SetParent ( nsnull ) ; <NEW_LINE> content -> SetBindingParent ( nsnull ) ; <NEW_LINE> content -> SetDocument ( nsnull , PR_TRUE , PR_TRUE ) ;
return InliningStatus_NotInlined ; <NEW_LINE> if ( CallResultEscapes ( pc ) && getInlineReturnType ( ) != MIRType_Boolean ) <NEW_LINE> return InliningStatus_NotInlined ; <NEW_LINE> if ( getInlineThisType ( callInfo ) != MIRType_Object ) <NEW_LINE> return InliningStatus_NotInlined ; <NEW_LINE> if ( getInlineArgType ( callInfo , 0 ) != MIRType_String ) <NEW_LINE> return InliningStatus_NotInlined ; <NEW_LINE> callInfo . unwrapArgs ( ) ; <NEW_LINE> MInstruction * match = MRegExpTest::New ( callInfo . thisArg ( ) , callInfo . getArg ( 0 ) ) ; <NEW_LINE> current -> add ( match ) ; <NEW_LINE> current -> push ( match ) ; <NEW_LINE> <START_VULN> - <NEW_LINE> <END_VULN> tg: ( 8999ad0 ) t / bug849014 -- Bug 849014 - Check type inference before optimizing regexp calls . r = <NEW_LINE> tg: depends on ( ae1c51d ) master --
if ( mNextBinding ) { <NEW_LINE> nsresult rv = mNextBinding -> InstallImplementation ( ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> } <NEW_LINE> if ( AllowScripts ( ) ) <NEW_LINE> <START_VULN> return mPrototypeBinding -> InstallImplementation ( mBoundElement ) ; <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> } <NEW_LINE> nsIAtom * <NEW_LINE> nsXBLBinding::GetBaseTag ( int32_t * aNameSpaceID ) <NEW_LINE> { <NEW_LINE> nsIAtom * tag = mPrototypeBinding -> GetBaseTag ( aNameSpaceID ) ;
return NS_OK ; <NEW_LINE> return InsertFromTransferable ( trans , nullptr , contextStr , infoStr , <NEW_LINE> nullptr , 0 , true ) ; <NEW_LINE> } <NEW_LINE> NS_IMETHODIMP nsHTMLEditor::PasteTransferable ( nsITransferable * aTransferable ) <NEW_LINE> { <NEW_LINE> <START_VULN> if ( ! FireClipboardEvent ( NS_PASTE ) ) <NEW_LINE> <END_VULN> return NS_OK ; <NEW_LINE> nsCOMPtr < nsIDOMDocument > domdoc = GetDOMDocument ( ) ; <NEW_LINE> if ( ! nsEditorHookUtils::DoInsertionHook ( domdoc , nullptr , aTransferable ) ) <NEW_LINE> return NS_OK ; <NEW_LINE> nsAutoString contextStr , infoStr ;
info -> dev = dev ; <NEW_LINE> usb_fill_bulk_urb ( urb , priv -> udev , usb_sndbulkpipe ( priv -> udev , 2 ) , <NEW_LINE> hdr , skb -> len , rtl8187_tx_cb , skb ) ; <NEW_LINE> <START_VULN> usb_submit_urb ( urb , GFP_ATOMIC ) ; <NEW_LINE> <END_VULN> return 0 ; <NEW_LINE> }
ASSERT_GC_OBJECT_INHERITS ( castedThis , & JSTestObj::s_info ) ; <NEW_LINE> TestObj * impl = static_cast < TestObj * > ( castedThis -> impl ( ) ) ; <NEW_LINE> if ( exec -> argumentCount ( ) < 1 ) <NEW_LINE> <START_VULN> return throwVMError ( exec , createTypeError ( exec , "Not enough arguments" ) ) ; <NEW_LINE> <END_VULN> TestObj * objArg ( toTestObj ( MAYBE_MISSING_PARAMETER ( exec , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> if ( exec -> hadException ( ) ) <NEW_LINE> return JSValue::encode ( jsUndefined ( ) ) ;
( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; <NEW_LINE> fputs ( "\n" , config -> errors ) ; <NEW_LINE> ptr += cut + 1 ; <NEW_LINE> <START_VULN> len - = cut ; <NEW_LINE> <END_VULN> } <NEW_LINE> else { <NEW_LINE> fputs ( ptr , config -> errors ) ;
return HandleCharMessage ( msg , nullptr , & aExtraFlags ) ; <NEW_LINE> } <NEW_LINE> if ( msg . message == WM_DEADCHAR ) { <NEW_LINE> bool defaultPrevented = aExtraFlags . mDefaultPrevented ; <NEW_LINE> if ( mWidget -> PluginHasFocus ( ) ) { <NEW_LINE> <START_VULN> defaultPrevented = mWidget -> DispatchPluginEvent ( msg ) || defaultPrevented ; <NEW_LINE> <END_VULN> } <NEW_LINE> return defaultPrevented ; <NEW_LINE> } <NEW_LINE> bool defaultPrevented = ( HandleCharMessage ( msg , nullptr , & aExtraFlags ) || <NEW_LINE> aExtraFlags . mDefaultPrevented ) ;
<START_VULN> const uint64_t mask_y = ( ( ( 1 << columns ) - 1 ) ) * 0x0101010101010101 ; <NEW_LINE> <END_VULN> const uint16_t mask_uv = ( ( 1 << ( ( columns + 1 ) >> 1 ) ) - 1 ) * 0x1111 ;
} <NEW_LINE> } ; <NEW_LINE> NS_IMPL_ISUPPORTS1 ( EncodeKeysFunction , mozIStorageFunction ) <NEW_LINE> nsresult <NEW_LINE> UpgradeSchemaFrom11_0To12_0 ( mozIStorageConnection * aConnection ) <NEW_LINE> { <NEW_LINE> <START_VULN> NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread ! " ) ; <NEW_LINE> <END_VULN> NS_ASSERTION ( IndexedDatabaseManager::IsMainProcess ( ) , "Wrong process ! " ) ; <NEW_LINE> PROFILER_LABEL ( "IndexedDB" , "UpgradeSchemaFrom11_0To12_0" ) ; <NEW_LINE> NS_NAMED_LITERAL_CSTRING ( encoderName , "encode" ) ; <NEW_LINE> nsCOMPtr < mozIStorageFunction > encoder = new EncodeKeysFunction ( ) ;
mParisBindingsEnabled ( ccx . GetRuntime ( ) -> ParisBindingsEnabled ( ) ) <NEW_LINE> { <NEW_LINE> { <NEW_LINE> XPCAutoLock lock ( mRuntime -> GetMapLock ( ) ) ; <NEW_LINE> #ifdef DEBUG <NEW_LINE> for ( XPCWrappedNativeScope * cur = gScopes ; cur ; cur = cur -> mNext ) <NEW_LINE> <START_VULN> NS_ASSERTION ( aGlobal != cur -> GetGlobalJSObject ( ) , "dup object" ) ; <NEW_LINE> <END_VULN> #endif <NEW_LINE> mNext = gScopes ; <NEW_LINE> gScopes = this ; <NEW_LINE> mContext = XPCContext::GetXPCContext ( ccx . GetJSContext ( ) ) ; <NEW_LINE> mContext -> AddScope ( this ) ;
#elif SHRT_MIN == - 32768 && SHRT_MAX == 32767 <NEW_LINE> typedef short png_int_16 ; <NEW_LINE> #else <NEW_LINE> <START_VULN> # error "libpng requires a signed 16 bit type" <NEW_LINE> <END_VULN> #endif <NEW_LINE> #if UINT_MAX == 65535
LayoutUnit logicalLeftOffset = 0 ; <NEW_LINE> <START_VULN> if ( ! isPositioned ( ) && avoidsFloats ( ) && cb -> containsFloats ( ) ) { <NEW_LINE> <END_VULN> LayoutUnit startPositionDelta = cb -> computeStartPositionDeltaForChildAvoidingFloats ( this , marginStartInRegion , region , offsetFromLogicalTopOfFirstPage ) ; <NEW_LINE> if ( cb -> style ( ) -> isLeftToRightDirection ( ) ) <NEW_LINE> logicalLeftDelta += startPositionDelta ;
iterator -> current = object ; <NEW_LINE> } <NEW_LINE> zval_add_ref ( & object ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> return ( zend_object_iterator * ) iterator ; <NEW_LINE> }
} <NEW_LINE> } else { <NEW_LINE> if ( state -> array_nl ) ruby_xfree ( state -> array_nl ) ; <NEW_LINE> <START_VULN> state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ; <NEW_LINE> <END_VULN> state -> array_nl_len = len ; <NEW_LINE> } <NEW_LINE> return Qnil ;
WORD32 ih264d_read_mmco_commands ( struct _DecStruct * ps_dec ) <NEW_LINE> { <NEW_LINE> dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; <NEW_LINE> <START_VULN> dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ; <NEW_LINE> <END_VULN> dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; <NEW_LINE> WORD32 j ; <NEW_LINE> UWORD8 u1_buf_mode ;
static void spl_filesystem_dir_it_current_data ( zend_object_iterator * iter , zval ** * data TSRMLS_DC ) <NEW_LINE> { <NEW_LINE> spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> * data = & iterator -> current ; <NEW_LINE> }
XPCWrappedNativeTearOffChunk * chunk ; <NEW_LINE> for ( chunk = & mFirstChunk ; chunk ; chunk = chunk -> mNextChunk ) { <NEW_LINE> XPCWrappedNativeTearOff * to = chunk -> mTearOffs ; <NEW_LINE> for ( int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK - 1 ; i >= 0 ; i -- , to ++ ) { <NEW_LINE> <START_VULN> JSObject * jso = to -> GetJSObject ( ) ; <NEW_LINE> <END_VULN> if ( jso ) { <NEW_LINE> NS_ASSERTION ( JS_IsAboutToBeFinalized ( cx , jso ) , "bad ! " ) ; <NEW_LINE> JS_SetPrivate ( cx , jso , nsnull ) ; <NEW_LINE> to -> JSObjectFinalized ( ) ; <NEW_LINE> } <NEW_LINE> nsISupports * obj = to -> GetNative ( ) ;
{ <NEW_LINE> INC_STATS ( "DOM . TestObj . voidMethodWithArgs" ) ; <NEW_LINE> if ( args . Length ( ) < 3 ) <NEW_LINE> <START_VULN> return V8Proxy::throwNotEnoughArgumentsError ( ) ; <NEW_LINE> <END_VULN> TestObj * imp = V8TestObj::toNative ( args . Holder ( ) ) ; <NEW_LINE> EXCEPTION_BLOCK ( int , intArg , toInt32 ( MAYBE_MISSING_PARAMETER ( args , 0 , DefaultIsUndefined ) ) ) ; <NEW_LINE> STRING_TO_V8PARAMETER_EXCEPTION_BLOCK ( V8Parameter < > , strArg , MAYBE_MISSING_PARAMETER ( args , 1 , DefaultIsUndefined ) ) ;
int32_t newIndex = frameIndex ; <NEW_LINE> do { <NEW_LINE> } while ( ++ newIndex < frameCount && <NEW_LINE> aBpd -> FrameAt ( newIndex ) == NS_BIDI_CONTROL_FRAME ) ; <NEW_LINE> if ( newIndex < frameCount ) { <NEW_LINE> RemoveBidiContinuation ( aBpd , frame , <NEW_LINE> frameIndex , newIndex , lineOffset ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> } else if ( runLength == fragmentLength && <NEW_LINE>frame -> GetNextSibling ( ) ) { <NEW_LINE> <END_VULN> nsIFrame * next = frame -> GetNextInFlow ( ) ; <NEW_LINE> if ( next ) { <NEW_LINE> frame -> SetNextContinuation ( next ) ; <NEW_LINE> next -> SetPrevContinuation ( frame ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> frame -> AdjustOffsetsForBidi ( contentOffset , contentOffset + fragmentLength ) ;
{ <NEW_LINE> png_debug1 ( 1 , "in % s retrieval function" , "oFFs" ) ; <NEW_LINE> <START_VULN> if ( png_ptr != NULL && info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_oFFs ) <NEW_LINE> && offset_x != NULL && offset_y != NULL && unit_type != NULL ) <NEW_LINE> <END_VULN> { <NEW_LINE> * offset_x = info_ptr -> x_offset ; <NEW_LINE> * offset_y = info_ptr -> y_offset ;
JSCompartment::wrap ( JSContext * cx , Value * vp , JSObject * existing ) <NEW_LINE> { <NEW_LINE> JS_ASSERT ( cx -> compartment == this ) ; <NEW_LINE> JS_ASSERT_IF ( existing , existing -> compartment ( ) == cx -> compartment ) ; <NEW_LINE> JS_ASSERT_IF ( existing , vp -> isObject ( ) ) ; <NEW_LINE> unsigned flags = 0 ; <NEW_LINE> <START_VULN> JS_CHECK_RECURSION ( cx , return false ) ; <NEW_LINE> <END_VULN> #ifdef DEBUG <NEW_LINE> struct AutoDisableProxyCheck { <NEW_LINE> JSRuntime * runtime ; <NEW_LINE> AutoDisableProxyCheck ( JSRuntime * rt ) : runtime ( rt ) { <NEW_LINE> runtime -> gcDisableStrictProxyCheckingCount ++ ; <NEW_LINE> } <NEW_LINE> ~ AutoDisableProxyCheck ( ) { runtime -> gcDisableStrictProxyCheckingCount -- ; }
int_mv mode_mv [ MB_MODE_COUNT ] [ 2 ] ; <NEW_LINE> int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; <NEW_LINE> <START_VULN> MB_PREDICTION_MODE mode_selected = ZEROMV ; <NEW_LINE> <END_VULN> int64_t best_rd = INT64_MAX ; <NEW_LINE> const int i = idy * 2 + idx ; <NEW_LINE> int ref ;
this_mv . as_mv . row = br + hex [ i ] . row ; <NEW_LINE> this_mv . as_mv . col = bc + hex [ i ] . col ; <NEW_LINE> this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <NEW_LINE> <START_VULN> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <NEW_LINE> <END_VULN> CHECK_BETTER <NEW_LINE> } <NEW_LINE> } else
walkbuf = result + * result_len ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> if ( eval || is_callable_replace ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> function: #ifdef jail to whip a few platforms into the UNIX ideal . <NEW_LINE> <START_VULN> last mod: $ Id: os . h 13293 2007 - 07 - 24 00:09:47Z xiphmont $ <NEW_LINE> <END_VULN> #ifdef HAVE_CONFIG_H <NEW_LINE> #include "config . h" <NEW_LINE> #endif <NEW_LINE> #include < math . h >
int y4m_write_file_header ( char * buf , size_t len , int width , int height , <NEW_LINE> const struct VpxRational * framerate , <NEW_LINE> <START_VULN> vpx_img_fmt_t fmt ) ; <NEW_LINE> <END_VULN> int y4m_write_frame_header ( char * buf , size_t len ) ; <NEW_LINE> #ifdef __cplusplus
void AddInterstitialObservers ( content::WebContents * contents ) ; <NEW_LINE> <START_VULN> void RemoveInterstitialObservers ( TabContents * contents ) ; <NEW_LINE> <END_VULN> inline BrowserWindow * window ( ) ; <NEW_LINE> inline Profile * profile ( ) ;
ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; <NEW_LINE> if ( ret <= 0 ) { <NEW_LINE> if ( ret != 0 ) <NEW_LINE> <START_VULN> ERROR ( "error using IPC to receive notification from attached process ( 1 ) " ) ; <NEW_LINE> <END_VULN> goto cleanup_error ; <NEW_LINE> }
BTIF_TRACE_DEBUG ( " % s: Sending hid report to kernel "\ <NEW_LINE> "indicating lock key state 0x % x" , __FUNCTION__ , <NEW_LINE> keylockstates ) ; <NEW_LINE> <START_VULN> usleep ( 200000 ) ; <NEW_LINE> <END_VULN> toggle_os_keylockstates ( p_dev -> fd , keylockstates ) ; <NEW_LINE> } <NEW_LINE> else
InstallNewDocumentReason , <NEW_LINE> ParserSynchronizationPolicy , <NEW_LINE> const KURL & overriding_url ) ; <NEW_LINE> <START_VULN> void DidInstallNewDocument ( Document * ) ; <NEW_LINE> <END_VULN> void WillCommitNavigation ( ) ; <NEW_LINE> void DidCommitNavigation ( WebGlobalObjectReusePolicy ) ;
FEColorMatrix * colorMatrix = static_cast < FEColorMatrix * > ( effect ) ; <NEW_LINE> if ( attrName == SVGNames::typeAttr ) <NEW_LINE> return colorMatrix -> setType ( m_type -> currentValue ( ) -> enumValue ( ) ) ; <NEW_LINE> <START_VULN> if ( attrName == SVGNames::valuesAttr ) <NEW_LINE>return colorMatrix -> setValues ( m_values -> currentValue ( ) -> toFloatVector ( ) ) ; <NEW_LINE> <END_VULN> ASSERT_NOT_REACHED ( ) ; <NEW_LINE> return false ;
static int CVE_2013_4534_openpic_load ( QEMUFile * f , void * opaque , int version_id ) <NEW_LINE> { <NEW_LINE> OpenPICState * opp = ( OpenPICState * ) opaque ; <NEW_LINE> <START_VULN> unsigned int i ; <NEW_LINE> <END_VULN> if ( version_id != 1 ) { <NEW_LINE> return - EINVAL ;
virtual void TabInsertedAt ( content::WebContents * contents , <NEW_LINE> int index , <NEW_LINE> bool foreground ) OVERRIDE ; <NEW_LINE> <START_VULN> virtual void TabDetachedAt ( TabContents * contents , int index ) OVERRIDE ; <NEW_LINE> <END_VULN> virtual void TabChangedAt ( <NEW_LINE> TabContents * tab , <NEW_LINE> int index ,
static inline int perf_event_task_enable ( void ) { return - EINVAL ; } <NEW_LINE> static inline void <NEW_LINE> <START_VULN> perf_sw_event ( u32 event_id , u64 nr , int nmi , <NEW_LINE>struct pt_regs * regs , u64 addr ) { } <NEW_LINE> <END_VULN> static inline void <NEW_LINE> perf_bp_event ( struct perf_event * event , void * data ) { }
ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; <NEW_LINE> ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; <NEW_LINE> } <NEW_LINE> <START_VULN> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <NEW_LINE> <END_VULN> { <NEW_LINE> ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , <NEW_LINE> & ps_dec -> s_prev_pic_poc ,
static png_structp <NEW_LINE> set_store_for_read ( png_store * ps , png_infopp ppi , png_uint_32 id , <NEW_LINE> <START_VULN> PNG_CONST char * name ) <NEW_LINE> <END_VULN> { <NEW_LINE> safecat ( ps -> test , sizeof ps -> test , 0 , name ) ;
{ <NEW_LINE> png_debug ( 1 , "in png_set_expand_gray_1_2_4_to_8" ) ; <NEW_LINE> <START_VULN> if ( ! png_rtran_ok ( png_ptr , 0 ) ) <NEW_LINE> <END_VULN> return ; <NEW_LINE> png_ptr -> transformations |= PNG_EXPAND ;
& v , getter_AddRefs ( holder ) ) ; <NEW_LINE> NS_ENSURE_SUCCESS ( rv , rv ) ; <NEW_LINE> JSAutoRequest ar ( cx ) ; <NEW_LINE> JSString * str = JSVAL_TO_STRING ( id ) ; <NEW_LINE> JSBool ok = ::JS_DefineUCProperty ( cx , obj , ::JS_GetStringChars ( str ) , <NEW_LINE> ::JS_GetStringLength ( str ) , v , nsnull , <NEW_LINE> <START_VULN> nsnull , JSPROP_ENUMERATE ) ; <NEW_LINE> <END_VULN> if ( ! ok ) { <NEW_LINE> return NS_ERROR_FAILURE ; <NEW_LINE> } <NEW_LINE> * objp = obj ; <NEW_LINE> return NS_OK ;
if ( m_lastFatFingersResult . isTextInput ( ) ) { <NEW_LINE> elementUnderFatFinger = m_lastFatFingersResult . nodeAsElementIfApplicable ( FatFingersResult::ShadowContentNotAllowed , true ) ; <NEW_LINE> <START_VULN> m_shouldRequestSpellCheckOptions = m_webPage -> m_inputHandler -> shouldRequestSpellCheckingOptionsForPoint ( point . m_pos , elementUnderFatFinger , m_spellCheckOptionRequest ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> handleFatFingerPressed ( shiftActive , altActive , ctrlActive ) ;
if ( image -> next == ( Image * ) NULL ) <NEW_LINE> goto Finish ; <NEW_LINE> image = SyncNextImageInList ( image ) ; <NEW_LINE> <START_VULN> image -> columns = image -> rows = 0 ; <NEW_LINE> <END_VULN> image -> colors = 0 ; <NEW_LINE> break ;
public Page::Backend , <NEW_LINE> public RenderWidgetHostObserver { <NEW_LINE> public: <NEW_LINE> <START_VULN> explicit PageHandler ( EmulationHandler * handler ) ; <NEW_LINE> <END_VULN> ~ PageHandler ( ) override ; <NEW_LINE> static std::vector < PageHandler * > EnabledForWebContents (
nb_tests ++ ; <NEW_LINE> ctxt = xmlRelaxNGNewValidCtxt ( rng ) ; <NEW_LINE> xmlRelaxNGSetValidErrors ( ctxt , <NEW_LINE> <START_VULN> ( xmlRelaxNGValidityErrorFunc ) testErrorHandler , <NEW_LINE> ( xmlRelaxNGValidityWarningFunc ) testErrorHandler , <NEW_LINE>ctxt ) ; <NEW_LINE> <END_VULN> ret = xmlRelaxNGValidateDoc ( ctxt , doc ) ; <NEW_LINE> xmlRelaxNGFreeValidCtxt ( ctxt ) ; <NEW_LINE> if ( ret == 0 ) {
if ( NS_FAILED ( rv ) ) <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> nsTreeRange * range = new nsTreeRange ( this , start , end ) ; <NEW_LINE> if ( ! range ) <NEW_LINE> return NS_ERROR_OUT_OF_MEMORY ; <NEW_LINE> <START_VULN> range -> Invalidate ( ) ; <NEW_LINE> <END_VULN> if ( aAugment && mFirstRange ) <NEW_LINE> mFirstRange -> Insert ( range ) ; <NEW_LINE> else <NEW_LINE> mFirstRange = range ; <NEW_LINE> FireOnSelectHandler ( ) ;
png_debug ( 1 , "in png_write_sBIT" ) ; <NEW_LINE> <START_VULN> if ( color_type & PNG_COLOR_MASK_COLOR ) <NEW_LINE> <END_VULN> { <NEW_LINE> png_byte maxbits ;
{ <NEW_LINE> aTargetObject . set ( nullptr ) ; <NEW_LINE> RootedObject targetObject ( aCx ) ; <NEW_LINE> if ( mReuseLoaderGlobal ) { <NEW_LINE> JSScript * script = <NEW_LINE> js::GetOutermostEnclosingFunctionOfScriptedCaller ( aCx ) ; <NEW_LINE> if ( script ) { <NEW_LINE> <START_VULN> targetObject = mThisObjects . Get ( script ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> if ( ! targetObject ) {
class MIDI_EXPORT TaskService final { <NEW_LINE> public: <NEW_LINE> using RunnerId = size_t ; <NEW_LINE> <START_VULN> using InstanceId = int ; <NEW_LINE> <END_VULN> static constexpr RunnerId kDefaultRunnerId = 0 ;
#define CONTENT_PUBLIC_RENDERER_WINDOW_FEATURES_CONVERTER_H_ <NEW_LINE> #include "content / common / content_export . h" <NEW_LINE> <START_VULN> #include "third_party / blink / public / mojom / window_features / window_features . mojom . h" <NEW_LINE> <END_VULN> #include "third_party / blink / public / web / web_window_features . h" <NEW_LINE> namespace content {
DocumentLoader * , <NEW_LINE> const ResourceRequest & , <NEW_LINE> const ResourceResponse & redirect_response , <NEW_LINE> <START_VULN> const FetchInitiatorInfo & ) ; <NEW_LINE> <END_VULN> void DelayedRemoveReplayXHR ( XMLHttpRequest * ) ; <NEW_LINE> void RemoveFinishedReplayXHRFired ( TimerBase * ) ; <NEW_LINE> void DidFinishXHRInternal ( ExecutionContext * ,
void SetJavaRef ( JNIEnv * , jobject obj ) ; <NEW_LINE> <START_VULN> void RequestHTTPGetDownload ( const std::string & url , <NEW_LINE>const std::string & user_agent , <NEW_LINE>const std::string & content_disposition , <NEW_LINE>const std::string & mime_type , <NEW_LINE>const std::string & cookie , <NEW_LINE>const std::string & referer , <NEW_LINE>const base::string16 & file_name , <NEW_LINE>int64_t content_length , <NEW_LINE>bool has_user_geature , <NEW_LINE>bool must_download ) ; <NEW_LINE>void OnDownloadStarted ( const std::string & filename , <NEW_LINE>const std::string & mime_type ) ; <NEW_LINE> <END_VULN> void OnDangerousDownload ( const std::string & filename , <NEW_LINE> const std::string & guid ) ; <NEW_LINE> void RequestFileAccess ( intptr_t callback_id ) ;
data_encoding = P_sRGB ; <NEW_LINE> <START_VULN> if ( output_format & PNG_FORMAT_FLAG_ALPHA ) <NEW_LINE> <END_VULN> { <NEW_LINE> if ( PNG_GA_COLORMAP_ENTRIES > image -> colormap_entries ) <NEW_LINE> png_error ( png_ptr , "gray + alpha color - map: too few entries" ) ;
toBuffer += bitWidth >> 3 ; <NEW_LINE> fromBuffer += bitWidth >> 3 ; <NEW_LINE> <START_VULN> <NEW_LINE>mask = 0xff >> ( bitWidth & 7 ) ; <NEW_LINE> <END_VULN> * toBuffer = ( png_byte ) ( ( * toBuffer & mask ) | ( * fromBuffer & ~ mask ) ) ; <NEW_LINE> } <NEW_LINE> }
break ; <NEW_LINE> case 2: <NEW_LINE> tv_info_v1_2 = ( ATOM_ANALOG_TV_INFO_V1_2 * ) ( mode_info -> atom_context -> bios + data_offset ) ; <NEW_LINE> <START_VULN> if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 ) <NEW_LINE> <END_VULN> return false ; <NEW_LINE> dtd_timings = & tv_info_v1_2 -> aModeTimings [ index ] ;
uint32_t mNumSampleSizes ; <NEW_LINE> uint32_t mTimeToSampleCount ; <NEW_LINE> <START_VULN> uint32_t * mTimeToSample ; <NEW_LINE> <END_VULN> struct SampleTimeEntry { <NEW_LINE> uint32_t mSampleIndex ;
ci -> _cse = ci -> _fold = 0 ; <NEW_LINE> ci -> _abi = ABI_CDECL ; <NEW_LINE> #ifdef DEBUG <NEW_LINE> ci -> _name = "JSPropertyOp" ; <NEW_LINE> #endif <NEW_LINE> LIns * args [ ] = { vp_ins , INS_CONSTWORD ( SPROP_USERID ( sprop ) ) , obj_ins , cx_ins } ; <NEW_LINE> LIns * ok_ins = lir -> insCall ( ci , args ) ; <NEW_LINE> <START_VULN> <NEW_LINE> <END_VULN> lir -> insStorei ( INS_NULL ( ) , cx_ins , offsetof ( JSContext , nativeVp ) ) ; <NEW_LINE> leaveDeepBailCall ( ) ; <NEW_LINE> LIns * status_ins = lir -> insLoad ( LIR_ld ,
clear_ptrace_hw_breakpoint ( p ) ; <NEW_LINE> if ( clone_flags & CLONE_SETTLS ) <NEW_LINE> <START_VULN> thread -> tp_value = childregs -> ARM_r3 ; <NEW_LINE> <END_VULN> thread_notify ( THREAD_NOTIFY_COPY , thread ) ;
Z_PARAM_PATH ( filename , filename_len ) \ <NEW_LINE> ZEND_PARSE_PARAMETERS_END ( ) ; \ <NEW_LINE> \ <NEW_LINE> <START_VULN> php_stat ( filename , ( php_stat_len ) filename_len , funcnum , return_value ) ; \ <NEW_LINE> <END_VULN> }
unsigned char abs_delta ) { <NEW_LINE> seg -> abs_delta = abs_delta ; <NEW_LINE> <START_VULN> vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ; <NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE><NEW_LINE> <END_VULN> } <NEW_LINE> void vp9_disable_segfeature ( struct segmentation * seg , int segment_id , <NEW_LINE> SEG_LVL_FEATURES feature_id ) {
<START_VULN> if ( transforms & PNG_TRANSFORM_INVERT_MONO ) <NEW_LINE> <END_VULN> #ifdef PNG_READ_INVERT_SUPPORTED <NEW_LINE> png_set_invert_mono ( png_ptr ) ; <NEW_LINE> #else
<START_VULN> if ( mprGetJson ( route -> config , sfmt ( "app . http . content . compress [ @ = ' % s' ] " , child -> value ) ) == 0 ) { <NEW_LINE> <END_VULN> httpAddRouteMapping ( route , child -> value , "min . $ { 1 } " ) ; <NEW_LINE> } <NEW_LINE> }
void HandleHttpMultipartResponse ( const WebKit::WebURLResponse & response , <NEW_LINE> WebPluginResourceClient * client ) ; <NEW_LINE> <START_VULN> void HandleURLRequestInternal ( const char * method , bool is_javascript_url , <NEW_LINE>const char * target , unsigned int len , <NEW_LINE>const char * buf , bool is_file_data , <NEW_LINE>bool notify , const char * url , <NEW_LINE>intptr_t notify_data , bool popups_allowed , <NEW_LINE> <END_VULN> Referrer referrer_flag ) ;
mApplicationCache -> Discard ( ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> nsresult rv = NS_OK ; <NEW_LINE> if ( mOwner ) { <NEW_LINE> rv = mOwner -> UpdateFinished ( this ) ; <NEW_LINE> <START_VULN> mOwner = nullptr ; <NEW_LINE> <END_VULN> } <NEW_LINE> return rv ; <NEW_LINE> } <NEW_LINE> nsresult <NEW_LINE> nsOfflineCacheUpdate::Finish ( ) <NEW_LINE> {
NS_ENSURE_TRUE ( sel , false ) ; <NEW_LINE> bool isCollapsed ; <NEW_LINE> sel -> GetIsCollapsed ( & isCollapsed ) ; <NEW_LINE> return ! isCollapsed ; <NEW_LINE> } <NEW_LINE> bool <NEW_LINE> <START_VULN> nsCopySupport::FireClipboardEvent ( int32_t aType , nsIPresShell * aPresShell , nsISelection * aSelection ) <NEW_LINE> <END_VULN> { <NEW_LINE> NS_ASSERTION ( aType == NS_CUT || aType == NS_COPY || aType == NS_PASTE , <NEW_LINE> "Invalid clipboard event type" ) ; <NEW_LINE> nsCOMPtr < nsIPresShell > presShell = aPresShell ; <NEW_LINE> if ( ! presShell ) <NEW_LINE> return false ;
exit ( EXIT_FAILURE ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static void encode_frame ( vpx_codec_ctx_t * codec , <NEW_LINE>vpx_image_t * img , <NEW_LINE>int frame_index , <NEW_LINE>int flags , <NEW_LINE>VpxVideoWriter * writer ) { <NEW_LINE> <END_VULN> vpx_codec_iter_t iter = NULL ; <NEW_LINE> const vpx_codec_cx_pkt_t * pkt = NULL ; <NEW_LINE> const vpx_codec_err_t res = vpx_codec_encode ( codec , img , frame_index , 1 ,
chnMem . autoPortaDown = 0 ; <NEW_LINE> chnMem . autoTonePorta = 0 ; <NEW_LINE> <START_VULN> m . command = m . param = 0 ; <NEW_LINE> <END_VULN> break ; <NEW_LINE> case 0x05:
" non - zero code is returned ) . " , <NEW_LINE> " 0x10: The file could not be read , even with corrections . " , <NEW_LINE> " 0x20: The output file could not be written . " , <NEW_LINE> <START_VULN> " 0x40: An unexpected , potentially internal , error occured . " , <NEW_LINE> <END_VULN> " If the command line arguments are incorrect the program exits with exit" , <NEW_LINE> " 255 . Some older operating systems only support 7 - bit exit codes , on those" , <NEW_LINE> " systems it is suggested that this program is first tested by supplying" ,
{ <NEW_LINE> vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , <NEW_LINE> dst , dst_stride , dst , dst_stride ) ; <NEW_LINE> <START_VULN> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> } <NEW_LINE> }
unsigned int red , green , blue , alpha ; <NEW_LINE> unsigned int palette_index ; <NEW_LINE> <START_VULN> png_byte colour_type ; <NEW_LINE>png_byte bit_depth ; <NEW_LINE>png_byte sample_depth ; <NEW_LINE>int have_tRNS ; <NEW_LINE> <END_VULN> double redf , greenf , bluef , alphaf ; <NEW_LINE> double rede , greene , bluee , alphae ;
virtual void ShowDropDown ( bool aDoDropDown ) ; <NEW_LINE> virtual nsIFrame * GetDropDown ( ) ; <NEW_LINE> virtual void SetDropDown ( nsIFrame * aDropDownFrame ) ; <NEW_LINE> virtual void RollupFromList ( ) ; <NEW_LINE> <START_VULN> virtual void AbsolutelyPositionDropDown ( ) ; <NEW_LINE> <END_VULN> virtual PRInt32 GetIndexOfDisplayArea ( ) ; <NEW_LINE> NS_IMETHOD RedisplaySelectedText ( ) ; <NEW_LINE> virtual PRInt32 UpdateRecentIndex ( PRInt32 aIndex ) ; <NEW_LINE> virtual void OnContentReset ( ) ;
size += EbmlElementSize ( kMkvCueTrack , track_ ) ; <NEW_LINE> if ( output_block_number_ && block_number_ > 1 ) <NEW_LINE> size += EbmlElementSize ( kMkvCueBlockNumber , block_number_ ) ; <NEW_LINE> <START_VULN> const uint64 track_pos_size = EbmlMasterElementSize ( kMkvCueTrackPositions , <NEW_LINE>size ) + size ; <NEW_LINE>const uint64 payload_size = EbmlElementSize ( kMkvCueTime , time_ ) + <NEW_LINE>track_pos_size ; <NEW_LINE> <END_VULN> return payload_size ; <NEW_LINE> }
mysql_init ( & mysql ) ; <NEW_LINE> if ( opt_compress ) <NEW_LINE> mysql_options ( & mysql , MYSQL_OPT_COMPRESS , NullS ) ; <NEW_LINE> <START_VULN> #ifdef HAVE_OPENSSL <NEW_LINE>if ( opt_use_ssl ) <NEW_LINE> { <NEW_LINE>mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , <NEW_LINE>opt_ssl_capath , opt_ssl_cipher ) ; <NEW_LINE>mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; <NEW_LINE>mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; <NEW_LINE> } <NEW_LINE>#endif <NEW_LINE> <END_VULN> if ( opt_protocol ) <NEW_LINE> mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; <NEW_LINE> #if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY )
if ( GetNextImageInList ( image ) == ( Image * ) NULL ) <NEW_LINE> { <NEW_LINE> status = MagickFalse ; <NEW_LINE> <START_VULN> return ( ( Image * ) NULL ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> image = SyncNextImageInList ( image ) ; <NEW_LINE> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) ,
strcpy ( temp_str , app ) ; <NEW_LINE> #endif <NEW_LINE> <START_VULN> delete [ ] writing_app_ ; <NEW_LINE> <END_VULN> writing_app_ = temp_str ; <NEW_LINE> } <NEW_LINE> }
m_scrollsHorizontally = view -> contentsWidth ( ) > view -> visibleWidth ( ) ; <NEW_LINE> m_scrollsVertically = view -> contentsHeight ( ) > view -> visibleHeight ( ) ; <NEW_LINE> <START_VULN> m_minimumScrollPosition = m_webPage -> mapToTransformed ( calculateMinimumScrollPosition ( <NEW_LINE>view -> visibleContentRect ( ) . size ( ) , <NEW_LINE>0 . 0 ) ) ; <NEW_LINE>m_maximumScrollPosition = m_webPage -> mapToTransformed ( calculateMaximumScrollPosition ( <NEW_LINE>view -> visibleContentRect ( ) . size ( ) , <NEW_LINE>view -> contentsSize ( ) , <NEW_LINE>0 . 0 ) ) ; <NEW_LINE><NEW_LINE> <END_VULN> } else { <NEW_LINE> RenderBox * box = m_layer -> renderBox ( ) ;
bool hasStartTime ( ) const { return ! isNull ( m_startTime ) ; } <NEW_LINE> double startTime ( ) const { return m_startTime ; } <NEW_LINE> <START_VULN> void setStartTime ( double ) ; <NEW_LINE> <END_VULN> TimedItem * source ( ) { return m_content . get ( ) ; } <NEW_LINE> TimedItem * source ( bool & isNull ) { isNull = ! m_content ; return m_content . get ( ) ; }
static const uint32_t GB18030CharLenTable [ ] = { 0 , 1 , 1 , 1 , 1 , 1 , 2 } ; <NEW_LINE> const SMModel GB18030SMModel = { <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , GB18030_cls } , <NEW_LINE> 7 , <NEW_LINE> { eIdxSft4bits , eSftMsk4bits , eBitSft4bits , eUnitMsk4bits , GB18030_st } , <NEW_LINE> <START_VULN> GB18030CharLenTable , <NEW_LINE> <END_VULN> "GB18030" , <NEW_LINE> } ; <NEW_LINE> static const uint32_t SJIS_cls [ 256 / 8 ] = { <NEW_LINE> PCK4BITS ( 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ) ,
if ( nameAtom != aAttribute ) { <NEW_LINE> return ; <NEW_LINE> } <NEW_LINE> nsCOMPtr < nsIMutationObserver > kungFuDeathGrip ( this ) ; <NEW_LINE> if ( mChild ) { <NEW_LINE> <START_VULN> doRemoveChild ( ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> EnsureChildState ( ) ; <NEW_LINE> } <NEW_LINE> void <NEW_LINE> nsDOMAttribute::Initialize ( ) <NEW_LINE> { <NEW_LINE> sInitialized = PR_TRUE ;
struct ipcm_cookie * ipc , struct rtable ** rtp ) <NEW_LINE> { <NEW_LINE> struct inet_sock * inet = inet_sk ( sk ) ; <NEW_LINE> <START_VULN> struct ip_options * opt ; <NEW_LINE> <END_VULN> struct rtable * rt ;
<START_VULN> virtual void ConfigureDataTypes ( const syncable::ModelTypeSet & types , <NEW_LINE>CancelableTask * ready_task ) ; <NEW_LINE> <END_VULN> syncable::AutofillMigrationState <NEW_LINE> GetAutofillMigrationState ( ) ;
} <NEW_LINE> if ( mRootPresContextRegisteredWith && mRootPresContextRegisteredWith != rpc ) { <NEW_LINE> UnregisterPluginForGeometryUpdates ( ) ; <NEW_LINE> } <NEW_LINE> mRootPresContextRegisteredWith = rpc ; <NEW_LINE> mRootPresContextRegisteredWith -> RegisterPluginForGeometryUpdates ( mContent ) ; <NEW_LINE> <START_VULN> mRootPresContextRegisteredWith -> RequestUpdatePluginGeometry ( this ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> void <NEW_LINE> nsObjectFrame::UnregisterPluginForGeometryUpdates ( ) <NEW_LINE> { <NEW_LINE> if ( ! mRootPresContextRegisteredWith ) { <NEW_LINE> return ;
{ <NEW_LINE> ca_slot_info_t * info = ( ca_slot_info_t * ) parg ; <NEW_LINE> <START_VULN> if ( info -> num > 1 ) <NEW_LINE> <END_VULN> return - EINVAL ; <NEW_LINE> av7110 -> ci_slot [ info -> num ] . num = info -> num ; <NEW_LINE> av7110 -> ci_slot [ info -> num ] . type = FW_CI_LL_SUPPORT ( av7110 -> arm_app ) ?
} <NEW_LINE> bool <NEW_LINE> CrossCompartmentWrapper::keys ( JSContext * cx , JSObject * wrapper , AutoIdVector & props ) <NEW_LINE> { <NEW_LINE> PIERCE ( cx , wrapper , GET , <NEW_LINE> NOTHING , <NEW_LINE> DirectWrapper::keys ( cx , wrapper , props ) , <NEW_LINE> <START_VULN> call . origin -> wrap ( cx , props ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> static bool <NEW_LINE> CanReify ( Value * vp )
alarm_cancel ( alarm_timer ) ; <NEW_LINE> <START_VULN> pthread_mutex_lock ( & lock ) ; <NEW_LINE>config_save ( config , CONFIG_FILE_PATH ) ; <NEW_LINE>pthread_mutex_unlock ( & lock ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> int btif_config_clear ( void ) {
if ( NS_FRAME_IS_FULLY_COMPLETE ( aFrameReflowStatus ) ) { <NEW_LINE> nsIFrame * kidNextInFlow = mFrame -> GetNextInFlow ( ) ; <NEW_LINE> if ( nullptr != kidNextInFlow ) { <NEW_LINE> <START_VULN> <NEW_LINE>aState . mOverflowTracker -> Finish ( mFrame ) ; <NEW_LINE> <END_VULN> static_cast < nsContainerFrame * > ( kidNextInFlow -> GetParent ( ) ) <NEW_LINE> -> DeleteNextInFlowChild ( mPresContext , kidNextInFlow , true ) ; <NEW_LINE> } <NEW_LINE> } <NEW_LINE> } <NEW_LINE> return rv ; <NEW_LINE> }
MakeContextCurrent ( ) ; <NEW_LINE> mColorWriteMask [ 0 ] = r ; <NEW_LINE> mColorWriteMask [ 1 ] = g ; <NEW_LINE> mColorWriteMask [ 2 ] = b ; <NEW_LINE> mColorWriteMask [ 3 ] = a ; <NEW_LINE> gl -> fColorMask ( r , g , b , a ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> void <NEW_LINE> <END_VULN> WebGLContext::CopyTexSubImage2D_base ( WebGLenum target , <NEW_LINE> WebGLint level , <NEW_LINE> WebGLenum internalformat , <NEW_LINE> WebGLint xoffset , <NEW_LINE> WebGLint yoffset , <NEW_LINE> WebGLint x , <NEW_LINE> WebGLint y , <NEW_LINE> WebGLsizei width ,
vpx_malloc ( sizeof ( sem_t ) * th_count ) ) ; <NEW_LINE> CHECK_MEM_ERROR ( cpi -> mb_row_ei , <NEW_LINE> vpx_memalign ( 32 , sizeof ( MB_ROW_COMP ) * th_count ) ) ; <NEW_LINE> <START_VULN> vpx_memset ( cpi -> mb_row_ei , 0 , sizeof ( MB_ROW_COMP ) * th_count ) ; <NEW_LINE> <END_VULN> CHECK_MEM_ERROR ( cpi -> en_thread_data , <NEW_LINE> vpx_malloc ( sizeof ( ENCODETHREAD_DATA ) * th_count ) ) ;
String InspectorPageAgent::CachedResourceTypeJson ( <NEW_LINE> const Resource & cached_resource ) { <NEW_LINE> <START_VULN> return ResourceTypeJson ( CachedResourceType ( cached_resource ) ) ; <NEW_LINE> <END_VULN> } <NEW_LINE> InspectorPageAgent::InspectorPageAgent (
FORWARD_DECLARE_TEST ( AppCacheDatabaseTest , ReCreate ) ; <NEW_LINE> FORWARD_DECLARE_TEST ( AppCacheDatabaseTest , DeletableResponseIds ) ; <NEW_LINE> FORWARD_DECLARE_TEST ( AppCacheDatabaseTest , OriginUsage ) ; <NEW_LINE> <START_VULN> FORWARD_DECLARE_TEST ( AppCacheDatabaseTest , UpgradeSchemaNukesDeprecatedVersion ) ; <NEW_LINE> <END_VULN> FORWARD_DECLARE_TEST ( AppCacheDatabaseTest , WasCorrutionDetected ) ; <NEW_LINE> class AppCacheDatabaseTest ; <NEW_LINE> class AppCacheStorageImplTest ;
case VISUALIZER_CMD_CAPTURE: { <NEW_LINE> uint32_t captureSize = pContext -> mCaptureSize ; <NEW_LINE> <START_VULN> if ( pReplyData == NULL || * replySize != captureSize ) { <NEW_LINE> <END_VULN> ALOGV ( "VISUALIZER_CMD_CAPTURE ( ) error * replySize % " PRIu32 " captureSize % " PRIu32 , <NEW_LINE> * replySize , captureSize ) ; <NEW_LINE> return - EINVAL ;
return ; <NEW_LINE> } <NEW_LINE> std::vector < std::vector < std::string > > result ; <NEW_LINE> <START_VULN> result = m_sql . safe_queryBlob ( "SELECT Image FROM Floorplans WHERE ID = % s" , idx . c_str ( ) ) ; <NEW_LINE> <END_VULN> if ( result . empty ( ) ) <NEW_LINE> return ; <NEW_LINE> reply::set_content ( & rep , result [ 0 ] [ 0 ] . begin ( ) , result [ 0 ] [ 0 ] . end ( ) ) ;
<START_VULN> if ( bytecnt ) { <NEW_LINE> <END_VULN> wpc -> file_format = * byteptr ++ ; <NEW_LINE> wpc -> config . qmode = ( wpc -> config . qmode & ~ 0xff ) | * byteptr ++ ; <NEW_LINE> bytecnt - = 2 ;
const uint8_t * eod = ( data + size ) ; <NEW_LINE> uint32_t flag , mask ; <NEW_LINE> uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; <NEW_LINE> <START_VULN> unsigned int x , y ; <NEW_LINE> <END_VULN> char * ip0 , * ip1 , * ip2 , * ip3 ; <NEW_LINE> flag = 0 ;
#else <NEW_LINE> struct mobj * mobj = mobj_mm_alloc ( mobj_sec_ddr , size , & tee_mm_sec_ddr ) ; <NEW_LINE> <START_VULN> if ( mobj ) <NEW_LINE>memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ; <NEW_LINE> <END_VULN> return mobj ; <NEW_LINE> #endif <NEW_LINE> }
"NTLMSSP_NEGOTIATE_UNICODE" <NEW_LINE> } ; <NEW_LINE> <START_VULN> void ntlm_print_negotiate_flags ( UINT32 flags ) <NEW_LINE> <END_VULN> { <NEW_LINE> int i ; <NEW_LINE> const char * str ;
( void ) png_safecat ( msg , ( sizeof msg ) , 10 , " using zstream" ) ; <NEW_LINE> <START_VULN> # if PNG_LIBPNG_BUILD_BASE_TYPE >= PNG_LIBPNG_BUILD_RC <NEW_LINE> <END_VULN> png_warning ( png_ptr , msg ) ;
NSS_CMSSignerInfo_Sign ( NSSCMSSignerInfo * signerinfo , SECItem * digest , SECItem * contentType ) <NEW_LINE> { <NEW_LINE> CERTCertificate * cert ; <NEW_LINE> SECKEYPrivateKey * privkey = NULL ; <NEW_LINE> SECOidTag digestalgtag ; <NEW_LINE> SECOidTag pubkAlgTag ; <NEW_LINE> SECItem signature = { 0 } ; <NEW_LINE> SECStatus rv ; <NEW_LINE> <START_VULN> PLArenaPool * poolp , * tmppoolp ; <NEW_LINE> <END_VULN> SECAlgorithmID * algID , freeAlgID ; <NEW_LINE> CERTSubjectPublicKeyInfo * spki ; <NEW_LINE> PORT_Assert ( digest != NULL ) ; <NEW_LINE> poolp = signerinfo -> cmsg -> poolp ; <NEW_LINE> switch ( signerinfo -> signerIdentifier . identifierType ) {
<START_VULN> #ifndef PENDING_TASK_H_ <NEW_LINE>#define PENDING_TASK_H_ <NEW_LINE> <END_VULN> #include < queue >
MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , 1 , 0 ) ) ; <NEW_LINE> MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , 2 , 0 ) ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> else <NEW_LINE> <END_VULN> #endif <NEW_LINE> #if defined ( ECP_SHORTWEIERSTRASS ) <NEW_LINE> if ( ecp_get_type ( grp ) == ECP_TYPE_SHORT_WEIERSTRASS ) <NEW_LINE> {
virtual unsigned int length ( ) const { return 1 ; } <NEW_LINE> <START_VULN> bool isFloatingOrPositioned ( ) const { return ( isFloating ( ) || isPositioned ( ) ) ; } <NEW_LINE> <END_VULN> bool isTransparent ( ) const { return style ( ) -> opacity ( ) < 1 . 0f ; } <NEW_LINE> float opacity ( ) const { return style ( ) -> opacity ( ) ; }
if ( ref_frame_flag == VP9_LAST_FLAG ) { <NEW_LINE> <START_VULN> const YV12_BUFFER_CONFIG * const cfg = <NEW_LINE> & cm -> frame_bufs [ cm -> ref_frame_map [ 0 ] ] . buf ; <NEW_LINE> <END_VULN> if ( ! equal_dimensions ( cfg , sd ) ) <NEW_LINE> vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , <NEW_LINE> "Incorrect buffer dimensions" ) ;
return false ; <NEW_LINE> CGImageRef cgImage ; <NEW_LINE> RetainPtr < CGImageRef > decodedImage ; <NEW_LINE> <START_VULN> bool hasAlpha = image -> isBitmapImage ( ) ? static_cast < BitmapImage * > ( image ) -> frameHasAlphaAtIndex ( 0 ) : true ; <NEW_LINE> <END_VULN> if ( ( ignoreGammaAndColorProfile || ( hasAlpha && ! premultiplyAlpha ) ) && image -> data ( ) ) { <NEW_LINE> ImageSource decoder ( ImageSource::AlphaNotPremultiplied , <NEW_LINE> ignoreGammaAndColorProfile ? ImageSource::GammaAndColorProfileIgnored : ImageSource::GammaAndColorProfileApplied ) ;
intf -> desc . bInterfaceProtocol == USB_PR_UAS ) ; <NEW_LINE> } <NEW_LINE> <START_VULN> static int uas_find_uas_alt_setting ( struct usb_interface * intf ) <NEW_LINE> <END_VULN> { <NEW_LINE> int i ;
* <NEW_LINE> ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** <NEW_LINE> <START_VULN> extern js::Class XPC_WN_NoHelper_JSClass ; <NEW_LINE> <END_VULN> extern js::Class XPC_WN_NoMods_WithCall_Proto_JSClass ; <NEW_LINE> extern js::Class XPC_WN_NoMods_NoCall_Proto_JSClass ; <NEW_LINE> extern js::Class XPC_WN_ModsAllowed_WithCall_Proto_JSClass ; <NEW_LINE> extern js::Class XPC_WN_ModsAllowed_NoCall_Proto_JSClass ; <NEW_LINE> extern js::Class XPC_WN_Tearoff_JSClass ; <NEW_LINE> extern js::Class XPC_WN_NoHelper_Proto_JSClass ; <NEW_LINE> extern JSBool
aScriptObject . drop ( ) ; <NEW_LINE> if ( ! ok || JSVersion ( aVersion ) == JSVERSION_UNKNOWN ) <NEW_LINE> return NS_OK ; <NEW_LINE> <START_VULN> JSAutoRequest ar ( mContext ) ; <NEW_LINE> <END_VULN> JSScript * script = <NEW_LINE> ::JS_CompileUCScriptForPrincipalsVersion ( mContext , <NEW_LINE> scopeObject , <NEW_LINE> nsJSPrincipals::get ( aPrincipal ) , <NEW_LINE> static_cast < const jschar * > ( aText ) , <NEW_LINE> aTextLength , <NEW_LINE> aURL ,
long long element_size = - 1 ; <NEW_LINE> <START_VULN> for ( ; ; ) <NEW_LINE> { <NEW_LINE> <END_VULN> if ( ( total >= 0 ) && ( pos >= total ) ) <NEW_LINE> { <NEW_LINE> element_size = total - element_start ;
nsAutoString typeHint ; <NEW_LINE> nsCOMPtr < nsIDOMHTMLAnchorElement > anchor ( do_QueryInterface ( aContent ) ) ; <NEW_LINE> if ( anchor ) { <NEW_LINE> anchor -> GetType ( typeHint ) ; <NEW_LINE> } <NEW_LINE> rv = InternalLoad ( aURI , <NEW_LINE> referer , <NEW_LINE> <START_VULN> nsnull , <NEW_LINE>INTERNAL_LOAD_FLAGS_INHERIT_OWNER , <NEW_LINE> <END_VULN> target . get ( ) , <NEW_LINE> NS_LossyConvertUTF16toASCII ( typeHint ) . get ( ) , <NEW_LINE> aPostDataStream , <NEW_LINE> aHeadersDataStream , <NEW_LINE> LOAD_LINK , <NEW_LINE> nsnull , <NEW_LINE> PR_TRUE , <NEW_LINE> aDocShell ,
{ - 1024 , 0 } } , <NEW_LINE> } ; <NEW_LINE> return vp9_pattern_search ( x , ref_mv , search_param , sad_per_bit , <NEW_LINE> <START_VULN> do_init_search , 0 , vfp , use_mvcost , <NEW_LINE> <END_VULN> center_mv , best_mv , <NEW_LINE> hex_num_candidates , hex_candidates ) ; <NEW_LINE> }
err_out: <NEW_LINE> <START_VULN> qrio_set_gpio ( GPIO_A , CONF_SEL_L , 1 ) ; <NEW_LINE> <END_VULN> toggle_fpga_eeprom_bus ( true ) ; <NEW_LINE> return ret ;
int filter_step ; <NEW_LINE> int filt_high = 0 ; <NEW_LINE> <START_VULN> <NEW_LINE>int filt_mid = cm -> filter_level ; <NEW_LINE> <END_VULN> int filt_low = 0 ; <NEW_LINE> int filt_best ; <NEW_LINE> int filt_direction = 0 ;
-- mSize ; <NEW_LINE> -- dataSize ; <NEW_LINE> } <NEW_LINE> <START_VULN> mData [ writeOffset ++ ] = mData [ readOffset ++ ] ; <NEW_LINE> <END_VULN> } <NEW_LINE> if ( readOffset <= oldSize ) {
