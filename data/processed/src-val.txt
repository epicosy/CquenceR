NS_IMETHODIMP CVE_2012_3979_nsFrameMessageManager : : Dump(const nsAString & aStr ) { #ifdef ANDROID <START_VULN> __android_log_print(ANDROID_LOG_INFO , "Gecko" , NS_ConvertUTF16toUTF8(aStr ) . get( ) ) ; <END_VULN> #endif fputs(NS_ConvertUTF16toUTF8(aStr ) . get( ) , stdout ) ; fflush(stdout ) ; return NS_OK ; }
{ return 1 ; } <START_VULN> mpz_powm (v , v , key -> e , key -> n ) ; <END_VULN> return 0 ; }
ast_rtp_codecs_payloads_copy( & newtextrtp , ast_rtp_instance_get_codecs(p -> trtp ) , p -> trtp ) ; } else { ast_rtp_instance_stop(p -> trtp ) ; if (debug ) ast_verbose("Peer doesn't provide T . 140" ) ; } } if (p -> udptl ) { <START_VULN> if (udptlportno > 0 ) { <END_VULN> if (ast_test_flag( & p -> flags [ 1 ] , SIP_PAGE2_SYMMETRICRTP ) && ast_test_flag( & p -> flags [ 1 ] , SIP_PAGE2_UDPTL_DESTINATION ) ) { ast_rtp_instance_get_remote_address(p -> rtp , isa ) ; if ( ! ast_sockaddr_isnull(isa ) && debug ) { ast_debug(1 , "Peer T . 38 UDPTL is set behind NAT and with destination , destination address now % s" , ast_sockaddr_stringify(isa ) ) ; } } ast_sockaddr_set_port(isa , udptlportno ) ; ast_udptl_set_peer(p -> udptl , isa ) ; if (debug ) ast_debug(1 , "Peer T . 38 UDPTL is at port % s" , ast_sockaddr_stringify(isa ) ) ;
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("Blowfish Cipher Algorithm" ) ; <START_VULN> MODULE_ALIAS("blowfish" ) ; <END_VULN>
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : cdf . c , v 1 . 61 20140604 17 : 23 : 19 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
exit(1 ) ; } for(i = 0 ; i < TESTSIZE ; i + + ) if(fabs(qv [ i ] - iv [ i ] ) > . 000001 ) { fprintf(stderr , "read ( % g ) != written ( % g ) at position ( % ld ) " , iv [ i ] , qv [ i ] , i ) ; exit(1 ) ; } <START_VULN> <END_VULN> fprintf(stderr , "OK" ) ; ptr + + ; } exit(0 ) ; }
efree(ustr ) ; } ubrk_close(bi ) ; <START_VULN> RETURN_EMPTY_STRING( ) ; <END_VULN> }
{ MsgToEventLog(M_SYSERR , TEXT("PeekNamedPipeAsync failed" ) ) ; ReturnLastError(pipe , L"PeekNamedPipeAsync" ) ; <START_VULN> goto out ; <END_VULN> } size = bytes sizeof( * data ) ;
"recovered" , SAS_ADDR(task -> dev ) , cmd -> device -> lun ) ; <START_VULN> sas_eh_defer_cmd(cmd ) ; <END_VULN> sas_scsi_clear_queue_lu(work_q , cmd ) ; goto Again ; }
typedef struct _dumpOptions { <START_VULN> const char * dbname ; <END_VULN> const char * pghost ; const char * pgport ; const char * username ;
void ErrorInvalidEnumInfo(const char * info , WebGLenum enumvalue ) { return ErrorInvalidEnum(" % s : invalid enum value 0x % x" , info , enumvalue ) ; } void ErrorOutOfMemory(const char * fmt = 0 , . . . ) ; const char * ErrorName(GLenum error ) ; bool IsTextureFormatCompressed(GLenum format ) ; <START_VULN> void DummyFramebufferOperation(const char * info ) ; <END_VULN> WebGLTexture * activeBoundTextureForTarget(WebGLenum target ) { return target == LOCAL_GL_TEXTURE_2D ? mBound2DTextures [ mActiveTexture ] : mBoundCubeMapTextures [ mActiveTexture ] ; } already_AddRefed < CanvasLayer > GetCanvasLayer(nsDisplayListBuilder * aBuilder , CanvasLayer * aOldLayer ,
JSTokenStream * ts ; JSPrincipals * principals ; jschar * collected_args , * cp ; <START_VULN> size_t arg_length , args_length ; <END_VULN> JSTokenType tt ; JSBool ok ;
return SC_ERROR_INVALID_ARGUMENTS ; } <START_VULN> if (sec_attr == NULL ) { <END_VULN> if (file -> sec_attr != NULL ) free(file -> sec_attr ) ; file -> sec_attr = NULL ;
MXFEssenceContainerData * essence_data ; if ( ! (essence_data = mxf_resolve_strong_ref(mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) { <START_VULN> av_log(mxf , AV_LOG_TRACE , "could not resolve essence container data strong ref" ) ; <END_VULN> continue ; } if ( ! memcmp(component -> source_package_ul , essence_data -> package_ul , sizeof(UID ) ) && ! memcmp(component -> source_package_uid , essence_data -> package_uid , sizeof(UID ) ) ) {
unsigned int cscov ; const char * msg ; <START_VULN> dh = skb_header_pointer(skb , dataoff , sizeof(_dh ) , & dh ) ; <END_VULN> if (dh == NULL ) { msg = "nf_ct_dccp : short packet " ; goto out_invalid ;
if(posts == 0 ) { nonzero + = accumulate_fit(logmask , logmdct , 0 , n , fits , n , info ) ; } else { for(i = 0 ; i < posts - 1 ; i + + ) nonzero + = accumulate_fit(logmask , logmdct , look -> sorted_index [ i ] , look -> sorted_index [ i + 1 ] , fits + i , n , info ) ; } <START_VULN> <END_VULN> if(nonzero ) { int y0 = - 200 ; int y1 = - 200 ; fit_line(fits , posts - 1 , & y0 , & y1 ) ; fit_valueA [ 0 ] = y0 ; fit_valueB [ 0 ] = y0 ;
} <START_VULN> bool f2fs_init_extent_tree(struct inode * inode , struct f2fs_extent * i_ext ) <END_VULN> { struct f2fs_sb_info * sbi = F2FS_I_SB(inode ) ; struct extent_tree * et ;
OM_uint32 ret ; spnego_gss_ctx_id_t sc = NULL ; <START_VULN> sc = create_spnego_ctx( ) ; <END_VULN> if (sc == NULL ) return GSS_S_FAILURE ;
case EXPR_INVERT : case EXPR_NOT : <START_VULN> ok = ExprResolveBoolean(ctx , expr , set_rtrn ) ; <END_VULN> if (ok ) * set_rtrn = ! * set_rtrn ; return ok ;
bits [ 1 ] = cpu_to_be64(sctx -> count [ 0 ] << 3 ) ; <START_VULN> bits [ 0 ] = cpu_to_be64(sctx -> count [ 1 ] << 3 ) | sctx -> count [ 0 ] >> 61 ; <END_VULN>
void midi_synth_close (int dev ) ; void midi_synth_hw_control (int dev , unsigned char * event ) ; int midi_synth_load_patch (int dev , int format , const char __user * addr , <START_VULN> int offs , int count , int pmgr_flag ) ; <END_VULN> void midi_synth_panning (int dev , int channel , int pressure ) ; void midi_synth_aftertouch (int dev , int channel , int pressure ) ; void midi_synth_controller (int dev , int channel , int ctrl_num , int value ) ;
class nsGIFDecoder2 : public Decoder { public : nsGIFDecoder2(RasterImage & aImage ) ; ~ nsGIFDecoder2( ) ; <START_VULN> virtual void WriteInternal(const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual void FinishInternal( ) ; virtual Telemetry : : ID SpeedHistogram( ) ; private : void BeginGIF( ) ;
. mmap = generic_file_mmap , . fsync = noop_fsync , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . llseek = generic_file_llseek , } ;
ret = anon_inode_getfd(ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; if (ret < 0 ) { <START_VULN> ops -> destroy(dev ) ; <END_VULN> mutex_lock( & kvm -> lock ) ; list_del( & dev -> vm_node ) ; mutex_unlock( & kvm -> lock ) ; return ret ; }
{ int i ; int nr = pagevec_count(pvec ) ; <START_VULN> int delta_munlocked ; <END_VULN> struct pagevec pvec_putback ; int pgrescued = 0 ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : cdf . c , v 1 . 63 20140609 13 : 04 : 37 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
int ret = 0 ; ve -> stretch + + ; if(ve -> stretch > VE_MAXSTRETCH * 2 ) ve -> stretch = VE_MAXSTRETCH * 2 ; for(i = 0 ; i < ve -> ch ; i + + ) { float * pcm = v -> pcm [ i ] + ve -> searchstep * (j ) ; <START_VULN> ret |= _ve_amp(ve , gi , pcm , ve -> band , ve -> filter + i * VE_BANDS , j ) ; <END_VULN> } ve -> mark [ j + VE_POST ] = 0 ; if(ret & 1 ) { ve -> mark [ j ] = 1 ; ve -> mark [ j + 1 ] = 1 ; }
if ((pce = pcre_get_compiled_regex_cache(regex , regex_len TSRMLS_CC ) ) == NULL ) { RETURN_FALSE ; } <START_VULN> php_pcre_match_impl(pce , subject , subject_len , return_value , subpats , <END_VULN> global , ZEND_NUM_ARGS( ) >= 4 , flags , start_offset TSRMLS_CC ) ; }
int ext_off , noff , weight ; size_t lt ; <START_VULN> if ((int ) (l = np -> file -> basename_utf16 . length ) > ffmax ) <END_VULN> l = ffmax ; p = malloc((l + 1 ) * 2 ) ;
cl_allowDownload = Cvar_Get( "cl_allowDownload" , "1" , CVAR_ARCHIVE ) ; #ifdef USE_CURL_DLOPEN <START_VULN> cl_cURLLib = Cvar_Get("cl_cURLLib" , DEFAULT_CURL_LIB , CVAR_ARCHIVE ) ; <END_VULN> #endif
else h -> is_streamed = 1 ; <START_VULN> s -> filesize = - 1 ; <END_VULN> s -> location = av_strdup(uri ) ; if ( ! s -> location ) return AVERROR(ENOMEM ) ;
* s = '' ; } } <START_VULN> s [ 1 ] = '0' ; <END_VULN> if (resource -> path && * (resource -> path ) == '' && * (resource -> path + 1 ) == '0' ) { snprintf(loc_path , sizeof(loc_path ) - 1 , " % s % s" , resource -> path , location ) ; } else {
break ; case 0x70 . . . 0x7f : if (test_cc(ctxt -> b , ctxt -> eflags ) ) <START_VULN> jmp_rel(ctxt , ctxt -> src . val ) ; <END_VULN> break ; case 0x8d : ctxt -> dst . val = ctxt -> src . addr . mem . ea ;
. write_iter = generic_file_write_iter , . mmap = generic_file_mmap , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . fsync = jfs_fsync , . release = jfs_release , . unlocked_ioctl = jfs_ioctl ,
pixGetDimensions(pix , & w , NULL , & d ) ; factor = (l_float32 ) thumbwidth (l_float32 ) w ; pixthumb = pixScale(pix , factor , factor ) ; <START_VULN> sprintf(charbuf , " % s_thumb_ % 03d" , rootname , index ) ; <END_VULN> sarrayAddString(sathumbs , charbuf , L_COPY ) ; outname = genPathname(dirout , charbuf ) ; WriteFormattedPix(outname , pixthumb ) ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : readelf . c , v 1 . 126 20151116 16 : 03 : 45 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
r = sc_read_record (card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof(buff ) , SC_RECORD_BY_REC_NR ) ; SC_TEST_RET(card -> ctx , SC_LOG_DEBUG_NORMAL , r , "read document number failed" ) ; <START_VULN> buff [ r ] = '0' ; <END_VULN> set_string ( & p15card -> tokeninfo -> serial_number , (const char * ) buff ) ; p15card -> tokeninfo -> flags = SC_PKCS15_TOKEN_PRN_GENERATION
<START_VULN> if ((int ) np -> file -> basename_utf16 . length > ffmax ) { <END_VULN> if (archive_strncpy_l( & iso9660 -> mbs , (const char * ) np -> identifier , l , iso9660 -> sconv_from_utf16be ) != 0 &&
if ((have_header & HTTP_HEADER_HOST ) == 0 ) { <START_VULN> if ((use_ssl && resource -> port != 443 && resource -> port != 0 ) || <END_VULN> ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) { if (snprintf(scratch , scratch_len , "Host : % s : % ir" , resource -> host , resource -> port ) > 0 ) php_stream_write(stream , scratch , strlen(scratch ) ) ;
tfm -> __crt_alg -> cra_type == & crypto_givcipher_type ) return crypto_init_skcipher_ops_ablkcipher(tfm ) ; <START_VULN> skcipher -> setkey = alg -> setkey ; <END_VULN> skcipher -> encrypt = alg -> encrypt ; skcipher -> decrypt = alg -> decrypt ; skcipher -> ivsize = alg -> ivsize ;
* <START_VULN> <END_VULN> #ifndef __nss_h_ #define __nss_h_ #ifdef NSS_ENABLE_ECC #ifdef NSS_ECC_MORE_THAN_SUITE_B #define _NSS_ECC_STRING " Extended ECC"
phar_obj -> arc . archive -> alias = oldalias ; phar_obj -> arc . archive -> alias_len = oldalias_len ; phar_obj -> arc . archive -> is_temporary_alias = old_temp ; <START_VULN> zend_throw_exception_ex(phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> if (readd ) { zend_hash_add( & (PHAR_GLOBALS -> phar_alias_map ) , oldalias , oldalias_len , (void * ) & (phar_obj -> arc . archive ) , sizeof(phar_archive_data * ) , NULL ) ; }
} update_open_stateid(state , & data -> o_res . stateid , NULL , <START_VULN> data -> o_arg . open_flags ) ; <END_VULN> iput(inode ) ; out : return state ;
(v -> sequence + 1 != vb -> sequence ) ) { v -> granulepos = - 1 ; * out of sequence ; lose count * b -> sample_count = - 1 ; } v -> sequence = vb -> sequence ; if(vb -> pcm ) { * no pcm to process if vorbis_synthesis_trackonly <START_VULN> was called on block * <END_VULN> int n = ci -> blocksizes [ v -> W ] >> (hs + 1 ) ; int n0 = ci -> blocksizes [ 0 ] >> (hs + 1 ) ; int n1 = ci -> blocksizes [ 1 ] >> (hs + 1 ) ; int thisCenter ; int prevCenter ; v -> glue_bits + = vb -> glue_bits ;
case ' > ' : h -> endian = BIG ; return ; case ' < ' : h -> endian = LITTLE ; return ; case ' ! ' : { <START_VULN> int a = getnum(L , fmt , MAXALIGN ) ; <END_VULN> if ( ! isp2(a ) ) luaL_error(L , "alignment % d is not a power of 2" , a ) ; h -> align = a ;
<START_VULN> touch_file(t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <END_VULN> } t -> result = TIMER_SUCCESS ;
ind = 2 ; <START_VULN> while (ibuf [ ind ] == 0x01 ) { <END_VULN> if (ibuf [ ind + 1 ] == 0xFE ) { gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; sc_log(card -> ctx , "Key container % d is allocated and uses key_ref % d" ,
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : PCM data envelope analysis <START_VULN> last mod : $ Id : envelope . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < stdio . h > #include < math . h > #include < oggogg . h >
u32 eb ; eb = (1u << PF_VECTOR ) | (1u << UD_VECTOR ) | (1u << MC_VECTOR ) | <START_VULN> (1u << NM_VECTOR ) | (1u << DB_VECTOR ) ; <END_VULN> if ((vcpu -> guest_debug & (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) )
public : ObjectElements(uint32_t capacity , uint32_t length ) <START_VULN> : capacity(capacity ) , initializedLength(0 ) , length(length ) <END_VULN> { } HeapSlot * elements( ) { return (HeapSlot * ) (uintptr_t(this ) + sizeof(ObjectElements ) ) ; }
if (chr(s , ' < ' ) ) { <START_VULN> while (peek(s ) != ' > ' && ! eol(s ) ) <END_VULN> buf_append(s , next(s ) ) ; if ( ! chr(s , ' > ' ) ) { scanner_err(s , "unterminated keysym literal" ) ;
virtual mozilla : : dom : : EventTarget * GetParentTarget( ) MOZ_OVERRIDE { return mParent ; } virtual nsIDOMWindow * GetOwnerGlobal( ) MOZ_OVERRIDE ; NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(nsWindowRoot , nsIDOMEventTarget ) protected : <START_VULN> nsPIDOMWindow * mWindow ; <END_VULN> nsRefPtr < nsEventListenerManager > mListenerManager ; nsCOMPtr < nsIDOMNode > mPopupNode ; nsCOMPtr < mozilla : : dom : : EventTarget > mParent ; } ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : cdf . c , v 1 . 59 20140514 23 : 22 : 48 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
} ; extern nsresult <START_VULN> NS_CreateJSTimeoutHandler(nsIScriptContext * aContext , <END_VULN> PRBool * aIsInterval , PRInt32 * aInterval , nsIScriptTimeoutHandler ** aRet ) ;
while (ns -- > 0 && cp && cp < end ) { zval * retval = NULL ; <START_VULN> cp = php_parserr(cp , & answer , DNS_T_ANY , authns != NULL , raw , & retval ) ; <END_VULN> if (retval != NULL ) { add_next_index_zval(authns , retval ) ; }
seed = buf ; } <START_VULN> err = tfm -> seed(tfm , seed , slen ) ; <END_VULN> kfree(buf ) ; return err ;
u16 selector , int seg ) { u8 cpl = ctxt -> ops -> cpl(ctxt ) ; <START_VULN> return __load_segment_descriptor(ctxt , selector , seg , cpl , false ) ; <END_VULN> } static void write_register_operand(struct operand * op )
replace_value = & empty_replace ; } } <START_VULN> <END_VULN> if ((result = php_pcre_replace(Z_STRVAL_PP(regex_entry ) ,
err = sock_do_ioctl(net , sock , cmd , (unsigned long ) & ktv ) ; set_fs(old_fs ) ; if ( ! err ) <START_VULN> err = compat_put_timeval(up , & ktv ) ; <END_VULN> return err ; }
<START_VULN> p = BuildTestPacket(1 , 8183 , 0 , 'A' , 71 ) ; <END_VULN> if (p == NULL ) goto end ;
rcu_read_lock( ) ; indev = __in_dev_get_rcu(skb -> dev ) ; <START_VULN> if (indev != NULL ) { <END_VULN> ifa = indev -> ifa_list ; newdst = ifa -> ifa_local ; }
struct hlist_node node ; struct user_namespace * ns ; kuid_t uid ; <START_VULN> atomic_t count ; <END_VULN> atomic_t ucount [ UCOUNT_COUNTS ] ; } ;
continue ; } } else { <START_VULN> NEED_OP(t ) ; <END_VULN> do { * op + + = * m_pos + + ; } while (op < oe ) ;
* <START_VULN> <END_VULN> #include "cert . h" #include "ssl . h" #include "cryptohi . h" #include "keyhi . h" #include "secder . h" #include "secitem . h"
ret = gpiochip_add_data( & gpio_dev -> gc , gpio_dev ) ; if (ret ) <START_VULN> goto out1 ; <END_VULN> ret = gpiochip_add_pin_range( & gpio_dev -> gc , dev_name( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ;
break ; case 0x80 . . . 0x8f : if (test_cc(ctxt -> b , ctxt -> eflags ) ) <START_VULN> jmp_rel(ctxt , ctxt -> src . val ) ; <END_VULN> break ; case 0x90 . . . 0x9f : ctxt -> dst . val = test_cc(ctxt -> b , ctxt -> eflags ) ;
( * buffer ) [ ( * currlen ) + + ] = (char ) c ; } <START_VULN> return ; <END_VULN> }
for (int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK ; i > 0 ; i -- , to + + ) { JSBool marked = to -> IsMarked( ) ; to -> Unmark( ) ; if (marked ) continue ; <START_VULN> if ( ! to -> GetJSObject( ) ) { <END_VULN> nsISupports * obj = to -> GetNative( ) ; if (obj ) { obj -> Release( ) ; to -> SetNative(nsnull ) ; } to -> SetInterface(nsnull ) ; } }
if (ast_strlen_zero(header_content ) ) { ast_log (LOG_ERROR , "Could not fetch header for message number % ld" , vms -> msgArray [ vms -> curmsg ] ) ; return - 1 ; } snprintf(todir , sizeof(todir ) , " % s % s % stmp" , VM_SPOOL_DIR , vmu -> context , vmu -> mailbox ) ; make_gsm_file(vms -> fn , vms -> imapuser , todir , vms -> curmsg ) ; mail_fetchstructure (vms -> mailstream , vms -> msgArray [ vms -> curmsg ] , & body ) ; <START_VULN> if (body -> nested . part -> next && body -> nested . part -> next -> body . parameter -> value ) { <END_VULN> attachedfilefmt = ast_strdupa(body -> nested . part -> next -> body . parameter -> value ) ; } else { ast_log(LOG_ERROR , "There is no file attached to this IMAP message . " ) ; return - 1 ; } strsep( & attachedfilefmt , " . " ) ; if ( ! attachedfilefmt ) {
return bh ; } brelse(bh ) ; <START_VULN> ce = mb_cache_entry_find_next(ce , inode -> i_sb -> s_bdev , hash ) ; <END_VULN> } return NULL ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : libvorbis backend and mapping structures ; needed for static mode headers <START_VULN> last mod : $ Id : backends . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _vorbis_backend_h_
int flags = 0 ; Elf32_Ehdr elf32hdr ; Elf64_Ehdr elf64hdr ; <START_VULN> uint16_t type ; <END_VULN> if (ms -> flags & (MAGIC_MIME | MAGIC_APPLE ) ) return 0 ;
char * datablob ; int ret = 0 ; <START_VULN> if (test_bit(KEY_FLAG_NEGATIVE , & key -> flags ) ) <END_VULN> return - ENOKEY ; p = key -> payload . data [ 0 ] ; if ( ! p -> migratable )
static int CVE_2006_2935_dvd_read_bca(struct cdrom_device_info * cdi , dvd_struct * s ) { int ret ; u_char buf [ 4 + 188 ] ; struct packet_command cgc ; struct cdrom_device_ops * cdo = cdi -> ops ; init_cdrom_command( & cgc , buf , sizeof(buf ) , CGC_DATA_READ ) ; cgc . cmd [ 0 ] = GPCMD_READ_DVD_STRUCTURE ; cgc . cmd [ 7 ] = s -> type ; <START_VULN> cgc . cmd [ 9 ] = cgc . buflen = 0xff ; <END_VULN> if ((ret = cdo -> generic_packet(cdi , & cgc ) ) ) return ret ; s -> bca . len = buf [ 0 ] << 8 | buf [ 1 ] ; if (s -> bca . len < 12 || s -> bca . len > 188 ) { cdinfo(CD_WARNING , "Received invalid BCA length ( % d ) " , s -> bca . len ) ; return - EIO ; } memcpy(s -> bca . value , & buf [ 4 ] , s -> bca . len ) ;
STATE_UNINITIALIZED , STATE_INITIALIZED , STATE_CHECKING , STATE_DOWNLOADING , STATE_CANCELLED , STATE_FINISHED } mState ; <START_VULN> nsOfflineCacheUpdateOwner * mOwner ; <END_VULN> bool mAddedItems ; bool mPartialUpdate ; bool mOnlyCheckUpdate ; bool mSucceeded ; bool mObsolete ; nsCString mUpdateDomain ;
linenr_Tline_lnum ; colnr_Tline_colnr ; linenr_Tline_count ; <START_VULN> intnum_head = 0 ; <END_VULN> longold_header_seq , new_header_seq , cur_header_seq ; longseq_last , seq_cur ; longlast_save_nr = 0 ;
n = 0 ; quantum = 0 ; <START_VULN> for (x = 0 ; x < (ssize_t ) number_pixels ; x + = 2 ) <END_VULN> { for (i = 0 ; i < 4 ; i + + ) {
char __ptype [ 5 ] ; strcpy(__ptype , gf_4cc_to_str(__parent -> type ) ) ; GF_LOG(GF_LOG_WARNING , GF_LOG_CONTAINER , (" [ iso file ] extra box % s found in % s , deleting" , gf_4cc_to_str(__abox -> type ) , __ptype ) ) ; <START_VULN> gf_isom_box_del(a ) ; <END_VULN> return GF_OK ; }
goto bail ; } <START_VULN> len = mutt_b64_decode(obuf , idata -> buf + 2 ) ; <END_VULN> if (len == - 1 ) { mutt_debug(1 , "Error decoding base64 response . " ) ;
struct TypedArrayObjectStorage : AllTypedArraysBase { protected : JSObject * mObj ; <START_VULN> TypedArrayObjectStorage( ) <END_VULN> { } public : inline void TraceSelf(JSTracer * trc ) { if (mObj ) { JS_CallObjectTracer(trc , & mObj , "TypedArray . mObj" ) ;
{ MsgToEventLog(M_SYSERR , TEXT("malloc failed" ) ) ; ReturnLastError(pipe , L"malloc" ) ; <START_VULN> goto out ; <END_VULN> } read = ReadPipeAsync(pipe , data , bytes , 1 , & exit_event ) ;
return user_core_fd ; } <START_VULN> static bool dump_fd_info(const char * dest_filename , char * source_filename , int source_base_ofs ) <END_VULN> { FILE * fp = fopen(dest_filename , "w" ) ; if ( ! fp )
class nsPNGDecoder : public Decoder { public : nsPNGDecoder(RasterImage & aImage ) ; virtual ~ nsPNGDecoder( ) ; virtual void InitInternal( ) ; <START_VULN> virtual void WriteInternal(const char * aBuffer , uint32_t aCount ) ; <END_VULN> virtual Telemetry : : ID SpeedHistogram( ) ; void CreateFrame(png_uint_32 x_offset , png_uint_32 y_offset , int32_t width , int32_t height , gfxImageFormat format ) ; void EndImageFrame( ) ;
MODULE_DESCRIPTION("Camellia Cipher Algorithm" ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("camellia" ) ; <END_VULN>
. index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred( ) , <START_VULN> . match_data . cmp = user_match , <END_VULN> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ;
fptr = (struct frag_hdr * ) (skb_network_header(skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; <START_VULN> ipv6_select_ident(fptr ) ; <END_VULN>
const PRUint16 platformID = ReadShortAt(table , TableOffsetPlatformID ) ; if ( ! acceptablePlatform(platformID ) ) continue ; const PRUint16 encodingID = ReadShortAt(table , TableOffsetEncodingID ) ; const PRUint32 offset = ReadLongAt(table , TableOffsetOffset ) ; NS_ASSERTION(offset < aBufLength , "cmap table offset is longer than table size" ) ; <START_VULN> NS_ENSURE_TRUE(offset < aBufLength , NS_ERROR_FAILURE ) ; <END_VULN> const PRUint8 * subtable = aBuf + offset ; const PRUint16 format = ReadShortAt(subtable , SubtableOffsetFormat ) ; if (isSymbol(platformID , encodingID ) ) { aUnicodeFont = PR_FALSE ; aSymbolFont = PR_TRUE ; keepFormat = format ;
new_timer -> it_id = (timer_t ) new_timer_id ; new_timer -> it_clock = which_clock ; new_timer -> kclock = kc ; <START_VULN> new_timer -> it_overrun = - 1 ; <END_VULN> if (event ) { rcu_read_lock( ) ;
(u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ) ; <START_VULN> if ( ! ssid_ie ) <END_VULN> return - EINVAL ; memcpy(ssid_le . SSID , ssid_ie -> data , ssid_ie -> len ) ;
UTF16_BIG_ENDIAN } ; <START_VULN> <END_VULN> extern int register_nls(struct nls_table * ) ; extern int unregister_nls(struct nls_table * ) ; extern struct nls_table * load_nls(char * ) ;
rkeylen = strlen(rkey ) ; <START_VULN> if(nad_find_attr(nad , 0 , - 1 , "type" , "valid" ) >= 0 ) { <END_VULN> log_write(out -> s2s -> log , LOG_NOTICE , " [ % d ] [ % s , port = % d ] outgoing route ' % s' is now valid % s % s" , out -> fd -> fd , out -> ip , out -> port , rkey , (out -> s -> flags & SX_SSL_WRAPPER ) ? " , TLS negotiated" : "" , out -> s -> compressed ? " , ZLIB compression enabled" : "" ) ; xhash_put(out -> states , pstrdup(xhash_pool(out -> states ) , rkey ) , (void * ) conn_VALID ) ;
struct domain_device * dev = NULL ; res = sas_find_bcast_dev(port_dev , & dev ) ; <START_VULN> while (res == 0 && dev ) { <END_VULN> struct expander_device * ex = & dev -> ex_dev ; int i = 0 , phy_id ;
if (signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { <START_VULN> ASN1err(ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <END_VULN> return - 1 ; }
if (value_expected == MagickFalse ) continue ; p = value ; <START_VULN> while ((c != '' ) && (c != '0' ) ) <END_VULN> { if ((size_t ) (p - value ) < (MaxTextExtent - 1 ) ) * p + + = c ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : single - block PCM analysis mode dispatch <START_VULN> last mod : $ Id : analysis . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdio . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
if (rc != X86EMUL_CONTINUE ) return rc ; <START_VULN> rc = segmented_read(ctxt , ctxt -> memop . addr . mem , & fx_state , 512 ) ; <END_VULN> if (rc != X86EMUL_CONTINUE ) return rc ;
int err ; struct virtio_net_hdr vnet_hdr = { 0 } ; int vnet_hdr_len = 0 ; <START_VULN> int copylen ; <END_VULN> bool zerocopy = false ; if (q -> flags & IFF_VNET_HDR ) {
} <START_VULN> #define DOBIG4 c ^= * + + buf4 ; <END_VULN> c = crc_table [ 4 ] [ c & 0xff ] ^ crc_table [ 5 ] [ (c >> 8 ) & 0xff ] ^ crc_table [ 6 ] [ (c >> 16 ) & 0xff ] ^ crc_table [ 7 ] [ c >> 24 ] #define DOBIG32 DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4 ; DOBIG4
if (avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) { <START_VULN> if (avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <END_VULN> c -> idct_put = ff_simple_idct_put_int32_10bit ; else { c -> idct_put = ff_simple_idct_put_int16_10bit ;
<START_VULN> return mutt_bcache_del(bcache , id ) ; <END_VULN> } #ifdef USE_HCACHE
sem_lock_and_putref(sma ) ; if (sma -> sem_perm . deleted ) { <START_VULN> sem_unlock(sma ) ; <END_VULN> kfree(new ) ; un = ERR_PTR( - EIDRM ) ; goto out ;
path . dentry = res ; nfs_set_verifier(path . dentry , nfs_save_change_attribute(dir ) ) ; nfs_unblock_sillyrename(parent ) ; <START_VULN> nfs4_intent_set_file(nd , & path , state ) ; <END_VULN> return res ; }
virtual void ProcessTextData( ) ; PRBool SetTextStyle( ) ; <START_VULN> void SetQuotes( ) ; <END_VULN> } ; #endif
{ MOZ_COUNT_DTOR(nsXBLProtoImpl ) ; delete mMembers ; delete mFields ; } <START_VULN> nsresult InstallImplementation(nsXBLPrototypeBinding * aBinding , nsIContent * aBoundElement ) ; <END_VULN> nsresult InitTargetObjects(nsXBLPrototypeBinding * aBinding , nsIScriptContext * aContext , nsIContent * aBoundElement , nsIXPConnectJSObjectHolder ** aScriptObjectHolder , JSObject ** aTargetClassObject ) ; nsresult CompilePrototypeMembers(nsXBLPrototypeBinding * aBinding ) ; void SetMemberList(nsXBLProtoImplMember * aMemberList ) {
p -> n = n ; p -> rate = rate ; p -> m_val = 1 . ; if(rate < 26000 ) p -> m_val = 0 ; else if(rate < 38000 ) p -> m_val = . 94 ; else if(rate > 46000 ) p -> m_val = 1 . 275 ; <START_VULN> <END_VULN> for(i = 0 , j = 0 ; i < MAX_ATH - 1 ; i + + ) { int endpos = rint(fromOC((i + 1 ) * . 125 - 2 . ) * 2 * nrate ) ; float base = ATH [ i ] ; if(j < endpos ) { float delta = (ATH [ i + 1 ] - base ) (endpos - j ) ; for( ; j < endpos && j < n ; j + + ) {
out1 [ 0 ] = '0' ; <START_VULN> declen = mutt_b64_decode(out2 , out1 ) ; <END_VULN> if ( ! TEST_CHECK(declen == - 1 ) ) { TEST_MSG("Expected : % zu" , - 1 ) ;
memcpy(new_bh -> b_data , header , new_bh -> b_size ) ; set_buffer_uptodate(new_bh ) ; unlock_buffer(new_bh ) ; <START_VULN> ext2_xattr_cache_insert(new_bh ) ; <END_VULN> ext2_xattr_update_super_block(sb ) ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : floor backend 1 implementation <START_VULN> last mod : $ Id : floor1 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
static void CVE_2012_4298_vwr_read_rec_data_ethernet(wtap * wth , guint8 * data_ptr , guint8 * rec , int rec_size , int IS_TX ) { vwr_t * vwr = (vwr_t * ) wth -> priv ; int bytes_written = 0 ; register int i ; register guint8 * s_ptr , * m_ptr ; <START_VULN> gint16 msdu_length , actual_octets ; <END_VULN> guint8 flow_seq ; guint64 s_time = LL_ZERO , e_time = LL_ZERO ; guint32 latency = 0 ; guint64 start_time , s_sec , s_usec = LL_ZERO ; guint64 end_time ; guint16 l4id , info , validityBits ; guint32 errors ; guint16 vc_id ; guint32 flow_id , d_time ;
} if ((flags & FOLL_NUMA ) && pte_protnone(pte ) ) goto no_page ; <START_VULN> if ((flags & FOLL_WRITE ) && ! pte_write(pte ) ) { <END_VULN> pte_unmap_unlock(ptep , ptl ) ; return NULL ; }
guint32 offset , guint32 str_tbl , guint8 level , guint8 * codepage_attr ) { guint32 tvb_len = tvb_reported_length (tvb ) ; <START_VULN> guint32 off = offset ; <END_VULN> guint32 len ; guint str_len ; guint32 ent ;
. lock = gfs2_lock , . flock = gfs2_flock , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . setlease = gfs2_setlease , . fallocate = gfs2_fallocate , } ;
} if (src != tmp_im ) { <START_VULN> gdFree(tmp_im ) ; <END_VULN> } return dst ;
} <START_VULN> ws_buffer_assure_space(buf , TOSHIBA_MAX_PACKET_LEN ) ; <END_VULN> pd = ws_buffer_start_ptr(buf ) ;
if (parse_cookie(s , p , & s -> cookie_dict ) ) av_log(h , AV_LOG_WARNING , "Unable to parse ' % s'" , p ) ; } else if ( ! av_strcasecmp(tag , "Icy - MetaInt" ) ) { <START_VULN> s -> icy_metaint = strtoll(p , NULL , 10 ) ; <END_VULN> } else if ( ! av_strncasecmp(tag , "Icy - " , 4 ) ) { if ((ret = parse_icy(s , tag , p ) ) < 0 ) return ret ;
gss_buffer_t interprocess_token ) { OM_uint32 maj ; <START_VULN> iakerb_ctx_id_t ctx = (iakerb_ctx_id_t ) context_handle ; <END_VULN> if ( ! ctx -> established )
if (rc == pcmk_ok ) { rc = cib -> cmds -> set_connection_dnotify(cib , mon_cib_connection_destroy ) ; if (rc == - EPROTONOSUPPORT ) { <START_VULN> print_as("Notification setup failed , won't be able to reconnect after failure" ) ; <END_VULN> if (as_console ) { sleep(2 ) ; }
if(likely(vbr != NULL ) ) { svbranch = vbr -> value ; trim( & svbranch ) ; <START_VULN> dsize + = svbranch . len ; <END_VULN> } if(dsize < 256 ) dsize = 256 ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : readelf . c , v 1 . 115 20141216 20 : 53 : 05 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
{ zval * retval_ptr ; zval ** args [ 1 ] ; <START_VULN> zval * subpats ; <END_VULN> int result_len ; int i ;
if (IS_SYNTAX_OP(syn , ONIG_SYN_OP_ESC_OCTAL3 ) ) { prev = p ; num = scan_unsigned_octal_number( & p , end , (c == '0' ? 2 : 3 ) , enc ) ; <START_VULN> if (num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <END_VULN> if (p == prev ) { num = 0 ; }
char * guestfs___first_line_of_file (guestfs_h * g , const char * filename ) { <START_VULN> CLEANUP_FREE char ** lines = NULL ; <END_VULN> int64_t size ; char * ret ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : LSP (also called LSF ) conversion routines <START_VULN> last mod : $ Id : lsp . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> The LSP generation code is taken (with minimal modification and a few bugfixes ) from "On the Computation of the LSP Frequencies" by Joseph Rothweiler (see http : The paper is available at : http :
static const struct driver_info wwan_info = { . description = "Mobile Broadband Network Device" , . flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET <START_VULN> | FLAG_WWAN , <END_VULN> . bind = cdc_ncm_bind , . unbind = cdc_ncm_unbind , . manage_power = usbnet_manage_power ,
case GF_ISOM_SAMPLE_GROUP_TRIF : trif_dump(trace , (char * ) ((GF_DefaultSampleGroupDescriptionEntry * ) entry ) -> data , ((GF_DefaultSampleGroupDescriptionEntry * ) entry ) -> length ) ; break ; <START_VULN> <END_VULN> case GF_ISOM_SAMPLE_GROUP_NALM : nalm_dump(trace , (char * ) ((GF_DefaultSampleGroupDescriptionEntry * ) entry ) -> data , ((GF_DefaultSampleGroupDescriptionEntry * ) entry ) -> length ) ; break ;
MODULE_DESCRIPTION("Adjunct Processor Bus driver , " "Copyright IBM Corp . 2006 , 2012" ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("z90crypt" ) ; <END_VULN>
frame -> width = w ; frame -> height = h ; <START_VULN> for (plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane + + ) { <END_VULN> int hsub = s -> draw . hsub [ plane ] ; int vsub = s -> draw . vsub [ plane ] ; frame -> data [ plane ] + = (s -> x >> hsub ) * s -> draw . pixelstep [ plane ] +
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : bitrate tracking and management <START_VULN> last mod : $ Id : bitrate . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
#ifdef MOZ_MAINTENANCE_SERVICE useService = IsUpdateStatusPendingService( ) ; testOnlyFallbackKeyExists = DoesFallbackKeyExist( ) ; #endif { <START_VULN> HKEY hkApp ; <END_VULN> RegCreateKeyExW(HKEY_CURRENT_USER , L"SoftwareClassesApplications" , 0 , nullptr , REG_OPTION_NON_VOLATILE , KEY_SET_VALUE , nullptr , & hkApp , nullptr ) ; RegCloseKey(hkApp ) ; if (RegCreateKeyExW(HKEY_CURRENT_USER , L"SoftwareClassesApplicationsupdater . exe" , 0 , nullptr , REG_OPTION_VOLATILE , KEY_SET_VALUE , nullptr , & hkApp , nullptr ) == ERROR_SUCCESS ) { RegSetValueExW(hkApp , L"IsHostApp" , 0 , REG_NONE , 0 , 0 ) ; RegSetValueExW(hkApp , L"NoOpenWith" , 0 , REG_NONE , 0 , 0 ) ;
{ int error ; bool is_dir = d_is_dir(old_dentry ) ; <START_VULN> const unsigned char * old_name ; <END_VULN> struct inode * source = old_dentry -> d_inode ; struct inode * target = new_dentry -> d_inode ; bool new_is_dir = false ; unsigned max_links = new_dir -> i_sb -> s_max_links ; if (source == target ) return 0 ;
av_frame_copy_props(out , in ) ; } <START_VULN> for (p = 0 ; p < 4 && in -> data [ p ] ; p + + ) { <END_VULN> int w = inlink -> w ; int h = inlink -> h ; int r = s -> radius ;
int vorbis_synthesis_pcmout(vorbis_dsp_state * v , float ** * pcm ) { vorbis_info * vi = v -> vi ; if(v -> pcm_returned > - 1 && v -> pcm_returned < v -> pcm_current ) { if(pcm ) { int i ; for(i = 0 ; i < vi -> channels ; i + + ) <START_VULN> v -> pcmret [ i ] = v -> pcm [ i ] + v -> pcm_returned ; <END_VULN> * pcm = v -> pcmret ; } return(v -> pcm_current - v -> pcm_returned ) ; } return(0 ) ; } int vorbis_synthesis_read(vorbis_dsp_state * v , int n ) {
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : #ifdef jail to whip a few platforms into the UNIX ideal . <START_VULN> last mod : $ Id : os_types . h 16649 2009 - 10 - 25 00 : 49 : 58Z ds $ <END_VULN> #ifndef _OS_TYPES_H #define _OS_TYPES_H different malloc than stdlib * #define _ogg_malloc malloc
if (s -> size - stream_ptr < n_blocks * 4 ) return ; while (n_blocks -- ) { block_ptr = row_ptr + pixel_ptr ; for (pixel_y = 0 ; pixel_y < 4 ; pixel_y + + ) { } <START_VULN> ADVANCE_BLOCK( ) ; <END_VULN> } break ;
e = sc_file_get_acl_entry(file , SC_AC_OP_READ ) ; if (e == NULL || e -> method == SC_AC_NEVER ) return 10 ; <START_VULN> bufsize = file -> size ; <END_VULN> sc_file_free(file ) ; r = sc_read_binary(card , 0 , buf , bufsize , 0 ) ; if (r < 0 ) {
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID("@(# ) $ File : readelf . c , v 1 . 113 20141211 14 : 10 : 53 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
if (acl_len > buflen ) goto out_free ; _copy_from_pages(buf , pages , res . acl_data_offset , <START_VULN> res . acl_len ) ; <END_VULN> } ret = acl_len ; out_free :
nsresult SaveSelection(nsISelection * aSel ) ; nsresult RestoreSelection(nsISelection * aSel ) ; bool IsCollapsed( ) ; bool IsEqual(nsSelectionState * aSelState ) ; void MakeEmpty( ) ; bool IsEmpty( ) ; protected : <START_VULN> nsTArray < nsRangeStore > mArray ; <END_VULN> friend class nsRangeUpdater ; } ; class nsRangeUpdater { public :
sycc_to_rgb(offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; + + ny ; + + nr ; + + ng ; + + nb ; + + cb ; + + cr ; } <START_VULN> if(j < maxw ) <END_VULN> { sycc_to_rgb(offset , upb , * y , * cb , * cr , r , g , b ) ; + + y ; + + r ; + + g ; + + b ;
JSObject ** aRetval ) ; nsresult PutImageData_explicit(int32_t x , int32_t y , uint32_t w , uint32_t h , <START_VULN> unsigned char * aData , uint32_t aDataLen , <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , int32_t dirtyWidth , int32_t dirtyHeight ) ;
u_int8_t type , old_state , new_state ; enum ct_dccp_roles role ; <START_VULN> dh = skb_header_pointer(skb , dataoff , sizeof(_dh ) , & dh ) ; <END_VULN> BUG_ON(dh == NULL ) ; type = dh -> dccph_type ;
len -= sizeof( * io ) * nid ; io = (struct id_off * ) (id + 1 ) ; cp = (char * ) (io + nid ) ; <START_VULN> if ( ! ND_TTEST2(cp , len ) ) { <END_VULN> ND_PRINT((ndo , """ ) ) ; fn_print(ndo , (u_char * ) cp , (u_char * ) cp + len ) ; ND_PRINT((ndo , """ ) ) ;
if (IS_ERR(map ) ) return map ; <START_VULN> bpf_map_inc(map , true ) ; <END_VULN> fdput(f ) ; return map ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : bitrate tracking and management <START_VULN> last mod : $ Id : bitrate . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_BITRATE_H_ #define _V_BITRATE_H_ #include "vorbiscodec . h" #include "codec_internal . h"
WebGLContextOptions mOptions ; PRPackedBool mInvalidated ; PRPackedBool mResetLayer ; PRPackedBool mVerbose ; PRPackedBool mOptionsFrozen ; WebGLuint mActiveTexture ; <START_VULN> WebGLenum mSynthesizedGLError ; <END_VULN> PRBool mShaderValidation ; PRInt32 mGLMaxVertexAttribs ; PRInt32 mGLMaxTextureUnits ; PRInt32 mGLMaxTextureSize ;
ut64data ; st64sdata ; ut64reference ; <START_VULN> struct str_structt { <END_VULN> char * string ; ut64offset ; } str_struct ;
unsigned long nr_segs , loff_t * poffset ) { unsigned long nr_pages , i ; <START_VULN> size_t copied , len , cur_len ; <END_VULN> ssize_t total_written = 0 ; loff_t offset ; struct iov_iter it ;
mrb_bool failed = TRUE ; mrb_get_args(mrb , "o" , & orig ) ; fptr_copy = (struct mrb_io * ) DATA_PTR(copy ) ; if (fptr_copy != NULL ) { fptr_finalize(mrb , fptr_copy , FALSE ) ; mrb_free(mrb , fptr_copy ) ; } fptr_copy = (struct mrb_io * ) mrb_io_alloc(mrb ) ; <START_VULN> fptr_orig = io_get_open_fptr(mrb , orig ) ; <END_VULN> DATA_TYPE(copy ) = & mrb_io_type ; DATA_PTR(copy ) = fptr_copy ;
static int mp_get_count(struct sb_uart_state * state , struct serial_icounter_struct * icnt ) { <START_VULN> struct serial_icounter_struct icount ; <END_VULN> struct sb_uart_icount cnow ; struct sb_uart_port * port = state -> port ;
conn -> current_result = NULL ; } while (0 ) ; <START_VULN> conn -> m -> local_tx_end(conn , this_func , result == NULL ? FAIL : PASS TSRMLS_CC ) ; <END_VULN> } DBG_RETURN(result ) ; }
int lines ; int compressed_lines ; int starting_line ; signed short line_packets ; int y_ptr ; int byte_run ; int pixel_skip ; int pixel_countdown ; unsigned char * pixels ; <START_VULN> int pixel_limit ; <END_VULN> s -> frame . reference = 1 ; s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ; if (avctx -> reget_buffer(avctx , & s -> frame ) < 0 ) { av_log(avctx , AV_LOG_ERROR , "reget_buffer( ) failed" ) ; return - 1 ; } pixels = s -> frame . data [ 0 ] ; pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] ;
if (data -> state != NULL ) { struct nfs_delegation * delegation ; <START_VULN> if (can_open_cached(data -> state , data -> o_arg . open_flags & (FMODE_READ | FMODE_WRITE | O_EXCL ) ) ) <END_VULN> goto out_no_action ; rcu_read_lock( ) ; delegation = rcu_dereference(NFS_I(data -> state -> inode ) -> delegation ) ;
keywords [ 3 ] = "password" ; values [ 3 ] = password ; keywords [ 4 ] = "dbname" ; <START_VULN> values [ 4 ] = newdb ; <END_VULN> keywords [ 5 ] = "fallback_application_name" ; values [ 5 ] = progname ; keywords [ 6 ] = NULL ;
c -> padded_bits = aligned_width - c -> avctx -> width ; if (c -> video_size < aligned_width * avctx -> height * (int64_t ) c -> bpp 8 ) return AVERROR_INVALIDDATA ; <START_VULN> if ( ! encoding && c -> palette_size && c -> bpp <= 8 ) { <END_VULN> avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; } else if (encoding == 1 && (c -> bpp == 6 || c -> bpp == 8 ) ) { if (c -> palette_size != (1 << (c -> bpp - 1 ) ) )
else ip4h . ip_off = htons(off ) ; ip4h . ip_ttl = ttl ; <START_VULN> ip4h . ip_proto = IPPROTO_ICMP ; <END_VULN> ip4h . s_ip_src . s_addr = 0x01010101 ; ip4h . s_ip_dst . s_addr = 0x02020202 ;
transport_string = estrndup(Z_STRVAL_PP(tmpzval ) , Z_STRLEN_PP(tmpzval ) ) ; } else { <START_VULN> <END_VULN> if (strpbrk(mode , "awx + " ) ) { php_stream_wrapper_log_error(wrapper , options TSRMLS_CC , "HTTP wrapper does not support writeable connections" ) ; php_url_free(resource ) ;
} <START_VULN> mpz_powm (v , v , key -> d , key -> n ) ; <END_VULN> return 0 ; }
MODULE_DESCRIPTION("Cast5 Cipher Algorithm , AVX optimized" ) ; MODULE_LICENSE("GPL" ) ; <START_VULN> MODULE_ALIAS("cast5" ) ; <END_VULN>
destroy_bio(struct bio * bio ) { pthread_cond_destroy( & bio -> bio_wait ) ; <START_VULN> <END_VULN> free(bio ) ; }
{ int error ; struct dentry * dentry = NULL , * trap ; <START_VULN> const char * old_name ; <END_VULN> trap = lock_rename(new_dir , old_dir ) ;
} else { snprintf(lbuf , llen , " % s [ name ] " , param ) ; } <START_VULN> if (s && s > filename ) { <END_VULN> register_http_post_files_variable(lbuf , s + 1 , http_post_files , 0 TSRMLS_CC ) ; } else { register_http_post_files_variable(lbuf , filename , http_post_files , 0 TSRMLS_CC ) ;
ctl_dir = container_of(head , struct ctl_dir , header ) ; if ( ! dir_emit_dots(file , ctx ) ) <START_VULN> return 0 ; <END_VULN> pos = 2 ;
int32_t i32 ; uint32_t u32 ; JSWhyMagic why ; } payload ; } s ; double asDouble ; void * asPtr ; size_t asWord ; <START_VULN> } jsval_layout ; <END_VULN> # endif #else # if JS_BITS_PER_WORD == 32 typedef union jsval_layout { uint64_t asBits ; struct { JSValueTag tag ;
const ut8 * buf_end = obuf + obuf_len ; size_t j ; <START_VULN> if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { <END_VULN> return NULL ; }
#ifndef _TYPES_INCLUDED #define _TYPES_INCLUDED #include "compilerBaseTypes . h" #include "compilerCommon . h" <START_VULN> #include "compilerdebug . h"<END_VULN> class TType ; struct TTypeLine { TType * type ; int line ; rename from gfxanglesrccompilerdebug . cpp rename to gfxanglesrccompilercompilerdebug . cpp
{ if (ftrace_event_is_function(tp_event ) && <START_VULN> perf_paranoid_kernel( ) && ! capable(CAP_SYS_ADMIN ) ) <END_VULN> return - EPERM ;
RESERVE_SPACE(8 ) ; WRITE32(OP_OPEN ) ; WRITE32(arg -> seqid -> sequence -> counter ) ; <START_VULN> encode_share_access(xdr , arg -> open_flags ) ; <END_VULN> RESERVE_SPACE(28 ) ; WRITE64(arg -> clientid ) ; WRITE32(16 ) ;
verdef -> vd_aux = READ32 (dfs , j ) verdef -> vd_next = READ32 (dfs , j ) int vdaux = verdef -> vd_aux ; <START_VULN> if (vdaux < 1 || (char * ) UINTPTR_MAX - vstart < vdaux ) { <END_VULN> sdb_free (sdb_verdef ) ; goto out_error ; }
sb_block = simple_strtoul(options , & options , 0 ) ; if ( * options && * options != ' , ' ) { <START_VULN> ext3_msg(sb , "error : invalid sb specification : % s" , <END_VULN> (char * ) * data ) ; return 1 ; }
{ MsgToEventLog(M_SYSERR , TEXT("malformed startup data : 1 byte received" ) ) ; ReturnError(pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <START_VULN> goto out ; <END_VULN> } data = malloc(bytes ) ;
void pid_ns_release_proc(struct pid_namespace * ns ) { <START_VULN> mntput(ns -> proc_mnt ) ; <END_VULN> }
return ; } <START_VULN> it = item_get(key , nkey , c , DO_UPDATE ) ; <END_VULN> if (settings . detail_enabled ) { stats_prefix_record_get(key , nkey , NULL != it ) ; }
} out_unlock : <START_VULN> sem_unlock(sma ) ; <END_VULN> out_up : up_write( & sem_ids(ns ) . rw_mutex ) ; return err ;
ma_mov(c , lr ) ; ma_str(lr , dest ) ; } BufferOffset ma_BoundsCheck(Register bounded ) { return as_cmp(bounded , Imm8(0 ) ) ; } void moveFloat32(FloatRegister src , FloatRegister dest ) { <START_VULN> as_vmov(VFPRegister(src ) . singleOverlay( ) , VFPRegister(dest ) . singleOverlay( ) ) ; <END_VULN> } #ifdef JSGC_GENERATIONAL void branchPtrInNurseryRange(Condition cond , Register ptr , Register temp , Label * label ) ; void branchValueIsNurseryObject(Condition cond , ValueOperand value , Register temp , Label * label ) ; #endif } ;
bee_t * bee = ic -> bee ; bee_user_t * bu = bee_user_by_handle(bee , ic , handle ) ; <START_VULN> if (bee -> ui -> ft_in_start ) { <END_VULN> return bee -> ui -> ft_in_start(bee , bu , file_name , file_size ) ; } else { return NULL ;
<START_VULN> { <END_VULN> long bp = _ve_envelope_search(v ) ; if(bp == - 1 ) { if(v -> eofflag == 0 ) return(0 ) ; v -> nW = 0 ; } else {
const struct xt_entry_target * t ; unsigned int verdict ; <START_VULN> if ( ! unconditional( & e -> ip ) ) <END_VULN> return false ; t = ipt_get_target_c(e ) ; if (strcmp(t -> u . user . name , XT_STANDARD_TARGET ) != 0 )
<START_VULN> static void ptrace_hbptriggered(struct perf_event * bp , int unused , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) {
if ((sess != NULL ) && (s -> enc_read_ctx != NULL ) && <START_VULN> (EVP_MD_CTX_md(s -> read_hash ) != NULL ) && ! SSL_USE_ETM(s ) ) { <END_VULN> unsigned char * mac = NULL ; unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ;
vd = & (iso9660 -> joliet ) ; <START_VULN> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <END_VULN> skipsize = __archive_read_consume(a , skipsize ) ; if (skipsize < 0 ) return ((int ) skipsize ) ;
<START_VULN> pfn = kvm_pin_pages(slot , gfn , page_size ) ; <END_VULN> if (is_error_noslot_pfn(pfn ) ) { gfn + = 1 ; continue ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : lookup based functions <START_VULN> last mod : $ Id : lookup . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_LOOKUP_H_ #ifdef FLOAT_LOOKUP extern float vorbis_coslook(float a ) ; extern float vorbis_invsqlook(float a ) ;
<START_VULN> uintdblocks = XFS_B_TO_FSB(mp , valuelen ) ; <END_VULN> nblks + = dblocks ; nblks + = XFS_NEXTENTADD_SPACE_RES(mp , dblocks , XFS_ATTR_FORK ) ; }
<START_VULN> if (sbi -> s_journal && ! handle ) <END_VULN> goto out ; err = ext4_reserve_inode_write(handle , inode , & iloc ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : floor backend 0 implementation <START_VULN> last mod : $ Id : floor0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdlib . h > #include < string . h > #include < math . h > #include < oggogg . h > #include "vorbiscodec . h"
if( ! op && ! adv ) return(1 ) ; { int size = os -> lacing_vals [ ptr ] & 0xff ; <START_VULN> int bytes = size ; <END_VULN> int eos = os -> lacing_vals [ ptr ] & 0x200 ; int bos = os -> lacing_vals [ ptr ] & 0x100 ; while(size == 255 ) { int val = os -> lacing_vals [ + + ptr ] ; size = val & 0xff ; if(val & 0x200 ) eos = 0x200 ; bytes + = size ;
long err ; int i ; <START_VULN> if (nsops < 1 ) <END_VULN> return - EINVAL ; sops = kmalloc(sizeof( * sops ) * nsops , GFP_KERNEL ) ; if ( ! sops )
} } <START_VULN> if ( ! eof ) { <END_VULN> memmove(vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ; } return SUCCESS ;
conn -> current_result = NULL ; } while (0 ) ; <START_VULN> conn -> m -> local_tx_end(conn , this_func , result == NULL ? FAIL : PASS TSRMLS_CC ) ; <END_VULN> } DBG_RETURN(result ) ;
if ( ! md -> chain [ ISAKMP_NEXT_v2E ] ) { libreswan_log("R2 state should receive an encrypted payload" ) ; <START_VULN> reset_globals( ) ; <END_VULN> return STF_FATAL ; }
#ifndef _V_LOOKUP_H_ #ifdef FLOAT_LOOKUP extern float vorbis_coslook(float a ) ; extern float vorbis_invsqlook(float a ) ; extern float vorbis_invsq2explook(int a ) ; extern float vorbis_fromdBlook(float a ) ; #endif #ifdef INT_LOOKUP extern long vorbis_invsqlook_i(long a , long e ) ; extern long vorbis_coslook_i(long a ) ; extern float vorbis_fromdBlook_i(long a ) ; <START_VULN> #endif<END_VULN> #endif
MODULE_LICENSE("GPL" ) ; MODULE_DESCRIPTION("MD5 Secure Hash Algorithm , sparc64 md5 opcode accelerated" ) ; <START_VULN> MODULE_ALIAS("md5" ) ; <END_VULN> #include "crop_devid . c"
Find pathnames matching a pattern * PHP_FUNCTION(glob ) { <START_VULN> int cwd_skip = 0 ; <END_VULN> #ifdef ZTS char cwd [ MAXPATHLEN ] ; char work_pattern [ MAXPATHLEN ] ;
* int mar_read_product_info_block(MarFile * mar , struct ProductInformationBlock * infoBlock ) { <START_VULN> int i , hasAdditionalBlocks , offset , <END_VULN> offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; char buf [ 97 ] = { '0' } ; int ret = get_mar_file_info_fp(mar -> fp , NULL , NULL , & hasAdditionalBlocks , & offsetAdditionalBlocks ,
return rv ; case FILE_USE : <START_VULN> if (nbytes < offset ) <END_VULN> return 0 ; sbuf = m -> value . s ; if ( * sbuf == ' ^ ' ) {
case htons(PPP_IPV6 ) : goto ipv6 ; default : <START_VULN> return false ; <END_VULN> } } case htons(ETH_P_TIPC ) : {
return ret ; out_release_unlock : spin_unlock(ptl ) ; <START_VULN> out_release_nounlock : <END_VULN> if (vm_shared ) unlock_page(page ) ; put_page(page ) ; goto out ; }
static int do_tkill(pid_t tgid , pid_t pid , int sig ) { <START_VULN> struct siginfo info ; <END_VULN> info . si_signo = sig ; info . si_errno = 0 ;
size_t estimate = (4 * l ) + 3 ; <START_VULN> cmd = zend_string_alloc(4 * l + 2 , 0 ) ; <END_VULN> #ifdef PHP_WIN32 ZSTR_VAL(cmd ) [ y + + ] = '"' ;
if (limit_val != - 1 ) limit_val -- ; } <START_VULN> <END_VULN> last_match = & subject [ offsets [ 1 ] ] ; next_offset = offsets [ 1 ] ;
int imap_mxcmp(const char * mx1 , const char * mx2 ) ; char * imap_next_word(char * s ) ; void imap_qualify_path(char * dest , size_t len , struct ImapMbox * mx , char * path ) ; <START_VULN> void imap_quote_string(char * dest , size_t dlen , const char * src ) ; <END_VULN> void imap_unquote_string(char * s ) ; void imap_munge_mbox_name(struct ImapData * idata , char * dest , size_t dlen , const char * src ) ; void imap_unmunge_mbox_name(struct ImapData * idata , char * s ) ;
strcmp(f -> file , "cgroup . procs" ) == 0 || strcmp(f -> file , "cgroup . procs" ) == 0 ) <START_VULN> r = do_write_pids(fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ; <END_VULN> else r = cgfs_set_value(f -> controller , f -> cgroup , f -> file , localbuf ) ;
ret = pop_query(pop_data , buf , sizeof(buf ) ) ; if (ret == 0 ) { <START_VULN> mutt_bcache_del(pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <END_VULN> #ifdef USE_HCACHE mutt_hcache_delete(hc , ctx -> hdrs [ i ] -> data , strlen(ctx -> hdrs [ i ] -> data ) ) ; #endif
static void add_bytes_l2_c(uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { long i ; <START_VULN> for (i = 0 ; i <= w - sizeof(long ) ; i + = sizeof(long ) ) { <END_VULN> long a = * (long * ) (src1 + i ) ; long b = * (long * ) (src2 + i ) ; * (long * ) (dst + i ) = ((a & pb_7f ) + (b & pb_7f ) ) ^ ((a ^ b ) & pb_80 ) ;
s -> buf_ptr = s -> buffer ; s -> buf_end = s -> buffer ; s -> line_count = 0 ; <START_VULN> s -> filesize = - 1 ; <END_VULN> cur_auth_type = s -> proxy_auth_state . auth_type ;
if (in_atomic( ) || ! mm ) goto intr_or_no_mm ; <START_VULN> perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> if ( ! down_read_trylock( & mm -> mmap_sem ) ) { if ((regs -> tstate & TSTATE_PRIV ) &&
don't need to change the reference count . * new_bh = old_bh ; get_bh(new_bh ) ; <START_VULN> ext2_xattr_cache_insert(new_bh ) ; <END_VULN> } else { ext2_fsblk_t goal = ext2_group_first_block_no(sb ,
static void CVE_2014_5163_decode_apn(tvbuff_t * tvb , int offset , guint16 length , proto_tree * tree , proto_item * item ) { guint8str [ MAX_APN_LENGTH + 1 ] ; guintcurr_len ; <START_VULN> memset(str , 0 , MAX_APN_LENGTH ) ; <END_VULN> tvb_memcpy(tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ) ; curr_len = 0 ; while ((curr_len < length ) && (curr_len < MAX_APN_LENGTH ) ) { guint step = str [ curr_len ] ; str [ curr_len ] = ' . ' ; curr_len + = step + 1 ; }
uint32_t tag = track -> tag ; if (track -> mode == MODE_MOV ) { <START_VULN> if (track -> timescale > UINT16_MAX ) { <END_VULN> if (mov_get_lpcm_flags(track -> par -> codec_id ) ) tag = AV_RL32("lpcm" ) ; version = 2 ;
else regs . flags &= ~ PERF_EFLAGS_EXACT ; <START_VULN> if (perf_event_overflow(event , 1 , & data , & regs ) ) <END_VULN> x86_pmu_stop(event , 0 ) ; }
while (nz >= 8 ) { c = (z >> (nz - 8 ) ) & 0xff ; if (jas_stream_putc(out , c ) == EOF ) { <START_VULN> return - 1 ; <END_VULN> } nz -= 8 ; z &= RAS_ONES(nz ) ;
' < session - name >= < session - id > ' to allow URLs of the form http : <START_VULN> if ( ! PS(id ) && <END_VULN> zend_hash_find( & EG(symbol_table ) , "REQUEST_URI" , sizeof("REQUEST_URI" ) , (void ** ) & data ) == SUCCESS && Z_TYPE_PP(data ) == IS_STRING &&
struct timespec tstamp ; wait_queue_head_t qchange_sleep ; struct fasync_struct * fasync ; <START_VULN> struct mutex tread_sem ; <END_VULN> } ;
proto_tree * tree ) { char * mountpoint = NULL ; if(( ! pinfo -> fd -> flags . visited ) && nfs_file_name_snooping ) { rpc_call_info_value * civ = pinfo -> private_data ; if(civ -> request && (civ -> proc == 1 ) ) { const gchar * host ; unsigned char * name ; <START_VULN> int len ; <END_VULN> unsigned char * ptr ; host = ip_to_str(pinfo -> dst . data ) ; len = tvb_get_ntohl(tvb , offset ) ; if (len >= ITEM_LABEL_LENGTH ) THROW(ReportedBoundsError ) ; name = g_malloc(strlen(host ) + 1 + len + 1 + 200 ) ; ptr = name ; memcpy(ptr , host , strlen(host ) ) ;
* #ifndef _nsCrypto_h_ #define _nsCrypto_h_ #include "nsCOMPtr . h" #include "nsIDOMCRMFObject . h" #include "nsIDOMCrypto . h" <START_VULN> #include "nsIDOMPkcs11 . h"<END_VULN> #include "nsIRunnable . h" #include "nsString . h" #include "jsapi . h" #include "nsIPrincipal . h" #define NS_CRYPTO_CLASSNAME "Crypto JavaScript Class" #define NS_CRYPTO_CID { 0x929d9320 , 0x251e , 0x11d4 , { 0x8a , 0x7c , 0x00 , 0x60 , 0x08 , 0xc8 , 0x44 , 0xc3 } }
else status = 1 ; <START_VULN> if (caught_signal ) <END_VULN> { fprintf (stderr , _("Session terminated , killing shell . . . " ) ) ; kill (child , SIGTERM ) ;
unsigned int lci , new_lci ; unsigned char cause , diagnostic ; struct net_device * dev ; <START_VULN> int len , res = 0 ; <END_VULN> char buf [ 11 ] ; #if 0
static nsresult CVE_2013_1705_cryptojs_ReadArgsAndGenerateKey(JSContext * cx , jsval * argv , nsKeyPairInfo * keyGenType , nsIInterfaceRequestor * uiCxt , PK11SlotInfo ** slot , bool willEscrow ) { JSString * jsString ; <START_VULN> JSAutoByteString params , keyGenAlg ; <END_VULN> int keySize ; nsresult rv ; if ( ! JSVAL_IS_INT(argv [ 0 ] ) ) { JS_ReportError(cx , " % s % s" , JS_ERROR , "passed in non - integer for key size" ) ; return NS_ERROR_FAILURE ; } keySize = JSVAL_TO_INT(argv [ 0 ] ) ; if ( ! JSVAL_IS_NULL(argv [ 1 ] ) ) {
{ struct NntpServer * nserv = data ; struct NntpData * nntp_data = NULL ; <START_VULN> char group [ LONG_STRING ] ; <END_VULN> char desc [ HUGE_STRING ] = "" ; char mod ; anum_t first , last ;
} for(j = first ; j < last ; j + + ) { int ret = 0 ; ve -> stretch + + ; if(ve -> stretch > VE_MAXSTRETCH * 2 ) ve -> stretch = VE_MAXSTRETCH * 2 ; <START_VULN> <END_VULN> for(i = 0 ; i < ve -> ch ; i + + ) { float * pcm = v -> pcm [ i ] + ve -> searchstep * (j ) ; ret |= _ve_amp(ve , gi , pcm , ve -> band , ve -> filter + i * VE_BANDS ) ; } ve -> mark [ j + VE_POST ] = 0 ; if(ret & 1 ) { ve -> mark [ j ] = 1 ;
unsigned int n_rdonly ; unsigned int n_wronly ; unsigned int n_rdwr ; <START_VULN> int state ; <END_VULN> atomic_t count ; } ;
if (pv -> context -> extradata == NULL ) { <START_VULN> if (pv -> parser == NULL || pv -> parser == NULL || <END_VULN> pv -> parser -> parser -> split == NULL ) { return 0 ;
bool mFullScreen ; void * mJavaView ; #endif nsPluginNativeWindow * mPluginWindow ; nsRefPtr < nsNPAPIPluginInstance > mInstance ; nsPluginFrame * mPluginFrame ; <START_VULN> nsIContent * mContent ; <END_VULN> nsCString mDocumentBase ; bool mWidgetCreationComplete ; nsCOMPtr < nsIWidget > mWidget ; nsRefPtr < nsPluginHost > mPluginHost ; #ifdef XP_MACOSX NP_CGContext mCGPluginPortCopy ; int32_t mInCGPaintLevel ;
case NCI_NFC_B_PASSIVE_POLL_MODE : nfcb_poll = & ntf - > activation_params . nfcb_poll_iso_dep ; <START_VULN> nfcb_poll - > attrib_res_len = * data ++ ; <END_VULN> pr_debug ( "attrib_res_len % d" , nfcb_poll - > attrib_res_len ) ; if ( nfcb_poll - > attrib_res_len > 0 ) { memcpy ( nfcb_poll - > attrib_res ,
void PopulateJSClass ( JSBool isGlobal ) ; void Mark ( ) { mFlags . Mark ( ) ; } void Unmark ( ) { mFlags . Unmark ( ) ; } JSBool IsMarked ( ) const { return mFlags . IsMarked ( ) ; } private : XPCNativeScriptableFlags mFlags ; <START_VULN> XPCNativeScriptableSharedJSClass mJSClass ; <END_VULN> JSBool mCanBeSlim ; } ; class XPCNativeScriptableInfo
NS_IMETHODIMP CVE_2012_3979_nsFrameMessageManager : : Dump ( const nsAString & aStr ) { #ifdef ANDROID <START_VULN> __android_log_print ( ANDROID_LOG_INFO , "Gecko" , NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) ) ; <END_VULN> #endif fputs ( NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) , stdout ) ; fflush ( stdout ) ; return NS_OK ; }
eWOFF_warn_checksum_mismatch = 0x0200 , eWOFF_warn_misaligned_table = 0x0400 , eWOFF_warn_trailing_data = 0x0800 , eWOFF_warn_unpadded_table = 0x1000 , <START_VULN> eWOFF_warn_removed_DSIG = 0x2000<END_VULN> } ; #define WOFF_SUCCESS ( status ) ( ( ( uint32_t ) ( status ) & 0xff ) == eWOFF_ok ) #define WOFF_FAILURE ( status ) ( ! WOFF_SUCCESS ( status ) )
parse_profile_level_id ( s , h264_data , value ) ; } else if ( ! strcmp ( attr , "sprop - parameter - sets" ) ) { int ret ; <START_VULN> if ( value [ strlen ( value ) - 1 ] == ' , ' ) { <END_VULN> av_log ( s , AV_LOG_WARNING , "Missing PPS in sprop - parameter - sets , ignoring" ) ; return 0 ; }
uint32_t str_key_len , base_len = p_obj - > l ; phar_entry_data * data ; php_stream * fp ; <START_VULN> php_stat_len fname_len ; <END_VULN> size_t contents_len ; char * fname , * error = NULL , * base = p_obj - > b , * save = NULL , * temp = NULL ; zend_string * opened ;
return ret ; } <START_VULN> static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events ) <END_VULN> { struct fsnotify_group * group ;
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : readelf . c , v 1 . 142 20180524 18 : 08 : 01 christos Exp $ " ) <END_VULN> #endif #ifdef BUILTIN_ELF
break ; case 0x70 . . . 0x7f : if ( test_cc ( ctxt - > b , ctxt - > eflags ) ) <START_VULN> jmp_rel ( ctxt , ctxt - > src . val ) ; <END_VULN> break ; case 0x8d : ctxt - > dst . val = ctxt - > src . addr . mem . ea ;
conn - > current_result = NULL ; } while ( 0 ) ; <START_VULN> conn - > m - > local_tx_end ( conn , this_func , result == NULL ? FAIL : PASS TSRMLS_CC ) ; <END_VULN> } DBG_RETURN ( result ) ;
case htons ( PPP_IPV6 ) : goto ipv6 ; default : <START_VULN> return false ; <END_VULN> } } case htons ( ETH_P_TIPC ) : {
<START_VULN> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <END_VULN> ff_thread_report_progress ( & h0 - > cur_pic_ptr - > tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; }
if ( likely ( vbr != NULL ) ) { svbranch = vbr - > value ; trim ( & svbranch ) ; <START_VULN> dsize + = svbranch . len ; <END_VULN> } if ( dsize < 256 ) dsize = 256 ;
nsCOMPtr < nsIPrincipal > mSystemPrincipal ; nsCOMPtr < nsIXPConnectJSObjectHolder > mLoaderGlobal ; JSRuntime * mRuntime ; JSContext * mContext ; class ModuleEntry : public mozilla : : Module { public : <START_VULN> ModuleEntry ( ) : mozilla : : Module ( ) { <END_VULN> mVersion = mozilla : : Module : : kVersion ; mCIDs = nullptr ; mContractIDs = nullptr ; mCategoryEntries = nullptr ; getFactoryProc = GetFactory ; loadProc = nullptr ; unloadProc = nullptr ;
if ( subpats != NULL ) { <START_VULN> if ( pcre_get_substring_list ( subject , offsets , count , & stringlist ) < 0 ) { <END_VULN> efree ( subpat_names ) ; efree ( offsets ) ; if ( match_sets ) efree ( match_sets ) ;
{ return 2 ; } <START_VULN> mpz_powm ( b , b , key - > e , key - > n ) ; <END_VULN> mpz_mul ( v , v , b ) ; mpz_mod ( v , v , key - > n ) ; return 0 ;
virtual void ProcessTextData ( ) ; PRBool SetTextStyle ( ) ; <START_VULN> void SetQuotes ( ) ; <END_VULN> } ; #endif
va_start ( ap , files ) ; while ( files != NULL ) { _cleanup_free_ char * path = strappend ( tmp_dir , files ) ; <START_VULN> assert_se ( touch_file ( path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) == 0 ) ; <END_VULN> files = va_arg ( ap , const char * ) ; } va_end ( ap ) ;
if ( ast_test_flag ( & p - > flags [ 1 ] , SIP_PAGE2_PREFERRED_CODEC ) ) { ast_codec_choose ( & p - > prefs , p - > jointcaps , 1 , & tmp_fmt ) ; ast_format_cap_set ( p - > jointcaps , & tmp_fmt ) ; } } if ( p - > rtp ) { <START_VULN> if ( portno > 0 ) { <END_VULN> ast_sockaddr_set_port ( sa , portno ) ; ast_rtp_instance_set_remote_address ( p - > rtp , sa ) ; if ( debug ) { ast_verbose ( "Peer audio RTP is at port % s" , ast_sockaddr_stringify ( sa ) ) ; } ast_rtp_codecs_payloads_copy ( & newaudiortp , ast_rtp_instance_get_codecs ( p - > rtp ) , p - > rtp ) ; ast_rtp_instance_set_prop ( p - > rtp , AST_RTP_PROPERTY_RTCP , 1 ) ;
goto fail ; } <START_VULN> spin_unlock_irqrestore ( & dev - > lock , flags ) ; <END_VULN>
int err ; if ( level != SOL_PPPOL2TP ) <START_VULN> return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ; <END_VULN> if ( optlen < sizeof ( int ) ) return - EINVAL ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "CRC32c ( Castagnoli ) , sparc64 crc32c opcode accelerated" ) ; <START_VULN> MODULE_ALIAS ( "crc32c" ) ; <END_VULN> #include "crop_devid . c"
file - > path = * in_path ; for ( i = 2 ; i+1 < apdu . resplen && i+1+apdu . resp [ i+1 ] < apdu . resplen ; i+ = 2+apdu . resp [ i+1 ] ) { <START_VULN> int j , len = apdu . resp [ i+1 ] ; <END_VULN> unsigned char type = apdu . resp [ i ] , * d = apdu . resp+i+2 ; switch ( type ) {
} else { fit_valueB [ ln ] = ly0 ; if ( ln == 0 ) fit_valueA [ ln ] = ly0 ; fit_valueA [ i ] = ly1 ; fit_valueB [ i ] = hy0 ; fit_valueA [ hn ] = hy1 ; if ( hn == 1 ) fit_valueB [ hn ] = hy1 ; <START_VULN> <END_VULN> if ( ly1 >= 0 || hy0 >= 0 ) { for ( j = sortpos - 1 ; j >= 0 ; j -- ) if ( hineighbor [ j ] == hn ) hineighbor [ j ] = i ; else break ; for ( j = sortpos+1 ; j < posts ; j ++ )
bool GetHitRegionRect ( Element * aElement , nsRect & aRect ) ; protected : nsresult GetImageDataArray ( JSContext * aCx , int32_t aX , int32_t aY , uint32_t aWidth , uint32_t aHeight , JSObject ** aRetval ) ; nsresult PutImageData_explicit ( int32_t x , int32_t y , uint32_t w , uint32_t h , <START_VULN> unsigned char * aData , uint32_t aDataLen , <END_VULN> bool hasDirtyRect , int32_t dirtyX , int32_t dirtyY , int32_t dirtyWidth , int32_t dirtyHeight ) ; nsresult Initialize ( int32_t width , int32_t height ) ;
return 0 ; fail : <START_VULN> spin_unlock_irqrestore ( & dev - > lock , flags ) ; <END_VULN> return ret < 0 ? ret : - EIO ; }
else ip4h . ip_off = htons ( off ) ; ip4h . ip_ttl = ttl ; <START_VULN> ip4h . ip_proto = IPPROTO_ICMP ; <END_VULN> ip4h . s_ip_src . s_addr = 0x01010101 ; ip4h . s_ip_dst . s_addr = 0x02020202 ;
} <START_VULN> sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; <END_VULN> sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ;
static struct user_namespace * user_ns ; <START_VULN> static struct mount * last_dest , * last_source , * dest_master ; <END_VULN> static struct mountpoint * mp ; static struct hlist_head * list ;
tnl_hlen = skb_tnl_header_len ( skb ) ; <START_VULN> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <END_VULN> if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; }
s + = 11 ; SKIPWS ( s ) ; ptmp = tmp ; <START_VULN> while ( isdigit ( ( unsigned char ) * s ) ) <END_VULN> * ptmp ++ = * s ++ ; * ptmp = '0' ; if ( mutt_str_atol ( tmp , & h - > content_length ) < 0 ) commit 1b0f0d0988e6df4e32e9f4bf8780846ea95d4485 Author : JerikoOne < jeriko . one@gmx . us > Date : Sat Jul 7 14 : 03 : 46 2018 - 0500 Don't overflow stack buffer in msg_parse_fetch
} offset = skb - > csum_start - skb_headroom ( skb ) ; csum = skb_checksum ( skb , offset , skb - > len - offset , 0 ) ; offset + = skb - > csum_offset ; * ( __sum16 * ) ( skb - > data + offset ) = csum_fold ( csum ) ; skb - > ip_summed = CHECKSUM_NONE ; <START_VULN> if ( ( skb_headroom ( skb ) < frag_hdr_sz ) && <END_VULN> pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header ( skb ) ;
void SetDirectionFromNewTextNode ( nsIContent * aTextNode ) ; <START_VULN> void ResetDirectionSetByTextNode ( nsTextNode * aTextNode ) ; <END_VULN> void SetDirectionalityFromValue ( mozilla : : dom : : Element * aElement , const nsAString & aValue , bool aNotify ) ;
} <START_VULN> static inline realpath_cache_bucket * realpath_cache_find ( const char * path , int path_len , time_t t ) <END_VULN> { zend_ulong key = realpath_cache_key ( path , path_len ) ; zend_ulong n = key % ( sizeof ( CWDG ( realpath_cache ) ) sizeof ( CWDG ( realpath_cache ) [ 0 ] ) ) ;
<START_VULN> if ( inet - > hdrincl ) <END_VULN> goto done ; if ( ipc . opt - > opt . srr ) { if ( ! daddr )
Com_Printf ( " -- -- - Initializing Renderer -- -- " ) ; #ifdef USE_RENDERER_DLOPEN <START_VULN> cl_renderer = Cvar_Get ( "cl_renderer" , "opengl1" , CVAR_ARCHIVE | CVAR_LATCH ) ; <END_VULN> Com_sprintf ( dllName , sizeof ( dllName ) , "renderer_sp_ % s_" ARCH_STRING DLL_EXT , cl_renderer - > string ) ;
if ( shdr - > sh_link > bin - > ehdr . e_shnum ) { return NULL ; } <START_VULN> if ( shdr - > sh_size < 1 ) { <END_VULN> return NULL ; } sdb = sdb_new0 ( ) ;
<START_VULN> struct dump_dir * dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ; <END_VULN> if ( ! dd ) { error_msg_and_die ( "Error creating problem directory ' % s'" , path ) ;
assert ( h0 - > cur_pic_ptr - > reference != DELAYED_PIC_REF ) ; <START_VULN> if ( ! last_pic_droppable && h0 - > cur_pic_ptr - > tf . owner == h0 - > avctx ) { <END_VULN> ff_thread_report_progress ( & h0 - > cur_pic_ptr - > tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ; }
int32_t i32 ; uint32_t u32 ; JSWhyMagic why ; } payload ; } s ; double asDouble ; void * asPtr ; size_t asWord ; <START_VULN> } jsval_layout ; <END_VULN> # endif #else # if JS_BITS_PER_WORD == 32 typedef union jsval_layout { uint64_t asBits ; struct { JSValueTag tag ;
static void rtc_irq_eoi_tracking_reset ( struct kvm_ioapic * ioapic ) { ioapic - > rtc_status . pending_eoi = 0 ; <START_VULN> bitmap_zero ( ioapic - > rtc_status . dest_map . map , KVM_MAX_VCPUS ) ; <END_VULN> } static void kvm_rtc_eoi_tracking_restore_all ( struct kvm_ioapic * ioapic ) ;
call_rcu_bh ( & p - > rcu , br_multicast_free_pg ) ; err = 0 ; <START_VULN> if ( ! mp - > ports && ! mp - > mglist && <END_VULN> netif_running ( br - > dev ) ) mod_timer ( & mp - > timer , jiffies ) ; break ;
extern key_ref_t search_my_process_keyrings ( struct keyring_search_context * ctx ) ; extern key_ref_t search_process_keyrings ( struct keyring_search_context * ctx ) ; <START_VULN> extern struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) ; <END_VULN> extern int install_user_keyrings ( void ) ; extern int install_thread_keyring_to_cred ( struct cred * ) ;
} for ( j = first ; j < last ; j ++ ) { int ret = 0 ; ve - > stretch ++ ; if ( ve - > stretch > VE_MAXSTRETCH * 2 ) ve - > stretch = VE_MAXSTRETCH * 2 ; <START_VULN> <END_VULN> for ( i = 0 ; i < ve - > ch ; i ++ ) { float * pcm = v - > pcm [ i ] +ve - > searchstep * ( j ) ; ret |= _ve_amp ( ve , gi , pcm , ve - > band , ve - > filter+i * VE_BANDS ) ; } ve - > mark [ j+VE_POST ] = 0 ; if ( ret & 1 ) { ve - > mark [ j ] = 1 ;
return 0 ; unmap_pages : <START_VULN> kvm_iommu_put_pages ( kvm , slot - > base_gfn , gfn ) ; <END_VULN> return r ; }
} } } <START_VULN> <END_VULN> if ( context && php_stream_context_get_option ( context , "http" , "protocol_version" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ;
{ STATE_AGGR_R0 , STATE_AGGR_R1 , SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY , P ( SA ) | P ( KE ) | P ( NONCE ) | P ( ID ) , P ( VID ) | P ( NATD_RFC ) , PT ( NONE ) , <START_VULN> EVENT_v1_RETRANSMIT , aggr_inI1_outR1 } , <END_VULN>
r = sc_read_record ( card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; SC_TEST_RET ( card - > ctx , SC_LOG_DEBUG_NORMAL , r , "read document number failed" ) ; <START_VULN> buff [ r ] = '0' ; <END_VULN> set_string ( & p15card - > tokeninfo - > serial_number , ( const char * ) buff ) ; p15card - > tokeninfo - > flags = SC_PKCS15_TOKEN_PRN_GENERATION
NULL , #else iakerb_gss_export_sec_context , <START_VULN> NULL , <END_VULN> #endif krb5_gss_inquire_cred_by_mech , krb5_gss_inquire_names_for_mech ,
} ; extern nsresult <START_VULN> NS_CreateJSTimeoutHandler ( nsIScriptContext * aContext , <END_VULN> PRBool * aIsInterval , PRInt32 * aInterval , nsIScriptTimeoutHandler ** aRet ) ;
<START_VULN> void * sys_call_table [ __NR_syscalls ] __aligned ( 4096 ) = { <END_VULN> [ 0 . . . __NR_syscalls - 1 ] = sys_ni_syscall , #include < asmunistd . h > } ;
<START_VULN> static void ptrace_hbptriggered ( struct perf_event * bp , int unused , <END_VULN> struct perf_sample_data * data , struct pt_regs * regs ) {
qsort ( sortpointer , n , sizeof ( * sortpointer ) , icomp ) ; for ( i = 0 ; i < n ; i ++ ) look - > forward_index [ i ] = sortpointer [ i ] - info - > postlist ; for ( i = 0 ; i < n ; i ++ ) look - > reverse_index [ look - > forward_index [ i ] ] = i ; for ( i = 0 ; i < n ; i ++ ) look - > sorted_index [ i ] = info - > postlist [ look - > forward_index [ i ] ] ; <START_VULN> <END_VULN> switch ( info - > mult ) { case 1 : look - > quant_q = 256 ; break ; case 2 : look - > quant_q = 128 ; break ;
void init ( JSContext * cx ) ; ~ TypeCompartment ( ) ; inline JSCompartment * compartment ( ) ; inline void addPending ( JSContext * cx , TypeConstraint * constraint , TypeSet * source , Type type ) ; <START_VULN> void growPendingArray ( JSContext * cx ) ; <END_VULN> inline void resolvePending ( JSContext * cx ) ; void print ( JSContext * cx , bool force ) ;
} if ( ntohs ( uh - > uh_dport ) == TFTP_SERVER ) { tftp_input ( m ) ; goto bad ; } so = slirp - > udp_last_so ; <START_VULN> if ( so - > so_lport != uh - > uh_sport || <END_VULN> so - > so_laddr . s_addr != ip - > ip_src . s_addr ) { struct socket * tmp ; for ( tmp = slirp - > udb . so_next ; tmp != & slirp - > udb ; tmp = tmp - > so_next ) { if ( tmp - > so_lport == uh - > uh_sport && tmp - > so_laddr . s_addr == ip - > ip_src . s_addr ) { so = tmp ; break ; }
i = 0 ; <START_VULN> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <END_VULN> i ++ ; }
if ( ( ( avail & codemask ) == 0 ) && ( avail < 4096 ) ) { codesize ++ ; codemask + = avail ; } } oldcode = incode ; do { <START_VULN> * rowp ++ = * -- stackp ; <END_VULN> if ( rowp == rowend ) OUTPUT_ROW ( ) ; } while ( stackp > stack ) ; } } END : mGIFStruct . avail = avail ;
if ( mech != NULL ) { _sx_debug ( ZONE , "auth request from client ( mechanism = % s ) " , mech ) ; <START_VULN> if ( ! gsasl_server_support_p ( ctx - > gsasl_ctx , mech ) ) { <END_VULN> _sx_debug ( ZONE , "client requested mechanism ( % s ) that we didn't offer" , mech ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INVALID_MECHANISM , NULL ) , 0 ) ; return ;
key - > expiry = prep - > expiry ; <START_VULN> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key - > flags ) ) <END_VULN> zap = dereference_key_locked ( key ) ; rcu_assign_keypointer ( key , prep - > payload . data [ 0 ] ) ; prep - > payload . data [ 0 ] = NULL ;
if ( ! ip_checkentry ( & e - > ip ) ) return - EINVAL ; <START_VULN> ret = xt_compat_check_entry_offsets ( e , <END_VULN> e - > target_offset , e - > next_offset ) ; if ( ret ) return ret ;
phar_flush ( phar_obj - > arc . archive , 0 , 0 , 0 , & error TSRMLS_CC ) ; if ( error ) { <START_VULN> zend_throw_exception_ex ( phar_ce_PharException , 0 TSRMLS_CC , error ) ; <END_VULN> efree ( error ) ; }
node = blk - > bp - > b_addr ; dp - > d_ops - > node_hdr_from_disk ( & nodehdr , node ) ; btree = dp - > d_ops - > node_tree_p ( node ) ; <START_VULN> if ( be32_to_cpu ( btree - > hashval ) == lasthash ) <END_VULN> break ; blk - > hashval = lasthash ; btree [ blk - > index ] . hashval = cpu_to_be32 ( lasthash ) ;
struct sembuf fast_sops [ SEMOPM_FAST ] ; struct sembuf * sops = fast_sops , * sop ; struct sem_undo * un ; <START_VULN> int undos = 0 , alter = 0 , max ; <END_VULN> struct sem_queue queue ; unsigned long jiffies_left = 0 ; struct ipc_namespace * ns ;
static int CVE_2006_2935_dvd_read_bca ( struct cdrom_device_info * cdi , dvd_struct * s ) { int ret ; u_char buf [ 4 + 188 ] ; struct packet_command cgc ; struct cdrom_device_ops * cdo = cdi - > ops ; init_cdrom_command ( & cgc , buf , sizeof ( buf ) , CGC_DATA_READ ) ; cgc . cmd [ 0 ] = GPCMD_READ_DVD_STRUCTURE ; cgc . cmd [ 7 ] = s - > type ; <START_VULN> cgc . cmd [ 9 ] = cgc . buflen = 0xff ; <END_VULN> if ( ( ret = cdo - > generic_packet ( cdi , & cgc ) ) ) return ret ; s - > bca . len = buf [ 0 ] << 8 | buf [ 1 ] ; if ( s - > bca . len < 12 || s - > bca . len > 188 ) { cdinfo ( CD_WARNING , "Received invalid BCA length ( % d ) " , s - > bca . len ) ; return - EIO ; } memcpy ( s - > bca . value , & buf [ 4 ] , s - > bca . len ) ;
fprintf ( fdest , " % c" , ( OPJ_UINT8 ) r ) ; if ( ( i + 1 ) % w == 0 ) { <START_VULN> for ( ( pad = w % 4 ) ? ( 4 - w % 4 ) : 0 ; pad > 0 ; pad -- ) <END_VULN> fprintf ( fdest , " % c" , 0 ) ; } }
. release = ext4_release_file , . fsync = ext4_sync_file , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> . fallocate = ext4_fallocate , } ;
if ( code == ( clear_code + 1 ) ) { return ( mGIFStruct . rows_remaining == 0 ) ; } if ( oldcode == - 1 ) { if ( code >= MAX_BITS ) return false ; <START_VULN> * rowp ++ = suffix [ code ] ; <END_VULN> if ( rowp == rowend ) OUTPUT_ROW ( ) ; firstchar = oldcode = code ; continue ; } int incode = code ; if ( code >= avail ) { * stackp ++ = firstchar ;
kfree ( entry ) ; <START_VULN> if ( pskb_expand_head ( skb_out , 0 , size - skb - > len , GFP_ATOMIC ) < 0 ) { <END_VULN> kfree_skb ( skb_out ) ; skb_out = NULL ; goto free ;
} * tail = vp ; <START_VULN> while ( * tail ) tail = & vp - > next ; <END_VULN> p + = alen ; } }
AVPacket * avpkt ) { const uint8_t * buf = avpkt - > data ; int buf_size = avpkt - > size ; const uint8_t * buf_end = buf+buf_size ; MadContext * s = avctx - > priv_data ; int width , height ; int chunk_type ; int inter ; <START_VULN> if ( buf_size < 17 ) { <END_VULN> av_log ( avctx , AV_LOG_ERROR , "Input buffer too small" ) ; * data_size = 0 ; return - 1 ; } chunk_type = AV_RL32 ( & buf [ 0 ] ) ; inter = ( chunk_type == MADm_TAG || chunk_type == MADe_TAG ) ; buf + = 8 ; av_reduce ( & avctx - > time_base . num , & avctx - > time_base . den ,
void * arm_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { <START_VULN> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <END_VULN> void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) )
atomic_dec ( & key - > user - > nkeys ) ; atomic_inc ( & newowner - > nkeys ) ; <START_VULN> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key - > flags ) ) { <END_VULN> atomic_dec ( & key - > user - > nikeys ) ; atomic_inc ( & newowner - > nikeys ) ; }
walkbuf = result + * result_len ; <START_VULN> <END_VULN> if ( eval || is_callable_replace ) {
} tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ; <START_VULN> <END_VULN> if ( snprintf ( scratch , scratch_len , "Authorization : Basic % sr" , tmp ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ;
copy_flags = CL_COPY_ALL | CL_EXPIRE ; if ( user_ns != mnt_ns - > user_ns ) <START_VULN> copy_flags |= CL_SHARED_TO_SLAVE ; <END_VULN> new = copy_tree ( old , old - > mnt . mnt_root , copy_flags ) ; if ( IS_ERR ( new ) ) { up_write ( & namespace_sem ) ;
{ ldblk = ( ssize_t ) ( ( bpp * image - > columns+7 ) 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) <START_VULN> ldblk , sizeof ( * BImgBuff ) ) ; <END_VULN> if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;
} } else #endif <START_VULN> for ( i = 0 ; i <= w - sizeof ( long ) ; i+ = sizeof ( long ) ) { <END_VULN> long a = * ( long * ) ( src1+i ) ; long b = * ( long * ) ( src2+i ) ; * ( long * ) ( dst+i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ;
&& iso9660 - > seenJoliet ) { vd = & ( iso9660 - > joliet ) ; <START_VULN> skipsize = LOGICAL_BLOCK_SIZE * vd - > location ; <END_VULN> skipsize -= iso9660 - > current_position ; skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 )
case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <START_VULN> case EXIT_REASON_INVEPT : <END_VULN>
fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr - > nexthdr = nexthdr ; fptr - > reserved = 0 ; <START_VULN> ipv6_select_ident ( fptr ) ; <END_VULN>
#include "file . h" #ifndef lint <START_VULN> FILE_RCSID ( "@ ( # ) $ File : cdf . c , v 1 . 63 20140609 13 : 04 : 37 christos Exp $ " ) <END_VULN> #endif #include < assert . h >
free ( devices ) ; devices = NULL ; } <START_VULN> return 1 ; <END_VULN> }
JSIdArray * ida ; jschar * chars , * ochars , * vsharp ; const jschar * idstrchars , * vchars ; <START_VULN> size_t nchars , idstrlength , gsoplength , vlength , vsharplength ; <END_VULN> char * comma ; jsint i , j , length , valcnt ; jsid id ;
<START_VULN> Copyright ( c ) 2000 , 2010 , Oracle andor its affiliates<END_VULN> This program is free software ; you can redistribute it andor modify it under the terms of the GNU General Public License as published by
if ( avctx - > bits_per_raw_sample == 10 || avctx - > bits_per_raw_sample == 9 ) { <START_VULN> if ( avctx - > codec_id == AV_CODEC_ID_MPEG4 && avctx - > profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <END_VULN> c - > idct_put = ff_simple_idct_put_int32_10bit ; else { c - > idct_put = ff_simple_idct_put_int16_10bit ;
if ( s - > size - stream_ptr < n_blocks * 4 ) return ; while ( n_blocks -- ) { block_ptr = row_ptr + pixel_ptr ; for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { } <START_VULN> ADVANCE_BLOCK ( ) ; <END_VULN> } break ;
MODULE_DESCRIPTION ( "Synchronous AES in CCM mode using ARMv8 Crypto Extensions" ) ; MODULE_AUTHOR ( "Ard Biesheuvel < ard . biesheuvel@linaro . org > " ) ; MODULE_LICENSE ( "GPL v2" ) ; <START_VULN> MODULE_ALIAS ( "ccm ( aes ) " ) ; <END_VULN>
{ FILE * f ; char * tmpname ; <START_VULN> f = xfmkstemp ( & tmpname , NULL ) ; <END_VULN> unlink ( tmpname ) ; free ( tmpname ) ; fclose ( f ) ;
} break ; case rsaKey : { SECItem digest ; digest . data = final ; digest . len = part ; if ( sig ) { PORT_Assert ( cx - > hashAlg != SEC_OID_UNKNOWN ) ; <START_VULN> SECOidTag hashid ; <END_VULN> rv = recoverPKCS1DigestInfo ( cx - > hashAlg , & hashid , & cx - > pkcs1RSADigestInfo , & cx - > pkcs1RSADigestInfoLen , cx - > key , sig , cx - > wincx ) ; PORT_Assert ( cx - > hashAlg == hashid ) ; if ( rv != SECSuccess ) { return SECFailure ;
tfm - > __crt_alg - > cra_type == & crypto_givcipher_type ) return crypto_init_skcipher_ops_ablkcipher ( tfm ) ; <START_VULN> skcipher - > setkey = alg - > setkey ; <END_VULN> skcipher - > encrypt = alg - > encrypt ; skcipher - > decrypt = alg - > decrypt ; skcipher - > ivsize = alg - > ivsize ;
* <START_VULN> <END_VULN> #ifndef __nss_h_ #define __nss_h_ #ifdef NSS_ENABLE_ECC #ifdef NSS_ECC_MORE_THAN_SUITE_B #define _NSS_ECC_STRING " Extended ECC"
sizeof ( _eth ) , data , hlen , & _eth ) ; if ( ! eth ) <START_VULN> return false ; <END_VULN> proto = eth - > h_proto ; nhoff + = sizeof ( * eth ) ; }
sb_block = simple_strtoul ( options , & options , 0 ) ; if ( * options && * options != ' , ' ) { <START_VULN> ext3_msg ( sb , "error : invalid sb specification : % s" , <END_VULN> ( char * ) * data ) ; return 1 ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : residue backend 0 , 1 and 2 implementation <START_VULN> last mod : $ Id : res0 . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN>
struct snd_hrtimer * stime = t - > private_data ; atomic_set ( & stime - > running , 0 ) ; <START_VULN> hrtimer_cancel ( & stime - > hrt ) ; <END_VULN> hrtimer_start ( & stime - > hrt , ns_to_ktime ( t - > sticks * resolution ) , HRTIMER_MODE_REL ) ; atomic_set ( & stime - > running , 1 ) ;
} else { mag << = bgshift ; <START_VULN> mask = ( 1 << numbps ) - 1 ; <END_VULN> most - significant bit planes introduced by ROI shifting .
} } ; <START_VULN> static OM_uint32 KRB5_CALLCONV<END_VULN> krb5_gss_inquire_sec_context_by_oid ( OM_uint32 * minor_status , const gss_ctx_id_t context_handle , const gss_OID desired_object ,
static const struct driver_info wwan_info = { . description = "Mobile Broadband Network Device" , . flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET <START_VULN> | FLAG_WWAN , <END_VULN> . bind = cdc_ncm_bind , . unbind = cdc_ncm_unbind , . manage_power = usbnet_manage_power ,
exit ( 1 ) ; } for ( i = 0 ; i < TESTSIZE ; i ++ ) if ( fabs ( qv [ i ] - iv [ i ] ) > . 000001 ) { fprintf ( stderr , "read ( % g ) != written ( % g ) at position ( % ld ) " , iv [ i ] , qv [ i ] , i ) ; exit ( 1 ) ; } <START_VULN> <END_VULN> fprintf ( stderr , "OK" ) ; ptr ++ ; } exit ( 0 ) ; }
zrtpPacket - > messageData = ( void * ) messageData ; <START_VULN> <END_VULN> zrtpPacket - > packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket - > packetString , input , inputLength ) ; }
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : * unnormalized * fft transform <START_VULN> last mod : $ Id : smallft . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < stdio . h > #include < oggogg . h > #include "vorbiscodec . h" #include "codec_internal . h" #include "registry . h"
void * ipc_rcu_alloc ( int size ) ; <START_VULN> void ipc_rcu_getref ( void * ptr ) ; <END_VULN> void ipc_rcu_putref ( void * ptr ) ; struct kern_ipc_perm * ipc_lock ( struct ipc_ids * , int ) ;
unsigned int lci , new_lci ; unsigned char cause , diagnostic ; struct net_device * dev ; <START_VULN> int len , res = 0 ; <END_VULN> char buf [ 11 ] ; #if 0
return 1 ; } mpz_init ( temp ) ; <START_VULN> mpz_powm ( r , key - > g , k , key - > p ) ; <END_VULN> mpz_mod ( r , r , key - > q ) ; mpz_invert ( s , k , key - > q ) ; mpz_mul ( temp , key - > x , r ) ;
for ( i = 0 ; i < 16 ; i ++ ) { <START_VULN> Packet * p = BuildTestPacket ( i , 0 , 1 , 'A' + i , 16 ) ; <END_VULN> if ( p == NULL ) goto end ;
} n = xmalloc ( len ) ; m = n + len - ( nlen + 1 ) ; <START_VULN> strcpy ( m , name ) ; <END_VULN> for ( p = path ; p ; p = p - > up ) { if ( p - > elem_len ) { m -= p - > elem_len + 1 ;
cli_dbgmsg ( "messageFindArgument : no ' = ' sign found in MIME header ' % s' ( % s ) " , variable , messageGetArgument ( m , i ) ) ; return NULL ; } <START_VULN> if ( ( * ++ ptr == '"' ) && ( strchr ( & ptr [ 1 ] , '"' ) != NULL ) ) { <END_VULN> char * ret = cli_strdup ( ++ ptr ) ; char * p ;
OD ( nsExtEntityLogo , SEC_OID_NS_CERT_EXT_ENTITY_LOGO , "Certificate Entity Logo" , CKM_INVALID_MECHANISM , UNSUPPORTED_CERT_EXTENSION ) , OD ( nsExtUserPicture , SEC_OID_NS_CERT_EXT_USER_PICTURE , "Certificate User Picture" , CKM_INVALID_MECHANISM , UNSUPPORTED_CERT_EXTENSION ) , OD ( nsExtSSLServerName , SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME , "Certificate SSL Server Name" , <START_VULN> CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , <END_VULN> OD ( nsExtComment , SEC_OID_NS_CERT_EXT_COMMENT , "Certificate Comment" , CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , OD ( nsExtLostPasswordURL , SEC_OID_NS_CERT_EXT_LOST_PASSWORD_URL , "Lost Password URL" , CKM_INVALID_MECHANISM , SUPPORTED_CERT_EXTENSION ) , OD ( nsExtCertRenewalTime , SEC_OID_NS_CERT_EXT_CERT_RENEWAL_TIME , "Certificate Renewal Time" ,
return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) <START_VULN> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <END_VULN> number_pixels = ( MagickSizeType ) image - > columns * image - > rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) )
if ( rc == pcmk_ok ) { rc = cib - > cmds - > set_connection_dnotify ( cib , mon_cib_connection_destroy ) ; if ( rc == - EPROTONOSUPPORT ) { <START_VULN> print_as ( "Notification setup failed , won't be able to reconnect after failure" ) ; <END_VULN> if ( as_console ) { sleep ( 2 ) ; }
if ( ! timr ) return - EINVAL ; <START_VULN> overrun = timr - > it_overrun_last ; <END_VULN> unlock_timer ( timr , flags ) ; return overrun ;
return NULL ; mutex_lock ( & mut ) ; <START_VULN> mc - > id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ; <END_VULN> mutex_unlock ( & mut ) ; if ( mc - > id < 0 ) goto error ;
break ; case 0xe9 : case 0xeb : <START_VULN> jmp_rel ( ctxt , ctxt - > src . val ) ; <END_VULN> ctxt - > dst . type = OP_NONE ; break ; case 0xf4 :
if ( ast_strlen_zero ( header_content ) ) { ast_log ( LOG_ERROR , "Could not fetch header for message number % ld" , vms - > msgArray [ vms - > curmsg ] ) ; return - 1 ; } snprintf ( todir , sizeof ( todir ) , " % s % s % stmp" , VM_SPOOL_DIR , vmu - > context , vmu - > mailbox ) ; make_gsm_file ( vms - > fn , vms - > imapuser , todir , vms - > curmsg ) ; mail_fetchstructure ( vms - > mailstream , vms - > msgArray [ vms - > curmsg ] , & body ) ; <START_VULN> if ( body - > nested . part - > next && body - > nested . part - > next - > body . parameter - > value ) { <END_VULN> attachedfilefmt = ast_strdupa ( body - > nested . part - > next - > body . parameter - > value ) ; } else { ast_log ( LOG_ERROR , "There is no file attached to this IMAP message . " ) ; return - 1 ; } strsep ( & attachedfilefmt , " . " ) ; if ( ! attachedfilefmt ) {
newExtIndex = newIndex ; } } <START_VULN> if ( newIndex < 256 ) <END_VULN> newName [ newIndex ++ ] = curr ; else needsCRC = 1 ;
#include < windows . h > #elif defined ( ANGLE_OS_POSIX ) #include < pthread . h > #include < semaphore . h > #include < errno . h > #endif <START_VULN> #include "compilerdebug . h"<END_VULN> #if defined ( ANGLE_USE_NSPR ) typedef PRUintn OS_TLSIndex ; #define OS_INVALID_TLS_INDEX 0xFFFFFFFF #elif defined ( ANGLE_OS_WIN )
struct ipcm_cookie { __be32addr ; intoif ; <START_VULN> struct ip_options * opt ; <END_VULN> __u8tx_flags ; } ;
for ( size_t i = 0 ; i < numBlocks_ ; i ++ ) blocks_ [ i ] . destroy ( ) ; js_free ( blocks_ ) ; js_delete ( previous_ ) ; } bool init ( size_t numBlocks ) { numBlocks_ = numBlocks ; <START_VULN> blocks_ = ( IonBlockCounts * ) js_calloc ( numBlocks * sizeof ( IonBlockCounts ) ) ; <END_VULN> return blocks_ != NULL ; } size_t numBlocks ( ) const { return numBlocks_ ; } IonBlockCounts & block ( size_t i ) {
ASSERT ( ( entry - > flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote ( leaf , args - > index ) ; name_rmt - > valueblk = cpu_to_be32 ( args - > rmtblkno ) ; <START_VULN> name_rmt - > valuelen = cpu_to_be32 ( args - > valuelen ) ; <END_VULN> xfs_trans_log_buf ( args - > trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ; }
attr - > size = usize ; } <START_VULN> ret = copy_to_user ( uattr , attr , usize ) ; <END_VULN> if ( ret ) return - EFAULT ;
( v - > sequence+1 != vb - > sequence ) ) { v - > granulepos = - 1 ; b - > sample_count = - 1 ; } v - > sequence = vb - > sequence ; if ( vb - > pcm ) { <END_VULN> int n = ci - > blocksizes [ v - > W ] >> ( hs+1 ) ; int n0 = ci - > blocksizes [ 0 ] >> ( hs+1 ) ; int n1 = ci - > blocksizes [ 1 ] >> ( hs+1 ) ; int thisCenter ; int prevCenter ; v - > glue_bits+ = vb - > glue_bits ;
#include < linuxinit . h > #include < linuxfs . h > #include < linuxslab . h > <START_VULN> #include < linuxmbcache . h > <END_VULN> #include < linuxquotaops . h > #include "ext4_jbd2 . h" #include "ext4 . h"
the match again at the same point . If this fails ( picked up above ) we advance to the next character . * g_notempty = ( offsets [ 1 ] == offsets [ 0 ] ) ? PCRE_NOTEMPTY | PCRE_ANCHORED : 0 ; <START_VULN> <END_VULN> start_offset = offsets [ 1 ] ; }
vlan = __skb_header_pointer ( skb , nhoff , sizeof ( _vlan ) , data , hlen , & _vlan ) ; if ( ! vlan ) <START_VULN> return false ; <END_VULN> if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_VLANID ) ) {
void pid_ns_release_proc ( struct pid_namespace * ns ) { <START_VULN> mntput ( ns - > proc_mnt ) ; <END_VULN> }
} const nsCString & ClassName ( ) const { return mImplementation ? mImplementation - > mClassName : EmptyCString ( ) ; } nsresult InitClass ( const nsCString & aClassName , JSContext * aContext , JSObject * aGlobal , JSObject * aScriptObject , <START_VULN> JSObject ** aClassObject ) ; <END_VULN> nsresult ConstructInterfaceTable ( const nsAString & aImpls ) ; void SetImplementation ( nsXBLProtoImpl * aImpl ) { mImplementation = aImpl ; } nsresult InstallImplementation ( nsXBLBinding * aBinding ) ; bool HasImplementation ( ) const { return mImplementation != nullptr ; } void AttributeChanged ( nsIAtom * aAttribute , int32_t aNameSpaceID ,
} <START_VULN> snprintf_func ( ecmd , TESTBUFSIZE , " % s % s - f % s % s % s % s % s % s % s" , <END_VULN> program_name , test_softcfg_str , has_adler32 ? "" : " - n " , has_apphead ? " - A = encode_apphead " : " - A = " ,
s - > line_count = 0 ; s - > off = 0 ; s - > icy_data_read = 0 ; <START_VULN> s - > filesize = - 1 ; <END_VULN> s - > willclose = 0 ; s - > end_chunked_post = 0 ; s - > end_header = 0 ;
} <START_VULN> if ( ! npages ) { <END_VULN> struct kvm_memory_slot * slot ; r = - ENOMEM ;
( u8 * ) & settings - > beacon . head [ ie_offset ] , settings - > beacon . head_len - ie_offset , WLAN_EID_SSID ) ; <START_VULN> if ( ! ssid_ie ) <END_VULN> return - EINVAL ; memcpy ( ssid_le . SSID , ssid_ie - > data , ssid_ie - > len ) ;
SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; if ( skb_is_err_queue ( skb ) && skb - > len && <START_VULN> ( sk - > sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <END_VULN> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb - > len , skb - > data ) ; }
} <START_VULN> if ( i > ( int ) rec - > length ) <END_VULN> {
static inline bool kvm_apic_has_events ( struct kvm_vcpu * vcpu ) { <START_VULN> return vcpu - > arch . apic - > pending_events ; <END_VULN> } static inline bool kvm_lowest_prio_delivery ( struct kvm_lapic_irq * irq )
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "SHA1 Secure Hash Algorithm ( ARM ) " ) ; <START_VULN> MODULE_ALIAS ( "sha1" ) ; <END_VULN> MODULE_AUTHOR ( "David McCullough < ucdevel@gmail . com > " ) ;
struct timespec tstamp ; wait_queue_head_t qchange_sleep ; struct fasync_struct * fasync ; <START_VULN> struct mutex tread_sem ; <END_VULN> } ;
int imap_mxcmp ( const char * mx1 , const char * mx2 ) ; char * imap_next_word ( char * s ) ; void imap_qualify_path ( char * dest , size_t len , struct ImapMbox * mx , char * path ) ; <START_VULN> void imap_quote_string ( char * dest , size_t dlen , const char * src ) ; <END_VULN> void imap_unquote_string ( char * s ) ; void imap_munge_mbox_name ( struct ImapData * idata , char * dest , size_t dlen , const char * src ) ; void imap_unmunge_mbox_name ( struct ImapData * idata , char * s ) ;
if ( error ) return error ; <START_VULN> old_name = fsnotify_oldname_init ( old_dentry - > d_name . name ) ; <END_VULN> dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ;
MODULE_DESCRIPTION ( "Cast5 Cipher Algorithm , AVX optimized" ) ; MODULE_LICENSE ( "GPL" ) ; <START_VULN> MODULE_ALIAS ( "cast5" ) ; <END_VULN>
} fname = Z_STRVAL_P ( value ) ; <START_VULN> fname_len = ( php_stat_len ) Z_STRLEN_P ( value ) ; <END_VULN> phar_spl_fileinfo : if ( base_len ) {
} len + = 128 ; buf = ( char * ) PORT_Alloc ( len ) ; if ( ! buf ) { <START_VULN> return ( 0 ) ; <END_VULN> } tmpbuf = buf ; if ( cn ) { PORT_Memcpy ( tmpbuf , cn - > data , cn - > len ) ; tmpbuf + = cn - > len ; PORT_Memcpy ( tmpbuf , BREAK , BREAKLEN ) ;
for ( j = 0 ; j < 2 ; j ++ ) band - > coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band - > coord [ 1 ] [ j ] , dy ) ; <START_VULN> band - > prec = av_malloc_array ( reslevel - > num_precincts_x * <END_VULN> ( uint64_t ) reslevel - > num_precincts_y , sizeof ( * band - > prec ) ) ; if ( ! band - > prec )
ulong flags ; TRACE2 ( ( "CVE_2009_3080_gdth_read_event ( ) handle % d" , handle ) ) ; spin_lock_irqsave ( & ha - > smp_lock , flags ) ; if ( handle == - 1 ) eindex = eoldidx ; else eindex = handle ; estr - > event_source = 0 ; <START_VULN> if ( eindex >= MAX_EVENTS ) { <END_VULN> spin_unlock_irqrestore ( & ha - > smp_lock , flags ) ; return eindex ; } e = & ebuffer [ eindex ] ; if ( e - > event_source != 0 ) { if ( eindex != elastidx ) { if ( ++ eindex == MAX_EVENTS ) eindex = 0 ; } else { eindex = - 1 ;
. preparse = dns_resolver_preparse , . free_preparse = dns_resolver_free_preparse , . instantiate = generic_key_instantiate , <START_VULN> . match = dns_resolver_match , <END_VULN> . revoke = user_revoke , . destroy = user_destroy , . describe = dns_resolver_describe ,
JSObject * argv6 = JSVAL_TO_OBJECT ( argv [ 6 ] ) ; jsval js_width , js_height , js_data ; JS_GetProperty ( cx , argv6 , "width" , & js_width ) ; JS_GetProperty ( cx , argv6 , "height" , & js_height ) ; JS_GetProperty ( cx , argv6 , "data" , & js_data ) ; if ( js_width == JSVAL_VOID || js_height == JSVAL_VOID || <START_VULN> js_data == JSVAL_VOID ) <END_VULN> { xpc_qsThrowBadArg ( cx , NS_ERROR_FAILURE , vp , 6 ) ; return JS_FALSE ; } int32_t int_width , int_height ; JSObject * obj_data = JSVAL_TO_OBJECT ( js_data ) ; if ( ! JS_ValueToECMAInt32 ( cx , js_width , & int_width ) || ! JS_ValueToECMAInt32 ( cx , js_height , & int_height ) )
if ( log_level ) { verbose ( " % d : " , insn_idx ) ; <START_VULN> print_bpf_insn ( insn ) ; <END_VULN> } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ;
if ( get_vmx_mem_address ( vcpu , exit_qualification , vmx_instruction_info , true , & gva ) ) return 1 ; <START_VULN> <END_VULN> kvm_write_guest_virt_system ( & vcpu - > arch . emulate_ctxt , gva , & field_value , ( is_long_mode ( vcpu ) ? 8 : 4 ) , NULL ) ; }
static long mem_seek ( jas_stream_obj_t * obj , long offset , int origin ) { jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; <START_VULN> long newpos ; <END_VULN> JAS_DBGLOG ( 100 , ( "mem_seek ( % p , % ld , % d ) " , obj , offset , origin ) ) ; switch ( origin ) {
#include "vmRegExpObject . h" #include "jsscopeinlines . h" namespace js { inline Bindings : : Bindings ( JSContext * cx ) <START_VULN> : lastBinding ( NULL ) , nargs ( 0 ) , nvars ( 0 ) , nupvars ( 0 ) <END_VULN> { } inline void Bindings : : transfer ( JSContext * cx , Bindings * bindings ) { JS_ASSERT ( ! lastBinding ) ; JS_ASSERT ( ! bindings - > lastBinding || ! bindings - > lastBinding - > inDictionary ( ) ) ;
count ++ ; } } loser : if ( nickname ) { PORT_Free ( nickname ) ; } <START_VULN> nickname = "" ; <END_VULN> done : if ( firstname ) { PORT_Free ( firstname ) ; } if ( org ) { PORT_Free ( org ) ; }
len -- ; int l = 0 ; <START_VULN> while ( * s && l < len ) { <END_VULN> str [ l ] = s [ l ] ; l ++ ; }
unsigned char * p ; size_t l ; int r ; <START_VULN> int ffmax , parent_len ; <END_VULN> static const struct archive_rb_tree_ops rb_ops = { isoent_cmp_node_joliet , isoent_cmp_key_joliet } ;
{ MsgToEventLog ( M_SYSERR , TEXT ( "PeekNamedPipeAsync failed" ) ) ; ReturnLastError ( pipe , L"PeekNamedPipeAsync" ) ; <START_VULN> goto out ; <END_VULN> } size = bytes sizeof ( * data ) ;
ret = gpiochip_add_data ( & gpio_dev - > gc , gpio_dev ) ; if ( ret ) <START_VULN> goto out1 ; <END_VULN> ret = gpiochip_add_pin_range ( & gpio_dev - > gc , dev_name ( & pdev - > dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : fft transform <START_VULN> last mod : $ Id : smallft . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_SMFT_H_ #define _V_SMFT_H_ #include "vorbiscodec . h"
static inline unsigned int __xfrm4_daddr_saddr_hash ( xfrm_address_t * daddr , xfrm_address_t * saddr ) { <START_VULN> return ntohl ( daddr - > a4 ^ saddr - > a4 ) ; <END_VULN> } static inline unsigned int __xfrm6_daddr_saddr_hash ( xfrm_address_t * daddr , xfrm_address_t * saddr )
s + = 11 ; SKIPWS ( s ) ; ptmp = tmp ; <START_VULN> while ( isdigit ( ( unsigned char ) * s ) ) <END_VULN> * ptmp ++ = * s ++ ; * ptmp = '0' ; if ( mutt_str_atol ( tmp , & h - > content_length ) < 0 )
* result_len = 0 ; start_offset = 0 ; PCRE_G ( error_code ) = PHP_PCRE_NO_ERROR ; <START_VULN> <END_VULN> while ( 1 ) { count = pcre_exec ( pce - > re , extra , subject , subject_len , start_offset ,
% % DefineImageProperty ( ) associates an assignment string of the form % "key = value" with an artifact or options . It is equivelent to <START_VULN> % SetImageProperty ( ) <END_VULN> % % The format of the DefineImageProperty method is : %
queue_unlock ( struct futex_q * q , struct futex_hash_bucket * hb ) { spin_unlock ( & hb - > lock ) ; <START_VULN> drop_futex_key_refs ( & q - > key ) ; <END_VULN> } ret = futex_wait_setup ( uaddr , val , fshared , & q , & hb ) ; if ( ret ) goto out ;
mrb_field_write_barrier ( mrb , ( struct RBasic * ) p , ( struct RBasic * ) p - > c ) ; clone = mrb_obj_value ( p ) ; init_copy ( mrb , clone , self ) ; <START_VULN> p - > flags = mrb_obj_ptr ( self ) - > flags ; <END_VULN> return clone ; }
WRITE32 ( OP_OPEN_DOWNGRADE ) ; WRITEMEM ( arg - > stateid - > data , NFS4_STATEID_SIZE ) ; WRITE32 ( arg - > seqid - > sequence - > counter ) ; <START_VULN> encode_share_access ( xdr , arg - > open_flags ) ; <END_VULN> return 0 ; }
<START_VULN> PHPAPI void php_stat ( const char * filename , php_stat_len filename_length , int type , zval * return_value ) <END_VULN> { zval stat_dev , stat_ino , stat_mode , stat_nlink , stat_uid , stat_gid , stat_rdev , stat_size , stat_atime , stat_mtime , stat_ctime , stat_blksize , stat_blocks ;
if ( one_entry_in_sg ) { if ( unlikely ( req - > src != req - > dst ) ) { scatterwalk_unmap ( dst ) ; scatterwalk_done ( & dst_sg_walk , 0 , 0 ) ; } scatterwalk_unmap ( src ) ; scatterwalk_unmap ( assoc ) ; scatterwalk_done ( & src_sg_walk , 0 , 0 ) ; scatterwalk_done ( & assoc_sg_walk , 0 , 0 ) ; } else { <START_VULN> scatterwalk_map_and_copy ( dst , req - > dst , 0 , req - > cryptlen , 1 ) ; <END_VULN> kfree ( src ) ; } return retval ; }
<START_VULN> if ( client - > type == USER_CLIENT ) <END_VULN> snd_seq_fifo_clear ( client - > data . user . fifo ) ; }
static int perf_swevent_init ( struct perf_event * event ) { <START_VULN> int event_id = event - > attr . config ; <END_VULN> if ( event - > attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ;
unsigned char __user * ugreen ; unsigned char __user * ublue ; struct fb_cmap * cmap = & info - > cmap ; <START_VULN> int index , count , i ; <END_VULN> u8 red , green , blue ; if ( get_user ( index , & c - > index ) ||
void ErrorInvalidEnumInfo ( const char * info , WebGLenum enumvalue ) { return ErrorInvalidEnum ( " % s : invalid enum value 0x % x" , info , enumvalue ) ; } void ErrorOutOfMemory ( const char * fmt = 0 , . . . ) ; const char * ErrorName ( GLenum error ) ; bool IsTextureFormatCompressed ( GLenum format ) ; <START_VULN> void DummyFramebufferOperation ( const char * info ) ; <END_VULN> WebGLTexture * activeBoundTextureForTarget ( WebGLenum target ) { return target == LOCAL_GL_TEXTURE_2D ? mBound2DTextures [ mActiveTexture ] : mBoundCubeMapTextures [ mActiveTexture ] ; } already_AddRefed < CanvasLayer > GetCanvasLayer ( nsDisplayListBuilder * aBuilder , CanvasLayer * aOldLayer ,
TFunctionSign3 ,
* y0 = rint ( a+b * x0 ) ; * y1 = rint ( a+b * x1 ) ; if ( * y0 > 1023 ) * y0 = 1023 ; if ( * y1 > 1023 ) * y1 = 1023 ; if ( * y0 < 0 ) * y0 = 0 ; if ( * y1 < 0 ) * y1 = 0 ; <START_VULN> <END_VULN> return 0 ; } else { * y0 = 0 ; * y1 = 0 ; return 1 ; } } }
static int CVE_2013_4516_mp_get_count ( struct sb_uart_state * state , struct serial_icounter_struct * icnt ) { <START_VULN> struct serial_icounter_struct icount ; <END_VULN> struct sb_uart_icount cnow ; struct sb_uart_port * port = state - > port ; spin_lock_irq ( & port - > lock ) ; memcpy ( & cnow , & port - > icount , sizeof ( struct sb_uart_icount ) ) ; spin_unlock_irq ( & port - > lock ) ; icount . cts = cnow . cts ; icount . dsr = cnow . dsr ; icount . rng = cnow . rng ;
size_t noff , size_t doff , int * flags ) { if ( namesz == 4 && strcmp ( ( char * ) & nbuf [ noff ] , "GNU" ) == 0 && <START_VULN> type == NT_GNU_BUILD_ID && ( descsz >= 4 || descsz <= 20 ) ) { <END_VULN> uint8_t desc [ 20 ] ; const char * btype ; uint32_t i ;
UNIXCB ( skb ) . fp = NULL ; for ( i = scm - > fp - > count - 1 ; i >= 0 ; i -- ) <START_VULN> unix_notinflight ( scm - > fp - > fp [ i ] ) ; <END_VULN> } static void unix_destruct_scm ( struct sk_buff * skb )
efree ( result ) ; } } <START_VULN> <END_VULN> zend_hash_move_forward ( Z_ARRVAL_PP ( subject ) ) ; } } else {
no_journal : if ( ext4_mballoc_ready ) { <START_VULN> sbi - > s_mb_cache = ext4_xattr_create_cache ( sb - > s_id ) ; <END_VULN> if ( ! sbi - > s_mb_cache ) { ext4_msg ( sb , KERN_ERR , "Failed to create an mb_cache" ) ; goto failed_mount_wq ;
rkey = s2s_route_key ( NULL , to - > domain , from - > domain ) ; attr = nad_find_attr ( nad , 0 , - 1 , "type" , "valid" ) ; <START_VULN> if ( attr >= 0 ) { <END_VULN> xhash_put ( in - > states , pstrdup ( xhash_pool ( in - > states ) , rkey ) , ( void * ) conn_VALID ) ; log_write ( in - > s2s - > log , LOG_NOTICE , " [ % d ] [ % s , port = % d ] incoming route ' % s' is now valid % s % s" , in - > fd - > fd , in - > ip , in - > port , rkey , ( in - > s - > flags & SX_SSL_WRAPPER ) ? " , TLS negotiated" : "" , in - > s - > compressed ? " , ZLIB compression enabled" : "" ) ; valid = 1 ;
float secs = ( float ) nvi - > rate ; amp+ = secs * gi - > ampmax_att_per_sec ; if ( amp < - 9999 ) amp = - 9999 ; return ( amp ) ; } static void couple_lossless ( float A , float B , <START_VULN> float * qA , float * qB ) { <END_VULN> int test1 = fabs ( * qA ) > fabs ( * qB ) ; test1 -= fabs ( * qA ) < fabs ( * qB ) ; if ( ! test1 ) test1 = ( ( fabs ( A ) > fabs ( B ) ) << 1 ) - 1 ; if ( test1 == 1 ) { * qB = ( * qA > 0 . f ? * qA - * qB : * qB - * qA ) ; } else { float temp = * qB ;
vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; <START_VULN> <END_VULN> snprintf ( str , sizeof ( str ) , " v % i , v % i , 0x % 08"PFMT64x , vA , vB , a - > pc + ( vC * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : lookup based functions <START_VULN> last mod : $ Id : lookup . c 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #include < math . h > #include "lookup . h" #include "lookup_data . h" #include "os . h" #include "misc . h"
* #ifndef _nsCrypto_h_ #define _nsCrypto_h_ #include "nsCOMPtr . h" #include "nsIDOMCRMFObject . h" #include "nsIDOMCrypto . h" <START_VULN> #include "nsIDOMPkcs11 . h"<END_VULN> #include "nsIRunnable . h" #include "nsString . h" #include "jsapi . h" #include "nsIPrincipal . h" #define NS_CRYPTO_CLASSNAME "Crypto JavaScript Class" #define NS_CRYPTO_CID { 0x929d9320 , 0x251e , 0x11d4 , { 0x8a , 0x7c , 0x00 , 0x60 , 0x08 , 0xc8 , 0x44 , 0xc3 } }
if ( compile_options ) { * compile_options = pce ? pce - > compile_options : 0 ; } <START_VULN> <END_VULN> return pce ? pce - > re : NULL ; }
<START_VULN> if ( ! asoc - > temp ) { <END_VULN> list_del ( & asoc - > asocs ) ;
typedef struct _dumpOptions { <START_VULN> const char * dbname ; <END_VULN> const char * pghost ; const char * pgport ; const char * username ;
SSL_TRC ( 3 , ( " % d : SSL3 [ % d ] : handle certificate_verify handshake" , SSL_GETPID ( ) , ss - > fd ) ) ; PORT_Assert ( ss - > opt . noLocks || ssl_HaveRecvBufLock ( ss ) ) ; PORT_Assert ( ss - > opt . noLocks || ssl_HaveSSL3HandshakeLock ( ss ) ) ; isTLS = ( PRBool ) ( ss - > ssl3 . prSpec - > version > SSL_LIBRARY_VERSION_3_0 ) ; isTLS12 = ( PRBool ) ( ss - > ssl3 . prSpec - > version >= SSL_LIBRARY_VERSION_TLS_1_2 ) ; <START_VULN> if ( ss - > ssl3 . hs . ws != wait_cert_verify || ss - > sec . peerCert == NULL ) { <END_VULN> desc = unexpected_message ; errCode = SSL_ERROR_RX_UNEXPECTED_CERT_VERIFY ; goto alert_loser ; } if ( isTLS12 ) { rv = ssl3_ConsumeSignatureAndHashAlgorithm ( ss , & b , & length , & sigAndHash ) ;
assert ( sizeof ( sf_count_t ) == 8 ) ; <START_VULN> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <END_VULN> { sf_errno = SFE_MALLOC_FAILED ; returnNULL ; } ;
<START_VULN> remaining = tvb_captured_length_remaining ( tvb , offset ) ; <END_VULN> if ( remaining <= 0 ) { if ( data ) * data = g_strdup ( "" ) ;
if ( test ) { fname = test ; <START_VULN> fname_len = ( php_stat_len ) strlen ( fname ) ; <END_VULN> } else { zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 , "Could not resolve file path" ) ; return ZEND_HASH_APPLY_STOP ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : lookup based functions <START_VULN> last mod : $ Id : lookup . h 13293 2007 - 07 - 24 00 : 09 : 47Z xiphmont $ <END_VULN> #ifndef _V_LOOKUP_H_ #ifdef FLOAT_LOOKUP extern float vorbis_coslook ( float a ) ; extern float vorbis_invsqlook ( float a ) ;
while ( nz >= 8 ) { c = ( z >> ( nz - 8 ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) { <START_VULN> return - 1 ; <END_VULN> } nz -= 8 ; z &= RAS_ONES ( nz ) ;
snprintf_func ( recmd , TESTBUFSIZE , " % s recode % s - f % s % s % s % s % s" , program_name , test_softcfg_str , recoded_adler32 ? "" : " - n " , <START_VULN> ! change_apphead ? "" : <END_VULN> ( recoded_apphead ? " - A = recode_apphead " : " - A = " ) , recoded_secondary ? " - S djw " : " - S none " , TEST_DELTA_FILE ,
return 0 ; zsize = ( src [ 0 ] << 8 ) | src [ 1 ] ; src + = 2 ; <START_VULN> if ( src_end - src < zsize ) <END_VULN> return AVERROR_INVALIDDATA ; ret = uncompress ( c - > kempf_buf , & dlen , src , zsize ) ;
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** function : bitrate tracking and management <START_VULN> last mod : $ Id $ <END_VULN> #ifndef _V_BITRATE_H_ #define _V_BITRATE_H_ #include "vorbiscodec . h" #include "codec_internal . h"
jsval * rval ) ; JS_REQUIRES_STACK JSRecordingStatus newString ( JSObject * ctor , uint32 argc , jsval * argv , jsval * rval ) ; JS_REQUIRES_STACK JSRecordingStatus interpretedFunctionCall ( jsval & fval , JSFunction * fun , uintN argc , bool constructing ) ; JS_REQUIRES_STACK void propagateFailureToBuiltinStatus ( nanojit : : LIns * ok_ins , nanojit : : LIns * & status_ins ) ; JS_REQUIRES_STACK JSRecordingStatus emitNativeCall ( JSSpecializedNative * sn , uintN argc , <START_VULN> nanojit : : LIns * args [ ] ) ; <END_VULN> JS_REQUIRES_STACK void emitNativePropertyOp ( JSScope * scope , JSScopeProperty * sprop , nanojit : : LIns * obj_ins , bool setflag , nanojit : : LIns * boxed_ins ) ; JS_REQUIRES_STACK JSRecordingStatus callSpecializedNative ( JSNativeTraceInfo * trcinfo , uintN argc , bool constructing ) ; JS_REQUIRES_STACK JSRecordingStatus callNative ( uintN argc , JSOp mode ) ;
value - > encoding . address = READ ( buf , ut64 ) ; break ; default : <START_VULN> eprintf ( "DWARF : Unexpected pointer size : % u" , ( unsigned ) hdr - > pointer_size ) ; <END_VULN> return NULL ; } break ;
if ( haveQuote ) { cmd ++ ; <START_VULN> p = find_eoq ( cmd + 1 ) ; <END_VULN> if ( ! p || ! * p ) { eprintf ( "Missing " in ( % s ) . " , cmd ) ; return false ;
<START_VULN> if ( tsk != current ) <END_VULN> return ; if ( MSR_TM_SUSPENDED ( mfmsr ( ) ) ) {
PHPAPI pcre * pcre_get_compiled_regex_ex ( char * regex , pcre_extra ** extra , int * preg_options , int * compile_options TSRMLS_DC ) { pcre_cache_entry * pce = pcre_get_compiled_regex_cache ( regex , strlen ( regex ) TSRMLS_CC ) ; <START_VULN> <END_VULN> if ( extra ) { * extra = pce ? pce - > extra : NULL ; }
del_timer ( & p - > timer ) ; call_rcu_bh ( & p - > rcu , br_multicast_free_pg ) ; <START_VULN> if ( ! mp - > ports && ! mp - > mglist && <END_VULN> netif_running ( br - > dev ) ) mod_timer ( & mp - > timer , jiffies ) ;
static int hns_gmac_get_sset_count ( int stringset ) { <START_VULN> if ( stringset == ETH_SS_STATS ) <END_VULN> return ARRAY_SIZE ( g_gmac_stats_string ) ; return 0 ;
oggpack_write ( opb , 1 , 1 ) ; return ( 0 ) ; err_out : return ( - 1 ) ; } int vorbis_commentheader_out ( vorbis_comment * vc , <START_VULN> ogg_packet * op ) { <END_VULN> oggpack_buffer opb ; oggpack_writeinit ( & opb ) ; if ( _vorbis_pack_comment ( & opb , vc ) ) return OV_EIMPL ; op - > packet = _ogg_malloc ( oggpack_bytes ( & opb ) ) ; memcpy ( op - > packet , opb . buffer , oggpack_bytes ( & opb ) ) ;
module_init ( ghash_mod_init ) ; module_exit ( ghash_mod_exit ) ; <START_VULN> MODULE_ALIAS ( "ghash" ) ; <END_VULN> MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "GHASH Message Digest Algorithm , s390 implementation" ) ;
. release = ext2_release_file , . fsync = ext2_fsync , . splice_read = generic_file_splice_read , <START_VULN> . splice_write = generic_file_splice_write , <END_VULN> } ; #ifdef CONFIG_EXT2_FS_XIP
} else { snprintf ( lbuf , llen , " % s [ name ] " , param ) ; } <START_VULN> if ( s && s > filename ) { <END_VULN> register_http_post_files_variable ( lbuf , s+1 , http_post_files , 0 TSRMLS_CC ) ; } else { register_http_post_files_variable ( lbuf , filename , http_post_files , 0 TSRMLS_CC ) ;
private : already_AddRefed < nsIAtom > GetNameAtom ( nsIContent * aContent ) ; void EnsureChildState ( ) ; <START_VULN> void doRemoveChild ( ) ; <END_VULN> nsString mValue ; nsIContent * mChild ; mozilla : : dom : : Element * GetContentInternal ( ) const
fit_value [ i ] = val+predicted ; fit_value [ look - > loneighbor [ i - 2 ] ] &= 0x7fff ; fit_value [ look - > hineighbor [ i - 2 ] ] &= 0x7fff ; } else { fit_value [ i ] = predicted | 0x8000 ; } <START_VULN> <END_VULN> } return ( fit_value ) ; } eop : return ( NULL ) ; }
mode_t curumsk = umask ( 022 ) ; umask ( curumsk ) ; <START_VULN> if ( fchmod ( fileno ( fp ) , 0666 - curumsk ) < 0 ) { <END_VULN> err_status = "create_chmod" ; return - 1 ; }
conn - > m - > local_tx_end ( conn , this_func , ret TSRMLS_CC ) ; } <START_VULN> DBG_RETURN ( ret ) ; <END_VULN> }
unsigned int cscov ; const char * msg ; <START_VULN> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <END_VULN> if ( dh == NULL ) { msg = "nf_ct_dccp : short packet " ; goto out_invalid ;
struct list_headlist ; struct inode * inode ; unsigned intflag ; <START_VULN> interror ; <END_VULN> loff_toffset ; ssize_tsize ; struct work_structwork ;
MODULE_LICENSE ( "GPL" ) ; MODULE_DESCRIPTION ( "Camellia Cipher Algorithm , sparc64 camellia opcode accelerated" ) ; <START_VULN> MODULE_ALIAS ( "aes" ) ; <END_VULN> #include "crop_devid . c"
* <START_VULN> <END_VULN> #include "cert . h" #include "secitem . h" #include "keyhi . h" #include "ssl . h" #include "sslimpl . h" #include "sslproto . h" #include "secoid . h" #include "pk11func . h"
__be16inet_sport ; __u16inet_id ; <START_VULN> struct ip_options * opt ; <END_VULN> __u8tos ; __u8min_ttl ; __u8mc_ttl ;
JS_STATIC_ASSERT ( sizeof ( JSValueTag ) == 4 ) ; JS_STATIC_ASSERT ( sizeof ( JSBool ) == 4 ) ; JS_STATIC_ASSERT ( sizeof ( JSWhyMagic ) <= 4 ) ; JS_STATIC_ASSERT ( sizeof ( Value ) == 8 ) ; } friend jsval_layout ( : : JSVAL_TO_IMPL ) ( Value ) ; friend Value ( : : IMPL_TO_JSVAL ) ( jsval_layout l ) ; <START_VULN> } JSVAL_ALIGNMENT ; <END_VULN> inline bool IsPoisonedValue ( const Value & v ) { if ( v . isString ( ) ) return IsPoisonedPtr ( v . toString ( ) ) ; if ( v . isObject ( ) ) return IsPoisonedPtr ( & v . toObject ( ) ) ;
hid - > version = req - > version ; hid - > country = req - > country ; <START_VULN> strncpy ( hid - > name , req - > name , 128 ) ; <END_VULN> snprintf ( hid - > phys , sizeof ( hid - > phys ) , " % pMR" , & bt_sk ( session - > ctrl_sock - > sk ) - > src ) ;
} ret = PTR_ERR ( filp ) ; out_close : <START_VULN> nfs4_close_sync ( path , state , nd - > intent . open . flags ) ; <END_VULN> return ret ; }
if ( s - > s3 - > tmp . message_type != SSL3_MT_CERTIFICATE_VERIFY ) { s - > s3 - > tmp . reuse_message = 1 ; <START_VULN> if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) ) <END_VULN> { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_MISSING_VERIFY_MESSAGE ) ;
* <START_VULN> <END_VULN> #include "lowkeyi . h" #include "secasn1 . h" #include "secder . h" #include "secoid . h" #include "blapi . h" #include "secitem . h" #include "pcert . h"
pixGetDimensions ( pix , & w , NULL , & d ) ; factor = ( l_float32 ) thumbwidth ( l_float32 ) w ; pixthumb = pixScale ( pix , factor , factor ) ; <START_VULN> sprintf ( charbuf , " % s_thumb_ % 03d" , rootname , index ) ; <END_VULN> sarrayAddString ( sathumbs , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixthumb ) ;
} update_open_stateid ( state , & data - > o_res . stateid , NULL , <START_VULN> data - > o_arg . open_flags ) ; <END_VULN> iput ( inode ) ; out : return state ;
<START_VULN> <END_VULN> #ifndef COMPILER_DEBUG_H_ #define COMPILER_DEBUG_H_ #include < assert . h > #ifdef _DEBUG #define TRACE_ENABLED
} efree ( match_sets ) ; } <START_VULN> <END_VULN> efree ( offsets ) ; efree ( subpat_names ) ;
} static int _vorbis_pack_info ( oggpack_buffer * opb , vorbis_info * vi ) { codec_setup_info * ci = vi - > codec_setup ; if ( ! ci ) return ( OV_EFAULT ) ; <START_VULN> <END_VULN> oggpack_write ( opb , 0x01 , 8 ) ; _v_writestring ( opb , "vorbis" , 6 ) ; oggpack_write ( opb , 0x00 , 32 ) ; oggpack_write ( opb , vi - > channels , 8 ) ; oggpack_write ( opb , vi - > rate , 32 ) ;
return error ; } <START_VULN> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <END_VULN> srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) {
} mark_discard_range_all ( sbi ) ; <START_VULN> f2fs_wait_discard_bios ( sbi ) ; <END_VULN> out : range - > len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ; return err ;
